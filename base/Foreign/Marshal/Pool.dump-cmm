
==================== Output Cmm ====================
2018-03-16 16:04:14.827999081 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:04:14.828618054 UTC

[section ""cstring" . Foreign.Marshal.Pool.$trModule4_bytes" {
     Foreign.Marshal.Pool.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.829203425 UTC

[section ""data" . Foreign.Marshal.Pool.$trModule3_closure" {
     Foreign.Marshal.Pool.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Pool.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.829778669 UTC

[section ""cstring" . Foreign.Marshal.Pool.$trModule2_bytes" {
     Foreign.Marshal.Pool.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,80,111,111,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.83035219 UTC

[section ""data" . Foreign.Marshal.Pool.$trModule1_closure" {
     Foreign.Marshal.Pool.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Pool.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.830927412 UTC

[section ""data" . Foreign.Marshal.Pool.$trModule_closure" {
     Foreign.Marshal.Pool.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Marshal.Pool.$trModule3_closure+1;
         const Foreign.Marshal.Pool.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.831541849 UTC

[section ""data" . $krep_r95mW_closure" {
     $krep_r95mW_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.832156122 UTC

[section ""data" . $krep1_r95mX_closure" {
     $krep1_r95mX_closure:
         const :_con_info;
         const $krep_r95mW_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.832759845 UTC

[section ""data" . $krep2_r95mY_closure" {
     $krep2_r95mY_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Ptr.$tcPtr_closure;
         const $krep1_r95mX_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.833396416 UTC

[section ""data" . $krep3_r95mZ_closure" {
     $krep3_r95mZ_closure:
         const :_con_info;
         const $krep2_r95mY_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.833953759 UTC

[section ""data" . $krep4_r95n0_closure" {
     $krep4_r95n0_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep3_r95mZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.834567379 UTC

[section ""data" . $krep5_r95n1_closure" {
     $krep5_r95n1_closure:
         const :_con_info;
         const $krep4_r95n0_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.835169718 UTC

[section ""data" . $krep6_r95n2_closure" {
     $krep6_r95n2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep5_r95n1_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.836227335 UTC

[section ""cstring" . Foreign.Marshal.Pool.$tcPool2_bytes" {
     Foreign.Marshal.Pool.$tcPool2_bytes:
         I8[] [80,111,111,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.836746796 UTC

[section ""data" . Foreign.Marshal.Pool.$tcPool1_closure" {
     Foreign.Marshal.Pool.$tcPool1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Pool.$tcPool2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.837377707 UTC

[section ""data" . Foreign.Marshal.Pool.$tcPool_closure" {
     Foreign.Marshal.Pool.$tcPool_closure:
         const GHC.Types.TyCon_con_info;
         const Foreign.Marshal.Pool.$trModule_closure+1;
         const Foreign.Marshal.Pool.$tcPool1_closure+1;
         const GHC.Types.krep$*_closure;
         const 6812857741828992361;
         const 12127662557529231519;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.837992307 UTC

[section ""data" . $krep7_r95n3_closure" {
     $krep7_r95n3_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.Marshal.Pool.$tcPool_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.838571989 UTC

[section ""data" . Foreign.Marshal.Pool.$tc'Pool1_closure" {
     Foreign.Marshal.Pool.$tc'Pool1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r95n2_closure+1;
         const $krep7_r95n3_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.839135368 UTC

[section ""cstring" . Foreign.Marshal.Pool.$tc'Pool3_bytes" {
     Foreign.Marshal.Pool.$tc'Pool3_bytes:
         I8[] [39,80,111,111,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.839670586 UTC

[section ""data" . Foreign.Marshal.Pool.$tc'Pool2_closure" {
     Foreign.Marshal.Pool.$tc'Pool2_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Pool.$tc'Pool3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.840253699 UTC

[section ""data" . Foreign.Marshal.Pool.$tc'Pool_closure" {
     Foreign.Marshal.Pool.$tc'Pool_closure:
         const GHC.Types.TyCon_con_info;
         const Foreign.Marshal.Pool.$trModule_closure+1;
         const Foreign.Marshal.Pool.$tc'Pool2_closure+1;
         const Foreign.Marshal.Pool.$tc'Pool1_closure+4;
         const 11588816997626637361;
         const 15405086111208545194;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.840874916 UTC

[section ""cstring" . lvl_r95n4_bytes" {
     lvl_r95n4_bytes:
         I8[] [112,111,105,110,116,101,114,32,110,111,116,32,105,110,32,112,111,111,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.841809381 UTC

[section ""data" . Foreign.Marshal.Pool.pooledRealloc2_closure" {
     Foreign.Marshal.Pool.pooledRealloc2_closure:
         const Foreign.Marshal.Pool.pooledRealloc2_info;
 },
 Foreign.Marshal.Pool.pooledRealloc2_entry() //  []
         { info_tbl: [(c95tg,
                       label: Foreign.Marshal.Pool.pooledRealloc2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95tg: // global
           R2 = lvl_r95n4_bytes;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.843671781 UTC

[section ""data" . Foreign.Marshal.Pool.$wpooledReallocBytes_closure" {
     Foreign.Marshal.Pool.$wpooledReallocBytes_closure:
         const Foreign.Marshal.Pool.$wpooledReallocBytes_info;
         const 0;
 },
 sat_s95nT_entry() //  [R1]
         { info_tbl: [(c95tK,
                       label: sat_s95nT_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95tK: // global
           _s95nT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c95tL; else goto c95tM;
       c95tM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95tO; else goto c95tN;
       c95tO: // global
           HpAlloc = 16;
           goto c95tL;
       c95tL: // global
           R1 = _s95nT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95tN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s95nT::P64;
           _s95nQ::P64 = P64[_s95nT::P64 + 16];
           _s95ny::I64 = I64[_s95nT::P64 + 24];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s95ny::I64;
           R4 = _s95nQ::P64;
           R3 = Hp - 7;
           R2 = GHC.Ptr.$fEqPtr_$c==_closure+2;
           Sp = Sp - 16;
           call Data.OldList.deleteBy_entry(R4,
                                            R3,
                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s95o4_entry() //  [R1]
         { info_tbl: [(c95tX,
                       label: sat_s95o4_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95tX: // global
           _s95o4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c95tY; else goto c95tZ;
       c95tZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95u1; else goto c95u0;
       c95u1: // global
           HpAlloc = 16;
           goto c95tY;
       c95tY: // global
           R1 = _s95o4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95u0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s95o4::P64;
           _s95o2::P64 = P64[_s95o4::P64 + 16];
           _s95ny::I64 = I64[_s95o4::P64 + 24];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s95ny::I64;
           R4 = _s95o2::P64;
           R3 = Hp - 7;
           R2 = GHC.Ptr.$fEqPtr_$c==_closure+2;
           Sp = Sp - 16;
           call Data.OldList.deleteBy_entry(R4,
                                            R3,
                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Pool.$wpooledReallocBytes_entry() //  [R2, R3, R4]
         { info_tbl: [(c95u6,
                       label: Foreign.Marshal.Pool.$wpooledReallocBytes_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 20} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95u6: // global
           _s95nz::I64 = R4;
           _s95ny::I64 = R3;
           _s95nx::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto c95u7; else goto c95u8;
       c95u8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95ua; else goto c95u9;
       c95ua: // global
           HpAlloc = 16;
           goto c95u7;
       c95u7: // global
           R4 = _s95nz::I64;
           R3 = _s95ny::I64;
           R2 = _s95nx::P64;
           R1 = Foreign.Marshal.Pool.$wpooledReallocBytes_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c95u9: // global
           _s95nD::P64 = P64[_s95nx::P64 + 8];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s95ny::I64;
           I64[Sp - 40] = block_c95to_info;
           R4 = _s95nD::P64;
           R3 = Hp - 7;
           R2 = GHC.Ptr.$fEqPtr_closure;
           P64[Sp - 32] = _s95nx::P64;
           I64[Sp - 24] = _s95ny::I64;
           I64[Sp - 16] = _s95nz::I64;
           P64[Sp - 8] = _s95nD::P64;
           Sp = Sp - 40;
           call GHC.List.elem_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c95to() //  [R1]
         { info_tbl: [(c95to,
                       label: block_c95to_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95to: // global
           if (R1 & 7 == 1) goto c95u3; else goto c95u4;
       c95u3: // global
           R3 = Foreign.Marshal.Pool.pooledRealloc2_closure+1;
           R2 = P64[Sp + 32];
           Sp = Sp + 40;
           call Foreign.Marshal.Error.throwIf2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c95u4: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c95uf; else goto c95ue;
       c95uf: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95ue: // global
           _s95nx::P64 = P64[Sp + 8];
           _s95ny::I64 = I64[Sp + 16];
           _s95nH::I64 = I64[Sp + 24];
           if (_s95nH::I64 != 0) goto c95uk; else goto c95ul;
       c95uk: // global
           (_s95nM::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(_s95ny::I64, _s95nH::I64);
           if (_s95nM::I64 == 0) goto c95ui; else goto c95uh;
       c95ui: // global
           Hp = Hp - 72;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c95uh: // global
           _s95nQ::P64 = P64[_s95nx::P64 + 8];
           I64[Hp - 64] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 56] = _s95nM::I64;
           I64[Hp - 48] = sat_s95nT_info;
           P64[Hp - 32] = _s95nQ::P64;
           I64[Hp - 24] = _s95ny::I64;
           I64[Hp - 16] = :_con_info;
           _c95tE::P64 = Hp - 63;
           P64[Hp - 8] = _c95tE::P64;
           P64[Hp] = Hp - 48;
           call MO_WriteBarrier();
           P64[_s95nx::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95nx::P64);
           R1 = _c95tE::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c95ul: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(_s95ny::I64);
           _s95o2::P64 = P64[_s95nx::P64 + 8];
           I64[Hp - 64] = sat_s95o4_info;
           P64[Hp - 48] = _s95o2::P64;
           I64[Hp - 40] = _s95ny::I64;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Ptr.nullPtr_closure;
           P64[Hp - 16] = Hp - 64;
           call MO_WriteBarrier();
           P64[_s95nx::P64 + 8] = Hp - 30;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95nx::P64);
           Hp = Hp - 16;
           R1 = GHC.Ptr.nullPtr_closure;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.847041719 UTC

[section ""data" . Foreign.Marshal.Pool.pooledRealloc1_closure" {
     Foreign.Marshal.Pool.pooledRealloc1_closure:
         const Foreign.Marshal.Pool.pooledRealloc1_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledRealloc1_entry() //  [R2, R3, R4]
         { info_tbl: [(c95uC,
                       label: Foreign.Marshal.Pool.pooledRealloc1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95uC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c95uL; else goto c95uM;
       c95uL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledRealloc1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c95uM: // global
           I64[Sp - 24] = block_c95uz_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u95uV; else goto c95uA;
       u95uV: // global
           call _c95uz(R1) args: 0, res: 0, upd: 0;
       c95uA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95uz() //  [R1]
         { info_tbl: [(c95uz,
                       label: block_c95uz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95uz: // global
           I64[Sp] = block_c95uF_info;
           _s95oc::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s95oc::P64;
           if (R1 & 7 != 0) goto u95uU; else goto c95uG;
       u95uU: // global
           call _c95uF(R1) args: 0, res: 0, upd: 0;
       c95uG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95uF() //  [R1]
         { info_tbl: [(c95uF,
                       label: block_c95uF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95uF: // global
           I64[Sp] = block_c95uK_info;
           _s95oe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s95oe::I64;
           if (R1 & 7 != 0) goto u95uW; else goto c95uP;
       u95uW: // global
           call _c95uK(R1) args: 0, res: 0, upd: 0;
       c95uP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95uK() //  [R1]
         { info_tbl: [(c95uK,
                       label: block_c95uK_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95uK: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Pool.$wpooledReallocBytes_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.848679612 UTC

[section ""data" . Foreign.Marshal.Pool.pooledReallocBytes_closure" {
     Foreign.Marshal.Pool.pooledReallocBytes_closure:
         const Foreign.Marshal.Pool.pooledReallocBytes_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledReallocBytes_entry() //  [R2, R3, R4]
         { info_tbl: [(c95v1,
                       label: Foreign.Marshal.Pool.pooledReallocBytes_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95v1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledRealloc1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.849475833 UTC

[section ""cstring" . lvl1_r95n5_bytes" {
     lvl1_r95n5_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.850249924 UTC

[section ""data" . lvl2_r95n6_closure" {
     lvl2_r95n6_closure:
         const lvl2_r95n6_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r95n6_entry() //  [R1]
         { info_tbl: [(c95va,
                       label: lvl2_r95n6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95va: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95vb; else goto c95vc;
       c95vb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95vc: // global
           (_c95v7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c95v7::I64 == 0) goto c95v9; else goto c95v8;
       c95v9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c95v8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c95v7::I64;
           R2 = lvl1_r95n5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.85131343 UTC

[section ""data" . lvl3_r95n7_closure" {
     lvl3_r95n7_closure:
         const lvl3_r95n7_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r95n7_entry() //  [R1]
         { info_tbl: [(c95vj,
                       label: lvl3_r95n7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95vj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95vk; else goto c95vl;
       c95vk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95vl: // global
           (_c95vg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c95vg::I64 == 0) goto c95vi; else goto c95vh;
       c95vi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c95vh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c95vg::I64;
           R2 = Foreign.Marshal.Pool.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.852933945 UTC

[section ""data" . lvl4_r95n8_closure" {
     lvl4_r95n8_closure:
         const lvl4_r95n8_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r95n8_entry() //  [R1]
         { info_tbl: [(c95vs,
                       label: lvl4_r95n8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95vs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95vt; else goto c95vu;
       c95vt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95vu: // global
           (_c95vp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c95vp::I64 == 0) goto c95vr; else goto c95vq;
       c95vr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c95vq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c95vp::I64;
           R2 = Foreign.Marshal.Pool.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.853805126 UTC

[section ""cstring" . lvl5_r95n9_bytes" {
     lvl5_r95n9_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,77,97,114,115,104,97,108,47,80,111,111,108,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.854533386 UTC

[section ""data" . lvl6_r95na_closure" {
     lvl6_r95na_closure:
         const lvl6_r95na_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r95na_entry() //  [R1]
         { info_tbl: [(c95vB,
                       label: lvl6_r95na_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95vB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95vC; else goto c95vD;
       c95vC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95vD: // global
           (_c95vy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c95vy::I64 == 0) goto c95vA; else goto c95vz;
       c95vA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c95vz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c95vy::I64;
           R2 = lvl5_r95n9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.855455239 UTC

[section ""data" . lvl7_r95nb_closure" {
     lvl7_r95nb_closure:
         const GHC.Types.I#_con_info;
         const 159;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.856018098 UTC

[section ""data" . lvl8_r95nc_closure" {
     lvl8_r95nc_closure:
         const GHC.Types.I#_con_info;
         const 26;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.856575316 UTC

[section ""data" . lvl9_r95nd_closure" {
     lvl9_r95nd_closure:
         const GHC.Types.I#_con_info;
         const 35;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.857132144 UTC

[section ""data" . lvl10_r95ne_closure" {
     lvl10_r95ne_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_r95n7_closure;
         const lvl4_r95n8_closure;
         const lvl6_r95na_closure;
         const lvl7_r95nb_closure+1;
         const lvl8_r95nc_closure+1;
         const lvl7_r95nb_closure+1;
         const lvl9_r95nd_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.857913237 UTC

[section ""data" . lvl11_r95nf_closure" {
     lvl11_r95nf_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_r95n6_closure;
         const lvl10_r95ne_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.858679811 UTC

[section ""data" . Foreign.Marshal.Pool.pooledReallocArray1_closure" {
     Foreign.Marshal.Pool.pooledReallocArray1_closure:
         const Foreign.Marshal.Pool.pooledReallocArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Pool.pooledReallocArray1_entry() //  [R1]
         { info_tbl: [(c95vK,
                       label: Foreign.Marshal.Pool.pooledReallocArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95vK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95vL; else goto c95vM;
       c95vL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95vM: // global
           (_c95vH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c95vH::I64 == 0) goto c95vJ; else goto c95vI;
       c95vJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c95vI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c95vH::I64;
           R2 = lvl11_r95nf_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.860334983 UTC

[section ""data" . Foreign.Marshal.Pool.pooledReallocArray_closure" {
     Foreign.Marshal.Pool.pooledReallocArray_closure:
         const Foreign.Marshal.Pool.pooledReallocArray_info;
         const 0;
 },
 lvl27_s95oi_entry() //  [R1]
         { info_tbl: [(c95vV,
                       label: lvl27_s95oi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95vV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c95vW; else goto c95vX;
       c95vW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95vX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Pool.pooledReallocArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s95ow_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c95w6,
                       label: sat_s95ow_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95w6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c95wk; else goto c95wl;
       c95wk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c95wl: // global
           I64[Sp - 32] = block_c95w3_info;
           _s95oi::P64 = P64[R1 + 4];
           R1 = R2;
           P64[Sp - 24] = _s95oi::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u95ww; else goto c95w4;
       u95ww: // global
           call _c95w3(R1) args: 0, res: 0, upd: 0;
       c95w4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95w3() //  [R1]
         { info_tbl: [(c95w3,
                       label: block_c95w3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95w3: // global
           I64[Sp] = block_c95w9_info;
           _s95oo::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s95oo::P64;
           if (R1 & 7 != 0) goto u95wv; else goto c95wa;
       u95wv: // global
           call _c95w9(R1) args: 0, res: 0, upd: 0;
       c95wa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95w9() //  [R1]
         { info_tbl: [(c95w9,
                       label: block_c95w9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95w9: // global
           I64[Sp] = block_c95we_info;
           _s95oq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s95oq::I64;
           if (R1 & 7 != 0) goto u95wx; else goto c95wf;
       u95wx: // global
           call _c95we(R1) args: 0, res: 0, upd: 0;
       c95wf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95we() //  [R1]
         { info_tbl: [(c95we,
                       label: block_c95we_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95we: // global
           I64[Sp] = block_c95wj_info;
           _s95os::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s95os::I64;
           if (R1 & 7 != 0) goto u95wy; else goto c95wp;
       u95wy: // global
           call _c95wj(R1) args: 0, res: 0, upd: 0;
       c95wp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95wj() //  [R1]
         { info_tbl: [(c95wj,
                       label: block_c95wj_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95wj: // global
           R4 = I64[Sp + 8] * I64[R1 + 7];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Foreign.Marshal.Pool.$wpooledReallocBytes_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Pool.pooledReallocArray_entry() //  [R2]
         { info_tbl: [(c95wz,
                       label: Foreign.Marshal.Pool.pooledReallocArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95wz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95wD; else goto c95wC;
       c95wD: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledReallocArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c95wC: // global
           I64[Hp - 32] = lvl27_s95oi_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s95ow_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.863252288 UTC

[section ""data" . Foreign.Marshal.Pool.pooledReallocArray2_closure" {
     Foreign.Marshal.Pool.pooledReallocArray2_closure:
         const Foreign.Marshal.Pool.pooledReallocArray2_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledReallocArray2_entry() //  [R2, R3, R4,
                                                       R5]
         { info_tbl: [(c95wL,
                       label: Foreign.Marshal.Pool.pooledReallocArray2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95wL: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c95wZ; else goto c95x0;
       c95wZ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledReallocArray2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c95x0: // global
           I64[Sp - 32] = block_c95wI_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u95xd; else goto c95wJ;
       u95xd: // global
           call _c95wI(R1) args: 0, res: 0, upd: 0;
       c95wJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95wI() //  [R1]
         { info_tbl: [(c95wI,
                       label: block_c95wI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95wI: // global
           I64[Sp] = block_c95wO_info;
           _s95oD::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s95oD::P64;
           if (R1 & 7 != 0) goto u95xc; else goto c95wP;
       u95xc: // global
           call _c95wO(R1) args: 0, res: 0, upd: 0;
       c95wP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95wO() //  [R1]
         { info_tbl: [(c95wO,
                       label: block_c95wO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95wO: // global
           I64[Sp] = block_c95wT_info;
           _s95oF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s95oF::I64;
           if (R1 & 7 != 0) goto u95xe; else goto c95wU;
       u95xe: // global
           call _c95wT(R1) args: 0, res: 0, upd: 0;
       c95wU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95wT() //  [R1]
         { info_tbl: [(c95wT,
                       label: block_c95wT_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95wT: // global
           I64[Sp] = block_c95wY_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Foreign.Marshal.Pool.pooledReallocArray1_closure;
           I64[Sp + 8] = I64[R1 + 7];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c95wY() //  [R1]
         { info_tbl: [(c95wY,
                       label: block_c95wY_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95wY: // global
           R4 = (I64[Sp + 8] + 1) * I64[R1 + 7];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Foreign.Marshal.Pool.$wpooledReallocBytes_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.86504273 UTC

[section ""data" . Foreign.Marshal.Pool.pooledReallocArray0_closure" {
     Foreign.Marshal.Pool.pooledReallocArray0_closure:
         const Foreign.Marshal.Pool.pooledReallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledReallocArray0_entry() //  [R2, R3, R4,
                                                       R5]
         { info_tbl: [(c95xj,
                       label: Foreign.Marshal.Pool.pooledReallocArray0_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95xj: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledReallocArray2_entry(R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.865859285 UTC

[section ""data" . lvl12_r95ng_closure" {
     lvl12_r95ng_closure:
         const GHC.Types.I#_con_info;
         const 124;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.866432351 UTC

[section ""data" . lvl13_r95nh_closure" {
     lvl13_r95nh_closure:
         const GHC.Types.I#_con_info;
         const 20;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.867041049 UTC

[section ""data" . lvl14_r95ni_closure" {
     lvl14_r95ni_closure:
         const GHC.Types.I#_con_info;
         const 29;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.867672671 UTC

[section ""data" . lvl15_r95nj_closure" {
     lvl15_r95nj_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_r95n7_closure;
         const lvl4_r95n8_closure;
         const lvl6_r95na_closure;
         const lvl12_r95ng_closure+1;
         const lvl13_r95nh_closure+1;
         const lvl12_r95ng_closure+1;
         const lvl14_r95ni_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.868297844 UTC

[section ""data" . lvl16_r95nk_closure" {
     lvl16_r95nk_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_r95n6_closure;
         const lvl15_r95nj_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.869786211 UTC

[section ""data" . Foreign.Marshal.Pool.pooledRealloc3_closure" {
     Foreign.Marshal.Pool.pooledRealloc3_closure:
         const Foreign.Marshal.Pool.pooledRealloc3_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Pool.pooledRealloc3_entry() //  [R1]
         { info_tbl: [(c95xs,
                       label: Foreign.Marshal.Pool.pooledRealloc3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95xs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95xt; else goto c95xu;
       c95xt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95xu: // global
           (_c95xp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c95xp::I64 == 0) goto c95xr; else goto c95xq;
       c95xr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c95xq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c95xp::I64;
           R2 = lvl16_r95nk_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.871075732 UTC

[section ""data" . Foreign.Marshal.Pool.pooledRealloc_closure" {
     Foreign.Marshal.Pool.pooledRealloc_closure:
         const Foreign.Marshal.Pool.pooledRealloc_info;
         const 0;
 },
 lvl27_s95oN_entry() //  [R1]
         { info_tbl: [(c95xD,
                       label: lvl27_s95oN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95xD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c95xE; else goto c95xF;
       c95xE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95xF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Pool.pooledRealloc3_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s95oR_entry() //  [R1, R2, R3]
         { info_tbl: [(c95xL,
                       label: sat_s95oR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95xL: // global
           R4 = P64[R1 + 5];
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledRealloc1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Pool.pooledRealloc_entry() //  [R2]
         { info_tbl: [(c95xO,
                       label: Foreign.Marshal.Pool.pooledRealloc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95xO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95xS; else goto c95xR;
       c95xS: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledRealloc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c95xR: // global
           I64[Hp - 32] = lvl27_s95oN_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s95oR_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.87285837 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocBytes1_closure" {
     Foreign.Marshal.Pool.pooledMallocBytes1_closure:
         const Foreign.Marshal.Pool.pooledMallocBytes1_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMallocBytes1_entry() //  [R2, R3]
         { info_tbl: [(c95y0,
                       label: Foreign.Marshal.Pool.pooledMallocBytes1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95y0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95y1; else goto c95y2;
       c95y1: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledMallocBytes1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c95y2: // global
           I64[Sp - 16] = block_c95xX_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u95yv; else goto c95xY;
       u95yv: // global
           call _c95xX(R1) args: 0, res: 0, upd: 0;
       c95xY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95xX() //  [R1]
         { info_tbl: [(c95xX,
                       label: block_c95xX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95xX: // global
           _s95oS::P64 = P64[Sp + 8];
           (_s95p1::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s95p1::I64 == 0) goto c95yp; else goto c95yl;
       c95yp: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c95yl: // global
           I64[Sp] = block_c95ye_info;
           R1 = _s95oS::P64;
           I64[Sp + 8] = _s95p1::I64;
           if (R1 & 7 != 0) goto u95yu; else goto c95yf;
       u95yu: // global
           call _c95ye(R1) args: 0, res: 0, upd: 0;
       c95yf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95ye() //  [R1]
         { info_tbl: [(c95ye,
                       label: block_c95ye_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95ye: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95yo; else goto c95yn;
       c95yo: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95yn: // global
           _s95p4::P64 = P64[R1 + 7];
           _s95p7::P64 = P64[_s95p4::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           _c95yj::P64 = Hp - 31;
           P64[Hp - 8] = _c95yj::P64;
           P64[Hp] = _s95p7::P64;
           call MO_WriteBarrier();
           P64[_s95p4::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95p4::P64);
           R1 = _c95yj::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.874565282 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocBytes_closure" {
     Foreign.Marshal.Pool.pooledMallocBytes_closure:
         const Foreign.Marshal.Pool.pooledMallocBytes_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMallocBytes_entry() //  [R2, R3]
         { info_tbl: [(c95yA,
                       label: Foreign.Marshal.Pool.pooledMallocBytes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95yA: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledMallocBytes1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.875305029 UTC

[section ""data" . lvl17_r95nl_closure" {
     lvl17_r95nl_closure:
         const GHC.Types.I#_con_info;
         const 144;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.875839325 UTC

[section ""data" . lvl18_r95nm_closure" {
     lvl18_r95nm_closure:
         const GHC.Types.I#_con_info;
         const 25;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.876392974 UTC

[section ""data" . lvl19_r95nn_closure" {
     lvl19_r95nn_closure:
         const GHC.Types.I#_con_info;
         const 34;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.876962793 UTC

[section ""data" . lvl20_r95no_closure" {
     lvl20_r95no_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_r95n7_closure;
         const lvl4_r95n8_closure;
         const lvl6_r95na_closure;
         const lvl17_r95nl_closure+1;
         const lvl18_r95nm_closure+1;
         const lvl17_r95nl_closure+1;
         const lvl19_r95nn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.877752965 UTC

[section ""data" . lvl21_r95np_closure" {
     lvl21_r95np_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_r95n6_closure;
         const lvl20_r95no_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.878495864 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocArray1_closure" {
     Foreign.Marshal.Pool.pooledMallocArray1_closure:
         const Foreign.Marshal.Pool.pooledMallocArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMallocArray1_entry() //  [R1]
         { info_tbl: [(c95yJ,
                       label: Foreign.Marshal.Pool.pooledMallocArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95yJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95yK; else goto c95yL;
       c95yK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95yL: // global
           (_c95yG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c95yG::I64 == 0) goto c95yI; else goto c95yH;
       c95yI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c95yH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c95yG::I64;
           R2 = lvl21_r95np_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.8802393 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocArray_closure" {
     Foreign.Marshal.Pool.pooledMallocArray_closure:
         const Foreign.Marshal.Pool.pooledMallocArray_info;
         const 0;
 },
 lvl27_s95pd_entry() //  [R1]
         { info_tbl: [(c95yU,
                       label: lvl27_s95pd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95yU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c95yV; else goto c95yW;
       c95yV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95yW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Pool.pooledMallocArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s95pB_entry() //  [R1, R2, R3]
         { info_tbl: [(c95z5,
                       label: sat_s95pB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95z5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c95z9; else goto c95za;
       c95z9: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c95za: // global
           I64[Sp - 24] = block_c95z2_info;
           _s95pd::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s95pd::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u95zJ; else goto c95z3;
       u95zJ: // global
           call _c95z2(R1) args: 0, res: 0, upd: 0;
       c95z3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95z2() //  [R1]
         { info_tbl: [(c95z2,
                       label: block_c95z2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95z2: // global
           I64[Sp] = block_c95z8_info;
           _s95pi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s95pi::I64;
           if (R1 & 7 != 0) goto u95zI; else goto c95zc;
       u95zI: // global
           call _c95z8(R1) args: 0, res: 0, upd: 0;
       c95zc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95z8() //  [R1]
         { info_tbl: [(c95z8,
                       label: block_c95z8_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95z8: // global
           _s95pe::P64 = P64[Sp + 16];
           (_s95pq::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[Sp + 8] * I64[R1 + 7]);
           if (_s95pq::I64 == 0) goto c95zD; else goto c95zz;
       c95zD: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c95zz: // global
           I64[Sp + 8] = block_c95zs_info;
           R1 = _s95pe::P64;
           I64[Sp + 16] = _s95pq::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u95zK; else goto c95zt;
       u95zK: // global
           call _c95zs(R1) args: 0, res: 0, upd: 0;
       c95zt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95zs() //  [R1]
         { info_tbl: [(c95zs,
                       label: block_c95zs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95zs: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95zC; else goto c95zB;
       c95zC: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95zB: // global
           _s95pt::P64 = P64[R1 + 7];
           _s95pw::P64 = P64[_s95pt::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           _c95zx::P64 = Hp - 31;
           P64[Hp - 8] = _c95zx::P64;
           P64[Hp] = _s95pw::P64;
           call MO_WriteBarrier();
           P64[_s95pt::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95pt::P64);
           R1 = _c95zx::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Pool.pooledMallocArray_entry() //  [R2]
         { info_tbl: [(c95zL,
                       label: Foreign.Marshal.Pool.pooledMallocArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95zL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95zP; else goto c95zO;
       c95zP: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledMallocArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c95zO: // global
           I64[Hp - 32] = lvl27_s95pd_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s95pB_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.883117265 UTC

[section ""data" . Foreign.Marshal.Pool.$wpooledMallocArray0_closure" {
     Foreign.Marshal.Pool.$wpooledMallocArray0_closure:
         const Foreign.Marshal.Pool.$wpooledMallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Pool.$wpooledMallocArray0_entry() //  [R2, R3, R4]
         { info_tbl: [(c95zW,
                       label: Foreign.Marshal.Pool.$wpooledMallocArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95zW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c95zX; else goto c95zY;
       c95zX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.$wpooledMallocArray0_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c95zY: // global
           I64[Sp - 24] = block_c95zU_info;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = Foreign.Marshal.Pool.pooledMallocArray1_closure;
           P64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c95zU() //  [R1]
         { info_tbl: [(c95zU,
                       label: block_c95zU_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95zU: // global
           _s95pD::P64 = P64[Sp + 8];
           (_s95pO::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc((I64[Sp + 16] + 1) * I64[R1 + 7]);
           if (_s95pO::I64 == 0) goto c95Ar; else goto c95An;
       c95Ar: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c95An: // global
           I64[Sp + 8] = block_c95Ag_info;
           R1 = _s95pD::P64;
           I64[Sp + 16] = _s95pO::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u95Aw; else goto c95Ah;
       u95Aw: // global
           call _c95Ag(R1) args: 0, res: 0, upd: 0;
       c95Ah: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Ag() //  [R1]
         { info_tbl: [(c95Ag,
                       label: block_c95Ag_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Ag: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95Aq; else goto c95Ap;
       c95Aq: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95Ap: // global
           _s95pR::P64 = P64[R1 + 7];
           _s95pU::P64 = P64[_s95pR::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           _c95Al::P64 = Hp - 31;
           P64[Hp - 8] = _c95Al::P64;
           P64[Hp] = _s95pU::P64;
           call MO_WriteBarrier();
           P64[_s95pR::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95pR::P64);
           R1 = _c95Al::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.884964747 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocArray2_closure" {
     Foreign.Marshal.Pool.pooledMallocArray2_closure:
         const Foreign.Marshal.Pool.pooledMallocArray2_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMallocArray2_entry() //  [R2, R3, R4]
         { info_tbl: [(c95AE,
                       label: Foreign.Marshal.Pool.pooledMallocArray2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95AE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c95AF; else goto c95AG;
       c95AF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledMallocArray2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c95AG: // global
           I64[Sp - 24] = block_c95AB_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u95AK; else goto c95AC;
       u95AK: // global
           call _c95AB(R1) args: 0, res: 0, upd: 0;
       c95AC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95AB() //  [R1]
         { info_tbl: [(c95AB,
                       label: block_c95AB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95AB: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Pool.$wpooledMallocArray0_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.887060254 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocArray0_closure" {
     Foreign.Marshal.Pool.pooledMallocArray0_closure:
         const Foreign.Marshal.Pool.pooledMallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMallocArray0_entry() //  [R2, R3, R4]
         { info_tbl: [(c95AP,
                       label: Foreign.Marshal.Pool.pooledMallocArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95AP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledMallocArray2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.887811024 UTC

[section ""data" . lvl22_r95nq_closure" {
     lvl22_r95nq_closure:
         const GHC.Types.I#_con_info;
         const 106;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.888364512 UTC

[section ""data" . lvl23_r95nr_closure" {
     lvl23_r95nr_closure:
         const GHC.Types.I#_con_info;
         const 19;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.888920634 UTC

[section ""data" . lvl24_r95ns_closure" {
     lvl24_r95ns_closure:
         const GHC.Types.I#_con_info;
         const 28;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.889505686 UTC

[section ""data" . lvl25_r95nt_closure" {
     lvl25_r95nt_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_r95n7_closure;
         const lvl4_r95n8_closure;
         const lvl6_r95na_closure;
         const lvl22_r95nq_closure+1;
         const lvl23_r95nr_closure+1;
         const lvl22_r95nq_closure+1;
         const lvl24_r95ns_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.89010739 UTC

[section ""data" . lvl26_r95nu_closure" {
     lvl26_r95nu_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_r95n6_closure;
         const lvl25_r95nt_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.890839202 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMalloc1_closure" {
     Foreign.Marshal.Pool.pooledMalloc1_closure:
         const Foreign.Marshal.Pool.pooledMalloc1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMalloc1_entry() //  [R1]
         { info_tbl: [(c95AY,
                       label: Foreign.Marshal.Pool.pooledMalloc1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95AY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95AZ; else goto c95B0;
       c95AZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95B0: // global
           (_c95AV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c95AV::I64 == 0) goto c95AX; else goto c95AW;
       c95AX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c95AW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c95AV::I64;
           R2 = lvl26_r95nu_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.892542646 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMalloc_closure" {
     Foreign.Marshal.Pool.pooledMalloc_closure:
         const Foreign.Marshal.Pool.pooledMalloc_info;
         const 0;
 },
 lvl27_s95q6_entry() //  [R1]
         { info_tbl: [(c95B9,
                       label: lvl27_s95q6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95B9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c95Ba; else goto c95Bb;
       c95Ba: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95Bb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Pool.pooledMalloc1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s95qq_entry() //  [R1, R2]
         { info_tbl: [(c95Bk,
                       label: sat_s95qq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Bk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95Bl; else goto c95Bm;
       c95Bl: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c95Bm: // global
           I64[Sp - 16] = block_c95Bh_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u95BP; else goto c95Bi;
       u95BP: // global
           call _c95Bh(R1) args: 0, res: 0, upd: 0;
       c95Bi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Bh() //  [R1]
         { info_tbl: [(c95Bh,
                       label: block_c95Bh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Bh: // global
           _s95q7::P64 = P64[Sp + 8];
           (_s95qf::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s95qf::I64 == 0) goto c95BJ; else goto c95BF;
       c95BJ: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c95BF: // global
           I64[Sp] = block_c95By_info;
           R1 = _s95q7::P64;
           I64[Sp + 8] = _s95qf::I64;
           if (R1 & 7 != 0) goto u95BO; else goto c95Bz;
       u95BO: // global
           call _c95By(R1) args: 0, res: 0, upd: 0;
       c95Bz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95By() //  [R1]
         { info_tbl: [(c95By,
                       label: block_c95By_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95By: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95BI; else goto c95BH;
       c95BI: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95BH: // global
           _s95qi::P64 = P64[R1 + 7];
           _s95ql::P64 = P64[_s95qi::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           _c95BD::P64 = Hp - 31;
           P64[Hp - 8] = _c95BD::P64;
           P64[Hp] = _s95ql::P64;
           call MO_WriteBarrier();
           P64[_s95qi::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95qi::P64);
           R1 = _c95BD::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Pool.pooledMalloc_entry() //  [R2]
         { info_tbl: [(c95BQ,
                       label: Foreign.Marshal.Pool.pooledMalloc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95BQ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95BU; else goto c95BT;
       c95BU: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledMalloc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c95BT: // global
           I64[Hp - 32] = lvl27_s95q6_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s95qq_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.895320614 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNewArray2_closure" {
     Foreign.Marshal.Pool.pooledNewArray2_closure:
         const Foreign.Marshal.Pool.pooledNewArray2_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNewArray2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c95C1,
                       label: Foreign.Marshal.Pool.pooledNewArray2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95C1: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c95C5; else goto c95C6;
       c95C5: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledNewArray2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c95C6: // global
           I64[Sp - 40] = block_c95BZ_info;
           _s95qs::P64 = R3;
           R3 = 0;
           _s95qr::P64 = R2;
           R2 = R5;
           P64[Sp - 32] = _s95qr::P64;
           P64[Sp - 24] = _s95qs::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c95BZ() //  [R1]
         { info_tbl: [(c95BZ,
                       label: block_c95BZ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95BZ: // global
           I64[Sp - 8] = block_c95C4_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = Foreign.Marshal.Pool.pooledMallocArray1_closure;
           I64[Sp] = R1;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c95C4() //  [R1]
         { info_tbl: [(c95C4,
                       label: block_c95C4_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95C4: // global
           _s95qs::P64 = P64[Sp + 24];
           (_s95qF::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc((I64[Sp + 8] + 1) * I64[R1 + 7]);
           if (_s95qF::I64 == 0) goto c95CI; else goto c95CC;
       c95CI: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c95CC: // global
           I64[Sp + 8] = block_c95Cq_info;
           R1 = _s95qs::P64;
           I64[Sp + 24] = _s95qF::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u95CJ; else goto c95Cr;
       u95CJ: // global
           call _c95Cq(R1) args: 0, res: 0, upd: 0;
       c95Cr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Cq() //  [R1]
         { info_tbl: [(c95Cq,
                       label: block_c95Cq_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Cq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95CF; else goto c95CE;
       c95CF: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95CE: // global
           _s95qI::P64 = P64[R1 + 7];
           _s95qL::P64 = P64[_s95qI::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           _c95Cv::P64 = Hp - 31;
           P64[Hp - 8] = _c95Cv::P64;
           P64[Hp] = _s95qL::P64;
           _s95qr::P64 = P64[Sp + 8];
           _s95qt::P64 = P64[Sp + 24];
           _s95qu::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_s95qI::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95qI::P64);
           I64[Sp + 24] = block_c95CA_info;
           R5 = _s95qu::P64;
           R4 = _c95Cv::P64;
           R3 = _s95qt::P64;
           R2 = _s95qr::P64;
           P64[Sp + 32] = _c95Cv::P64;
           Sp = Sp + 24;
           call Foreign.Marshal.Array.newArray4_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c95CA() //  []
         { info_tbl: [(c95CA,
                       label: block_c95CA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95CA: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.897457239 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNewArray0_closure" {
     Foreign.Marshal.Pool.pooledNewArray0_closure:
         const Foreign.Marshal.Pool.pooledNewArray0_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNewArray0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c95CO,
                       label: Foreign.Marshal.Pool.pooledNewArray0_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95CO: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledNewArray2_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.898855083 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNewArray1_closure" {
     Foreign.Marshal.Pool.pooledNewArray1_closure:
         const Foreign.Marshal.Pool.pooledNewArray1_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNewArray1_entry() //  [R2, R3, R4]
         { info_tbl: [(c95CX,
                       label: Foreign.Marshal.Pool.pooledNewArray1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95CX: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c95D1; else goto c95D2;
       c95D1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledNewArray1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c95D2: // global
           I64[Sp - 32] = block_c95CV_info;
           _s95qU::P64 = R3;
           R3 = 0;
           _s95qT::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _s95qT::P64;
           P64[Sp - 16] = _s95qU::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c95CV() //  [R1]
         { info_tbl: [(c95CV,
                       label: block_c95CV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95CV: // global
           I64[Sp - 8] = block_c95D0_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = Foreign.Marshal.Pool.pooledMallocArray1_closure;
           I64[Sp] = R1;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c95D0() //  [R1]
         { info_tbl: [(c95D0,
                       label: block_c95D0_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95D0: // global
           _s95qU::P64 = P64[Sp + 24];
           (_s95r5::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[Sp + 8] * I64[R1 + 7]);
           if (_s95r5::I64 == 0) goto c95DB; else goto c95Dv;
       c95DB: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c95Dv: // global
           I64[Sp + 8] = block_c95Dj_info;
           R1 = _s95qU::P64;
           I64[Sp + 24] = _s95r5::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u95DC; else goto c95Dk;
       u95DC: // global
           call _c95Dj(R1) args: 0, res: 0, upd: 0;
       c95Dk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Dj() //  [R1]
         { info_tbl: [(c95Dj,
                       label: block_c95Dj_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Dj: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95Dy; else goto c95Dx;
       c95Dy: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95Dx: // global
           _s95r8::P64 = P64[R1 + 7];
           _s95rb::P64 = P64[_s95r8::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           _c95Do::P64 = Hp - 31;
           P64[Hp - 8] = _c95Do::P64;
           P64[Hp] = _s95rb::P64;
           _s95qT::P64 = P64[Sp + 8];
           _s95qV::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_s95r8::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95r8::P64);
           I64[Sp + 16] = block_c95Dt_info;
           R4 = _s95qV::P64;
           R3 = _c95Do::P64;
           R2 = _s95qT::P64;
           P64[Sp + 24] = _c95Do::P64;
           Sp = Sp + 16;
           call Foreign.Marshal.Array.newArray2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c95Dt() //  []
         { info_tbl: [(c95Dt,
                       label: block_c95Dt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Dt: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.901023994 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNewArray_closure" {
     Foreign.Marshal.Pool.pooledNewArray_closure:
         const Foreign.Marshal.Pool.pooledNewArray_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNewArray_entry() //  [R2, R3, R4]
         { info_tbl: [(c95DH,
                       label: Foreign.Marshal.Pool.pooledNewArray_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95DH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledNewArray1_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.902368935 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNew1_closure" {
     Foreign.Marshal.Pool.pooledNew1_closure:
         const Foreign.Marshal.Pool.pooledNew1_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNew1_entry() //  [R2, R3, R4]
         { info_tbl: [(c95DQ,
                       label: Foreign.Marshal.Pool.pooledNew1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95DQ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c95DR; else goto c95DS;
       c95DR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledNew1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c95DS: // global
           I64[Sp - 32] = block_c95DO_info;
           _s95rj::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = Foreign.Marshal.Pool.pooledMalloc1_closure;
           P64[Sp - 24] = _s95rj::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 48;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c95DO() //  [R1]
         { info_tbl: [(c95DO,
                       label: block_c95DO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95DO: // global
           _s95rk::P64 = P64[Sp + 16];
           (_s95rt::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s95rt::I64 == 0) goto c95Em; else goto c95Eg;
       c95Em: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c95Eg: // global
           I64[Sp] = block_c95E4_info;
           R1 = _s95rk::P64;
           I64[Sp + 16] = _s95rt::I64;
           if (R1 & 7 != 0) goto u95En; else goto c95E5;
       u95En: // global
           call _c95E4(R1) args: 0, res: 0, upd: 0;
       c95E5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95E4() //  [R1]
         { info_tbl: [(c95E4,
                       label: block_c95E4_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95E4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95Ej; else goto c95Ei;
       c95Ej: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95Ei: // global
           _s95rw::P64 = P64[R1 + 7];
           _s95rz::P64 = P64[_s95rw::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           _c95E9::P64 = Hp - 31;
           P64[Hp - 8] = _c95E9::P64;
           P64[Hp] = _s95rz::P64;
           _s95rj::P64 = P64[Sp + 8];
           _s95rl::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_s95rw::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95rw::P64);
           I64[Sp + 16] = block_c95Ee_info;
           R2 = _s95rj::P64;
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _c95E9::P64;
           P64[Sp + 8] = _s95rl::P64;
           P64[Sp + 24] = _c95E9::P64;
           Sp = Sp - 8;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c95Ee() //  []
         { info_tbl: [(c95Ee,
                       label: block_c95Ee_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Ee: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.904999549 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNew_closure" {
     Foreign.Marshal.Pool.pooledNew_closure:
         const Foreign.Marshal.Pool.pooledNew_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNew_entry() //  [R2, R3, R4]
         { info_tbl: [(c95Es,
                       label: Foreign.Marshal.Pool.pooledNew_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Es: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledNew1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.906288436 UTC

[section ""data" . Foreign.Marshal.Pool.freePool2_closure" {
     Foreign.Marshal.Pool.freePool2_closure:
         const Foreign.Marshal.Pool.freePool2_info;
 },
 Foreign.Marshal.Pool.freePool2_entry() //  [R2]
         { info_tbl: [(c95EG,
                       label: Foreign.Marshal.Pool.freePool2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95EG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95EH; else goto u95EX;
       c95EH: // global
           R2 = R2;
           R1 = Foreign.Marshal.Pool.freePool2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u95EX: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c95Ew() args: 0, res: 0, upd: 0;
     }
 },
 _c95Ew() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Ew: // global
           _s95rH::P64 = P64[Sp];
           I64[Sp] = block_c95Ez_info;
           R1 = _s95rH::P64;
           if (R1 & 7 != 0) goto u95EZ; else goto c95EA;
       u95EZ: // global
           call _c95Ez(R1) args: 0, res: 0, upd: 0;
       c95EA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Ez() //  [R1]
         { info_tbl: [(c95Ez,
                       label: block_c95Ez_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Ez: // global
           if (R1 & 7 == 1) goto c95ED; else goto c95EE;
       c95ED: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c95EE: // global
           I64[Sp - 8] = block_c95EO_info;
           _s95rL::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s95rL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u95F0; else goto c95EQ;
       u95F0: // global
           call _c95EO(R1) args: 0, res: 0, upd: 0;
       c95EQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95EO() //  [R1]
         { info_tbl: [(c95EO,
                       label: block_c95EO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95EO: // global
           _s95rL::P64 = P64[Sp + 8];
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[R1 + 7]);
           P64[Sp + 8] = _s95rL::P64;
           Sp = Sp + 8;
           call _c95Ew() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.90780154 UTC

[section ""data" . Foreign.Marshal.Pool.freePool1_closure" {
     Foreign.Marshal.Pool.freePool1_closure:
         const Foreign.Marshal.Pool.freePool1_info;
 },
 Foreign.Marshal.Pool.freePool1_entry() //  [R2]
         { info_tbl: [(c95Fa,
                       label: Foreign.Marshal.Pool.freePool1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Fa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c95Fb; else goto c95Fc;
       c95Fb: // global
           R2 = R2;
           R1 = Foreign.Marshal.Pool.freePool1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c95Fc: // global
           I64[Sp - 8] = block_c95F7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u95Fg; else goto c95F8;
       u95Fg: // global
           call _c95F7(R1) args: 0, res: 0, upd: 0;
       c95F8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95F7() //  [R1]
         { info_tbl: [(c95F7,
                       label: block_c95F7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95F7: // global
           R2 = P64[P64[R1 + 7] + 8];
           Sp = Sp + 8;
           call Foreign.Marshal.Pool.freePool2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.908826823 UTC

[section ""data" . Foreign.Marshal.Pool.freePool_closure" {
     Foreign.Marshal.Pool.freePool_closure:
         const Foreign.Marshal.Pool.freePool_info;
 },
 Foreign.Marshal.Pool.freePool_entry() //  [R2]
         { info_tbl: [(c95Fl,
                       label: Foreign.Marshal.Pool.freePool_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Fl: // global
           R2 = R2;
           call Foreign.Marshal.Pool.freePool1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.909734307 UTC

[section ""data" . Foreign.Marshal.Pool.newPool1_closure" {
     Foreign.Marshal.Pool.newPool1_closure:
         const Foreign.Marshal.Pool.newPool1_info;
 },
 Foreign.Marshal.Pool.newPool1_entry() //  []
         { info_tbl: [(c95Fv,
                       label: Foreign.Marshal.Pool.newPool1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Fv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c95Fw; else goto c95Fx;
       c95Fw: // global
           R1 = Foreign.Marshal.Pool.newPool1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c95Fx: // global
           I64[Sp - 8] = block_c95Fs_info;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Fs() //  [R1]
         { info_tbl: [(c95Fs,
                       label: block_c95Fs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Fs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95FA; else goto c95Fz;
       c95FA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95Fz: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.910816647 UTC

[section ""data" . Foreign.Marshal.Pool.newPool_closure" {
     Foreign.Marshal.Pool.newPool_closure:
         const Foreign.Marshal.Pool.newPool_info;
 },
 Foreign.Marshal.Pool.newPool_entry() //  []
         { info_tbl: [(c95FF,
                       label: Foreign.Marshal.Pool.newPool_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95FF: // global
           call Foreign.Marshal.Pool.newPool1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.913980884 UTC

[section ""data" . Foreign.Marshal.Pool.withPool1_closure" {
     Foreign.Marshal.Pool.withPool1_closure:
         const Foreign.Marshal.Pool.withPool1_info;
 },
 sat_s95sf_entry() //  [R1]
         { info_tbl: [(c95G0,
                       label: sat_s95sf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95G0: // global
           _s95sf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c95G1; else goto c95G2;
       c95G2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95G4; else goto c95G3;
       c95G4: // global
           HpAlloc = 16;
           goto c95G1;
       c95G1: // global
           R1 = _s95sf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95G3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s95sf::P64;
           _s95s3::P64 = P64[_s95sf::P64 + 16];
           _s95sd::P64 = P64[_s95sf::P64 + 24];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _s95sd::P64;
           R2 = Hp - 7;
           R1 = _s95s3::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s95st_entry() //  [R1]
         { info_tbl: [(c95Go,
                       label: sat_s95st_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Go: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c95Gp; else goto c95Gq;
       c95Gp: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c95Gq: // global
           _s95so::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp - 24] = block_c95Gm_info;
           R2 = _s95so::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 24;
           call Foreign.Marshal.Pool.freePool2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c95Gm() //  []
         { info_tbl: [(c95Gm,
                       label: block_c95Gm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Gm: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95su_entry() //  [R1, R2]
         { info_tbl: [(c95Gs,
                       label: sat_s95su_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Gs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95Gt; else goto c95Gu;
       c95Gt: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c95Gu: // global
           I64[Sp - 16] = block_c95Gc_info;
           _s95sd::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _s95sd::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u95Gy; else goto c95Gd;
       u95Gy: // global
           call _c95Gc(R1) args: 0, res: 0, upd: 0;
       c95Gd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Gc() //  [R1]
         { info_tbl: [(c95Gc,
                       label: block_c95Gc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Gc: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c95Gx; else goto c95Gw;
       c95Gx: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95Gw: // global
           _s95sj::P64 = P64[R1 + 7];
           _s95sk::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_s95st_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _s95sj::P64;
           P64[Hp] = _s95sk::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95sF_entry() //  [R2]
         { info_tbl: [(c95GG,
                       label: sat_s95sF_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95GG: // global
           R1 = R2;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95sZ_entry() //  [R1]
         { info_tbl: [(c95H8,
                       label: sat_s95sZ_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95H8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c95H9; else goto c95Ha;
       c95H9: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c95Ha: // global
           _s95sU::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp - 24] = block_c95H6_info;
           R2 = _s95sU::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 24;
           call Foreign.Marshal.Pool.freePool2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c95H6() //  []
         { info_tbl: [(c95H6,
                       label: block_c95H6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95H6: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95t0_entry() //  [R1, R2]
         { info_tbl: [(c95Hc,
                       label: sat_s95t0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Hc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95Hd; else goto c95He;
       c95Hd: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c95He: // global
           I64[Sp - 16] = block_c95GW_info;
           _s95sJ::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _s95sJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u95Hi; else goto c95GX;
       u95Hi: // global
           call _c95GW(R1) args: 0, res: 0, upd: 0;
       c95GX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95GW() //  [R1]
         { info_tbl: [(c95GW,
                       label: block_c95GW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95GW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c95Hh; else goto c95Hg;
       c95Hh: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95Hg: // global
           _s95sP::P64 = P64[R1 + 7];
           _s95sQ::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_s95sZ_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _s95sP::P64;
           P64[Hp] = _s95sQ::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95sL_entry() //  [R1]
         { info_tbl: [(c95Ho,
                       label: sat_s95sL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Ho: // global
           _s95sL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c95Hp; else goto c95Hq;
       c95Hq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95Hs; else goto c95Hr;
       c95Hs: // global
           HpAlloc = 16;
           goto c95Hp;
       c95Hp: // global
           R1 = _s95sL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95Hr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s95sL::P64;
           _s95s3::P64 = P64[_s95sL::P64 + 16];
           _s95sJ::P64 = P64[_s95sL::P64 + 24];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _s95sJ::P64;
           R2 = Hp - 7;
           R1 = _s95s3::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s95sM_entry() //  [R1]
         { info_tbl: [(c95Hy,
                       label: sat_s95sM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Hy: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95ta_entry() //  [R1]
         { info_tbl: [(c95HF,
                       label: sat_s95ta_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95HF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95HG; else goto c95HH;
       c95HG: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c95HH: // global
           I64[Sp - 16] = block_c95GP_info;
           _s95s3::P64 = P64[R1 + 7];
           R1 = GHC.Types.[]_closure+1;
           P64[Sp - 8] = _s95s3::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95GP() //  [R1]
         { info_tbl: [(c95GP,
                       label: block_c95GP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95GP: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c95HK; else goto c95HJ;
       c95HK: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95HJ: // global
           I64[Hp - 56] = sat_s95t0_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = sat_s95sL_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s95sM_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c95HB_info;
           R2 = Hp - 55;
           _s95sJ::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _s95sJ::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95HB() //  [R1]
         { info_tbl: [(c95HB,
                       label: block_c95HB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95HB: // global
           _s95t6::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = block_c95HD_info;
           R2 = _s95t6::P64;
           P64[Sp + 8] = R1;
           call Foreign.Marshal.Pool.freePool2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c95HD() //  []
         { info_tbl: [(c95HD,
                       label: block_c95HD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95HD: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95tb_entry() //  [R2]
         { info_tbl: [(c95HT,
                       label: sat_s95tb_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95HT: // global
           R1 = R2;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Pool.withPool1_entry() //  [R2]
         { info_tbl: [(c95I0,
                       label: Foreign.Marshal.Pool.withPool1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95I0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c95I1; else goto c95I2;
       c95I1: // global
           R2 = R2;
           R1 = Foreign.Marshal.Pool.withPool1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c95I2: // global
           I64[Sp - 16] = block_c95FM_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c95FM() //  [R1]
         { info_tbl: [(c95FM,
                       label: block_c95FM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95FM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95I5; else goto c95I4;
       c95I5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c95I4: // global
           if (R1 == 0) goto c95HY; else goto u95Ij;
       c95HY: // global
           I64[Hp - 8] = sat_s95ta_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       u95Ij: // global
           if (R1 == 1) goto c95HZ; else goto c95HX;
       c95HZ: // global
           I64[Hp - 8] = sat_s95tb_info;
           _s95s9::P64 = Hp - 6;
           goto s95s8;
       c95HX: // global
           I64[Hp - 8] = sat_s95sF_info;
           _s95s9::P64 = Hp - 6;
           goto s95s8;
       s95s8: // global
           I64[Sp - 8] = block_c95FT_info;
           R1 = GHC.Types.[]_closure+1;
           P64[Sp] = _s95s9::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95FT() //  [R1]
         { info_tbl: [(c95FT,
                       label: block_c95FT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95FT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c95Ic; else goto c95Ib;
       c95Ic: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95Ib: // global
           I64[Hp - 24] = sat_s95sf_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           _s95s9::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c95G5_info;
           R2 = Hp - 24;
           _s95sd::P64 = R1;
           R1 = _s95s9::P64;
           P64[Sp + 16] = _s95sd::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95G5() //  [R1]
         { info_tbl: [(c95G5,
                       label: block_c95G5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95G5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95If; else goto c95Ie;
       c95If: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95Ie: // global
           I64[Hp - 8] = sat_s95su_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_c95I6_info;
           R2 = Hp - 7;
           R1 = R1;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95I6() //  [R1]
         { info_tbl: [(c95I6,
                       label: block_c95I6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95I6: // global
           _s95sA::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = block_c95I8_info;
           R2 = _s95sA::P64;
           P64[Sp + 8] = R1;
           call Foreign.Marshal.Pool.freePool2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c95I8() //  []
         { info_tbl: [(c95I8,
                       label: block_c95I8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95I8: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.9200869 UTC

[section ""data" . Foreign.Marshal.Pool.withPool_closure" {
     Foreign.Marshal.Pool.withPool_closure:
         const Foreign.Marshal.Pool.withPool_info;
 },
 Foreign.Marshal.Pool.withPool_entry() //  [R2]
         { info_tbl: [(c95Io,
                       label: Foreign.Marshal.Pool.withPool_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Io: // global
           R2 = R2;
           call Foreign.Marshal.Pool.withPool1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.920795761 UTC

[section ""relreadonly" . S95uu_srt" {
     S95uu_srt:
         const Foreign.Marshal.Error.throwIf2_closure;
         const Foreign.Marshal.Alloc.realloc2_closure;
         const Foreign.Marshal.Pool.$wpooledReallocBytes_closure;
         const Foreign.Marshal.Pool.pooledRealloc1_closure;
         const GHC.Err.undefined_closure;
         const lvl11_r95nf_closure;
         const Foreign.Marshal.Pool.pooledReallocArray1_closure;
         const Foreign.Marshal.Pool.pooledReallocArray_closure;
         const Foreign.Marshal.Pool.pooledReallocArray2_closure;
         const lvl16_r95nk_closure;
         const Foreign.Marshal.Pool.pooledRealloc3_closure;
         const Foreign.Marshal.Pool.pooledRealloc_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Pool.pooledMallocBytes1_closure;
         const lvl21_r95np_closure;
         const Foreign.Marshal.Pool.pooledMallocArray1_closure;
         const Foreign.Marshal.Pool.pooledMallocArray_closure;
         const Foreign.Marshal.Pool.$wpooledMallocArray0_closure;
         const Foreign.Marshal.Pool.pooledMallocArray2_closure;
         const lvl26_r95nu_closure;
         const Foreign.Marshal.Pool.pooledMalloc1_closure;
         const Foreign.Marshal.Pool.pooledMalloc_closure;
         const Foreign.Marshal.Pool.pooledNewArray2_closure;
         const Foreign.Marshal.Pool.pooledNewArray1_closure;
         const Foreign.Marshal.Pool.pooledNew1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.922218183 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:04:14.922710752 UTC

[section ""cstring" . Foreign.Marshal.Pool.$trModule4_bytes" {
     Foreign.Marshal.Pool.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.923255745 UTC

[section ""data" . Foreign.Marshal.Pool.$trModule3_closure" {
     Foreign.Marshal.Pool.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Pool.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.923781632 UTC

[section ""cstring" . Foreign.Marshal.Pool.$trModule2_bytes" {
     Foreign.Marshal.Pool.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,80,111,111,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.924248316 UTC

[section ""data" . Foreign.Marshal.Pool.$trModule1_closure" {
     Foreign.Marshal.Pool.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Pool.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.924743876 UTC

[section ""data" . Foreign.Marshal.Pool.$trModule_closure" {
     Foreign.Marshal.Pool.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Marshal.Pool.$trModule3_closure+1;
         const Foreign.Marshal.Pool.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.92547692 UTC

[section ""data" . $krep_r95mW_closure" {
     $krep_r95mW_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.926047646 UTC

[section ""data" . $krep1_r95mX_closure" {
     $krep1_r95mX_closure:
         const :_con_info;
         const $krep_r95mW_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.926563093 UTC

[section ""data" . $krep2_r95mY_closure" {
     $krep2_r95mY_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Ptr.$tcPtr_closure;
         const $krep1_r95mX_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.927188705 UTC

[section ""data" . $krep3_r95mZ_closure" {
     $krep3_r95mZ_closure:
         const :_con_info;
         const $krep2_r95mY_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.927739497 UTC

[section ""data" . $krep4_r95n0_closure" {
     $krep4_r95n0_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep3_r95mZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.928334853 UTC

[section ""data" . $krep5_r95n1_closure" {
     $krep5_r95n1_closure:
         const :_con_info;
         const $krep4_r95n0_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.92889822 UTC

[section ""data" . $krep6_r95n2_closure" {
     $krep6_r95n2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep5_r95n1_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.929480978 UTC

[section ""cstring" . Foreign.Marshal.Pool.$tcPool2_bytes" {
     Foreign.Marshal.Pool.$tcPool2_bytes:
         I8[] [80,111,111,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.930041787 UTC

[section ""data" . Foreign.Marshal.Pool.$tcPool1_closure" {
     Foreign.Marshal.Pool.$tcPool1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Pool.$tcPool2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.930626187 UTC

[section ""data" . Foreign.Marshal.Pool.$tcPool_closure" {
     Foreign.Marshal.Pool.$tcPool_closure:
         const GHC.Types.TyCon_con_info;
         const Foreign.Marshal.Pool.$trModule_closure+1;
         const Foreign.Marshal.Pool.$tcPool1_closure+1;
         const GHC.Types.krep$*_closure;
         const 6812857741828992361;
         const 12127662557529231519;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.931241466 UTC

[section ""data" . $krep7_r95n3_closure" {
     $krep7_r95n3_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.Marshal.Pool.$tcPool_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.931826959 UTC

[section ""data" . Foreign.Marshal.Pool.$tc'Pool1_closure" {
     Foreign.Marshal.Pool.$tc'Pool1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r95n2_closure+1;
         const $krep7_r95n3_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.932431451 UTC

[section ""cstring" . Foreign.Marshal.Pool.$tc'Pool3_bytes" {
     Foreign.Marshal.Pool.$tc'Pool3_bytes:
         I8[] [39,80,111,111,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.932991117 UTC

[section ""data" . Foreign.Marshal.Pool.$tc'Pool2_closure" {
     Foreign.Marshal.Pool.$tc'Pool2_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Pool.$tc'Pool3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.933588069 UTC

[section ""data" . Foreign.Marshal.Pool.$tc'Pool_closure" {
     Foreign.Marshal.Pool.$tc'Pool_closure:
         const GHC.Types.TyCon_con_info;
         const Foreign.Marshal.Pool.$trModule_closure+1;
         const Foreign.Marshal.Pool.$tc'Pool2_closure+1;
         const Foreign.Marshal.Pool.$tc'Pool1_closure+4;
         const 11588816997626637361;
         const 15405086111208545194;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.934222162 UTC

[section ""cstring" . lvl_r95n4_bytes" {
     lvl_r95n4_bytes:
         I8[] [112,111,105,110,116,101,114,32,110,111,116,32,105,110,32,112,111,111,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.934965958 UTC

[section ""data" . Foreign.Marshal.Pool.pooledRealloc2_closure" {
     Foreign.Marshal.Pool.pooledRealloc2_closure:
         const Foreign.Marshal.Pool.pooledRealloc2_info;
 },
 Foreign.Marshal.Pool.pooledRealloc2_entry() //  []
         { info_tbl: [(c95Iv,
                       label: Foreign.Marshal.Pool.pooledRealloc2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Iv: // global
           R2 = lvl_r95n4_bytes;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.936860568 UTC

[section ""data" . Foreign.Marshal.Pool.$wpooledReallocBytes_closure" {
     Foreign.Marshal.Pool.$wpooledReallocBytes_closure:
         const Foreign.Marshal.Pool.$wpooledReallocBytes_info;
         const 0;
 },
 sat_s95nT_entry() //  [R1]
         { info_tbl: [(c95IZ,
                       label: sat_s95nT_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95IZ: // global
           _s95nT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c95J0; else goto c95J1;
       c95J1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95J3; else goto c95J2;
       c95J3: // global
           HpAlloc = 16;
           goto c95J0;
       c95J0: // global
           R1 = _s95nT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95J2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s95nT::P64;
           _s95nQ::P64 = P64[_s95nT::P64 + 16];
           _s95ny::I64 = I64[_s95nT::P64 + 24];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s95ny::I64;
           R4 = _s95nQ::P64;
           R3 = Hp - 7;
           R2 = GHC.Ptr.$fEqPtr_$c==_closure+2;
           Sp = Sp - 16;
           call Data.OldList.deleteBy_entry(R4,
                                            R3,
                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s95o4_entry() //  [R1]
         { info_tbl: [(c95Jc,
                       label: sat_s95o4_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Jc: // global
           _s95o4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c95Jd; else goto c95Je;
       c95Je: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95Jg; else goto c95Jf;
       c95Jg: // global
           HpAlloc = 16;
           goto c95Jd;
       c95Jd: // global
           R1 = _s95o4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95Jf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s95o4::P64;
           _s95o2::P64 = P64[_s95o4::P64 + 16];
           _s95ny::I64 = I64[_s95o4::P64 + 24];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s95ny::I64;
           R4 = _s95o2::P64;
           R3 = Hp - 7;
           R2 = GHC.Ptr.$fEqPtr_$c==_closure+2;
           Sp = Sp - 16;
           call Data.OldList.deleteBy_entry(R4,
                                            R3,
                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Pool.$wpooledReallocBytes_entry() //  [R2, R3, R4]
         { info_tbl: [(c95Jl,
                       label: Foreign.Marshal.Pool.$wpooledReallocBytes_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 20} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Jl: // global
           _s95nz::I64 = R4;
           _s95ny::I64 = R3;
           _s95nx::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto c95Jm; else goto c95Jn;
       c95Jn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95Jp; else goto c95Jo;
       c95Jp: // global
           HpAlloc = 16;
           goto c95Jm;
       c95Jm: // global
           R4 = _s95nz::I64;
           R3 = _s95ny::I64;
           R2 = _s95nx::P64;
           R1 = Foreign.Marshal.Pool.$wpooledReallocBytes_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c95Jo: // global
           _s95nD::P64 = P64[_s95nx::P64 + 8];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s95ny::I64;
           I64[Sp - 40] = block_c95ID_info;
           R4 = _s95nD::P64;
           R3 = Hp - 7;
           R2 = GHC.Ptr.$fEqPtr_closure;
           P64[Sp - 32] = _s95nx::P64;
           I64[Sp - 24] = _s95ny::I64;
           I64[Sp - 16] = _s95nz::I64;
           P64[Sp - 8] = _s95nD::P64;
           Sp = Sp - 40;
           call GHC.List.elem_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c95ID() //  [R1]
         { info_tbl: [(c95ID,
                       label: block_c95ID_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95ID: // global
           if (R1 & 7 == 1) goto c95Ji; else goto c95Jj;
       c95Ji: // global
           R3 = Foreign.Marshal.Pool.pooledRealloc2_closure+1;
           R2 = P64[Sp + 32];
           Sp = Sp + 40;
           call Foreign.Marshal.Error.throwIf2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c95Jj: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c95Ju; else goto c95Jt;
       c95Ju: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95Jt: // global
           _s95nx::P64 = P64[Sp + 8];
           _s95ny::I64 = I64[Sp + 16];
           _s95nH::I64 = I64[Sp + 24];
           if (_s95nH::I64 != 0) goto c95Jz; else goto c95JA;
       c95Jz: // global
           (_s95nM::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(_s95ny::I64, _s95nH::I64);
           if (_s95nM::I64 == 0) goto c95Jx; else goto c95Jw;
       c95Jx: // global
           Hp = Hp - 72;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c95Jw: // global
           _s95nQ::P64 = P64[_s95nx::P64 + 8];
           I64[Hp - 64] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 56] = _s95nM::I64;
           I64[Hp - 48] = sat_s95nT_info;
           P64[Hp - 32] = _s95nQ::P64;
           I64[Hp - 24] = _s95ny::I64;
           I64[Hp - 16] = :_con_info;
           _c95IT::P64 = Hp - 63;
           P64[Hp - 8] = _c95IT::P64;
           P64[Hp] = Hp - 48;
           call MO_WriteBarrier();
           P64[_s95nx::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95nx::P64);
           R1 = _c95IT::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c95JA: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(_s95ny::I64);
           _s95o2::P64 = P64[_s95nx::P64 + 8];
           I64[Hp - 64] = sat_s95o4_info;
           P64[Hp - 48] = _s95o2::P64;
           I64[Hp - 40] = _s95ny::I64;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Ptr.nullPtr_closure;
           P64[Hp - 16] = Hp - 64;
           call MO_WriteBarrier();
           P64[_s95nx::P64 + 8] = Hp - 30;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95nx::P64);
           Hp = Hp - 16;
           R1 = GHC.Ptr.nullPtr_closure;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.94064905 UTC

[section ""data" . Foreign.Marshal.Pool.pooledRealloc1_closure" {
     Foreign.Marshal.Pool.pooledRealloc1_closure:
         const Foreign.Marshal.Pool.pooledRealloc1_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledRealloc1_entry() //  [R2, R3, R4]
         { info_tbl: [(c95JQ,
                       label: Foreign.Marshal.Pool.pooledRealloc1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95JQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c95JZ; else goto c95K0;
       c95JZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledRealloc1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c95K0: // global
           I64[Sp - 24] = block_c95JN_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u95K9; else goto c95JO;
       u95K9: // global
           call _c95JN(R1) args: 0, res: 0, upd: 0;
       c95JO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95JN() //  [R1]
         { info_tbl: [(c95JN,
                       label: block_c95JN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95JN: // global
           I64[Sp] = block_c95JT_info;
           _s95oc::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s95oc::P64;
           if (R1 & 7 != 0) goto u95K8; else goto c95JU;
       u95K8: // global
           call _c95JT(R1) args: 0, res: 0, upd: 0;
       c95JU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95JT() //  [R1]
         { info_tbl: [(c95JT,
                       label: block_c95JT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95JT: // global
           I64[Sp] = block_c95JY_info;
           _s95oe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s95oe::I64;
           if (R1 & 7 != 0) goto u95Ka; else goto c95K3;
       u95Ka: // global
           call _c95JY(R1) args: 0, res: 0, upd: 0;
       c95K3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95JY() //  [R1]
         { info_tbl: [(c95JY,
                       label: block_c95JY_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95JY: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Pool.$wpooledReallocBytes_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.942225662 UTC

[section ""data" . Foreign.Marshal.Pool.pooledReallocBytes_closure" {
     Foreign.Marshal.Pool.pooledReallocBytes_closure:
         const Foreign.Marshal.Pool.pooledReallocBytes_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledReallocBytes_entry() //  [R2, R3, R4]
         { info_tbl: [(c95Kf,
                       label: Foreign.Marshal.Pool.pooledReallocBytes_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Kf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledRealloc1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.942975613 UTC

[section ""cstring" . lvl1_r95n5_bytes" {
     lvl1_r95n5_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.943738377 UTC

[section ""data" . lvl2_r95n6_closure" {
     lvl2_r95n6_closure:
         const lvl2_r95n6_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r95n6_entry() //  [R1]
         { info_tbl: [(c95Ko,
                       label: lvl2_r95n6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Ko: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95Kp; else goto c95Kq;
       c95Kp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95Kq: // global
           (_c95Kl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c95Kl::I64 == 0) goto c95Kn; else goto c95Km;
       c95Kn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c95Km: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c95Kl::I64;
           R2 = lvl1_r95n5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.94476076 UTC

[section ""data" . lvl3_r95n7_closure" {
     lvl3_r95n7_closure:
         const lvl3_r95n7_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r95n7_entry() //  [R1]
         { info_tbl: [(c95Kx,
                       label: lvl3_r95n7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Kx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95Ky; else goto c95Kz;
       c95Ky: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95Kz: // global
           (_c95Ku::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c95Ku::I64 == 0) goto c95Kw; else goto c95Kv;
       c95Kw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c95Kv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c95Ku::I64;
           R2 = Foreign.Marshal.Pool.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.946213486 UTC

[section ""data" . lvl4_r95n8_closure" {
     lvl4_r95n8_closure:
         const lvl4_r95n8_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r95n8_entry() //  [R1]
         { info_tbl: [(c95KG,
                       label: lvl4_r95n8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95KG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95KH; else goto c95KI;
       c95KH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95KI: // global
           (_c95KD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c95KD::I64 == 0) goto c95KF; else goto c95KE;
       c95KF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c95KE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c95KD::I64;
           R2 = Foreign.Marshal.Pool.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.947117352 UTC

[section ""cstring" . lvl5_r95n9_bytes" {
     lvl5_r95n9_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,77,97,114,115,104,97,108,47,80,111,111,108,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.947819184 UTC

[section ""data" . lvl6_r95na_closure" {
     lvl6_r95na_closure:
         const lvl6_r95na_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r95na_entry() //  [R1]
         { info_tbl: [(c95KP,
                       label: lvl6_r95na_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95KP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95KQ; else goto c95KR;
       c95KQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95KR: // global
           (_c95KM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c95KM::I64 == 0) goto c95KO; else goto c95KN;
       c95KO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c95KN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c95KM::I64;
           R2 = lvl5_r95n9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.948720527 UTC

[section ""data" . lvl7_r95nb_closure" {
     lvl7_r95nb_closure:
         const GHC.Types.I#_con_info;
         const 159;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.949281394 UTC

[section ""data" . lvl8_r95nc_closure" {
     lvl8_r95nc_closure:
         const GHC.Types.I#_con_info;
         const 26;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.949861388 UTC

[section ""data" . lvl9_r95nd_closure" {
     lvl9_r95nd_closure:
         const GHC.Types.I#_con_info;
         const 35;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.950454267 UTC

[section ""data" . lvl10_r95ne_closure" {
     lvl10_r95ne_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_r95n7_closure;
         const lvl4_r95n8_closure;
         const lvl6_r95na_closure;
         const lvl7_r95nb_closure+1;
         const lvl8_r95nc_closure+1;
         const lvl7_r95nb_closure+1;
         const lvl9_r95nd_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.951094638 UTC

[section ""data" . lvl11_r95nf_closure" {
     lvl11_r95nf_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_r95n6_closure;
         const lvl10_r95ne_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.951876799 UTC

[section ""data" . Foreign.Marshal.Pool.pooledReallocArray1_closure" {
     Foreign.Marshal.Pool.pooledReallocArray1_closure:
         const Foreign.Marshal.Pool.pooledReallocArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Pool.pooledReallocArray1_entry() //  [R1]
         { info_tbl: [(c95KY,
                       label: Foreign.Marshal.Pool.pooledReallocArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95KY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95KZ; else goto c95L0;
       c95KZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95L0: // global
           (_c95KV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c95KV::I64 == 0) goto c95KX; else goto c95KW;
       c95KX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c95KW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c95KV::I64;
           R2 = lvl11_r95nf_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.953725285 UTC

[section ""data" . Foreign.Marshal.Pool.pooledReallocArray_closure" {
     Foreign.Marshal.Pool.pooledReallocArray_closure:
         const Foreign.Marshal.Pool.pooledReallocArray_info;
         const 0;
 },
 lvl27_s95oi_entry() //  [R1]
         { info_tbl: [(c95L9,
                       label: lvl27_s95oi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95L9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c95La; else goto c95Lb;
       c95La: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95Lb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Pool.pooledReallocArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s95ow_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c95Lk,
                       label: sat_s95ow_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Lk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c95Ly; else goto c95Lz;
       c95Ly: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c95Lz: // global
           I64[Sp - 32] = block_c95Lh_info;
           _s95oi::P64 = P64[R1 + 4];
           R1 = R2;
           P64[Sp - 24] = _s95oi::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u95LK; else goto c95Li;
       u95LK: // global
           call _c95Lh(R1) args: 0, res: 0, upd: 0;
       c95Li: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Lh() //  [R1]
         { info_tbl: [(c95Lh,
                       label: block_c95Lh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Lh: // global
           I64[Sp] = block_c95Ln_info;
           _s95oo::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s95oo::P64;
           if (R1 & 7 != 0) goto u95LJ; else goto c95Lo;
       u95LJ: // global
           call _c95Ln(R1) args: 0, res: 0, upd: 0;
       c95Lo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Ln() //  [R1]
         { info_tbl: [(c95Ln,
                       label: block_c95Ln_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Ln: // global
           I64[Sp] = block_c95Ls_info;
           _s95oq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s95oq::I64;
           if (R1 & 7 != 0) goto u95LL; else goto c95Lt;
       u95LL: // global
           call _c95Ls(R1) args: 0, res: 0, upd: 0;
       c95Lt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Ls() //  [R1]
         { info_tbl: [(c95Ls,
                       label: block_c95Ls_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Ls: // global
           I64[Sp] = block_c95Lx_info;
           _s95os::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s95os::I64;
           if (R1 & 7 != 0) goto u95LM; else goto c95LD;
       u95LM: // global
           call _c95Lx(R1) args: 0, res: 0, upd: 0;
       c95LD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Lx() //  [R1]
         { info_tbl: [(c95Lx,
                       label: block_c95Lx_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Lx: // global
           R4 = I64[Sp + 8] * I64[R1 + 7];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Foreign.Marshal.Pool.$wpooledReallocBytes_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Pool.pooledReallocArray_entry() //  [R2]
         { info_tbl: [(c95LN,
                       label: Foreign.Marshal.Pool.pooledReallocArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95LN: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95LR; else goto c95LQ;
       c95LR: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledReallocArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c95LQ: // global
           I64[Hp - 32] = lvl27_s95oi_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s95ow_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.957031289 UTC

[section ""data" . Foreign.Marshal.Pool.pooledReallocArray2_closure" {
     Foreign.Marshal.Pool.pooledReallocArray2_closure:
         const Foreign.Marshal.Pool.pooledReallocArray2_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledReallocArray2_entry() //  [R2, R3, R4,
                                                       R5]
         { info_tbl: [(c95LZ,
                       label: Foreign.Marshal.Pool.pooledReallocArray2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95LZ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c95Md; else goto c95Me;
       c95Md: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledReallocArray2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c95Me: // global
           I64[Sp - 32] = block_c95LW_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u95Mr; else goto c95LX;
       u95Mr: // global
           call _c95LW(R1) args: 0, res: 0, upd: 0;
       c95LX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95LW() //  [R1]
         { info_tbl: [(c95LW,
                       label: block_c95LW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95LW: // global
           I64[Sp] = block_c95M2_info;
           _s95oD::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s95oD::P64;
           if (R1 & 7 != 0) goto u95Mq; else goto c95M3;
       u95Mq: // global
           call _c95M2(R1) args: 0, res: 0, upd: 0;
       c95M3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95M2() //  [R1]
         { info_tbl: [(c95M2,
                       label: block_c95M2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95M2: // global
           I64[Sp] = block_c95M7_info;
           _s95oF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s95oF::I64;
           if (R1 & 7 != 0) goto u95Ms; else goto c95M8;
       u95Ms: // global
           call _c95M7(R1) args: 0, res: 0, upd: 0;
       c95M8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95M7() //  [R1]
         { info_tbl: [(c95M7,
                       label: block_c95M7_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95M7: // global
           I64[Sp] = block_c95Mc_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Foreign.Marshal.Pool.pooledReallocArray1_closure;
           I64[Sp + 8] = I64[R1 + 7];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c95Mc() //  [R1]
         { info_tbl: [(c95Mc,
                       label: block_c95Mc_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Mc: // global
           R4 = (I64[Sp + 8] + 1) * I64[R1 + 7];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Foreign.Marshal.Pool.$wpooledReallocBytes_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.958829288 UTC

[section ""data" . Foreign.Marshal.Pool.pooledReallocArray0_closure" {
     Foreign.Marshal.Pool.pooledReallocArray0_closure:
         const Foreign.Marshal.Pool.pooledReallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledReallocArray0_entry() //  [R2, R3, R4,
                                                       R5]
         { info_tbl: [(c95Mx,
                       label: Foreign.Marshal.Pool.pooledReallocArray0_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Mx: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledReallocArray2_entry(R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.959580065 UTC

[section ""data" . lvl12_r95ng_closure" {
     lvl12_r95ng_closure:
         const GHC.Types.I#_con_info;
         const 124;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.960151768 UTC

[section ""data" . lvl13_r95nh_closure" {
     lvl13_r95nh_closure:
         const GHC.Types.I#_con_info;
         const 20;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.960681797 UTC

[section ""data" . lvl14_r95ni_closure" {
     lvl14_r95ni_closure:
         const GHC.Types.I#_con_info;
         const 29;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.961237159 UTC

[section ""data" . lvl15_r95nj_closure" {
     lvl15_r95nj_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_r95n7_closure;
         const lvl4_r95n8_closure;
         const lvl6_r95na_closure;
         const lvl12_r95ng_closure+1;
         const lvl13_r95nh_closure+1;
         const lvl12_r95ng_closure+1;
         const lvl14_r95ni_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.962065782 UTC

[section ""data" . lvl16_r95nk_closure" {
     lvl16_r95nk_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_r95n6_closure;
         const lvl15_r95nj_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.962804858 UTC

[section ""data" . Foreign.Marshal.Pool.pooledRealloc3_closure" {
     Foreign.Marshal.Pool.pooledRealloc3_closure:
         const Foreign.Marshal.Pool.pooledRealloc3_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Pool.pooledRealloc3_entry() //  [R1]
         { info_tbl: [(c95MG,
                       label: Foreign.Marshal.Pool.pooledRealloc3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95MG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95MH; else goto c95MI;
       c95MH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95MI: // global
           (_c95MD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c95MD::I64 == 0) goto c95MF; else goto c95ME;
       c95MF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c95ME: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c95MD::I64;
           R2 = lvl16_r95nk_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.964101312 UTC

[section ""data" . Foreign.Marshal.Pool.pooledRealloc_closure" {
     Foreign.Marshal.Pool.pooledRealloc_closure:
         const Foreign.Marshal.Pool.pooledRealloc_info;
         const 0;
 },
 lvl27_s95oN_entry() //  [R1]
         { info_tbl: [(c95MR,
                       label: lvl27_s95oN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95MR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c95MS; else goto c95MT;
       c95MS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95MT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Pool.pooledRealloc3_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s95oR_entry() //  [R1, R2, R3]
         { info_tbl: [(c95MZ,
                       label: sat_s95oR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95MZ: // global
           R4 = P64[R1 + 5];
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledRealloc1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Pool.pooledRealloc_entry() //  [R2]
         { info_tbl: [(c95N2,
                       label: Foreign.Marshal.Pool.pooledRealloc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95N2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95N6; else goto c95N5;
       c95N6: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledRealloc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c95N5: // global
           I64[Hp - 32] = lvl27_s95oN_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s95oR_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.965882541 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocBytes1_closure" {
     Foreign.Marshal.Pool.pooledMallocBytes1_closure:
         const Foreign.Marshal.Pool.pooledMallocBytes1_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMallocBytes1_entry() //  [R2, R3]
         { info_tbl: [(c95Ne,
                       label: Foreign.Marshal.Pool.pooledMallocBytes1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Ne: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95Nf; else goto c95Ng;
       c95Nf: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledMallocBytes1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c95Ng: // global
           I64[Sp - 16] = block_c95Nb_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u95NJ; else goto c95Nc;
       u95NJ: // global
           call _c95Nb(R1) args: 0, res: 0, upd: 0;
       c95Nc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Nb() //  [R1]
         { info_tbl: [(c95Nb,
                       label: block_c95Nb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Nb: // global
           _s95oS::P64 = P64[Sp + 8];
           (_s95p1::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s95p1::I64 == 0) goto c95ND; else goto c95Nz;
       c95ND: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c95Nz: // global
           I64[Sp] = block_c95Ns_info;
           R1 = _s95oS::P64;
           I64[Sp + 8] = _s95p1::I64;
           if (R1 & 7 != 0) goto u95NI; else goto c95Nt;
       u95NI: // global
           call _c95Ns(R1) args: 0, res: 0, upd: 0;
       c95Nt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Ns() //  [R1]
         { info_tbl: [(c95Ns,
                       label: block_c95Ns_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Ns: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95NC; else goto c95NB;
       c95NC: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95NB: // global
           _s95p4::P64 = P64[R1 + 7];
           _s95p7::P64 = P64[_s95p4::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           _c95Nx::P64 = Hp - 31;
           P64[Hp - 8] = _c95Nx::P64;
           P64[Hp] = _s95p7::P64;
           call MO_WriteBarrier();
           P64[_s95p4::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95p4::P64);
           R1 = _c95Nx::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.967596683 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocBytes_closure" {
     Foreign.Marshal.Pool.pooledMallocBytes_closure:
         const Foreign.Marshal.Pool.pooledMallocBytes_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMallocBytes_entry() //  [R2, R3]
         { info_tbl: [(c95NO,
                       label: Foreign.Marshal.Pool.pooledMallocBytes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95NO: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledMallocBytes1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.96836296 UTC

[section ""data" . lvl17_r95nl_closure" {
     lvl17_r95nl_closure:
         const GHC.Types.I#_con_info;
         const 144;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.968945341 UTC

[section ""data" . lvl18_r95nm_closure" {
     lvl18_r95nm_closure:
         const GHC.Types.I#_con_info;
         const 25;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.969575452 UTC

[section ""data" . lvl19_r95nn_closure" {
     lvl19_r95nn_closure:
         const GHC.Types.I#_con_info;
         const 34;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.970155878 UTC

[section ""data" . lvl20_r95no_closure" {
     lvl20_r95no_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_r95n7_closure;
         const lvl4_r95n8_closure;
         const lvl6_r95na_closure;
         const lvl17_r95nl_closure+1;
         const lvl18_r95nm_closure+1;
         const lvl17_r95nl_closure+1;
         const lvl19_r95nn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.971431027 UTC

[section ""data" . lvl21_r95np_closure" {
     lvl21_r95np_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_r95n6_closure;
         const lvl20_r95no_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.972173806 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocArray1_closure" {
     Foreign.Marshal.Pool.pooledMallocArray1_closure:
         const Foreign.Marshal.Pool.pooledMallocArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMallocArray1_entry() //  [R1]
         { info_tbl: [(c95NX,
                       label: Foreign.Marshal.Pool.pooledMallocArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95NX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95NY; else goto c95NZ;
       c95NY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95NZ: // global
           (_c95NU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c95NU::I64 == 0) goto c95NW; else goto c95NV;
       c95NW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c95NV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c95NU::I64;
           R2 = lvl21_r95np_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.973941585 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocArray_closure" {
     Foreign.Marshal.Pool.pooledMallocArray_closure:
         const Foreign.Marshal.Pool.pooledMallocArray_info;
         const 0;
 },
 lvl27_s95pd_entry() //  [R1]
         { info_tbl: [(c95O8,
                       label: lvl27_s95pd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95O8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c95O9; else goto c95Oa;
       c95O9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95Oa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Pool.pooledMallocArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s95pB_entry() //  [R1, R2, R3]
         { info_tbl: [(c95Oj,
                       label: sat_s95pB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Oj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c95On; else goto c95Oo;
       c95On: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c95Oo: // global
           I64[Sp - 24] = block_c95Og_info;
           _s95pd::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s95pd::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u95OX; else goto c95Oh;
       u95OX: // global
           call _c95Og(R1) args: 0, res: 0, upd: 0;
       c95Oh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Og() //  [R1]
         { info_tbl: [(c95Og,
                       label: block_c95Og_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Og: // global
           I64[Sp] = block_c95Om_info;
           _s95pi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s95pi::I64;
           if (R1 & 7 != 0) goto u95OW; else goto c95Oq;
       u95OW: // global
           call _c95Om(R1) args: 0, res: 0, upd: 0;
       c95Oq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Om() //  [R1]
         { info_tbl: [(c95Om,
                       label: block_c95Om_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Om: // global
           _s95pe::P64 = P64[Sp + 16];
           (_s95pq::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[Sp + 8] * I64[R1 + 7]);
           if (_s95pq::I64 == 0) goto c95OR; else goto c95ON;
       c95OR: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c95ON: // global
           I64[Sp + 8] = block_c95OG_info;
           R1 = _s95pe::P64;
           I64[Sp + 16] = _s95pq::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u95OY; else goto c95OH;
       u95OY: // global
           call _c95OG(R1) args: 0, res: 0, upd: 0;
       c95OH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95OG() //  [R1]
         { info_tbl: [(c95OG,
                       label: block_c95OG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95OG: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95OQ; else goto c95OP;
       c95OQ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95OP: // global
           _s95pt::P64 = P64[R1 + 7];
           _s95pw::P64 = P64[_s95pt::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           _c95OL::P64 = Hp - 31;
           P64[Hp - 8] = _c95OL::P64;
           P64[Hp] = _s95pw::P64;
           call MO_WriteBarrier();
           P64[_s95pt::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95pt::P64);
           R1 = _c95OL::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Pool.pooledMallocArray_entry() //  [R2]
         { info_tbl: [(c95OZ,
                       label: Foreign.Marshal.Pool.pooledMallocArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95OZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95P3; else goto c95P2;
       c95P3: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledMallocArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c95P2: // global
           I64[Hp - 32] = lvl27_s95pd_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s95pB_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.976789736 UTC

[section ""data" . Foreign.Marshal.Pool.$wpooledMallocArray0_closure" {
     Foreign.Marshal.Pool.$wpooledMallocArray0_closure:
         const Foreign.Marshal.Pool.$wpooledMallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Pool.$wpooledMallocArray0_entry() //  [R2, R3, R4]
         { info_tbl: [(c95Pa,
                       label: Foreign.Marshal.Pool.$wpooledMallocArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Pa: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c95Pb; else goto c95Pc;
       c95Pb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.$wpooledMallocArray0_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c95Pc: // global
           I64[Sp - 24] = block_c95P8_info;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = Foreign.Marshal.Pool.pooledMallocArray1_closure;
           P64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c95P8() //  [R1]
         { info_tbl: [(c95P8,
                       label: block_c95P8_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95P8: // global
           _s95pD::P64 = P64[Sp + 8];
           (_s95pO::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc((I64[Sp + 16] + 1) * I64[R1 + 7]);
           if (_s95pO::I64 == 0) goto c95PF; else goto c95PB;
       c95PF: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c95PB: // global
           I64[Sp + 8] = block_c95Pu_info;
           R1 = _s95pD::P64;
           I64[Sp + 16] = _s95pO::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u95PK; else goto c95Pv;
       u95PK: // global
           call _c95Pu(R1) args: 0, res: 0, upd: 0;
       c95Pv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Pu() //  [R1]
         { info_tbl: [(c95Pu,
                       label: block_c95Pu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Pu: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95PE; else goto c95PD;
       c95PE: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95PD: // global
           _s95pR::P64 = P64[R1 + 7];
           _s95pU::P64 = P64[_s95pR::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           _c95Pz::P64 = Hp - 31;
           P64[Hp - 8] = _c95Pz::P64;
           P64[Hp] = _s95pU::P64;
           call MO_WriteBarrier();
           P64[_s95pR::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95pR::P64);
           R1 = _c95Pz::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.978585433 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocArray2_closure" {
     Foreign.Marshal.Pool.pooledMallocArray2_closure:
         const Foreign.Marshal.Pool.pooledMallocArray2_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMallocArray2_entry() //  [R2, R3, R4]
         { info_tbl: [(c95PS,
                       label: Foreign.Marshal.Pool.pooledMallocArray2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95PS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c95PT; else goto c95PU;
       c95PT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledMallocArray2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c95PU: // global
           I64[Sp - 24] = block_c95PP_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u95PY; else goto c95PQ;
       u95PY: // global
           call _c95PP(R1) args: 0, res: 0, upd: 0;
       c95PQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95PP() //  [R1]
         { info_tbl: [(c95PP,
                       label: block_c95PP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95PP: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Pool.$wpooledMallocArray0_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.979787209 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocArray0_closure" {
     Foreign.Marshal.Pool.pooledMallocArray0_closure:
         const Foreign.Marshal.Pool.pooledMallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMallocArray0_entry() //  [R2, R3, R4]
         { info_tbl: [(c95Q3,
                       label: Foreign.Marshal.Pool.pooledMallocArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Q3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledMallocArray2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.980557928 UTC

[section ""data" . lvl22_r95nq_closure" {
     lvl22_r95nq_closure:
         const GHC.Types.I#_con_info;
         const 106;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.981128122 UTC

[section ""data" . lvl23_r95nr_closure" {
     lvl23_r95nr_closure:
         const GHC.Types.I#_con_info;
         const 19;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.982013544 UTC

[section ""data" . lvl24_r95ns_closure" {
     lvl24_r95ns_closure:
         const GHC.Types.I#_con_info;
         const 28;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.982573341 UTC

[section ""data" . lvl25_r95nt_closure" {
     lvl25_r95nt_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_r95n7_closure;
         const lvl4_r95n8_closure;
         const lvl6_r95na_closure;
         const lvl22_r95nq_closure+1;
         const lvl23_r95nr_closure+1;
         const lvl22_r95nq_closure+1;
         const lvl24_r95ns_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.983182827 UTC

[section ""data" . lvl26_r95nu_closure" {
     lvl26_r95nu_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_r95n6_closure;
         const lvl25_r95nt_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.983994941 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMalloc1_closure" {
     Foreign.Marshal.Pool.pooledMalloc1_closure:
         const Foreign.Marshal.Pool.pooledMalloc1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMalloc1_entry() //  [R1]
         { info_tbl: [(c95Qc,
                       label: Foreign.Marshal.Pool.pooledMalloc1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Qc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95Qd; else goto c95Qe;
       c95Qd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95Qe: // global
           (_c95Q9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c95Q9::I64 == 0) goto c95Qb; else goto c95Qa;
       c95Qb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c95Qa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c95Q9::I64;
           R2 = lvl26_r95nu_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.985746634 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMalloc_closure" {
     Foreign.Marshal.Pool.pooledMalloc_closure:
         const Foreign.Marshal.Pool.pooledMalloc_info;
         const 0;
 },
 lvl27_s95q6_entry() //  [R1]
         { info_tbl: [(c95Qn,
                       label: lvl27_s95q6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Qn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c95Qo; else goto c95Qp;
       c95Qo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95Qp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Pool.pooledMalloc1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s95qq_entry() //  [R1, R2]
         { info_tbl: [(c95Qy,
                       label: sat_s95qq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Qy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95Qz; else goto c95QA;
       c95Qz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c95QA: // global
           I64[Sp - 16] = block_c95Qv_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u95R3; else goto c95Qw;
       u95R3: // global
           call _c95Qv(R1) args: 0, res: 0, upd: 0;
       c95Qw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Qv() //  [R1]
         { info_tbl: [(c95Qv,
                       label: block_c95Qv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Qv: // global
           _s95q7::P64 = P64[Sp + 8];
           (_s95qf::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s95qf::I64 == 0) goto c95QX; else goto c95QT;
       c95QX: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c95QT: // global
           I64[Sp] = block_c95QM_info;
           R1 = _s95q7::P64;
           I64[Sp + 8] = _s95qf::I64;
           if (R1 & 7 != 0) goto u95R2; else goto c95QN;
       u95R2: // global
           call _c95QM(R1) args: 0, res: 0, upd: 0;
       c95QN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95QM() //  [R1]
         { info_tbl: [(c95QM,
                       label: block_c95QM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95QM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95QW; else goto c95QV;
       c95QW: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95QV: // global
           _s95qi::P64 = P64[R1 + 7];
           _s95ql::P64 = P64[_s95qi::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           _c95QR::P64 = Hp - 31;
           P64[Hp - 8] = _c95QR::P64;
           P64[Hp] = _s95ql::P64;
           call MO_WriteBarrier();
           P64[_s95qi::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95qi::P64);
           R1 = _c95QR::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Pool.pooledMalloc_entry() //  [R2]
         { info_tbl: [(c95R4,
                       label: Foreign.Marshal.Pool.pooledMalloc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95R4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95R8; else goto c95R7;
       c95R8: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledMalloc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c95R7: // global
           I64[Hp - 32] = lvl27_s95q6_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s95qq_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.989616995 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNewArray2_closure" {
     Foreign.Marshal.Pool.pooledNewArray2_closure:
         const Foreign.Marshal.Pool.pooledNewArray2_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNewArray2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c95Rf,
                       label: Foreign.Marshal.Pool.pooledNewArray2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Rf: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c95Rj; else goto c95Rk;
       c95Rj: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledNewArray2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c95Rk: // global
           I64[Sp - 40] = block_c95Rd_info;
           _s95qs::P64 = R3;
           R3 = 0;
           _s95qr::P64 = R2;
           R2 = R5;
           P64[Sp - 32] = _s95qr::P64;
           P64[Sp - 24] = _s95qs::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c95Rd() //  [R1]
         { info_tbl: [(c95Rd,
                       label: block_c95Rd_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Rd: // global
           I64[Sp - 8] = block_c95Ri_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = Foreign.Marshal.Pool.pooledMallocArray1_closure;
           I64[Sp] = R1;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c95Ri() //  [R1]
         { info_tbl: [(c95Ri,
                       label: block_c95Ri_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Ri: // global
           _s95qs::P64 = P64[Sp + 24];
           (_s95qF::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc((I64[Sp + 8] + 1) * I64[R1 + 7]);
           if (_s95qF::I64 == 0) goto c95RW; else goto c95RQ;
       c95RW: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c95RQ: // global
           I64[Sp + 8] = block_c95RE_info;
           R1 = _s95qs::P64;
           I64[Sp + 24] = _s95qF::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u95RX; else goto c95RF;
       u95RX: // global
           call _c95RE(R1) args: 0, res: 0, upd: 0;
       c95RF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95RE() //  [R1]
         { info_tbl: [(c95RE,
                       label: block_c95RE_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95RE: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95RT; else goto c95RS;
       c95RT: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95RS: // global
           _s95qI::P64 = P64[R1 + 7];
           _s95qL::P64 = P64[_s95qI::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           _c95RJ::P64 = Hp - 31;
           P64[Hp - 8] = _c95RJ::P64;
           P64[Hp] = _s95qL::P64;
           _s95qr::P64 = P64[Sp + 8];
           _s95qt::P64 = P64[Sp + 24];
           _s95qu::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_s95qI::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95qI::P64);
           I64[Sp + 24] = block_c95RO_info;
           R5 = _s95qu::P64;
           R4 = _c95RJ::P64;
           R3 = _s95qt::P64;
           R2 = _s95qr::P64;
           P64[Sp + 32] = _c95RJ::P64;
           Sp = Sp + 24;
           call Foreign.Marshal.Array.newArray4_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c95RO() //  []
         { info_tbl: [(c95RO,
                       label: block_c95RO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95RO: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.991704434 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNewArray0_closure" {
     Foreign.Marshal.Pool.pooledNewArray0_closure:
         const Foreign.Marshal.Pool.pooledNewArray0_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNewArray0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c95S2,
                       label: Foreign.Marshal.Pool.pooledNewArray0_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95S2: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledNewArray2_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.993076286 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNewArray1_closure" {
     Foreign.Marshal.Pool.pooledNewArray1_closure:
         const Foreign.Marshal.Pool.pooledNewArray1_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNewArray1_entry() //  [R2, R3, R4]
         { info_tbl: [(c95Sb,
                       label: Foreign.Marshal.Pool.pooledNewArray1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Sb: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c95Sf; else goto c95Sg;
       c95Sf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledNewArray1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c95Sg: // global
           I64[Sp - 32] = block_c95S9_info;
           _s95qU::P64 = R3;
           R3 = 0;
           _s95qT::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _s95qT::P64;
           P64[Sp - 16] = _s95qU::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c95S9() //  [R1]
         { info_tbl: [(c95S9,
                       label: block_c95S9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95S9: // global
           I64[Sp - 8] = block_c95Se_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = Foreign.Marshal.Pool.pooledMallocArray1_closure;
           I64[Sp] = R1;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c95Se() //  [R1]
         { info_tbl: [(c95Se,
                       label: block_c95Se_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Se: // global
           _s95qU::P64 = P64[Sp + 24];
           (_s95r5::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[Sp + 8] * I64[R1 + 7]);
           if (_s95r5::I64 == 0) goto c95SP; else goto c95SJ;
       c95SP: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c95SJ: // global
           I64[Sp + 8] = block_c95Sx_info;
           R1 = _s95qU::P64;
           I64[Sp + 24] = _s95r5::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u95SQ; else goto c95Sy;
       u95SQ: // global
           call _c95Sx(R1) args: 0, res: 0, upd: 0;
       c95Sy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Sx() //  [R1]
         { info_tbl: [(c95Sx,
                       label: block_c95Sx_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Sx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95SM; else goto c95SL;
       c95SM: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95SL: // global
           _s95r8::P64 = P64[R1 + 7];
           _s95rb::P64 = P64[_s95r8::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           _c95SC::P64 = Hp - 31;
           P64[Hp - 8] = _c95SC::P64;
           P64[Hp] = _s95rb::P64;
           _s95qT::P64 = P64[Sp + 8];
           _s95qV::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_s95r8::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95r8::P64);
           I64[Sp + 16] = block_c95SH_info;
           R4 = _s95qV::P64;
           R3 = _c95SC::P64;
           R2 = _s95qT::P64;
           P64[Sp + 24] = _c95SC::P64;
           Sp = Sp + 16;
           call Foreign.Marshal.Array.newArray2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c95SH() //  []
         { info_tbl: [(c95SH,
                       label: block_c95SH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95SH: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.99519542 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNewArray_closure" {
     Foreign.Marshal.Pool.pooledNewArray_closure:
         const Foreign.Marshal.Pool.pooledNewArray_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNewArray_entry() //  [R2, R3, R4]
         { info_tbl: [(c95SV,
                       label: Foreign.Marshal.Pool.pooledNewArray_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95SV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledNewArray1_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.996525345 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNew1_closure" {
     Foreign.Marshal.Pool.pooledNew1_closure:
         const Foreign.Marshal.Pool.pooledNew1_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNew1_entry() //  [R2, R3, R4]
         { info_tbl: [(c95T4,
                       label: Foreign.Marshal.Pool.pooledNew1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95T4: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c95T5; else goto c95T6;
       c95T5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledNew1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c95T6: // global
           I64[Sp - 32] = block_c95T2_info;
           _s95rj::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = Foreign.Marshal.Pool.pooledMalloc1_closure;
           P64[Sp - 24] = _s95rj::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 48;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c95T2() //  [R1]
         { info_tbl: [(c95T2,
                       label: block_c95T2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95T2: // global
           _s95rk::P64 = P64[Sp + 16];
           (_s95rt::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s95rt::I64 == 0) goto c95TA; else goto c95Tu;
       c95TA: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c95Tu: // global
           I64[Sp] = block_c95Ti_info;
           R1 = _s95rk::P64;
           I64[Sp + 16] = _s95rt::I64;
           if (R1 & 7 != 0) goto u95TB; else goto c95Tj;
       u95TB: // global
           call _c95Ti(R1) args: 0, res: 0, upd: 0;
       c95Tj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Ti() //  [R1]
         { info_tbl: [(c95Ti,
                       label: block_c95Ti_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Ti: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c95Tx; else goto c95Tw;
       c95Tx: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95Tw: // global
           _s95rw::P64 = P64[R1 + 7];
           _s95rz::P64 = P64[_s95rw::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           _c95Tn::P64 = Hp - 31;
           P64[Hp - 8] = _c95Tn::P64;
           P64[Hp] = _s95rz::P64;
           _s95rj::P64 = P64[Sp + 8];
           _s95rl::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_s95rw::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95rw::P64);
           I64[Sp + 16] = block_c95Ts_info;
           R2 = _s95rj::P64;
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _c95Tn::P64;
           P64[Sp + 8] = _s95rl::P64;
           P64[Sp + 24] = _c95Tn::P64;
           Sp = Sp - 8;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c95Ts() //  []
         { info_tbl: [(c95Ts,
                       label: block_c95Ts_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Ts: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.998507344 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNew_closure" {
     Foreign.Marshal.Pool.pooledNew_closure:
         const Foreign.Marshal.Pool.pooledNew_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNew_entry() //  [R2, R3, R4]
         { info_tbl: [(c95TG,
                       label: Foreign.Marshal.Pool.pooledNew_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95TG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledNew1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:14.999590567 UTC

[section ""data" . Foreign.Marshal.Pool.freePool2_closure" {
     Foreign.Marshal.Pool.freePool2_closure:
         const Foreign.Marshal.Pool.freePool2_info;
 },
 Foreign.Marshal.Pool.freePool2_entry() //  [R2]
         { info_tbl: [(c95TU,
                       label: Foreign.Marshal.Pool.freePool2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95TU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95TV; else goto u95Ub;
       c95TV: // global
           R2 = R2;
           R1 = Foreign.Marshal.Pool.freePool2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u95Ub: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c95TK() args: 0, res: 0, upd: 0;
     }
 },
 _c95TK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95TK: // global
           _s95rH::P64 = P64[Sp];
           I64[Sp] = block_c95TN_info;
           R1 = _s95rH::P64;
           if (R1 & 7 != 0) goto u95Ud; else goto c95TO;
       u95Ud: // global
           call _c95TN(R1) args: 0, res: 0, upd: 0;
       c95TO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95TN() //  [R1]
         { info_tbl: [(c95TN,
                       label: block_c95TN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95TN: // global
           if (R1 & 7 == 1) goto c95TR; else goto c95TS;
       c95TR: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c95TS: // global
           I64[Sp - 8] = block_c95U2_info;
           _s95rL::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s95rL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u95Ue; else goto c95U4;
       u95Ue: // global
           call _c95U2(R1) args: 0, res: 0, upd: 0;
       c95U4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95U2() //  [R1]
         { info_tbl: [(c95U2,
                       label: block_c95U2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95U2: // global
           _s95rL::P64 = P64[Sp + 8];
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[R1 + 7]);
           P64[Sp + 8] = _s95rL::P64;
           Sp = Sp + 8;
           call _c95TK() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.001142878 UTC

[section ""data" . Foreign.Marshal.Pool.freePool1_closure" {
     Foreign.Marshal.Pool.freePool1_closure:
         const Foreign.Marshal.Pool.freePool1_info;
 },
 Foreign.Marshal.Pool.freePool1_entry() //  [R2]
         { info_tbl: [(c95Uo,
                       label: Foreign.Marshal.Pool.freePool1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Uo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c95Up; else goto c95Uq;
       c95Up: // global
           R2 = R2;
           R1 = Foreign.Marshal.Pool.freePool1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c95Uq: // global
           I64[Sp - 8] = block_c95Ul_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u95Uu; else goto c95Um;
       u95Uu: // global
           call _c95Ul(R1) args: 0, res: 0, upd: 0;
       c95Um: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Ul() //  [R1]
         { info_tbl: [(c95Ul,
                       label: block_c95Ul_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Ul: // global
           R2 = P64[P64[R1 + 7] + 8];
           Sp = Sp + 8;
           call Foreign.Marshal.Pool.freePool2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.002237625 UTC

[section ""data" . Foreign.Marshal.Pool.freePool_closure" {
     Foreign.Marshal.Pool.freePool_closure:
         const Foreign.Marshal.Pool.freePool_info;
 },
 Foreign.Marshal.Pool.freePool_entry() //  [R2]
         { info_tbl: [(c95Uz,
                       label: Foreign.Marshal.Pool.freePool_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Uz: // global
           R2 = R2;
           call Foreign.Marshal.Pool.freePool1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.00309389 UTC

[section ""data" . Foreign.Marshal.Pool.newPool1_closure" {
     Foreign.Marshal.Pool.newPool1_closure:
         const Foreign.Marshal.Pool.newPool1_info;
 },
 Foreign.Marshal.Pool.newPool1_entry() //  []
         { info_tbl: [(c95UJ,
                       label: Foreign.Marshal.Pool.newPool1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95UJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c95UK; else goto c95UL;
       c95UK: // global
           R1 = Foreign.Marshal.Pool.newPool1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c95UL: // global
           I64[Sp - 8] = block_c95UG_info;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95UG() //  [R1]
         { info_tbl: [(c95UG,
                       label: block_c95UG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95UG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95UO; else goto c95UN;
       c95UO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95UN: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.004182269 UTC

[section ""data" . Foreign.Marshal.Pool.newPool_closure" {
     Foreign.Marshal.Pool.newPool_closure:
         const Foreign.Marshal.Pool.newPool_info;
 },
 Foreign.Marshal.Pool.newPool_entry() //  []
         { info_tbl: [(c95UT,
                       label: Foreign.Marshal.Pool.newPool_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95UT: // global
           call Foreign.Marshal.Pool.newPool1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.007413056 UTC

[section ""data" . Foreign.Marshal.Pool.withPool1_closure" {
     Foreign.Marshal.Pool.withPool1_closure:
         const Foreign.Marshal.Pool.withPool1_info;
 },
 sat_s95sf_entry() //  [R1]
         { info_tbl: [(c95Ve,
                       label: sat_s95sf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Ve: // global
           _s95sf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c95Vf; else goto c95Vg;
       c95Vg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95Vi; else goto c95Vh;
       c95Vi: // global
           HpAlloc = 16;
           goto c95Vf;
       c95Vf: // global
           R1 = _s95sf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95Vh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s95sf::P64;
           _s95s3::P64 = P64[_s95sf::P64 + 16];
           _s95sd::P64 = P64[_s95sf::P64 + 24];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _s95sd::P64;
           R2 = Hp - 7;
           R1 = _s95s3::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s95st_entry() //  [R1]
         { info_tbl: [(c95VC,
                       label: sat_s95st_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95VC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c95VD; else goto c95VE;
       c95VD: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c95VE: // global
           _s95so::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp - 24] = block_c95VA_info;
           R2 = _s95so::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 24;
           call Foreign.Marshal.Pool.freePool2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c95VA() //  []
         { info_tbl: [(c95VA,
                       label: block_c95VA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95VA: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95su_entry() //  [R1, R2]
         { info_tbl: [(c95VG,
                       label: sat_s95su_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95VG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95VH; else goto c95VI;
       c95VH: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c95VI: // global
           I64[Sp - 16] = block_c95Vq_info;
           _s95sd::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _s95sd::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u95VM; else goto c95Vr;
       u95VM: // global
           call _c95Vq(R1) args: 0, res: 0, upd: 0;
       c95Vr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Vq() //  [R1]
         { info_tbl: [(c95Vq,
                       label: block_c95Vq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Vq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c95VL; else goto c95VK;
       c95VL: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95VK: // global
           _s95sj::P64 = P64[R1 + 7];
           _s95sk::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_s95st_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _s95sj::P64;
           P64[Hp] = _s95sk::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95sF_entry() //  [R2]
         { info_tbl: [(c95VU,
                       label: sat_s95sF_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95VU: // global
           R1 = R2;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95sZ_entry() //  [R1]
         { info_tbl: [(c95Wm,
                       label: sat_s95sZ_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Wm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c95Wn; else goto c95Wo;
       c95Wn: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c95Wo: // global
           _s95sU::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp - 24] = block_c95Wk_info;
           R2 = _s95sU::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 24;
           call Foreign.Marshal.Pool.freePool2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c95Wk() //  []
         { info_tbl: [(c95Wk,
                       label: block_c95Wk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Wk: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95t0_entry() //  [R1, R2]
         { info_tbl: [(c95Wq,
                       label: sat_s95t0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Wq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95Wr; else goto c95Ws;
       c95Wr: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c95Ws: // global
           I64[Sp - 16] = block_c95Wa_info;
           _s95sJ::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _s95sJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u95Ww; else goto c95Wb;
       u95Ww: // global
           call _c95Wa(R1) args: 0, res: 0, upd: 0;
       c95Wb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Wa() //  [R1]
         { info_tbl: [(c95Wa,
                       label: block_c95Wa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Wa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c95Wv; else goto c95Wu;
       c95Wv: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95Wu: // global
           _s95sP::P64 = P64[R1 + 7];
           _s95sQ::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_s95sZ_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _s95sP::P64;
           P64[Hp] = _s95sQ::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95sL_entry() //  [R1]
         { info_tbl: [(c95WC,
                       label: sat_s95sL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95WC: // global
           _s95sL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c95WD; else goto c95WE;
       c95WE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95WG; else goto c95WF;
       c95WG: // global
           HpAlloc = 16;
           goto c95WD;
       c95WD: // global
           R1 = _s95sL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95WF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s95sL::P64;
           _s95s3::P64 = P64[_s95sL::P64 + 16];
           _s95sJ::P64 = P64[_s95sL::P64 + 24];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _s95sJ::P64;
           R2 = Hp - 7;
           R1 = _s95s3::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s95sM_entry() //  [R1]
         { info_tbl: [(c95WM,
                       label: sat_s95sM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95WM: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95ta_entry() //  [R1]
         { info_tbl: [(c95WT,
                       label: sat_s95ta_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95WT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c95WU; else goto c95WV;
       c95WU: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c95WV: // global
           I64[Sp - 16] = block_c95W3_info;
           _s95s3::P64 = P64[R1 + 7];
           R1 = GHC.Types.[]_closure+1;
           P64[Sp - 8] = _s95s3::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95W3() //  [R1]
         { info_tbl: [(c95W3,
                       label: block_c95W3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95W3: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c95WY; else goto c95WX;
       c95WY: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95WX: // global
           I64[Hp - 56] = sat_s95t0_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = sat_s95sL_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s95sM_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c95WP_info;
           R2 = Hp - 55;
           _s95sJ::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _s95sJ::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95WP() //  [R1]
         { info_tbl: [(c95WP,
                       label: block_c95WP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95WP: // global
           _s95t6::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = block_c95WR_info;
           R2 = _s95t6::P64;
           P64[Sp + 8] = R1;
           call Foreign.Marshal.Pool.freePool2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c95WR() //  []
         { info_tbl: [(c95WR,
                       label: block_c95WR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95WR: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95tb_entry() //  [R2]
         { info_tbl: [(c95X7,
                       label: sat_s95tb_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95X7: // global
           R1 = R2;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Pool.withPool1_entry() //  [R2]
         { info_tbl: [(c95Xe,
                       label: Foreign.Marshal.Pool.withPool1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Xe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c95Xf; else goto c95Xg;
       c95Xf: // global
           R2 = R2;
           R1 = Foreign.Marshal.Pool.withPool1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c95Xg: // global
           I64[Sp - 16] = block_c95V0_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c95V0() //  [R1]
         { info_tbl: [(c95V0,
                       label: block_c95V0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95V0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95Xj; else goto c95Xi;
       c95Xj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c95Xi: // global
           if (R1 == 0) goto c95Xc; else goto u95Xx;
       c95Xc: // global
           I64[Hp - 8] = sat_s95ta_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       u95Xx: // global
           if (R1 == 1) goto c95Xd; else goto c95Xb;
       c95Xd: // global
           I64[Hp - 8] = sat_s95tb_info;
           _s95s9::P64 = Hp - 6;
           goto s95s8;
       c95Xb: // global
           I64[Hp - 8] = sat_s95sF_info;
           _s95s9::P64 = Hp - 6;
           goto s95s8;
       s95s8: // global
           I64[Sp - 8] = block_c95V7_info;
           R1 = GHC.Types.[]_closure+1;
           P64[Sp] = _s95s9::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95V7() //  [R1]
         { info_tbl: [(c95V7,
                       label: block_c95V7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95V7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c95Xq; else goto c95Xp;
       c95Xq: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95Xp: // global
           I64[Hp - 24] = sat_s95sf_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           _s95s9::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c95Vj_info;
           R2 = Hp - 24;
           _s95sd::P64 = R1;
           R1 = _s95s9::P64;
           P64[Sp + 16] = _s95sd::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Vj() //  [R1]
         { info_tbl: [(c95Vj,
                       label: block_c95Vj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Vj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95Xt; else goto c95Xs;
       c95Xt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95Xs: // global
           I64[Hp - 8] = sat_s95su_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_c95Xk_info;
           R2 = Hp - 7;
           R1 = R1;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95Xk() //  [R1]
         { info_tbl: [(c95Xk,
                       label: block_c95Xk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Xk: // global
           _s95sA::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = block_c95Xm_info;
           R2 = _s95sA::P64;
           P64[Sp + 8] = R1;
           call Foreign.Marshal.Pool.freePool2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c95Xm() //  []
         { info_tbl: [(c95Xm,
                       label: block_c95Xm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Xm: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.014149653 UTC

[section ""data" . Foreign.Marshal.Pool.withPool_closure" {
     Foreign.Marshal.Pool.withPool_closure:
         const Foreign.Marshal.Pool.withPool_info;
 },
 Foreign.Marshal.Pool.withPool_entry() //  [R2]
         { info_tbl: [(c95XC,
                       label: Foreign.Marshal.Pool.withPool_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95XC: // global
           R2 = R2;
           call Foreign.Marshal.Pool.withPool1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.014851791 UTC

[section ""relreadonly" . S95uu_srt" {
     S95uu_srt:
         const Foreign.Marshal.Error.throwIf2_closure;
         const Foreign.Marshal.Alloc.realloc2_closure;
         const Foreign.Marshal.Pool.$wpooledReallocBytes_closure;
         const Foreign.Marshal.Pool.pooledRealloc1_closure;
         const GHC.Err.undefined_closure;
         const lvl11_r95nf_closure;
         const Foreign.Marshal.Pool.pooledReallocArray1_closure;
         const Foreign.Marshal.Pool.pooledReallocArray_closure;
         const Foreign.Marshal.Pool.pooledReallocArray2_closure;
         const lvl16_r95nk_closure;
         const Foreign.Marshal.Pool.pooledRealloc3_closure;
         const Foreign.Marshal.Pool.pooledRealloc_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Pool.pooledMallocBytes1_closure;
         const lvl21_r95np_closure;
         const Foreign.Marshal.Pool.pooledMallocArray1_closure;
         const Foreign.Marshal.Pool.pooledMallocArray_closure;
         const Foreign.Marshal.Pool.$wpooledMallocArray0_closure;
         const Foreign.Marshal.Pool.pooledMallocArray2_closure;
         const lvl26_r95nu_closure;
         const Foreign.Marshal.Pool.pooledMalloc1_closure;
         const Foreign.Marshal.Pool.pooledMalloc_closure;
         const Foreign.Marshal.Pool.pooledNewArray2_closure;
         const Foreign.Marshal.Pool.pooledNewArray1_closure;
         const Foreign.Marshal.Pool.pooledNew1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.015805398 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:04:15.016937564 UTC

[section ""cstring" . Foreign.Marshal.Pool.$trModule4_bytes" {
     Foreign.Marshal.Pool.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.018709091 UTC

[section ""data" . Foreign.Marshal.Pool.$trModule3_closure" {
     Foreign.Marshal.Pool.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Pool.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.020491016 UTC

[section ""cstring" . Foreign.Marshal.Pool.$trModule2_bytes" {
     Foreign.Marshal.Pool.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,80,111,111,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.022353685 UTC

[section ""data" . Foreign.Marshal.Pool.$trModule1_closure" {
     Foreign.Marshal.Pool.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Pool.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.024608924 UTC

[section ""data" . Foreign.Marshal.Pool.$trModule_closure" {
     Foreign.Marshal.Pool.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Marshal.Pool.$trModule3_closure+1;
         const Foreign.Marshal.Pool.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.026333379 UTC

[section ""data" . $krep_r95mW_closure" {
     $krep_r95mW_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.028015912 UTC

[section ""data" . $krep1_r95mX_closure" {
     $krep1_r95mX_closure:
         const :_con_info;
         const $krep_r95mW_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.029733581 UTC

[section ""data" . $krep2_r95mY_closure" {
     $krep2_r95mY_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Ptr.$tcPtr_closure;
         const $krep1_r95mX_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.031474455 UTC

[section ""data" . $krep3_r95mZ_closure" {
     $krep3_r95mZ_closure:
         const :_con_info;
         const $krep2_r95mY_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.033093969 UTC

[section ""data" . $krep4_r95n0_closure" {
     $krep4_r95n0_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep3_r95mZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.034886984 UTC

[section ""data" . $krep5_r95n1_closure" {
     $krep5_r95n1_closure:
         const :_con_info;
         const $krep4_r95n0_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.036642851 UTC

[section ""data" . $krep6_r95n2_closure" {
     $krep6_r95n2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep5_r95n1_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.039155713 UTC

[section ""cstring" . Foreign.Marshal.Pool.$tcPool2_bytes" {
     Foreign.Marshal.Pool.$tcPool2_bytes:
         I8[] [80,111,111,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.040834122 UTC

[section ""data" . Foreign.Marshal.Pool.$tcPool1_closure" {
     Foreign.Marshal.Pool.$tcPool1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Pool.$tcPool2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.043073988 UTC

[section ""data" . Foreign.Marshal.Pool.$tcPool_closure" {
     Foreign.Marshal.Pool.$tcPool_closure:
         const GHC.Types.TyCon_con_info;
         const Foreign.Marshal.Pool.$trModule_closure+1;
         const Foreign.Marshal.Pool.$tcPool1_closure+1;
         const GHC.Types.krep$*_closure;
         const 6812857741828992361;
         const 12127662557529231519;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.044924235 UTC

[section ""data" . $krep7_r95n3_closure" {
     $krep7_r95n3_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.Marshal.Pool.$tcPool_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.046685915 UTC

[section ""data" . Foreign.Marshal.Pool.$tc'Pool1_closure" {
     Foreign.Marshal.Pool.$tc'Pool1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r95n2_closure+1;
         const $krep7_r95n3_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.048393231 UTC

[section ""cstring" . Foreign.Marshal.Pool.$tc'Pool3_bytes" {
     Foreign.Marshal.Pool.$tc'Pool3_bytes:
         I8[] [39,80,111,111,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.05080568 UTC

[section ""data" . Foreign.Marshal.Pool.$tc'Pool2_closure" {
     Foreign.Marshal.Pool.$tc'Pool2_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Pool.$tc'Pool3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.052513611 UTC

[section ""data" . Foreign.Marshal.Pool.$tc'Pool_closure" {
     Foreign.Marshal.Pool.$tc'Pool_closure:
         const GHC.Types.TyCon_con_info;
         const Foreign.Marshal.Pool.$trModule_closure+1;
         const Foreign.Marshal.Pool.$tc'Pool2_closure+1;
         const Foreign.Marshal.Pool.$tc'Pool1_closure+4;
         const 11588816997626637361;
         const 15405086111208545194;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.05475443 UTC

[section ""cstring" . lvl_r95n4_bytes" {
     lvl_r95n4_bytes:
         I8[] [112,111,105,110,116,101,114,32,110,111,116,32,105,110,32,112,111,111,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.056555258 UTC

[section ""data" . Foreign.Marshal.Pool.pooledRealloc2_closure" {
     Foreign.Marshal.Pool.pooledRealloc2_closure:
         const Foreign.Marshal.Pool.pooledRealloc2_info;
 },
 Foreign.Marshal.Pool.pooledRealloc2_entry() //  []
         { info_tbl: [(c95Y4,
                       label: Foreign.Marshal.Pool.pooledRealloc2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Y4: // global
           R2 = lvl_r95n4_bytes;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.0613854 UTC

[section ""data" . Foreign.Marshal.Pool.$wpooledReallocBytes_closure" {
     Foreign.Marshal.Pool.$wpooledReallocBytes_closure:
         const Foreign.Marshal.Pool.$wpooledReallocBytes_info;
         const 0;
 },
 sat_s95nT_entry() //  [R1]
         { info_tbl: [(c95YC,
                       label: sat_s95nT_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95YC: // global
           _s95nT::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c95YD; else goto c95YE;
       c95YE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95YG; else goto c95YF;
       c95YG: // global
           HpAlloc = 16;
           goto c95YD;
       c95YD: // global
           R1 = _s95nT::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95YF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s95nT::P64;
           _s95nQ::P64 = P64[_s95nT::P64 + 16];
           _s95ny::I64 = I64[_s95nT::P64 + 24];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s95ny::I64;
           R4 = _s95nQ::P64;
           R3 = Hp - 7;
           R2 = GHC.Ptr.$fEqPtr_$c==_closure+2;
           Sp = Sp - 16;
           call Data.OldList.deleteBy_entry(R4,
                                            R3,
                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s95o4_entry() //  [R1]
         { info_tbl: [(c95YP,
                       label: sat_s95o4_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95YP: // global
           _s95o4::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c95YQ; else goto c95YR;
       c95YR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95YT; else goto c95YS;
       c95YT: // global
           HpAlloc = 16;
           goto c95YQ;
       c95YQ: // global
           R1 = _s95o4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c95YS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s95o4::P64;
           _s95o2::P64 = P64[_s95o4::P64 + 16];
           _s95ny::I64 = I64[_s95o4::P64 + 24];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s95ny::I64;
           R4 = _s95o2::P64;
           R3 = Hp - 7;
           R2 = GHC.Ptr.$fEqPtr_$c==_closure+2;
           Sp = Sp - 16;
           call Data.OldList.deleteBy_entry(R4,
                                            R3,
                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Pool.$wpooledReallocBytes_entry() //  [R2, R3, R4]
         { info_tbl: [(c95YY,
                       label: Foreign.Marshal.Pool.$wpooledReallocBytes_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 20} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95YY: // global
           _s95nz::I64 = R4;
           _s95ny::I64 = R3;
           _s95nx::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto c95YZ; else goto c95Z0;
       c95Z0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c95Z2; else goto c95Z1;
       c95Z2: // global
           HpAlloc = 16;
           goto c95YZ;
       c95YZ: // global
           R4 = _s95nz::I64;
           R3 = _s95ny::I64;
           R2 = _s95nx::P64;
           R1 = Foreign.Marshal.Pool.$wpooledReallocBytes_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c95Z1: // global
           _s95nD::P64 = P64[_s95nx::P64 + 8];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s95ny::I64;
           I64[Sp - 40] = block_c95Yg_info;
           R4 = _s95nD::P64;
           R3 = Hp - 7;
           R2 = GHC.Ptr.$fEqPtr_closure;
           P64[Sp - 32] = _s95nx::P64;
           I64[Sp - 24] = _s95ny::I64;
           I64[Sp - 16] = _s95nz::I64;
           P64[Sp - 8] = _s95nD::P64;
           Sp = Sp - 40;
           call GHC.List.elem_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c95Yg() //  [R1]
         { info_tbl: [(c95Yg,
                       label: block_c95Yg_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95Yg: // global
           if (R1 & 7 == 1) goto c95YV; else goto c95YW;
       c95YV: // global
           R3 = Foreign.Marshal.Pool.pooledRealloc2_closure+1;
           R2 = P64[Sp + 32];
           Sp = Sp + 40;
           call Foreign.Marshal.Error.throwIf2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c95YW: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c95Z7; else goto c95Z6;
       c95Z7: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c95Z6: // global
           _s95nx::P64 = P64[Sp + 8];
           _s95ny::I64 = I64[Sp + 16];
           _s95nH::I64 = I64[Sp + 24];
           if (_s95nH::I64 != 0) goto c95Zc; else goto c95Zd;
       c95Zc: // global
           (_s95nM::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(_s95ny::I64, _s95nH::I64);
           if (_s95nM::I64 == 0) goto c95Za; else goto c95Z9;
       c95Za: // global
           Hp = Hp - 72;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c95Z9: // global
           _s95nQ::P64 = P64[_s95nx::P64 + 8];
           I64[Hp - 64] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 56] = _s95nM::I64;
           I64[Hp - 48] = sat_s95nT_info;
           P64[Hp - 32] = _s95nQ::P64;
           I64[Hp - 24] = _s95ny::I64;
           I64[Hp - 16] = :_con_info;
           _c95Yw::P64 = Hp - 63;
           P64[Hp - 8] = _c95Yw::P64;
           P64[Hp] = Hp - 48;
           call MO_WriteBarrier();
           P64[_s95nx::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95nx::P64);
           R1 = _c95Yw::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c95Zd: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(_s95ny::I64);
           _s95o2::P64 = P64[_s95nx::P64 + 8];
           I64[Hp - 64] = sat_s95o4_info;
           P64[Hp - 48] = _s95o2::P64;
           I64[Hp - 40] = _s95ny::I64;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Ptr.nullPtr_closure;
           P64[Hp - 16] = Hp - 64;
           call MO_WriteBarrier();
           P64[_s95nx::P64 + 8] = Hp - 30;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95nx::P64);
           Hp = Hp - 16;
           R1 = GHC.Ptr.nullPtr_closure;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.074981215 UTC

[section ""data" . Foreign.Marshal.Pool.pooledRealloc1_closure" {
     Foreign.Marshal.Pool.pooledRealloc1_closure:
         const Foreign.Marshal.Pool.pooledRealloc1_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledRealloc1_entry() //  [R2, R3, R4]
         { info_tbl: [(c95ZU,
                       label: Foreign.Marshal.Pool.pooledRealloc1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95ZU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c9603; else goto c9604;
       c9603: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledRealloc1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c9604: // global
           I64[Sp - 24] = block_c95ZR_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u960d; else goto c95ZS;
       u960d: // global
           call _c95ZR(R1) args: 0, res: 0, upd: 0;
       c95ZS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95ZR() //  [R1]
         { info_tbl: [(c95ZR,
                       label: block_c95ZR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95ZR: // global
           I64[Sp] = block_c95ZX_info;
           _s95oc::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s95oc::P64;
           if (R1 & 7 != 0) goto u960c; else goto c95ZY;
       u960c: // global
           call _c95ZX(R1) args: 0, res: 0, upd: 0;
       c95ZY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c95ZX() //  [R1]
         { info_tbl: [(c95ZX,
                       label: block_c95ZX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c95ZX: // global
           I64[Sp] = block_c9602_info;
           _s95oe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s95oe::I64;
           if (R1 & 7 != 0) goto u960e; else goto c9607;
       u960e: // global
           call _c9602(R1) args: 0, res: 0, upd: 0;
       c9607: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9602() //  [R1]
         { info_tbl: [(c9602,
                       label: block_c9602_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9602: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Pool.$wpooledReallocBytes_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.08429548 UTC

[section ""data" . Foreign.Marshal.Pool.pooledReallocBytes_closure" {
     Foreign.Marshal.Pool.pooledReallocBytes_closure:
         const Foreign.Marshal.Pool.pooledReallocBytes_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledReallocBytes_entry() //  [R2, R3, R4]
         { info_tbl: [(c960A,
                       label: Foreign.Marshal.Pool.pooledReallocBytes_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c960A: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledRealloc1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.087998332 UTC

[section ""cstring" . lvl1_r95n5_bytes" {
     lvl1_r95n5_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.090352253 UTC

[section ""data" . lvl2_r95n6_closure" {
     lvl2_r95n6_closure:
         const lvl2_r95n6_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r95n6_entry() //  [R1]
         { info_tbl: [(c960O,
                       label: lvl2_r95n6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c960O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c960P; else goto c960Q;
       c960P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c960Q: // global
           (_c960L::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c960L::I64 == 0) goto c960N; else goto c960M;
       c960N: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c960M: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c960L::I64;
           R2 = lvl1_r95n5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.094305557 UTC

[section ""data" . lvl3_r95n7_closure" {
     lvl3_r95n7_closure:
         const lvl3_r95n7_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r95n7_entry() //  [R1]
         { info_tbl: [(c9614,
                       label: lvl3_r95n7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9614: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c9615; else goto c9616;
       c9615: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9616: // global
           (_c9611::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c9611::I64 == 0) goto c9613; else goto c9612;
       c9613: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c9612: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c9611::I64;
           R2 = Foreign.Marshal.Pool.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.098523552 UTC

[section ""data" . lvl4_r95n8_closure" {
     lvl4_r95n8_closure:
         const lvl4_r95n8_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r95n8_entry() //  [R1]
         { info_tbl: [(c961k,
                       label: lvl4_r95n8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c961k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c961l; else goto c961m;
       c961l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c961m: // global
           (_c961h::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c961h::I64 == 0) goto c961j; else goto c961i;
       c961j: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c961i: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c961h::I64;
           R2 = Foreign.Marshal.Pool.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.102788073 UTC

[section ""cstring" . lvl5_r95n9_bytes" {
     lvl5_r95n9_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,77,97,114,115,104,97,108,47,80,111,111,108,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.104636344 UTC

[section ""data" . lvl6_r95na_closure" {
     lvl6_r95na_closure:
         const lvl6_r95na_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r95na_entry() //  [R1]
         { info_tbl: [(c961B,
                       label: lvl6_r95na_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c961B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c961C; else goto c961D;
       c961C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c961D: // global
           (_c961y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c961y::I64 == 0) goto c961A; else goto c961z;
       c961A: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c961z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c961y::I64;
           R2 = lvl5_r95n9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.108420125 UTC

[section ""data" . lvl7_r95nb_closure" {
     lvl7_r95nb_closure:
         const GHC.Types.I#_con_info;
         const 159;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.110068661 UTC

[section ""data" . lvl8_r95nc_closure" {
     lvl8_r95nc_closure:
         const GHC.Types.I#_con_info;
         const 26;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.111728317 UTC

[section ""data" . lvl9_r95nd_closure" {
     lvl9_r95nd_closure:
         const GHC.Types.I#_con_info;
         const 35;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.113473472 UTC

[section ""data" . lvl10_r95ne_closure" {
     lvl10_r95ne_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_r95n7_closure;
         const lvl4_r95n8_closure;
         const lvl6_r95na_closure;
         const lvl7_r95nb_closure+1;
         const lvl8_r95nc_closure+1;
         const lvl7_r95nb_closure+1;
         const lvl9_r95nd_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.11535023 UTC

[section ""data" . lvl11_r95nf_closure" {
     lvl11_r95nf_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_r95n6_closure;
         const lvl10_r95ne_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.118047886 UTC

[section ""data" . Foreign.Marshal.Pool.pooledReallocArray1_closure" {
     Foreign.Marshal.Pool.pooledReallocArray1_closure:
         const Foreign.Marshal.Pool.pooledReallocArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Pool.pooledReallocArray1_entry() //  [R1]
         { info_tbl: [(c961W,
                       label: Foreign.Marshal.Pool.pooledReallocArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c961W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c961X; else goto c961Y;
       c961X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c961Y: // global
           (_c961T::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c961T::I64 == 0) goto c961V; else goto c961U;
       c961V: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c961U: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c961T::I64;
           R2 = lvl11_r95nf_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.122784167 UTC

[section ""data" . Foreign.Marshal.Pool.pooledReallocArray_closure" {
     Foreign.Marshal.Pool.pooledReallocArray_closure:
         const Foreign.Marshal.Pool.pooledReallocArray_info;
         const 0;
 },
 lvl27_s95oi_entry() //  [R1]
         { info_tbl: [(c962e,
                       label: lvl27_s95oi_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c962e: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c962f; else goto c962g;
       c962f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c962g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Pool.pooledReallocArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s95ow_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c962p,
                       label: sat_s95ow_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c962p: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c962D; else goto c962E;
       c962D: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c962E: // global
           I64[Sp - 32] = block_c962m_info;
           _s95oi::P64 = P64[R1 + 4];
           R1 = R2;
           P64[Sp - 24] = _s95oi::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u962P; else goto c962n;
       u962P: // global
           call _c962m(R1) args: 0, res: 0, upd: 0;
       c962n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c962m() //  [R1]
         { info_tbl: [(c962m,
                       label: block_c962m_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c962m: // global
           I64[Sp] = block_c962s_info;
           _s95oo::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s95oo::P64;
           if (R1 & 7 != 0) goto u962O; else goto c962t;
       u962O: // global
           call _c962s(R1) args: 0, res: 0, upd: 0;
       c962t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c962s() //  [R1]
         { info_tbl: [(c962s,
                       label: block_c962s_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c962s: // global
           I64[Sp] = block_c962x_info;
           _s95oq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s95oq::I64;
           if (R1 & 7 != 0) goto u962Q; else goto c962y;
       u962Q: // global
           call _c962x(R1) args: 0, res: 0, upd: 0;
       c962y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c962x() //  [R1]
         { info_tbl: [(c962x,
                       label: block_c962x_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c962x: // global
           I64[Sp] = block_c962C_info;
           _s95os::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s95os::I64;
           if (R1 & 7 != 0) goto u962R; else goto c962I;
       u962R: // global
           call _c962C(R1) args: 0, res: 0, upd: 0;
       c962I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c962C() //  [R1]
         { info_tbl: [(c962C,
                       label: block_c962C_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c962C: // global
           R4 = I64[Sp + 8] * I64[R1 + 7];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Foreign.Marshal.Pool.$wpooledReallocBytes_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Pool.pooledReallocArray_entry() //  [R2]
         { info_tbl: [(c962S,
                       label: Foreign.Marshal.Pool.pooledReallocArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c962S: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c962W; else goto c962V;
       c962W: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledReallocArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c962V: // global
           I64[Hp - 32] = lvl27_s95oi_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s95ow_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.138869855 UTC

[section ""data" . Foreign.Marshal.Pool.pooledReallocArray2_closure" {
     Foreign.Marshal.Pool.pooledReallocArray2_closure:
         const Foreign.Marshal.Pool.pooledReallocArray2_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledReallocArray2_entry() //  [R2, R3, R4,
                                                       R5]
         { info_tbl: [(c963A,
                       label: Foreign.Marshal.Pool.pooledReallocArray2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c963A: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c963O; else goto c963P;
       c963O: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledReallocArray2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c963P: // global
           I64[Sp - 32] = block_c963x_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u9642; else goto c963y;
       u9642: // global
           call _c963x(R1) args: 0, res: 0, upd: 0;
       c963y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c963x() //  [R1]
         { info_tbl: [(c963x,
                       label: block_c963x_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c963x: // global
           I64[Sp] = block_c963D_info;
           _s95oD::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s95oD::P64;
           if (R1 & 7 != 0) goto u9641; else goto c963E;
       u9641: // global
           call _c963D(R1) args: 0, res: 0, upd: 0;
       c963E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c963D() //  [R1]
         { info_tbl: [(c963D,
                       label: block_c963D_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c963D: // global
           I64[Sp] = block_c963I_info;
           _s95oF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s95oF::I64;
           if (R1 & 7 != 0) goto u9643; else goto c963J;
       u9643: // global
           call _c963I(R1) args: 0, res: 0, upd: 0;
       c963J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c963I() //  [R1]
         { info_tbl: [(c963I,
                       label: block_c963I_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c963I: // global
           I64[Sp] = block_c963N_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Foreign.Marshal.Pool.pooledReallocArray1_closure;
           I64[Sp + 8] = I64[R1 + 7];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c963N() //  [R1]
         { info_tbl: [(c963N,
                       label: block_c963N_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c963N: // global
           R4 = (I64[Sp + 8] + 1) * I64[R1 + 7];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Foreign.Marshal.Pool.$wpooledReallocBytes_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.150227218 UTC

[section ""data" . Foreign.Marshal.Pool.pooledReallocArray0_closure" {
     Foreign.Marshal.Pool.pooledReallocArray0_closure:
         const Foreign.Marshal.Pool.pooledReallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledReallocArray0_entry() //  [R2, R3, R4,
                                                       R5]
         { info_tbl: [(c964w,
                       label: Foreign.Marshal.Pool.pooledReallocArray0_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c964w: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledReallocArray2_entry(R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.153506348 UTC

[section ""data" . lvl12_r95ng_closure" {
     lvl12_r95ng_closure:
         const GHC.Types.I#_con_info;
         const 124;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.155138744 UTC

[section ""data" . lvl13_r95nh_closure" {
     lvl13_r95nh_closure:
         const GHC.Types.I#_con_info;
         const 20;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.156776123 UTC

[section ""data" . lvl14_r95ni_closure" {
     lvl14_r95ni_closure:
         const GHC.Types.I#_con_info;
         const 29;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.15847494 UTC

[section ""data" . lvl15_r95nj_closure" {
     lvl15_r95nj_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_r95n7_closure;
         const lvl4_r95n8_closure;
         const lvl6_r95na_closure;
         const lvl12_r95ng_closure+1;
         const lvl13_r95nh_closure+1;
         const lvl12_r95ng_closure+1;
         const lvl14_r95ni_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.160280347 UTC

[section ""data" . lvl16_r95nk_closure" {
     lvl16_r95nk_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_r95n6_closure;
         const lvl15_r95nj_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.162507011 UTC

[section ""data" . Foreign.Marshal.Pool.pooledRealloc3_closure" {
     Foreign.Marshal.Pool.pooledRealloc3_closure:
         const Foreign.Marshal.Pool.pooledRealloc3_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Pool.pooledRealloc3_entry() //  [R1]
         { info_tbl: [(c964O,
                       label: Foreign.Marshal.Pool.pooledRealloc3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c964O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c964P; else goto c964Q;
       c964P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c964Q: // global
           (_c964L::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c964L::I64 == 0) goto c964N; else goto c964M;
       c964N: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c964M: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c964L::I64;
           R2 = lvl16_r95nk_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.167362432 UTC

[section ""data" . Foreign.Marshal.Pool.pooledRealloc_closure" {
     Foreign.Marshal.Pool.pooledRealloc_closure:
         const Foreign.Marshal.Pool.pooledRealloc_info;
         const 0;
 },
 lvl27_s95oN_entry() //  [R1]
         { info_tbl: [(c9656,
                       label: lvl27_s95oN_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9656: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9657; else goto c9658;
       c9657: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9658: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Pool.pooledRealloc3_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s95oR_entry() //  [R1, R2, R3]
         { info_tbl: [(c965e,
                       label: sat_s95oR_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c965e: // global
           R4 = P64[R1 + 5];
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledRealloc1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Pool.pooledRealloc_entry() //  [R2]
         { info_tbl: [(c965h,
                       label: Foreign.Marshal.Pool.pooledRealloc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c965h: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c965l; else goto c965k;
       c965l: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledRealloc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c965k: // global
           I64[Hp - 32] = lvl27_s95oN_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s95oR_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.174929803 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocBytes1_closure" {
     Foreign.Marshal.Pool.pooledMallocBytes1_closure:
         const Foreign.Marshal.Pool.pooledMallocBytes1_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMallocBytes1_entry() //  [R2, R3]
         { info_tbl: [(c965G,
                       label: Foreign.Marshal.Pool.pooledMallocBytes1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c965G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c965H; else goto c965I;
       c965H: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledMallocBytes1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c965I: // global
           I64[Sp - 16] = block_c965D_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u966b; else goto c965E;
       u966b: // global
           call _c965D(R1) args: 0, res: 0, upd: 0;
       c965E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c965D() //  [R1]
         { info_tbl: [(c965D,
                       label: block_c965D_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c965D: // global
           _s95oS::P64 = P64[Sp + 8];
           (_s95p1::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s95p1::I64 == 0) goto c9665; else goto c9661;
       c9665: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c9661: // global
           I64[Sp] = block_c965U_info;
           R1 = _s95oS::P64;
           I64[Sp + 8] = _s95p1::I64;
           if (R1 & 7 != 0) goto u966a; else goto c965V;
       u966a: // global
           call _c965U(R1) args: 0, res: 0, upd: 0;
       c965V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c965U() //  [R1]
         { info_tbl: [(c965U,
                       label: block_c965U_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c965U: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9664; else goto c9663;
       c9664: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9663: // global
           _s95p4::P64 = P64[R1 + 7];
           _s95p7::P64 = P64[_s95p4::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           _c965Z::P64 = Hp - 31;
           P64[Hp - 8] = _c965Z::P64;
           P64[Hp] = _s95p7::P64;
           call MO_WriteBarrier();
           P64[_s95p4::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95p4::P64);
           R1 = _c965Z::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.184610597 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocBytes_closure" {
     Foreign.Marshal.Pool.pooledMallocBytes_closure:
         const Foreign.Marshal.Pool.pooledMallocBytes_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMallocBytes_entry() //  [R2, R3]
         { info_tbl: [(c966x,
                       label: Foreign.Marshal.Pool.pooledMallocBytes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c966x: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledMallocBytes1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.187868113 UTC

[section ""data" . lvl17_r95nl_closure" {
     lvl17_r95nl_closure:
         const GHC.Types.I#_con_info;
         const 144;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.189816642 UTC

[section ""data" . lvl18_r95nm_closure" {
     lvl18_r95nm_closure:
         const GHC.Types.I#_con_info;
         const 25;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.191479383 UTC

[section ""data" . lvl19_r95nn_closure" {
     lvl19_r95nn_closure:
         const GHC.Types.I#_con_info;
         const 34;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.193190083 UTC

[section ""data" . lvl20_r95no_closure" {
     lvl20_r95no_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_r95n7_closure;
         const lvl4_r95n8_closure;
         const lvl6_r95na_closure;
         const lvl17_r95nl_closure+1;
         const lvl18_r95nm_closure+1;
         const lvl17_r95nl_closure+1;
         const lvl19_r95nn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.195475865 UTC

[section ""data" . lvl21_r95np_closure" {
     lvl21_r95np_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_r95n6_closure;
         const lvl20_r95no_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.197468906 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocArray1_closure" {
     Foreign.Marshal.Pool.pooledMallocArray1_closure:
         const Foreign.Marshal.Pool.pooledMallocArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMallocArray1_entry() //  [R1]
         { info_tbl: [(c966P,
                       label: Foreign.Marshal.Pool.pooledMallocArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c966P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c966Q; else goto c966R;
       c966Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c966R: // global
           (_c966M::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c966M::I64 == 0) goto c966O; else goto c966N;
       c966O: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c966N: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c966M::I64;
           R2 = lvl21_r95np_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.202693636 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocArray_closure" {
     Foreign.Marshal.Pool.pooledMallocArray_closure:
         const Foreign.Marshal.Pool.pooledMallocArray_info;
         const 0;
 },
 lvl27_s95pd_entry() //  [R1]
         { info_tbl: [(c9677,
                       label: lvl27_s95pd_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9677: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9678; else goto c9679;
       c9678: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9679: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Pool.pooledMallocArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s95pB_entry() //  [R1, R2, R3]
         { info_tbl: [(c967i,
                       label: sat_s95pB_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c967i: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c967m; else goto c967n;
       c967m: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c967n: // global
           I64[Sp - 24] = block_c967f_info;
           _s95pd::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s95pd::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u967W; else goto c967g;
       u967W: // global
           call _c967f(R1) args: 0, res: 0, upd: 0;
       c967g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c967f() //  [R1]
         { info_tbl: [(c967f,
                       label: block_c967f_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c967f: // global
           I64[Sp] = block_c967l_info;
           _s95pi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s95pi::I64;
           if (R1 & 7 != 0) goto u967V; else goto c967p;
       u967V: // global
           call _c967l(R1) args: 0, res: 0, upd: 0;
       c967p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c967l() //  [R1]
         { info_tbl: [(c967l,
                       label: block_c967l_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c967l: // global
           _s95pe::P64 = P64[Sp + 16];
           (_s95pq::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[Sp + 8] * I64[R1 + 7]);
           if (_s95pq::I64 == 0) goto c967Q; else goto c967M;
       c967Q: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c967M: // global
           I64[Sp + 8] = block_c967F_info;
           R1 = _s95pe::P64;
           I64[Sp + 16] = _s95pq::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u967X; else goto c967G;
       u967X: // global
           call _c967F(R1) args: 0, res: 0, upd: 0;
       c967G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c967F() //  [R1]
         { info_tbl: [(c967F,
                       label: block_c967F_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c967F: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c967P; else goto c967O;
       c967P: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c967O: // global
           _s95pt::P64 = P64[R1 + 7];
           _s95pw::P64 = P64[_s95pt::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           _c967K::P64 = Hp - 31;
           P64[Hp - 8] = _c967K::P64;
           P64[Hp] = _s95pw::P64;
           call MO_WriteBarrier();
           P64[_s95pt::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95pt::P64);
           R1 = _c967K::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Pool.pooledMallocArray_entry() //  [R2]
         { info_tbl: [(c967Y,
                       label: Foreign.Marshal.Pool.pooledMallocArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c967Y: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9682; else goto c9681;
       c9682: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledMallocArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9681: // global
           I64[Hp - 32] = lvl27_s95pd_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s95pB_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.217905722 UTC

[section ""data" . Foreign.Marshal.Pool.$wpooledMallocArray0_closure" {
     Foreign.Marshal.Pool.$wpooledMallocArray0_closure:
         const Foreign.Marshal.Pool.$wpooledMallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Pool.$wpooledMallocArray0_entry() //  [R2, R3, R4]
         { info_tbl: [(c968F,
                       label: Foreign.Marshal.Pool.$wpooledMallocArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c968F: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c968G; else goto c968H;
       c968G: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.$wpooledMallocArray0_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c968H: // global
           I64[Sp - 24] = block_c968D_info;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = Foreign.Marshal.Pool.pooledMallocArray1_closure;
           P64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c968D() //  [R1]
         { info_tbl: [(c968D,
                       label: block_c968D_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c968D: // global
           _s95pD::P64 = P64[Sp + 8];
           (_s95pO::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc((I64[Sp + 16] + 1) * I64[R1 + 7]);
           if (_s95pO::I64 == 0) goto c969a; else goto c9696;
       c969a: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c9696: // global
           I64[Sp + 8] = block_c968Z_info;
           R1 = _s95pD::P64;
           I64[Sp + 16] = _s95pO::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u969f; else goto c9690;
       u969f: // global
           call _c968Z(R1) args: 0, res: 0, upd: 0;
       c9690: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c968Z() //  [R1]
         { info_tbl: [(c968Z,
                       label: block_c968Z_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c968Z: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9699; else goto c9698;
       c9699: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9698: // global
           _s95pR::P64 = P64[R1 + 7];
           _s95pU::P64 = P64[_s95pR::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           _c9694::P64 = Hp - 31;
           P64[Hp - 8] = _c9694::P64;
           P64[Hp] = _s95pU::P64;
           call MO_WriteBarrier();
           P64[_s95pR::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95pR::P64);
           R1 = _c9694::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.227147467 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocArray2_closure" {
     Foreign.Marshal.Pool.pooledMallocArray2_closure:
         const Foreign.Marshal.Pool.pooledMallocArray2_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMallocArray2_entry() //  [R2, R3, R4]
         { info_tbl: [(c969G,
                       label: Foreign.Marshal.Pool.pooledMallocArray2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c969G: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c969H; else goto c969I;
       c969H: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledMallocArray2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c969I: // global
           I64[Sp - 24] = block_c969D_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u969M; else goto c969E;
       u969M: // global
           call _c969D(R1) args: 0, res: 0, upd: 0;
       c969E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c969D() //  [R1]
         { info_tbl: [(c969D,
                       label: block_c969D_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c969D: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Pool.$wpooledMallocArray0_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.232693851 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocArray0_closure" {
     Foreign.Marshal.Pool.pooledMallocArray0_closure:
         const Foreign.Marshal.Pool.pooledMallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMallocArray0_entry() //  [R2, R3, R4]
         { info_tbl: [(c96a0,
                       label: Foreign.Marshal.Pool.pooledMallocArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96a0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledMallocArray2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.235887438 UTC

[section ""data" . lvl22_r95nq_closure" {
     lvl22_r95nq_closure:
         const GHC.Types.I#_con_info;
         const 106;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.237881036 UTC

[section ""data" . lvl23_r95nr_closure" {
     lvl23_r95nr_closure:
         const GHC.Types.I#_con_info;
         const 19;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.23953663 UTC

[section ""data" . lvl24_r95ns_closure" {
     lvl24_r95ns_closure:
         const GHC.Types.I#_con_info;
         const 28;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.241700415 UTC

[section ""data" . lvl25_r95nt_closure" {
     lvl25_r95nt_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_r95n7_closure;
         const lvl4_r95n8_closure;
         const lvl6_r95na_closure;
         const lvl22_r95nq_closure+1;
         const lvl23_r95nr_closure+1;
         const lvl22_r95nq_closure+1;
         const lvl24_r95ns_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.243524709 UTC

[section ""data" . lvl26_r95nu_closure" {
     lvl26_r95nu_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_r95n6_closure;
         const lvl25_r95nt_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.24552023 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMalloc1_closure" {
     Foreign.Marshal.Pool.pooledMalloc1_closure:
         const Foreign.Marshal.Pool.pooledMalloc1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMalloc1_entry() //  [R1]
         { info_tbl: [(c96ai,
                       label: Foreign.Marshal.Pool.pooledMalloc1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96ai: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96aj; else goto c96ak;
       c96aj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c96ak: // global
           (_c96af::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c96af::I64 == 0) goto c96ah; else goto c96ag;
       c96ah: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c96ag: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c96af::I64;
           R2 = lvl26_r95nu_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.250615771 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMalloc_closure" {
     Foreign.Marshal.Pool.pooledMalloc_closure:
         const Foreign.Marshal.Pool.pooledMalloc_info;
         const 0;
 },
 lvl27_s95q6_entry() //  [R1]
         { info_tbl: [(c96aA,
                       label: lvl27_s95q6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96aA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c96aB; else goto c96aC;
       c96aB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c96aC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Pool.pooledMalloc1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s95qq_entry() //  [R1, R2]
         { info_tbl: [(c96aL,
                       label: sat_s95qq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96aL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96aM; else goto c96aN;
       c96aM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c96aN: // global
           I64[Sp - 16] = block_c96aI_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u96bg; else goto c96aJ;
       u96bg: // global
           call _c96aI(R1) args: 0, res: 0, upd: 0;
       c96aJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96aI() //  [R1]
         { info_tbl: [(c96aI,
                       label: block_c96aI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96aI: // global
           _s95q7::P64 = P64[Sp + 8];
           (_s95qf::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s95qf::I64 == 0) goto c96ba; else goto c96b6;
       c96ba: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c96b6: // global
           I64[Sp] = block_c96aZ_info;
           R1 = _s95q7::P64;
           I64[Sp + 8] = _s95qf::I64;
           if (R1 & 7 != 0) goto u96bf; else goto c96b0;
       u96bf: // global
           call _c96aZ(R1) args: 0, res: 0, upd: 0;
       c96b0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96aZ() //  [R1]
         { info_tbl: [(c96aZ,
                       label: block_c96aZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96aZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c96b9; else goto c96b8;
       c96b9: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96b8: // global
           _s95qi::P64 = P64[R1 + 7];
           _s95ql::P64 = P64[_s95qi::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           _c96b4::P64 = Hp - 31;
           P64[Hp - 8] = _c96b4::P64;
           P64[Hp] = _s95ql::P64;
           call MO_WriteBarrier();
           P64[_s95qi::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95qi::P64);
           R1 = _c96b4::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Pool.pooledMalloc_entry() //  [R2]
         { info_tbl: [(c96bh,
                       label: Foreign.Marshal.Pool.pooledMalloc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96bh: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c96bl; else goto c96bk;
       c96bl: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledMalloc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c96bk: // global
           I64[Hp - 32] = lvl27_s95q6_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s95qq_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.264010577 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNewArray2_closure" {
     Foreign.Marshal.Pool.pooledNewArray2_closure:
         const Foreign.Marshal.Pool.pooledNewArray2_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNewArray2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c96bS,
                       label: Foreign.Marshal.Pool.pooledNewArray2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96bS: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c96bW; else goto c96bX;
       c96bW: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledNewArray2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c96bX: // global
           I64[Sp - 40] = block_c96bQ_info;
           _s95qs::P64 = R3;
           R3 = 0;
           _s95qr::P64 = R2;
           R2 = R5;
           P64[Sp - 32] = _s95qr::P64;
           P64[Sp - 24] = _s95qs::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c96bQ() //  [R1]
         { info_tbl: [(c96bQ,
                       label: block_c96bQ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96bQ: // global
           I64[Sp - 8] = block_c96bV_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = Foreign.Marshal.Pool.pooledMallocArray1_closure;
           I64[Sp] = R1;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c96bV() //  [R1]
         { info_tbl: [(c96bV,
                       label: block_c96bV_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96bV: // global
           _s95qs::P64 = P64[Sp + 24];
           (_s95qF::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc((I64[Sp + 8] + 1) * I64[R1 + 7]);
           if (_s95qF::I64 == 0) goto c96cz; else goto c96ct;
       c96cz: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c96ct: // global
           I64[Sp + 8] = block_c96ch_info;
           R1 = _s95qs::P64;
           I64[Sp + 24] = _s95qF::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u96cA; else goto c96ci;
       u96cA: // global
           call _c96ch(R1) args: 0, res: 0, upd: 0;
       c96ci: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96ch() //  [R1]
         { info_tbl: [(c96ch,
                       label: block_c96ch_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96ch: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c96cw; else goto c96cv;
       c96cw: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96cv: // global
           _s95qI::P64 = P64[R1 + 7];
           _s95qL::P64 = P64[_s95qI::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           _c96cm::P64 = Hp - 31;
           P64[Hp - 8] = _c96cm::P64;
           P64[Hp] = _s95qL::P64;
           _s95qr::P64 = P64[Sp + 8];
           _s95qt::P64 = P64[Sp + 24];
           _s95qu::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_s95qI::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95qI::P64);
           I64[Sp + 24] = block_c96cr_info;
           R5 = _s95qu::P64;
           R4 = _c96cm::P64;
           R3 = _s95qt::P64;
           R2 = _s95qr::P64;
           P64[Sp + 32] = _c96cm::P64;
           Sp = Sp + 24;
           call Foreign.Marshal.Array.newArray4_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c96cr() //  []
         { info_tbl: [(c96cr,
                       label: block_c96cr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96cr: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.276741218 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNewArray0_closure" {
     Foreign.Marshal.Pool.pooledNewArray0_closure:
         const Foreign.Marshal.Pool.pooledNewArray0_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNewArray0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c96d4,
                       label: Foreign.Marshal.Pool.pooledNewArray0_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96d4: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledNewArray2_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.280777611 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNewArray1_closure" {
     Foreign.Marshal.Pool.pooledNewArray1_closure:
         const Foreign.Marshal.Pool.pooledNewArray1_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNewArray1_entry() //  [R2, R3, R4]
         { info_tbl: [(c96dh,
                       label: Foreign.Marshal.Pool.pooledNewArray1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96dh: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c96dl; else goto c96dm;
       c96dl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledNewArray1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c96dm: // global
           I64[Sp - 32] = block_c96df_info;
           _s95qU::P64 = R3;
           R3 = 0;
           _s95qT::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _s95qT::P64;
           P64[Sp - 16] = _s95qU::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c96df() //  [R1]
         { info_tbl: [(c96df,
                       label: block_c96df_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96df: // global
           I64[Sp - 8] = block_c96dk_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = Foreign.Marshal.Pool.pooledMallocArray1_closure;
           I64[Sp] = R1;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c96dk() //  [R1]
         { info_tbl: [(c96dk,
                       label: block_c96dk_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96dk: // global
           _s95qU::P64 = P64[Sp + 24];
           (_s95r5::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[Sp + 8] * I64[R1 + 7]);
           if (_s95r5::I64 == 0) goto c96dV; else goto c96dP;
       c96dV: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c96dP: // global
           I64[Sp + 8] = block_c96dD_info;
           R1 = _s95qU::P64;
           I64[Sp + 24] = _s95r5::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u96dW; else goto c96dE;
       u96dW: // global
           call _c96dD(R1) args: 0, res: 0, upd: 0;
       c96dE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96dD() //  [R1]
         { info_tbl: [(c96dD,
                       label: block_c96dD_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96dD: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c96dS; else goto c96dR;
       c96dS: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96dR: // global
           _s95r8::P64 = P64[R1 + 7];
           _s95rb::P64 = P64[_s95r8::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           _c96dI::P64 = Hp - 31;
           P64[Hp - 8] = _c96dI::P64;
           P64[Hp] = _s95rb::P64;
           _s95qT::P64 = P64[Sp + 8];
           _s95qV::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_s95r8::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95r8::P64);
           I64[Sp + 16] = block_c96dN_info;
           R4 = _s95qV::P64;
           R3 = _c96dI::P64;
           R2 = _s95qT::P64;
           P64[Sp + 24] = _c96dI::P64;
           Sp = Sp + 16;
           call Foreign.Marshal.Array.newArray2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c96dN() //  []
         { info_tbl: [(c96dN,
                       label: block_c96dN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96dN: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.293175282 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNewArray_closure" {
     Foreign.Marshal.Pool.pooledNewArray_closure:
         const Foreign.Marshal.Pool.pooledNewArray_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNewArray_entry() //  [R2, R3, R4]
         { info_tbl: [(c96ep,
                       label: Foreign.Marshal.Pool.pooledNewArray_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96ep: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledNewArray1_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.297186135 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNew1_closure" {
     Foreign.Marshal.Pool.pooledNew1_closure:
         const Foreign.Marshal.Pool.pooledNew1_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNew1_entry() //  [R2, R3, R4]
         { info_tbl: [(c96eC,
                       label: Foreign.Marshal.Pool.pooledNew1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96eC: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c96eD; else goto c96eE;
       c96eD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledNew1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c96eE: // global
           I64[Sp - 32] = block_c96eA_info;
           _s95rj::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = Foreign.Marshal.Pool.pooledMalloc1_closure;
           P64[Sp - 24] = _s95rj::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 48;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c96eA() //  [R1]
         { info_tbl: [(c96eA,
                       label: block_c96eA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96eA: // global
           _s95rk::P64 = P64[Sp + 16];
           (_s95rt::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s95rt::I64 == 0) goto c96f8; else goto c96f2;
       c96f8: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c96f2: // global
           I64[Sp] = block_c96eQ_info;
           R1 = _s95rk::P64;
           I64[Sp + 16] = _s95rt::I64;
           if (R1 & 7 != 0) goto u96f9; else goto c96eR;
       u96f9: // global
           call _c96eQ(R1) args: 0, res: 0, upd: 0;
       c96eR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96eQ() //  [R1]
         { info_tbl: [(c96eQ,
                       label: block_c96eQ_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96eQ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c96f5; else goto c96f4;
       c96f5: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96f4: // global
           _s95rw::P64 = P64[R1 + 7];
           _s95rz::P64 = P64[_s95rw::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           _c96eV::P64 = Hp - 31;
           P64[Hp - 8] = _c96eV::P64;
           P64[Hp] = _s95rz::P64;
           _s95rj::P64 = P64[Sp + 8];
           _s95rl::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_s95rw::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s95rw::P64);
           I64[Sp + 16] = block_c96f0_info;
           R2 = _s95rj::P64;
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _c96eV::P64;
           P64[Sp + 8] = _s95rl::P64;
           P64[Sp + 24] = _c96eV::P64;
           Sp = Sp - 8;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c96f0() //  []
         { info_tbl: [(c96f0,
                       label: block_c96f0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96f0: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.307999338 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNew_closure" {
     Foreign.Marshal.Pool.pooledNew_closure:
         const Foreign.Marshal.Pool.pooledNew_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNew_entry() //  [R2, R3, R4]
         { info_tbl: [(c96fx,
                       label: Foreign.Marshal.Pool.pooledNew_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96fx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledNew1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.311769614 UTC

[section ""data" . Foreign.Marshal.Pool.freePool2_closure" {
     Foreign.Marshal.Pool.freePool2_closure:
         const Foreign.Marshal.Pool.freePool2_info;
 },
 Foreign.Marshal.Pool.freePool2_entry() //  [R2]
         { info_tbl: [(c96fP,
                       label: Foreign.Marshal.Pool.freePool2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96fP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96fQ; else goto u96g6;
       c96fQ: // global
           R2 = R2;
           R1 = Foreign.Marshal.Pool.freePool2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u96g6: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c96fF() args: 0, res: 0, upd: 0;
     }
 },
 _c96fF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96fF: // global
           _s95rH::P64 = P64[Sp];
           I64[Sp] = block_c96fI_info;
           R1 = _s95rH::P64;
           if (R1 & 7 != 0) goto u96g8; else goto c96fJ;
       u96g8: // global
           call _c96fI(R1) args: 0, res: 0, upd: 0;
       c96fJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96fI() //  [R1]
         { info_tbl: [(c96fI,
                       label: block_c96fI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96fI: // global
           if (R1 & 7 == 1) goto c96fM; else goto c96fN;
       c96fM: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c96fN: // global
           I64[Sp - 8] = block_c96fX_info;
           _s95rL::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s95rL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u96g9; else goto c96fZ;
       u96g9: // global
           call _c96fX(R1) args: 0, res: 0, upd: 0;
       c96fZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96fX() //  [R1]
         { info_tbl: [(c96fX,
                       label: block_c96fX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96fX: // global
           _s95rL::P64 = P64[Sp + 8];
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[R1 + 7]);
           P64[Sp + 8] = _s95rL::P64;
           Sp = Sp + 8;
           call _c96fF() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.320766572 UTC

[section ""data" . Foreign.Marshal.Pool.freePool1_closure" {
     Foreign.Marshal.Pool.freePool1_closure:
         const Foreign.Marshal.Pool.freePool1_info;
 },
 Foreign.Marshal.Pool.freePool1_entry() //  [R2]
         { info_tbl: [(c96gB,
                       label: Foreign.Marshal.Pool.freePool1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96gB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c96gC; else goto c96gD;
       c96gC: // global
           R2 = R2;
           R1 = Foreign.Marshal.Pool.freePool1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c96gD: // global
           I64[Sp - 8] = block_c96gy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u96gH; else goto c96gz;
       u96gH: // global
           call _c96gy(R1) args: 0, res: 0, upd: 0;
       c96gz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96gy() //  [R1]
         { info_tbl: [(c96gy,
                       label: block_c96gy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96gy: // global
           R2 = P64[P64[R1 + 7] + 8];
           Sp = Sp + 8;
           call Foreign.Marshal.Pool.freePool2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.326226397 UTC

[section ""data" . Foreign.Marshal.Pool.freePool_closure" {
     Foreign.Marshal.Pool.freePool_closure:
         const Foreign.Marshal.Pool.freePool_info;
 },
 Foreign.Marshal.Pool.freePool_entry() //  [R2]
         { info_tbl: [(c96gW,
                       label: Foreign.Marshal.Pool.freePool_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96gW: // global
           R2 = R2;
           call Foreign.Marshal.Pool.freePool1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.329586222 UTC

[section ""data" . Foreign.Marshal.Pool.newPool1_closure" {
     Foreign.Marshal.Pool.newPool1_closure:
         const Foreign.Marshal.Pool.newPool1_info;
 },
 Foreign.Marshal.Pool.newPool1_entry() //  []
         { info_tbl: [(c96ha,
                       label: Foreign.Marshal.Pool.newPool1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96ha: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c96hb; else goto c96hc;
       c96hb: // global
           R1 = Foreign.Marshal.Pool.newPool1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c96hc: // global
           I64[Sp - 8] = block_c96h7_info;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96h7() //  [R1]
         { info_tbl: [(c96h7,
                       label: block_c96h7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96h7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c96hf; else goto c96he;
       c96hf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96he: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.334977924 UTC

[section ""data" . Foreign.Marshal.Pool.newPool_closure" {
     Foreign.Marshal.Pool.newPool_closure:
         const Foreign.Marshal.Pool.newPool_info;
 },
 Foreign.Marshal.Pool.newPool_entry() //  []
         { info_tbl: [(c96ht,
                       label: Foreign.Marshal.Pool.newPool_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96ht: // global
           call Foreign.Marshal.Pool.newPool1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.341382335 UTC

[section ""data" . Foreign.Marshal.Pool.withPool1_closure" {
     Foreign.Marshal.Pool.withPool1_closure:
         const Foreign.Marshal.Pool.withPool1_info;
 },
 sat_s95sf_entry() //  [R1]
         { info_tbl: [(c96hS,
                       label: sat_s95sf_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96hS: // global
           _s95sf::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c96hT; else goto c96hU;
       c96hU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c96hW; else goto c96hV;
       c96hW: // global
           HpAlloc = 16;
           goto c96hT;
       c96hT: // global
           R1 = _s95sf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c96hV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s95sf::P64;
           _s95s3::P64 = P64[_s95sf::P64 + 16];
           _s95sd::P64 = P64[_s95sf::P64 + 24];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _s95sd::P64;
           R2 = Hp - 7;
           R1 = _s95s3::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s95st_entry() //  [R1]
         { info_tbl: [(c96ig,
                       label: sat_s95st_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96ig: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c96ih; else goto c96ii;
       c96ih: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c96ii: // global
           _s95so::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp - 24] = block_c96ie_info;
           R2 = _s95so::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 24;
           call Foreign.Marshal.Pool.freePool2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c96ie() //  []
         { info_tbl: [(c96ie,
                       label: block_c96ie_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96ie: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95su_entry() //  [R1, R2]
         { info_tbl: [(c96ik,
                       label: sat_s95su_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96ik: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96il; else goto c96im;
       c96il: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c96im: // global
           I64[Sp - 16] = block_c96i4_info;
           _s95sd::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _s95sd::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u96iq; else goto c96i5;
       u96iq: // global
           call _c96i4(R1) args: 0, res: 0, upd: 0;
       c96i5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96i4() //  [R1]
         { info_tbl: [(c96i4,
                       label: block_c96i4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96i4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c96ip; else goto c96io;
       c96ip: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96io: // global
           _s95sj::P64 = P64[R1 + 7];
           _s95sk::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_s95st_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _s95sj::P64;
           P64[Hp] = _s95sk::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95sF_entry() //  [R2]
         { info_tbl: [(c96iy,
                       label: sat_s95sF_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96iy: // global
           R1 = R2;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95sZ_entry() //  [R1]
         { info_tbl: [(c96j0,
                       label: sat_s95sZ_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96j0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c96j1; else goto c96j2;
       c96j1: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c96j2: // global
           _s95sU::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp - 24] = block_c96iY_info;
           R2 = _s95sU::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 24;
           call Foreign.Marshal.Pool.freePool2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c96iY() //  []
         { info_tbl: [(c96iY,
                       label: block_c96iY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96iY: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95t0_entry() //  [R1, R2]
         { info_tbl: [(c96j4,
                       label: sat_s95t0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96j4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96j5; else goto c96j6;
       c96j5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c96j6: // global
           I64[Sp - 16] = block_c96iO_info;
           _s95sJ::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _s95sJ::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u96ja; else goto c96iP;
       u96ja: // global
           call _c96iO(R1) args: 0, res: 0, upd: 0;
       c96iP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96iO() //  [R1]
         { info_tbl: [(c96iO,
                       label: block_c96iO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96iO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c96j9; else goto c96j8;
       c96j9: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96j8: // global
           _s95sP::P64 = P64[R1 + 7];
           _s95sQ::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_s95sZ_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _s95sP::P64;
           P64[Hp] = _s95sQ::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95sL_entry() //  [R1]
         { info_tbl: [(c96jg,
                       label: sat_s95sL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96jg: // global
           _s95sL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c96jh; else goto c96ji;
       c96ji: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c96jk; else goto c96jj;
       c96jk: // global
           HpAlloc = 16;
           goto c96jh;
       c96jh: // global
           R1 = _s95sL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c96jj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s95sL::P64;
           _s95s3::P64 = P64[_s95sL::P64 + 16];
           _s95sJ::P64 = P64[_s95sL::P64 + 24];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _s95sJ::P64;
           R2 = Hp - 7;
           R1 = _s95s3::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s95sM_entry() //  [R1]
         { info_tbl: [(c96jq,
                       label: sat_s95sM_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96jq: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95ta_entry() //  [R1]
         { info_tbl: [(c96jx,
                       label: sat_s95ta_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96jx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96jy; else goto c96jz;
       c96jy: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c96jz: // global
           I64[Sp - 16] = block_c96iH_info;
           _s95s3::P64 = P64[R1 + 7];
           R1 = GHC.Types.[]_closure+1;
           P64[Sp - 8] = _s95s3::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96iH() //  [R1]
         { info_tbl: [(c96iH,
                       label: block_c96iH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96iH: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c96jC; else goto c96jB;
       c96jC: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96jB: // global
           I64[Hp - 56] = sat_s95t0_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = sat_s95sL_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s95sM_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c96jt_info;
           R2 = Hp - 55;
           _s95sJ::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _s95sJ::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96jt() //  [R1]
         { info_tbl: [(c96jt,
                       label: block_c96jt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96jt: // global
           _s95t6::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = block_c96jv_info;
           R2 = _s95t6::P64;
           P64[Sp + 8] = R1;
           call Foreign.Marshal.Pool.freePool2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c96jv() //  []
         { info_tbl: [(c96jv,
                       label: block_c96jv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96jv: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s95tb_entry() //  [R2]
         { info_tbl: [(c96jL,
                       label: sat_s95tb_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96jL: // global
           R1 = R2;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Pool.withPool1_entry() //  [R2]
         { info_tbl: [(c96jS,
                       label: Foreign.Marshal.Pool.withPool1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96jS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c96jT; else goto c96jU;
       c96jT: // global
           R2 = R2;
           R1 = Foreign.Marshal.Pool.withPool1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c96jU: // global
           I64[Sp - 16] = block_c96hE_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c96hE() //  [R1]
         { info_tbl: [(c96hE,
                       label: block_c96hE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96hE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c96jX; else goto c96jW;
       c96jX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c96jW: // global
           if (R1 == 0) goto c96jQ; else goto u96kb;
       c96jQ: // global
           I64[Hp - 8] = sat_s95ta_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       u96kb: // global
           if (R1 == 1) goto c96jR; else goto c96jP;
       c96jR: // global
           I64[Hp - 8] = sat_s95tb_info;
           _s95s9::P64 = Hp - 6;
           goto s95s8;
       c96jP: // global
           I64[Hp - 8] = sat_s95sF_info;
           _s95s9::P64 = Hp - 6;
           goto s95s8;
       s95s8: // global
           I64[Sp - 8] = block_c96hL_info;
           R1 = GHC.Types.[]_closure+1;
           P64[Sp] = _s95s9::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96hL() //  [R1]
         { info_tbl: [(c96hL,
                       label: block_c96hL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96hL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c96k4; else goto c96k3;
       c96k4: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96k3: // global
           I64[Hp - 24] = sat_s95sf_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           _s95s9::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c96hX_info;
           R2 = Hp - 24;
           _s95sd::P64 = R1;
           R1 = _s95s9::P64;
           P64[Sp + 16] = _s95sd::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96hX() //  [R1]
         { info_tbl: [(c96hX,
                       label: block_c96hX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96hX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c96k7; else goto c96k6;
       c96k7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96k6: // global
           I64[Hp - 8] = sat_s95su_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_c96jY_info;
           R2 = Hp - 7;
           R1 = R1;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96jY() //  [R1]
         { info_tbl: [(c96jY,
                       label: block_c96jY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96jY: // global
           _s95sA::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = block_c96k0_info;
           R2 = _s95sA::P64;
           P64[Sp + 8] = R1;
           call Foreign.Marshal.Pool.freePool2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c96k0() //  []
         { info_tbl: [(c96k0,
                       label: block_c96k0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96k0: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.386547466 UTC

[section ""data" . Foreign.Marshal.Pool.withPool_closure" {
     Foreign.Marshal.Pool.withPool_closure:
         const Foreign.Marshal.Pool.withPool_info;
 },
 Foreign.Marshal.Pool.withPool_entry() //  [R2]
         { info_tbl: [(c96lR,
                       label: Foreign.Marshal.Pool.withPool_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96lR: // global
           R2 = R2;
           call Foreign.Marshal.Pool.withPool1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:15.389835458 UTC

[section ""relreadonly" . S95uu_srt" {
     S95uu_srt:
         const Foreign.Marshal.Error.throwIf2_closure;
         const Foreign.Marshal.Alloc.realloc2_closure;
         const Foreign.Marshal.Pool.$wpooledReallocBytes_closure;
         const Foreign.Marshal.Pool.pooledRealloc1_closure;
         const GHC.Err.undefined_closure;
         const lvl11_r95nf_closure;
         const Foreign.Marshal.Pool.pooledReallocArray1_closure;
         const Foreign.Marshal.Pool.pooledReallocArray_closure;
         const Foreign.Marshal.Pool.pooledReallocArray2_closure;
         const lvl16_r95nk_closure;
         const Foreign.Marshal.Pool.pooledRealloc3_closure;
         const Foreign.Marshal.Pool.pooledRealloc_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Pool.pooledMallocBytes1_closure;
         const lvl21_r95np_closure;
         const Foreign.Marshal.Pool.pooledMallocArray1_closure;
         const Foreign.Marshal.Pool.pooledMallocArray_closure;
         const Foreign.Marshal.Pool.$wpooledMallocArray0_closure;
         const Foreign.Marshal.Pool.pooledMallocArray2_closure;
         const lvl26_r95nu_closure;
         const Foreign.Marshal.Pool.pooledMalloc1_closure;
         const Foreign.Marshal.Pool.pooledMalloc_closure;
         const Foreign.Marshal.Pool.pooledNewArray2_closure;
         const Foreign.Marshal.Pool.pooledNewArray1_closure;
         const Foreign.Marshal.Pool.pooledNew1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.749505935 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:04:16.750593788 UTC

[section ""cstring" . Foreign.Marshal.Pool.$trModule4_bytes" {
     Foreign.Marshal.Pool.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.752321775 UTC

[section ""data" . Foreign.Marshal.Pool.$trModule3_closure" {
     Foreign.Marshal.Pool.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Pool.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.754195971 UTC

[section ""cstring" . Foreign.Marshal.Pool.$trModule2_bytes" {
     Foreign.Marshal.Pool.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,80,111,111,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.756423442 UTC

[section ""data" . Foreign.Marshal.Pool.$trModule1_closure" {
     Foreign.Marshal.Pool.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Pool.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.758178396 UTC

[section ""data" . Foreign.Marshal.Pool.$trModule_closure" {
     Foreign.Marshal.Pool.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Marshal.Pool.$trModule3_closure+1;
         const Foreign.Marshal.Pool.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.760016306 UTC

[section ""data" . $krep_r95mW_closure" {
     $krep_r95mW_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Tuple.$tc()_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.761861578 UTC

[section ""data" . $krep1_r95mX_closure" {
     $krep1_r95mX_closure:
         const :_con_info;
         const $krep_r95mW_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.763684455 UTC

[section ""data" . $krep2_r95mY_closure" {
     $krep2_r95mY_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Ptr.$tcPtr_closure;
         const $krep1_r95mX_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.765593011 UTC

[section ""data" . $krep3_r95mZ_closure" {
     $krep3_r95mZ_closure:
         const :_con_info;
         const $krep2_r95mY_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.767836266 UTC

[section ""data" . $krep4_r95n0_closure" {
     $krep4_r95n0_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep3_r95mZ_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.769708494 UTC

[section ""data" . $krep5_r95n1_closure" {
     $krep5_r95n1_closure:
         const :_con_info;
         const $krep4_r95n0_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.771526274 UTC

[section ""data" . $krep6_r95n2_closure" {
     $krep6_r95n2_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.IORef.$tcIORef_closure;
         const $krep5_r95n1_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.773365757 UTC

[section ""cstring" . Foreign.Marshal.Pool.$tcPool2_bytes" {
     Foreign.Marshal.Pool.$tcPool2_bytes:
         I8[] [80,111,111,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.775086799 UTC

[section ""data" . Foreign.Marshal.Pool.$tcPool1_closure" {
     Foreign.Marshal.Pool.$tcPool1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Pool.$tcPool2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.776780285 UTC

[section ""data" . Foreign.Marshal.Pool.$tcPool_closure" {
     Foreign.Marshal.Pool.$tcPool_closure:
         const GHC.Types.TyCon_con_info;
         const Foreign.Marshal.Pool.$trModule_closure+1;
         const Foreign.Marshal.Pool.$tcPool1_closure+1;
         const GHC.Types.krep$*_closure;
         const 6812857741828992361;
         const 12127662557529231519;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.779058008 UTC

[section ""data" . $krep7_r95n3_closure" {
     $krep7_r95n3_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const Foreign.Marshal.Pool.$tcPool_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.780795795 UTC

[section ""data" . Foreign.Marshal.Pool.$tc'Pool1_closure" {
     Foreign.Marshal.Pool.$tc'Pool1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep6_r95n2_closure+1;
         const $krep7_r95n3_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.783207026 UTC

[section ""cstring" . Foreign.Marshal.Pool.$tc'Pool3_bytes" {
     Foreign.Marshal.Pool.$tc'Pool3_bytes:
         I8[] [39,80,111,111,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.784943441 UTC

[section ""data" . Foreign.Marshal.Pool.$tc'Pool2_closure" {
     Foreign.Marshal.Pool.$tc'Pool2_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Pool.$tc'Pool3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.786714044 UTC

[section ""data" . Foreign.Marshal.Pool.$tc'Pool_closure" {
     Foreign.Marshal.Pool.$tc'Pool_closure:
         const GHC.Types.TyCon_con_info;
         const Foreign.Marshal.Pool.$trModule_closure+1;
         const Foreign.Marshal.Pool.$tc'Pool2_closure+1;
         const Foreign.Marshal.Pool.$tc'Pool1_closure+4;
         const 11588816997626637361;
         const 15405086111208545194;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.788621959 UTC

[section ""cstring" . lvl_r95n4_bytes" {
     lvl_r95n4_bytes:
         I8[] [112,111,105,110,116,101,114,32,110,111,116,32,105,110,32,112,111,111,108]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.791299475 UTC

[section ""data" . Foreign.Marshal.Pool.pooledRealloc2_closure" {
     Foreign.Marshal.Pool.pooledRealloc2_closure:
         const Foreign.Marshal.Pool.pooledRealloc2_info;
 },
 Foreign.Marshal.Pool.pooledRealloc2_entry() //  []
         { info_tbl: [(c96s4,
                       label: Foreign.Marshal.Pool.pooledRealloc2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96s4: // global
           R2 = lvl_r95n4_bytes;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.796306528 UTC

[section ""data" . Foreign.Marshal.Pool.$wpooledReallocBytes_closure" {
     Foreign.Marshal.Pool.$wpooledReallocBytes_closure:
         const Foreign.Marshal.Pool.$wpooledReallocBytes_info;
         const 0;
 },
 sat_s96mm_entry() //  [R1]
         { info_tbl: [(c96sC,
                       label: sat_s96mm_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96sC: // global
           _s96mm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c96sD; else goto c96sE;
       c96sE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c96sG; else goto c96sF;
       c96sG: // global
           HpAlloc = 16;
           goto c96sD;
       c96sD: // global
           R1 = _s96mm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c96sF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s96mm::P64;
           _s96mj::P64 = P64[_s96mm::P64 + 16];
           _s96m1::I64 = I64[_s96mm::P64 + 24];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s96m1::I64;
           R4 = _s96mj::P64;
           R3 = Hp - 7;
           R2 = GHC.Ptr.$fEqPtr_$c==_closure+2;
           Sp = Sp - 16;
           call Data.OldList.deleteBy_entry(R4,
                                            R3,
                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s96mx_entry() //  [R1]
         { info_tbl: [(c96sP,
                       label: sat_s96mx_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96sP: // global
           _s96mx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c96sQ; else goto c96sR;
       c96sR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c96sT; else goto c96sS;
       c96sT: // global
           HpAlloc = 16;
           goto c96sQ;
       c96sQ: // global
           R1 = _s96mx::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c96sS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s96mx::P64;
           _s96mv::P64 = P64[_s96mx::P64 + 16];
           _s96m1::I64 = I64[_s96mx::P64 + 24];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s96m1::I64;
           R4 = _s96mv::P64;
           R3 = Hp - 7;
           R2 = GHC.Ptr.$fEqPtr_$c==_closure+2;
           Sp = Sp - 16;
           call Data.OldList.deleteBy_entry(R4,
                                            R3,
                                            R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Pool.$wpooledReallocBytes_entry() //  [R2, R3, R4]
         { info_tbl: [(c96sY,
                       label: Foreign.Marshal.Pool.$wpooledReallocBytes_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 20} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96sY: // global
           _s96m2::I64 = R4;
           _s96m1::I64 = R3;
           _s96m0::P64 = R2;
           if ((Sp + -40) < SpLim) (likely: False) goto c96sZ; else goto c96t0;
       c96t0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c96t2; else goto c96t1;
       c96t2: // global
           HpAlloc = 16;
           goto c96sZ;
       c96sZ: // global
           R4 = _s96m2::I64;
           R3 = _s96m1::I64;
           R2 = _s96m0::P64;
           R1 = Foreign.Marshal.Pool.$wpooledReallocBytes_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c96t1: // global
           _s96m6::P64 = P64[_s96m0::P64 + 8];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s96m1::I64;
           I64[Sp - 40] = block_c96sg_info;
           R4 = _s96m6::P64;
           R3 = Hp - 7;
           R2 = GHC.Ptr.$fEqPtr_closure;
           P64[Sp - 32] = _s96m0::P64;
           I64[Sp - 24] = _s96m1::I64;
           I64[Sp - 16] = _s96m2::I64;
           P64[Sp - 8] = _s96m6::P64;
           Sp = Sp - 40;
           call GHC.List.elem_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c96sg() //  [R1]
         { info_tbl: [(c96sg,
                       label: block_c96sg_info
                       rep:StackRep [False, True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96sg: // global
           if (R1 & 7 == 1) goto c96sV; else goto c96sW;
       c96sV: // global
           R3 = Foreign.Marshal.Pool.pooledRealloc2_closure+1;
           R2 = P64[Sp + 32];
           Sp = Sp + 40;
           call Foreign.Marshal.Error.throwIf2_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       c96sW: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c96t7; else goto c96t6;
       c96t7: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96t6: // global
           _s96m0::P64 = P64[Sp + 8];
           _s96m1::I64 = I64[Sp + 16];
           _s96ma::I64 = I64[Sp + 24];
           if (_s96ma::I64 != 0) goto c96tc; else goto c96td;
       c96tc: // global
           (_s96mf::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(_s96m1::I64, _s96ma::I64);
           if (_s96mf::I64 == 0) goto c96ta; else goto c96t9;
       c96ta: // global
           Hp = Hp - 72;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c96t9: // global
           _s96mj::P64 = P64[_s96m0::P64 + 8];
           I64[Hp - 64] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 56] = _s96mf::I64;
           I64[Hp - 48] = sat_s96mm_info;
           P64[Hp - 32] = _s96mj::P64;
           I64[Hp - 24] = _s96m1::I64;
           I64[Hp - 16] = :_con_info;
           _c96sw::P64 = Hp - 63;
           P64[Hp - 8] = _c96sw::P64;
           P64[Hp] = Hp - 48;
           call MO_WriteBarrier();
           P64[_s96m0::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s96m0::P64);
           R1 = _c96sw::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c96td: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(_s96m1::I64);
           _s96mv::P64 = P64[_s96m0::P64 + 8];
           I64[Hp - 64] = sat_s96mx_info;
           P64[Hp - 48] = _s96mv::P64;
           I64[Hp - 40] = _s96m1::I64;
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = GHC.Ptr.nullPtr_closure;
           P64[Hp - 16] = Hp - 64;
           call MO_WriteBarrier();
           P64[_s96m0::P64 + 8] = Hp - 30;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s96m0::P64);
           Hp = Hp - 16;
           R1 = GHC.Ptr.nullPtr_closure;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.810005171 UTC

[section ""data" . Foreign.Marshal.Pool.pooledRealloc1_closure" {
     Foreign.Marshal.Pool.pooledRealloc1_closure:
         const Foreign.Marshal.Pool.pooledRealloc1_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledRealloc1_entry() //  [R2, R3, R4]
         { info_tbl: [(c96u9,
                       label: Foreign.Marshal.Pool.pooledRealloc1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96u9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c96ui; else goto c96uj;
       c96ui: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledRealloc1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c96uj: // global
           I64[Sp - 24] = block_c96u6_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u96us; else goto c96u7;
       u96us: // global
           call _c96u6(R1) args: 0, res: 0, upd: 0;
       c96u7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96u6() //  [R1]
         { info_tbl: [(c96u6,
                       label: block_c96u6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96u6: // global
           I64[Sp] = block_c96uc_info;
           _s96mF::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s96mF::P64;
           if (R1 & 7 != 0) goto u96ur; else goto c96ud;
       u96ur: // global
           call _c96uc(R1) args: 0, res: 0, upd: 0;
       c96ud: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96uc() //  [R1]
         { info_tbl: [(c96uc,
                       label: block_c96uc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96uc: // global
           I64[Sp] = block_c96uh_info;
           _s96mH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s96mH::I64;
           if (R1 & 7 != 0) goto u96ut; else goto c96um;
       u96ut: // global
           call _c96uh(R1) args: 0, res: 0, upd: 0;
       c96um: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96uh() //  [R1]
         { info_tbl: [(c96uh,
                       label: block_c96uh_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96uh: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Pool.$wpooledReallocBytes_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.819676639 UTC

[section ""data" . Foreign.Marshal.Pool.pooledReallocBytes_closure" {
     Foreign.Marshal.Pool.pooledReallocBytes_closure:
         const Foreign.Marshal.Pool.pooledReallocBytes_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledReallocBytes_entry() //  [R2, R3, R4]
         { info_tbl: [(c96uS,
                       label: Foreign.Marshal.Pool.pooledReallocBytes_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96uS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledRealloc1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.823020993 UTC

[section ""cstring" . lvl1_r95n5_bytes" {
     lvl1_r95n5_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.824892006 UTC

[section ""data" . lvl2_r95n6_closure" {
     lvl2_r95n6_closure:
         const lvl2_r95n6_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r95n6_entry() //  [R1]
         { info_tbl: [(c96v6,
                       label: lvl2_r95n6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96v6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96v7; else goto c96v8;
       c96v7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c96v8: // global
           (_c96v3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c96v3::I64 == 0) goto c96v5; else goto c96v4;
       c96v5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c96v4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c96v3::I64;
           R2 = lvl1_r95n5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.829411561 UTC

[section ""data" . lvl3_r95n7_closure" {
     lvl3_r95n7_closure:
         const lvl3_r95n7_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r95n7_entry() //  [R1]
         { info_tbl: [(c96vn,
                       label: lvl3_r95n7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96vn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96vo; else goto c96vp;
       c96vo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c96vp: // global
           (_c96vk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c96vk::I64 == 0) goto c96vm; else goto c96vl;
       c96vm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c96vl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c96vk::I64;
           R2 = Foreign.Marshal.Pool.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.833960915 UTC

[section ""data" . lvl4_r95n8_closure" {
     lvl4_r95n8_closure:
         const lvl4_r95n8_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r95n8_entry() //  [R1]
         { info_tbl: [(c96vE,
                       label: lvl4_r95n8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96vE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96vF; else goto c96vG;
       c96vF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c96vG: // global
           (_c96vB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c96vB::I64 == 0) goto c96vD; else goto c96vC;
       c96vD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c96vC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c96vB::I64;
           R2 = Foreign.Marshal.Pool.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.838124344 UTC

[section ""cstring" . lvl5_r95n9_bytes" {
     lvl5_r95n9_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,77,97,114,115,104,97,108,47,80,111,111,108,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.839965516 UTC

[section ""data" . lvl6_r95na_closure" {
     lvl6_r95na_closure:
         const lvl6_r95na_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r95na_entry() //  [R1]
         { info_tbl: [(c96vW,
                       label: lvl6_r95na_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96vW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96vX; else goto c96vY;
       c96vX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c96vY: // global
           (_c96vT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c96vT::I64 == 0) goto c96vV; else goto c96vU;
       c96vV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c96vU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c96vT::I64;
           R2 = lvl5_r95n9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.84385467 UTC

[section ""data" . lvl7_r95nb_closure" {
     lvl7_r95nb_closure:
         const GHC.Types.I#_con_info;
         const 159;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.846015627 UTC

[section ""data" . lvl8_r95nc_closure" {
     lvl8_r95nc_closure:
         const GHC.Types.I#_con_info;
         const 26;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.847674464 UTC

[section ""data" . lvl9_r95nd_closure" {
     lvl9_r95nd_closure:
         const GHC.Types.I#_con_info;
         const 35;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.849465837 UTC

[section ""data" . lvl10_r95ne_closure" {
     lvl10_r95ne_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_r95n7_closure;
         const lvl4_r95n8_closure;
         const lvl6_r95na_closure;
         const lvl7_r95nb_closure+1;
         const lvl8_r95nc_closure+1;
         const lvl7_r95nb_closure+1;
         const lvl9_r95nd_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.851288025 UTC

[section ""data" . lvl11_r95nf_closure" {
     lvl11_r95nf_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_r95n6_closure;
         const lvl10_r95ne_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.854818735 UTC

[section ""data" . Foreign.Marshal.Pool.pooledReallocArray1_closure" {
     Foreign.Marshal.Pool.pooledReallocArray1_closure:
         const Foreign.Marshal.Pool.pooledReallocArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Pool.pooledReallocArray1_entry() //  [R1]
         { info_tbl: [(c96wi,
                       label: Foreign.Marshal.Pool.pooledReallocArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96wi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96wj; else goto c96wk;
       c96wj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c96wk: // global
           (_c96wf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c96wf::I64 == 0) goto c96wh; else goto c96wg;
       c96wh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c96wg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c96wf::I64;
           R2 = lvl11_r95nf_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.86129479 UTC

[section ""data" . Foreign.Marshal.Pool.pooledReallocArray_closure" {
     Foreign.Marshal.Pool.pooledReallocArray_closure:
         const Foreign.Marshal.Pool.pooledReallocArray_info;
         const 0;
 },
 lvl27_s96mL_entry() //  [R1]
         { info_tbl: [(c96wB,
                       label: lvl27_s96mL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96wB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c96wC; else goto c96wD;
       c96wC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c96wD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Pool.pooledReallocArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s96mZ_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c96wM,
                       label: sat_s96mZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96wM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c96x0; else goto c96x1;
       c96x0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c96x1: // global
           I64[Sp - 32] = block_c96wJ_info;
           _s96mL::P64 = P64[R1 + 4];
           R1 = R2;
           P64[Sp - 24] = _s96mL::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u96xc; else goto c96wK;
       u96xc: // global
           call _c96wJ(R1) args: 0, res: 0, upd: 0;
       c96wK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96wJ() //  [R1]
         { info_tbl: [(c96wJ,
                       label: block_c96wJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96wJ: // global
           I64[Sp] = block_c96wP_info;
           _s96mR::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s96mR::P64;
           if (R1 & 7 != 0) goto u96xb; else goto c96wQ;
       u96xb: // global
           call _c96wP(R1) args: 0, res: 0, upd: 0;
       c96wQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96wP() //  [R1]
         { info_tbl: [(c96wP,
                       label: block_c96wP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96wP: // global
           I64[Sp] = block_c96wU_info;
           _s96mT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s96mT::I64;
           if (R1 & 7 != 0) goto u96xd; else goto c96wV;
       u96xd: // global
           call _c96wU(R1) args: 0, res: 0, upd: 0;
       c96wV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96wU() //  [R1]
         { info_tbl: [(c96wU,
                       label: block_c96wU_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96wU: // global
           I64[Sp] = block_c96wZ_info;
           _s96mV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s96mV::I64;
           if (R1 & 7 != 0) goto u96xe; else goto c96x5;
       u96xe: // global
           call _c96wZ(R1) args: 0, res: 0, upd: 0;
       c96x5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96wZ() //  [R1]
         { info_tbl: [(c96wZ,
                       label: block_c96wZ_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96wZ: // global
           R4 = I64[Sp + 8] * I64[R1 + 7];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Foreign.Marshal.Pool.$wpooledReallocBytes_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Pool.pooledReallocArray_entry() //  [R2]
         { info_tbl: [(c96xf,
                       label: Foreign.Marshal.Pool.pooledReallocArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96xf: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c96xj; else goto c96xi;
       c96xj: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledReallocArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c96xi: // global
           I64[Hp - 32] = lvl27_s96mL_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s96mZ_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.878657048 UTC

[section ""data" . Foreign.Marshal.Pool.pooledReallocArray2_closure" {
     Foreign.Marshal.Pool.pooledReallocArray2_closure:
         const Foreign.Marshal.Pool.pooledReallocArray2_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledReallocArray2_entry() //  [R2, R3, R4,
                                                       R5]
         { info_tbl: [(c96y6,
                       label: Foreign.Marshal.Pool.pooledReallocArray2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96y6: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c96yk; else goto c96yl;
       c96yk: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledReallocArray2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c96yl: // global
           I64[Sp - 32] = block_c96y3_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u96yy; else goto c96y4;
       u96yy: // global
           call _c96y3(R1) args: 0, res: 0, upd: 0;
       c96y4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96y3() //  [R1]
         { info_tbl: [(c96y3,
                       label: block_c96y3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96y3: // global
           I64[Sp] = block_c96y9_info;
           _s96n6::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s96n6::P64;
           if (R1 & 7 != 0) goto u96yx; else goto c96ya;
       u96yx: // global
           call _c96y9(R1) args: 0, res: 0, upd: 0;
       c96ya: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96y9() //  [R1]
         { info_tbl: [(c96y9,
                       label: block_c96y9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96y9: // global
           I64[Sp] = block_c96ye_info;
           _s96n8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s96n8::I64;
           if (R1 & 7 != 0) goto u96yz; else goto c96yf;
       u96yz: // global
           call _c96ye(R1) args: 0, res: 0, upd: 0;
       c96yf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96ye() //  [R1]
         { info_tbl: [(c96ye,
                       label: block_c96ye_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96ye: // global
           I64[Sp] = block_c96yj_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Foreign.Marshal.Pool.pooledReallocArray1_closure;
           I64[Sp + 8] = I64[R1 + 7];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c96yj() //  [R1]
         { info_tbl: [(c96yj,
                       label: block_c96yj_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96yj: // global
           R4 = (I64[Sp + 8] + 1) * I64[R1 + 7];
           R3 = I64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call Foreign.Marshal.Pool.$wpooledReallocBytes_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.890153566 UTC

[section ""data" . Foreign.Marshal.Pool.pooledReallocArray0_closure" {
     Foreign.Marshal.Pool.pooledReallocArray0_closure:
         const Foreign.Marshal.Pool.pooledReallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledReallocArray0_entry() //  [R2, R3, R4,
                                                       R5]
         { info_tbl: [(c96z8,
                       label: Foreign.Marshal.Pool.pooledReallocArray0_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96z8: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledReallocArray2_entry(R5,
                                                               R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.893874459 UTC

[section ""data" . lvl12_r95ng_closure" {
     lvl12_r95ng_closure:
         const GHC.Types.I#_con_info;
         const 124;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.89557408 UTC

[section ""data" . lvl13_r95nh_closure" {
     lvl13_r95nh_closure:
         const GHC.Types.I#_con_info;
         const 20;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.897291829 UTC

[section ""data" . lvl14_r95ni_closure" {
     lvl14_r95ni_closure:
         const GHC.Types.I#_con_info;
         const 29;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.899106016 UTC

[section ""data" . lvl15_r95nj_closure" {
     lvl15_r95nj_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_r95n7_closure;
         const lvl4_r95n8_closure;
         const lvl6_r95na_closure;
         const lvl12_r95ng_closure+1;
         const lvl13_r95nh_closure+1;
         const lvl12_r95ng_closure+1;
         const lvl14_r95ni_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.900926951 UTC

[section ""data" . lvl16_r95nk_closure" {
     lvl16_r95nk_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_r95n6_closure;
         const lvl15_r95nj_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.903849133 UTC

[section ""data" . Foreign.Marshal.Pool.pooledRealloc3_closure" {
     Foreign.Marshal.Pool.pooledRealloc3_closure:
         const Foreign.Marshal.Pool.pooledRealloc3_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Pool.pooledRealloc3_entry() //  [R1]
         { info_tbl: [(c96zq,
                       label: Foreign.Marshal.Pool.pooledRealloc3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96zq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96zr; else goto c96zs;
       c96zr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c96zs: // global
           (_c96zn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c96zn::I64 == 0) goto c96zp; else goto c96zo;
       c96zp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c96zo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c96zn::I64;
           R2 = lvl16_r95nk_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.90831063 UTC

[section ""data" . Foreign.Marshal.Pool.pooledRealloc_closure" {
     Foreign.Marshal.Pool.pooledRealloc_closure:
         const Foreign.Marshal.Pool.pooledRealloc_info;
         const 0;
 },
 lvl27_s96ng_entry() //  [R1]
         { info_tbl: [(c96zJ,
                       label: lvl27_s96ng_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96zJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c96zK; else goto c96zL;
       c96zK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c96zL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Pool.pooledRealloc3_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s96nk_entry() //  [R1, R2, R3]
         { info_tbl: [(c96zR,
                       label: sat_s96nk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96zR: // global
           R4 = P64[R1 + 5];
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledRealloc1_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Pool.pooledRealloc_entry() //  [R2]
         { info_tbl: [(c96zU,
                       label: Foreign.Marshal.Pool.pooledRealloc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96zU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c96zY; else goto c96zX;
       c96zY: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledRealloc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c96zX: // global
           I64[Hp - 32] = lvl27_s96ng_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s96nk_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.916889435 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocBytes1_closure" {
     Foreign.Marshal.Pool.pooledMallocBytes1_closure:
         const Foreign.Marshal.Pool.pooledMallocBytes1_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMallocBytes1_entry() //  [R2, R3]
         { info_tbl: [(c96Ao,
                       label: Foreign.Marshal.Pool.pooledMallocBytes1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Ao: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96Ap; else goto c96Aq;
       c96Ap: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledMallocBytes1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c96Aq: // global
           I64[Sp - 16] = block_c96Al_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u96AT; else goto c96Am;
       u96AT: // global
           call _c96Al(R1) args: 0, res: 0, upd: 0;
       c96Am: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96Al() //  [R1]
         { info_tbl: [(c96Al,
                       label: block_c96Al_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Al: // global
           _s96nl::P64 = P64[Sp + 8];
           (_s96nu::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s96nu::I64 == 0) goto c96AN; else goto c96AJ;
       c96AN: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c96AJ: // global
           I64[Sp] = block_c96AC_info;
           R1 = _s96nl::P64;
           I64[Sp + 8] = _s96nu::I64;
           if (R1 & 7 != 0) goto u96AS; else goto c96AD;
       u96AS: // global
           call _c96AC(R1) args: 0, res: 0, upd: 0;
       c96AD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96AC() //  [R1]
         { info_tbl: [(c96AC,
                       label: block_c96AC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96AC: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c96AM; else goto c96AL;
       c96AM: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96AL: // global
           _s96nx::P64 = P64[R1 + 7];
           _s96nA::P64 = P64[_s96nx::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           _c96AH::P64 = Hp - 31;
           P64[Hp - 8] = _c96AH::P64;
           P64[Hp] = _s96nA::P64;
           call MO_WriteBarrier();
           P64[_s96nx::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s96nx::P64);
           R1 = _c96AH::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.925209904 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocBytes_closure" {
     Foreign.Marshal.Pool.pooledMallocBytes_closure:
         const Foreign.Marshal.Pool.pooledMallocBytes_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMallocBytes_entry() //  [R2, R3]
         { info_tbl: [(c96Bj,
                       label: Foreign.Marshal.Pool.pooledMallocBytes_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Bj: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledMallocBytes1_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.928886697 UTC

[section ""data" . lvl17_r95nl_closure" {
     lvl17_r95nl_closure:
         const GHC.Types.I#_con_info;
         const 144;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.931021515 UTC

[section ""data" . lvl18_r95nm_closure" {
     lvl18_r95nm_closure:
         const GHC.Types.I#_con_info;
         const 25;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.932657933 UTC

[section ""data" . lvl19_r95nn_closure" {
     lvl19_r95nn_closure:
         const GHC.Types.I#_con_info;
         const 34;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.934347916 UTC

[section ""data" . lvl20_r95no_closure" {
     lvl20_r95no_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_r95n7_closure;
         const lvl4_r95n8_closure;
         const lvl6_r95na_closure;
         const lvl17_r95nl_closure+1;
         const lvl18_r95nm_closure+1;
         const lvl17_r95nl_closure+1;
         const lvl19_r95nn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.936204112 UTC

[section ""data" . lvl21_r95np_closure" {
     lvl21_r95np_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_r95n6_closure;
         const lvl20_r95no_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.938523093 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocArray1_closure" {
     Foreign.Marshal.Pool.pooledMallocArray1_closure:
         const Foreign.Marshal.Pool.pooledMallocArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMallocArray1_entry() //  [R1]
         { info_tbl: [(c96BB,
                       label: Foreign.Marshal.Pool.pooledMallocArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96BB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96BC; else goto c96BD;
       c96BC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c96BD: // global
           (_c96By::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c96By::I64 == 0) goto c96BA; else goto c96Bz;
       c96BA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c96Bz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c96By::I64;
           R2 = lvl21_r95np_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.94421796 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocArray_closure" {
     Foreign.Marshal.Pool.pooledMallocArray_closure:
         const Foreign.Marshal.Pool.pooledMallocArray_info;
         const 0;
 },
 lvl27_s96nG_entry() //  [R1]
         { info_tbl: [(c96BU,
                       label: lvl27_s96nG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96BU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c96BV; else goto c96BW;
       c96BV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c96BW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Pool.pooledMallocArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s96o4_entry() //  [R1, R2, R3]
         { info_tbl: [(c96C5,
                       label: sat_s96o4_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96C5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c96C9; else goto c96Ca;
       c96C9: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c96Ca: // global
           I64[Sp - 24] = block_c96C2_info;
           _s96nG::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s96nG::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u96CJ; else goto c96C3;
       u96CJ: // global
           call _c96C2(R1) args: 0, res: 0, upd: 0;
       c96C3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96C2() //  [R1]
         { info_tbl: [(c96C2,
                       label: block_c96C2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96C2: // global
           I64[Sp] = block_c96C8_info;
           _s96nL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s96nL::I64;
           if (R1 & 7 != 0) goto u96CI; else goto c96Cc;
       u96CI: // global
           call _c96C8(R1) args: 0, res: 0, upd: 0;
       c96Cc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96C8() //  [R1]
         { info_tbl: [(c96C8,
                       label: block_c96C8_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96C8: // global
           _s96nH::P64 = P64[Sp + 16];
           (_s96nT::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[Sp + 8] * I64[R1 + 7]);
           if (_s96nT::I64 == 0) goto c96CD; else goto c96Cz;
       c96CD: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c96Cz: // global
           I64[Sp + 8] = block_c96Cs_info;
           R1 = _s96nH::P64;
           I64[Sp + 16] = _s96nT::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u96CK; else goto c96Ct;
       u96CK: // global
           call _c96Cs(R1) args: 0, res: 0, upd: 0;
       c96Ct: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96Cs() //  [R1]
         { info_tbl: [(c96Cs,
                       label: block_c96Cs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Cs: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c96CC; else goto c96CB;
       c96CC: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96CB: // global
           _s96nW::P64 = P64[R1 + 7];
           _s96nZ::P64 = P64[_s96nW::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           _c96Cx::P64 = Hp - 31;
           P64[Hp - 8] = _c96Cx::P64;
           P64[Hp] = _s96nZ::P64;
           call MO_WriteBarrier();
           P64[_s96nW::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s96nW::P64);
           R1 = _c96Cx::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Pool.pooledMallocArray_entry() //  [R2]
         { info_tbl: [(c96CL,
                       label: Foreign.Marshal.Pool.pooledMallocArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96CL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c96CP; else goto c96CO;
       c96CP: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledMallocArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c96CO: // global
           I64[Hp - 32] = lvl27_s96nG_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s96o4_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.959951383 UTC

[section ""data" . Foreign.Marshal.Pool.$wpooledMallocArray0_closure" {
     Foreign.Marshal.Pool.$wpooledMallocArray0_closure:
         const Foreign.Marshal.Pool.$wpooledMallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Pool.$wpooledMallocArray0_entry() //  [R2, R3, R4]
         { info_tbl: [(c96DC,
                       label: Foreign.Marshal.Pool.$wpooledMallocArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 22} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96DC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c96DD; else goto c96DE;
       c96DD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.$wpooledMallocArray0_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c96DE: // global
           I64[Sp - 24] = block_c96DA_info;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = Foreign.Marshal.Pool.pooledMallocArray1_closure;
           P64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c96DA() //  [R1]
         { info_tbl: [(c96DA,
                       label: block_c96DA_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96DA: // global
           _s96o6::P64 = P64[Sp + 8];
           (_s96oh::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc((I64[Sp + 16] + 1) * I64[R1 + 7]);
           if (_s96oh::I64 == 0) goto c96E7; else goto c96E3;
       c96E7: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c96E3: // global
           I64[Sp + 8] = block_c96DW_info;
           R1 = _s96o6::P64;
           I64[Sp + 16] = _s96oh::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u96Ec; else goto c96DX;
       u96Ec: // global
           call _c96DW(R1) args: 0, res: 0, upd: 0;
       c96DX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96DW() //  [R1]
         { info_tbl: [(c96DW,
                       label: block_c96DW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96DW: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c96E6; else goto c96E5;
       c96E6: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96E5: // global
           _s96ok::P64 = P64[R1 + 7];
           _s96on::P64 = P64[_s96ok::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           _c96E1::P64 = Hp - 31;
           P64[Hp - 8] = _c96E1::P64;
           P64[Hp] = _s96on::P64;
           call MO_WriteBarrier();
           P64[_s96ok::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s96ok::P64);
           R1 = _c96E1::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.968804342 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocArray2_closure" {
     Foreign.Marshal.Pool.pooledMallocArray2_closure:
         const Foreign.Marshal.Pool.pooledMallocArray2_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMallocArray2_entry() //  [R2, R3, R4]
         { info_tbl: [(c96EJ,
                       label: Foreign.Marshal.Pool.pooledMallocArray2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96EJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c96EK; else goto c96EL;
       c96EK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledMallocArray2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c96EL: // global
           I64[Sp - 24] = block_c96EG_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u96EP; else goto c96EH;
       u96EP: // global
           call _c96EG(R1) args: 0, res: 0, upd: 0;
       c96EH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96EG() //  [R1]
         { info_tbl: [(c96EG,
                       label: block_c96EG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96EG: // global
           R4 = I64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Pool.$wpooledMallocArray0_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.975094073 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMallocArray0_closure" {
     Foreign.Marshal.Pool.pooledMallocArray0_closure:
         const Foreign.Marshal.Pool.pooledMallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMallocArray0_entry() //  [R2, R3, R4]
         { info_tbl: [(c96F4,
                       label: Foreign.Marshal.Pool.pooledMallocArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96F4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledMallocArray2_entry(R4,
                                                              R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.978924404 UTC

[section ""data" . lvl22_r95nq_closure" {
     lvl22_r95nq_closure:
         const GHC.Types.I#_con_info;
         const 106;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.980561177 UTC

[section ""data" . lvl23_r95nr_closure" {
     lvl23_r95nr_closure:
         const GHC.Types.I#_con_info;
         const 19;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.98239403 UTC

[section ""data" . lvl24_r95ns_closure" {
     lvl24_r95ns_closure:
         const GHC.Types.I#_con_info;
         const 28;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.984107896 UTC

[section ""data" . lvl25_r95nt_closure" {
     lvl25_r95nt_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl3_r95n7_closure;
         const lvl4_r95n8_closure;
         const lvl6_r95na_closure;
         const lvl22_r95nq_closure+1;
         const lvl23_r95nr_closure+1;
         const lvl22_r95nq_closure+1;
         const lvl24_r95ns_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.98636788 UTC

[section ""data" . lvl26_r95nu_closure" {
     lvl26_r95nu_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl2_r95n6_closure;
         const lvl25_r95nt_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.988363282 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMalloc1_closure" {
     Foreign.Marshal.Pool.pooledMalloc1_closure:
         const Foreign.Marshal.Pool.pooledMalloc1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Pool.pooledMalloc1_entry() //  [R1]
         { info_tbl: [(c96Fm,
                       label: Foreign.Marshal.Pool.pooledMalloc1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Fm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96Fn; else goto c96Fo;
       c96Fn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c96Fo: // global
           (_c96Fj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c96Fj::I64 == 0) goto c96Fl; else goto c96Fk;
       c96Fl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c96Fk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c96Fj::I64;
           R2 = lvl26_r95nu_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:16.993804937 UTC

[section ""data" . Foreign.Marshal.Pool.pooledMalloc_closure" {
     Foreign.Marshal.Pool.pooledMalloc_closure:
         const Foreign.Marshal.Pool.pooledMalloc_info;
         const 0;
 },
 lvl27_s96oz_entry() //  [R1]
         { info_tbl: [(c96FF,
                       label: lvl27_s96oz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96FF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c96FG; else goto c96FH;
       c96FG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c96FH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Pool.pooledMalloc1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s96oT_entry() //  [R1, R2]
         { info_tbl: [(c96FQ,
                       label: sat_s96oT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96FQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96FR; else goto c96FS;
       c96FR: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c96FS: // global
           I64[Sp - 16] = block_c96FN_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u96Gl; else goto c96FO;
       u96Gl: // global
           call _c96FN(R1) args: 0, res: 0, upd: 0;
       c96FO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96FN() //  [R1]
         { info_tbl: [(c96FN,
                       label: block_c96FN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96FN: // global
           _s96oA::P64 = P64[Sp + 8];
           (_s96oI::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s96oI::I64 == 0) goto c96Gf; else goto c96Gb;
       c96Gf: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c96Gb: // global
           I64[Sp] = block_c96G4_info;
           R1 = _s96oA::P64;
           I64[Sp + 8] = _s96oI::I64;
           if (R1 & 7 != 0) goto u96Gk; else goto c96G5;
       u96Gk: // global
           call _c96G4(R1) args: 0, res: 0, upd: 0;
       c96G5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96G4() //  [R1]
         { info_tbl: [(c96G4,
                       label: block_c96G4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96G4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c96Ge; else goto c96Gd;
       c96Ge: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96Gd: // global
           _s96oL::P64 = P64[R1 + 7];
           _s96oO::P64 = P64[_s96oL::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           _c96G9::P64 = Hp - 31;
           P64[Hp - 8] = _c96G9::P64;
           P64[Hp] = _s96oO::P64;
           call MO_WriteBarrier();
           P64[_s96oL::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s96oL::P64);
           R1 = _c96G9::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Pool.pooledMalloc_entry() //  [R2]
         { info_tbl: [(c96Gm,
                       label: Foreign.Marshal.Pool.pooledMalloc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Gm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c96Gq; else goto c96Gp;
       c96Gq: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledMalloc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c96Gp: // global
           I64[Hp - 32] = lvl27_s96oz_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s96oT_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:17.00873746 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNewArray2_closure" {
     Foreign.Marshal.Pool.pooledNewArray2_closure:
         const Foreign.Marshal.Pool.pooledNewArray2_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNewArray2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c96H6,
                       label: Foreign.Marshal.Pool.pooledNewArray2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96H6: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c96Ha; else goto c96Hb;
       c96Ha: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledNewArray2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c96Hb: // global
           I64[Sp - 40] = block_c96H4_info;
           _s96oV::P64 = R3;
           R3 = 0;
           _s96oU::P64 = R2;
           R2 = R5;
           P64[Sp - 32] = _s96oU::P64;
           P64[Sp - 24] = _s96oV::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c96H4() //  [R1]
         { info_tbl: [(c96H4,
                       label: block_c96H4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96H4: // global
           I64[Sp - 8] = block_c96H9_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = Foreign.Marshal.Pool.pooledMallocArray1_closure;
           I64[Sp] = R1;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c96H9() //  [R1]
         { info_tbl: [(c96H9,
                       label: block_c96H9_info
                       rep:StackRep [True, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96H9: // global
           _s96oV::P64 = P64[Sp + 24];
           (_s96p8::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc((I64[Sp + 8] + 1) * I64[R1 + 7]);
           if (_s96p8::I64 == 0) goto c96HN; else goto c96HH;
       c96HN: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 48;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c96HH: // global
           I64[Sp + 8] = block_c96Hv_info;
           R1 = _s96oV::P64;
           I64[Sp + 24] = _s96p8::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u96HO; else goto c96Hw;
       u96HO: // global
           call _c96Hv(R1) args: 0, res: 0, upd: 0;
       c96Hw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96Hv() //  [R1]
         { info_tbl: [(c96Hv,
                       label: block_c96Hv_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Hv: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c96HK; else goto c96HJ;
       c96HK: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96HJ: // global
           _s96pb::P64 = P64[R1 + 7];
           _s96pe::P64 = P64[_s96pb::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           _c96HA::P64 = Hp - 31;
           P64[Hp - 8] = _c96HA::P64;
           P64[Hp] = _s96pe::P64;
           _s96oU::P64 = P64[Sp + 8];
           _s96oW::P64 = P64[Sp + 24];
           _s96oX::P64 = P64[Sp + 32];
           call MO_WriteBarrier();
           P64[_s96pb::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s96pb::P64);
           I64[Sp + 24] = block_c96HF_info;
           R5 = _s96oX::P64;
           R4 = _c96HA::P64;
           R3 = _s96oW::P64;
           R2 = _s96oU::P64;
           P64[Sp + 32] = _c96HA::P64;
           Sp = Sp + 24;
           call Foreign.Marshal.Array.newArray4_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c96HF() //  []
         { info_tbl: [(c96HF,
                       label: block_c96HF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96HF: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:17.02232004 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNewArray0_closure" {
     Foreign.Marshal.Pool.pooledNewArray0_closure:
         const Foreign.Marshal.Pool.pooledNewArray0_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNewArray0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c96Iq,
                       label: Foreign.Marshal.Pool.pooledNewArray0_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Iq: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledNewArray2_entry(R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:17.027114376 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNewArray1_closure" {
     Foreign.Marshal.Pool.pooledNewArray1_closure:
         const Foreign.Marshal.Pool.pooledNewArray1_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNewArray1_entry() //  [R2, R3, R4]
         { info_tbl: [(c96ID,
                       label: Foreign.Marshal.Pool.pooledNewArray1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96ID: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c96IH; else goto c96II;
       c96IH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledNewArray1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c96II: // global
           I64[Sp - 32] = block_c96IB_info;
           _s96pn::P64 = R3;
           R3 = 0;
           _s96pm::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _s96pm::P64;
           P64[Sp - 16] = _s96pn::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c96IB() //  [R1]
         { info_tbl: [(c96IB,
                       label: block_c96IB_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96IB: // global
           I64[Sp - 8] = block_c96IG_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = Foreign.Marshal.Pool.pooledMallocArray1_closure;
           I64[Sp] = R1;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c96IG() //  [R1]
         { info_tbl: [(c96IG,
                       label: block_c96IG_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96IG: // global
           _s96pn::P64 = P64[Sp + 24];
           (_s96py::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[Sp + 8] * I64[R1 + 7]);
           if (_s96py::I64 == 0) goto c96Jh; else goto c96Jb;
       c96Jh: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c96Jb: // global
           I64[Sp + 8] = block_c96IZ_info;
           R1 = _s96pn::P64;
           I64[Sp + 24] = _s96py::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u96Ji; else goto c96J0;
       u96Ji: // global
           call _c96IZ(R1) args: 0, res: 0, upd: 0;
       c96J0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96IZ() //  [R1]
         { info_tbl: [(c96IZ,
                       label: block_c96IZ_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96IZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c96Je; else goto c96Jd;
       c96Je: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96Jd: // global
           _s96pB::P64 = P64[R1 + 7];
           _s96pE::P64 = P64[_s96pB::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           _c96J4::P64 = Hp - 31;
           P64[Hp - 8] = _c96J4::P64;
           P64[Hp] = _s96pE::P64;
           _s96pm::P64 = P64[Sp + 8];
           _s96po::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_s96pB::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s96pB::P64);
           I64[Sp + 16] = block_c96J9_info;
           R4 = _s96po::P64;
           R3 = _c96J4::P64;
           R2 = _s96pm::P64;
           P64[Sp + 24] = _c96J4::P64;
           Sp = Sp + 16;
           call Foreign.Marshal.Array.newArray2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c96J9() //  []
         { info_tbl: [(c96J9,
                       label: block_c96J9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96J9: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:17.040894534 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNewArray_closure" {
     Foreign.Marshal.Pool.pooledNewArray_closure:
         const Foreign.Marshal.Pool.pooledNewArray_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNewArray_entry() //  [R2, R3, R4]
         { info_tbl: [(c96JT,
                       label: Foreign.Marshal.Pool.pooledNewArray_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96JT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledNewArray1_entry(R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:17.045499126 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNew1_closure" {
     Foreign.Marshal.Pool.pooledNew1_closure:
         const Foreign.Marshal.Pool.pooledNew1_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNew1_entry() //  [R2, R3, R4]
         { info_tbl: [(c96K6,
                       label: Foreign.Marshal.Pool.pooledNew1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96K6: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c96K7; else goto c96K8;
       c96K7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Pool.pooledNew1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c96K8: // global
           I64[Sp - 32] = block_c96K4_info;
           _s96pM::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = Foreign.Marshal.Pool.pooledMalloc1_closure;
           P64[Sp - 24] = _s96pM::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 48;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c96K4() //  [R1]
         { info_tbl: [(c96K4,
                       label: block_c96K4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96K4: // global
           _s96pN::P64 = P64[Sp + 16];
           (_s96pW::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s96pW::I64 == 0) goto c96KC; else goto c96Kw;
       c96KC: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c96Kw: // global
           I64[Sp] = block_c96Kk_info;
           R1 = _s96pN::P64;
           I64[Sp + 16] = _s96pW::I64;
           if (R1 & 7 != 0) goto u96KD; else goto c96Kl;
       u96KD: // global
           call _c96Kk(R1) args: 0, res: 0, upd: 0;
       c96Kl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96Kk() //  [R1]
         { info_tbl: [(c96Kk,
                       label: block_c96Kk_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Kk: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c96Kz; else goto c96Ky;
       c96Kz: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96Ky: // global
           _s96pZ::P64 = P64[R1 + 7];
           _s96q2::P64 = P64[_s96pZ::P64 + 8];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = :_con_info;
           _c96Kp::P64 = Hp - 31;
           P64[Hp - 8] = _c96Kp::P64;
           P64[Hp] = _s96q2::P64;
           _s96pM::P64 = P64[Sp + 8];
           _s96pO::P64 = P64[Sp + 24];
           call MO_WriteBarrier();
           P64[_s96pZ::P64 + 8] = Hp - 14;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _s96pZ::P64);
           I64[Sp + 16] = block_c96Ku_info;
           R2 = _s96pM::P64;
           I64[Sp - 8] = stg_ap_ppv_info;
           P64[Sp] = _c96Kp::P64;
           P64[Sp + 8] = _s96pO::P64;
           P64[Sp + 24] = _c96Kp::P64;
           Sp = Sp - 8;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c96Ku() //  []
         { info_tbl: [(c96Ku,
                       label: block_c96Ku_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Ku: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:17.057509012 UTC

[section ""data" . Foreign.Marshal.Pool.pooledNew_closure" {
     Foreign.Marshal.Pool.pooledNew_closure:
         const Foreign.Marshal.Pool.pooledNew_info;
         const 0;
 },
 Foreign.Marshal.Pool.pooledNew_entry() //  [R2, R3, R4]
         { info_tbl: [(c96L9,
                       label: Foreign.Marshal.Pool.pooledNew_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96L9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Pool.pooledNew1_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:17.061970373 UTC

[section ""data" . Foreign.Marshal.Pool.freePool2_closure" {
     Foreign.Marshal.Pool.freePool2_closure:
         const Foreign.Marshal.Pool.freePool2_info;
 },
 Foreign.Marshal.Pool.freePool2_entry() //  [R2]
         { info_tbl: [(c96Lr,
                       label: Foreign.Marshal.Pool.freePool2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Lr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96Ls; else goto u96LI;
       c96Ls: // global
           R2 = R2;
           R1 = Foreign.Marshal.Pool.freePool2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u96LI: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c96Lh() args: 0, res: 0, upd: 0;
     }
 },
 _c96Lh() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Lh: // global
           _s96qa::P64 = P64[Sp];
           I64[Sp] = block_c96Lk_info;
           R1 = _s96qa::P64;
           if (R1 & 7 != 0) goto u96LK; else goto c96Ll;
       u96LK: // global
           call _c96Lk(R1) args: 0, res: 0, upd: 0;
       c96Ll: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96Lk() //  [R1]
         { info_tbl: [(c96Lk,
                       label: block_c96Lk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Lk: // global
           if (R1 & 7 == 1) goto c96Lo; else goto c96Lp;
       c96Lo: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c96Lp: // global
           I64[Sp - 8] = block_c96Lz_info;
           _s96qe::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s96qe::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u96LL; else goto c96LB;
       u96LL: // global
           call _c96Lz(R1) args: 0, res: 0, upd: 0;
       c96LB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96Lz() //  [R1]
         { info_tbl: [(c96Lz,
                       label: block_c96Lz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Lz: // global
           _s96qe::P64 = P64[Sp + 8];
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[R1 + 7]);
           P64[Sp + 8] = _s96qe::P64;
           Sp = Sp + 8;
           call _c96Lh() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:17.070576631 UTC

[section ""data" . Foreign.Marshal.Pool.freePool1_closure" {
     Foreign.Marshal.Pool.freePool1_closure:
         const Foreign.Marshal.Pool.freePool1_info;
 },
 Foreign.Marshal.Pool.freePool1_entry() //  [R2]
         { info_tbl: [(c96Mg,
                       label: Foreign.Marshal.Pool.freePool1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Mg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c96Mh; else goto c96Mi;
       c96Mh: // global
           R2 = R2;
           R1 = Foreign.Marshal.Pool.freePool1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c96Mi: // global
           I64[Sp - 8] = block_c96Md_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u96Mm; else goto c96Me;
       u96Mm: // global
           call _c96Md(R1) args: 0, res: 0, upd: 0;
       c96Me: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96Md() //  [R1]
         { info_tbl: [(c96Md,
                       label: block_c96Md_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Md: // global
           R2 = P64[P64[R1 + 7] + 8];
           Sp = Sp + 8;
           call Foreign.Marshal.Pool.freePool2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:17.076450072 UTC

[section ""data" . Foreign.Marshal.Pool.freePool_closure" {
     Foreign.Marshal.Pool.freePool_closure:
         const Foreign.Marshal.Pool.freePool_info;
 },
 Foreign.Marshal.Pool.freePool_entry() //  [R2]
         { info_tbl: [(c96MC,
                       label: Foreign.Marshal.Pool.freePool_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96MC: // global
           R2 = R2;
           call Foreign.Marshal.Pool.freePool1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:17.079951676 UTC

[section ""data" . Foreign.Marshal.Pool.newPool1_closure" {
     Foreign.Marshal.Pool.newPool1_closure:
         const Foreign.Marshal.Pool.newPool1_info;
 },
 Foreign.Marshal.Pool.newPool1_entry() //  []
         { info_tbl: [(c96MQ,
                       label: Foreign.Marshal.Pool.newPool1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96MQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c96MR; else goto c96MS;
       c96MR: // global
           R1 = Foreign.Marshal.Pool.newPool1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c96MS: // global
           I64[Sp - 8] = block_c96MN_info;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96MN() //  [R1]
         { info_tbl: [(c96MN,
                       label: block_c96MN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96MN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c96MV; else goto c96MU;
       c96MV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96MU: // global
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:17.085585474 UTC

[section ""data" . Foreign.Marshal.Pool.newPool_closure" {
     Foreign.Marshal.Pool.newPool_closure:
         const Foreign.Marshal.Pool.newPool_info;
 },
 Foreign.Marshal.Pool.newPool_entry() //  []
         { info_tbl: [(c96Nc,
                       label: Foreign.Marshal.Pool.newPool_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Nc: // global
           call Foreign.Marshal.Pool.newPool1_entry() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:17.091650005 UTC

[section ""data" . Foreign.Marshal.Pool.withPool1_closure" {
     Foreign.Marshal.Pool.withPool1_closure:
         const Foreign.Marshal.Pool.withPool1_info;
 },
 sat_s96qI_entry() //  [R1]
         { info_tbl: [(c96NB,
                       label: sat_s96qI_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96NB: // global
           _s96qI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c96NC; else goto c96ND;
       c96ND: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c96NF; else goto c96NE;
       c96NF: // global
           HpAlloc = 16;
           goto c96NC;
       c96NC: // global
           R1 = _s96qI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c96NE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s96qI::P64;
           _s96qw::P64 = P64[_s96qI::P64 + 16];
           _s96qG::P64 = P64[_s96qI::P64 + 24];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _s96qG::P64;
           R2 = Hp - 7;
           R1 = _s96qw::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s96qW_entry() //  [R1]
         { info_tbl: [(c96NZ,
                       label: sat_s96qW_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96NZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c96O0; else goto c96O1;
       c96O0: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c96O1: // global
           _s96qR::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp - 24] = block_c96NX_info;
           R2 = _s96qR::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 24;
           call Foreign.Marshal.Pool.freePool2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c96NX() //  []
         { info_tbl: [(c96NX,
                       label: block_c96NX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96NX: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s96qX_entry() //  [R1, R2]
         { info_tbl: [(c96O3,
                       label: sat_s96qX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96O3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96O4; else goto c96O5;
       c96O4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c96O5: // global
           I64[Sp - 16] = block_c96NN_info;
           _s96qG::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _s96qG::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u96O9; else goto c96NO;
       u96O9: // global
           call _c96NN(R1) args: 0, res: 0, upd: 0;
       c96NO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96NN() //  [R1]
         { info_tbl: [(c96NN,
                       label: block_c96NN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96NN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c96O8; else goto c96O7;
       c96O8: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96O7: // global
           _s96qM::P64 = P64[R1 + 7];
           _s96qN::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_s96qW_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _s96qM::P64;
           P64[Hp] = _s96qN::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s96r8_entry() //  [R2]
         { info_tbl: [(c96Oh,
                       label: sat_s96r8_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Oh: // global
           R1 = R2;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s96rs_entry() //  [R1]
         { info_tbl: [(c96OJ,
                       label: sat_s96rs_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96OJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c96OK; else goto c96OL;
       c96OK: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c96OL: // global
           _s96rn::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp - 24] = block_c96OH_info;
           R2 = _s96rn::P64;
           P64[Sp - 16] = P64[R1 + 15];
           P64[Sp - 8] = P64[R1 + 23];
           Sp = Sp - 24;
           call Foreign.Marshal.Pool.freePool2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c96OH() //  []
         { info_tbl: [(c96OH,
                       label: block_c96OH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96OH: // global
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Exception.throw_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s96rt_entry() //  [R1, R2]
         { info_tbl: [(c96ON,
                       label: sat_s96rt_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96ON: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96OO; else goto c96OP;
       c96OO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c96OP: // global
           I64[Sp - 16] = block_c96Ox_info;
           _s96rc::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 8] = _s96rc::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u96OT; else goto c96Oy;
       u96OT: // global
           call _c96Ox(R1) args: 0, res: 0, upd: 0;
       c96Oy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96Ox() //  [R1]
         { info_tbl: [(c96Ox,
                       label: block_c96Ox_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Ox: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c96OS; else goto c96OR;
       c96OS: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96OR: // global
           _s96ri::P64 = P64[R1 + 7];
           _s96rj::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_s96rs_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _s96ri::P64;
           P64[Hp] = _s96rj::P64;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s96re_entry() //  [R1]
         { info_tbl: [(c96OZ,
                       label: sat_s96re_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96OZ: // global
           _s96re::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c96P0; else goto c96P1;
       c96P1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c96P3; else goto c96P2;
       c96P3: // global
           HpAlloc = 16;
           goto c96P0;
       c96P0: // global
           R1 = _s96re::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c96P2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s96re::P64;
           _s96qw::P64 = P64[_s96re::P64 + 16];
           _s96rc::P64 = P64[_s96re::P64 + 24];
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _s96rc::P64;
           R2 = Hp - 7;
           R1 = _s96qw::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s96rf_entry() //  [R1]
         { info_tbl: [(c96P9,
                       label: sat_s96rf_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96P9: // global
           R1 = P64[R1 + 7];
           call stg_unmaskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s96rD_entry() //  [R1]
         { info_tbl: [(c96Pg,
                       label: sat_s96rD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Pg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c96Ph; else goto c96Pi;
       c96Ph: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       c96Pi: // global
           I64[Sp - 16] = block_c96Oq_info;
           _s96qw::P64 = P64[R1 + 7];
           R1 = GHC.Types.[]_closure+1;
           P64[Sp - 8] = _s96qw::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96Oq() //  [R1]
         { info_tbl: [(c96Oq,
                       label: block_c96Oq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Oq: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c96Pl; else goto c96Pk;
       c96Pl: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96Pk: // global
           I64[Hp - 56] = sat_s96rt_info;
           P64[Hp - 48] = R1;
           I64[Hp - 40] = sat_s96re_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = sat_s96rf_info;
           P64[Hp] = Hp - 40;
           I64[Sp] = block_c96Pc_info;
           R2 = Hp - 55;
           _s96rc::P64 = R1;
           R1 = Hp - 7;
           P64[Sp + 8] = _s96rc::P64;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96Pc() //  [R1]
         { info_tbl: [(c96Pc,
                       label: block_c96Pc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Pc: // global
           _s96rz::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = block_c96Pe_info;
           R2 = _s96rz::P64;
           P64[Sp + 8] = R1;
           call Foreign.Marshal.Pool.freePool2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c96Pe() //  []
         { info_tbl: [(c96Pe,
                       label: block_c96Pe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Pe: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s96rE_entry() //  [R2]
         { info_tbl: [(c96Pu,
                       label: sat_s96rE_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Pu: // global
           R1 = R2;
           call stg_maskUninterruptible#(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Pool.withPool1_entry() //  [R2]
         { info_tbl: [(c96PB,
                       label: Foreign.Marshal.Pool.withPool1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96PB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c96PC; else goto c96PD;
       c96PC: // global
           R2 = R2;
           R1 = Foreign.Marshal.Pool.withPool1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c96PD: // global
           I64[Sp - 16] = block_c96Nn_info;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_getMaskingState#() args: 8, res: 8, upd: 8;
     }
 },
 _c96Nn() //  [R1]
         { info_tbl: [(c96Nn,
                       label: block_c96Nn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Nn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c96PG; else goto c96PF;
       c96PG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c96PF: // global
           if (R1 == 0) goto c96Pz; else goto u96PU;
       c96Pz: // global
           I64[Hp - 8] = sat_s96rD_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 7;
           Sp = Sp + 16;
           call stg_maskAsyncExceptions#(R1) args: 8, res: 0, upd: 8;
       u96PU: // global
           if (R1 == 1) goto c96PA; else goto c96Py;
       c96PA: // global
           I64[Hp - 8] = sat_s96rE_info;
           _s96qC::P64 = Hp - 6;
           goto s96qB;
       c96Py: // global
           I64[Hp - 8] = sat_s96r8_info;
           _s96qC::P64 = Hp - 6;
           goto s96qB;
       s96qB: // global
           I64[Sp - 8] = block_c96Nu_info;
           R1 = GHC.Types.[]_closure+1;
           P64[Sp] = _s96qC::P64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96Nu() //  [R1]
         { info_tbl: [(c96Nu,
                       label: block_c96Nu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96Nu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c96PN; else goto c96PM;
       c96PN: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96PM: // global
           I64[Hp - 24] = sat_s96qI_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           _s96qC::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c96NG_info;
           R2 = Hp - 24;
           _s96qG::P64 = R1;
           R1 = _s96qC::P64;
           P64[Sp + 16] = _s96qG::P64;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96NG() //  [R1]
         { info_tbl: [(c96NG,
                       label: block_c96NG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96NG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c96PQ; else goto c96PP;
       c96PQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c96PP: // global
           I64[Hp - 8] = sat_s96qX_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_c96PH_info;
           R2 = Hp - 7;
           R1 = R1;
           call stg_catch#(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c96PH() //  [R1]
         { info_tbl: [(c96PH,
                       label: block_c96PH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96PH: // global
           _s96r3::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = block_c96PJ_info;
           R2 = _s96r3::P64;
           P64[Sp + 8] = R1;
           call Foreign.Marshal.Pool.freePool2_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _c96PJ() //  []
         { info_tbl: [(c96PJ,
                       label: block_c96PJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96PJ: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:17.136989102 UTC

[section ""data" . Foreign.Marshal.Pool.withPool_closure" {
     Foreign.Marshal.Pool.withPool_closure:
         const Foreign.Marshal.Pool.withPool_info;
 },
 Foreign.Marshal.Pool.withPool_entry() //  [R2]
         { info_tbl: [(c96S2,
                       label: Foreign.Marshal.Pool.withPool_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c96S2: // global
           R2 = R2;
           call Foreign.Marshal.Pool.withPool1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:17.140131391 UTC

[section ""relreadonly" . S96tm_srt" {
     S96tm_srt:
         const Foreign.Marshal.Error.throwIf2_closure;
         const Foreign.Marshal.Alloc.realloc2_closure;
         const Foreign.Marshal.Pool.$wpooledReallocBytes_closure;
         const Foreign.Marshal.Pool.pooledRealloc1_closure;
         const GHC.Err.undefined_closure;
         const lvl11_r95nf_closure;
         const Foreign.Marshal.Pool.pooledReallocArray1_closure;
         const Foreign.Marshal.Pool.pooledReallocArray_closure;
         const Foreign.Marshal.Pool.pooledReallocArray2_closure;
         const lvl16_r95nk_closure;
         const Foreign.Marshal.Pool.pooledRealloc3_closure;
         const Foreign.Marshal.Pool.pooledRealloc_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Pool.pooledMallocBytes1_closure;
         const lvl21_r95np_closure;
         const Foreign.Marshal.Pool.pooledMallocArray1_closure;
         const Foreign.Marshal.Pool.pooledMallocArray_closure;
         const Foreign.Marshal.Pool.$wpooledMallocArray0_closure;
         const Foreign.Marshal.Pool.pooledMallocArray2_closure;
         const lvl26_r95nu_closure;
         const Foreign.Marshal.Pool.pooledMalloc1_closure;
         const Foreign.Marshal.Pool.pooledMalloc_closure;
         const Foreign.Marshal.Pool.pooledNewArray2_closure;
         const Foreign.Marshal.Pool.pooledNewArray1_closure;
         const Foreign.Marshal.Pool.pooledNew1_closure;
 }]

