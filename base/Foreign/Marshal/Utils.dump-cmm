
==================== Output Cmm ====================
2018-03-16 16:03:57.971250624 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:57.971818956 UTC

[section ""cstring" . lvl_r8Ohb_bytes" {
     lvl_r8Ohb_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.972618942 UTC

[section ""data" . lvl1_r8Ohc_closure" {
     lvl1_r8Ohc_closure:
         const lvl1_r8Ohc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r8Ohc_entry() //  [R1]
         { info_tbl: [(c8OjE,
                       label: lvl1_r8Ohc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OjE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OjF; else goto c8OjG;
       c8OjF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8OjG: // global
           (_c8OjB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8OjB::I64 == 0) goto c8OjD; else goto c8OjC;
       c8OjD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8OjC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8OjB::I64;
           R2 = lvl_r8Ohb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.973586278 UTC

[section ""cstring" . Foreign.Marshal.Utils.$trModule4_bytes" {
     Foreign.Marshal.Utils.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.974314709 UTC

[section ""data" . lvl2_r8Ohd_closure" {
     lvl2_r8Ohd_closure:
         const lvl2_r8Ohd_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r8Ohd_entry() //  [R1]
         { info_tbl: [(c8OjN,
                       label: lvl2_r8Ohd_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OjN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OjO; else goto c8OjP;
       c8OjO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8OjP: // global
           (_c8OjK::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8OjK::I64 == 0) goto c8OjM; else goto c8OjL;
       c8OjM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8OjL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8OjK::I64;
           R2 = Foreign.Marshal.Utils.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.975215262 UTC

[section ""cstring" . lvl3_r8Ohe_bytes" {
     lvl3_r8Ohe_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,65,108,108,111,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.975961807 UTC

[section ""data" . lvl4_r8Ohf_closure" {
     lvl4_r8Ohf_closure:
         const lvl4_r8Ohf_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r8Ohf_entry() //  [R1]
         { info_tbl: [(c8OjW,
                       label: lvl4_r8Ohf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OjW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OjX; else goto c8OjY;
       c8OjX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8OjY: // global
           (_c8OjT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8OjT::I64 == 0) goto c8OjV; else goto c8OjU;
       c8OjV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8OjU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8OjT::I64;
           R2 = lvl3_r8Ohe_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.976870525 UTC

[section ""cstring" . lvl5_r8Ohg_bytes" {
     lvl5_r8Ohg_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,77,97,114,115,104,97,108,47,65,108,108,111,99,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.977605143 UTC

[section ""data" . lvl6_r8Ohh_closure" {
     lvl6_r8Ohh_closure:
         const lvl6_r8Ohh_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r8Ohh_entry() //  [R1]
         { info_tbl: [(c8Ok5,
                       label: lvl6_r8Ohh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ok5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ok6; else goto c8Ok7;
       c8Ok6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ok7: // global
           (_c8Ok2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Ok2::I64 == 0) goto c8Ok4; else goto c8Ok3;
       c8Ok4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Ok3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Ok2::I64;
           R2 = lvl5_r8Ohg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.978520684 UTC

[section ""data" . lvl7_r8Ohi_closure" {
     lvl7_r8Ohi_closure:
         const GHC.Types.I#_con_info;
         const 84;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.97911022 UTC

[section ""data" . lvl8_r8Ohj_closure" {
     lvl8_r8Ohj_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.979670503 UTC

[section ""data" . lvl9_r8Ohk_closure" {
     lvl9_r8Ohk_closure:
         const GHC.Types.I#_con_info;
         const 41;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.980253778 UTC

[section ""data" . lvl10_r8Ohl_closure" {
     lvl10_r8Ohl_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8Ohd_closure;
         const lvl4_r8Ohf_closure;
         const lvl6_r8Ohh_closure;
         const lvl7_r8Ohi_closure+1;
         const lvl8_r8Ohj_closure+1;
         const lvl7_r8Ohi_closure+1;
         const lvl9_r8Ohk_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.980864744 UTC

[section ""data" . lvl11_r8Ohm_closure" {
     lvl11_r8Ohm_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8Ohc_closure;
         const lvl10_r8Ohl_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.981669866 UTC

[section ""data" . Foreign.Marshal.Utils.new2_closure" {
     Foreign.Marshal.Utils.new2_closure:
         const Foreign.Marshal.Utils.new2_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Utils.new2_entry() //  [R1]
         { info_tbl: [(c8Oke,
                       label: Foreign.Marshal.Utils.new2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oke: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Okf; else goto c8Okg;
       c8Okf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Okg: // global
           (_c8Okb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Okb::I64 == 0) goto c8Okd; else goto c8Okc;
       c8Okd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Okc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Okb::I64;
           R2 = lvl11_r8Ohm_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.983111432 UTC

[section ""data" . Foreign.Marshal.Utils.new1_closure" {
     Foreign.Marshal.Utils.new1_closure:
         const Foreign.Marshal.Utils.new1_info;
         const 0;
 },
 Foreign.Marshal.Utils.new1_entry() //  [R2, R3]
         { info_tbl: [(c8Oko,
                       label: Foreign.Marshal.Utils.new1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oko: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8Okp; else goto c8Okq;
       c8Okp: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.new1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Okq: // global
           I64[Sp - 24] = block_c8Okm_info;
           _s8Ohx::P64 = R2;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = Foreign.Marshal.Utils.new2_closure;
           P64[Sp - 16] = _s8Ohx::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8Okm() //  [R1]
         { info_tbl: [(c8Okm,
                       label: block_c8Okm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Okm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Okv; else goto c8Oku;
       c8Okv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Oku: // global
           _s8Ohx::P64 = P64[Sp + 8];
           _s8Ohy::P64 = P64[Sp + 16];
           (_s8OhG::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s8OhG::I64 == 0) goto c8OkK; else goto c8OkH;
       c8OkK: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8OkH: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8OhG::I64;
           I64[Sp + 8] = block_c8OkF_info;
           R2 = _s8Ohx::P64;
           I64[Sp - 16] = stg_ap_ppv_info;
           _c8OkE::P64 = Hp - 7;
           P64[Sp - 8] = _c8OkE::P64;
           P64[Sp] = _s8Ohy::P64;
           P64[Sp + 16] = _c8OkE::P64;
           Sp = Sp - 16;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8OkF() //  []
         { info_tbl: [(c8OkF,
                       label: block_c8OkF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OkF: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.984711106 UTC

[section ""data" . Foreign.Marshal.Utils.new_closure" {
     Foreign.Marshal.Utils.new_closure:
         const Foreign.Marshal.Utils.new_info;
         const 0;
 },
 Foreign.Marshal.Utils.new_entry() //  [R2, R3]
         { info_tbl: [(c8OkP,
                       label: Foreign.Marshal.Utils.new_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OkP: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.new1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.985467353 UTC

[section ""data" . lvl12_r8Ohn_closure" {
     lvl12_r8Ohn_closure:
         const GHC.Types.I#_con_info;
         const 117;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.986077178 UTC

[section ""data" . lvl13_r8Oho_closure" {
     lvl13_r8Oho_closure:
         const GHC.Types.I#_con_info;
         const 60;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.986677492 UTC

[section ""data" . lvl14_r8Ohp_closure" {
     lvl14_r8Ohp_closure:
         const GHC.Types.I#_con_info;
         const 69;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.987256283 UTC

[section ""data" . lvl15_r8Ohq_closure" {
     lvl15_r8Ohq_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8Ohd_closure;
         const lvl4_r8Ohf_closure;
         const lvl6_r8Ohh_closure;
         const lvl12_r8Ohn_closure+1;
         const lvl13_r8Oho_closure+1;
         const lvl12_r8Ohn_closure+1;
         const lvl14_r8Ohp_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.987888207 UTC

[section ""data" . lvl16_r8Ohr_closure" {
     lvl16_r8Ohr_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8Ohc_closure;
         const lvl15_r8Ohq_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.988675443 UTC

[section ""data" . Foreign.Marshal.Utils.with2_closure" {
     Foreign.Marshal.Utils.with2_closure:
         const Foreign.Marshal.Utils.with2_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Utils.with2_entry() //  [R1]
         { info_tbl: [(c8OkY,
                       label: Foreign.Marshal.Utils.with2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OkY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OkZ; else goto c8Ol0;
       c8OkZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ol0: // global
           (_c8OkV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8OkV::I64 == 0) goto c8OkX; else goto c8OkW;
       c8OkX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8OkW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8OkV::I64;
           R2 = lvl16_r8Ohr_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.989594912 UTC

[section ""data" . lvl17_r8Ohs_closure" {
     lvl17_r8Ohs_closure:
         const GHC.Types.I#_con_info;
         const 31;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.990170736 UTC

[section ""data" . lvl18_r8Oht_closure" {
     lvl18_r8Oht_closure:
         const GHC.Types.I#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.991576927 UTC

[section ""data" . lvl19_r8Ohu_closure" {
     lvl19_r8Ohu_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8Ohd_closure;
         const lvl4_r8Ohf_closure;
         const lvl6_r8Ohh_closure;
         const lvl12_r8Ohn_closure+1;
         const lvl17_r8Ohs_closure+1;
         const lvl12_r8Ohn_closure+1;
         const lvl18_r8Oht_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.992221975 UTC

[section ""data" . lvl20_r8Ohv_closure" {
     lvl20_r8Ohv_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8Ohc_closure;
         const lvl19_r8Ohu_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.992957418 UTC

[section ""data" . Foreign.Marshal.Utils.with3_closure" {
     Foreign.Marshal.Utils.with3_closure:
         const Foreign.Marshal.Utils.with3_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Utils.with3_entry() //  [R1]
         { info_tbl: [(c8Ol7,
                       label: Foreign.Marshal.Utils.with3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ol7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ol8; else goto c8Ol9;
       c8Ol8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ol9: // global
           (_c8Ol4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Ol4::I64 == 0) goto c8Ol6; else goto c8Ol5;
       c8Ol6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Ol5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Ol4::I64;
           R2 = lvl20_r8Ohv_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.994704106 UTC

[section ""data" . Foreign.Marshal.Utils.with1_closure" {
     Foreign.Marshal.Utils.with1_closure:
         const Foreign.Marshal.Utils.with1_info;
         const 0;
 },
 Foreign.Marshal.Utils.with1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Olg,
                       label: Foreign.Marshal.Utils.with1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Olg: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8Olk; else goto c8Oll;
       c8Olk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.with1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Oll: // global
           I64[Sp - 32] = block_c8Ole_info;
           _s8OhM::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = Foreign.Marshal.Utils.with3_closure;
           P64[Sp - 24] = _s8OhM::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 48;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8Ole() //  [R1]
         { info_tbl: [(c8Ole,
                       label: block_c8Ole_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ole: // global
           I64[Sp - 8] = block_c8Olj_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = Foreign.Marshal.Utils.with2_closure;
           I64[Sp] = I64[R1 + 7];
           Sp = Sp - 24;
           call Foreign.Storable.alignment_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8Olj() //  [R1]
         { info_tbl: [(c8Olj,
                       label: block_c8Olj_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Olj: // global
           _s8OhR::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c8Olq_info;
           R2 = I64[R1 + 7];
           R1 = _s8OhR::I64;
           Sp = Sp + 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Olq() //  [R1]
         { info_tbl: [(c8Olq,
                       label: block_c8Olq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Olq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Olv; else goto c8Olu;
       c8Olv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Olu: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           P64[Hp] = R1 + 16;
           I64[Sp] = block_c8OlA_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_ppv_info;
           _c8Olz::P64 = Hp - 7;
           P64[Sp - 16] = _c8Olz::P64;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 8] = R1;
           P64[Sp + 16] = _c8Olz::P64;
           Sp = Sp - 24;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8OlA() //  []
         { info_tbl: [(c8OlA,
                       label: block_c8OlA_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OlA: // global
           I64[Sp] = block_c8OlC_info;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 24];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OlC() //  [R1]
         { info_tbl: [(c8OlC,
                       label: block_c8OlC_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OlC: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.996575007 UTC

[section ""data" . Foreign.Marshal.Utils.with_closure" {
     Foreign.Marshal.Utils.with_closure:
         const Foreign.Marshal.Utils.with_info;
         const 0;
 },
 Foreign.Marshal.Utils.with_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OlL,
                       label: Foreign.Marshal.Utils.with_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OlL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.with1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.997495418 UTC

[section ""data" . Foreign.Marshal.Utils.fromBool2_closure" {
     Foreign.Marshal.Utils.fromBool2_closure:
         const Foreign.Marshal.Utils.fromBool2_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Utils.fromBool2_entry() //  [R1]
         { info_tbl: [(c8OlU,
                       label: Foreign.Marshal.Utils.fromBool2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OlU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OlV; else goto c8OlW;
       c8OlV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8OlW: // global
           (_c8OlR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8OlR::I64 == 0) goto c8OlT; else goto c8OlS;
       c8OlT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8OlS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8OlR::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.998393744 UTC

[section ""data" . sat_s8Oi9_closure" {
     sat_s8Oi9_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.998942738 UTC

[section ""data" . sat_s8Oia_closure" {
     sat_s8Oia_closure:
         const :_con_info;
         const sat_s8Oi9_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:57.999651824 UTC

[section ""data" . Foreign.Marshal.Utils.fromBool1_closure" {
     Foreign.Marshal.Utils.fromBool1_closure:
         const Foreign.Marshal.Utils.fromBool1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Utils.fromBool1_entry() //  [R1]
         { info_tbl: [(c8Om3,
                       label: Foreign.Marshal.Utils.fromBool1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Om3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Om4; else goto c8Om5;
       c8Om4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Om5: // global
           (_c8Om0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Om0::I64 == 0) goto c8Om2; else goto c8Om1;
       c8Om2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Om1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Om0::I64;
           R3 = sat_s8Oia_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.000795071 UTC

[section ""data" . Foreign.Marshal.Utils.fromBool_closure" {
     Foreign.Marshal.Utils.fromBool_closure:
         const Foreign.Marshal.Utils.fromBool_info;
         const 0;
 },
 Foreign.Marshal.Utils.fromBool_entry() //  [R2, R3]
         { info_tbl: [(c8Omh,
                       label: Foreign.Marshal.Utils.fromBool_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Omh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Omi; else goto c8Omj;
       c8Omi: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.fromBool_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Omj: // global
           I64[Sp - 16] = block_c8Oma_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Omq; else goto c8Omb;
       u8Omq: // global
           call _c8Oma(R1) args: 0, res: 0, upd: 0;
       c8Omb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Oma() //  [R1]
         { info_tbl: [(c8Oma,
                       label: block_c8Oma_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oma: // global
           _s8Oib::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8Ome; else goto c8Omf;
       c8Ome: // global
           R2 = _s8Oib::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = Foreign.Marshal.Utils.fromBool2_closure;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
       c8Omf: // global
           R2 = _s8Oib::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = Foreign.Marshal.Utils.fromBool1_closure;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.002381047 UTC

[section ""data" . Foreign.Marshal.Utils.toBool_closure" {
     Foreign.Marshal.Utils.toBool_closure:
         const Foreign.Marshal.Utils.toBool_info;
         const 0;
 },
 ds_s8Oig_entry() //  [R1]
         { info_tbl: [(c8Omz,
                       label: ds_s8Oig_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Omz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8OmA; else goto c8OmB;
       c8OmA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8OmB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Utils.fromBool2_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8Oii_entry() //  [R1, R2]
         { info_tbl: [(c8OmH,
                       label: sat_s8Oii_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OmH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8OmI; else goto c8OmJ;
       c8OmI: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8OmJ: // global
           _s8Oih::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s8Oih::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes./=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Utils.toBool_entry() //  [R2, R3]
         { info_tbl: [(c8OmK,
                       label: Foreign.Marshal.Utils.toBool_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OmK: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8OmO; else goto c8OmN;
       c8OmO: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.toBool_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OmN: // global
           I64[Hp - 40] = ds_s8Oig_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s8Oii_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.004013293 UTC

[section ""data" . Foreign.Marshal.Utils.maybeNew1_closure" {
     Foreign.Marshal.Utils.maybeNew1_closure:
         const Foreign.Marshal.Utils.maybeNew1_info;
 },
 Foreign.Marshal.Utils.maybeNew1_entry() //  [R2, R3]
         { info_tbl: [(c8On0,
                       label: Foreign.Marshal.Utils.maybeNew1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8On0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8On1; else goto c8On2;
       c8On1: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.maybeNew1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8On2: // global
           I64[Sp - 16] = block_c8OmT_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8On9; else goto c8OmU;
       u8On9: // global
           call _c8OmT(R1) args: 0, res: 0, upd: 0;
       c8OmU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OmT() //  [R1]
         { info_tbl: [(c8OmT,
                       label: block_c8OmT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OmT: // global
           if (R1 & 7 == 1) goto c8OmX; else goto c8OmY;
       c8OmX: // global
           R1 = GHC.Ptr.nullPtr_closure;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8OmY: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.0052095 UTC

[section ""data" . Foreign.Marshal.Utils.maybeNew_closure" {
     Foreign.Marshal.Utils.maybeNew_closure:
         const Foreign.Marshal.Utils.maybeNew_info;
 },
 Foreign.Marshal.Utils.maybeNew_entry() //  [R2, R3]
         { info_tbl: [(c8One,
                       label: Foreign.Marshal.Utils.maybeNew_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8One: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.maybeNew1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.006348624 UTC

[section ""data" . Foreign.Marshal.Utils.maybeWith_n_closure" {
     Foreign.Marshal.Utils.maybeWith_n_closure:
         const Foreign.Marshal.Utils.maybeWith_n_info;
 },
 Foreign.Marshal.Utils.maybeWith_n_entry() //  [R2]
         { info_tbl: [(c8Onl,
                       label: Foreign.Marshal.Utils.maybeWith_n_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Onl: // global
           _s8Oio::P64 = R2;
           R2 = GHC.Ptr.nullPtr_closure;
           R1 = _s8Oio::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.007296345 UTC

[section ""data" . Foreign.Marshal.Utils.maybeWith_closure" {
     Foreign.Marshal.Utils.maybeWith_closure:
         const Foreign.Marshal.Utils.maybeWith_info;
 },
 Foreign.Marshal.Utils.maybeWith_entry() //  [R2, R3]
         { info_tbl: [(c8Onz,
                       label: Foreign.Marshal.Utils.maybeWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Onz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OnA; else goto c8OnB;
       c8OnA: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.maybeWith_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OnB: // global
           I64[Sp - 16] = block_c8Ons_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8OnI; else goto c8Ont;
       u8OnI: // global
           call _c8Ons(R1) args: 0, res: 0, upd: 0;
       c8Ont: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ons() //  [R1]
         { info_tbl: [(c8Ons,
                       label: block_c8Ons_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ons: // global
           if (R1 & 7 == 1) goto c8Onw; else goto c8Onx;
       c8Onw: // global
           R1 = Foreign.Marshal.Utils.maybeWith_n_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Onx: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.008722401 UTC

[section ""data" . Foreign.Marshal.Utils.maybePeek1_closure" {
     Foreign.Marshal.Utils.maybePeek1_closure:
         const Foreign.Marshal.Utils.maybePeek1_info;
 },
 Foreign.Marshal.Utils.maybePeek1_entry() //  [R2, R3]
         { info_tbl: [(c8OnQ,
                       label: Foreign.Marshal.Utils.maybePeek1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OnQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OnR; else goto c8OnS;
       c8OnR: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.maybePeek1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OnS: // global
           I64[Sp - 16] = block_c8OnN_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Oo8; else goto c8OnO;
       u8Oo8: // global
           call _c8OnN(R1) args: 0, res: 0, upd: 0;
       c8OnO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OnN() //  [R1]
         { info_tbl: [(c8OnN,
                       label: block_c8OnN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OnN: // global
           if (I64[R1 + 7] == 0) goto c8Oo7; else goto c8Oo3;
       c8Oo7: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Oo3: // global
           _s8Oit::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8OnZ_info;
           R2 = R1;
           R1 = _s8Oit::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OnZ() //  [R1]
         { info_tbl: [(c8OnZ,
                       label: block_c8OnZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OnZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Oo6; else goto c8Oo5;
       c8Oo6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Oo5: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.010160011 UTC

[section ""data" . Foreign.Marshal.Utils.maybePeek_closure" {
     Foreign.Marshal.Utils.maybePeek_closure:
         const Foreign.Marshal.Utils.maybePeek_info;
 },
 Foreign.Marshal.Utils.maybePeek_entry() //  [R2, R3]
         { info_tbl: [(c8Ood,
                       label: Foreign.Marshal.Utils.maybePeek_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ood: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.maybePeek1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.011614027 UTC

[section ""data" . Foreign.Marshal.Utils.withMany_closure" {
     Foreign.Marshal.Utils.withMany_closure:
         const Foreign.Marshal.Utils.withMany_info;
 },
 sat_s8OiM_entry() //  [R1, R2]
         { info_tbl: [(c8OoB,
                       label: sat_s8OiM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OoB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8OoF; else goto c8OoE;
       c8OoF: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8OoE: // global
           _s8OiF::P64 = P64[R1 + 7];
           _s8OiJ::P64 = P64[R1 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s8OiJ::P64;
           P64[Hp] = R2;
           R2 = Hp - 14;
           R1 = _s8OiF::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8OiN_entry() //  [R1, R2]
         { info_tbl: [(c8OoG,
                       label: sat_s8OiN_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OoG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8OoK; else goto c8OoJ;
       c8OoK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8OoJ: // global
           _s8OiD::P64 = P64[R1 + 7];
           _s8OiF::P64 = P64[R1 + 15];
           _s8OiI::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_s8OiM_info;
           P64[Hp - 8] = _s8OiF::P64;
           P64[Hp] = R2;
           R4 = Hp - 15;
           R3 = _s8OiI::P64;
           R2 = _s8OiD::P64;
           call Foreign.Marshal.Utils.withMany_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Utils.withMany_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OoP,
                       label: Foreign.Marshal.Utils.withMany_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OoP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8OoQ; else goto c8OoR;
       c8OoQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.withMany_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OoR: // global
           I64[Sp - 24] = block_c8Ook_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8OoX; else goto c8Ool;
       u8OoX: // global
           call _c8Ook(R1) args: 0, res: 0, upd: 0;
       c8Ool: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ook() //  [R1]
         { info_tbl: [(c8Ook,
                       label: block_c8Ook_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ook: // global
           _s8OiF::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8OoM; else goto c8OoN;
       c8OoM: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = _s8OiF::P64;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       c8OoN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8OoW; else goto c8OoV;
       c8OoW: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8OoV: // global
           _s8OiH::P64 = P64[R1 + 6];
           _s8OiI::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s8OiN_info;
           _s8OiD::P64 = P64[Sp + 8];
           P64[Hp - 16] = _s8OiD::P64;
           P64[Hp - 8] = _s8OiF::P64;
           P64[Hp] = _s8OiI::P64;
           R3 = Hp - 23;
           R2 = _s8OiH::P64;
           R1 = _s8OiD::P64;
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.013535892 UTC

[section ""data" . Foreign.Marshal.Utils.$trModule3_closure" {
     Foreign.Marshal.Utils.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Utils.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.014083776 UTC

[section ""cstring" . Foreign.Marshal.Utils.$trModule2_bytes" {
     Foreign.Marshal.Utils.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,85,116,105,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.014573068 UTC

[section ""data" . Foreign.Marshal.Utils.$trModule1_closure" {
     Foreign.Marshal.Utils.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Utils.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.015170015 UTC

[section ""data" . Foreign.Marshal.Utils.$trModule_closure" {
     Foreign.Marshal.Utils.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Marshal.Utils.$trModule3_closure+1;
         const Foreign.Marshal.Utils.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.016155041 UTC

[section ""data" . Foreign.Marshal.Utils.copyBytes1_closure" {
     Foreign.Marshal.Utils.copyBytes1_closure:
         const Foreign.Marshal.Utils.copyBytes1_info;
 },
 Foreign.Marshal.Utils.copyBytes1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Op5,
                       label: Foreign.Marshal.Utils.copyBytes1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Op5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Ope; else goto c8Opf;
       c8Ope: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.copyBytes1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Opf: // global
           I64[Sp - 24] = block_c8Op2_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Opv; else goto c8Op3;
       u8Opv: // global
           call _c8Op2(R1) args: 0, res: 0, upd: 0;
       c8Op3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Op2() //  [R1]
         { info_tbl: [(c8Op2,
                       label: block_c8Op2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Op2: // global
           I64[Sp] = block_c8Op8_info;
           _s8OiT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8OiT::I64;
           if (R1 & 7 != 0) goto u8Opu; else goto c8Op9;
       u8Opu: // global
           call _c8Op8(R1) args: 0, res: 0, upd: 0;
       c8Op9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Op8() //  [R1]
         { info_tbl: [(c8Op8,
                       label: block_c8Op8_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Op8: // global
           I64[Sp] = block_c8Opd_info;
           _s8OiV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8OiV::I64;
           if (R1 & 7 != 0) goto u8Opw; else goto c8Opi;
       u8Opw: // global
           call _c8Opd(R1) args: 0, res: 0, upd: 0;
       c8Opi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Opd() //  [R1]
         { info_tbl: [(c8Opd,
                       label: block_c8Opd_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Opd: // global
           (_s8Oj2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[Sp + 8], I64[Sp + 16], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.018025235 UTC

[section ""data" . Foreign.Marshal.Utils.copyBytes_closure" {
     Foreign.Marshal.Utils.copyBytes_closure:
         const Foreign.Marshal.Utils.copyBytes_info;
 },
 Foreign.Marshal.Utils.copyBytes_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OpB,
                       label: Foreign.Marshal.Utils.copyBytes_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OpB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.copyBytes1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.01909835 UTC

[section ""data" . Foreign.Marshal.Utils.moveBytes1_closure" {
     Foreign.Marshal.Utils.moveBytes1_closure:
         const Foreign.Marshal.Utils.moveBytes1_info;
 },
 Foreign.Marshal.Utils.moveBytes1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OpL,
                       label: Foreign.Marshal.Utils.moveBytes1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OpL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8OpU; else goto c8OpV;
       c8OpU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.moveBytes1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OpV: // global
           I64[Sp - 24] = block_c8OpI_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Oqb; else goto c8OpJ;
       u8Oqb: // global
           call _c8OpI(R1) args: 0, res: 0, upd: 0;
       c8OpJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OpI() //  [R1]
         { info_tbl: [(c8OpI,
                       label: block_c8OpI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OpI: // global
           I64[Sp] = block_c8OpO_info;
           _s8Oj8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8Oj8::I64;
           if (R1 & 7 != 0) goto u8Oqa; else goto c8OpP;
       u8Oqa: // global
           call _c8OpO(R1) args: 0, res: 0, upd: 0;
       c8OpP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OpO() //  [R1]
         { info_tbl: [(c8OpO,
                       label: block_c8OpO_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OpO: // global
           I64[Sp] = block_c8OpT_info;
           _s8Oja::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8Oja::I64;
           if (R1 & 7 != 0) goto u8Oqc; else goto c8OpY;
       u8Oqc: // global
           call _c8OpT(R1) args: 0, res: 0, upd: 0;
       c8OpY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OpT() //  [R1]
         { info_tbl: [(c8OpT,
                       label: block_c8OpT_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OpT: // global
           (_s8Ojh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(I64[Sp + 8], I64[Sp + 16], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.020653566 UTC

[section ""data" . Foreign.Marshal.Utils.moveBytes_closure" {
     Foreign.Marshal.Utils.moveBytes_closure:
         const Foreign.Marshal.Utils.moveBytes_info;
 },
 Foreign.Marshal.Utils.moveBytes_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Oqh,
                       label: Foreign.Marshal.Utils.moveBytes_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oqh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.moveBytes1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.021819528 UTC

[section ""data" . Foreign.Marshal.Utils.fillBytes1_closure" {
     Foreign.Marshal.Utils.fillBytes1_closure:
         const Foreign.Marshal.Utils.fillBytes1_info;
 },
 Foreign.Marshal.Utils.fillBytes1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Oqr,
                       label: Foreign.Marshal.Utils.fillBytes1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oqr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8OqA; else goto c8OqB;
       c8OqA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.fillBytes1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OqB: // global
           I64[Sp - 24] = block_c8Oqo_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8OqU; else goto c8Oqp;
       u8OqU: // global
           call _c8Oqo(R1) args: 0, res: 0, upd: 0;
       c8Oqp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Oqo() //  [R1]
         { info_tbl: [(c8Oqo,
                       label: block_c8Oqo_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oqo: // global
           I64[Sp] = block_c8Oqu_info;
           _s8Ojn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8Ojn::I64;
           if (R1 & 7 != 0) goto u8OqT; else goto c8Oqv;
       u8OqT: // global
           call _c8Oqu(R1) args: 0, res: 0, upd: 0;
       c8Oqv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Oqu() //  [R1]
         { info_tbl: [(c8Oqu,
                       label: block_c8Oqu_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oqu: // global
           I64[Sp] = block_c8Oqz_info;
           _s8Ojp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8Ojp::I64;
           if (R1 & 7 != 0) goto u8OqV; else goto c8OqE;
       u8OqV: // global
           call _c8Oqz(R1) args: 0, res: 0, upd: 0;
       c8OqE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Oqz() //  [R1]
         { info_tbl: [(c8Oqz,
                       label: block_c8Oqz_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oqz: // global
           (_s8Ojx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     signed,]  result hints:  [PtrHint] memset(I64[Sp + 8], I64[Sp + 16], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.023438657 UTC

[section ""data" . Foreign.Marshal.Utils.fillBytes_closure" {
     Foreign.Marshal.Utils.fillBytes_closure:
         const Foreign.Marshal.Utils.fillBytes_info;
 },
 Foreign.Marshal.Utils.fillBytes_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Or0,
                       label: Foreign.Marshal.Utils.fillBytes_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Or0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.fillBytes1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.024159316 UTC

[section ""relreadonly" . S8Okh_srt" {
     S8Okh_srt:
         const GHC.Err.undefined_closure;
         const lvl11_r8Ohm_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Utils.new1_closure;
         const Foreign.Marshal.Utils.new2_closure;
         const lvl16_r8Ohr_closure;
         const lvl20_r8Ohv_closure;
         const Foreign.Marshal.Utils.with1_closure;
         const Foreign.Marshal.Utils.with2_closure;
         const Foreign.Marshal.Utils.with3_closure;
         const sat_s8Oia_closure;
         const Foreign.Marshal.Utils.fromBool_closure;
         const Foreign.Marshal.Utils.fromBool1_closure;
         const Foreign.Marshal.Utils.fromBool2_closure;
         const Foreign.Marshal.Utils.toBool_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.024820338 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:58.025409059 UTC

[section ""cstring" . lvl_r8Ohb_bytes" {
     lvl_r8Ohb_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.026194169 UTC

[section ""data" . lvl1_r8Ohc_closure" {
     lvl1_r8Ohc_closure:
         const lvl1_r8Ohc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r8Ohc_entry() //  [R1]
         { info_tbl: [(c8Or9,
                       label: lvl1_r8Ohc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Or9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ora; else goto c8Orb;
       c8Ora: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Orb: // global
           (_c8Or6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Or6::I64 == 0) goto c8Or8; else goto c8Or7;
       c8Or8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Or7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Or6::I64;
           R2 = lvl_r8Ohb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.027148318 UTC

[section ""cstring" . Foreign.Marshal.Utils.$trModule4_bytes" {
     Foreign.Marshal.Utils.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.027887523 UTC

[section ""data" . lvl2_r8Ohd_closure" {
     lvl2_r8Ohd_closure:
         const lvl2_r8Ohd_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r8Ohd_entry() //  [R1]
         { info_tbl: [(c8Ori,
                       label: lvl2_r8Ohd_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ori: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Orj; else goto c8Ork;
       c8Orj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ork: // global
           (_c8Orf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Orf::I64 == 0) goto c8Orh; else goto c8Org;
       c8Orh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Org: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Orf::I64;
           R2 = Foreign.Marshal.Utils.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.028845922 UTC

[section ""cstring" . lvl3_r8Ohe_bytes" {
     lvl3_r8Ohe_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,65,108,108,111,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.029820206 UTC

[section ""data" . lvl4_r8Ohf_closure" {
     lvl4_r8Ohf_closure:
         const lvl4_r8Ohf_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r8Ohf_entry() //  [R1]
         { info_tbl: [(c8Orr,
                       label: lvl4_r8Ohf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Orr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ors; else goto c8Ort;
       c8Ors: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ort: // global
           (_c8Oro::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Oro::I64 == 0) goto c8Orq; else goto c8Orp;
       c8Orq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Orp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Oro::I64;
           R2 = lvl3_r8Ohe_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.031902396 UTC

[section ""cstring" . lvl5_r8Ohg_bytes" {
     lvl5_r8Ohg_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,77,97,114,115,104,97,108,47,65,108,108,111,99,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.032620325 UTC

[section ""data" . lvl6_r8Ohh_closure" {
     lvl6_r8Ohh_closure:
         const lvl6_r8Ohh_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r8Ohh_entry() //  [R1]
         { info_tbl: [(c8OrA,
                       label: lvl6_r8Ohh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OrA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OrB; else goto c8OrC;
       c8OrB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8OrC: // global
           (_c8Orx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Orx::I64 == 0) goto c8Orz; else goto c8Ory;
       c8Orz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Ory: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Orx::I64;
           R2 = lvl5_r8Ohg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.03348071 UTC

[section ""data" . lvl7_r8Ohi_closure" {
     lvl7_r8Ohi_closure:
         const GHC.Types.I#_con_info;
         const 84;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.034042579 UTC

[section ""data" . lvl8_r8Ohj_closure" {
     lvl8_r8Ohj_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.034557746 UTC

[section ""data" . lvl9_r8Ohk_closure" {
     lvl9_r8Ohk_closure:
         const GHC.Types.I#_con_info;
         const 41;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.035099215 UTC

[section ""data" . lvl10_r8Ohl_closure" {
     lvl10_r8Ohl_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8Ohd_closure;
         const lvl4_r8Ohf_closure;
         const lvl6_r8Ohh_closure;
         const lvl7_r8Ohi_closure+1;
         const lvl8_r8Ohj_closure+1;
         const lvl7_r8Ohi_closure+1;
         const lvl9_r8Ohk_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.035701842 UTC

[section ""data" . lvl11_r8Ohm_closure" {
     lvl11_r8Ohm_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8Ohc_closure;
         const lvl10_r8Ohl_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.036413092 UTC

[section ""data" . Foreign.Marshal.Utils.new2_closure" {
     Foreign.Marshal.Utils.new2_closure:
         const Foreign.Marshal.Utils.new2_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Utils.new2_entry() //  [R1]
         { info_tbl: [(c8OrJ,
                       label: Foreign.Marshal.Utils.new2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OrJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OrK; else goto c8OrL;
       c8OrK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8OrL: // global
           (_c8OrG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8OrG::I64 == 0) goto c8OrI; else goto c8OrH;
       c8OrI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8OrH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8OrG::I64;
           R2 = lvl11_r8Ohm_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.037816027 UTC

[section ""data" . Foreign.Marshal.Utils.new1_closure" {
     Foreign.Marshal.Utils.new1_closure:
         const Foreign.Marshal.Utils.new1_info;
         const 0;
 },
 Foreign.Marshal.Utils.new1_entry() //  [R2, R3]
         { info_tbl: [(c8OrS,
                       label: Foreign.Marshal.Utils.new1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OrS: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8OrT; else goto c8OrU;
       c8OrT: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.new1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OrU: // global
           I64[Sp - 24] = block_c8OrQ_info;
           _s8Ohx::P64 = R2;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = Foreign.Marshal.Utils.new2_closure;
           P64[Sp - 16] = _s8Ohx::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8OrQ() //  [R1]
         { info_tbl: [(c8OrQ,
                       label: block_c8OrQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OrQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8OrZ; else goto c8OrY;
       c8OrZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8OrY: // global
           _s8Ohx::P64 = P64[Sp + 8];
           _s8Ohy::P64 = P64[Sp + 16];
           (_s8OhG::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s8OhG::I64 == 0) goto c8Ose; else goto c8Osb;
       c8Ose: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Osb: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8OhG::I64;
           I64[Sp + 8] = block_c8Os9_info;
           R2 = _s8Ohx::P64;
           I64[Sp - 16] = stg_ap_ppv_info;
           _c8Os8::P64 = Hp - 7;
           P64[Sp - 8] = _c8Os8::P64;
           P64[Sp] = _s8Ohy::P64;
           P64[Sp + 16] = _c8Os8::P64;
           Sp = Sp - 16;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8Os9() //  []
         { info_tbl: [(c8Os9,
                       label: block_c8Os9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Os9: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.039330068 UTC

[section ""data" . Foreign.Marshal.Utils.new_closure" {
     Foreign.Marshal.Utils.new_closure:
         const Foreign.Marshal.Utils.new_info;
         const 0;
 },
 Foreign.Marshal.Utils.new_entry() //  [R2, R3]
         { info_tbl: [(c8Osj,
                       label: Foreign.Marshal.Utils.new_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Osj: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.new1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.040041995 UTC

[section ""data" . lvl12_r8Ohn_closure" {
     lvl12_r8Ohn_closure:
         const GHC.Types.I#_con_info;
         const 117;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.04057498 UTC

[section ""data" . lvl13_r8Oho_closure" {
     lvl13_r8Oho_closure:
         const GHC.Types.I#_con_info;
         const 60;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.041145188 UTC

[section ""data" . lvl14_r8Ohp_closure" {
     lvl14_r8Ohp_closure:
         const GHC.Types.I#_con_info;
         const 69;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.0420049 UTC

[section ""data" . lvl15_r8Ohq_closure" {
     lvl15_r8Ohq_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8Ohd_closure;
         const lvl4_r8Ohf_closure;
         const lvl6_r8Ohh_closure;
         const lvl12_r8Ohn_closure+1;
         const lvl13_r8Oho_closure+1;
         const lvl12_r8Ohn_closure+1;
         const lvl14_r8Ohp_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.042600987 UTC

[section ""data" . lvl16_r8Ohr_closure" {
     lvl16_r8Ohr_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8Ohc_closure;
         const lvl15_r8Ohq_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.043372012 UTC

[section ""data" . Foreign.Marshal.Utils.with2_closure" {
     Foreign.Marshal.Utils.with2_closure:
         const Foreign.Marshal.Utils.with2_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Utils.with2_entry() //  [R1]
         { info_tbl: [(c8Oss,
                       label: Foreign.Marshal.Utils.with2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oss: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ost; else goto c8Osu;
       c8Ost: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Osu: // global
           (_c8Osp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Osp::I64 == 0) goto c8Osr; else goto c8Osq;
       c8Osr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Osq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Osp::I64;
           R2 = lvl16_r8Ohr_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.04423692 UTC

[section ""data" . lvl17_r8Ohs_closure" {
     lvl17_r8Ohs_closure:
         const GHC.Types.I#_con_info;
         const 31;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.044788736 UTC

[section ""data" . lvl18_r8Oht_closure" {
     lvl18_r8Oht_closure:
         const GHC.Types.I#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.045294655 UTC

[section ""data" . lvl19_r8Ohu_closure" {
     lvl19_r8Ohu_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8Ohd_closure;
         const lvl4_r8Ohf_closure;
         const lvl6_r8Ohh_closure;
         const lvl12_r8Ohn_closure+1;
         const lvl17_r8Ohs_closure+1;
         const lvl12_r8Ohn_closure+1;
         const lvl18_r8Oht_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.045870129 UTC

[section ""data" . lvl20_r8Ohv_closure" {
     lvl20_r8Ohv_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8Ohc_closure;
         const lvl19_r8Ohu_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.046628571 UTC

[section ""data" . Foreign.Marshal.Utils.with3_closure" {
     Foreign.Marshal.Utils.with3_closure:
         const Foreign.Marshal.Utils.with3_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Utils.with3_entry() //  [R1]
         { info_tbl: [(c8OsB,
                       label: Foreign.Marshal.Utils.with3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OsB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OsC; else goto c8OsD;
       c8OsC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8OsD: // global
           (_c8Osy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Osy::I64 == 0) goto c8OsA; else goto c8Osz;
       c8OsA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Osz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Osy::I64;
           R2 = lvl20_r8Ohv_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.048091129 UTC

[section ""data" . Foreign.Marshal.Utils.with1_closure" {
     Foreign.Marshal.Utils.with1_closure:
         const Foreign.Marshal.Utils.with1_info;
         const 0;
 },
 Foreign.Marshal.Utils.with1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OsK,
                       label: Foreign.Marshal.Utils.with1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OsK: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8OsO; else goto c8OsP;
       c8OsO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.with1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OsP: // global
           I64[Sp - 32] = block_c8OsI_info;
           _s8OhM::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = Foreign.Marshal.Utils.with3_closure;
           P64[Sp - 24] = _s8OhM::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 48;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8OsI() //  [R1]
         { info_tbl: [(c8OsI,
                       label: block_c8OsI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OsI: // global
           I64[Sp - 8] = block_c8OsN_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = Foreign.Marshal.Utils.with2_closure;
           I64[Sp] = I64[R1 + 7];
           Sp = Sp - 24;
           call Foreign.Storable.alignment_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8OsN() //  [R1]
         { info_tbl: [(c8OsN,
                       label: block_c8OsN_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OsN: // global
           _s8OhR::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c8OsU_info;
           R2 = I64[R1 + 7];
           R1 = _s8OhR::I64;
           Sp = Sp + 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OsU() //  [R1]
         { info_tbl: [(c8OsU,
                       label: block_c8OsU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OsU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8OsZ; else goto c8OsY;
       c8OsZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8OsY: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           P64[Hp] = R1 + 16;
           I64[Sp] = block_c8Ot4_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_ppv_info;
           _c8Ot3::P64 = Hp - 7;
           P64[Sp - 16] = _c8Ot3::P64;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 8] = R1;
           P64[Sp + 16] = _c8Ot3::P64;
           Sp = Sp - 24;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8Ot4() //  []
         { info_tbl: [(c8Ot4,
                       label: block_c8Ot4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ot4: // global
           I64[Sp] = block_c8Ot6_info;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 24];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ot6() //  [R1]
         { info_tbl: [(c8Ot6,
                       label: block_c8Ot6_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ot6: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.050035444 UTC

[section ""data" . Foreign.Marshal.Utils.with_closure" {
     Foreign.Marshal.Utils.with_closure:
         const Foreign.Marshal.Utils.with_info;
         const 0;
 },
 Foreign.Marshal.Utils.with_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Otf,
                       label: Foreign.Marshal.Utils.with_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Otf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.with1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.050928639 UTC

[section ""data" . Foreign.Marshal.Utils.fromBool2_closure" {
     Foreign.Marshal.Utils.fromBool2_closure:
         const Foreign.Marshal.Utils.fromBool2_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Utils.fromBool2_entry() //  [R1]
         { info_tbl: [(c8Oto,
                       label: Foreign.Marshal.Utils.fromBool2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oto: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Otp; else goto c8Otq;
       c8Otp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Otq: // global
           (_c8Otl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Otl::I64 == 0) goto c8Otn; else goto c8Otm;
       c8Otn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Otm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Otl::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.051874456 UTC

[section ""data" . sat_s8Oi9_closure" {
     sat_s8Oi9_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.052452567 UTC

[section ""data" . sat_s8Oia_closure" {
     sat_s8Oia_closure:
         const :_con_info;
         const sat_s8Oi9_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.053185566 UTC

[section ""data" . Foreign.Marshal.Utils.fromBool1_closure" {
     Foreign.Marshal.Utils.fromBool1_closure:
         const Foreign.Marshal.Utils.fromBool1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Utils.fromBool1_entry() //  [R1]
         { info_tbl: [(c8Otx,
                       label: Foreign.Marshal.Utils.fromBool1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Otx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Oty; else goto c8Otz;
       c8Oty: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Otz: // global
           (_c8Otu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Otu::I64 == 0) goto c8Otw; else goto c8Otv;
       c8Otw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Otv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Otu::I64;
           R3 = sat_s8Oia_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.054804741 UTC

[section ""data" . Foreign.Marshal.Utils.fromBool_closure" {
     Foreign.Marshal.Utils.fromBool_closure:
         const Foreign.Marshal.Utils.fromBool_info;
         const 0;
 },
 Foreign.Marshal.Utils.fromBool_entry() //  [R2, R3]
         { info_tbl: [(c8OtL,
                       label: Foreign.Marshal.Utils.fromBool_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OtL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OtM; else goto c8OtN;
       c8OtM: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.fromBool_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OtN: // global
           I64[Sp - 16] = block_c8OtE_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8OtU; else goto c8OtF;
       u8OtU: // global
           call _c8OtE(R1) args: 0, res: 0, upd: 0;
       c8OtF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OtE() //  [R1]
         { info_tbl: [(c8OtE,
                       label: block_c8OtE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OtE: // global
           _s8Oib::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8OtI; else goto c8OtJ;
       c8OtI: // global
           R2 = _s8Oib::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = Foreign.Marshal.Utils.fromBool2_closure;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
       c8OtJ: // global
           R2 = _s8Oib::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = Foreign.Marshal.Utils.fromBool1_closure;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.056364549 UTC

[section ""data" . Foreign.Marshal.Utils.toBool_closure" {
     Foreign.Marshal.Utils.toBool_closure:
         const Foreign.Marshal.Utils.toBool_info;
         const 0;
 },
 ds_s8Oig_entry() //  [R1]
         { info_tbl: [(c8Ou3,
                       label: ds_s8Oig_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ou3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Ou4; else goto c8Ou5;
       c8Ou4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ou5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Utils.fromBool2_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8Oii_entry() //  [R1, R2]
         { info_tbl: [(c8Oub,
                       label: sat_s8Oii_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oub: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Ouc; else goto c8Oud;
       c8Ouc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Oud: // global
           _s8Oih::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s8Oih::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes./=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Utils.toBool_entry() //  [R2, R3]
         { info_tbl: [(c8Oue,
                       label: Foreign.Marshal.Utils.toBool_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oue: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8Oui; else goto c8Ouh;
       c8Oui: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.toBool_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Ouh: // global
           I64[Hp - 40] = ds_s8Oig_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s8Oii_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.058112884 UTC

[section ""data" . Foreign.Marshal.Utils.maybeNew1_closure" {
     Foreign.Marshal.Utils.maybeNew1_closure:
         const Foreign.Marshal.Utils.maybeNew1_info;
 },
 Foreign.Marshal.Utils.maybeNew1_entry() //  [R2, R3]
         { info_tbl: [(c8Ouu,
                       label: Foreign.Marshal.Utils.maybeNew1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ouu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ouv; else goto c8Ouw;
       c8Ouv: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.maybeNew1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Ouw: // global
           I64[Sp - 16] = block_c8Oun_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8OuD; else goto c8Ouo;
       u8OuD: // global
           call _c8Oun(R1) args: 0, res: 0, upd: 0;
       c8Ouo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Oun() //  [R1]
         { info_tbl: [(c8Oun,
                       label: block_c8Oun_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oun: // global
           if (R1 & 7 == 1) goto c8Our; else goto c8Ous;
       c8Our: // global
           R1 = GHC.Ptr.nullPtr_closure;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Ous: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.05934244 UTC

[section ""data" . Foreign.Marshal.Utils.maybeNew_closure" {
     Foreign.Marshal.Utils.maybeNew_closure:
         const Foreign.Marshal.Utils.maybeNew_info;
 },
 Foreign.Marshal.Utils.maybeNew_entry() //  [R2, R3]
         { info_tbl: [(c8OuI,
                       label: Foreign.Marshal.Utils.maybeNew_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OuI: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.maybeNew1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.060173642 UTC

[section ""data" . Foreign.Marshal.Utils.maybeWith_n_closure" {
     Foreign.Marshal.Utils.maybeWith_n_closure:
         const Foreign.Marshal.Utils.maybeWith_n_info;
 },
 Foreign.Marshal.Utils.maybeWith_n_entry() //  [R2]
         { info_tbl: [(c8OuP,
                       label: Foreign.Marshal.Utils.maybeWith_n_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OuP: // global
           _s8Oio::P64 = R2;
           R2 = GHC.Ptr.nullPtr_closure;
           R1 = _s8Oio::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.06123386 UTC

[section ""data" . Foreign.Marshal.Utils.maybeWith_closure" {
     Foreign.Marshal.Utils.maybeWith_closure:
         const Foreign.Marshal.Utils.maybeWith_info;
 },
 Foreign.Marshal.Utils.maybeWith_entry() //  [R2, R3]
         { info_tbl: [(c8Ov3,
                       label: Foreign.Marshal.Utils.maybeWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ov3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ov4; else goto c8Ov5;
       c8Ov4: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.maybeWith_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Ov5: // global
           I64[Sp - 16] = block_c8OuW_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Ovc; else goto c8OuX;
       u8Ovc: // global
           call _c8OuW(R1) args: 0, res: 0, upd: 0;
       c8OuX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OuW() //  [R1]
         { info_tbl: [(c8OuW,
                       label: block_c8OuW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OuW: // global
           if (R1 & 7 == 1) goto c8Ov0; else goto c8Ov1;
       c8Ov0: // global
           R1 = Foreign.Marshal.Utils.maybeWith_n_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Ov1: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.062684894 UTC

[section ""data" . Foreign.Marshal.Utils.maybePeek1_closure" {
     Foreign.Marshal.Utils.maybePeek1_closure:
         const Foreign.Marshal.Utils.maybePeek1_info;
 },
 Foreign.Marshal.Utils.maybePeek1_entry() //  [R2, R3]
         { info_tbl: [(c8Ovk,
                       label: Foreign.Marshal.Utils.maybePeek1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ovk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ovl; else goto c8Ovm;
       c8Ovl: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.maybePeek1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Ovm: // global
           I64[Sp - 16] = block_c8Ovh_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8OvC; else goto c8Ovi;
       u8OvC: // global
           call _c8Ovh(R1) args: 0, res: 0, upd: 0;
       c8Ovi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ovh() //  [R1]
         { info_tbl: [(c8Ovh,
                       label: block_c8Ovh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ovh: // global
           if (I64[R1 + 7] == 0) goto c8OvB; else goto c8Ovx;
       c8OvB: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Ovx: // global
           _s8Oit::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Ovt_info;
           R2 = R1;
           R1 = _s8Oit::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ovt() //  [R1]
         { info_tbl: [(c8Ovt,
                       label: block_c8Ovt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ovt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8OvA; else goto c8Ovz;
       c8OvA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Ovz: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.064127553 UTC

[section ""data" . Foreign.Marshal.Utils.maybePeek_closure" {
     Foreign.Marshal.Utils.maybePeek_closure:
         const Foreign.Marshal.Utils.maybePeek_info;
 },
 Foreign.Marshal.Utils.maybePeek_entry() //  [R2, R3]
         { info_tbl: [(c8OvH,
                       label: Foreign.Marshal.Utils.maybePeek_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OvH: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.maybePeek1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.065936995 UTC

[section ""data" . Foreign.Marshal.Utils.withMany_closure" {
     Foreign.Marshal.Utils.withMany_closure:
         const Foreign.Marshal.Utils.withMany_info;
 },
 sat_s8OiM_entry() //  [R1, R2]
         { info_tbl: [(c8Ow5,
                       label: sat_s8OiM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ow5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Ow9; else goto c8Ow8;
       c8Ow9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Ow8: // global
           _s8OiF::P64 = P64[R1 + 7];
           _s8OiJ::P64 = P64[R1 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s8OiJ::P64;
           P64[Hp] = R2;
           R2 = Hp - 14;
           R1 = _s8OiF::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8OiN_entry() //  [R1, R2]
         { info_tbl: [(c8Owa,
                       label: sat_s8OiN_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Owa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Owe; else goto c8Owd;
       c8Owe: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Owd: // global
           _s8OiD::P64 = P64[R1 + 7];
           _s8OiF::P64 = P64[R1 + 15];
           _s8OiI::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_s8OiM_info;
           P64[Hp - 8] = _s8OiF::P64;
           P64[Hp] = R2;
           R4 = Hp - 15;
           R3 = _s8OiI::P64;
           R2 = _s8OiD::P64;
           call Foreign.Marshal.Utils.withMany_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Utils.withMany_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Owj,
                       label: Foreign.Marshal.Utils.withMany_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Owj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Owk; else goto c8Owl;
       c8Owk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.withMany_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Owl: // global
           I64[Sp - 24] = block_c8OvO_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Owr; else goto c8OvP;
       u8Owr: // global
           call _c8OvO(R1) args: 0, res: 0, upd: 0;
       c8OvP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OvO() //  [R1]
         { info_tbl: [(c8OvO,
                       label: block_c8OvO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OvO: // global
           _s8OiF::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8Owg; else goto c8Owh;
       c8Owg: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = _s8OiF::P64;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       c8Owh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8Owq; else goto c8Owp;
       c8Owq: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Owp: // global
           _s8OiH::P64 = P64[R1 + 6];
           _s8OiI::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s8OiN_info;
           _s8OiD::P64 = P64[Sp + 8];
           P64[Hp - 16] = _s8OiD::P64;
           P64[Hp - 8] = _s8OiF::P64;
           P64[Hp] = _s8OiI::P64;
           R3 = Hp - 23;
           R2 = _s8OiH::P64;
           R1 = _s8OiD::P64;
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.067882099 UTC

[section ""data" . Foreign.Marshal.Utils.$trModule3_closure" {
     Foreign.Marshal.Utils.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Utils.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.068472084 UTC

[section ""cstring" . Foreign.Marshal.Utils.$trModule2_bytes" {
     Foreign.Marshal.Utils.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,85,116,105,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.070226898 UTC

[section ""data" . Foreign.Marshal.Utils.$trModule1_closure" {
     Foreign.Marshal.Utils.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Utils.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.070796512 UTC

[section ""data" . Foreign.Marshal.Utils.$trModule_closure" {
     Foreign.Marshal.Utils.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Marshal.Utils.$trModule3_closure+1;
         const Foreign.Marshal.Utils.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.071698538 UTC

[section ""data" . Foreign.Marshal.Utils.copyBytes1_closure" {
     Foreign.Marshal.Utils.copyBytes1_closure:
         const Foreign.Marshal.Utils.copyBytes1_info;
 },
 Foreign.Marshal.Utils.copyBytes1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Owz,
                       label: Foreign.Marshal.Utils.copyBytes1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Owz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8OwI; else goto c8OwJ;
       c8OwI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.copyBytes1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OwJ: // global
           I64[Sp - 24] = block_c8Oww_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8OwZ; else goto c8Owx;
       u8OwZ: // global
           call _c8Oww(R1) args: 0, res: 0, upd: 0;
       c8Owx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Oww() //  [R1]
         { info_tbl: [(c8Oww,
                       label: block_c8Oww_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oww: // global
           I64[Sp] = block_c8OwC_info;
           _s8OiT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8OiT::I64;
           if (R1 & 7 != 0) goto u8OwY; else goto c8OwD;
       u8OwY: // global
           call _c8OwC(R1) args: 0, res: 0, upd: 0;
       c8OwD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OwC() //  [R1]
         { info_tbl: [(c8OwC,
                       label: block_c8OwC_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OwC: // global
           I64[Sp] = block_c8OwH_info;
           _s8OiV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8OiV::I64;
           if (R1 & 7 != 0) goto u8Ox0; else goto c8OwM;
       u8Ox0: // global
           call _c8OwH(R1) args: 0, res: 0, upd: 0;
       c8OwM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OwH() //  [R1]
         { info_tbl: [(c8OwH,
                       label: block_c8OwH_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OwH: // global
           (_s8Oj2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[Sp + 8], I64[Sp + 16], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.073282269 UTC

[section ""data" . Foreign.Marshal.Utils.copyBytes_closure" {
     Foreign.Marshal.Utils.copyBytes_closure:
         const Foreign.Marshal.Utils.copyBytes_info;
 },
 Foreign.Marshal.Utils.copyBytes_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Ox5,
                       label: Foreign.Marshal.Utils.copyBytes_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ox5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.copyBytes1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.074367128 UTC

[section ""data" . Foreign.Marshal.Utils.moveBytes1_closure" {
     Foreign.Marshal.Utils.moveBytes1_closure:
         const Foreign.Marshal.Utils.moveBytes1_info;
 },
 Foreign.Marshal.Utils.moveBytes1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Oxf,
                       label: Foreign.Marshal.Utils.moveBytes1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oxf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Oxo; else goto c8Oxp;
       c8Oxo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.moveBytes1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Oxp: // global
           I64[Sp - 24] = block_c8Oxc_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8OxF; else goto c8Oxd;
       u8OxF: // global
           call _c8Oxc(R1) args: 0, res: 0, upd: 0;
       c8Oxd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Oxc() //  [R1]
         { info_tbl: [(c8Oxc,
                       label: block_c8Oxc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oxc: // global
           I64[Sp] = block_c8Oxi_info;
           _s8Oj8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8Oj8::I64;
           if (R1 & 7 != 0) goto u8OxE; else goto c8Oxj;
       u8OxE: // global
           call _c8Oxi(R1) args: 0, res: 0, upd: 0;
       c8Oxj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Oxi() //  [R1]
         { info_tbl: [(c8Oxi,
                       label: block_c8Oxi_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oxi: // global
           I64[Sp] = block_c8Oxn_info;
           _s8Oja::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8Oja::I64;
           if (R1 & 7 != 0) goto u8OxG; else goto c8Oxs;
       u8OxG: // global
           call _c8Oxn(R1) args: 0, res: 0, upd: 0;
       c8Oxs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Oxn() //  [R1]
         { info_tbl: [(c8Oxn,
                       label: block_c8Oxn_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oxn: // global
           (_s8Ojh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(I64[Sp + 8], I64[Sp + 16], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.075881675 UTC

[section ""data" . Foreign.Marshal.Utils.moveBytes_closure" {
     Foreign.Marshal.Utils.moveBytes_closure:
         const Foreign.Marshal.Utils.moveBytes_info;
 },
 Foreign.Marshal.Utils.moveBytes_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OxL,
                       label: Foreign.Marshal.Utils.moveBytes_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OxL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.moveBytes1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.076969676 UTC

[section ""data" . Foreign.Marshal.Utils.fillBytes1_closure" {
     Foreign.Marshal.Utils.fillBytes1_closure:
         const Foreign.Marshal.Utils.fillBytes1_info;
 },
 Foreign.Marshal.Utils.fillBytes1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OxV,
                       label: Foreign.Marshal.Utils.fillBytes1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OxV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Oy4; else goto c8Oy5;
       c8Oy4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.fillBytes1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Oy5: // global
           I64[Sp - 24] = block_c8OxS_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Oyo; else goto c8OxT;
       u8Oyo: // global
           call _c8OxS(R1) args: 0, res: 0, upd: 0;
       c8OxT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OxS() //  [R1]
         { info_tbl: [(c8OxS,
                       label: block_c8OxS_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OxS: // global
           I64[Sp] = block_c8OxY_info;
           _s8Ojn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8Ojn::I64;
           if (R1 & 7 != 0) goto u8Oyn; else goto c8OxZ;
       u8Oyn: // global
           call _c8OxY(R1) args: 0, res: 0, upd: 0;
       c8OxZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OxY() //  [R1]
         { info_tbl: [(c8OxY,
                       label: block_c8OxY_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OxY: // global
           I64[Sp] = block_c8Oy3_info;
           _s8Ojp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8Ojp::I64;
           if (R1 & 7 != 0) goto u8Oyp; else goto c8Oy8;
       u8Oyp: // global
           call _c8Oy3(R1) args: 0, res: 0, upd: 0;
       c8Oy8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Oy3() //  [R1]
         { info_tbl: [(c8Oy3,
                       label: block_c8Oy3_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oy3: // global
           (_s8Ojx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     signed,]  result hints:  [PtrHint] memset(I64[Sp + 8], I64[Sp + 16], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.078679458 UTC

[section ""data" . Foreign.Marshal.Utils.fillBytes_closure" {
     Foreign.Marshal.Utils.fillBytes_closure:
         const Foreign.Marshal.Utils.fillBytes_info;
 },
 Foreign.Marshal.Utils.fillBytes_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Oyu,
                       label: Foreign.Marshal.Utils.fillBytes_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Oyu: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.fillBytes1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.07942219 UTC

[section ""relreadonly" . S8Okh_srt" {
     S8Okh_srt:
         const GHC.Err.undefined_closure;
         const lvl11_r8Ohm_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Utils.new1_closure;
         const Foreign.Marshal.Utils.new2_closure;
         const lvl16_r8Ohr_closure;
         const lvl20_r8Ohv_closure;
         const Foreign.Marshal.Utils.with1_closure;
         const Foreign.Marshal.Utils.with2_closure;
         const Foreign.Marshal.Utils.with3_closure;
         const sat_s8Oia_closure;
         const Foreign.Marshal.Utils.fromBool_closure;
         const Foreign.Marshal.Utils.fromBool1_closure;
         const Foreign.Marshal.Utils.fromBool2_closure;
         const Foreign.Marshal.Utils.toBool_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.080279996 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:58.081430344 UTC

[section ""cstring" . lvl_r8Ohb_bytes" {
     lvl_r8Ohb_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.08336577 UTC

[section ""data" . lvl1_r8Ohc_closure" {
     lvl1_r8Ohc_closure:
         const lvl1_r8Ohc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r8Ohc_entry() //  [R1]
         { info_tbl: [(c8OyE,
                       label: lvl1_r8Ohc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OyE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OyF; else goto c8OyG;
       c8OyF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8OyG: // global
           (_c8OyB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8OyB::I64 == 0) goto c8OyD; else goto c8OyC;
       c8OyD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8OyC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8OyB::I64;
           R2 = lvl_r8Ohb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.087148124 UTC

[section ""cstring" . Foreign.Marshal.Utils.$trModule4_bytes" {
     Foreign.Marshal.Utils.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.089001445 UTC

[section ""data" . lvl2_r8Ohd_closure" {
     lvl2_r8Ohd_closure:
         const lvl2_r8Ohd_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r8Ohd_entry() //  [R1]
         { info_tbl: [(c8OyV,
                       label: lvl2_r8Ohd_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OyV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OyW; else goto c8OyX;
       c8OyW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8OyX: // global
           (_c8OyS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8OyS::I64 == 0) goto c8OyU; else goto c8OyT;
       c8OyU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8OyT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8OyS::I64;
           R2 = Foreign.Marshal.Utils.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.092980733 UTC

[section ""cstring" . lvl3_r8Ohe_bytes" {
     lvl3_r8Ohe_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,65,108,108,111,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.094915855 UTC

[section ""data" . lvl4_r8Ohf_closure" {
     lvl4_r8Ohf_closure:
         const lvl4_r8Ohf_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r8Ohf_entry() //  [R1]
         { info_tbl: [(c8Ozc,
                       label: lvl4_r8Ohf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ozc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ozd; else goto c8Oze;
       c8Ozd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Oze: // global
           (_c8Oz9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Oz9::I64 == 0) goto c8Ozb; else goto c8Oza;
       c8Ozb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Oza: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Oz9::I64;
           R2 = lvl3_r8Ohe_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.098733651 UTC

[section ""cstring" . lvl5_r8Ohg_bytes" {
     lvl5_r8Ohg_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,77,97,114,115,104,97,108,47,65,108,108,111,99,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.100636616 UTC

[section ""data" . lvl6_r8Ohh_closure" {
     lvl6_r8Ohh_closure:
         const lvl6_r8Ohh_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r8Ohh_entry() //  [R1]
         { info_tbl: [(c8Ozt,
                       label: lvl6_r8Ohh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ozt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Ozu; else goto c8Ozv;
       c8Ozu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Ozv: // global
           (_c8Ozq::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Ozq::I64 == 0) goto c8Ozs; else goto c8Ozr;
       c8Ozs: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Ozr: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Ozq::I64;
           R2 = lvl5_r8Ohg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.106042823 UTC

[section ""data" . lvl7_r8Ohi_closure" {
     lvl7_r8Ohi_closure:
         const GHC.Types.I#_con_info;
         const 84;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.107692401 UTC

[section ""data" . lvl8_r8Ohj_closure" {
     lvl8_r8Ohj_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.109347441 UTC

[section ""data" . lvl9_r8Ohk_closure" {
     lvl9_r8Ohk_closure:
         const GHC.Types.I#_con_info;
         const 41;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.110911941 UTC

[section ""data" . lvl10_r8Ohl_closure" {
     lvl10_r8Ohl_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8Ohd_closure;
         const lvl4_r8Ohf_closure;
         const lvl6_r8Ohh_closure;
         const lvl7_r8Ohi_closure+1;
         const lvl8_r8Ohj_closure+1;
         const lvl7_r8Ohi_closure+1;
         const lvl9_r8Ohk_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.112695761 UTC

[section ""data" . lvl11_r8Ohm_closure" {
     lvl11_r8Ohm_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8Ohc_closure;
         const lvl10_r8Ohl_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.11505654 UTC

[section ""data" . Foreign.Marshal.Utils.new2_closure" {
     Foreign.Marshal.Utils.new2_closure:
         const Foreign.Marshal.Utils.new2_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Utils.new2_entry() //  [R1]
         { info_tbl: [(c8OzO,
                       label: Foreign.Marshal.Utils.new2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OzO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OzP; else goto c8OzQ;
       c8OzP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8OzQ: // global
           (_c8OzL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8OzL::I64 == 0) goto c8OzN; else goto c8OzM;
       c8OzN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8OzM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8OzL::I64;
           R2 = lvl11_r8Ohm_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.119533652 UTC

[section ""data" . Foreign.Marshal.Utils.new1_closure" {
     Foreign.Marshal.Utils.new1_closure:
         const Foreign.Marshal.Utils.new1_info;
         const 0;
 },
 Foreign.Marshal.Utils.new1_entry() //  [R2, R3]
         { info_tbl: [(c8OA4,
                       label: Foreign.Marshal.Utils.new1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OA4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8OA5; else goto c8OA6;
       c8OA5: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.new1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OA6: // global
           I64[Sp - 24] = block_c8OA2_info;
           _s8Ohx::P64 = R2;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = Foreign.Marshal.Utils.new2_closure;
           P64[Sp - 16] = _s8Ohx::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8OA2() //  [R1]
         { info_tbl: [(c8OA2,
                       label: block_c8OA2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OA2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8OAb; else goto c8OAa;
       c8OAb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8OAa: // global
           _s8Ohx::P64 = P64[Sp + 8];
           _s8Ohy::P64 = P64[Sp + 16];
           (_s8OhG::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s8OhG::I64 == 0) goto c8OAq; else goto c8OAn;
       c8OAq: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8OAn: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8OhG::I64;
           I64[Sp + 8] = block_c8OAl_info;
           R2 = _s8Ohx::P64;
           I64[Sp - 16] = stg_ap_ppv_info;
           _c8OAk::P64 = Hp - 7;
           P64[Sp - 8] = _c8OAk::P64;
           P64[Sp] = _s8Ohy::P64;
           P64[Sp + 16] = _c8OAk::P64;
           Sp = Sp - 16;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8OAl() //  []
         { info_tbl: [(c8OAl,
                       label: block_c8OAl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OAl: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.127597485 UTC

[section ""data" . Foreign.Marshal.Utils.new_closure" {
     Foreign.Marshal.Utils.new_closure:
         const Foreign.Marshal.Utils.new_info;
         const 0;
 },
 Foreign.Marshal.Utils.new_entry() //  [R2, R3]
         { info_tbl: [(c8OAH,
                       label: Foreign.Marshal.Utils.new_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OAH: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.new1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.130862501 UTC

[section ""data" . lvl12_r8Ohn_closure" {
     lvl12_r8Ohn_closure:
         const GHC.Types.I#_con_info;
         const 117;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.132520482 UTC

[section ""data" . lvl13_r8Oho_closure" {
     lvl13_r8Oho_closure:
         const GHC.Types.I#_con_info;
         const 60;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.134226599 UTC

[section ""data" . lvl14_r8Ohp_closure" {
     lvl14_r8Ohp_closure:
         const GHC.Types.I#_con_info;
         const 69;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.136463456 UTC

[section ""data" . lvl15_r8Ohq_closure" {
     lvl15_r8Ohq_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8Ohd_closure;
         const lvl4_r8Ohf_closure;
         const lvl6_r8Ohh_closure;
         const lvl12_r8Ohn_closure+1;
         const lvl13_r8Oho_closure+1;
         const lvl12_r8Ohn_closure+1;
         const lvl14_r8Ohp_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.138527513 UTC

[section ""data" . lvl16_r8Ohr_closure" {
     lvl16_r8Ohr_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8Ohc_closure;
         const lvl15_r8Ohq_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.140476232 UTC

[section ""data" . Foreign.Marshal.Utils.with2_closure" {
     Foreign.Marshal.Utils.with2_closure:
         const Foreign.Marshal.Utils.with2_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Utils.with2_entry() //  [R1]
         { info_tbl: [(c8OAZ,
                       label: Foreign.Marshal.Utils.with2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OAZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OB0; else goto c8OB1;
       c8OB0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8OB1: // global
           (_c8OAW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8OAW::I64 == 0) goto c8OAY; else goto c8OAX;
       c8OAY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8OAX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8OAW::I64;
           R2 = lvl16_r8Ohr_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.144396017 UTC

[section ""data" . lvl17_r8Ohs_closure" {
     lvl17_r8Ohs_closure:
         const GHC.Types.I#_con_info;
         const 31;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.146082316 UTC

[section ""data" . lvl18_r8Oht_closure" {
     lvl18_r8Oht_closure:
         const GHC.Types.I#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.147774686 UTC

[section ""data" . lvl19_r8Ohu_closure" {
     lvl19_r8Ohu_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8Ohd_closure;
         const lvl4_r8Ohf_closure;
         const lvl6_r8Ohh_closure;
         const lvl12_r8Ohn_closure+1;
         const lvl17_r8Ohs_closure+1;
         const lvl12_r8Ohn_closure+1;
         const lvl18_r8Oht_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.150014506 UTC

[section ""data" . lvl20_r8Ohv_closure" {
     lvl20_r8Ohv_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8Ohc_closure;
         const lvl19_r8Ohu_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.1519928 UTC

[section ""data" . Foreign.Marshal.Utils.with3_closure" {
     Foreign.Marshal.Utils.with3_closure:
         const Foreign.Marshal.Utils.with3_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Utils.with3_entry() //  [R1]
         { info_tbl: [(c8OBj,
                       label: Foreign.Marshal.Utils.with3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OBj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OBk; else goto c8OBl;
       c8OBk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8OBl: // global
           (_c8OBg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8OBg::I64 == 0) goto c8OBi; else goto c8OBh;
       c8OBi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8OBh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8OBg::I64;
           R2 = lvl20_r8Ohv_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.156520606 UTC

[section ""data" . Foreign.Marshal.Utils.with1_closure" {
     Foreign.Marshal.Utils.with1_closure:
         const Foreign.Marshal.Utils.with1_info;
         const 0;
 },
 Foreign.Marshal.Utils.with1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OBz,
                       label: Foreign.Marshal.Utils.with1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OBz: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8OBD; else goto c8OBE;
       c8OBD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.with1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OBE: // global
           I64[Sp - 32] = block_c8OBx_info;
           _s8OhM::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = Foreign.Marshal.Utils.with3_closure;
           P64[Sp - 24] = _s8OhM::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 48;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8OBx() //  [R1]
         { info_tbl: [(c8OBx,
                       label: block_c8OBx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OBx: // global
           I64[Sp - 8] = block_c8OBC_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = Foreign.Marshal.Utils.with2_closure;
           I64[Sp] = I64[R1 + 7];
           Sp = Sp - 24;
           call Foreign.Storable.alignment_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8OBC() //  [R1]
         { info_tbl: [(c8OBC,
                       label: block_c8OBC_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OBC: // global
           _s8OhR::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c8OBJ_info;
           R2 = I64[R1 + 7];
           R1 = _s8OhR::I64;
           Sp = Sp + 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OBJ() //  [R1]
         { info_tbl: [(c8OBJ,
                       label: block_c8OBJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OBJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8OBO; else goto c8OBN;
       c8OBO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8OBN: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           P64[Hp] = R1 + 16;
           I64[Sp] = block_c8OBT_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_ppv_info;
           _c8OBS::P64 = Hp - 7;
           P64[Sp - 16] = _c8OBS::P64;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 8] = R1;
           P64[Sp + 16] = _c8OBS::P64;
           Sp = Sp - 24;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8OBT() //  []
         { info_tbl: [(c8OBT,
                       label: block_c8OBT_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OBT: // global
           I64[Sp] = block_c8OBV_info;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 24];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OBV() //  [R1]
         { info_tbl: [(c8OBV,
                       label: block_c8OBV_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OBV: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.169994022 UTC

[section ""data" . Foreign.Marshal.Utils.with_closure" {
     Foreign.Marshal.Utils.with_closure:
         const Foreign.Marshal.Utils.with_info;
         const 0;
 },
 Foreign.Marshal.Utils.with_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OCs,
                       label: Foreign.Marshal.Utils.with_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OCs: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.with1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.173710346 UTC

[section ""data" . Foreign.Marshal.Utils.fromBool2_closure" {
     Foreign.Marshal.Utils.fromBool2_closure:
         const Foreign.Marshal.Utils.fromBool2_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Utils.fromBool2_entry() //  [R1]
         { info_tbl: [(c8OCF,
                       label: Foreign.Marshal.Utils.fromBool2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OCF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OCG; else goto c8OCH;
       c8OCG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8OCH: // global
           (_c8OCC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8OCC::I64 == 0) goto c8OCE; else goto c8OCD;
       c8OCE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8OCD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8OCC::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.177640443 UTC

[section ""data" . sat_s8Oi9_closure" {
     sat_s8Oi9_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.179377343 UTC

[section ""data" . sat_s8Oia_closure" {
     sat_s8Oia_closure:
         const :_con_info;
         const sat_s8Oi9_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.181268064 UTC

[section ""data" . Foreign.Marshal.Utils.fromBool1_closure" {
     Foreign.Marshal.Utils.fromBool1_closure:
         const Foreign.Marshal.Utils.fromBool1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Utils.fromBool1_entry() //  [R1]
         { info_tbl: [(c8OCX,
                       label: Foreign.Marshal.Utils.fromBool1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OCX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OCY; else goto c8OCZ;
       c8OCY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8OCZ: // global
           (_c8OCU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8OCU::I64 == 0) goto c8OCW; else goto c8OCV;
       c8OCW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8OCV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8OCU::I64;
           R3 = sat_s8Oia_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.185706379 UTC

[section ""data" . Foreign.Marshal.Utils.fromBool_closure" {
     Foreign.Marshal.Utils.fromBool_closure:
         const Foreign.Marshal.Utils.fromBool_info;
         const 0;
 },
 Foreign.Marshal.Utils.fromBool_entry() //  [R2, R3]
         { info_tbl: [(c8ODi,
                       label: Foreign.Marshal.Utils.fromBool_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ODi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ODj; else goto c8ODk;
       c8ODj: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.fromBool_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ODk: // global
           I64[Sp - 16] = block_c8ODb_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ODr; else goto c8ODc;
       u8ODr: // global
           call _c8ODb(R1) args: 0, res: 0, upd: 0;
       c8ODc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ODb() //  [R1]
         { info_tbl: [(c8ODb,
                       label: block_c8ODb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ODb: // global
           _s8Oib::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8ODf; else goto c8ODg;
       c8ODf: // global
           R2 = _s8Oib::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = Foreign.Marshal.Utils.fromBool2_closure;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
       c8ODg: // global
           R2 = _s8Oib::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = Foreign.Marshal.Utils.fromBool1_closure;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.191675548 UTC

[section ""data" . Foreign.Marshal.Utils.toBool_closure" {
     Foreign.Marshal.Utils.toBool_closure:
         const Foreign.Marshal.Utils.toBool_info;
         const 0;
 },
 ds_s8Oig_entry() //  [R1]
         { info_tbl: [(c8ODL,
                       label: ds_s8Oig_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ODL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8ODM; else goto c8ODN;
       c8ODM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ODN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Utils.fromBool2_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8Oii_entry() //  [R1, R2]
         { info_tbl: [(c8ODT,
                       label: sat_s8Oii_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ODT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8ODU; else goto c8ODV;
       c8ODU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ODV: // global
           _s8Oih::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s8Oih::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes./=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Utils.toBool_entry() //  [R2, R3]
         { info_tbl: [(c8ODW,
                       label: Foreign.Marshal.Utils.toBool_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ODW: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8OE0; else goto c8ODZ;
       c8OE0: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.toBool_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ODZ: // global
           I64[Hp - 40] = ds_s8Oig_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s8Oii_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.199890868 UTC

[section ""data" . Foreign.Marshal.Utils.maybeNew1_closure" {
     Foreign.Marshal.Utils.maybeNew1_closure:
         const Foreign.Marshal.Utils.maybeNew1_info;
 },
 Foreign.Marshal.Utils.maybeNew1_entry() //  [R2, R3]
         { info_tbl: [(c8OEr,
                       label: Foreign.Marshal.Utils.maybeNew1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OEr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OEs; else goto c8OEt;
       c8OEs: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.maybeNew1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OEt: // global
           I64[Sp - 16] = block_c8OEk_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8OEA; else goto c8OEl;
       u8OEA: // global
           call _c8OEk(R1) args: 0, res: 0, upd: 0;
       c8OEl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OEk() //  [R1]
         { info_tbl: [(c8OEk,
                       label: block_c8OEk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OEk: // global
           if (R1 & 7 == 1) goto c8OEo; else goto c8OEp;
       c8OEo: // global
           R1 = GHC.Ptr.nullPtr_closure;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8OEp: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.206909065 UTC

[section ""data" . Foreign.Marshal.Utils.maybeNew_closure" {
     Foreign.Marshal.Utils.maybeNew_closure:
         const Foreign.Marshal.Utils.maybeNew_info;
 },
 Foreign.Marshal.Utils.maybeNew_entry() //  [R2, R3]
         { info_tbl: [(c8OER,
                       label: Foreign.Marshal.Utils.maybeNew_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OER: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.maybeNew1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.210540012 UTC

[section ""data" . Foreign.Marshal.Utils.maybeWith_n_closure" {
     Foreign.Marshal.Utils.maybeWith_n_closure:
         const Foreign.Marshal.Utils.maybeWith_n_info;
 },
 Foreign.Marshal.Utils.maybeWith_n_entry() //  [R2]
         { info_tbl: [(c8OF2,
                       label: Foreign.Marshal.Utils.maybeWith_n_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OF2: // global
           _s8Oio::P64 = R2;
           R2 = GHC.Ptr.nullPtr_closure;
           R1 = _s8Oio::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.214567386 UTC

[section ""data" . Foreign.Marshal.Utils.maybeWith_closure" {
     Foreign.Marshal.Utils.maybeWith_closure:
         const Foreign.Marshal.Utils.maybeWith_info;
 },
 Foreign.Marshal.Utils.maybeWith_entry() //  [R2, R3]
         { info_tbl: [(c8OFk,
                       label: Foreign.Marshal.Utils.maybeWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OFk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OFl; else goto c8OFm;
       c8OFl: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.maybeWith_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OFm: // global
           I64[Sp - 16] = block_c8OFd_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8OFt; else goto c8OFe;
       u8OFt: // global
           call _c8OFd(R1) args: 0, res: 0, upd: 0;
       c8OFe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OFd() //  [R1]
         { info_tbl: [(c8OFd,
                       label: block_c8OFd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OFd: // global
           if (R1 & 7 == 1) goto c8OFh; else goto c8OFi;
       c8OFh: // global
           R1 = Foreign.Marshal.Utils.maybeWith_n_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8OFi: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.221221679 UTC

[section ""data" . Foreign.Marshal.Utils.maybePeek1_closure" {
     Foreign.Marshal.Utils.maybePeek1_closure:
         const Foreign.Marshal.Utils.maybePeek1_info;
 },
 Foreign.Marshal.Utils.maybePeek1_entry() //  [R2, R3]
         { info_tbl: [(c8OFN,
                       label: Foreign.Marshal.Utils.maybePeek1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OFN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OFO; else goto c8OFP;
       c8OFO: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.maybePeek1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OFP: // global
           I64[Sp - 16] = block_c8OFK_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8OG5; else goto c8OFL;
       u8OG5: // global
           call _c8OFK(R1) args: 0, res: 0, upd: 0;
       c8OFL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OFK() //  [R1]
         { info_tbl: [(c8OFK,
                       label: block_c8OFK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OFK: // global
           if (I64[R1 + 7] == 0) goto c8OG4; else goto c8OG0;
       c8OG4: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8OG0: // global
           _s8Oit::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8OFW_info;
           R2 = R1;
           R1 = _s8Oit::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OFW() //  [R1]
         { info_tbl: [(c8OFW,
                       label: block_c8OFW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OFW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8OG3; else goto c8OG2;
       c8OG3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8OG2: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.229601467 UTC

[section ""data" . Foreign.Marshal.Utils.maybePeek_closure" {
     Foreign.Marshal.Utils.maybePeek_closure:
         const Foreign.Marshal.Utils.maybePeek_info;
 },
 Foreign.Marshal.Utils.maybePeek_entry() //  [R2, R3]
         { info_tbl: [(c8OGo,
                       label: Foreign.Marshal.Utils.maybePeek_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OGo: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.maybePeek1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.234055553 UTC

[section ""data" . Foreign.Marshal.Utils.withMany_closure" {
     Foreign.Marshal.Utils.withMany_closure:
         const Foreign.Marshal.Utils.withMany_info;
 },
 sat_s8OiM_entry() //  [R1, R2]
         { info_tbl: [(c8OGQ,
                       label: sat_s8OiM_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OGQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8OGU; else goto c8OGT;
       c8OGU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8OGT: // global
           _s8OiF::P64 = P64[R1 + 7];
           _s8OiJ::P64 = P64[R1 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s8OiJ::P64;
           P64[Hp] = R2;
           R2 = Hp - 14;
           R1 = _s8OiF::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8OiN_entry() //  [R1, R2]
         { info_tbl: [(c8OGV,
                       label: sat_s8OiN_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OGV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8OGZ; else goto c8OGY;
       c8OGZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8OGY: // global
           _s8OiD::P64 = P64[R1 + 7];
           _s8OiF::P64 = P64[R1 + 15];
           _s8OiI::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_s8OiM_info;
           P64[Hp - 8] = _s8OiF::P64;
           P64[Hp] = R2;
           R4 = Hp - 15;
           R3 = _s8OiI::P64;
           R2 = _s8OiD::P64;
           call Foreign.Marshal.Utils.withMany_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Utils.withMany_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OH4,
                       label: Foreign.Marshal.Utils.withMany_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OH4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8OH5; else goto c8OH6;
       c8OH5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.withMany_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OH6: // global
           I64[Sp - 24] = block_c8OGz_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8OHc; else goto c8OGA;
       u8OHc: // global
           call _c8OGz(R1) args: 0, res: 0, upd: 0;
       c8OGA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OGz() //  [R1]
         { info_tbl: [(c8OGz,
                       label: block_c8OGz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OGz: // global
           _s8OiF::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8OH1; else goto c8OH2;
       c8OH1: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = _s8OiF::P64;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       c8OH2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8OHb; else goto c8OHa;
       c8OHb: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8OHa: // global
           _s8OiH::P64 = P64[R1 + 6];
           _s8OiI::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s8OiN_info;
           _s8OiD::P64 = P64[Sp + 8];
           P64[Hp - 16] = _s8OiD::P64;
           P64[Hp - 8] = _s8OiF::P64;
           P64[Hp] = _s8OiI::P64;
           R3 = Hp - 23;
           R2 = _s8OiH::P64;
           R1 = _s8OiD::P64;
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.245506723 UTC

[section ""data" . Foreign.Marshal.Utils.$trModule3_closure" {
     Foreign.Marshal.Utils.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Utils.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.247319354 UTC

[section ""cstring" . Foreign.Marshal.Utils.$trModule2_bytes" {
     Foreign.Marshal.Utils.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,85,116,105,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.249045476 UTC

[section ""data" . Foreign.Marshal.Utils.$trModule1_closure" {
     Foreign.Marshal.Utils.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Utils.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.250871944 UTC

[section ""data" . Foreign.Marshal.Utils.$trModule_closure" {
     Foreign.Marshal.Utils.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Marshal.Utils.$trModule3_closure+1;
         const Foreign.Marshal.Utils.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.253420613 UTC

[section ""data" . Foreign.Marshal.Utils.copyBytes1_closure" {
     Foreign.Marshal.Utils.copyBytes1_closure:
         const Foreign.Marshal.Utils.copyBytes1_info;
 },
 Foreign.Marshal.Utils.copyBytes1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OHF,
                       label: Foreign.Marshal.Utils.copyBytes1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OHF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8OHO; else goto c8OHP;
       c8OHO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.copyBytes1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OHP: // global
           I64[Sp - 24] = block_c8OHC_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8OI5; else goto c8OHD;
       u8OI5: // global
           call _c8OHC(R1) args: 0, res: 0, upd: 0;
       c8OHD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OHC() //  [R1]
         { info_tbl: [(c8OHC,
                       label: block_c8OHC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OHC: // global
           I64[Sp] = block_c8OHI_info;
           _s8OiT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8OiT::I64;
           if (R1 & 7 != 0) goto u8OI4; else goto c8OHJ;
       u8OI4: // global
           call _c8OHI(R1) args: 0, res: 0, upd: 0;
       c8OHJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OHI() //  [R1]
         { info_tbl: [(c8OHI,
                       label: block_c8OHI_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OHI: // global
           I64[Sp] = block_c8OHN_info;
           _s8OiV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8OiV::I64;
           if (R1 & 7 != 0) goto u8OI6; else goto c8OHS;
       u8OI6: // global
           call _c8OHN(R1) args: 0, res: 0, upd: 0;
       c8OHS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OHN() //  [R1]
         { info_tbl: [(c8OHN,
                       label: block_c8OHN_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OHN: // global
           (_s8Oj2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[Sp + 8], I64[Sp + 16], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.264519328 UTC

[section ""data" . Foreign.Marshal.Utils.copyBytes_closure" {
     Foreign.Marshal.Utils.copyBytes_closure:
         const Foreign.Marshal.Utils.copyBytes_info;
 },
 Foreign.Marshal.Utils.copyBytes_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OIt,
                       label: Foreign.Marshal.Utils.copyBytes_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OIt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.copyBytes1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.26876133 UTC

[section ""data" . Foreign.Marshal.Utils.moveBytes1_closure" {
     Foreign.Marshal.Utils.moveBytes1_closure:
         const Foreign.Marshal.Utils.moveBytes1_info;
 },
 Foreign.Marshal.Utils.moveBytes1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OIH,
                       label: Foreign.Marshal.Utils.moveBytes1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OIH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8OIQ; else goto c8OIR;
       c8OIQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.moveBytes1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OIR: // global
           I64[Sp - 24] = block_c8OIE_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8OJ7; else goto c8OIF;
       u8OJ7: // global
           call _c8OIE(R1) args: 0, res: 0, upd: 0;
       c8OIF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OIE() //  [R1]
         { info_tbl: [(c8OIE,
                       label: block_c8OIE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OIE: // global
           I64[Sp] = block_c8OIK_info;
           _s8Oj8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8Oj8::I64;
           if (R1 & 7 != 0) goto u8OJ6; else goto c8OIL;
       u8OJ6: // global
           call _c8OIK(R1) args: 0, res: 0, upd: 0;
       c8OIL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OIK() //  [R1]
         { info_tbl: [(c8OIK,
                       label: block_c8OIK_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OIK: // global
           I64[Sp] = block_c8OIP_info;
           _s8Oja::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8Oja::I64;
           if (R1 & 7 != 0) goto u8OJ8; else goto c8OIU;
       u8OJ8: // global
           call _c8OIP(R1) args: 0, res: 0, upd: 0;
       c8OIU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OIP() //  [R1]
         { info_tbl: [(c8OIP,
                       label: block_c8OIP_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OIP: // global
           (_s8Ojh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(I64[Sp + 8], I64[Sp + 16], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.280779762 UTC

[section ""data" . Foreign.Marshal.Utils.moveBytes_closure" {
     Foreign.Marshal.Utils.moveBytes_closure:
         const Foreign.Marshal.Utils.moveBytes_info;
 },
 Foreign.Marshal.Utils.moveBytes_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OJv,
                       label: Foreign.Marshal.Utils.moveBytes_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OJv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.moveBytes1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.284890376 UTC

[section ""data" . Foreign.Marshal.Utils.fillBytes1_closure" {
     Foreign.Marshal.Utils.fillBytes1_closure:
         const Foreign.Marshal.Utils.fillBytes1_info;
 },
 Foreign.Marshal.Utils.fillBytes1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OJJ,
                       label: Foreign.Marshal.Utils.fillBytes1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OJJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8OJS; else goto c8OJT;
       c8OJS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.fillBytes1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OJT: // global
           I64[Sp - 24] = block_c8OJG_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8OKc; else goto c8OJH;
       u8OKc: // global
           call _c8OJG(R1) args: 0, res: 0, upd: 0;
       c8OJH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OJG() //  [R1]
         { info_tbl: [(c8OJG,
                       label: block_c8OJG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OJG: // global
           I64[Sp] = block_c8OJM_info;
           _s8Ojn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8Ojn::I64;
           if (R1 & 7 != 0) goto u8OKb; else goto c8OJN;
       u8OKb: // global
           call _c8OJM(R1) args: 0, res: 0, upd: 0;
       c8OJN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OJM() //  [R1]
         { info_tbl: [(c8OJM,
                       label: block_c8OJM_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OJM: // global
           I64[Sp] = block_c8OJR_info;
           _s8Ojp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8Ojp::I64;
           if (R1 & 7 != 0) goto u8OKd; else goto c8OJW;
       u8OKd: // global
           call _c8OJR(R1) args: 0, res: 0, upd: 0;
       c8OJW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OJR() //  [R1]
         { info_tbl: [(c8OJR,
                       label: block_c8OJR_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OJR: // global
           (_s8Ojx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     signed,]  result hints:  [PtrHint] memset(I64[Sp + 8], I64[Sp + 16], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.294687333 UTC

[section ""data" . Foreign.Marshal.Utils.fillBytes_closure" {
     Foreign.Marshal.Utils.fillBytes_closure:
         const Foreign.Marshal.Utils.fillBytes_info;
 },
 Foreign.Marshal.Utils.fillBytes_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OKA,
                       label: Foreign.Marshal.Utils.fillBytes_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OKA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.fillBytes1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.298412858 UTC

[section ""relreadonly" . S8Okh_srt" {
     S8Okh_srt:
         const GHC.Err.undefined_closure;
         const lvl11_r8Ohm_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Utils.new1_closure;
         const Foreign.Marshal.Utils.new2_closure;
         const lvl16_r8Ohr_closure;
         const lvl20_r8Ohv_closure;
         const Foreign.Marshal.Utils.with1_closure;
         const Foreign.Marshal.Utils.with2_closure;
         const Foreign.Marshal.Utils.with3_closure;
         const sat_s8Oia_closure;
         const Foreign.Marshal.Utils.fromBool_closure;
         const Foreign.Marshal.Utils.fromBool1_closure;
         const Foreign.Marshal.Utils.fromBool2_closure;
         const Foreign.Marshal.Utils.toBool_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.745840924 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:58.746933178 UTC

[section ""cstring" . lvl_r8Ohb_bytes" {
     lvl_r8Ohb_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.749170099 UTC

[section ""data" . lvl1_r8Ohc_closure" {
     lvl1_r8Ohc_closure:
         const lvl1_r8Ohc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r8Ohc_entry() //  [R1]
         { info_tbl: [(c8OMQ,
                       label: lvl1_r8Ohc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OMQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OMR; else goto c8OMS;
       c8OMR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8OMS: // global
           (_c8OMN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8OMN::I64 == 0) goto c8OMP; else goto c8OMO;
       c8OMP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8OMO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8OMN::I64;
           R2 = lvl_r8Ohb_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.753377548 UTC

[section ""cstring" . Foreign.Marshal.Utils.$trModule4_bytes" {
     Foreign.Marshal.Utils.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.755334393 UTC

[section ""data" . lvl2_r8Ohd_closure" {
     lvl2_r8Ohd_closure:
         const lvl2_r8Ohd_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r8Ohd_entry() //  [R1]
         { info_tbl: [(c8ON8,
                       label: lvl2_r8Ohd_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ON8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ON9; else goto c8ONa;
       c8ON9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ONa: // global
           (_c8ON5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8ON5::I64 == 0) goto c8ON7; else goto c8ON6;
       c8ON7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8ON6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8ON5::I64;
           R2 = Foreign.Marshal.Utils.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.759517984 UTC

[section ""cstring" . lvl3_r8Ohe_bytes" {
     lvl3_r8Ohe_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,65,108,108,111,99]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.761505842 UTC

[section ""data" . lvl4_r8Ohf_closure" {
     lvl4_r8Ohf_closure:
         const lvl4_r8Ohf_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_r8Ohf_entry() //  [R1]
         { info_tbl: [(c8ONq,
                       label: lvl4_r8Ohf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ONq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ONr; else goto c8ONs;
       c8ONr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ONs: // global
           (_c8ONn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8ONn::I64 == 0) goto c8ONp; else goto c8ONo;
       c8ONp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8ONo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8ONn::I64;
           R2 = lvl3_r8Ohe_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.765892077 UTC

[section ""cstring" . lvl5_r8Ohg_bytes" {
     lvl5_r8Ohg_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,77,97,114,115,104,97,108,47,65,108,108,111,99,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.768831465 UTC

[section ""data" . lvl6_r8Ohh_closure" {
     lvl6_r8Ohh_closure:
         const lvl6_r8Ohh_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r8Ohh_entry() //  [R1]
         { info_tbl: [(c8ONI,
                       label: lvl6_r8Ohh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ONI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ONJ; else goto c8ONK;
       c8ONJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ONK: // global
           (_c8ONF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8ONF::I64 == 0) goto c8ONH; else goto c8ONG;
       c8ONH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8ONG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8ONF::I64;
           R2 = lvl5_r8Ohg_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.772922532 UTC

[section ""data" . lvl7_r8Ohi_closure" {
     lvl7_r8Ohi_closure:
         const GHC.Types.I#_con_info;
         const 84;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.775108735 UTC

[section ""data" . lvl8_r8Ohj_closure" {
     lvl8_r8Ohj_closure:
         const GHC.Types.I#_con_info;
         const 32;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.776886389 UTC

[section ""data" . lvl9_r8Ohk_closure" {
     lvl9_r8Ohk_closure:
         const GHC.Types.I#_con_info;
         const 41;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.778703636 UTC

[section ""data" . lvl10_r8Ohl_closure" {
     lvl10_r8Ohl_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8Ohd_closure;
         const lvl4_r8Ohf_closure;
         const lvl6_r8Ohh_closure;
         const lvl7_r8Ohi_closure+1;
         const lvl8_r8Ohj_closure+1;
         const lvl7_r8Ohi_closure+1;
         const lvl9_r8Ohk_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.780752445 UTC

[section ""data" . lvl11_r8Ohm_closure" {
     lvl11_r8Ohm_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8Ohc_closure;
         const lvl10_r8Ohl_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.783031317 UTC

[section ""data" . Foreign.Marshal.Utils.new2_closure" {
     Foreign.Marshal.Utils.new2_closure:
         const Foreign.Marshal.Utils.new2_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Utils.new2_entry() //  [R1]
         { info_tbl: [(c8OO4,
                       label: Foreign.Marshal.Utils.new2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OO4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OO5; else goto c8OO6;
       c8OO5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8OO6: // global
           (_c8OO1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8OO1::I64 == 0) goto c8OO3; else goto c8OO2;
       c8OO3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8OO2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8OO1::I64;
           R2 = lvl11_r8Ohm_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.788610429 UTC

[section ""data" . Foreign.Marshal.Utils.new1_closure" {
     Foreign.Marshal.Utils.new1_closure:
         const Foreign.Marshal.Utils.new1_info;
         const 0;
 },
 Foreign.Marshal.Utils.new1_entry() //  [R2, R3]
         { info_tbl: [(c8OOm,
                       label: Foreign.Marshal.Utils.new1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OOm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8OOn; else goto c8OOo;
       c8OOn: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.new1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OOo: // global
           I64[Sp - 24] = block_c8OOk_info;
           _s8OKI::P64 = R2;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = Foreign.Marshal.Utils.new2_closure;
           P64[Sp - 16] = _s8OKI::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8OOk() //  [R1]
         { info_tbl: [(c8OOk,
                       label: block_c8OOk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OOk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8OOt; else goto c8OOs;
       c8OOt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8OOs: // global
           _s8OKI::P64 = P64[Sp + 8];
           _s8OKJ::P64 = P64[Sp + 16];
           (_s8OKR::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[R1 + 7]);
           if (_s8OKR::I64 == 0) goto c8OOI; else goto c8OOF;
       c8OOI: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 24;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8OOF: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8OKR::I64;
           I64[Sp + 8] = block_c8OOD_info;
           R2 = _s8OKI::P64;
           I64[Sp - 16] = stg_ap_ppv_info;
           _c8OOC::P64 = Hp - 7;
           P64[Sp - 8] = _c8OOC::P64;
           P64[Sp] = _s8OKJ::P64;
           P64[Sp + 16] = _c8OOC::P64;
           Sp = Sp - 16;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8OOD() //  []
         { info_tbl: [(c8OOD,
                       label: block_c8OOD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OOD: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.798655934 UTC

[section ""data" . Foreign.Marshal.Utils.new_closure" {
     Foreign.Marshal.Utils.new_closure:
         const Foreign.Marshal.Utils.new_info;
         const 0;
 },
 Foreign.Marshal.Utils.new_entry() //  [R2, R3]
         { info_tbl: [(c8OP5,
                       label: Foreign.Marshal.Utils.new_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OP5: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.new1_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.802424242 UTC

[section ""data" . lvl12_r8Ohn_closure" {
     lvl12_r8Ohn_closure:
         const GHC.Types.I#_con_info;
         const 117;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.804232545 UTC

[section ""data" . lvl13_r8Oho_closure" {
     lvl13_r8Oho_closure:
         const GHC.Types.I#_con_info;
         const 60;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.806284401 UTC

[section ""data" . lvl14_r8Ohp_closure" {
     lvl14_r8Ohp_closure:
         const GHC.Types.I#_con_info;
         const 69;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.807996786 UTC

[section ""data" . lvl15_r8Ohq_closure" {
     lvl15_r8Ohq_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8Ohd_closure;
         const lvl4_r8Ohf_closure;
         const lvl6_r8Ohh_closure;
         const lvl12_r8Ohn_closure+1;
         const lvl13_r8Oho_closure+1;
         const lvl12_r8Ohn_closure+1;
         const lvl14_r8Ohp_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.809879927 UTC

[section ""data" . lvl16_r8Ohr_closure" {
     lvl16_r8Ohr_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8Ohc_closure;
         const lvl15_r8Ohq_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.812089758 UTC

[section ""data" . Foreign.Marshal.Utils.with2_closure" {
     Foreign.Marshal.Utils.with2_closure:
         const Foreign.Marshal.Utils.with2_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Utils.with2_entry() //  [R1]
         { info_tbl: [(c8OPn,
                       label: Foreign.Marshal.Utils.with2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OPn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OPo; else goto c8OPp;
       c8OPo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8OPp: // global
           (_c8OPk::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8OPk::I64 == 0) goto c8OPm; else goto c8OPl;
       c8OPm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8OPl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8OPk::I64;
           R2 = lvl16_r8Ohr_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.816489306 UTC

[section ""data" . lvl17_r8Ohs_closure" {
     lvl17_r8Ohs_closure:
         const GHC.Types.I#_con_info;
         const 31;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.81833308 UTC

[section ""data" . lvl18_r8Oht_closure" {
     lvl18_r8Oht_closure:
         const GHC.Types.I#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.8205191 UTC

[section ""data" . lvl19_r8Ohu_closure" {
     lvl19_r8Ohu_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8Ohd_closure;
         const lvl4_r8Ohf_closure;
         const lvl6_r8Ohh_closure;
         const lvl12_r8Ohn_closure+1;
         const lvl17_r8Ohs_closure+1;
         const lvl12_r8Ohn_closure+1;
         const lvl18_r8Oht_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.822609896 UTC

[section ""data" . lvl20_r8Ohv_closure" {
     lvl20_r8Ohv_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8Ohc_closure;
         const lvl19_r8Ohu_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.824674086 UTC

[section ""data" . Foreign.Marshal.Utils.with3_closure" {
     Foreign.Marshal.Utils.with3_closure:
         const Foreign.Marshal.Utils.with3_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Utils.with3_entry() //  [R1]
         { info_tbl: [(c8OPI,
                       label: Foreign.Marshal.Utils.with3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OPI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OPJ; else goto c8OPK;
       c8OPJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8OPK: // global
           (_c8OPF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8OPF::I64 == 0) goto c8OPH; else goto c8OPG;
       c8OPH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8OPG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8OPF::I64;
           R2 = lvl20_r8Ohv_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.830620844 UTC

[section ""data" . Foreign.Marshal.Utils.with1_closure" {
     Foreign.Marshal.Utils.with1_closure:
         const Foreign.Marshal.Utils.with1_info;
         const 0;
 },
 Foreign.Marshal.Utils.with1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OPZ,
                       label: Foreign.Marshal.Utils.with1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OPZ: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8OQ3; else goto c8OQ4;
       c8OQ3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.with1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OQ4: // global
           I64[Sp - 32] = block_c8OPX_info;
           _s8OKX::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_p_info;
           P64[Sp - 40] = Foreign.Marshal.Utils.with3_closure;
           P64[Sp - 24] = _s8OKX::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 48;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8OPX() //  [R1]
         { info_tbl: [(c8OPX,
                       label: block_c8OPX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OPX: // global
           I64[Sp - 8] = block_c8OQ2_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = Foreign.Marshal.Utils.with2_closure;
           I64[Sp] = I64[R1 + 7];
           Sp = Sp - 24;
           call Foreign.Storable.alignment_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8OQ2() //  [R1]
         { info_tbl: [(c8OQ2,
                       label: block_c8OQ2_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OQ2: // global
           _s8OL2::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c8OQ9_info;
           R2 = I64[R1 + 7];
           R1 = _s8OL2::I64;
           Sp = Sp + 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OQ9() //  [R1]
         { info_tbl: [(c8OQ9,
                       label: block_c8OQ9_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OQ9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8OQe; else goto c8OQd;
       c8OQe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8OQd: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           P64[Hp] = R1 + 16;
           I64[Sp] = block_c8OQj_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_ppv_info;
           _c8OQi::P64 = Hp - 7;
           P64[Sp - 16] = _c8OQi::P64;
           P64[Sp - 8] = P64[Sp + 16];
           P64[Sp + 8] = R1;
           P64[Sp + 16] = _c8OQi::P64;
           Sp = Sp - 24;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8OQj() //  []
         { info_tbl: [(c8OQj,
                       label: block_c8OQj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OQj: // global
           I64[Sp] = block_c8OQl_info;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 24];
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OQl() //  [R1]
         { info_tbl: [(c8OQl,
                       label: block_c8OQl_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OQl: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.844821405 UTC

[section ""data" . Foreign.Marshal.Utils.with_closure" {
     Foreign.Marshal.Utils.with_closure:
         const Foreign.Marshal.Utils.with_info;
         const 0;
 },
 Foreign.Marshal.Utils.with_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OR3,
                       label: Foreign.Marshal.Utils.with_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OR3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.with1_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.850224783 UTC

[section ""data" . Foreign.Marshal.Utils.fromBool2_closure" {
     Foreign.Marshal.Utils.fromBool2_closure:
         const Foreign.Marshal.Utils.fromBool2_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Utils.fromBool2_entry() //  [R1]
         { info_tbl: [(c8ORg,
                       label: Foreign.Marshal.Utils.fromBool2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ORg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ORh; else goto c8ORi;
       c8ORh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ORi: // global
           (_c8ORd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8ORd::I64 == 0) goto c8ORf; else goto c8ORe;
       c8ORf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8ORe: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8ORd::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.854504292 UTC

[section ""data" . sat_s8OLk_closure" {
     sat_s8OLk_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.85612317 UTC

[section ""data" . sat_s8OLl_closure" {
     sat_s8OLl_closure:
         const :_con_info;
         const sat_s8OLk_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.858264185 UTC

[section ""data" . Foreign.Marshal.Utils.fromBool1_closure" {
     Foreign.Marshal.Utils.fromBool1_closure:
         const Foreign.Marshal.Utils.fromBool1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Utils.fromBool1_entry() //  [R1]
         { info_tbl: [(c8ORB,
                       label: Foreign.Marshal.Utils.fromBool1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ORB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ORC; else goto c8ORD;
       c8ORC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ORD: // global
           (_c8ORy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8ORy::I64 == 0) goto c8ORA; else goto c8ORz;
       c8ORA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8ORz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8ORy::I64;
           R3 = sat_s8OLl_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.86357956 UTC

[section ""data" . Foreign.Marshal.Utils.fromBool_closure" {
     Foreign.Marshal.Utils.fromBool_closure:
         const Foreign.Marshal.Utils.fromBool_info;
         const 0;
 },
 Foreign.Marshal.Utils.fromBool_entry() //  [R2, R3]
         { info_tbl: [(c8ORY,
                       label: Foreign.Marshal.Utils.fromBool_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ORY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ORZ; else goto c8OS0;
       c8ORZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.fromBool_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OS0: // global
           I64[Sp - 16] = block_c8ORR_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8OS7; else goto c8ORS;
       u8OS7: // global
           call _c8ORR(R1) args: 0, res: 0, upd: 0;
       c8ORS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ORR() //  [R1]
         { info_tbl: [(c8ORR,
                       label: block_c8ORR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ORR: // global
           _s8OLm::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto c8ORV; else goto c8ORW;
       c8ORV: // global
           R2 = _s8OLm::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = Foreign.Marshal.Utils.fromBool2_closure;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
       c8ORW: // global
           R2 = _s8OLm::P64;
           I64[Sp] = stg_ap_p_info;
           P64[Sp + 8] = Foreign.Marshal.Utils.fromBool1_closure;
           call GHC.Num.fromInteger_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.869968748 UTC

[section ""data" . Foreign.Marshal.Utils.toBool_closure" {
     Foreign.Marshal.Utils.toBool_closure:
         const Foreign.Marshal.Utils.toBool_info;
         const 0;
 },
 ds_s8OLr_entry() //  [R1]
         { info_tbl: [(c8OSw,
                       label: ds_s8OLr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OSw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8OSx; else goto c8OSy;
       c8OSx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8OSy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Utils.fromBool2_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8OLt_entry() //  [R1, R2]
         { info_tbl: [(c8OSE,
                       label: sat_s8OLt_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OSE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8OSF; else goto c8OSG;
       c8OSF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8OSG: // global
           _s8OLs::P64 = R2;
           R2 = P64[R1 + 7];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s8OLs::P64;
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes./=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Utils.toBool_entry() //  [R2, R3]
         { info_tbl: [(c8OSH,
                       label: Foreign.Marshal.Utils.toBool_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OSH: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8OSL; else goto c8OSK;
       c8OSL: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.toBool_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OSK: // global
           I64[Hp - 40] = ds_s8OLr_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s8OLt_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.879490502 UTC

[section ""data" . Foreign.Marshal.Utils.maybeNew1_closure" {
     Foreign.Marshal.Utils.maybeNew1_closure:
         const Foreign.Marshal.Utils.maybeNew1_info;
 },
 Foreign.Marshal.Utils.maybeNew1_entry() //  [R2, R3]
         { info_tbl: [(c8OTi,
                       label: Foreign.Marshal.Utils.maybeNew1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OTi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OTj; else goto c8OTk;
       c8OTj: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.maybeNew1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OTk: // global
           I64[Sp - 16] = block_c8OTb_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8OTr; else goto c8OTc;
       u8OTr: // global
           call _c8OTb(R1) args: 0, res: 0, upd: 0;
       c8OTc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OTb() //  [R1]
         { info_tbl: [(c8OTb,
                       label: block_c8OTb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OTb: // global
           if (R1 & 7 == 1) goto c8OTf; else goto c8OTg;
       c8OTf: // global
           R1 = GHC.Ptr.nullPtr_closure;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8OTg: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.885960194 UTC

[section ""data" . Foreign.Marshal.Utils.maybeNew_closure" {
     Foreign.Marshal.Utils.maybeNew_closure:
         const Foreign.Marshal.Utils.maybeNew_info;
 },
 Foreign.Marshal.Utils.maybeNew_entry() //  [R2, R3]
         { info_tbl: [(c8OTJ,
                       label: Foreign.Marshal.Utils.maybeNew_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OTJ: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.maybeNew1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.889430053 UTC

[section ""data" . Foreign.Marshal.Utils.maybeWith_n_closure" {
     Foreign.Marshal.Utils.maybeWith_n_closure:
         const Foreign.Marshal.Utils.maybeWith_n_info;
 },
 Foreign.Marshal.Utils.maybeWith_n_entry() //  [R2]
         { info_tbl: [(c8OTU,
                       label: Foreign.Marshal.Utils.maybeWith_n_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OTU: // global
           _s8OLz::P64 = R2;
           R2 = GHC.Ptr.nullPtr_closure;
           R1 = _s8OLz::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.893771458 UTC

[section ""data" . Foreign.Marshal.Utils.maybeWith_closure" {
     Foreign.Marshal.Utils.maybeWith_closure:
         const Foreign.Marshal.Utils.maybeWith_info;
 },
 Foreign.Marshal.Utils.maybeWith_entry() //  [R2, R3]
         { info_tbl: [(c8OUc,
                       label: Foreign.Marshal.Utils.maybeWith_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OUc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OUd; else goto c8OUe;
       c8OUd: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.maybeWith_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OUe: // global
           I64[Sp - 16] = block_c8OU5_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8OUl; else goto c8OU6;
       u8OUl: // global
           call _c8OU5(R1) args: 0, res: 0, upd: 0;
       c8OU6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OU5() //  [R1]
         { info_tbl: [(c8OU5,
                       label: block_c8OU5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OU5: // global
           if (R1 & 7 == 1) goto c8OU9; else goto c8OUa;
       c8OU9: // global
           R1 = Foreign.Marshal.Utils.maybeWith_n_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8OUa: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.901223599 UTC

[section ""data" . Foreign.Marshal.Utils.maybePeek1_closure" {
     Foreign.Marshal.Utils.maybePeek1_closure:
         const Foreign.Marshal.Utils.maybePeek1_info;
 },
 Foreign.Marshal.Utils.maybePeek1_entry() //  [R2, R3]
         { info_tbl: [(c8OUG,
                       label: Foreign.Marshal.Utils.maybePeek1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OUG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8OUH; else goto c8OUI;
       c8OUH: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.maybePeek1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OUI: // global
           I64[Sp - 16] = block_c8OUD_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8OUY; else goto c8OUE;
       u8OUY: // global
           call _c8OUD(R1) args: 0, res: 0, upd: 0;
       c8OUE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OUD() //  [R1]
         { info_tbl: [(c8OUD,
                       label: block_c8OUD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OUD: // global
           if (I64[R1 + 7] == 0) goto c8OUX; else goto c8OUT;
       c8OUX: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8OUT: // global
           _s8OLE::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8OUP_info;
           R2 = R1;
           R1 = _s8OLE::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OUP() //  [R1]
         { info_tbl: [(c8OUP,
                       label: block_c8OUP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OUP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8OUW; else goto c8OUV;
       c8OUW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8OUV: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.910730721 UTC

[section ""data" . Foreign.Marshal.Utils.maybePeek_closure" {
     Foreign.Marshal.Utils.maybePeek_closure:
         const Foreign.Marshal.Utils.maybePeek_info;
 },
 Foreign.Marshal.Utils.maybePeek_entry() //  [R2, R3]
         { info_tbl: [(c8OVl,
                       label: Foreign.Marshal.Utils.maybePeek_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OVl: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.maybePeek1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.9148504 UTC

[section ""data" . Foreign.Marshal.Utils.withMany_closure" {
     Foreign.Marshal.Utils.withMany_closure:
         const Foreign.Marshal.Utils.withMany_info;
 },
 sat_s8OLX_entry() //  [R1, R2]
         { info_tbl: [(c8OVN,
                       label: sat_s8OLX_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OVN: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8OVR; else goto c8OVQ;
       c8OVR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8OVQ: // global
           _s8OLQ::P64 = P64[R1 + 7];
           _s8OLU::P64 = P64[R1 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s8OLU::P64;
           P64[Hp] = R2;
           R2 = Hp - 14;
           R1 = _s8OLQ::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8OLY_entry() //  [R1, R2]
         { info_tbl: [(c8OVS,
                       label: sat_s8OLY_info
                       rep:HeapRep 3 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OVS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8OVW; else goto c8OVV;
       c8OVW: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8OVV: // global
           _s8OLO::P64 = P64[R1 + 7];
           _s8OLQ::P64 = P64[R1 + 15];
           _s8OLT::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_s8OLX_info;
           P64[Hp - 8] = _s8OLQ::P64;
           P64[Hp] = R2;
           R4 = Hp - 15;
           R3 = _s8OLT::P64;
           R2 = _s8OLO::P64;
           call Foreign.Marshal.Utils.withMany_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Utils.withMany_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OW1,
                       label: Foreign.Marshal.Utils.withMany_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OW1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8OW2; else goto c8OW3;
       c8OW2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.withMany_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OW3: // global
           I64[Sp - 24] = block_c8OVw_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8OW9; else goto c8OVx;
       u8OW9: // global
           call _c8OVw(R1) args: 0, res: 0, upd: 0;
       c8OVx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OVw() //  [R1]
         { info_tbl: [(c8OVw,
                       label: block_c8OVw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OVw: // global
           _s8OLQ::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto c8OVY; else goto c8OVZ;
       c8OVY: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = _s8OLQ::P64;
           Sp = Sp + 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
       c8OVZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8OW8; else goto c8OW7;
       c8OW8: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8OW7: // global
           _s8OLS::P64 = P64[R1 + 6];
           _s8OLT::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s8OLY_info;
           _s8OLO::P64 = P64[Sp + 8];
           P64[Hp - 16] = _s8OLO::P64;
           P64[Hp - 8] = _s8OLQ::P64;
           P64[Hp] = _s8OLT::P64;
           R3 = Hp - 23;
           R2 = _s8OLS::P64;
           R1 = _s8OLO::P64;
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.927721542 UTC

[section ""data" . Foreign.Marshal.Utils.$trModule3_closure" {
     Foreign.Marshal.Utils.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Utils.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.929435181 UTC

[section ""cstring" . Foreign.Marshal.Utils.$trModule2_bytes" {
     Foreign.Marshal.Utils.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,85,116,105,108,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.931117524 UTC

[section ""data" . Foreign.Marshal.Utils.$trModule1_closure" {
     Foreign.Marshal.Utils.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Utils.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.932773362 UTC

[section ""data" . Foreign.Marshal.Utils.$trModule_closure" {
     Foreign.Marshal.Utils.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Marshal.Utils.$trModule3_closure+1;
         const Foreign.Marshal.Utils.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.935473074 UTC

[section ""data" . Foreign.Marshal.Utils.copyBytes1_closure" {
     Foreign.Marshal.Utils.copyBytes1_closure:
         const Foreign.Marshal.Utils.copyBytes1_info;
 },
 Foreign.Marshal.Utils.copyBytes1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OWH,
                       label: Foreign.Marshal.Utils.copyBytes1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OWH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8OWQ; else goto c8OWR;
       c8OWQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.copyBytes1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OWR: // global
           I64[Sp - 24] = block_c8OWE_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8OX7; else goto c8OWF;
       u8OX7: // global
           call _c8OWE(R1) args: 0, res: 0, upd: 0;
       c8OWF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OWE() //  [R1]
         { info_tbl: [(c8OWE,
                       label: block_c8OWE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OWE: // global
           I64[Sp] = block_c8OWK_info;
           _s8OM4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8OM4::I64;
           if (R1 & 7 != 0) goto u8OX6; else goto c8OWL;
       u8OX6: // global
           call _c8OWK(R1) args: 0, res: 0, upd: 0;
       c8OWL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OWK() //  [R1]
         { info_tbl: [(c8OWK,
                       label: block_c8OWK_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OWK: // global
           I64[Sp] = block_c8OWP_info;
           _s8OM6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8OM6::I64;
           if (R1 & 7 != 0) goto u8OX8; else goto c8OWU;
       u8OX8: // global
           call _c8OWP(R1) args: 0, res: 0, upd: 0;
       c8OWU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OWP() //  [R1]
         { info_tbl: [(c8OWP,
                       label: block_c8OWP_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OWP: // global
           (_s8OMd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[Sp + 8], I64[Sp + 16], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.945425559 UTC

[section ""data" . Foreign.Marshal.Utils.copyBytes_closure" {
     Foreign.Marshal.Utils.copyBytes_closure:
         const Foreign.Marshal.Utils.copyBytes_info;
 },
 Foreign.Marshal.Utils.copyBytes_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OXz,
                       label: Foreign.Marshal.Utils.copyBytes_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OXz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.copyBytes1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.949721656 UTC

[section ""data" . Foreign.Marshal.Utils.moveBytes1_closure" {
     Foreign.Marshal.Utils.moveBytes1_closure:
         const Foreign.Marshal.Utils.moveBytes1_info;
 },
 Foreign.Marshal.Utils.moveBytes1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OXN,
                       label: Foreign.Marshal.Utils.moveBytes1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OXN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8OXW; else goto c8OXX;
       c8OXW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.moveBytes1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OXX: // global
           I64[Sp - 24] = block_c8OXK_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8OYd; else goto c8OXL;
       u8OYd: // global
           call _c8OXK(R1) args: 0, res: 0, upd: 0;
       c8OXL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OXK() //  [R1]
         { info_tbl: [(c8OXK,
                       label: block_c8OXK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OXK: // global
           I64[Sp] = block_c8OXQ_info;
           _s8OMj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8OMj::I64;
           if (R1 & 7 != 0) goto u8OYc; else goto c8OXR;
       u8OYc: // global
           call _c8OXQ(R1) args: 0, res: 0, upd: 0;
       c8OXR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OXQ() //  [R1]
         { info_tbl: [(c8OXQ,
                       label: block_c8OXQ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OXQ: // global
           I64[Sp] = block_c8OXV_info;
           _s8OMl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8OMl::I64;
           if (R1 & 7 != 0) goto u8OYe; else goto c8OY0;
       u8OYe: // global
           call _c8OXV(R1) args: 0, res: 0, upd: 0;
       c8OY0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OXV() //  [R1]
         { info_tbl: [(c8OXV,
                       label: block_c8OXV_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OXV: // global
           (_s8OMs::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(I64[Sp + 8], I64[Sp + 16], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.95962926 UTC

[section ""data" . Foreign.Marshal.Utils.moveBytes_closure" {
     Foreign.Marshal.Utils.moveBytes_closure:
         const Foreign.Marshal.Utils.moveBytes_info;
 },
 Foreign.Marshal.Utils.moveBytes_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OYF,
                       label: Foreign.Marshal.Utils.moveBytes_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OYF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.moveBytes1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.963969393 UTC

[section ""data" . Foreign.Marshal.Utils.fillBytes1_closure" {
     Foreign.Marshal.Utils.fillBytes1_closure:
         const Foreign.Marshal.Utils.fillBytes1_info;
 },
 Foreign.Marshal.Utils.fillBytes1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OYT,
                       label: Foreign.Marshal.Utils.fillBytes1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OYT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8OZ2; else goto c8OZ3;
       c8OZ2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Utils.fillBytes1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8OZ3: // global
           I64[Sp - 24] = block_c8OYQ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8OZm; else goto c8OYR;
       u8OZm: // global
           call _c8OYQ(R1) args: 0, res: 0, upd: 0;
       c8OYR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OYQ() //  [R1]
         { info_tbl: [(c8OYQ,
                       label: block_c8OYQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OYQ: // global
           I64[Sp] = block_c8OYW_info;
           _s8OMy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8OMy::I64;
           if (R1 & 7 != 0) goto u8OZl; else goto c8OYX;
       u8OZl: // global
           call _c8OYW(R1) args: 0, res: 0, upd: 0;
       c8OYX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OYW() //  [R1]
         { info_tbl: [(c8OYW,
                       label: block_c8OYW_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OYW: // global
           I64[Sp] = block_c8OZ1_info;
           _s8OMA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8OMA::I64;
           if (R1 & 7 != 0) goto u8OZn; else goto c8OZ6;
       u8OZn: // global
           call _c8OZ1(R1) args: 0, res: 0, upd: 0;
       c8OZ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8OZ1() //  [R1]
         { info_tbl: [(c8OZ1,
                       label: block_c8OZ1_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OZ1: // global
           (_s8OMI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     signed,]  result hints:  [PtrHint] memset(I64[Sp + 8], I64[Sp + 16], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.973669057 UTC

[section ""data" . Foreign.Marshal.Utils.fillBytes_closure" {
     Foreign.Marshal.Utils.fillBytes_closure:
         const Foreign.Marshal.Utils.fillBytes_info;
 },
 Foreign.Marshal.Utils.fillBytes_entry() //  [R2, R3, R4]
         { info_tbl: [(c8OZO,
                       label: Foreign.Marshal.Utils.fillBytes_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8OZO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Utils.fillBytes1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:58.977588207 UTC

[section ""relreadonly" . S8OO7_srt" {
     S8OO7_srt:
         const GHC.Err.undefined_closure;
         const lvl11_r8Ohm_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Utils.new1_closure;
         const Foreign.Marshal.Utils.new2_closure;
         const lvl16_r8Ohr_closure;
         const lvl20_r8Ohv_closure;
         const Foreign.Marshal.Utils.with1_closure;
         const Foreign.Marshal.Utils.with2_closure;
         const Foreign.Marshal.Utils.with3_closure;
         const sat_s8OLl_closure;
         const Foreign.Marshal.Utils.fromBool_closure;
         const Foreign.Marshal.Utils.fromBool1_closure;
         const Foreign.Marshal.Utils.fromBool2_closure;
         const Foreign.Marshal.Utils.toBool_closure;
 }]

