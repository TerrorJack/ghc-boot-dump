
==================== Output Cmm ====================
2018-03-16 16:03:59.263666204 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:59.264304774 UTC

[section ""cstring" . lvl_r8PPf_bytes" {
     lvl_r8PPf_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.265215117 UTC

[section ""data" . lvl1_r8PPg_closure" {
     lvl1_r8PPg_closure:
         const lvl1_r8PPg_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r8PPg_entry() //  [R1]
         { info_tbl: [(c8PW0,
                       label: lvl1_r8PPg_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PW0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8PW1; else goto c8PW2;
       c8PW1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8PW2: // global
           (_c8PVX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8PVX::I64 == 0) goto c8PVZ; else goto c8PVY;
       c8PVZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8PVY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8PVX::I64;
           R2 = lvl_r8PPf_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.266291239 UTC

[section ""cstring" . Foreign.Marshal.Array.$trModule4_bytes" {
     Foreign.Marshal.Array.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.267828809 UTC

[section ""data" . lvl2_r8PPh_closure" {
     lvl2_r8PPh_closure:
         const lvl2_r8PPh_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r8PPh_entry() //  [R1]
         { info_tbl: [(c8PW9,
                       label: lvl2_r8PPh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PW9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8PWa; else goto c8PWb;
       c8PWa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8PWb: // global
           (_c8PW6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8PW6::I64 == 0) goto c8PW8; else goto c8PW7;
       c8PW8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8PW7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8PW6::I64;
           R2 = Foreign.Marshal.Array.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.268716435 UTC

[section ""cstring" . Foreign.Marshal.Array.$trModule2_bytes" {
     Foreign.Marshal.Array.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,65,114,114,97,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.269451439 UTC

[section ""data" . lvl3_r8PPi_closure" {
     lvl3_r8PPi_closure:
         const lvl3_r8PPi_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r8PPi_entry() //  [R1]
         { info_tbl: [(c8PWi,
                       label: lvl3_r8PPi_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PWi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8PWj; else goto c8PWk;
       c8PWj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8PWk: // global
           (_c8PWf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8PWf::I64 == 0) goto c8PWh; else goto c8PWg;
       c8PWh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8PWg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8PWf::I64;
           R2 = Foreign.Marshal.Array.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.270376147 UTC

[section ""cstring" . lvl4_r8PPj_bytes" {
     lvl4_r8PPj_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,77,97,114,115,104,97,108,47,65,114,114,97,121,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.271102818 UTC

[section ""data" . lvl5_r8PPk_closure" {
     lvl5_r8PPk_closure:
         const lvl5_r8PPk_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r8PPk_entry() //  [R1]
         { info_tbl: [(c8PWr,
                       label: lvl5_r8PPk_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PWr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8PWs; else goto c8PWt;
       c8PWs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8PWt: // global
           (_c8PWo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8PWo::I64 == 0) goto c8PWq; else goto c8PWp;
       c8PWq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8PWp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8PWo::I64;
           R2 = lvl4_r8PPj_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.272020869 UTC

[section ""data" . lvl6_r8PPl_closure" {
     lvl6_r8PPl_closure:
         const GHC.Types.I#_con_info;
         const 86;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.272623675 UTC

[section ""data" . lvl7_r8PPm_closure" {
     lvl7_r8PPm_closure:
         const GHC.Types.I#_con_info;
         const 25;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.273178844 UTC

[section ""data" . lvl8_r8PPn_closure" {
     lvl8_r8PPn_closure:
         const GHC.Types.I#_con_info;
         const 34;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.273797916 UTC

[section ""data" . lvl9_r8PPo_closure" {
     lvl9_r8PPo_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl6_r8PPl_closure+1;
         const lvl7_r8PPm_closure+1;
         const lvl6_r8PPl_closure+1;
         const lvl8_r8PPn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.274398136 UTC

[section ""data" . lvl10_r8PPp_closure" {
     lvl10_r8PPp_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl9_r8PPo_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.275132316 UTC

[section ""data" . Foreign.Marshal.Array.mallocArray1_closure" {
     Foreign.Marshal.Array.mallocArray1_closure:
         const Foreign.Marshal.Array.mallocArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.mallocArray1_entry() //  [R1]
         { info_tbl: [(c8PWA,
                       label: Foreign.Marshal.Array.mallocArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PWA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8PWB; else goto c8PWC;
       c8PWB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8PWC: // global
           (_c8PWx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8PWx::I64 == 0) goto c8PWz; else goto c8PWy;
       c8PWz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8PWy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8PWx::I64;
           R2 = lvl10_r8PPp_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.276922563 UTC

[section ""data" . Foreign.Marshal.Array.mallocArray_closure" {
     Foreign.Marshal.Array.mallocArray_closure:
         const Foreign.Marshal.Array.mallocArray_info;
         const 0;
 },
 lvl33_s8PPO_entry() //  [R1]
         { info_tbl: [(c8PWM,
                       label: lvl33_s8PPO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PWM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8PWN; else goto c8PWO;
       c8PWN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8PWO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.mallocArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PQ3_entry() //  [R1, R2]
         { info_tbl: [(c8PWX,
                       label: sat_s8PQ3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PWX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8PX1; else goto c8PX2;
       c8PX1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8PX2: // global
           I64[Sp - 16] = block_c8PWU_info;
           _s8PPO::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _s8PPO::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8PXr; else goto c8PWV;
       u8PXr: // global
           call _c8PWU(R1) args: 0, res: 0, upd: 0;
       c8PWV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8PWU() //  [R1]
         { info_tbl: [(c8PWU,
                       label: block_c8PWU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PWU: // global
           I64[Sp] = block_c8PX0_info;
           _s8PPS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PPS::I64;
           if (R1 & 7 != 0) goto u8PXq; else goto c8PX4;
       u8PXq: // global
           call _c8PX0(R1) args: 0, res: 0, upd: 0;
       c8PX4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8PX0() //  [R1]
         { info_tbl: [(c8PX0,
                       label: block_c8PX0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PX0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8PXa; else goto c8PX9;
       c8PXa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8PX9: // global
           (_s8PQ0::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[Sp + 8] * I64[R1 + 7]);
           if (_s8PQ0::I64 == 0) goto c8PXp; else goto c8PXo;
       c8PXp: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8PXo: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PQ0::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.mallocArray_entry() //  [R2]
         { info_tbl: [(c8PXs,
                       label: Foreign.Marshal.Array.mallocArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PXs: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8PXw; else goto c8PXv;
       c8PXw: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.mallocArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8PXv: // global
           I64[Hp - 32] = lvl33_s8PPO_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8PQ3_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.279323584 UTC

[section ""data" . Foreign.Marshal.Array.$wmallocArray0_closure" {
     Foreign.Marshal.Array.$wmallocArray0_closure:
         const Foreign.Marshal.Array.$wmallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.$wmallocArray0_entry() //  [R2, R3]
         { info_tbl: [(c8PXD,
                       label: Foreign.Marshal.Array.$wmallocArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PXD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8PXE; else goto c8PXF;
       c8PXE: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.$wmallocArray0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8PXF: // global
           I64[Sp - 16] = block_c8PXB_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.mallocArray1_closure;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8PXB() //  [R1]
         { info_tbl: [(c8PXB,
                       label: block_c8PXB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PXB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8PXK; else goto c8PXJ;
       c8PXK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8PXJ: // global
           (_s8PQf::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc((I64[Sp + 8] + 1) * I64[R1 + 7]);
           if (_s8PQf::I64 == 0) goto c8PY2; else goto c8PY1;
       c8PY2: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8PY1: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PQf::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.280743383 UTC

[section ""data" . Foreign.Marshal.Array.mallocArray2_closure" {
     Foreign.Marshal.Array.mallocArray2_closure:
         const Foreign.Marshal.Array.mallocArray2_info;
         const 0;
 },
 Foreign.Marshal.Array.mallocArray2_entry() //  [R2, R3]
         { info_tbl: [(c8PYa,
                       label: Foreign.Marshal.Array.mallocArray2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PYa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8PYb; else goto c8PYc;
       c8PYb: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.mallocArray2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8PYc: // global
           I64[Sp - 16] = block_c8PY7_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8PYg; else goto c8PY8;
       u8PYg: // global
           call _c8PY7(R1) args: 0, res: 0, upd: 0;
       c8PY8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8PY7() //  [R1]
         { info_tbl: [(c8PY7,
                       label: block_c8PY7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PY7: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.Marshal.Array.$wmallocArray0_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.28221119 UTC

[section ""data" . Foreign.Marshal.Array.mallocArray0_closure" {
     Foreign.Marshal.Array.mallocArray0_closure:
         const Foreign.Marshal.Array.mallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.mallocArray0_entry() //  [R2, R3]
         { info_tbl: [(c8PYl,
                       label: Foreign.Marshal.Array.mallocArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PYl: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.mallocArray2_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.282999483 UTC

[section ""data" . lvl11_r8PPq_closure" {
     lvl11_r8PPq_closure:
         const GHC.Types.I#_con_info;
         const 100;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.283527799 UTC

[section ""data" . lvl12_r8PPr_closure" {
     lvl12_r8PPr_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl11_r8PPq_closure+1;
         const lvl7_r8PPm_closure+1;
         const lvl11_r8PPq_closure+1;
         const lvl8_r8PPn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.284117821 UTC

[section ""data" . lvl13_r8PPs_closure" {
     lvl13_r8PPs_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl12_r8PPr_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.284847169 UTC

[section ""data" . Foreign.Marshal.Array.callocArray1_closure" {
     Foreign.Marshal.Array.callocArray1_closure:
         const Foreign.Marshal.Array.callocArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.callocArray1_entry() //  [R1]
         { info_tbl: [(c8PYu,
                       label: Foreign.Marshal.Array.callocArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PYu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8PYv; else goto c8PYw;
       c8PYv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8PYw: // global
           (_c8PYr::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8PYr::I64 == 0) goto c8PYt; else goto c8PYs;
       c8PYt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8PYs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8PYr::I64;
           R2 = lvl13_r8PPs_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.286756294 UTC

[section ""data" . Foreign.Marshal.Array.callocArray_closure" {
     Foreign.Marshal.Array.callocArray_closure:
         const Foreign.Marshal.Array.callocArray_info;
         const 0;
 },
 lvl33_s8PQo_entry() //  [R1]
         { info_tbl: [(c8PYF,
                       label: lvl33_s8PQo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PYF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8PYG; else goto c8PYH;
       c8PYG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8PYH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.callocArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PQD_entry() //  [R1, R2]
         { info_tbl: [(c8PYQ,
                       label: sat_s8PQD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PYQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8PYU; else goto c8PYV;
       c8PYU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8PYV: // global
           I64[Sp - 16] = block_c8PYN_info;
           _s8PQo::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _s8PQo::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8PZl; else goto c8PYO;
       u8PZl: // global
           call _c8PYN(R1) args: 0, res: 0, upd: 0;
       c8PYO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8PYN() //  [R1]
         { info_tbl: [(c8PYN,
                       label: block_c8PYN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PYN: // global
           I64[Sp] = block_c8PYT_info;
           _s8PQs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PQs::I64;
           if (R1 & 7 != 0) goto u8PZk; else goto c8PYX;
       u8PZk: // global
           call _c8PYT(R1) args: 0, res: 0, upd: 0;
       c8PYX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8PYT() //  [R1]
         { info_tbl: [(c8PYT,
                       label: block_c8PYT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PYT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8PZ3; else goto c8PZ2;
       c8PZ3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8PZ2: // global
           (_s8PQA::I64) = call "ccall" arg hints:  [,]  result hints:  [PtrHint] calloc(1, I64[Sp + 8] * I64[R1 + 7]);
           if (_s8PQA::I64 == 0) goto c8PZj; else goto c8PZi;
       c8PZj: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.calloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8PZi: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PQA::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.callocArray_entry() //  [R2]
         { info_tbl: [(c8PZm,
                       label: Foreign.Marshal.Array.callocArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PZm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8PZq; else goto c8PZp;
       c8PZq: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.callocArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8PZp: // global
           I64[Hp - 32] = lvl33_s8PQo_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8PQD_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.289444665 UTC

[section ""data" . Foreign.Marshal.Array.$wcallocArray0_closure" {
     Foreign.Marshal.Array.$wcallocArray0_closure:
         const Foreign.Marshal.Array.$wcallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.$wcallocArray0_entry() //  [R2, R3]
         { info_tbl: [(c8PZx,
                       label: Foreign.Marshal.Array.$wcallocArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PZx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8PZy; else goto c8PZz;
       c8PZy: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.$wcallocArray0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8PZz: // global
           I64[Sp - 16] = block_c8PZv_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.callocArray1_closure;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8PZv() //  [R1]
         { info_tbl: [(c8PZv,
                       label: block_c8PZv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8PZv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8PZE; else goto c8PZD;
       c8PZE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8PZD: // global
           (_s8PQP::I64) = call "ccall" arg hints:  [,]  result hints:  [PtrHint] calloc(1, (I64[Sp + 8] + 1) * I64[R1 + 7]);
           if (_s8PQP::I64 == 0) goto c8PZX; else goto c8PZW;
       c8PZX: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.calloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8PZW: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PQP::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.291106795 UTC

[section ""data" . Foreign.Marshal.Array.callocArray2_closure" {
     Foreign.Marshal.Array.callocArray2_closure:
         const Foreign.Marshal.Array.callocArray2_info;
         const 0;
 },
 Foreign.Marshal.Array.callocArray2_entry() //  [R2, R3]
         { info_tbl: [(c8Q05,
                       label: Foreign.Marshal.Array.callocArray2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q05: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Q06; else goto c8Q07;
       c8Q06: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.callocArray2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Q07: // global
           I64[Sp - 16] = block_c8Q02_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Q0b; else goto c8Q03;
       u8Q0b: // global
           call _c8Q02(R1) args: 0, res: 0, upd: 0;
       c8Q03: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q02() //  [R1]
         { info_tbl: [(c8Q02,
                       label: block_c8Q02_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q02: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.Marshal.Array.$wcallocArray0_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.293375148 UTC

[section ""data" . Foreign.Marshal.Array.callocArray0_closure" {
     Foreign.Marshal.Array.callocArray0_closure:
         const Foreign.Marshal.Array.callocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.callocArray0_entry() //  [R2, R3]
         { info_tbl: [(c8Q0g,
                       label: Foreign.Marshal.Array.callocArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q0g: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.callocArray2_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.294127388 UTC

[section ""data" . lvl14_r8PPt_closure" {
     lvl14_r8PPt_closure:
         const GHC.Types.I#_con_info;
         const 115;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.294691228 UTC

[section ""data" . lvl15_r8PPu_closure" {
     lvl15_r8PPu_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl14_r8PPt_closure+1;
         const lvl7_r8PPm_closure+1;
         const lvl14_r8PPt_closure+1;
         const lvl8_r8PPn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.295326963 UTC

[section ""data" . lvl16_r8PPv_closure" {
     lvl16_r8PPv_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl15_r8PPu_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.296167391 UTC

[section ""data" . Foreign.Marshal.Array.allocaArray1_closure" {
     Foreign.Marshal.Array.allocaArray1_closure:
         const Foreign.Marshal.Array.allocaArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.allocaArray1_entry() //  [R1]
         { info_tbl: [(c8Q0p,
                       label: Foreign.Marshal.Array.allocaArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q0p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Q0q; else goto c8Q0r;
       c8Q0q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Q0r: // global
           (_c8Q0m::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Q0m::I64 == 0) goto c8Q0o; else goto c8Q0n;
       c8Q0o: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Q0n: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Q0m::I64;
           R2 = lvl16_r8PPv_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.29815676 UTC

[section ""data" . Foreign.Marshal.Array.allocaArray_closure" {
     Foreign.Marshal.Array.allocaArray_closure:
         const Foreign.Marshal.Array.allocaArray_info;
         const 0;
 },
 lvl33_s8PQY_entry() //  [R1]
         { info_tbl: [(c8Q0A,
                       label: lvl33_s8PQY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q0A: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Q0B; else goto c8Q0C;
       c8Q0B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Q0C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.allocaArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds1_s8PQZ_entry() //  [R1]
         { info_tbl: [(c8Q0H,
                       label: ds1_s8PQZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q0H: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Q0I; else goto c8Q0J;
       c8Q0I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Q0J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.allocaArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.alignment_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PRm_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Q0S,
                       label: sat_s8PRm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q0S: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Q11; else goto c8Q12;
       c8Q11: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Q12: // global
           I64[Sp - 32] = block_c8Q0P_info;
           _s8PQY::P64 = P64[R1 + 5];
           _s8PQZ::P64 = P64[R1 + 13];
           R1 = R2;
           P64[Sp - 24] = _s8PQY::P64;
           P64[Sp - 16] = _s8PQZ::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8Q1r; else goto c8Q0Q;
       u8Q1r: // global
           call _c8Q0P(R1) args: 0, res: 0, upd: 0;
       c8Q0Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q0P() //  [R1]
         { info_tbl: [(c8Q0P,
                       label: block_c8Q0P_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q0P: // global
           I64[Sp] = block_c8Q0V_info;
           _s8PR4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PR4::I64;
           if (R1 & 7 != 0) goto u8Q1q; else goto c8Q0W;
       u8Q1q: // global
           call _c8Q0V(R1) args: 0, res: 0, upd: 0;
       c8Q0W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q0V() //  [R1]
         { info_tbl: [(c8Q0V,
                       label: block_c8Q0V_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q0V: // global
           I64[Sp] = block_c8Q10_info;
           _s8PR6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8PR6::I64;
           if (R1 & 7 != 0) goto u8Q1s; else goto c8Q15;
       u8Q1s: // global
           call _c8Q10(R1) args: 0, res: 0, upd: 0;
       c8Q15: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q10() //  [R1]
         { info_tbl: [(c8Q10,
                       label: block_c8Q10_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q10: // global
           _s8PR9::I64 = I64[Sp + 8] * I64[Sp + 16];
           I64[Sp + 16] = block_c8Q1d_info;
           R2 = I64[R1 + 7];
           R1 = _s8PR9::I64;
           Sp = Sp + 16;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q1d() //  [R1]
         { info_tbl: [(c8Q1d,
                       label: block_c8Q1d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q1d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Q1h; else goto c8Q1g;
       c8Q1h: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Q1g: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           P64[Hp] = R1 + 16;
           I64[Sp] = block_c8Q1m_info;
           R2 = Hp - 7;
           _s8PRf::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8PRf::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q1m() //  [R1]
         { info_tbl: [(c8Q1m,
                       label: block_c8Q1m_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q1m: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.allocaArray_entry() //  [R2]
         { info_tbl: [(c8Q1t,
                       label: Foreign.Marshal.Array.allocaArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q1t: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8Q1x; else goto c8Q1w;
       c8Q1x: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Foreign.Marshal.Array.allocaArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Q1w: // global
           I64[Hp - 64] = lvl33_s8PQY_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = ds1_s8PQZ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s8PRm_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 13;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.301466163 UTC

[section ""data" . Foreign.Marshal.Array.allocaArray0_closure" {
     Foreign.Marshal.Array.allocaArray0_closure:
         const Foreign.Marshal.Array.allocaArray0_info;
         const 0;
 },
 sat_s8PRs_entry() //  [R1]
         { info_tbl: [(c8Q1J,
                       label: sat_s8PRs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q1J: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Q1Q; else goto c8Q1R;
       c8Q1Q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Q1R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8Q1G_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Q1V; else goto c8Q1H;
       u8Q1V: // global
           call _c8Q1G(R1) args: 0, res: 0, upd: 0;
       c8Q1H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8Q1G() //  [R1]
         { info_tbl: [(c8Q1G,
                       label: block_c8Q1G_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q1G: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Q1U; else goto c8Q1T;
       c8Q1U: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8Q1T: // global
           _s8PRr::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8PRr::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Array.allocaArray0_entry() //  [R2, R3]
         { info_tbl: [(c8Q1W,
                       label: Foreign.Marshal.Array.allocaArray0_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q1W: // global
           _s8PRo::P64 = R3;
           _s8PRn::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Q1X; else goto c8Q1Y;
       c8Q1Y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Q20; else goto c8Q1Z;
       c8Q20: // global
           HpAlloc = 24;
           goto c8Q1X;
       c8Q1X: // global
           R3 = _s8PRo::P64;
           R2 = _s8PRn::P64;
           R1 = Foreign.Marshal.Array.allocaArray0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Q1Z: // global
           I64[Hp - 16] = sat_s8PRs_info;
           P64[Hp] = _s8PRo::P64;
           R2 = _s8PRn::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Foreign.Marshal.Array.allocaArray_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.30303692 UTC

[section ""data" . lvl17_r8PPw_closure" {
     lvl17_r8PPw_closure:
         const GHC.Types.I#_con_info;
         const 133;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.303599787 UTC

[section ""data" . lvl18_r8PPx_closure" {
     lvl18_r8PPx_closure:
         const GHC.Types.I#_con_info;
         const 27;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.304188936 UTC

[section ""data" . lvl19_r8PPy_closure" {
     lvl19_r8PPy_closure:
         const GHC.Types.I#_con_info;
         const 36;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.304747242 UTC

[section ""data" . lvl20_r8PPz_closure" {
     lvl20_r8PPz_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl17_r8PPw_closure+1;
         const lvl18_r8PPx_closure+1;
         const lvl17_r8PPw_closure+1;
         const lvl19_r8PPy_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.305568937 UTC

[section ""data" . lvl21_r8PPA_closure" {
     lvl21_r8PPA_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl20_r8PPz_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.306323222 UTC

[section ""data" . Foreign.Marshal.Array.reallocArray1_closure" {
     Foreign.Marshal.Array.reallocArray1_closure:
         const Foreign.Marshal.Array.reallocArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.reallocArray1_entry() //  [R1]
         { info_tbl: [(c8Q27,
                       label: Foreign.Marshal.Array.reallocArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q27: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Q28; else goto c8Q29;
       c8Q28: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Q29: // global
           (_c8Q24::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Q24::I64 == 0) goto c8Q26; else goto c8Q25;
       c8Q26: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Q25: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Q24::I64;
           R2 = lvl21_r8PPA_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.30830783 UTC

[section ""data" . Foreign.Marshal.Array.reallocArray_closure" {
     Foreign.Marshal.Array.reallocArray_closure:
         const Foreign.Marshal.Array.reallocArray_info;
         const 0;
 },
 lvl33_s8PRu_entry() //  [R1]
         { info_tbl: [(c8Q2i,
                       label: lvl33_s8PRu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q2i: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Q2j; else goto c8Q2k;
       c8Q2j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Q2k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.reallocArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PRP_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Q2t,
                       label: sat_s8PRP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q2t: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Q2C; else goto c8Q2D;
       c8Q2C: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Q2D: // global
           I64[Sp - 24] = block_c8Q2q_info;
           _s8PRu::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s8PRu::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Q3k; else goto c8Q2r;
       u8Q3k: // global
           call _c8Q2q(R1) args: 0, res: 0, upd: 0;
       c8Q2r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q2q() //  [R1]
         { info_tbl: [(c8Q2q,
                       label: block_c8Q2q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q2q: // global
           I64[Sp] = block_c8Q2w_info;
           _s8PRz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PRz::I64;
           if (R1 & 7 != 0) goto u8Q3j; else goto c8Q2x;
       u8Q3j: // global
           call _c8Q2w(R1) args: 0, res: 0, upd: 0;
       c8Q2x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q2w() //  [R1]
         { info_tbl: [(c8Q2w,
                       label: block_c8Q2w_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q2w: // global
           I64[Sp] = block_c8Q2B_info;
           _s8PRB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8PRB::I64;
           if (R1 & 7 != 0) goto u8Q3l; else goto c8Q2G;
       u8Q3l: // global
           call _c8Q2B(R1) args: 0, res: 0, upd: 0;
       c8Q2G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q2B() //  [R1]
         { info_tbl: [(c8Q2B,
                       label: block_c8Q2B_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q2B: // global
           _s8PRD::I64 = I64[R1 + 7];
           _s8PRE::I64 = I64[Sp + 8] * I64[Sp + 16];
           if (_s8PRE::I64 != 0) goto u8Q3h; else goto c8Q3b;
       u8Q3h: // global
           I64[Sp + 8] = _s8PRE::I64;
           I64[Sp + 16] = _s8PRD::I64;
           Sp = Sp + 8;
           call _c8Q2R() args: 0, res: 0, upd: 0;
       c8Q3b: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(_s8PRD::I64);
           R1 = GHC.Ptr.nullPtr_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Q2R() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q2R: // global
           Hp = Hp + 16;
           _s8PRE::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c8Q2V; else goto c8Q2U;
       c8Q2V: // global
           HpAlloc = 16;
           I64[Sp] = block_c8Q2O_info;
           R1 = _s8PRE::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8Q2U: // global
           (_s8PRJ::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp + 8], _s8PRE::I64);
           if (_s8PRJ::I64 == 0) goto c8Q38; else goto c8Q37;
       c8Q38: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Q37: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PRJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Q2O() //  [R1]
         { info_tbl: [(c8Q2O,
                       label: block_c8Q2O_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q2O: // global
           I64[Sp] = R1;
           call _c8Q2R() args: 0, res: 0, upd: 0;
     }
 },
 Foreign.Marshal.Array.reallocArray_entry() //  [R2]
         { info_tbl: [(c8Q3o,
                       label: Foreign.Marshal.Array.reallocArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q3o: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Q3s; else goto c8Q3r;
       c8Q3s: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.reallocArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Q3r: // global
           I64[Hp - 32] = lvl33_s8PRu_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8PRP_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.311722909 UTC

[section ""data" . Foreign.Marshal.Array.$wreallocArray0_closure" {
     Foreign.Marshal.Array.$wreallocArray0_closure:
         const Foreign.Marshal.Array.$wreallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.$wreallocArray0_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Q3z,
                       label: Foreign.Marshal.Array.$wreallocArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 20} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q3z: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8Q3A; else goto c8Q3B;
       c8Q3A: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.$wreallocArray0_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Q3B: // global
           I64[Sp - 24] = block_c8Q3x_info;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = Foreign.Marshal.Array.reallocArray1_closure;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8Q3x() //  [R1]
         { info_tbl: [(c8Q3x,
                       label: block_c8Q3x_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q3x: // global
           _s8PRX::I64 = (I64[Sp + 16] + 1) * I64[R1 + 7];
           if (_s8PRX::I64 != 0) goto u8Q4e; else goto c8Q48;
       u8Q4e: // global
           I64[Sp + 16] = _s8PRX::I64;
           Sp = Sp + 8;
           call _c8Q3O() args: 0, res: 0, upd: 0;
       c8Q48: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[Sp + 8]);
           R1 = GHC.Ptr.nullPtr_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Q3O() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q3O: // global
           Hp = Hp + 16;
           _s8PRX::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c8Q3S; else goto c8Q3R;
       c8Q3S: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c8Q3L_info;
           R1 = _s8PRX::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8Q3R: // global
           (_s8PS2::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp], _s8PRX::I64);
           if (_s8PS2::I64 == 0) goto c8Q45; else goto c8Q44;
       c8Q45: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Q44: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PS2::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Q3L() //  [R1]
         { info_tbl: [(c8Q3L,
                       label: block_c8Q3L_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q3L: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c8Q3O() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.313907672 UTC

[section ""data" . Foreign.Marshal.Array.reallocArray2_closure" {
     Foreign.Marshal.Array.reallocArray2_closure:
         const Foreign.Marshal.Array.reallocArray2_info;
         const 0;
 },
 Foreign.Marshal.Array.reallocArray2_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Q4p,
                       label: Foreign.Marshal.Array.reallocArray2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q4p: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Q4t; else goto c8Q4u;
       c8Q4t: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.reallocArray2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Q4u: // global
           I64[Sp - 24] = block_c8Q4m_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Q4C; else goto c8Q4n;
       u8Q4C: // global
           call _c8Q4m(R1) args: 0, res: 0, upd: 0;
       c8Q4n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q4m() //  [R1]
         { info_tbl: [(c8Q4m,
                       label: block_c8Q4m_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q4m: // global
           I64[Sp] = block_c8Q4s_info;
           _s8PSd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8PSd::I64;
           if (R1 & 7 != 0) goto u8Q4B; else goto c8Q4w;
       u8Q4B: // global
           call _c8Q4s(R1) args: 0, res: 0, upd: 0;
       c8Q4w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q4s() //  [R1]
         { info_tbl: [(c8Q4s,
                       label: block_c8Q4s_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q4s: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Array.$wreallocArray0_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.315539347 UTC

[section ""data" . Foreign.Marshal.Array.reallocArray0_closure" {
     Foreign.Marshal.Array.reallocArray0_closure:
         const Foreign.Marshal.Array.reallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.reallocArray0_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Q4H,
                       label: Foreign.Marshal.Array.reallocArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q4H: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.reallocArray2_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.316432022 UTC

[section ""data" . Foreign.Marshal.Array.lengthArray2_closure" {
     Foreign.Marshal.Array.lengthArray2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.31939888 UTC

[section ""data" . Foreign.Marshal.Array.$wpeekArray_closure" {
     Foreign.Marshal.Array.$wpeekArray_closure:
         const Foreign.Marshal.Array.$wpeekArray_info;
 },
 Foreign.Marshal.Array.$wpeekArray_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Q5a,
                       label: Foreign.Marshal.Array.$wpeekArray_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q5a: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8Q5b; else goto c8Q5c;
       c8Q5b: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.$wpeekArray_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Q5c: // global
           if (%MO_S_Gt_W64(R3, 0)) goto c8Q58; else goto c8Q59;
       c8Q58: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R3 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call _c8Q4Y() args: 0, res: 0, upd: 0;
       c8Q59: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Q4Y() //  []
         { info_tbl: [(c8Q4Y,
                       label: block_c8Q4Y_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q4Y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Q5p; else goto c8Q5o;
       c8Q5p: // global
           HpAlloc = 16;
           I64[Sp] = block_c8Q4Y_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Q5o: // global
           _s8PSg::P64 = P64[Sp + 8];
           _s8PSi::P64 = P64[Sp + 16];
           _s8PSw::I64 = I64[Sp + 24];
           if (_s8PSw::I64 != 0) goto c8Q5r; else goto c8Q5v;
       c8Q5r: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8PSw::I64;
           I64[Sp] = block_c8Q54_info;
           R2 = _s8PSg::P64;
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = _s8PSi::P64;
           P64[Sp - 8] = Hp - 7;
           I64[Sp + 24] = _s8PSw::I64;
           Sp = Sp - 24;
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 8, upd: 8;
       c8Q5v: // global
           Hp = Hp - 16;
           I64[Sp + 24] = block_c8Q5g_info;
           R2 = _s8PSg::P64;
           I64[Sp] = stg_ap_ppv_info;
           P64[Sp + 8] = _s8PSi::P64;
           P64[Sp + 16] = Foreign.Marshal.Array.lengthArray2_closure+1;
           P64[Sp + 32] = P64[Sp + 32];
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8Q54() //  [R1]
         { info_tbl: [(c8Q54,
                       label: block_c8Q54_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q54: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Q5u; else goto c8Q5t;
       c8Q5u: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Q5t: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 32];
           I64[Sp + 24] = I64[Sp + 24] - 1;
           P64[Sp + 32] = Hp - 14;
           call _c8Q4Y() args: 0, res: 0, upd: 0;
     }
 },
 _c8Q5g() //  [R1]
         { info_tbl: [(c8Q5g,
                       label: block_c8Q5g_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q5g: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Q5m; else goto c8Q5l;
       c8Q5m: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Q5l: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.321613333 UTC

[section ""data" . Foreign.Marshal.Array.peekArray1_closure" {
     Foreign.Marshal.Array.peekArray1_closure:
         const Foreign.Marshal.Array.peekArray1_info;
 },
 Foreign.Marshal.Array.peekArray1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Q5I,
                       label: Foreign.Marshal.Array.peekArray1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q5I: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Q5J; else goto c8Q5K;
       c8Q5J: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.peekArray1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Q5K: // global
           I64[Sp - 24] = block_c8Q5F_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Q5O; else goto c8Q5G;
       u8Q5O: // global
           call _c8Q5F(R1) args: 0, res: 0, upd: 0;
       c8Q5G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q5F() //  [R1]
         { info_tbl: [(c8Q5F,
                       label: block_c8Q5F_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q5F: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Array.$wpeekArray_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.322873348 UTC

[section ""data" . Foreign.Marshal.Array.peekArray_closure" {
     Foreign.Marshal.Array.peekArray_closure:
         const Foreign.Marshal.Array.peekArray_info;
 },
 Foreign.Marshal.Array.peekArray_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Q5T,
                       label: Foreign.Marshal.Array.peekArray_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q5T: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.peekArray1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.324267263 UTC

[section ""data" . Foreign.Marshal.Array.newArray2_closure" {
     Foreign.Marshal.Array.newArray2_closure:
         const Foreign.Marshal.Array.newArray2_info;
 },
 Foreign.Marshal.Array.newArray2_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Q62,
                       label: Foreign.Marshal.Array.newArray2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q62: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c8Q63; else goto c8Q64;
       c8Q63: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.newArray2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Q64: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           I64[Sp - 8] = 0;
           Sp = Sp - 32;
           call _c8Q65() args: 0, res: 0, upd: 0;
     }
 },
 _c8Q65() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q65: // global
           I64[Sp - 8] = block_c8Q68_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Q6w; else goto c8Q6a;
       u8Q6w: // global
           call _c8Q68(R1) args: 0, res: 0, upd: 0;
       c8Q6a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q68() //  [R1]
         { info_tbl: [(c8Q68,
                       label: block_c8Q68_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q68: // global
           if (R1 & 7 == 1) goto c8Q6g; else goto c8Q6l;
       c8Q6g: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Q6l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Q6o; else goto c8Q6n;
       c8Q6o: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Q6n: // global
           _s8PST::P64 = P64[R1 + 6];
           _s8PSU::P64 = P64[R1 + 14];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 32];
           I64[Sp] = block_c8Q6k_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_pppv_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = Hp - 7;
           P64[Sp - 8] = _s8PST::P64;
           P64[Sp + 24] = _s8PSU::P64;
           Sp = Sp - 32;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _c8Q6k() //  []
         { info_tbl: [(c8Q6k,
                       label: block_c8Q6k_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q6k: // global
           P64[Sp + 24] = P64[Sp + 24];
           I64[Sp + 32] = I64[Sp + 32] + 1;
           Sp = Sp + 8;
           call _c8Q65() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.32607982 UTC

[section ""data" . Foreign.Marshal.Array.pokeArray_closure" {
     Foreign.Marshal.Array.pokeArray_closure:
         const Foreign.Marshal.Array.pokeArray_info;
 },
 Foreign.Marshal.Array.pokeArray_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Q6C,
                       label: Foreign.Marshal.Array.pokeArray_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q6C: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.newArray2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.327467835 UTC

[section ""data" . Foreign.Marshal.Array.withArrayLen_closure" {
     Foreign.Marshal.Array.withArrayLen_closure:
         const Foreign.Marshal.Array.withArrayLen_info;
         const 0;
 },
 len_s8PT3_entry() //  [R1]
         { info_tbl: [(c8Q6P,
                       label: len_s8PT3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q6P: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Q6T; else goto c8Q6U;
       c8Q6T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Q6U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8Q6N_info;
           R3 = 0;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8Q6N() //  [R1]
         { info_tbl: [(c8Q6N,
                       label: block_c8Q6N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q6N: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Q6X; else goto c8Q6W;
       c8Q6X: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c8Q6W: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8PTa_entry() //  [R1, R2]
         { info_tbl: [(c8Q75,
                       label: sat_s8PTa_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q75: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Q76; else goto c8Q77;
       c8Q76: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Q77: // global
           I64[Sp - 32] = block_c8Q73_info;
           R4 = P64[R1 + 14];
           R3 = R2;
           _s8PT5::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 22];
           P64[Sp - 16] = P64[R1 + 30];
           P64[Sp - 8] = _s8PT5::P64;
           Sp = Sp - 32;
           call Foreign.Marshal.Array.newArray2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q73() //  []
         { info_tbl: [(c8Q73,
                       label: block_c8Q73_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q73: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.withArrayLen_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Q79,
                       label: Foreign.Marshal.Array.withArrayLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q79: // global
           _s8PT2::P64 = R4;
           _s8PT1::P64 = R3;
           _s8PT0::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8Q7a; else goto c8Q7b;
       c8Q7b: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Q7d; else goto c8Q7c;
       c8Q7d: // global
           HpAlloc = 64;
           goto c8Q7a;
       c8Q7a: // global
           R4 = _s8PT2::P64;
           R3 = _s8PT1::P64;
           R2 = _s8PT0::P64;
           R1 = Foreign.Marshal.Array.withArrayLen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Q7c: // global
           I64[Hp - 56] = len_s8PT3_info;
           P64[Hp - 40] = _s8PT1::P64;
           I64[Hp - 32] = sat_s8PTa_info;
           P64[Hp - 24] = _s8PT0::P64;
           P64[Hp - 16] = _s8PT1::P64;
           P64[Hp - 8] = _s8PT2::P64;
           _c8Q6J::P64 = Hp - 56;
           P64[Hp] = _c8Q6J::P64;
           R2 = _s8PT0::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _c8Q6J::P64;
           P64[Sp - 8] = Hp - 30;
           Sp = Sp - 24;
           call Foreign.Marshal.Array.allocaArray_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.330355689 UTC

[section ""data" . Foreign.Marshal.Array.withArray_closure" {
     Foreign.Marshal.Array.withArray_closure:
         const Foreign.Marshal.Array.withArray_info;
         const 0;
 },
 sat_s8PTl_entry() //  [R1, R2]
         { info_tbl: [(c8Q7p,
                       label: sat_s8PTl_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q7p: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Q7q; else goto c8Q7r;
       c8Q7q: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Q7r: // global
           I64[Sp - 24] = block_c8Q7n_info;
           R4 = P64[R1 + 14];
           R3 = R2;
           _s8PTg::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = P64[R1 + 22];
           P64[Sp - 8] = _s8PTg::P64;
           Sp = Sp - 24;
           call Foreign.Marshal.Array.newArray2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q7n() //  []
         { info_tbl: [(c8Q7n,
                       label: block_c8Q7n_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q7n: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8PTf_entry() //  [R1]
         { info_tbl: [(c8Q7z,
                       label: sat_s8PTf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q7z: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Q7D; else goto c8Q7E;
       c8Q7D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Q7E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8Q7x_info;
           R3 = 0;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8Q7x() //  [R1]
         { info_tbl: [(c8Q7x,
                       label: block_c8Q7x_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q7x: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Q7H; else goto c8Q7G;
       c8Q7H: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c8Q7G: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Array.withArray_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Q7I,
                       label: Foreign.Marshal.Array.withArray_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q7I: // global
           _s8PTd::P64 = R4;
           _s8PTc::P64 = R3;
           _s8PTb::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8Q7J; else goto c8Q7K;
       c8Q7K: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Q7M; else goto c8Q7L;
       c8Q7M: // global
           HpAlloc = 56;
           goto c8Q7J;
       c8Q7J: // global
           R4 = _s8PTd::P64;
           R3 = _s8PTc::P64;
           R2 = _s8PTb::P64;
           R1 = Foreign.Marshal.Array.withArray_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Q7L: // global
           I64[Hp - 48] = sat_s8PTl_info;
           P64[Hp - 40] = _s8PTb::P64;
           P64[Hp - 32] = _s8PTc::P64;
           P64[Hp - 24] = _s8PTd::P64;
           I64[Hp - 16] = sat_s8PTf_info;
           P64[Hp] = _s8PTc::P64;
           R2 = _s8PTb::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 46;
           Sp = Sp - 24;
           call Foreign.Marshal.Array.allocaArray_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.332946762 UTC

[section ""data" . Foreign.Marshal.Array.newArray1_closure" {
     Foreign.Marshal.Array.newArray1_closure:
         const Foreign.Marshal.Array.newArray1_info;
         const 0;
 },
 Foreign.Marshal.Array.newArray1_entry() //  [R2, R3]
         { info_tbl: [(c8Q7T,
                       label: Foreign.Marshal.Array.newArray1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q7T: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8Q7X; else goto c8Q7Y;
       c8Q7X: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.newArray1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Q7Y: // global
           I64[Sp - 24] = block_c8Q7R_info;
           _s8PTn::P64 = R3;
           R3 = 0;
           _s8PTm::P64 = R2;
           R2 = _s8PTn::P64;
           P64[Sp - 16] = _s8PTm::P64;
           P64[Sp - 8] = _s8PTn::P64;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q7R() //  [R1]
         { info_tbl: [(c8Q7R,
                       label: block_c8Q7R_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q7R: // global
           I64[Sp - 8] = block_c8Q7W_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = Foreign.Marshal.Array.mallocArray1_closure;
           I64[Sp] = R1;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8Q7W() //  [R1]
         { info_tbl: [(c8Q7W,
                       label: block_c8Q7W_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q7W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Q85; else goto c8Q84;
       c8Q85: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Q84: // global
           _s8PTm::P64 = P64[Sp + 16];
           _s8PTn::P64 = P64[Sp + 24];
           (_s8PTx::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[Sp + 8] * I64[R1 + 7]);
           if (_s8PTx::I64 == 0) goto c8Q8n; else goto c8Q8k;
       c8Q8n: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Q8k: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PTx::I64;
           I64[Sp + 16] = block_c8Q8i_info;
           R4 = _s8PTn::P64;
           _c8Q8h::P64 = Hp - 7;
           R3 = _c8Q8h::P64;
           R2 = _s8PTm::P64;
           P64[Sp + 24] = _c8Q8h::P64;
           Sp = Sp + 16;
           call Foreign.Marshal.Array.newArray2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q8i() //  []
         { info_tbl: [(c8Q8i,
                       label: block_c8Q8i_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q8i: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.334880513 UTC

[section ""data" . Foreign.Marshal.Array.newArray_closure" {
     Foreign.Marshal.Array.newArray_closure:
         const Foreign.Marshal.Array.newArray_info;
         const 0;
 },
 Foreign.Marshal.Array.newArray_entry() //  [R2, R3]
         { info_tbl: [(c8Q8s,
                       label: Foreign.Marshal.Array.newArray_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q8s: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.newArray1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.336520339 UTC

[section ""data" . Foreign.Marshal.Array.newArray4_closure" {
     Foreign.Marshal.Array.newArray4_closure:
         const Foreign.Marshal.Array.newArray4_info;
 },
 Foreign.Marshal.Array.newArray4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8Q8D,
                       label: Foreign.Marshal.Array.newArray4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q8D: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8Q8E; else goto c8Q8F;
       c8Q8E: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.newArray4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Q8F: // global
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = 0;
           Sp = Sp - 40;
           call _c8Q8M() args: 0, res: 0, upd: 0;
     }
 },
 _c8Q8M() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q8M: // global
           I64[Sp - 8] = block_c8Q8P_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Q9h; else goto c8Q8R;
       u8Q9h: // global
           call _c8Q8P(R1) args: 0, res: 0, upd: 0;
       c8Q8R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q8P() //  [R1]
         { info_tbl: [(c8Q8P,
                       label: block_c8Q8P_info
                       rep:StackRep [False, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q8P: // global
           _s8PTO::I64 = I64[Sp + 40];
           if (R1 & 7 == 1) goto c8Q8X; else goto c8Q92;
       c8Q8X: // global
           I64[Sp + 40] = _s8PTO::I64;
           Sp = Sp + 8;
           call _c8Q8H() args: 0, res: 0, upd: 0;
       c8Q92: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Q95; else goto c8Q94;
       c8Q95: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Q94: // global
           _s8PTR::P64 = P64[R1 + 6];
           _s8PTS::P64 = P64[R1 + 14];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8PTO::I64;
           I64[Sp] = block_c8Q91_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_pppv_info;
           P64[Sp - 24] = P64[Sp + 24];
           P64[Sp - 16] = Hp - 7;
           P64[Sp - 8] = _s8PTR::P64;
           P64[Sp + 32] = _s8PTS::P64;
           Sp = Sp - 32;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _c8Q8H() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q8H: // global
           Hp = Hp + 16;
           _s8PTJ::I64 = I64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto c8Q8L; else goto c8Q8K;
       c8Q8L: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c8Q8G_info;
           R1 = _s8PTJ::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8Q8K: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8PTJ::I64;
           R2 = P64[Sp];
           _s8PTE::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pppv_info;
           P64[Sp + 24] = Hp - 7;
           P64[Sp + 32] = _s8PTE::P64;
           Sp = Sp + 8;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _c8Q8G() //  [R1]
         { info_tbl: [(c8Q8G,
                       label: block_c8Q8G_info
                       rep:StackRep [False, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q8G: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _c8Q8H() args: 0, res: 0, upd: 0;
     }
 },
 _c8Q91() //  []
         { info_tbl: [(c8Q91,
                       label: block_c8Q91_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q91: // global
           P64[Sp + 32] = P64[Sp + 32];
           I64[Sp + 40] = I64[Sp + 40] + 1;
           Sp = Sp + 8;
           call _c8Q8M() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.338830108 UTC

[section ""data" . Foreign.Marshal.Array.pokeArray0_closure" {
     Foreign.Marshal.Array.pokeArray0_closure:
         const Foreign.Marshal.Array.pokeArray0_info;
 },
 Foreign.Marshal.Array.pokeArray0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8Q9o,
                       label: Foreign.Marshal.Array.pokeArray0_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q9o: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.newArray4_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.340608321 UTC

[section ""data" . Foreign.Marshal.Array.withArrayLen0_closure" {
     Foreign.Marshal.Array.withArrayLen0_closure:
         const Foreign.Marshal.Array.withArrayLen0_info;
         const 0;
 },
 len_s8PU2_entry() //  [R1]
         { info_tbl: [(c8Q9B,
                       label: len_s8PU2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q9B: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Q9F; else goto c8Q9G;
       c8Q9F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Q9G: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8Q9z_info;
           R3 = 0;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8Q9z() //  [R1]
         { info_tbl: [(c8Q9z,
                       label: block_c8Q9z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q9z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Q9J; else goto c8Q9I;
       c8Q9J: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c8Q9I: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8PUd_entry() //  [R1, R2]
         { info_tbl: [(c8Q9R,
                       label: sat_s8PUd_info
                       rep:HeapRep 5 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q9R: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Q9S; else goto c8Q9T;
       c8Q9S: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Q9T: // global
           I64[Sp - 32] = block_c8Q9P_info;
           R5 = P64[R1 + 22];
           R4 = R2;
           R3 = P64[R1 + 14];
           _s8PU8::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 30];
           P64[Sp - 16] = P64[R1 + 38];
           P64[Sp - 8] = _s8PU8::P64;
           Sp = Sp - 32;
           call Foreign.Marshal.Array.newArray4_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Q9P() //  []
         { info_tbl: [(c8Q9P,
                       label: block_c8Q9P_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q9P: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8PU7_entry() //  [R1]
         { info_tbl: [(c8Qa2,
                       label: sat_s8PU7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qa2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Qa9; else goto c8Qaa;
       c8Qa9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Qaa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8Q9Z_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Qae; else goto c8Qa0;
       u8Qae: // global
           call _c8Q9Z(R1) args: 0, res: 0, upd: 0;
       c8Qa0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8Q9Z() //  [R1]
         { info_tbl: [(c8Q9Z,
                       label: block_c8Q9Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Q9Z: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Qad; else goto c8Qac;
       c8Qad: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8Qac: // global
           _s8PU6::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8PU6::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Array.withArrayLen0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8Qaf,
                       label: Foreign.Marshal.Array.withArrayLen0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qaf: // global
           _s8PU1::P64 = R5;
           _s8PU0::P64 = R4;
           _s8PTZ::P64 = R3;
           _s8PTY::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8Qag; else goto c8Qah;
       c8Qah: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c8Qaj; else goto c8Qai;
       c8Qaj: // global
           HpAlloc = 96;
           goto c8Qag;
       c8Qag: // global
           R5 = _s8PU1::P64;
           R4 = _s8PU0::P64;
           R3 = _s8PTZ::P64;
           R2 = _s8PTY::P64;
           R1 = Foreign.Marshal.Array.withArrayLen0_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Qai: // global
           I64[Hp - 88] = len_s8PU2_info;
           P64[Hp - 72] = _s8PU0::P64;
           I64[Hp - 64] = sat_s8PUd_info;
           P64[Hp - 56] = _s8PTY::P64;
           P64[Hp - 48] = _s8PTZ::P64;
           P64[Hp - 40] = _s8PU0::P64;
           P64[Hp - 32] = _s8PU1::P64;
           _c8Q9v::P64 = Hp - 88;
           P64[Hp - 24] = _c8Q9v::P64;
           I64[Hp - 16] = sat_s8PU7_info;
           P64[Hp] = _c8Q9v::P64;
           R2 = _s8PTY::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 62;
           Sp = Sp - 24;
           call Foreign.Marshal.Array.allocaArray_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.343917493 UTC

[section ""data" . Foreign.Marshal.Array.withArray0_closure" {
     Foreign.Marshal.Array.withArray0_closure:
         const Foreign.Marshal.Array.withArray0_info;
         const 0;
 },
 sat_s8PUj_entry() //  [R1]
         { info_tbl: [(c8Qat,
                       label: sat_s8PUj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qat: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.withArray0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8Qaw,
                       label: Foreign.Marshal.Array.withArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qaw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QaA; else goto c8Qaz;
       c8QaA: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.withArray0_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Qaz: // global
           I64[Hp - 8] = sat_s8PUj_info;
           P64[Hp] = R5;
           R5 = Hp - 7;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.withArrayLen0_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.345864392 UTC

[section ""data" . Foreign.Marshal.Array.newArray3_closure" {
     Foreign.Marshal.Array.newArray3_closure:
         const Foreign.Marshal.Array.newArray3_info;
         const 0;
 },
 Foreign.Marshal.Array.newArray3_entry() //  [R2, R3, R4]
         { info_tbl: [(c8QaH,
                       label: Foreign.Marshal.Array.newArray3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QaH: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8QaL; else goto c8QaM;
       c8QaL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.newArray3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QaM: // global
           I64[Sp - 32] = block_c8QaF_info;
           _s8PUl::P64 = R3;
           R3 = 0;
           _s8PUk::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _s8PUk::P64;
           P64[Sp - 16] = _s8PUl::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8QaF() //  [R1]
         { info_tbl: [(c8QaF,
                       label: block_c8QaF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QaF: // global
           I64[Sp - 8] = block_c8QaK_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = Foreign.Marshal.Array.mallocArray1_closure;
           I64[Sp] = R1;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8QaK() //  [R1]
         { info_tbl: [(c8QaK,
                       label: block_c8QaK_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QaK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QaT; else goto c8QaS;
       c8QaT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8QaS: // global
           _s8PUk::P64 = P64[Sp + 16];
           _s8PUl::P64 = P64[Sp + 24];
           _s8PUm::P64 = P64[Sp + 32];
           (_s8PUx::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc((I64[Sp + 8] + 1) * I64[R1 + 7]);
           if (_s8PUx::I64 == 0) goto c8Qbe; else goto c8Qbb;
       c8Qbe: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Qbb: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PUx::I64;
           I64[Sp + 24] = block_c8Qb9_info;
           R5 = _s8PUm::P64;
           _c8Qb8::P64 = Hp - 7;
           R4 = _c8Qb8::P64;
           R3 = _s8PUl::P64;
           R2 = _s8PUk::P64;
           P64[Sp + 32] = _c8Qb8::P64;
           Sp = Sp + 24;
           call Foreign.Marshal.Array.newArray4_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qb9() //  []
         { info_tbl: [(c8Qb9,
                       label: block_c8Qb9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qb9: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.348994375 UTC

[section ""data" . Foreign.Marshal.Array.newArray0_closure" {
     Foreign.Marshal.Array.newArray0_closure:
         const Foreign.Marshal.Array.newArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.newArray0_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Qbj,
                       label: Foreign.Marshal.Array.newArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qbj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.newArray3_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.349783805 UTC

[section ""data" . lvl22_r8PPB_closure" {
     lvl22_r8PPB_closure:
         const GHC.Types.I#_con_info;
         const 242;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.350407627 UTC

[section ""data" . lvl23_r8PPC_closure" {
     lvl23_r8PPC_closure:
         const GHC.Types.I#_con_info;
         const 21;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.351000932 UTC

[section ""data" . lvl24_r8PPD_closure" {
     lvl24_r8PPD_closure:
         const GHC.Types.I#_con_info;
         const 30;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.351601783 UTC

[section ""data" . lvl25_r8PPE_closure" {
     lvl25_r8PPE_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl22_r8PPB_closure+1;
         const lvl23_r8PPC_closure+1;
         const lvl22_r8PPB_closure+1;
         const lvl24_r8PPD_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.352276614 UTC

[section ""data" . lvl26_r8PPF_closure" {
     lvl26_r8PPF_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl25_r8PPE_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.353140675 UTC

[section ""data" . Foreign.Marshal.Array.copyArray1_closure" {
     Foreign.Marshal.Array.copyArray1_closure:
         const Foreign.Marshal.Array.copyArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.copyArray1_entry() //  [R1]
         { info_tbl: [(c8Qbs,
                       label: Foreign.Marshal.Array.copyArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qbs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Qbt; else goto c8Qbu;
       c8Qbt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Qbu: // global
           (_c8Qbp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Qbp::I64 == 0) goto c8Qbr; else goto c8Qbq;
       c8Qbr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Qbq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Qbp::I64;
           R2 = lvl26_r8PPF_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.354938169 UTC

[section ""data" . Foreign.Marshal.Array.copyArray_closure" {
     Foreign.Marshal.Array.copyArray_closure:
         const Foreign.Marshal.Array.copyArray_info;
         const 0;
 },
 lvl33_s8PUE_entry() //  [R1]
         { info_tbl: [(c8QbD,
                       label: lvl33_s8PUE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QbD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QbE; else goto c8QbF;
       c8QbE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QbF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.copyArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PUX_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c8QbO,
                       label: sat_s8PUX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QbO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Qc2; else goto c8Qc3;
       c8Qc2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Qc3: // global
           I64[Sp - 32] = block_c8QbL_info;
           _s8PUE::P64 = P64[R1 + 4];
           R1 = R2;
           P64[Sp - 24] = _s8PUE::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8Qcn; else goto c8QbM;
       u8Qcn: // global
           call _c8QbL(R1) args: 0, res: 0, upd: 0;
       c8QbM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QbL() //  [R1]
         { info_tbl: [(c8QbL,
                       label: block_c8QbL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QbL: // global
           I64[Sp] = block_c8QbR_info;
           _s8PUK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8PUK::I64;
           if (R1 & 7 != 0) goto u8Qcm; else goto c8QbS;
       u8Qcm: // global
           call _c8QbR(R1) args: 0, res: 0, upd: 0;
       c8QbS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QbR() //  [R1]
         { info_tbl: [(c8QbR,
                       label: block_c8QbR_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QbR: // global
           I64[Sp] = block_c8QbW_info;
           _s8PUM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s8PUM::I64;
           if (R1 & 7 != 0) goto u8Qco; else goto c8QbX;
       u8Qco: // global
           call _c8QbW(R1) args: 0, res: 0, upd: 0;
       c8QbX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QbW() //  [R1]
         { info_tbl: [(c8QbW,
                       label: block_c8QbW_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QbW: // global
           I64[Sp] = block_c8Qc1_info;
           _s8PUO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PUO::I64;
           if (R1 & 7 != 0) goto u8Qcp; else goto c8Qc7;
       u8Qcp: // global
           call _c8Qc1(R1) args: 0, res: 0, upd: 0;
       c8Qc7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qc1() //  [R1]
         { info_tbl: [(c8Qc1,
                       label: block_c8Qc1_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qc1: // global
           (_s8PUW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[Sp + 16], I64[Sp + 24], I64[Sp + 8] * I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.copyArray_entry() //  [R2]
         { info_tbl: [(c8Qcq,
                       label: Foreign.Marshal.Array.copyArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qcq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Qcu; else goto c8Qct;
       c8Qcu: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.copyArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Qct: // global
           I64[Hp - 32] = lvl33_s8PUE_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8PUX_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.35740467 UTC

[section ""data" . lvl27_r8PPG_closure" {
     lvl27_r8PPG_closure:
         const GHC.Types.I#_con_info;
         const 251;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.358038686 UTC

[section ""data" . lvl28_r8PPH_closure" {
     lvl28_r8PPH_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl27_r8PPG_closure+1;
         const lvl23_r8PPC_closure+1;
         const lvl27_r8PPG_closure+1;
         const lvl24_r8PPD_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.35871015 UTC

[section ""data" . lvl29_r8PPI_closure" {
     lvl29_r8PPI_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl28_r8PPH_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.359558493 UTC

[section ""data" . Foreign.Marshal.Array.moveArray1_closure" {
     Foreign.Marshal.Array.moveArray1_closure:
         const Foreign.Marshal.Array.moveArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.moveArray1_entry() //  [R1]
         { info_tbl: [(c8QcB,
                       label: Foreign.Marshal.Array.moveArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QcB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8QcC; else goto c8QcD;
       c8QcC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QcD: // global
           (_c8Qcy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Qcy::I64 == 0) goto c8QcA; else goto c8Qcz;
       c8QcA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Qcz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Qcy::I64;
           R2 = lvl29_r8PPI_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.361456548 UTC

[section ""data" . Foreign.Marshal.Array.moveArray_closure" {
     Foreign.Marshal.Array.moveArray_closure:
         const Foreign.Marshal.Array.moveArray_info;
         const 0;
 },
 lvl33_s8PUZ_entry() //  [R1]
         { info_tbl: [(c8QcM,
                       label: lvl33_s8PUZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QcM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QcN; else goto c8QcO;
       c8QcN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QcO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.moveArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PVi_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c8QcX,
                       label: sat_s8PVi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QcX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Qdb; else goto c8Qdc;
       c8Qdb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Qdc: // global
           I64[Sp - 32] = block_c8QcU_info;
           _s8PUZ::P64 = P64[R1 + 4];
           R1 = R2;
           P64[Sp - 24] = _s8PUZ::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8Qdw; else goto c8QcV;
       u8Qdw: // global
           call _c8QcU(R1) args: 0, res: 0, upd: 0;
       c8QcV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QcU() //  [R1]
         { info_tbl: [(c8QcU,
                       label: block_c8QcU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QcU: // global
           I64[Sp] = block_c8Qd0_info;
           _s8PV5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8PV5::I64;
           if (R1 & 7 != 0) goto u8Qdv; else goto c8Qd1;
       u8Qdv: // global
           call _c8Qd0(R1) args: 0, res: 0, upd: 0;
       c8Qd1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qd0() //  [R1]
         { info_tbl: [(c8Qd0,
                       label: block_c8Qd0_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qd0: // global
           I64[Sp] = block_c8Qd5_info;
           _s8PV7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s8PV7::I64;
           if (R1 & 7 != 0) goto u8Qdx; else goto c8Qd6;
       u8Qdx: // global
           call _c8Qd5(R1) args: 0, res: 0, upd: 0;
       c8Qd6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qd5() //  [R1]
         { info_tbl: [(c8Qd5,
                       label: block_c8Qd5_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qd5: // global
           I64[Sp] = block_c8Qda_info;
           _s8PV9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PV9::I64;
           if (R1 & 7 != 0) goto u8Qdy; else goto c8Qdg;
       u8Qdy: // global
           call _c8Qda(R1) args: 0, res: 0, upd: 0;
       c8Qdg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qda() //  [R1]
         { info_tbl: [(c8Qda,
                       label: block_c8Qda_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qda: // global
           (_s8PVh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(I64[Sp + 16], I64[Sp + 24], I64[Sp + 8] * I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.moveArray_entry() //  [R2]
         { info_tbl: [(c8Qdz,
                       label: Foreign.Marshal.Array.moveArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qdz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8QdD; else goto c8QdC;
       c8QdD: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.moveArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8QdC: // global
           I64[Hp - 32] = lvl33_s8PUZ_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8PVi_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.364757785 UTC

[section ""data" . Foreign.Marshal.Array.lengthArray1_closure" {
     Foreign.Marshal.Array.lengthArray1_closure:
         const Foreign.Marshal.Array.lengthArray1_info;
 },
 sat_s8PVy_entry() //  [R1]
         { info_tbl: [(c8Qe0,
                       label: sat_s8PVy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qe0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Qe7; else goto c8Qe8;
       c8Qe7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Qe8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8QdX_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Qec; else goto c8QdY;
       u8Qec: // global
           call _c8QdX(R1) args: 0, res: 0, upd: 0;
       c8QdY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8QdX() //  [R1]
         { info_tbl: [(c8QdX,
                       label: block_c8QdX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QdX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Qeb; else goto c8Qea;
       c8Qeb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8Qea: // global
           _s8PVx::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8PVx::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Array.lengthArray1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8Qed,
                       label: Foreign.Marshal.Array.lengthArray1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qed: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c8Qee; else goto c8Qef;
       c8Qee: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.lengthArray1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Qef: // global
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = Foreign.Marshal.Array.lengthArray2_closure+1;
           Sp = Sp - 40;
           call _c8QdL() args: 0, res: 0, upd: 0;
     }
 },
 _c8QdL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QdL: // global
           I64[Sp - 8] = block_c8QdN_info;
           R2 = P64[Sp];
           I64[Sp - 32] = stg_ap_ppv_info;
           P64[Sp - 24] = P64[Sp + 24];
           P64[Sp - 16] = P64[Sp + 32];
           Sp = Sp - 32;
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8QdN() //  [R1]
         { info_tbl: [(c8QdN,
                       label: block_c8QdN_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QdN: // global
           I64[Sp] = block_c8QdP_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R1;
           P64[Sp - 8] = P64[Sp + 24];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8QdP() //  [R1]
         { info_tbl: [(c8QdP,
                       label: block_c8QdP_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QdP: // global
           _s8PVp::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto c8Qej; else goto c8Qeq;
       c8Qej: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Qem; else goto c8Qel;
       c8Qem: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Qel: // global
           I64[Hp - 16] = sat_s8PVy_info;
           P64[Hp] = _s8PVp::P64;
           P64[Sp + 40] = Hp - 16;
           Sp = Sp + 8;
           call _c8QdL() args: 0, res: 0, upd: 0;
       c8Qeq: // global
           R1 = _s8PVp::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.36715182 UTC

[section ""data" . Foreign.Marshal.Array.lengthArray0_closure" {
     Foreign.Marshal.Array.lengthArray0_closure:
         const Foreign.Marshal.Array.lengthArray0_info;
 },
 Foreign.Marshal.Array.lengthArray0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8QeA,
                       label: Foreign.Marshal.Array.lengthArray0_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QeA: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.lengthArray1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.368246815 UTC

[section ""data" . Foreign.Marshal.Array.peekArray2_closure" {
     Foreign.Marshal.Array.peekArray2_closure:
         const Foreign.Marshal.Array.peekArray2_info;
 },
 Foreign.Marshal.Array.peekArray2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8QeJ,
                       label: Foreign.Marshal.Array.peekArray2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QeJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8QeK; else goto c8QeL;
       c8QeK: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.peekArray2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QeL: // global
           I64[Sp - 24] = block_c8QeH_info;
           _s8PVC::P64 = R5;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           _s8PVz::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s8PVz::P64;
           P64[Sp - 8] = _s8PVC::P64;
           Sp = Sp - 24;
           call Foreign.Marshal.Array.lengthArray1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8QeH() //  [R1]
         { info_tbl: [(c8QeH,
                       label: block_c8QeH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QeH: // global
           R4 = P64[Sp + 16];
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Array.peekArray1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.373741537 UTC

[section ""data" . Foreign.Marshal.Array.peekArray0_closure" {
     Foreign.Marshal.Array.peekArray0_closure:
         const Foreign.Marshal.Array.peekArray0_info;
 },
 Foreign.Marshal.Array.peekArray0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8QeR,
                       label: Foreign.Marshal.Array.peekArray0_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QeR: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.peekArray2_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.375046171 UTC

[section ""data" . lvl30_r8PPJ_closure" {
     lvl30_r8PPJ_closure:
         const GHC.Types.I#_con_info;
         const 276;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.375976475 UTC

[section ""data" . lvl31_r8PPK_closure" {
     lvl31_r8PPK_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl30_r8PPJ_closure+1;
         const lvl7_r8PPm_closure+1;
         const lvl30_r8PPJ_closure+1;
         const lvl8_r8PPn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.378644359 UTC

[section ""data" . lvl32_r8PPL_closure" {
     lvl32_r8PPL_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl31_r8PPK_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.379605366 UTC

[section ""data" . Foreign.Marshal.Array.advancePtr1_closure" {
     Foreign.Marshal.Array.advancePtr1_closure:
         const Foreign.Marshal.Array.advancePtr1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.advancePtr1_entry() //  [R1]
         { info_tbl: [(c8Qf0,
                       label: Foreign.Marshal.Array.advancePtr1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qf0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Qf1; else goto c8Qf2;
       c8Qf1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Qf2: // global
           (_c8QeX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8QeX::I64 == 0) goto c8QeZ; else goto c8QeY;
       c8QeZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8QeY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8QeX::I64;
           R2 = lvl32_r8PPL_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.381797502 UTC

[section ""data" . Foreign.Marshal.Array.advancePtr_closure" {
     Foreign.Marshal.Array.advancePtr_closure:
         const Foreign.Marshal.Array.advancePtr_info;
         const 0;
 },
 lvl33_s8PVI_entry() //  [R1]
         { info_tbl: [(c8Qfb,
                       label: lvl33_s8PVI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qfb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Qfc; else goto c8Qfd;
       c8Qfc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Qfd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.advancePtr1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PVT_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Qfm,
                       label: sat_s8PVT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qfm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8QfG; else goto c8QfH;
       c8QfG: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QfH: // global
           I64[Sp - 24] = block_c8Qfj_info;
           _s8PVI::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s8PVI::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8QfO; else goto c8Qfk;
       u8QfO: // global
           call _c8Qfj(R1) args: 0, res: 0, upd: 0;
       c8Qfk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qfj() //  [R1]
         { info_tbl: [(c8Qfj,
                       label: block_c8Qfj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qfj: // global
           I64[Sp] = block_c8Qfp_info;
           _s8PVM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8PVM::I64;
           if (R1 & 7 != 0) goto u8QfN; else goto c8Qfq;
       u8QfN: // global
           call _c8Qfp(R1) args: 0, res: 0, upd: 0;
       c8Qfq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qfp() //  [R1]
         { info_tbl: [(c8Qfp,
                       label: block_c8Qfp_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qfp: // global
           I64[Sp] = block_c8Qfu_info;
           _s8PVO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PVO::I64;
           if (R1 & 7 != 0) goto u8QfP; else goto c8Qfv;
       u8QfP: // global
           call _c8Qfu(R1) args: 0, res: 0, upd: 0;
       c8Qfv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qfu() //  [R1]
         { info_tbl: [(c8Qfu,
                       label: block_c8Qfu_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qfu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QfM; else goto c8QfL;
       c8QfM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8QfL: // global
           _s8PVS::I64 = I64[Sp + 16] + I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PVS::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.advancePtr_entry() //  [R2]
         { info_tbl: [(c8QfQ,
                       label: Foreign.Marshal.Array.advancePtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QfQ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8QfU; else goto c8QfT;
       c8QfU: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.advancePtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8QfT: // global
           I64[Hp - 32] = lvl33_s8PVI_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8PVT_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.384739787 UTC

[section ""data" . Foreign.Marshal.Array.$trModule3_closure" {
     Foreign.Marshal.Array.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Array.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.385496533 UTC

[section ""data" . Foreign.Marshal.Array.$trModule1_closure" {
     Foreign.Marshal.Array.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Array.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.386307312 UTC

[section ""data" . Foreign.Marshal.Array.$trModule_closure" {
     Foreign.Marshal.Array.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Marshal.Array.$trModule3_closure+1;
         const Foreign.Marshal.Array.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.38708803 UTC

[section ""relreadonly" . S8PWD_srt" {
     S8PWD_srt:
         const GHC.Err.undefined_closure;
         const lvl10_r8PPp_closure;
         const Foreign.Marshal.Array.mallocArray1_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Array.mallocArray_closure;
         const Foreign.Marshal.Array.$wmallocArray0_closure;
         const Foreign.Marshal.Array.mallocArray2_closure;
         const lvl13_r8PPs_closure;
         const Foreign.Marshal.Array.callocArray1_closure;
         const Foreign.Marshal.Alloc.calloc1_closure;
         const Foreign.Marshal.Array.callocArray_closure;
         const Foreign.Marshal.Array.$wcallocArray0_closure;
         const Foreign.Marshal.Array.callocArray2_closure;
         const lvl16_r8PPv_closure;
         const Foreign.Marshal.Array.allocaArray1_closure;
         const Foreign.Marshal.Array.allocaArray_closure;
         const Foreign.Marshal.Array.allocaArray0_closure;
         const lvl21_r8PPA_closure;
         const Foreign.Marshal.Array.reallocArray1_closure;
         const Foreign.Marshal.Alloc.realloc2_closure;
         const Foreign.Marshal.Array.reallocArray_closure;
         const Foreign.Marshal.Array.$wreallocArray0_closure;
         const Foreign.Marshal.Array.reallocArray2_closure;
         const Foreign.Marshal.Array.withArrayLen_closure;
         const Foreign.Marshal.Array.withArray_closure;
         const Foreign.Marshal.Array.newArray1_closure;
         const Foreign.Marshal.Array.withArrayLen0_closure;
         const Foreign.Marshal.Array.withArray0_closure;
         const Foreign.Marshal.Array.newArray3_closure;
         const lvl26_r8PPF_closure;
         const Foreign.Marshal.Array.copyArray1_closure;
         const Foreign.Marshal.Array.copyArray_closure;
         const lvl29_r8PPI_closure;
         const GHC.Err.undefined_closure;
         const Foreign.Marshal.Array.moveArray1_closure;
         const Foreign.Marshal.Array.moveArray_closure;
         const lvl32_r8PPL_closure;
         const Foreign.Marshal.Array.advancePtr1_closure;
         const Foreign.Marshal.Array.advancePtr_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.388119575 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:59.388863002 UTC

[section ""cstring" . lvl_r8PPf_bytes" {
     lvl_r8PPf_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.389903591 UTC

[section ""data" . lvl1_r8PPg_closure" {
     lvl1_r8PPg_closure:
         const lvl1_r8PPg_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r8PPg_entry() //  [R1]
         { info_tbl: [(c8Qg1,
                       label: lvl1_r8PPg_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qg1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Qg2; else goto c8Qg3;
       c8Qg2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Qg3: // global
           (_c8QfY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8QfY::I64 == 0) goto c8Qg0; else goto c8QfZ;
       c8Qg0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8QfZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8QfY::I64;
           R2 = lvl_r8PPf_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.391267528 UTC

[section ""cstring" . Foreign.Marshal.Array.$trModule4_bytes" {
     Foreign.Marshal.Array.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.392322352 UTC

[section ""data" . lvl2_r8PPh_closure" {
     lvl2_r8PPh_closure:
         const lvl2_r8PPh_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r8PPh_entry() //  [R1]
         { info_tbl: [(c8Qga,
                       label: lvl2_r8PPh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qga: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Qgb; else goto c8Qgc;
       c8Qgb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Qgc: // global
           (_c8Qg7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Qg7::I64 == 0) goto c8Qg9; else goto c8Qg8;
       c8Qg9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Qg8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Qg7::I64;
           R2 = Foreign.Marshal.Array.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.393682958 UTC

[section ""cstring" . Foreign.Marshal.Array.$trModule2_bytes" {
     Foreign.Marshal.Array.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,65,114,114,97,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.394794261 UTC

[section ""data" . lvl3_r8PPi_closure" {
     lvl3_r8PPi_closure:
         const lvl3_r8PPi_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r8PPi_entry() //  [R1]
         { info_tbl: [(c8Qgj,
                       label: lvl3_r8PPi_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qgj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Qgk; else goto c8Qgl;
       c8Qgk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Qgl: // global
           (_c8Qgg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Qgg::I64 == 0) goto c8Qgi; else goto c8Qgh;
       c8Qgi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Qgh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Qgg::I64;
           R2 = Foreign.Marshal.Array.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.39609359 UTC

[section ""cstring" . lvl4_r8PPj_bytes" {
     lvl4_r8PPj_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,77,97,114,115,104,97,108,47,65,114,114,97,121,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.397081294 UTC

[section ""data" . lvl5_r8PPk_closure" {
     lvl5_r8PPk_closure:
         const lvl5_r8PPk_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r8PPk_entry() //  [R1]
         { info_tbl: [(c8Qgs,
                       label: lvl5_r8PPk_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qgs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Qgt; else goto c8Qgu;
       c8Qgt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Qgu: // global
           (_c8Qgp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Qgp::I64 == 0) goto c8Qgr; else goto c8Qgq;
       c8Qgr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Qgq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Qgp::I64;
           R2 = lvl4_r8PPj_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.398390078 UTC

[section ""data" . lvl6_r8PPl_closure" {
     lvl6_r8PPl_closure:
         const GHC.Types.I#_con_info;
         const 86;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.39920378 UTC

[section ""data" . lvl7_r8PPm_closure" {
     lvl7_r8PPm_closure:
         const GHC.Types.I#_con_info;
         const 25;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.399987706 UTC

[section ""data" . lvl8_r8PPn_closure" {
     lvl8_r8PPn_closure:
         const GHC.Types.I#_con_info;
         const 34;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.400732414 UTC

[section ""data" . lvl9_r8PPo_closure" {
     lvl9_r8PPo_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl6_r8PPl_closure+1;
         const lvl7_r8PPm_closure+1;
         const lvl6_r8PPl_closure+1;
         const lvl8_r8PPn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.401600898 UTC

[section ""data" . lvl10_r8PPp_closure" {
     lvl10_r8PPp_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl9_r8PPo_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.402690164 UTC

[section ""data" . Foreign.Marshal.Array.mallocArray1_closure" {
     Foreign.Marshal.Array.mallocArray1_closure:
         const Foreign.Marshal.Array.mallocArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.mallocArray1_entry() //  [R1]
         { info_tbl: [(c8QgB,
                       label: Foreign.Marshal.Array.mallocArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QgB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8QgC; else goto c8QgD;
       c8QgC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QgD: // global
           (_c8Qgy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Qgy::I64 == 0) goto c8QgA; else goto c8Qgz;
       c8QgA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Qgz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Qgy::I64;
           R2 = lvl10_r8PPp_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.405192584 UTC

[section ""data" . Foreign.Marshal.Array.mallocArray_closure" {
     Foreign.Marshal.Array.mallocArray_closure:
         const Foreign.Marshal.Array.mallocArray_info;
         const 0;
 },
 lvl33_s8PPO_entry() //  [R1]
         { info_tbl: [(c8QgM,
                       label: lvl33_s8PPO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QgM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QgN; else goto c8QgO;
       c8QgN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QgO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.mallocArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PQ3_entry() //  [R1, R2]
         { info_tbl: [(c8QgX,
                       label: sat_s8PQ3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QgX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Qh1; else goto c8Qh2;
       c8Qh1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Qh2: // global
           I64[Sp - 16] = block_c8QgU_info;
           _s8PPO::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _s8PPO::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Qhr; else goto c8QgV;
       u8Qhr: // global
           call _c8QgU(R1) args: 0, res: 0, upd: 0;
       c8QgV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QgU() //  [R1]
         { info_tbl: [(c8QgU,
                       label: block_c8QgU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QgU: // global
           I64[Sp] = block_c8Qh0_info;
           _s8PPS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PPS::I64;
           if (R1 & 7 != 0) goto u8Qhq; else goto c8Qh4;
       u8Qhq: // global
           call _c8Qh0(R1) args: 0, res: 0, upd: 0;
       c8Qh4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qh0() //  [R1]
         { info_tbl: [(c8Qh0,
                       label: block_c8Qh0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qh0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Qha; else goto c8Qh9;
       c8Qha: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Qh9: // global
           (_s8PQ0::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[Sp + 8] * I64[R1 + 7]);
           if (_s8PQ0::I64 == 0) goto c8Qhp; else goto c8Qho;
       c8Qhp: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Qho: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PQ0::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.mallocArray_entry() //  [R2]
         { info_tbl: [(c8Qhs,
                       label: Foreign.Marshal.Array.mallocArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qhs: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Qhw; else goto c8Qhv;
       c8Qhw: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.mallocArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Qhv: // global
           I64[Hp - 32] = lvl33_s8PPO_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8PQ3_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.408336658 UTC

[section ""data" . Foreign.Marshal.Array.$wmallocArray0_closure" {
     Foreign.Marshal.Array.$wmallocArray0_closure:
         const Foreign.Marshal.Array.$wmallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.$wmallocArray0_entry() //  [R2, R3]
         { info_tbl: [(c8QhD,
                       label: Foreign.Marshal.Array.$wmallocArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QhD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QhE; else goto c8QhF;
       c8QhE: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.$wmallocArray0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QhF: // global
           I64[Sp - 16] = block_c8QhB_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.mallocArray1_closure;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8QhB() //  [R1]
         { info_tbl: [(c8QhB,
                       label: block_c8QhB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QhB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QhK; else goto c8QhJ;
       c8QhK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8QhJ: // global
           (_s8PQf::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc((I64[Sp + 8] + 1) * I64[R1 + 7]);
           if (_s8PQf::I64 == 0) goto c8Qi2; else goto c8Qi1;
       c8Qi2: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Qi1: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PQf::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.411104179 UTC

[section ""data" . Foreign.Marshal.Array.mallocArray2_closure" {
     Foreign.Marshal.Array.mallocArray2_closure:
         const Foreign.Marshal.Array.mallocArray2_info;
         const 0;
 },
 Foreign.Marshal.Array.mallocArray2_entry() //  [R2, R3]
         { info_tbl: [(c8Qia,
                       label: Foreign.Marshal.Array.mallocArray2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qia: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Qib; else goto c8Qic;
       c8Qib: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.mallocArray2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Qic: // global
           I64[Sp - 16] = block_c8Qi7_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Qig; else goto c8Qi8;
       u8Qig: // global
           call _c8Qi7(R1) args: 0, res: 0, upd: 0;
       c8Qi8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qi7() //  [R1]
         { info_tbl: [(c8Qi7,
                       label: block_c8Qi7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qi7: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.Marshal.Array.$wmallocArray0_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.412305909 UTC

[section ""data" . Foreign.Marshal.Array.mallocArray0_closure" {
     Foreign.Marshal.Array.mallocArray0_closure:
         const Foreign.Marshal.Array.mallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.mallocArray0_entry() //  [R2, R3]
         { info_tbl: [(c8Qil,
                       label: Foreign.Marshal.Array.mallocArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qil: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.mallocArray2_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.413111462 UTC

[section ""data" . lvl11_r8PPq_closure" {
     lvl11_r8PPq_closure:
         const GHC.Types.I#_con_info;
         const 100;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.41406228 UTC

[section ""data" . lvl12_r8PPr_closure" {
     lvl12_r8PPr_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl11_r8PPq_closure+1;
         const lvl7_r8PPm_closure+1;
         const lvl11_r8PPq_closure+1;
         const lvl8_r8PPn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.414674594 UTC

[section ""data" . lvl13_r8PPs_closure" {
     lvl13_r8PPs_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl12_r8PPr_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.415460681 UTC

[section ""data" . Foreign.Marshal.Array.callocArray1_closure" {
     Foreign.Marshal.Array.callocArray1_closure:
         const Foreign.Marshal.Array.callocArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.callocArray1_entry() //  [R1]
         { info_tbl: [(c8Qiu,
                       label: Foreign.Marshal.Array.callocArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qiu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Qiv; else goto c8Qiw;
       c8Qiv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Qiw: // global
           (_c8Qir::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Qir::I64 == 0) goto c8Qit; else goto c8Qis;
       c8Qit: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Qis: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Qir::I64;
           R2 = lvl13_r8PPs_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.417231359 UTC

[section ""data" . Foreign.Marshal.Array.callocArray_closure" {
     Foreign.Marshal.Array.callocArray_closure:
         const Foreign.Marshal.Array.callocArray_info;
         const 0;
 },
 lvl33_s8PQo_entry() //  [R1]
         { info_tbl: [(c8QiF,
                       label: lvl33_s8PQo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QiF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QiG; else goto c8QiH;
       c8QiG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QiH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.callocArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PQD_entry() //  [R1, R2]
         { info_tbl: [(c8QiQ,
                       label: sat_s8PQD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QiQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8QiU; else goto c8QiV;
       c8QiU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8QiV: // global
           I64[Sp - 16] = block_c8QiN_info;
           _s8PQo::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _s8PQo::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Qjl; else goto c8QiO;
       u8Qjl: // global
           call _c8QiN(R1) args: 0, res: 0, upd: 0;
       c8QiO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QiN() //  [R1]
         { info_tbl: [(c8QiN,
                       label: block_c8QiN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QiN: // global
           I64[Sp] = block_c8QiT_info;
           _s8PQs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PQs::I64;
           if (R1 & 7 != 0) goto u8Qjk; else goto c8QiX;
       u8Qjk: // global
           call _c8QiT(R1) args: 0, res: 0, upd: 0;
       c8QiX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QiT() //  [R1]
         { info_tbl: [(c8QiT,
                       label: block_c8QiT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QiT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Qj3; else goto c8Qj2;
       c8Qj3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Qj2: // global
           (_s8PQA::I64) = call "ccall" arg hints:  [,]  result hints:  [PtrHint] calloc(1, I64[Sp + 8] * I64[R1 + 7]);
           if (_s8PQA::I64 == 0) goto c8Qjj; else goto c8Qji;
       c8Qjj: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.calloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Qji: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PQA::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.callocArray_entry() //  [R2]
         { info_tbl: [(c8Qjm,
                       label: Foreign.Marshal.Array.callocArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qjm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Qjq; else goto c8Qjp;
       c8Qjq: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.callocArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Qjp: // global
           I64[Hp - 32] = lvl33_s8PQo_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8PQD_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.419750588 UTC

[section ""data" . Foreign.Marshal.Array.$wcallocArray0_closure" {
     Foreign.Marshal.Array.$wcallocArray0_closure:
         const Foreign.Marshal.Array.$wcallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.$wcallocArray0_entry() //  [R2, R3]
         { info_tbl: [(c8Qjx,
                       label: Foreign.Marshal.Array.$wcallocArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qjx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Qjy; else goto c8Qjz;
       c8Qjy: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.$wcallocArray0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Qjz: // global
           I64[Sp - 16] = block_c8Qjv_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.callocArray1_closure;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8Qjv() //  [R1]
         { info_tbl: [(c8Qjv,
                       label: block_c8Qjv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qjv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QjE; else goto c8QjD;
       c8QjE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8QjD: // global
           (_s8PQP::I64) = call "ccall" arg hints:  [,]  result hints:  [PtrHint] calloc(1, (I64[Sp + 8] + 1) * I64[R1 + 7]);
           if (_s8PQP::I64 == 0) goto c8QjX; else goto c8QjW;
       c8QjX: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.calloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8QjW: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PQP::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.421360182 UTC

[section ""data" . Foreign.Marshal.Array.callocArray2_closure" {
     Foreign.Marshal.Array.callocArray2_closure:
         const Foreign.Marshal.Array.callocArray2_info;
         const 0;
 },
 Foreign.Marshal.Array.callocArray2_entry() //  [R2, R3]
         { info_tbl: [(c8Qk5,
                       label: Foreign.Marshal.Array.callocArray2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qk5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Qk6; else goto c8Qk7;
       c8Qk6: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.callocArray2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Qk7: // global
           I64[Sp - 16] = block_c8Qk2_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Qkb; else goto c8Qk3;
       u8Qkb: // global
           call _c8Qk2(R1) args: 0, res: 0, upd: 0;
       c8Qk3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qk2() //  [R1]
         { info_tbl: [(c8Qk2,
                       label: block_c8Qk2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qk2: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.Marshal.Array.$wcallocArray0_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.422607923 UTC

[section ""data" . Foreign.Marshal.Array.callocArray0_closure" {
     Foreign.Marshal.Array.callocArray0_closure:
         const Foreign.Marshal.Array.callocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.callocArray0_entry() //  [R2, R3]
         { info_tbl: [(c8Qkg,
                       label: Foreign.Marshal.Array.callocArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qkg: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.callocArray2_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.423461954 UTC

[section ""data" . lvl14_r8PPt_closure" {
     lvl14_r8PPt_closure:
         const GHC.Types.I#_con_info;
         const 115;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.424106574 UTC

[section ""data" . lvl15_r8PPu_closure" {
     lvl15_r8PPu_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl14_r8PPt_closure+1;
         const lvl7_r8PPm_closure+1;
         const lvl14_r8PPt_closure+1;
         const lvl8_r8PPn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.424786806 UTC

[section ""data" . lvl16_r8PPv_closure" {
     lvl16_r8PPv_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl15_r8PPu_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.425967325 UTC

[section ""data" . Foreign.Marshal.Array.allocaArray1_closure" {
     Foreign.Marshal.Array.allocaArray1_closure:
         const Foreign.Marshal.Array.allocaArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.allocaArray1_entry() //  [R1]
         { info_tbl: [(c8Qkp,
                       label: Foreign.Marshal.Array.allocaArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qkp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Qkq; else goto c8Qkr;
       c8Qkq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Qkr: // global
           (_c8Qkm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Qkm::I64 == 0) goto c8Qko; else goto c8Qkn;
       c8Qko: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Qkn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Qkm::I64;
           R2 = lvl16_r8PPv_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.42799521 UTC

[section ""data" . Foreign.Marshal.Array.allocaArray_closure" {
     Foreign.Marshal.Array.allocaArray_closure:
         const Foreign.Marshal.Array.allocaArray_info;
         const 0;
 },
 lvl33_s8PQY_entry() //  [R1]
         { info_tbl: [(c8QkA,
                       label: lvl33_s8PQY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QkA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QkB; else goto c8QkC;
       c8QkB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QkC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.allocaArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds1_s8PQZ_entry() //  [R1]
         { info_tbl: [(c8QkH,
                       label: ds1_s8PQZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QkH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QkI; else goto c8QkJ;
       c8QkI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QkJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.allocaArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.alignment_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PRm_entry() //  [R1, R2, R3]
         { info_tbl: [(c8QkS,
                       label: sat_s8PRm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QkS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Ql1; else goto c8Ql2;
       c8Ql1: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Ql2: // global
           I64[Sp - 32] = block_c8QkP_info;
           _s8PQY::P64 = P64[R1 + 5];
           _s8PQZ::P64 = P64[R1 + 13];
           R1 = R2;
           P64[Sp - 24] = _s8PQY::P64;
           P64[Sp - 16] = _s8PQZ::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8Qlr; else goto c8QkQ;
       u8Qlr: // global
           call _c8QkP(R1) args: 0, res: 0, upd: 0;
       c8QkQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QkP() //  [R1]
         { info_tbl: [(c8QkP,
                       label: block_c8QkP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QkP: // global
           I64[Sp] = block_c8QkV_info;
           _s8PR4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PR4::I64;
           if (R1 & 7 != 0) goto u8Qlq; else goto c8QkW;
       u8Qlq: // global
           call _c8QkV(R1) args: 0, res: 0, upd: 0;
       c8QkW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QkV() //  [R1]
         { info_tbl: [(c8QkV,
                       label: block_c8QkV_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QkV: // global
           I64[Sp] = block_c8Ql0_info;
           _s8PR6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8PR6::I64;
           if (R1 & 7 != 0) goto u8Qls; else goto c8Ql5;
       u8Qls: // global
           call _c8Ql0(R1) args: 0, res: 0, upd: 0;
       c8Ql5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ql0() //  [R1]
         { info_tbl: [(c8Ql0,
                       label: block_c8Ql0_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ql0: // global
           _s8PR9::I64 = I64[Sp + 8] * I64[Sp + 16];
           I64[Sp + 16] = block_c8Qld_info;
           R2 = I64[R1 + 7];
           R1 = _s8PR9::I64;
           Sp = Sp + 16;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qld() //  [R1]
         { info_tbl: [(c8Qld,
                       label: block_c8Qld_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qld: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Qlh; else goto c8Qlg;
       c8Qlh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Qlg: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           P64[Hp] = R1 + 16;
           I64[Sp] = block_c8Qlm_info;
           R2 = Hp - 7;
           _s8PRf::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8PRf::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qlm() //  [R1]
         { info_tbl: [(c8Qlm,
                       label: block_c8Qlm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qlm: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.allocaArray_entry() //  [R2]
         { info_tbl: [(c8Qlt,
                       label: Foreign.Marshal.Array.allocaArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qlt: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8Qlx; else goto c8Qlw;
       c8Qlx: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Foreign.Marshal.Array.allocaArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Qlw: // global
           I64[Hp - 64] = lvl33_s8PQY_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = ds1_s8PQZ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s8PRm_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 13;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.431440195 UTC

[section ""data" . Foreign.Marshal.Array.allocaArray0_closure" {
     Foreign.Marshal.Array.allocaArray0_closure:
         const Foreign.Marshal.Array.allocaArray0_info;
         const 0;
 },
 sat_s8PRs_entry() //  [R1]
         { info_tbl: [(c8QlJ,
                       label: sat_s8PRs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QlJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8QlQ; else goto c8QlR;
       c8QlQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QlR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8QlG_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8QlV; else goto c8QlH;
       u8QlV: // global
           call _c8QlG(R1) args: 0, res: 0, upd: 0;
       c8QlH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8QlG() //  [R1]
         { info_tbl: [(c8QlG,
                       label: block_c8QlG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QlG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QlU; else goto c8QlT;
       c8QlU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8QlT: // global
           _s8PRr::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8PRr::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Array.allocaArray0_entry() //  [R2, R3]
         { info_tbl: [(c8QlW,
                       label: Foreign.Marshal.Array.allocaArray0_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QlW: // global
           _s8PRo::P64 = R3;
           _s8PRn::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c8QlX; else goto c8QlY;
       c8QlY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Qm0; else goto c8QlZ;
       c8Qm0: // global
           HpAlloc = 24;
           goto c8QlX;
       c8QlX: // global
           R3 = _s8PRo::P64;
           R2 = _s8PRn::P64;
           R1 = Foreign.Marshal.Array.allocaArray0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QlZ: // global
           I64[Hp - 16] = sat_s8PRs_info;
           P64[Hp] = _s8PRo::P64;
           R2 = _s8PRn::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Foreign.Marshal.Array.allocaArray_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.433158287 UTC

[section ""data" . lvl17_r8PPw_closure" {
     lvl17_r8PPw_closure:
         const GHC.Types.I#_con_info;
         const 133;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.433847897 UTC

[section ""data" . lvl18_r8PPx_closure" {
     lvl18_r8PPx_closure:
         const GHC.Types.I#_con_info;
         const 27;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.434533133 UTC

[section ""data" . lvl19_r8PPy_closure" {
     lvl19_r8PPy_closure:
         const GHC.Types.I#_con_info;
         const 36;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.435203329 UTC

[section ""data" . lvl20_r8PPz_closure" {
     lvl20_r8PPz_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl17_r8PPw_closure+1;
         const lvl18_r8PPx_closure+1;
         const lvl17_r8PPw_closure+1;
         const lvl19_r8PPy_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.435931495 UTC

[section ""data" . lvl21_r8PPA_closure" {
     lvl21_r8PPA_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl20_r8PPz_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.438143404 UTC

[section ""data" . Foreign.Marshal.Array.reallocArray1_closure" {
     Foreign.Marshal.Array.reallocArray1_closure:
         const Foreign.Marshal.Array.reallocArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.reallocArray1_entry() //  [R1]
         { info_tbl: [(c8Qm7,
                       label: Foreign.Marshal.Array.reallocArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qm7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Qm8; else goto c8Qm9;
       c8Qm8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Qm9: // global
           (_c8Qm4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Qm4::I64 == 0) goto c8Qm6; else goto c8Qm5;
       c8Qm6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Qm5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Qm4::I64;
           R2 = lvl21_r8PPA_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.440170411 UTC

[section ""data" . Foreign.Marshal.Array.reallocArray_closure" {
     Foreign.Marshal.Array.reallocArray_closure:
         const Foreign.Marshal.Array.reallocArray_info;
         const 0;
 },
 lvl33_s8PRu_entry() //  [R1]
         { info_tbl: [(c8Qmi,
                       label: lvl33_s8PRu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qmi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Qmj; else goto c8Qmk;
       c8Qmj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Qmk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.reallocArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PRP_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Qmt,
                       label: sat_s8PRP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qmt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8QmC; else goto c8QmD;
       c8QmC: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QmD: // global
           I64[Sp - 24] = block_c8Qmq_info;
           _s8PRu::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s8PRu::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Qnk; else goto c8Qmr;
       u8Qnk: // global
           call _c8Qmq(R1) args: 0, res: 0, upd: 0;
       c8Qmr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qmq() //  [R1]
         { info_tbl: [(c8Qmq,
                       label: block_c8Qmq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qmq: // global
           I64[Sp] = block_c8Qmw_info;
           _s8PRz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PRz::I64;
           if (R1 & 7 != 0) goto u8Qnj; else goto c8Qmx;
       u8Qnj: // global
           call _c8Qmw(R1) args: 0, res: 0, upd: 0;
       c8Qmx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qmw() //  [R1]
         { info_tbl: [(c8Qmw,
                       label: block_c8Qmw_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qmw: // global
           I64[Sp] = block_c8QmB_info;
           _s8PRB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8PRB::I64;
           if (R1 & 7 != 0) goto u8Qnl; else goto c8QmG;
       u8Qnl: // global
           call _c8QmB(R1) args: 0, res: 0, upd: 0;
       c8QmG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QmB() //  [R1]
         { info_tbl: [(c8QmB,
                       label: block_c8QmB_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QmB: // global
           _s8PRD::I64 = I64[R1 + 7];
           _s8PRE::I64 = I64[Sp + 8] * I64[Sp + 16];
           if (_s8PRE::I64 != 0) goto u8Qnh; else goto c8Qnb;
       u8Qnh: // global
           I64[Sp + 8] = _s8PRE::I64;
           I64[Sp + 16] = _s8PRD::I64;
           Sp = Sp + 8;
           call _c8QmR() args: 0, res: 0, upd: 0;
       c8Qnb: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(_s8PRD::I64);
           R1 = GHC.Ptr.nullPtr_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8QmR() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QmR: // global
           Hp = Hp + 16;
           _s8PRE::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c8QmV; else goto c8QmU;
       c8QmV: // global
           HpAlloc = 16;
           I64[Sp] = block_c8QmO_info;
           R1 = _s8PRE::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8QmU: // global
           (_s8PRJ::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp + 8], _s8PRE::I64);
           if (_s8PRJ::I64 == 0) goto c8Qn8; else goto c8Qn7;
       c8Qn8: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Qn7: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PRJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8QmO() //  [R1]
         { info_tbl: [(c8QmO,
                       label: block_c8QmO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QmO: // global
           I64[Sp] = R1;
           call _c8QmR() args: 0, res: 0, upd: 0;
     }
 },
 Foreign.Marshal.Array.reallocArray_entry() //  [R2]
         { info_tbl: [(c8Qno,
                       label: Foreign.Marshal.Array.reallocArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qno: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Qns; else goto c8Qnr;
       c8Qns: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.reallocArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Qnr: // global
           I64[Hp - 32] = lvl33_s8PRu_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8PRP_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.44352316 UTC

[section ""data" . Foreign.Marshal.Array.$wreallocArray0_closure" {
     Foreign.Marshal.Array.$wreallocArray0_closure:
         const Foreign.Marshal.Array.$wreallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.$wreallocArray0_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Qnz,
                       label: Foreign.Marshal.Array.$wreallocArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 20} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qnz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8QnA; else goto c8QnB;
       c8QnA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.$wreallocArray0_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QnB: // global
           I64[Sp - 24] = block_c8Qnx_info;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = Foreign.Marshal.Array.reallocArray1_closure;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8Qnx() //  [R1]
         { info_tbl: [(c8Qnx,
                       label: block_c8Qnx_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qnx: // global
           _s8PRX::I64 = (I64[Sp + 16] + 1) * I64[R1 + 7];
           if (_s8PRX::I64 != 0) goto u8Qoe; else goto c8Qo8;
       u8Qoe: // global
           I64[Sp + 16] = _s8PRX::I64;
           Sp = Sp + 8;
           call _c8QnO() args: 0, res: 0, upd: 0;
       c8Qo8: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[Sp + 8]);
           R1 = GHC.Ptr.nullPtr_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8QnO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QnO: // global
           Hp = Hp + 16;
           _s8PRX::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c8QnS; else goto c8QnR;
       c8QnS: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c8QnL_info;
           R1 = _s8PRX::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8QnR: // global
           (_s8PS2::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp], _s8PRX::I64);
           if (_s8PS2::I64 == 0) goto c8Qo5; else goto c8Qo4;
       c8Qo5: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Qo4: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PS2::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8QnL() //  [R1]
         { info_tbl: [(c8QnL,
                       label: block_c8QnL_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QnL: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c8QnO() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.445548424 UTC

[section ""data" . Foreign.Marshal.Array.reallocArray2_closure" {
     Foreign.Marshal.Array.reallocArray2_closure:
         const Foreign.Marshal.Array.reallocArray2_info;
         const 0;
 },
 Foreign.Marshal.Array.reallocArray2_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Qop,
                       label: Foreign.Marshal.Array.reallocArray2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qop: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Qot; else goto c8Qou;
       c8Qot: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.reallocArray2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Qou: // global
           I64[Sp - 24] = block_c8Qom_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8QoC; else goto c8Qon;
       u8QoC: // global
           call _c8Qom(R1) args: 0, res: 0, upd: 0;
       c8Qon: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qom() //  [R1]
         { info_tbl: [(c8Qom,
                       label: block_c8Qom_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qom: // global
           I64[Sp] = block_c8Qos_info;
           _s8PSd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8PSd::I64;
           if (R1 & 7 != 0) goto u8QoB; else goto c8Qow;
       u8QoB: // global
           call _c8Qos(R1) args: 0, res: 0, upd: 0;
       c8Qow: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qos() //  [R1]
         { info_tbl: [(c8Qos,
                       label: block_c8Qos_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qos: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Array.$wreallocArray0_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.447035376 UTC

[section ""data" . Foreign.Marshal.Array.reallocArray0_closure" {
     Foreign.Marshal.Array.reallocArray0_closure:
         const Foreign.Marshal.Array.reallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.reallocArray0_entry() //  [R2, R3, R4]
         { info_tbl: [(c8QoH,
                       label: Foreign.Marshal.Array.reallocArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QoH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.reallocArray2_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.447809546 UTC

[section ""data" . Foreign.Marshal.Array.lengthArray2_closure" {
     Foreign.Marshal.Array.lengthArray2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.449532424 UTC

[section ""data" . Foreign.Marshal.Array.$wpeekArray_closure" {
     Foreign.Marshal.Array.$wpeekArray_closure:
         const Foreign.Marshal.Array.$wpeekArray_info;
 },
 Foreign.Marshal.Array.$wpeekArray_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Qpa,
                       label: Foreign.Marshal.Array.$wpeekArray_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qpa: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8Qpb; else goto c8Qpc;
       c8Qpb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.$wpeekArray_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Qpc: // global
           if (%MO_S_Gt_W64(R3, 0)) goto c8Qp8; else goto c8Qp9;
       c8Qp8: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R3 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call _c8QoY() args: 0, res: 0, upd: 0;
       c8Qp9: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8QoY() //  []
         { info_tbl: [(c8QoY,
                       label: block_c8QoY_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QoY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Qpp; else goto c8Qpo;
       c8Qpp: // global
           HpAlloc = 16;
           I64[Sp] = block_c8QoY_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Qpo: // global
           _s8PSg::P64 = P64[Sp + 8];
           _s8PSi::P64 = P64[Sp + 16];
           _s8PSw::I64 = I64[Sp + 24];
           if (_s8PSw::I64 != 0) goto c8Qpr; else goto c8Qpv;
       c8Qpr: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8PSw::I64;
           I64[Sp] = block_c8Qp4_info;
           R2 = _s8PSg::P64;
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = _s8PSi::P64;
           P64[Sp - 8] = Hp - 7;
           I64[Sp + 24] = _s8PSw::I64;
           Sp = Sp - 24;
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 8, upd: 8;
       c8Qpv: // global
           Hp = Hp - 16;
           I64[Sp + 24] = block_c8Qpg_info;
           R2 = _s8PSg::P64;
           I64[Sp] = stg_ap_ppv_info;
           P64[Sp + 8] = _s8PSi::P64;
           P64[Sp + 16] = Foreign.Marshal.Array.lengthArray2_closure+1;
           P64[Sp + 32] = P64[Sp + 32];
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8Qp4() //  [R1]
         { info_tbl: [(c8Qp4,
                       label: block_c8Qp4_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qp4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Qpu; else goto c8Qpt;
       c8Qpu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Qpt: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 32];
           I64[Sp + 24] = I64[Sp + 24] - 1;
           P64[Sp + 32] = Hp - 14;
           call _c8QoY() args: 0, res: 0, upd: 0;
     }
 },
 _c8Qpg() //  [R1]
         { info_tbl: [(c8Qpg,
                       label: block_c8Qpg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qpg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Qpm; else goto c8Qpl;
       c8Qpm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Qpl: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.451807776 UTC

[section ""data" . Foreign.Marshal.Array.peekArray1_closure" {
     Foreign.Marshal.Array.peekArray1_closure:
         const Foreign.Marshal.Array.peekArray1_info;
 },
 Foreign.Marshal.Array.peekArray1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8QpI,
                       label: Foreign.Marshal.Array.peekArray1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QpI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8QpJ; else goto c8QpK;
       c8QpJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.peekArray1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QpK: // global
           I64[Sp - 24] = block_c8QpF_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8QpO; else goto c8QpG;
       u8QpO: // global
           call _c8QpF(R1) args: 0, res: 0, upd: 0;
       c8QpG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QpF() //  [R1]
         { info_tbl: [(c8QpF,
                       label: block_c8QpF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QpF: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Array.$wpeekArray_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.453085491 UTC

[section ""data" . Foreign.Marshal.Array.peekArray_closure" {
     Foreign.Marshal.Array.peekArray_closure:
         const Foreign.Marshal.Array.peekArray_info;
 },
 Foreign.Marshal.Array.peekArray_entry() //  [R2, R3, R4]
         { info_tbl: [(c8QpT,
                       label: Foreign.Marshal.Array.peekArray_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QpT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.peekArray1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.454567243 UTC

[section ""data" . Foreign.Marshal.Array.newArray2_closure" {
     Foreign.Marshal.Array.newArray2_closure:
         const Foreign.Marshal.Array.newArray2_info;
 },
 Foreign.Marshal.Array.newArray2_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Qq2,
                       label: Foreign.Marshal.Array.newArray2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qq2: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c8Qq3; else goto c8Qq4;
       c8Qq3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.newArray2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Qq4: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           I64[Sp - 8] = 0;
           Sp = Sp - 32;
           call _c8Qq5() args: 0, res: 0, upd: 0;
     }
 },
 _c8Qq5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qq5: // global
           I64[Sp - 8] = block_c8Qq8_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Qqw; else goto c8Qqa;
       u8Qqw: // global
           call _c8Qq8(R1) args: 0, res: 0, upd: 0;
       c8Qqa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qq8() //  [R1]
         { info_tbl: [(c8Qq8,
                       label: block_c8Qq8_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qq8: // global
           if (R1 & 7 == 1) goto c8Qqg; else goto c8Qql;
       c8Qqg: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Qql: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Qqo; else goto c8Qqn;
       c8Qqo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Qqn: // global
           _s8PST::P64 = P64[R1 + 6];
           _s8PSU::P64 = P64[R1 + 14];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 32];
           I64[Sp] = block_c8Qqk_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_pppv_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = Hp - 7;
           P64[Sp - 8] = _s8PST::P64;
           P64[Sp + 24] = _s8PSU::P64;
           Sp = Sp - 32;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _c8Qqk() //  []
         { info_tbl: [(c8Qqk,
                       label: block_c8Qqk_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qqk: // global
           P64[Sp + 24] = P64[Sp + 24];
           I64[Sp + 32] = I64[Sp + 32] + 1;
           Sp = Sp + 8;
           call _c8Qq5() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.456339118 UTC

[section ""data" . Foreign.Marshal.Array.pokeArray_closure" {
     Foreign.Marshal.Array.pokeArray_closure:
         const Foreign.Marshal.Array.pokeArray_info;
 },
 Foreign.Marshal.Array.pokeArray_entry() //  [R2, R3, R4]
         { info_tbl: [(c8QqC,
                       label: Foreign.Marshal.Array.pokeArray_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QqC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.newArray2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.457810381 UTC

[section ""data" . Foreign.Marshal.Array.withArrayLen_closure" {
     Foreign.Marshal.Array.withArrayLen_closure:
         const Foreign.Marshal.Array.withArrayLen_info;
         const 0;
 },
 len_s8PT3_entry() //  [R1]
         { info_tbl: [(c8QqP,
                       label: len_s8PT3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QqP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8QqT; else goto c8QqU;
       c8QqT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QqU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8QqN_info;
           R3 = 0;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8QqN() //  [R1]
         { info_tbl: [(c8QqN,
                       label: block_c8QqN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QqN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QqX; else goto c8QqW;
       c8QqX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c8QqW: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8PTa_entry() //  [R1, R2]
         { info_tbl: [(c8Qr5,
                       label: sat_s8PTa_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qr5: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Qr6; else goto c8Qr7;
       c8Qr6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Qr7: // global
           I64[Sp - 32] = block_c8Qr3_info;
           R4 = P64[R1 + 14];
           R3 = R2;
           _s8PT5::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 22];
           P64[Sp - 16] = P64[R1 + 30];
           P64[Sp - 8] = _s8PT5::P64;
           Sp = Sp - 32;
           call Foreign.Marshal.Array.newArray2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qr3() //  []
         { info_tbl: [(c8Qr3,
                       label: block_c8Qr3_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qr3: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.withArrayLen_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Qr9,
                       label: Foreign.Marshal.Array.withArrayLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qr9: // global
           _s8PT2::P64 = R4;
           _s8PT1::P64 = R3;
           _s8PT0::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8Qra; else goto c8Qrb;
       c8Qrb: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8Qrd; else goto c8Qrc;
       c8Qrd: // global
           HpAlloc = 64;
           goto c8Qra;
       c8Qra: // global
           R4 = _s8PT2::P64;
           R3 = _s8PT1::P64;
           R2 = _s8PT0::P64;
           R1 = Foreign.Marshal.Array.withArrayLen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Qrc: // global
           I64[Hp - 56] = len_s8PT3_info;
           P64[Hp - 40] = _s8PT1::P64;
           I64[Hp - 32] = sat_s8PTa_info;
           P64[Hp - 24] = _s8PT0::P64;
           P64[Hp - 16] = _s8PT1::P64;
           P64[Hp - 8] = _s8PT2::P64;
           _c8QqJ::P64 = Hp - 56;
           P64[Hp] = _c8QqJ::P64;
           R2 = _s8PT0::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _c8QqJ::P64;
           P64[Sp - 8] = Hp - 30;
           Sp = Sp - 24;
           call Foreign.Marshal.Array.allocaArray_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.460695955 UTC

[section ""data" . Foreign.Marshal.Array.withArray_closure" {
     Foreign.Marshal.Array.withArray_closure:
         const Foreign.Marshal.Array.withArray_info;
         const 0;
 },
 sat_s8PTl_entry() //  [R1, R2]
         { info_tbl: [(c8Qrp,
                       label: sat_s8PTl_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qrp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Qrq; else goto c8Qrr;
       c8Qrq: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Qrr: // global
           I64[Sp - 24] = block_c8Qrn_info;
           R4 = P64[R1 + 14];
           R3 = R2;
           _s8PTg::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = P64[R1 + 22];
           P64[Sp - 8] = _s8PTg::P64;
           Sp = Sp - 24;
           call Foreign.Marshal.Array.newArray2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qrn() //  []
         { info_tbl: [(c8Qrn,
                       label: block_c8Qrn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qrn: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8PTf_entry() //  [R1]
         { info_tbl: [(c8Qrz,
                       label: sat_s8PTf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qrz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8QrD; else goto c8QrE;
       c8QrD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QrE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8Qrx_info;
           R3 = 0;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8Qrx() //  [R1]
         { info_tbl: [(c8Qrx,
                       label: block_c8Qrx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qrx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QrH; else goto c8QrG;
       c8QrH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c8QrG: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Array.withArray_entry() //  [R2, R3, R4]
         { info_tbl: [(c8QrI,
                       label: Foreign.Marshal.Array.withArray_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QrI: // global
           _s8PTd::P64 = R4;
           _s8PTc::P64 = R3;
           _s8PTb::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8QrJ; else goto c8QrK;
       c8QrK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8QrM; else goto c8QrL;
       c8QrM: // global
           HpAlloc = 56;
           goto c8QrJ;
       c8QrJ: // global
           R4 = _s8PTd::P64;
           R3 = _s8PTc::P64;
           R2 = _s8PTb::P64;
           R1 = Foreign.Marshal.Array.withArray_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QrL: // global
           I64[Hp - 48] = sat_s8PTl_info;
           P64[Hp - 40] = _s8PTb::P64;
           P64[Hp - 32] = _s8PTc::P64;
           P64[Hp - 24] = _s8PTd::P64;
           I64[Hp - 16] = sat_s8PTf_info;
           P64[Hp] = _s8PTc::P64;
           R2 = _s8PTb::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 46;
           Sp = Sp - 24;
           call Foreign.Marshal.Array.allocaArray_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.463588536 UTC

[section ""data" . Foreign.Marshal.Array.newArray1_closure" {
     Foreign.Marshal.Array.newArray1_closure:
         const Foreign.Marshal.Array.newArray1_info;
         const 0;
 },
 Foreign.Marshal.Array.newArray1_entry() //  [R2, R3]
         { info_tbl: [(c8QrT,
                       label: Foreign.Marshal.Array.newArray1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QrT: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8QrX; else goto c8QrY;
       c8QrX: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.newArray1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QrY: // global
           I64[Sp - 24] = block_c8QrR_info;
           _s8PTn::P64 = R3;
           R3 = 0;
           _s8PTm::P64 = R2;
           R2 = _s8PTn::P64;
           P64[Sp - 16] = _s8PTm::P64;
           P64[Sp - 8] = _s8PTn::P64;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8QrR() //  [R1]
         { info_tbl: [(c8QrR,
                       label: block_c8QrR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QrR: // global
           I64[Sp - 8] = block_c8QrW_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = Foreign.Marshal.Array.mallocArray1_closure;
           I64[Sp] = R1;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8QrW() //  [R1]
         { info_tbl: [(c8QrW,
                       label: block_c8QrW_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QrW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Qs5; else goto c8Qs4;
       c8Qs5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Qs4: // global
           _s8PTm::P64 = P64[Sp + 16];
           _s8PTn::P64 = P64[Sp + 24];
           (_s8PTx::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[Sp + 8] * I64[R1 + 7]);
           if (_s8PTx::I64 == 0) goto c8Qsn; else goto c8Qsk;
       c8Qsn: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Qsk: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PTx::I64;
           I64[Sp + 16] = block_c8Qsi_info;
           R4 = _s8PTn::P64;
           _c8Qsh::P64 = Hp - 7;
           R3 = _c8Qsh::P64;
           R2 = _s8PTm::P64;
           P64[Sp + 24] = _c8Qsh::P64;
           Sp = Sp + 16;
           call Foreign.Marshal.Array.newArray2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qsi() //  []
         { info_tbl: [(c8Qsi,
                       label: block_c8Qsi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qsi: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.466773285 UTC

[section ""data" . Foreign.Marshal.Array.newArray_closure" {
     Foreign.Marshal.Array.newArray_closure:
         const Foreign.Marshal.Array.newArray_info;
         const 0;
 },
 Foreign.Marshal.Array.newArray_entry() //  [R2, R3]
         { info_tbl: [(c8Qss,
                       label: Foreign.Marshal.Array.newArray_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qss: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.newArray1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.468378651 UTC

[section ""data" . Foreign.Marshal.Array.newArray4_closure" {
     Foreign.Marshal.Array.newArray4_closure:
         const Foreign.Marshal.Array.newArray4_info;
 },
 Foreign.Marshal.Array.newArray4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8QsD,
                       label: Foreign.Marshal.Array.newArray4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QsD: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8QsE; else goto c8QsF;
       c8QsE: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.newArray4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QsF: // global
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = 0;
           Sp = Sp - 40;
           call _c8QsM() args: 0, res: 0, upd: 0;
     }
 },
 _c8QsM() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QsM: // global
           I64[Sp - 8] = block_c8QsP_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Qth; else goto c8QsR;
       u8Qth: // global
           call _c8QsP(R1) args: 0, res: 0, upd: 0;
       c8QsR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QsP() //  [R1]
         { info_tbl: [(c8QsP,
                       label: block_c8QsP_info
                       rep:StackRep [False, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QsP: // global
           _s8PTO::I64 = I64[Sp + 40];
           if (R1 & 7 == 1) goto c8QsX; else goto c8Qt2;
       c8QsX: // global
           I64[Sp + 40] = _s8PTO::I64;
           Sp = Sp + 8;
           call _c8QsH() args: 0, res: 0, upd: 0;
       c8Qt2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Qt5; else goto c8Qt4;
       c8Qt5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Qt4: // global
           _s8PTR::P64 = P64[R1 + 6];
           _s8PTS::P64 = P64[R1 + 14];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8PTO::I64;
           I64[Sp] = block_c8Qt1_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_pppv_info;
           P64[Sp - 24] = P64[Sp + 24];
           P64[Sp - 16] = Hp - 7;
           P64[Sp - 8] = _s8PTR::P64;
           P64[Sp + 32] = _s8PTS::P64;
           Sp = Sp - 32;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _c8QsH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QsH: // global
           Hp = Hp + 16;
           _s8PTJ::I64 = I64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto c8QsL; else goto c8QsK;
       c8QsL: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c8QsG_info;
           R1 = _s8PTJ::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8QsK: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8PTJ::I64;
           R2 = P64[Sp];
           _s8PTE::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pppv_info;
           P64[Sp + 24] = Hp - 7;
           P64[Sp + 32] = _s8PTE::P64;
           Sp = Sp + 8;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _c8QsG() //  [R1]
         { info_tbl: [(c8QsG,
                       label: block_c8QsG_info
                       rep:StackRep [False, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QsG: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _c8QsH() args: 0, res: 0, upd: 0;
     }
 },
 _c8Qt1() //  []
         { info_tbl: [(c8Qt1,
                       label: block_c8Qt1_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qt1: // global
           P64[Sp + 32] = P64[Sp + 32];
           I64[Sp + 40] = I64[Sp + 40] + 1;
           Sp = Sp + 8;
           call _c8QsM() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.470643479 UTC

[section ""data" . Foreign.Marshal.Array.pokeArray0_closure" {
     Foreign.Marshal.Array.pokeArray0_closure:
         const Foreign.Marshal.Array.pokeArray0_info;
 },
 Foreign.Marshal.Array.pokeArray0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8Qto,
                       label: Foreign.Marshal.Array.pokeArray0_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qto: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.newArray4_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.472381646 UTC

[section ""data" . Foreign.Marshal.Array.withArrayLen0_closure" {
     Foreign.Marshal.Array.withArrayLen0_closure:
         const Foreign.Marshal.Array.withArrayLen0_info;
         const 0;
 },
 len_s8PU2_entry() //  [R1]
         { info_tbl: [(c8QtB,
                       label: len_s8PU2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QtB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8QtF; else goto c8QtG;
       c8QtF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QtG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8Qtz_info;
           R3 = 0;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8Qtz() //  [R1]
         { info_tbl: [(c8Qtz,
                       label: block_c8Qtz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qtz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QtJ; else goto c8QtI;
       c8QtJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c8QtI: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8PUd_entry() //  [R1, R2]
         { info_tbl: [(c8QtR,
                       label: sat_s8PUd_info
                       rep:HeapRep 5 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QtR: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QtS; else goto c8QtT;
       c8QtS: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8QtT: // global
           I64[Sp - 32] = block_c8QtP_info;
           R5 = P64[R1 + 22];
           R4 = R2;
           R3 = P64[R1 + 14];
           _s8PU8::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 30];
           P64[Sp - 16] = P64[R1 + 38];
           P64[Sp - 8] = _s8PU8::P64;
           Sp = Sp - 32;
           call Foreign.Marshal.Array.newArray4_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8QtP() //  []
         { info_tbl: [(c8QtP,
                       label: block_c8QtP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QtP: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8PU7_entry() //  [R1]
         { info_tbl: [(c8Qu2,
                       label: sat_s8PU7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qu2: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Qu9; else goto c8Qua;
       c8Qu9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Qua: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8QtZ_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Que; else goto c8Qu0;
       u8Que: // global
           call _c8QtZ(R1) args: 0, res: 0, upd: 0;
       c8Qu0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8QtZ() //  [R1]
         { info_tbl: [(c8QtZ,
                       label: block_c8QtZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QtZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Qud; else goto c8Quc;
       c8Qud: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8Quc: // global
           _s8PU6::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8PU6::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Array.withArrayLen0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8Quf,
                       label: Foreign.Marshal.Array.withArrayLen0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Quf: // global
           _s8PU1::P64 = R5;
           _s8PU0::P64 = R4;
           _s8PTZ::P64 = R3;
           _s8PTY::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8Qug; else goto c8Quh;
       c8Quh: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c8Quj; else goto c8Qui;
       c8Quj: // global
           HpAlloc = 96;
           goto c8Qug;
       c8Qug: // global
           R5 = _s8PU1::P64;
           R4 = _s8PU0::P64;
           R3 = _s8PTZ::P64;
           R2 = _s8PTY::P64;
           R1 = Foreign.Marshal.Array.withArrayLen0_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Qui: // global
           I64[Hp - 88] = len_s8PU2_info;
           P64[Hp - 72] = _s8PU0::P64;
           I64[Hp - 64] = sat_s8PUd_info;
           P64[Hp - 56] = _s8PTY::P64;
           P64[Hp - 48] = _s8PTZ::P64;
           P64[Hp - 40] = _s8PU0::P64;
           P64[Hp - 32] = _s8PU1::P64;
           _c8Qtv::P64 = Hp - 88;
           P64[Hp - 24] = _c8Qtv::P64;
           I64[Hp - 16] = sat_s8PU7_info;
           P64[Hp] = _c8Qtv::P64;
           R2 = _s8PTY::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 62;
           Sp = Sp - 24;
           call Foreign.Marshal.Array.allocaArray_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.475400062 UTC

[section ""data" . Foreign.Marshal.Array.withArray0_closure" {
     Foreign.Marshal.Array.withArray0_closure:
         const Foreign.Marshal.Array.withArray0_info;
         const 0;
 },
 sat_s8PUj_entry() //  [R1]
         { info_tbl: [(c8Qut,
                       label: sat_s8PUj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qut: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.withArray0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8Quw,
                       label: Foreign.Marshal.Array.withArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Quw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QuA; else goto c8Quz;
       c8QuA: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.withArray0_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Quz: // global
           I64[Hp - 8] = sat_s8PUj_info;
           P64[Hp] = R5;
           R5 = Hp - 7;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.withArrayLen0_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.477166938 UTC

[section ""data" . Foreign.Marshal.Array.newArray3_closure" {
     Foreign.Marshal.Array.newArray3_closure:
         const Foreign.Marshal.Array.newArray3_info;
         const 0;
 },
 Foreign.Marshal.Array.newArray3_entry() //  [R2, R3, R4]
         { info_tbl: [(c8QuH,
                       label: Foreign.Marshal.Array.newArray3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QuH: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8QuL; else goto c8QuM;
       c8QuL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.newArray3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QuM: // global
           I64[Sp - 32] = block_c8QuF_info;
           _s8PUl::P64 = R3;
           R3 = 0;
           _s8PUk::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _s8PUk::P64;
           P64[Sp - 16] = _s8PUl::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8QuF() //  [R1]
         { info_tbl: [(c8QuF,
                       label: block_c8QuF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QuF: // global
           I64[Sp - 8] = block_c8QuK_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = Foreign.Marshal.Array.mallocArray1_closure;
           I64[Sp] = R1;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8QuK() //  [R1]
         { info_tbl: [(c8QuK,
                       label: block_c8QuK_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QuK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QuT; else goto c8QuS;
       c8QuT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8QuS: // global
           _s8PUk::P64 = P64[Sp + 16];
           _s8PUl::P64 = P64[Sp + 24];
           _s8PUm::P64 = P64[Sp + 32];
           (_s8PUx::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc((I64[Sp + 8] + 1) * I64[R1 + 7]);
           if (_s8PUx::I64 == 0) goto c8Qve; else goto c8Qvb;
       c8Qve: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Qvb: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PUx::I64;
           I64[Sp + 24] = block_c8Qv9_info;
           R5 = _s8PUm::P64;
           _c8Qv8::P64 = Hp - 7;
           R4 = _c8Qv8::P64;
           R3 = _s8PUl::P64;
           R2 = _s8PUk::P64;
           P64[Sp + 32] = _c8Qv8::P64;
           Sp = Sp + 24;
           call Foreign.Marshal.Array.newArray4_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qv9() //  []
         { info_tbl: [(c8Qv9,
                       label: block_c8Qv9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qv9: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.479339343 UTC

[section ""data" . Foreign.Marshal.Array.newArray0_closure" {
     Foreign.Marshal.Array.newArray0_closure:
         const Foreign.Marshal.Array.newArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.newArray0_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Qvj,
                       label: Foreign.Marshal.Array.newArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qvj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.newArray3_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.480136964 UTC

[section ""data" . lvl22_r8PPB_closure" {
     lvl22_r8PPB_closure:
         const GHC.Types.I#_con_info;
         const 242;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.480744634 UTC

[section ""data" . lvl23_r8PPC_closure" {
     lvl23_r8PPC_closure:
         const GHC.Types.I#_con_info;
         const 21;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.481361431 UTC

[section ""data" . lvl24_r8PPD_closure" {
     lvl24_r8PPD_closure:
         const GHC.Types.I#_con_info;
         const 30;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.481949571 UTC

[section ""data" . lvl25_r8PPE_closure" {
     lvl25_r8PPE_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl22_r8PPB_closure+1;
         const lvl23_r8PPC_closure+1;
         const lvl22_r8PPB_closure+1;
         const lvl24_r8PPD_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.482615039 UTC

[section ""data" . lvl26_r8PPF_closure" {
     lvl26_r8PPF_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl25_r8PPE_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.483481128 UTC

[section ""data" . Foreign.Marshal.Array.copyArray1_closure" {
     Foreign.Marshal.Array.copyArray1_closure:
         const Foreign.Marshal.Array.copyArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.copyArray1_entry() //  [R1]
         { info_tbl: [(c8Qvs,
                       label: Foreign.Marshal.Array.copyArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qvs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Qvt; else goto c8Qvu;
       c8Qvt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Qvu: // global
           (_c8Qvp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Qvp::I64 == 0) goto c8Qvr; else goto c8Qvq;
       c8Qvr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Qvq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Qvp::I64;
           R2 = lvl26_r8PPF_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.485308277 UTC

[section ""data" . Foreign.Marshal.Array.copyArray_closure" {
     Foreign.Marshal.Array.copyArray_closure:
         const Foreign.Marshal.Array.copyArray_info;
         const 0;
 },
 lvl33_s8PUE_entry() //  [R1]
         { info_tbl: [(c8QvD,
                       label: lvl33_s8PUE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QvD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QvE; else goto c8QvF;
       c8QvE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QvF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.copyArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PUX_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c8QvO,
                       label: sat_s8PUX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QvO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Qw2; else goto c8Qw3;
       c8Qw2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Qw3: // global
           I64[Sp - 32] = block_c8QvL_info;
           _s8PUE::P64 = P64[R1 + 4];
           R1 = R2;
           P64[Sp - 24] = _s8PUE::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8Qwn; else goto c8QvM;
       u8Qwn: // global
           call _c8QvL(R1) args: 0, res: 0, upd: 0;
       c8QvM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QvL() //  [R1]
         { info_tbl: [(c8QvL,
                       label: block_c8QvL_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QvL: // global
           I64[Sp] = block_c8QvR_info;
           _s8PUK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8PUK::I64;
           if (R1 & 7 != 0) goto u8Qwm; else goto c8QvS;
       u8Qwm: // global
           call _c8QvR(R1) args: 0, res: 0, upd: 0;
       c8QvS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QvR() //  [R1]
         { info_tbl: [(c8QvR,
                       label: block_c8QvR_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QvR: // global
           I64[Sp] = block_c8QvW_info;
           _s8PUM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s8PUM::I64;
           if (R1 & 7 != 0) goto u8Qwo; else goto c8QvX;
       u8Qwo: // global
           call _c8QvW(R1) args: 0, res: 0, upd: 0;
       c8QvX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QvW() //  [R1]
         { info_tbl: [(c8QvW,
                       label: block_c8QvW_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QvW: // global
           I64[Sp] = block_c8Qw1_info;
           _s8PUO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PUO::I64;
           if (R1 & 7 != 0) goto u8Qwp; else goto c8Qw7;
       u8Qwp: // global
           call _c8Qw1(R1) args: 0, res: 0, upd: 0;
       c8Qw7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qw1() //  [R1]
         { info_tbl: [(c8Qw1,
                       label: block_c8Qw1_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qw1: // global
           (_s8PUW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[Sp + 16], I64[Sp + 24], I64[Sp + 8] * I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.copyArray_entry() //  [R2]
         { info_tbl: [(c8Qwq,
                       label: Foreign.Marshal.Array.copyArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qwq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Qwu; else goto c8Qwt;
       c8Qwu: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.copyArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Qwt: // global
           I64[Hp - 32] = lvl33_s8PUE_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8PUX_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.48797445 UTC

[section ""data" . lvl27_r8PPG_closure" {
     lvl27_r8PPG_closure:
         const GHC.Types.I#_con_info;
         const 251;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.488612071 UTC

[section ""data" . lvl28_r8PPH_closure" {
     lvl28_r8PPH_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl27_r8PPG_closure+1;
         const lvl23_r8PPC_closure+1;
         const lvl27_r8PPG_closure+1;
         const lvl24_r8PPD_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.489367006 UTC

[section ""data" . lvl29_r8PPI_closure" {
     lvl29_r8PPI_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl28_r8PPH_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.490203475 UTC

[section ""data" . Foreign.Marshal.Array.moveArray1_closure" {
     Foreign.Marshal.Array.moveArray1_closure:
         const Foreign.Marshal.Array.moveArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.moveArray1_entry() //  [R1]
         { info_tbl: [(c8QwB,
                       label: Foreign.Marshal.Array.moveArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QwB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8QwC; else goto c8QwD;
       c8QwC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QwD: // global
           (_c8Qwy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Qwy::I64 == 0) goto c8QwA; else goto c8Qwz;
       c8QwA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Qwz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Qwy::I64;
           R2 = lvl29_r8PPI_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.493213728 UTC

[section ""data" . Foreign.Marshal.Array.moveArray_closure" {
     Foreign.Marshal.Array.moveArray_closure:
         const Foreign.Marshal.Array.moveArray_info;
         const 0;
 },
 lvl33_s8PUZ_entry() //  [R1]
         { info_tbl: [(c8QwM,
                       label: lvl33_s8PUZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QwM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QwN; else goto c8QwO;
       c8QwN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QwO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.moveArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PVi_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c8QwX,
                       label: sat_s8PVi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QwX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Qxb; else goto c8Qxc;
       c8Qxb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Qxc: // global
           I64[Sp - 32] = block_c8QwU_info;
           _s8PUZ::P64 = P64[R1 + 4];
           R1 = R2;
           P64[Sp - 24] = _s8PUZ::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8Qxw; else goto c8QwV;
       u8Qxw: // global
           call _c8QwU(R1) args: 0, res: 0, upd: 0;
       c8QwV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QwU() //  [R1]
         { info_tbl: [(c8QwU,
                       label: block_c8QwU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QwU: // global
           I64[Sp] = block_c8Qx0_info;
           _s8PV5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8PV5::I64;
           if (R1 & 7 != 0) goto u8Qxv; else goto c8Qx1;
       u8Qxv: // global
           call _c8Qx0(R1) args: 0, res: 0, upd: 0;
       c8Qx1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qx0() //  [R1]
         { info_tbl: [(c8Qx0,
                       label: block_c8Qx0_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qx0: // global
           I64[Sp] = block_c8Qx5_info;
           _s8PV7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s8PV7::I64;
           if (R1 & 7 != 0) goto u8Qxx; else goto c8Qx6;
       u8Qxx: // global
           call _c8Qx5(R1) args: 0, res: 0, upd: 0;
       c8Qx6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qx5() //  [R1]
         { info_tbl: [(c8Qx5,
                       label: block_c8Qx5_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qx5: // global
           I64[Sp] = block_c8Qxa_info;
           _s8PV9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PV9::I64;
           if (R1 & 7 != 0) goto u8Qxy; else goto c8Qxg;
       u8Qxy: // global
           call _c8Qxa(R1) args: 0, res: 0, upd: 0;
       c8Qxg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qxa() //  [R1]
         { info_tbl: [(c8Qxa,
                       label: block_c8Qxa_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qxa: // global
           (_s8PVh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(I64[Sp + 16], I64[Sp + 24], I64[Sp + 8] * I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.moveArray_entry() //  [R2]
         { info_tbl: [(c8Qxz,
                       label: Foreign.Marshal.Array.moveArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qxz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8QxD; else goto c8QxC;
       c8QxD: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.moveArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8QxC: // global
           I64[Hp - 32] = lvl33_s8PUZ_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8PVi_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.496554433 UTC

[section ""data" . Foreign.Marshal.Array.lengthArray1_closure" {
     Foreign.Marshal.Array.lengthArray1_closure:
         const Foreign.Marshal.Array.lengthArray1_info;
 },
 sat_s8PVy_entry() //  [R1]
         { info_tbl: [(c8Qy0,
                       label: sat_s8PVy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qy0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Qy7; else goto c8Qy8;
       c8Qy7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Qy8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8QxX_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Qyc; else goto c8QxY;
       u8Qyc: // global
           call _c8QxX(R1) args: 0, res: 0, upd: 0;
       c8QxY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8QxX() //  [R1]
         { info_tbl: [(c8QxX,
                       label: block_c8QxX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QxX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Qyb; else goto c8Qya;
       c8Qyb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8Qya: // global
           _s8PVx::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8PVx::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Array.lengthArray1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8Qyd,
                       label: Foreign.Marshal.Array.lengthArray1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qyd: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c8Qye; else goto c8Qyf;
       c8Qye: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.lengthArray1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Qyf: // global
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = Foreign.Marshal.Array.lengthArray2_closure+1;
           Sp = Sp - 40;
           call _c8QxL() args: 0, res: 0, upd: 0;
     }
 },
 _c8QxL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QxL: // global
           I64[Sp - 8] = block_c8QxN_info;
           R2 = P64[Sp];
           I64[Sp - 32] = stg_ap_ppv_info;
           P64[Sp - 24] = P64[Sp + 24];
           P64[Sp - 16] = P64[Sp + 32];
           Sp = Sp - 32;
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8QxN() //  [R1]
         { info_tbl: [(c8QxN,
                       label: block_c8QxN_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QxN: // global
           I64[Sp] = block_c8QxP_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R1;
           P64[Sp - 8] = P64[Sp + 24];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8QxP() //  [R1]
         { info_tbl: [(c8QxP,
                       label: block_c8QxP_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QxP: // global
           _s8PVp::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto c8Qyj; else goto c8Qyq;
       c8Qyj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Qym; else goto c8Qyl;
       c8Qym: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Qyl: // global
           I64[Hp - 16] = sat_s8PVy_info;
           P64[Hp] = _s8PVp::P64;
           P64[Sp + 40] = Hp - 16;
           Sp = Sp + 8;
           call _c8QxL() args: 0, res: 0, upd: 0;
       c8Qyq: // global
           R1 = _s8PVp::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.498836925 UTC

[section ""data" . Foreign.Marshal.Array.lengthArray0_closure" {
     Foreign.Marshal.Array.lengthArray0_closure:
         const Foreign.Marshal.Array.lengthArray0_info;
 },
 Foreign.Marshal.Array.lengthArray0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8QyA,
                       label: Foreign.Marshal.Array.lengthArray0_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QyA: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.lengthArray1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.499825152 UTC

[section ""data" . Foreign.Marshal.Array.peekArray2_closure" {
     Foreign.Marshal.Array.peekArray2_closure:
         const Foreign.Marshal.Array.peekArray2_info;
 },
 Foreign.Marshal.Array.peekArray2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8QyJ,
                       label: Foreign.Marshal.Array.peekArray2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QyJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8QyK; else goto c8QyL;
       c8QyK: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.peekArray2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QyL: // global
           I64[Sp - 24] = block_c8QyH_info;
           _s8PVC::P64 = R5;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           _s8PVz::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s8PVz::P64;
           P64[Sp - 8] = _s8PVC::P64;
           Sp = Sp - 24;
           call Foreign.Marshal.Array.lengthArray1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8QyH() //  [R1]
         { info_tbl: [(c8QyH,
                       label: block_c8QyH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QyH: // global
           R4 = P64[Sp + 16];
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Array.peekArray1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.501022493 UTC

[section ""data" . Foreign.Marshal.Array.peekArray0_closure" {
     Foreign.Marshal.Array.peekArray0_closure:
         const Foreign.Marshal.Array.peekArray0_info;
 },
 Foreign.Marshal.Array.peekArray0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8QyR,
                       label: Foreign.Marshal.Array.peekArray0_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QyR: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.peekArray2_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.501809573 UTC

[section ""data" . lvl30_r8PPJ_closure" {
     lvl30_r8PPJ_closure:
         const GHC.Types.I#_con_info;
         const 276;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.502433532 UTC

[section ""data" . lvl31_r8PPK_closure" {
     lvl31_r8PPK_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl30_r8PPJ_closure+1;
         const lvl7_r8PPm_closure+1;
         const lvl30_r8PPJ_closure+1;
         const lvl8_r8PPn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.503128182 UTC

[section ""data" . lvl32_r8PPL_closure" {
     lvl32_r8PPL_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl31_r8PPK_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.503971753 UTC

[section ""data" . Foreign.Marshal.Array.advancePtr1_closure" {
     Foreign.Marshal.Array.advancePtr1_closure:
         const Foreign.Marshal.Array.advancePtr1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.advancePtr1_entry() //  [R1]
         { info_tbl: [(c8Qz0,
                       label: Foreign.Marshal.Array.advancePtr1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qz0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Qz1; else goto c8Qz2;
       c8Qz1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Qz2: // global
           (_c8QyX::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8QyX::I64 == 0) goto c8QyZ; else goto c8QyY;
       c8QyZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8QyY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8QyX::I64;
           R2 = lvl32_r8PPL_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.505743871 UTC

[section ""data" . Foreign.Marshal.Array.advancePtr_closure" {
     Foreign.Marshal.Array.advancePtr_closure:
         const Foreign.Marshal.Array.advancePtr_info;
         const 0;
 },
 lvl33_s8PVI_entry() //  [R1]
         { info_tbl: [(c8Qzb,
                       label: lvl33_s8PVI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qzb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Qzc; else goto c8Qzd;
       c8Qzc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Qzd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.advancePtr1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PVT_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Qzm,
                       label: sat_s8PVT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qzm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8QzG; else goto c8QzH;
       c8QzG: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QzH: // global
           I64[Sp - 24] = block_c8Qzj_info;
           _s8PVI::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s8PVI::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8QzO; else goto c8Qzk;
       u8QzO: // global
           call _c8Qzj(R1) args: 0, res: 0, upd: 0;
       c8Qzk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qzj() //  [R1]
         { info_tbl: [(c8Qzj,
                       label: block_c8Qzj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qzj: // global
           I64[Sp] = block_c8Qzp_info;
           _s8PVM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8PVM::I64;
           if (R1 & 7 != 0) goto u8QzN; else goto c8Qzq;
       u8QzN: // global
           call _c8Qzp(R1) args: 0, res: 0, upd: 0;
       c8Qzq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qzp() //  [R1]
         { info_tbl: [(c8Qzp,
                       label: block_c8Qzp_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qzp: // global
           I64[Sp] = block_c8Qzu_info;
           _s8PVO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PVO::I64;
           if (R1 & 7 != 0) goto u8QzP; else goto c8Qzv;
       u8QzP: // global
           call _c8Qzu(R1) args: 0, res: 0, upd: 0;
       c8Qzv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Qzu() //  [R1]
         { info_tbl: [(c8Qzu,
                       label: block_c8Qzu_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Qzu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QzM; else goto c8QzL;
       c8QzM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8QzL: // global
           _s8PVS::I64 = I64[Sp + 16] + I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PVS::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.advancePtr_entry() //  [R2]
         { info_tbl: [(c8QzQ,
                       label: Foreign.Marshal.Array.advancePtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QzQ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8QzU; else goto c8QzT;
       c8QzU: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.advancePtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8QzT: // global
           I64[Hp - 32] = lvl33_s8PVI_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8PVT_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.508015906 UTC

[section ""data" . Foreign.Marshal.Array.$trModule3_closure" {
     Foreign.Marshal.Array.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Array.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.508632317 UTC

[section ""data" . Foreign.Marshal.Array.$trModule1_closure" {
     Foreign.Marshal.Array.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Array.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.509535163 UTC

[section ""data" . Foreign.Marshal.Array.$trModule_closure" {
     Foreign.Marshal.Array.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Marshal.Array.$trModule3_closure+1;
         const Foreign.Marshal.Array.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.51013842 UTC

[section ""relreadonly" . S8PWD_srt" {
     S8PWD_srt:
         const GHC.Err.undefined_closure;
         const lvl10_r8PPp_closure;
         const Foreign.Marshal.Array.mallocArray1_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Array.mallocArray_closure;
         const Foreign.Marshal.Array.$wmallocArray0_closure;
         const Foreign.Marshal.Array.mallocArray2_closure;
         const lvl13_r8PPs_closure;
         const Foreign.Marshal.Array.callocArray1_closure;
         const Foreign.Marshal.Alloc.calloc1_closure;
         const Foreign.Marshal.Array.callocArray_closure;
         const Foreign.Marshal.Array.$wcallocArray0_closure;
         const Foreign.Marshal.Array.callocArray2_closure;
         const lvl16_r8PPv_closure;
         const Foreign.Marshal.Array.allocaArray1_closure;
         const Foreign.Marshal.Array.allocaArray_closure;
         const Foreign.Marshal.Array.allocaArray0_closure;
         const lvl21_r8PPA_closure;
         const Foreign.Marshal.Array.reallocArray1_closure;
         const Foreign.Marshal.Alloc.realloc2_closure;
         const Foreign.Marshal.Array.reallocArray_closure;
         const Foreign.Marshal.Array.$wreallocArray0_closure;
         const Foreign.Marshal.Array.reallocArray2_closure;
         const Foreign.Marshal.Array.withArrayLen_closure;
         const Foreign.Marshal.Array.withArray_closure;
         const Foreign.Marshal.Array.newArray1_closure;
         const Foreign.Marshal.Array.withArrayLen0_closure;
         const Foreign.Marshal.Array.withArray0_closure;
         const Foreign.Marshal.Array.newArray3_closure;
         const lvl26_r8PPF_closure;
         const Foreign.Marshal.Array.copyArray1_closure;
         const Foreign.Marshal.Array.copyArray_closure;
         const lvl29_r8PPI_closure;
         const GHC.Err.undefined_closure;
         const Foreign.Marshal.Array.moveArray1_closure;
         const Foreign.Marshal.Array.moveArray_closure;
         const lvl32_r8PPL_closure;
         const Foreign.Marshal.Array.advancePtr1_closure;
         const Foreign.Marshal.Array.advancePtr_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.511457209 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:03:59.512702457 UTC

[section ""cstring" . lvl_r8PPf_bytes" {
     lvl_r8PPf_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.514911785 UTC

[section ""data" . lvl1_r8PPg_closure" {
     lvl1_r8PPg_closure:
         const lvl1_r8PPg_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r8PPg_entry() //  [R1]
         { info_tbl: [(c8QA2,
                       label: lvl1_r8PPg_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QA2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8QA3; else goto c8QA4;
       c8QA3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QA4: // global
           (_c8QzZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8QzZ::I64 == 0) goto c8QA1; else goto c8QA0;
       c8QA1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8QA0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8QzZ::I64;
           R2 = lvl_r8PPf_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.52016936 UTC

[section ""cstring" . Foreign.Marshal.Array.$trModule4_bytes" {
     Foreign.Marshal.Array.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.522242852 UTC

[section ""data" . lvl2_r8PPh_closure" {
     lvl2_r8PPh_closure:
         const lvl2_r8PPh_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r8PPh_entry() //  [R1]
         { info_tbl: [(c8QAj,
                       label: lvl2_r8PPh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QAj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8QAk; else goto c8QAl;
       c8QAk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QAl: // global
           (_c8QAg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8QAg::I64 == 0) goto c8QAi; else goto c8QAh;
       c8QAi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8QAh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8QAg::I64;
           R2 = Foreign.Marshal.Array.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.526514094 UTC

[section ""cstring" . Foreign.Marshal.Array.$trModule2_bytes" {
     Foreign.Marshal.Array.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,65,114,114,97,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.528588145 UTC

[section ""data" . lvl3_r8PPi_closure" {
     lvl3_r8PPi_closure:
         const lvl3_r8PPi_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r8PPi_entry() //  [R1]
         { info_tbl: [(c8QAA,
                       label: lvl3_r8PPi_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QAA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8QAB; else goto c8QAC;
       c8QAB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QAC: // global
           (_c8QAx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8QAx::I64 == 0) goto c8QAz; else goto c8QAy;
       c8QAz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8QAy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8QAx::I64;
           R2 = Foreign.Marshal.Array.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.53281718 UTC

[section ""cstring" . lvl4_r8PPj_bytes" {
     lvl4_r8PPj_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,77,97,114,115,104,97,108,47,65,114,114,97,121,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.534891149 UTC

[section ""data" . lvl5_r8PPk_closure" {
     lvl5_r8PPk_closure:
         const lvl5_r8PPk_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r8PPk_entry() //  [R1]
         { info_tbl: [(c8QAR,
                       label: lvl5_r8PPk_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QAR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8QAS; else goto c8QAT;
       c8QAS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QAT: // global
           (_c8QAO::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8QAO::I64 == 0) goto c8QAQ; else goto c8QAP;
       c8QAQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8QAP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8QAO::I64;
           R2 = lvl4_r8PPj_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.539070169 UTC

[section ""data" . lvl6_r8PPl_closure" {
     lvl6_r8PPl_closure:
         const GHC.Types.I#_con_info;
         const 86;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.541636496 UTC

[section ""data" . lvl7_r8PPm_closure" {
     lvl7_r8PPm_closure:
         const GHC.Types.I#_con_info;
         const 25;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.543313314 UTC

[section ""data" . lvl8_r8PPn_closure" {
     lvl8_r8PPn_closure:
         const GHC.Types.I#_con_info;
         const 34;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.545141147 UTC

[section ""data" . lvl9_r8PPo_closure" {
     lvl9_r8PPo_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl6_r8PPl_closure+1;
         const lvl7_r8PPm_closure+1;
         const lvl6_r8PPl_closure+1;
         const lvl8_r8PPn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.54749534 UTC

[section ""data" . lvl10_r8PPp_closure" {
     lvl10_r8PPp_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl9_r8PPo_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.549725531 UTC

[section ""data" . Foreign.Marshal.Array.mallocArray1_closure" {
     Foreign.Marshal.Array.mallocArray1_closure:
         const Foreign.Marshal.Array.mallocArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.mallocArray1_entry() //  [R1]
         { info_tbl: [(c8QBc,
                       label: Foreign.Marshal.Array.mallocArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QBc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8QBd; else goto c8QBe;
       c8QBd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QBe: // global
           (_c8QB9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8QB9::I64 == 0) goto c8QBb; else goto c8QBa;
       c8QBb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8QBa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8QB9::I64;
           R2 = lvl10_r8PPp_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.555137211 UTC

[section ""data" . Foreign.Marshal.Array.mallocArray_closure" {
     Foreign.Marshal.Array.mallocArray_closure:
         const Foreign.Marshal.Array.mallocArray_info;
         const 0;
 },
 lvl33_s8PPO_entry() //  [R1]
         { info_tbl: [(c8QBu,
                       label: lvl33_s8PPO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QBu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QBv; else goto c8QBw;
       c8QBv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QBw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.mallocArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PQ3_entry() //  [R1, R2]
         { info_tbl: [(c8QBF,
                       label: sat_s8PQ3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QBF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8QBJ; else goto c8QBK;
       c8QBJ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8QBK: // global
           I64[Sp - 16] = block_c8QBC_info;
           _s8PPO::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _s8PPO::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8QC9; else goto c8QBD;
       u8QC9: // global
           call _c8QBC(R1) args: 0, res: 0, upd: 0;
       c8QBD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QBC() //  [R1]
         { info_tbl: [(c8QBC,
                       label: block_c8QBC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QBC: // global
           I64[Sp] = block_c8QBI_info;
           _s8PPS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PPS::I64;
           if (R1 & 7 != 0) goto u8QC8; else goto c8QBM;
       u8QC8: // global
           call _c8QBI(R1) args: 0, res: 0, upd: 0;
       c8QBM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QBI() //  [R1]
         { info_tbl: [(c8QBI,
                       label: block_c8QBI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QBI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QBS; else goto c8QBR;
       c8QBS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8QBR: // global
           (_s8PQ0::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[Sp + 8] * I64[R1 + 7]);
           if (_s8PQ0::I64 == 0) goto c8QC7; else goto c8QC6;
       c8QC7: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8QC6: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PQ0::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.mallocArray_entry() //  [R2]
         { info_tbl: [(c8QCa,
                       label: Foreign.Marshal.Array.mallocArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QCa: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8QCe; else goto c8QCd;
       c8QCe: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.mallocArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8QCd: // global
           I64[Hp - 32] = lvl33_s8PPO_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8PQ3_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.569449472 UTC

[section ""data" . Foreign.Marshal.Array.$wmallocArray0_closure" {
     Foreign.Marshal.Array.$wmallocArray0_closure:
         const Foreign.Marshal.Array.$wmallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.$wmallocArray0_entry() //  [R2, R3]
         { info_tbl: [(c8QCK,
                       label: Foreign.Marshal.Array.$wmallocArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QCK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QCL; else goto c8QCM;
       c8QCL: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.$wmallocArray0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QCM: // global
           I64[Sp - 16] = block_c8QCI_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.mallocArray1_closure;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8QCI() //  [R1]
         { info_tbl: [(c8QCI,
                       label: block_c8QCI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QCI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QCR; else goto c8QCQ;
       c8QCR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8QCQ: // global
           (_s8PQf::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc((I64[Sp + 8] + 1) * I64[R1 + 7]);
           if (_s8PQf::I64 == 0) goto c8QD9; else goto c8QD8;
       c8QD9: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8QD8: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PQf::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.576337944 UTC

[section ""data" . Foreign.Marshal.Array.mallocArray2_closure" {
     Foreign.Marshal.Array.mallocArray2_closure:
         const Foreign.Marshal.Array.mallocArray2_info;
         const 0;
 },
 Foreign.Marshal.Array.mallocArray2_entry() //  [R2, R3]
         { info_tbl: [(c8QDt,
                       label: Foreign.Marshal.Array.mallocArray2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QDt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8QDu; else goto c8QDv;
       c8QDu: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.mallocArray2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QDv: // global
           I64[Sp - 16] = block_c8QDq_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8QDz; else goto c8QDr;
       u8QDz: // global
           call _c8QDq(R1) args: 0, res: 0, upd: 0;
       c8QDr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QDq() //  [R1]
         { info_tbl: [(c8QDq,
                       label: block_c8QDq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QDq: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.Marshal.Array.$wmallocArray0_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.582428967 UTC

[section ""data" . Foreign.Marshal.Array.mallocArray0_closure" {
     Foreign.Marshal.Array.mallocArray0_closure:
         const Foreign.Marshal.Array.mallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.mallocArray0_entry() //  [R2, R3]
         { info_tbl: [(c8QDN,
                       label: Foreign.Marshal.Array.mallocArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QDN: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.mallocArray2_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.58646491 UTC

[section ""data" . lvl11_r8PPq_closure" {
     lvl11_r8PPq_closure:
         const GHC.Types.I#_con_info;
         const 100;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.588407627 UTC

[section ""data" . lvl12_r8PPr_closure" {
     lvl12_r8PPr_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl11_r8PPq_closure+1;
         const lvl7_r8PPm_closure+1;
         const lvl11_r8PPq_closure+1;
         const lvl8_r8PPn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.591142256 UTC

[section ""data" . lvl13_r8PPs_closure" {
     lvl13_r8PPs_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl12_r8PPr_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.593258351 UTC

[section ""data" . Foreign.Marshal.Array.callocArray1_closure" {
     Foreign.Marshal.Array.callocArray1_closure:
         const Foreign.Marshal.Array.callocArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.callocArray1_entry() //  [R1]
         { info_tbl: [(c8QE3,
                       label: Foreign.Marshal.Array.callocArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QE3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8QE4; else goto c8QE5;
       c8QE4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QE5: // global
           (_c8QE0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8QE0::I64 == 0) goto c8QE2; else goto c8QE1;
       c8QE2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8QE1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8QE0::I64;
           R2 = lvl13_r8PPs_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.598447466 UTC

[section ""data" . Foreign.Marshal.Array.callocArray_closure" {
     Foreign.Marshal.Array.callocArray_closure:
         const Foreign.Marshal.Array.callocArray_info;
         const 0;
 },
 lvl33_s8PQo_entry() //  [R1]
         { info_tbl: [(c8QEl,
                       label: lvl33_s8PQo_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QEl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QEm; else goto c8QEn;
       c8QEm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QEn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.callocArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PQD_entry() //  [R1, R2]
         { info_tbl: [(c8QEw,
                       label: sat_s8PQD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QEw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8QEA; else goto c8QEB;
       c8QEA: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8QEB: // global
           I64[Sp - 16] = block_c8QEt_info;
           _s8PQo::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _s8PQo::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8QF1; else goto c8QEu;
       u8QF1: // global
           call _c8QEt(R1) args: 0, res: 0, upd: 0;
       c8QEu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QEt() //  [R1]
         { info_tbl: [(c8QEt,
                       label: block_c8QEt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QEt: // global
           I64[Sp] = block_c8QEz_info;
           _s8PQs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PQs::I64;
           if (R1 & 7 != 0) goto u8QF0; else goto c8QED;
       u8QF0: // global
           call _c8QEz(R1) args: 0, res: 0, upd: 0;
       c8QED: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QEz() //  [R1]
         { info_tbl: [(c8QEz,
                       label: block_c8QEz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QEz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QEJ; else goto c8QEI;
       c8QEJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8QEI: // global
           (_s8PQA::I64) = call "ccall" arg hints:  [,]  result hints:  [PtrHint] calloc(1, I64[Sp + 8] * I64[R1 + 7]);
           if (_s8PQA::I64 == 0) goto c8QEZ; else goto c8QEY;
       c8QEZ: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.calloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8QEY: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PQA::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.callocArray_entry() //  [R2]
         { info_tbl: [(c8QF2,
                       label: Foreign.Marshal.Array.callocArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QF2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8QF6; else goto c8QF5;
       c8QF6: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.callocArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8QF5: // global
           I64[Hp - 32] = lvl33_s8PQo_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8PQD_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.61214504 UTC

[section ""data" . Foreign.Marshal.Array.$wcallocArray0_closure" {
     Foreign.Marshal.Array.$wcallocArray0_closure:
         const Foreign.Marshal.Array.$wcallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.$wcallocArray0_entry() //  [R2, R3]
         { info_tbl: [(c8QFC,
                       label: Foreign.Marshal.Array.$wcallocArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QFC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QFD; else goto c8QFE;
       c8QFD: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.$wcallocArray0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QFE: // global
           I64[Sp - 16] = block_c8QFA_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.callocArray1_closure;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8QFA() //  [R1]
         { info_tbl: [(c8QFA,
                       label: block_c8QFA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QFA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QFJ; else goto c8QFI;
       c8QFJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8QFI: // global
           (_s8PQP::I64) = call "ccall" arg hints:  [,]  result hints:  [PtrHint] calloc(1, (I64[Sp + 8] + 1) * I64[R1 + 7]);
           if (_s8PQP::I64 == 0) goto c8QG2; else goto c8QG1;
       c8QG2: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.calloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8QG1: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PQP::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.619250223 UTC

[section ""data" . Foreign.Marshal.Array.callocArray2_closure" {
     Foreign.Marshal.Array.callocArray2_closure:
         const Foreign.Marshal.Array.callocArray2_info;
         const 0;
 },
 Foreign.Marshal.Array.callocArray2_entry() //  [R2, R3]
         { info_tbl: [(c8QGm,
                       label: Foreign.Marshal.Array.callocArray2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QGm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8QGn; else goto c8QGo;
       c8QGn: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.callocArray2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QGo: // global
           I64[Sp - 16] = block_c8QGj_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8QGs; else goto c8QGk;
       u8QGs: // global
           call _c8QGj(R1) args: 0, res: 0, upd: 0;
       c8QGk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QGj() //  [R1]
         { info_tbl: [(c8QGj,
                       label: block_c8QGj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QGj: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.Marshal.Array.$wcallocArray0_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.624829266 UTC

[section ""data" . Foreign.Marshal.Array.callocArray0_closure" {
     Foreign.Marshal.Array.callocArray0_closure:
         const Foreign.Marshal.Array.callocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.callocArray0_entry() //  [R2, R3]
         { info_tbl: [(c8QGG,
                       label: Foreign.Marshal.Array.callocArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QGG: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.callocArray2_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.628438836 UTC

[section ""data" . lvl14_r8PPt_closure" {
     lvl14_r8PPt_closure:
         const GHC.Types.I#_con_info;
         const 115;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.63068202 UTC

[section ""data" . lvl15_r8PPu_closure" {
     lvl15_r8PPu_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl14_r8PPt_closure+1;
         const lvl7_r8PPm_closure+1;
         const lvl14_r8PPt_closure+1;
         const lvl8_r8PPn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.632569041 UTC

[section ""data" . lvl16_r8PPv_closure" {
     lvl16_r8PPv_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl15_r8PPu_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.638729804 UTC

[section ""data" . Foreign.Marshal.Array.allocaArray1_closure" {
     Foreign.Marshal.Array.allocaArray1_closure:
         const Foreign.Marshal.Array.allocaArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.allocaArray1_entry() //  [R1]
         { info_tbl: [(c8QGW,
                       label: Foreign.Marshal.Array.allocaArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QGW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8QGX; else goto c8QGY;
       c8QGX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QGY: // global
           (_c8QGT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8QGT::I64 == 0) goto c8QGV; else goto c8QGU;
       c8QGV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8QGU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8QGT::I64;
           R2 = lvl16_r8PPv_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.646834545 UTC

[section ""data" . Foreign.Marshal.Array.allocaArray_closure" {
     Foreign.Marshal.Array.allocaArray_closure:
         const Foreign.Marshal.Array.allocaArray_info;
         const 0;
 },
 lvl33_s8PQY_entry() //  [R1]
         { info_tbl: [(c8QHe,
                       label: lvl33_s8PQY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QHe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QHf; else goto c8QHg;
       c8QHf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QHg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.allocaArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds1_s8PQZ_entry() //  [R1]
         { info_tbl: [(c8QHl,
                       label: ds1_s8PQZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QHl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QHm; else goto c8QHn;
       c8QHm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QHn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.allocaArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.alignment_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PRm_entry() //  [R1, R2, R3]
         { info_tbl: [(c8QHw,
                       label: sat_s8PRm_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QHw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QHF; else goto c8QHG;
       c8QHF: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QHG: // global
           I64[Sp - 32] = block_c8QHt_info;
           _s8PQY::P64 = P64[R1 + 5];
           _s8PQZ::P64 = P64[R1 + 13];
           R1 = R2;
           P64[Sp - 24] = _s8PQY::P64;
           P64[Sp - 16] = _s8PQZ::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8QI5; else goto c8QHu;
       u8QI5: // global
           call _c8QHt(R1) args: 0, res: 0, upd: 0;
       c8QHu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QHt() //  [R1]
         { info_tbl: [(c8QHt,
                       label: block_c8QHt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QHt: // global
           I64[Sp] = block_c8QHz_info;
           _s8PR4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PR4::I64;
           if (R1 & 7 != 0) goto u8QI4; else goto c8QHA;
       u8QI4: // global
           call _c8QHz(R1) args: 0, res: 0, upd: 0;
       c8QHA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QHz() //  [R1]
         { info_tbl: [(c8QHz,
                       label: block_c8QHz_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QHz: // global
           I64[Sp] = block_c8QHE_info;
           _s8PR6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8PR6::I64;
           if (R1 & 7 != 0) goto u8QI6; else goto c8QHJ;
       u8QI6: // global
           call _c8QHE(R1) args: 0, res: 0, upd: 0;
       c8QHJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QHE() //  [R1]
         { info_tbl: [(c8QHE,
                       label: block_c8QHE_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QHE: // global
           _s8PR9::I64 = I64[Sp + 8] * I64[Sp + 16];
           I64[Sp + 16] = block_c8QHR_info;
           R2 = I64[R1 + 7];
           R1 = _s8PR9::I64;
           Sp = Sp + 16;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QHR() //  [R1]
         { info_tbl: [(c8QHR,
                       label: block_c8QHR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QHR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QHV; else goto c8QHU;
       c8QHV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8QHU: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           P64[Hp] = R1 + 16;
           I64[Sp] = block_c8QI0_info;
           R2 = Hp - 7;
           _s8PRf::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8PRf::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QI0() //  [R1]
         { info_tbl: [(c8QI0,
                       label: block_c8QI0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QI0: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.allocaArray_entry() //  [R2]
         { info_tbl: [(c8QI7,
                       label: Foreign.Marshal.Array.allocaArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QI7: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8QIb; else goto c8QIa;
       c8QIb: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Foreign.Marshal.Array.allocaArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8QIa: // global
           I64[Hp - 64] = lvl33_s8PQY_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = ds1_s8PQZ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s8PRm_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 13;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.668980101 UTC

[section ""data" . Foreign.Marshal.Array.allocaArray0_closure" {
     Foreign.Marshal.Array.allocaArray0_closure:
         const Foreign.Marshal.Array.allocaArray0_info;
         const 0;
 },
 sat_s8PRs_entry() //  [R1]
         { info_tbl: [(c8QJ1,
                       label: sat_s8PRs_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QJ1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8QJ8; else goto c8QJ9;
       c8QJ8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QJ9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8QIY_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8QJd; else goto c8QIZ;
       u8QJd: // global
           call _c8QIY(R1) args: 0, res: 0, upd: 0;
       c8QIZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8QIY() //  [R1]
         { info_tbl: [(c8QIY,
                       label: block_c8QIY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QIY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QJc; else goto c8QJb;
       c8QJc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8QJb: // global
           _s8PRr::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8PRr::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Array.allocaArray0_entry() //  [R2, R3]
         { info_tbl: [(c8QJe,
                       label: Foreign.Marshal.Array.allocaArray0_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QJe: // global
           _s8PRo::P64 = R3;
           _s8PRn::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c8QJf; else goto c8QJg;
       c8QJg: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8QJi; else goto c8QJh;
       c8QJi: // global
           HpAlloc = 24;
           goto c8QJf;
       c8QJf: // global
           R3 = _s8PRo::P64;
           R2 = _s8PRn::P64;
           R1 = Foreign.Marshal.Array.allocaArray0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QJh: // global
           I64[Hp - 16] = sat_s8PRs_info;
           P64[Hp] = _s8PRo::P64;
           R2 = _s8PRn::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Foreign.Marshal.Array.allocaArray_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.677802527 UTC

[section ""data" . lvl17_r8PPw_closure" {
     lvl17_r8PPw_closure:
         const GHC.Types.I#_con_info;
         const 133;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.67963468 UTC

[section ""data" . lvl18_r8PPx_closure" {
     lvl18_r8PPx_closure:
         const GHC.Types.I#_con_info;
         const 27;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.681492015 UTC

[section ""data" . lvl19_r8PPy_closure" {
     lvl19_r8PPy_closure:
         const GHC.Types.I#_con_info;
         const 36;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.683370292 UTC

[section ""data" . lvl20_r8PPz_closure" {
     lvl20_r8PPz_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl17_r8PPw_closure+1;
         const lvl18_r8PPx_closure+1;
         const lvl17_r8PPw_closure+1;
         const lvl19_r8PPy_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.685691517 UTC

[section ""data" . lvl21_r8PPA_closure" {
     lvl21_r8PPA_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl20_r8PPz_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.687939648 UTC

[section ""data" . Foreign.Marshal.Array.reallocArray1_closure" {
     Foreign.Marshal.Array.reallocArray1_closure:
         const Foreign.Marshal.Array.reallocArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.reallocArray1_entry() //  [R1]
         { info_tbl: [(c8QJK,
                       label: Foreign.Marshal.Array.reallocArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QJK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8QJL; else goto c8QJM;
       c8QJL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QJM: // global
           (_c8QJH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8QJH::I64 == 0) goto c8QJJ; else goto c8QJI;
       c8QJJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8QJI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8QJH::I64;
           R2 = lvl21_r8PPA_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.69390163 UTC

[section ""data" . Foreign.Marshal.Array.reallocArray_closure" {
     Foreign.Marshal.Array.reallocArray_closure:
         const Foreign.Marshal.Array.reallocArray_info;
         const 0;
 },
 lvl33_s8PRu_entry() //  [R1]
         { info_tbl: [(c8QK2,
                       label: lvl33_s8PRu_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QK2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QK3; else goto c8QK4;
       c8QK3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QK4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.reallocArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PRP_entry() //  [R1, R2, R3]
         { info_tbl: [(c8QKd,
                       label: sat_s8PRP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QKd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8QKm; else goto c8QKn;
       c8QKm: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QKn: // global
           I64[Sp - 24] = block_c8QKa_info;
           _s8PRu::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s8PRu::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8QL4; else goto c8QKb;
       u8QL4: // global
           call _c8QKa(R1) args: 0, res: 0, upd: 0;
       c8QKb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QKa() //  [R1]
         { info_tbl: [(c8QKa,
                       label: block_c8QKa_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QKa: // global
           I64[Sp] = block_c8QKg_info;
           _s8PRz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PRz::I64;
           if (R1 & 7 != 0) goto u8QL3; else goto c8QKh;
       u8QL3: // global
           call _c8QKg(R1) args: 0, res: 0, upd: 0;
       c8QKh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QKg() //  [R1]
         { info_tbl: [(c8QKg,
                       label: block_c8QKg_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QKg: // global
           I64[Sp] = block_c8QKl_info;
           _s8PRB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8PRB::I64;
           if (R1 & 7 != 0) goto u8QL5; else goto c8QKq;
       u8QL5: // global
           call _c8QKl(R1) args: 0, res: 0, upd: 0;
       c8QKq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QKl() //  [R1]
         { info_tbl: [(c8QKl,
                       label: block_c8QKl_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QKl: // global
           _s8PRD::I64 = I64[R1 + 7];
           _s8PRE::I64 = I64[Sp + 8] * I64[Sp + 16];
           if (_s8PRE::I64 != 0) goto u8QL1; else goto c8QKV;
       u8QL1: // global
           I64[Sp + 8] = _s8PRE::I64;
           I64[Sp + 16] = _s8PRD::I64;
           Sp = Sp + 8;
           call _c8QKB() args: 0, res: 0, upd: 0;
       c8QKV: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(_s8PRD::I64);
           R1 = GHC.Ptr.nullPtr_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8QKB() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QKB: // global
           Hp = Hp + 16;
           _s8PRE::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c8QKF; else goto c8QKE;
       c8QKF: // global
           HpAlloc = 16;
           I64[Sp] = block_c8QKy_info;
           R1 = _s8PRE::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8QKE: // global
           (_s8PRJ::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp + 8], _s8PRE::I64);
           if (_s8PRJ::I64 == 0) goto c8QKS; else goto c8QKR;
       c8QKS: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8QKR: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PRJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8QKy() //  [R1]
         { info_tbl: [(c8QKy,
                       label: block_c8QKy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QKy: // global
           I64[Sp] = R1;
           call _c8QKB() args: 0, res: 0, upd: 0;
     }
 },
 Foreign.Marshal.Array.reallocArray_entry() //  [R2]
         { info_tbl: [(c8QL8,
                       label: Foreign.Marshal.Array.reallocArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QL8: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8QLc; else goto c8QLb;
       c8QLc: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.reallocArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8QLb: // global
           I64[Hp - 32] = lvl33_s8PRu_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8PRP_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.713709697 UTC

[section ""data" . Foreign.Marshal.Array.$wreallocArray0_closure" {
     Foreign.Marshal.Array.$wreallocArray0_closure:
         const Foreign.Marshal.Array.$wreallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.$wreallocArray0_entry() //  [R2, R3, R4]
         { info_tbl: [(c8QLR,
                       label: Foreign.Marshal.Array.$wreallocArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 20} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QLR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8QLS; else goto c8QLT;
       c8QLS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.$wreallocArray0_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QLT: // global
           I64[Sp - 24] = block_c8QLP_info;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = Foreign.Marshal.Array.reallocArray1_closure;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8QLP() //  [R1]
         { info_tbl: [(c8QLP,
                       label: block_c8QLP_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QLP: // global
           _s8PRX::I64 = (I64[Sp + 16] + 1) * I64[R1 + 7];
           if (_s8PRX::I64 != 0) goto u8QMw; else goto c8QMq;
       u8QMw: // global
           I64[Sp + 16] = _s8PRX::I64;
           Sp = Sp + 8;
           call _c8QM6() args: 0, res: 0, upd: 0;
       c8QMq: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[Sp + 8]);
           R1 = GHC.Ptr.nullPtr_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8QM6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QM6: // global
           Hp = Hp + 16;
           _s8PRX::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c8QMa; else goto c8QM9;
       c8QMa: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c8QM3_info;
           R1 = _s8PRX::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8QM9: // global
           (_s8PS2::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp], _s8PRX::I64);
           if (_s8PS2::I64 == 0) goto c8QMn; else goto c8QMm;
       c8QMn: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8QMm: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PS2::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8QM3() //  [R1]
         { info_tbl: [(c8QM3,
                       label: block_c8QM3_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QM3: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c8QM6() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.724791513 UTC

[section ""data" . Foreign.Marshal.Array.reallocArray2_closure" {
     Foreign.Marshal.Array.reallocArray2_closure:
         const Foreign.Marshal.Array.reallocArray2_info;
         const 0;
 },
 Foreign.Marshal.Array.reallocArray2_entry() //  [R2, R3, R4]
         { info_tbl: [(c8QMZ,
                       label: Foreign.Marshal.Array.reallocArray2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QMZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8QN3; else goto c8QN4;
       c8QN3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.reallocArray2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QN4: // global
           I64[Sp - 24] = block_c8QMW_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8QNc; else goto c8QMX;
       u8QNc: // global
           call _c8QMW(R1) args: 0, res: 0, upd: 0;
       c8QMX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QMW() //  [R1]
         { info_tbl: [(c8QMW,
                       label: block_c8QMW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QMW: // global
           I64[Sp] = block_c8QN2_info;
           _s8PSd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8PSd::I64;
           if (R1 & 7 != 0) goto u8QNb; else goto c8QN6;
       u8QNb: // global
           call _c8QN2(R1) args: 0, res: 0, upd: 0;
       c8QN6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QN2() //  [R1]
         { info_tbl: [(c8QN2,
                       label: block_c8QN2_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QN2: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Array.$wreallocArray0_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.732598518 UTC

[section ""data" . Foreign.Marshal.Array.reallocArray0_closure" {
     Foreign.Marshal.Array.reallocArray0_closure:
         const Foreign.Marshal.Array.reallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.reallocArray0_entry() //  [R2, R3, R4]
         { info_tbl: [(c8QNu,
                       label: Foreign.Marshal.Array.reallocArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QNu: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.reallocArray2_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.736010965 UTC

[section ""data" . Foreign.Marshal.Array.lengthArray2_closure" {
     Foreign.Marshal.Array.lengthArray2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.738822249 UTC

[section ""data" . Foreign.Marshal.Array.$wpeekArray_closure" {
     Foreign.Marshal.Array.$wpeekArray_closure:
         const Foreign.Marshal.Array.$wpeekArray_info;
 },
 Foreign.Marshal.Array.$wpeekArray_entry() //  [R2, R3, R4]
         { info_tbl: [(c8QO2,
                       label: Foreign.Marshal.Array.$wpeekArray_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QO2: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8QO3; else goto c8QO4;
       c8QO3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.$wpeekArray_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QO4: // global
           if (%MO_S_Gt_W64(R3, 0)) goto c8QO0; else goto c8QO1;
       c8QO0: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R3 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call _c8QNQ() args: 0, res: 0, upd: 0;
       c8QO1: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8QNQ() //  []
         { info_tbl: [(c8QNQ,
                       label: block_c8QNQ_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QNQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QOh; else goto c8QOg;
       c8QOh: // global
           HpAlloc = 16;
           I64[Sp] = block_c8QNQ_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8QOg: // global
           _s8PSg::P64 = P64[Sp + 8];
           _s8PSi::P64 = P64[Sp + 16];
           _s8PSw::I64 = I64[Sp + 24];
           if (_s8PSw::I64 != 0) goto c8QOj; else goto c8QOn;
       c8QOj: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8PSw::I64;
           I64[Sp] = block_c8QNW_info;
           R2 = _s8PSg::P64;
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = _s8PSi::P64;
           P64[Sp - 8] = Hp - 7;
           I64[Sp + 24] = _s8PSw::I64;
           Sp = Sp - 24;
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 8, upd: 8;
       c8QOn: // global
           Hp = Hp - 16;
           I64[Sp + 24] = block_c8QO8_info;
           R2 = _s8PSg::P64;
           I64[Sp] = stg_ap_ppv_info;
           P64[Sp + 8] = _s8PSi::P64;
           P64[Sp + 16] = Foreign.Marshal.Array.lengthArray2_closure+1;
           P64[Sp + 32] = P64[Sp + 32];
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8QNW() //  [R1]
         { info_tbl: [(c8QNW,
                       label: block_c8QNW_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QNW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8QOm; else goto c8QOl;
       c8QOm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8QOl: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 32];
           I64[Sp + 24] = I64[Sp + 24] - 1;
           P64[Sp + 32] = Hp - 14;
           call _c8QNQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8QO8() //  [R1]
         { info_tbl: [(c8QO8,
                       label: block_c8QO8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QO8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8QOe; else goto c8QOd;
       c8QOe: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8QOd: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.749987668 UTC

[section ""data" . Foreign.Marshal.Array.peekArray1_closure" {
     Foreign.Marshal.Array.peekArray1_closure:
         const Foreign.Marshal.Array.peekArray1_info;
 },
 Foreign.Marshal.Array.peekArray1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8QOW,
                       label: Foreign.Marshal.Array.peekArray1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QOW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8QOX; else goto c8QOY;
       c8QOX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.peekArray1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QOY: // global
           I64[Sp - 24] = block_c8QOT_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8QP2; else goto c8QOU;
       u8QP2: // global
           call _c8QOT(R1) args: 0, res: 0, upd: 0;
       c8QOU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QOT() //  [R1]
         { info_tbl: [(c8QOT,
                       label: block_c8QOT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QOT: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Array.$wpeekArray_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.755979864 UTC

[section ""data" . Foreign.Marshal.Array.peekArray_closure" {
     Foreign.Marshal.Array.peekArray_closure:
         const Foreign.Marshal.Array.peekArray_info;
 },
 Foreign.Marshal.Array.peekArray_entry() //  [R2, R3, R4]
         { info_tbl: [(c8QPg,
                       label: Foreign.Marshal.Array.peekArray_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QPg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.peekArray1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.760345511 UTC

[section ""data" . Foreign.Marshal.Array.newArray2_closure" {
     Foreign.Marshal.Array.newArray2_closure:
         const Foreign.Marshal.Array.newArray2_info;
 },
 Foreign.Marshal.Array.newArray2_entry() //  [R2, R3, R4]
         { info_tbl: [(c8QPt,
                       label: Foreign.Marshal.Array.newArray2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QPt: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c8QPu; else goto c8QPv;
       c8QPu: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.newArray2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QPv: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           I64[Sp - 8] = 0;
           Sp = Sp - 32;
           call _c8QPw() args: 0, res: 0, upd: 0;
     }
 },
 _c8QPw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QPw: // global
           I64[Sp - 8] = block_c8QPz_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8QPX; else goto c8QPB;
       u8QPX: // global
           call _c8QPz(R1) args: 0, res: 0, upd: 0;
       c8QPB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QPz() //  [R1]
         { info_tbl: [(c8QPz,
                       label: block_c8QPz_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QPz: // global
           if (R1 & 7 == 1) goto c8QPH; else goto c8QPM;
       c8QPH: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8QPM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QPP; else goto c8QPO;
       c8QPP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8QPO: // global
           _s8PST::P64 = P64[R1 + 6];
           _s8PSU::P64 = P64[R1 + 14];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 32];
           I64[Sp] = block_c8QPL_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_pppv_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = Hp - 7;
           P64[Sp - 8] = _s8PST::P64;
           P64[Sp + 24] = _s8PSU::P64;
           Sp = Sp - 32;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _c8QPL() //  []
         { info_tbl: [(c8QPL,
                       label: block_c8QPL_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QPL: // global
           P64[Sp + 24] = P64[Sp + 24];
           I64[Sp + 32] = I64[Sp + 32] + 1;
           Sp = Sp + 8;
           call _c8QPw() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.770721395 UTC

[section ""data" . Foreign.Marshal.Array.pokeArray_closure" {
     Foreign.Marshal.Array.pokeArray_closure:
         const Foreign.Marshal.Array.pokeArray_info;
 },
 Foreign.Marshal.Array.pokeArray_entry() //  [R2, R3, R4]
         { info_tbl: [(c8QQo,
                       label: Foreign.Marshal.Array.pokeArray_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QQo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.newArray2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.775155322 UTC

[section ""data" . Foreign.Marshal.Array.withArrayLen_closure" {
     Foreign.Marshal.Array.withArrayLen_closure:
         const Foreign.Marshal.Array.withArrayLen_info;
         const 0;
 },
 len_s8PT3_entry() //  [R1]
         { info_tbl: [(c8QQF,
                       label: len_s8PT3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QQF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8QQJ; else goto c8QQK;
       c8QQJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QQK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8QQD_info;
           R3 = 0;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8QQD() //  [R1]
         { info_tbl: [(c8QQD,
                       label: block_c8QQD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QQD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QQN; else goto c8QQM;
       c8QQN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c8QQM: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8PTa_entry() //  [R1, R2]
         { info_tbl: [(c8QQV,
                       label: sat_s8PTa_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QQV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QQW; else goto c8QQX;
       c8QQW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8QQX: // global
           I64[Sp - 32] = block_c8QQT_info;
           R4 = P64[R1 + 14];
           R3 = R2;
           _s8PT5::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 22];
           P64[Sp - 16] = P64[R1 + 30];
           P64[Sp - 8] = _s8PT5::P64;
           Sp = Sp - 32;
           call Foreign.Marshal.Array.newArray2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8QQT() //  []
         { info_tbl: [(c8QQT,
                       label: block_c8QQT_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QQT: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.withArrayLen_entry() //  [R2, R3, R4]
         { info_tbl: [(c8QQZ,
                       label: Foreign.Marshal.Array.withArrayLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QQZ: // global
           _s8PT2::P64 = R4;
           _s8PT1::P64 = R3;
           _s8PT0::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8QR0; else goto c8QR1;
       c8QR1: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8QR3; else goto c8QR2;
       c8QR3: // global
           HpAlloc = 64;
           goto c8QR0;
       c8QR0: // global
           R4 = _s8PT2::P64;
           R3 = _s8PT1::P64;
           R2 = _s8PT0::P64;
           R1 = Foreign.Marshal.Array.withArrayLen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QR2: // global
           I64[Hp - 56] = len_s8PT3_info;
           P64[Hp - 40] = _s8PT1::P64;
           I64[Hp - 32] = sat_s8PTa_info;
           P64[Hp - 24] = _s8PT0::P64;
           P64[Hp - 16] = _s8PT1::P64;
           P64[Hp - 8] = _s8PT2::P64;
           _c8QQz::P64 = Hp - 56;
           P64[Hp] = _c8QQz::P64;
           R2 = _s8PT0::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _c8QQz::P64;
           P64[Sp - 8] = Hp - 30;
           Sp = Sp - 24;
           call Foreign.Marshal.Array.allocaArray_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.787869704 UTC

[section ""data" . Foreign.Marshal.Array.withArray_closure" {
     Foreign.Marshal.Array.withArray_closure:
         const Foreign.Marshal.Array.withArray_info;
         const 0;
 },
 sat_s8PTl_entry() //  [R1, R2]
         { info_tbl: [(c8QRC,
                       label: sat_s8PTl_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QRC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8QRD; else goto c8QRE;
       c8QRD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8QRE: // global
           I64[Sp - 24] = block_c8QRA_info;
           R4 = P64[R1 + 14];
           R3 = R2;
           _s8PTg::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = P64[R1 + 22];
           P64[Sp - 8] = _s8PTg::P64;
           Sp = Sp - 24;
           call Foreign.Marshal.Array.newArray2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8QRA() //  []
         { info_tbl: [(c8QRA,
                       label: block_c8QRA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QRA: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8PTf_entry() //  [R1]
         { info_tbl: [(c8QRM,
                       label: sat_s8PTf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QRM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8QRQ; else goto c8QRR;
       c8QRQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QRR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8QRK_info;
           R3 = 0;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8QRK() //  [R1]
         { info_tbl: [(c8QRK,
                       label: block_c8QRK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QRK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QRU; else goto c8QRT;
       c8QRU: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c8QRT: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Array.withArray_entry() //  [R2, R3, R4]
         { info_tbl: [(c8QRV,
                       label: Foreign.Marshal.Array.withArray_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QRV: // global
           _s8PTd::P64 = R4;
           _s8PTc::P64 = R3;
           _s8PTb::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8QRW; else goto c8QRX;
       c8QRX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8QRZ; else goto c8QRY;
       c8QRZ: // global
           HpAlloc = 56;
           goto c8QRW;
       c8QRW: // global
           R4 = _s8PTd::P64;
           R3 = _s8PTc::P64;
           R2 = _s8PTb::P64;
           R1 = Foreign.Marshal.Array.withArray_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QRY: // global
           I64[Hp - 48] = sat_s8PTl_info;
           P64[Hp - 40] = _s8PTb::P64;
           P64[Hp - 32] = _s8PTc::P64;
           P64[Hp - 24] = _s8PTd::P64;
           I64[Hp - 16] = sat_s8PTf_info;
           P64[Hp] = _s8PTc::P64;
           R2 = _s8PTb::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 46;
           Sp = Sp - 24;
           call Foreign.Marshal.Array.allocaArray_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.802138108 UTC

[section ""data" . Foreign.Marshal.Array.newArray1_closure" {
     Foreign.Marshal.Array.newArray1_closure:
         const Foreign.Marshal.Array.newArray1_info;
         const 0;
 },
 Foreign.Marshal.Array.newArray1_entry() //  [R2, R3]
         { info_tbl: [(c8QSt,
                       label: Foreign.Marshal.Array.newArray1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QSt: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8QSx; else goto c8QSy;
       c8QSx: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.newArray1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QSy: // global
           I64[Sp - 24] = block_c8QSr_info;
           _s8PTn::P64 = R3;
           R3 = 0;
           _s8PTm::P64 = R2;
           R2 = _s8PTn::P64;
           P64[Sp - 16] = _s8PTm::P64;
           P64[Sp - 8] = _s8PTn::P64;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8QSr() //  [R1]
         { info_tbl: [(c8QSr,
                       label: block_c8QSr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QSr: // global
           I64[Sp - 8] = block_c8QSw_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = Foreign.Marshal.Array.mallocArray1_closure;
           I64[Sp] = R1;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8QSw() //  [R1]
         { info_tbl: [(c8QSw,
                       label: block_c8QSw_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QSw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QSF; else goto c8QSE;
       c8QSF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8QSE: // global
           _s8PTm::P64 = P64[Sp + 16];
           _s8PTn::P64 = P64[Sp + 24];
           (_s8PTx::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[Sp + 8] * I64[R1 + 7]);
           if (_s8PTx::I64 == 0) goto c8QSX; else goto c8QSU;
       c8QSX: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8QSU: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PTx::I64;
           I64[Sp + 16] = block_c8QSS_info;
           R4 = _s8PTn::P64;
           _c8QSR::P64 = Hp - 7;
           R3 = _c8QSR::P64;
           R2 = _s8PTm::P64;
           P64[Sp + 24] = _c8QSR::P64;
           Sp = Sp + 16;
           call Foreign.Marshal.Array.newArray2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8QSS() //  []
         { info_tbl: [(c8QSS,
                       label: block_c8QSS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QSS: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.813709311 UTC

[section ""data" . Foreign.Marshal.Array.newArray_closure" {
     Foreign.Marshal.Array.newArray_closure:
         const Foreign.Marshal.Array.newArray_info;
         const 0;
 },
 Foreign.Marshal.Array.newArray_entry() //  [R2, R3]
         { info_tbl: [(c8QTj,
                       label: Foreign.Marshal.Array.newArray_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QTj: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.newArray1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.818555257 UTC

[section ""data" . Foreign.Marshal.Array.newArray4_closure" {
     Foreign.Marshal.Array.newArray4_closure:
         const Foreign.Marshal.Array.newArray4_info;
 },
 Foreign.Marshal.Array.newArray4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8QTy,
                       label: Foreign.Marshal.Array.newArray4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QTy: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8QTz; else goto c8QTA;
       c8QTz: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.newArray4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QTA: // global
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = 0;
           Sp = Sp - 40;
           call _c8QTH() args: 0, res: 0, upd: 0;
     }
 },
 _c8QTH() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QTH: // global
           I64[Sp - 8] = block_c8QTK_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8QUc; else goto c8QTM;
       u8QUc: // global
           call _c8QTK(R1) args: 0, res: 0, upd: 0;
       c8QTM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QTK() //  [R1]
         { info_tbl: [(c8QTK,
                       label: block_c8QTK_info
                       rep:StackRep [False, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QTK: // global
           _s8PTO::I64 = I64[Sp + 40];
           if (R1 & 7 == 1) goto c8QTS; else goto c8QTX;
       c8QTS: // global
           I64[Sp + 40] = _s8PTO::I64;
           Sp = Sp + 8;
           call _c8QTC() args: 0, res: 0, upd: 0;
       c8QTX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QU0; else goto c8QTZ;
       c8QU0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8QTZ: // global
           _s8PTR::P64 = P64[R1 + 6];
           _s8PTS::P64 = P64[R1 + 14];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8PTO::I64;
           I64[Sp] = block_c8QTW_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_pppv_info;
           P64[Sp - 24] = P64[Sp + 24];
           P64[Sp - 16] = Hp - 7;
           P64[Sp - 8] = _s8PTR::P64;
           P64[Sp + 32] = _s8PTS::P64;
           Sp = Sp - 32;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _c8QTC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QTC: // global
           Hp = Hp + 16;
           _s8PTJ::I64 = I64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto c8QTG; else goto c8QTF;
       c8QTG: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c8QTB_info;
           R1 = _s8PTJ::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8QTF: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8PTJ::I64;
           R2 = P64[Sp];
           _s8PTE::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pppv_info;
           P64[Sp + 24] = Hp - 7;
           P64[Sp + 32] = _s8PTE::P64;
           Sp = Sp + 8;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _c8QTB() //  [R1]
         { info_tbl: [(c8QTB,
                       label: block_c8QTB_info
                       rep:StackRep [False, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QTB: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _c8QTC() args: 0, res: 0, upd: 0;
     }
 },
 _c8QTW() //  []
         { info_tbl: [(c8QTW,
                       label: block_c8QTW_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QTW: // global
           P64[Sp + 32] = P64[Sp + 32];
           I64[Sp + 40] = I64[Sp + 40] + 1;
           Sp = Sp + 8;
           call _c8QTH() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.830500114 UTC

[section ""data" . Foreign.Marshal.Array.pokeArray0_closure" {
     Foreign.Marshal.Array.pokeArray0_closure:
         const Foreign.Marshal.Array.pokeArray0_info;
 },
 Foreign.Marshal.Array.pokeArray0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8QUI,
                       label: Foreign.Marshal.Array.pokeArray0_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QUI: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.newArray4_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.83493967 UTC

[section ""data" . Foreign.Marshal.Array.withArrayLen0_closure" {
     Foreign.Marshal.Array.withArrayLen0_closure:
         const Foreign.Marshal.Array.withArrayLen0_info;
         const 0;
 },
 len_s8PU2_entry() //  [R1]
         { info_tbl: [(c8QUZ,
                       label: len_s8PU2_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QUZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8QV3; else goto c8QV4;
       c8QV3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QV4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8QUX_info;
           R3 = 0;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8QUX() //  [R1]
         { info_tbl: [(c8QUX,
                       label: block_c8QUX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QUX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QV7; else goto c8QV6;
       c8QV7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c8QV6: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8PUd_entry() //  [R1, R2]
         { info_tbl: [(c8QVf,
                       label: sat_s8PUd_info
                       rep:HeapRep 5 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QVf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QVg; else goto c8QVh;
       c8QVg: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8QVh: // global
           I64[Sp - 32] = block_c8QVd_info;
           R5 = P64[R1 + 22];
           R4 = R2;
           R3 = P64[R1 + 14];
           _s8PU8::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 30];
           P64[Sp - 16] = P64[R1 + 38];
           P64[Sp - 8] = _s8PU8::P64;
           Sp = Sp - 32;
           call Foreign.Marshal.Array.newArray4_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8QVd() //  []
         { info_tbl: [(c8QVd,
                       label: block_c8QVd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QVd: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8PU7_entry() //  [R1]
         { info_tbl: [(c8QVq,
                       label: sat_s8PU7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QVq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8QVx; else goto c8QVy;
       c8QVx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QVy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8QVn_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8QVC; else goto c8QVo;
       u8QVC: // global
           call _c8QVn(R1) args: 0, res: 0, upd: 0;
       c8QVo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8QVn() //  [R1]
         { info_tbl: [(c8QVn,
                       label: block_c8QVn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QVn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QVB; else goto c8QVA;
       c8QVB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8QVA: // global
           _s8PU6::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8PU6::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Array.withArrayLen0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8QVD,
                       label: Foreign.Marshal.Array.withArrayLen0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QVD: // global
           _s8PU1::P64 = R5;
           _s8PU0::P64 = R4;
           _s8PTZ::P64 = R3;
           _s8PTY::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8QVE; else goto c8QVF;
       c8QVF: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c8QVH; else goto c8QVG;
       c8QVH: // global
           HpAlloc = 96;
           goto c8QVE;
       c8QVE: // global
           R5 = _s8PU1::P64;
           R4 = _s8PU0::P64;
           R3 = _s8PTZ::P64;
           R2 = _s8PTY::P64;
           R1 = Foreign.Marshal.Array.withArrayLen0_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QVG: // global
           I64[Hp - 88] = len_s8PU2_info;
           P64[Hp - 72] = _s8PU0::P64;
           I64[Hp - 64] = sat_s8PUd_info;
           P64[Hp - 56] = _s8PTY::P64;
           P64[Hp - 48] = _s8PTZ::P64;
           P64[Hp - 40] = _s8PU0::P64;
           P64[Hp - 32] = _s8PU1::P64;
           _c8QUT::P64 = Hp - 88;
           P64[Hp - 24] = _c8QUT::P64;
           I64[Hp - 16] = sat_s8PU7_info;
           P64[Hp] = _c8QUT::P64;
           R2 = _s8PTY::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 62;
           Sp = Sp - 24;
           call Foreign.Marshal.Array.allocaArray_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.851596901 UTC

[section ""data" . Foreign.Marshal.Array.withArray0_closure" {
     Foreign.Marshal.Array.withArray0_closure:
         const Foreign.Marshal.Array.withArray0_info;
         const 0;
 },
 sat_s8PUj_entry() //  [R1]
         { info_tbl: [(c8QWp,
                       label: sat_s8PUj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QWp: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.withArray0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8QWs,
                       label: Foreign.Marshal.Array.withArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QWs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QWw; else goto c8QWv;
       c8QWw: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.withArray0_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QWv: // global
           I64[Hp - 8] = sat_s8PUj_info;
           P64[Hp] = R5;
           R5 = Hp - 7;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.withArrayLen0_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.857884066 UTC

[section ""data" . Foreign.Marshal.Array.newArray3_closure" {
     Foreign.Marshal.Array.newArray3_closure:
         const Foreign.Marshal.Array.newArray3_info;
         const 0;
 },
 Foreign.Marshal.Array.newArray3_entry() //  [R2, R3, R4]
         { info_tbl: [(c8QWK,
                       label: Foreign.Marshal.Array.newArray3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QWK: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8QWO; else goto c8QWP;
       c8QWO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.newArray3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QWP: // global
           I64[Sp - 32] = block_c8QWI_info;
           _s8PUl::P64 = R3;
           R3 = 0;
           _s8PUk::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _s8PUk::P64;
           P64[Sp - 16] = _s8PUl::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8QWI() //  [R1]
         { info_tbl: [(c8QWI,
                       label: block_c8QWI_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QWI: // global
           I64[Sp - 8] = block_c8QWN_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = Foreign.Marshal.Array.mallocArray1_closure;
           I64[Sp] = R1;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8QWN() //  [R1]
         { info_tbl: [(c8QWN,
                       label: block_c8QWN_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QWN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8QWW; else goto c8QWV;
       c8QWW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8QWV: // global
           _s8PUk::P64 = P64[Sp + 16];
           _s8PUl::P64 = P64[Sp + 24];
           _s8PUm::P64 = P64[Sp + 32];
           (_s8PUx::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc((I64[Sp + 8] + 1) * I64[R1 + 7]);
           if (_s8PUx::I64 == 0) goto c8QXh; else goto c8QXe;
       c8QXh: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8QXe: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PUx::I64;
           I64[Sp + 24] = block_c8QXc_info;
           R5 = _s8PUm::P64;
           _c8QXb::P64 = Hp - 7;
           R4 = _c8QXb::P64;
           R3 = _s8PUl::P64;
           R2 = _s8PUk::P64;
           P64[Sp + 32] = _c8QXb::P64;
           Sp = Sp + 24;
           call Foreign.Marshal.Array.newArray4_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8QXc() //  []
         { info_tbl: [(c8QXc,
                       label: block_c8QXc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QXc: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.868568431 UTC

[section ""data" . Foreign.Marshal.Array.newArray0_closure" {
     Foreign.Marshal.Array.newArray0_closure:
         const Foreign.Marshal.Array.newArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.newArray0_entry() //  [R2, R3, R4]
         { info_tbl: [(c8QXE,
                       label: Foreign.Marshal.Array.newArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QXE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.newArray3_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.871874534 UTC

[section ""data" . lvl22_r8PPB_closure" {
     lvl22_r8PPB_closure:
         const GHC.Types.I#_con_info;
         const 242;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.87358827 UTC

[section ""data" . lvl23_r8PPC_closure" {
     lvl23_r8PPC_closure:
         const GHC.Types.I#_con_info;
         const 21;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.875214284 UTC

[section ""data" . lvl24_r8PPD_closure" {
     lvl24_r8PPD_closure:
         const GHC.Types.I#_con_info;
         const 30;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.876883555 UTC

[section ""data" . lvl25_r8PPE_closure" {
     lvl25_r8PPE_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl22_r8PPB_closure+1;
         const lvl23_r8PPC_closure+1;
         const lvl22_r8PPB_closure+1;
         const lvl24_r8PPD_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.878953172 UTC

[section ""data" . lvl26_r8PPF_closure" {
     lvl26_r8PPF_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl25_r8PPE_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.881080906 UTC

[section ""data" . Foreign.Marshal.Array.copyArray1_closure" {
     Foreign.Marshal.Array.copyArray1_closure:
         const Foreign.Marshal.Array.copyArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.copyArray1_entry() //  [R1]
         { info_tbl: [(c8QXW,
                       label: Foreign.Marshal.Array.copyArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QXW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8QXX; else goto c8QXY;
       c8QXX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QXY: // global
           (_c8QXT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8QXT::I64 == 0) goto c8QXV; else goto c8QXU;
       c8QXV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8QXU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8QXT::I64;
           R2 = lvl26_r8PPF_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.886608574 UTC

[section ""data" . Foreign.Marshal.Array.copyArray_closure" {
     Foreign.Marshal.Array.copyArray_closure:
         const Foreign.Marshal.Array.copyArray_info;
         const 0;
 },
 lvl33_s8PUE_entry() //  [R1]
         { info_tbl: [(c8QYe,
                       label: lvl33_s8PUE_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QYe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QYf; else goto c8QYg;
       c8QYf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QYg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.copyArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PUX_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c8QYp,
                       label: sat_s8PUX_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QYp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8QYD; else goto c8QYE;
       c8QYD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8QYE: // global
           I64[Sp - 32] = block_c8QYm_info;
           _s8PUE::P64 = P64[R1 + 4];
           R1 = R2;
           P64[Sp - 24] = _s8PUE::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8QYY; else goto c8QYn;
       u8QYY: // global
           call _c8QYm(R1) args: 0, res: 0, upd: 0;
       c8QYn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QYm() //  [R1]
         { info_tbl: [(c8QYm,
                       label: block_c8QYm_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QYm: // global
           I64[Sp] = block_c8QYs_info;
           _s8PUK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8PUK::I64;
           if (R1 & 7 != 0) goto u8QYX; else goto c8QYt;
       u8QYX: // global
           call _c8QYs(R1) args: 0, res: 0, upd: 0;
       c8QYt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QYs() //  [R1]
         { info_tbl: [(c8QYs,
                       label: block_c8QYs_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QYs: // global
           I64[Sp] = block_c8QYx_info;
           _s8PUM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s8PUM::I64;
           if (R1 & 7 != 0) goto u8QYZ; else goto c8QYy;
       u8QYZ: // global
           call _c8QYx(R1) args: 0, res: 0, upd: 0;
       c8QYy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QYx() //  [R1]
         { info_tbl: [(c8QYx,
                       label: block_c8QYx_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QYx: // global
           I64[Sp] = block_c8QYC_info;
           _s8PUO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PUO::I64;
           if (R1 & 7 != 0) goto u8QZ0; else goto c8QYI;
       u8QZ0: // global
           call _c8QYC(R1) args: 0, res: 0, upd: 0;
       c8QYI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8QYC() //  [R1]
         { info_tbl: [(c8QYC,
                       label: block_c8QYC_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QYC: // global
           (_s8PUW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[Sp + 16], I64[Sp + 24], I64[Sp + 8] * I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.copyArray_entry() //  [R2]
         { info_tbl: [(c8QZ1,
                       label: Foreign.Marshal.Array.copyArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QZ1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8QZ5; else goto c8QZ4;
       c8QZ5: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.copyArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8QZ4: // global
           I64[Hp - 32] = lvl33_s8PUE_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8PUX_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.903050586 UTC

[section ""data" . lvl27_r8PPG_closure" {
     lvl27_r8PPG_closure:
         const GHC.Types.I#_con_info;
         const 251;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.904998396 UTC

[section ""data" . lvl28_r8PPH_closure" {
     lvl28_r8PPH_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl27_r8PPG_closure+1;
         const lvl23_r8PPC_closure+1;
         const lvl27_r8PPG_closure+1;
         const lvl24_r8PPD_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.907404561 UTC

[section ""data" . lvl29_r8PPI_closure" {
     lvl29_r8PPI_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl28_r8PPH_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.910174835 UTC

[section ""data" . Foreign.Marshal.Array.moveArray1_closure" {
     Foreign.Marshal.Array.moveArray1_closure:
         const Foreign.Marshal.Array.moveArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.moveArray1_entry() //  [R1]
         { info_tbl: [(c8QZM,
                       label: Foreign.Marshal.Array.moveArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8QZM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8QZN; else goto c8QZO;
       c8QZN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8QZO: // global
           (_c8QZJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8QZJ::I64 == 0) goto c8QZL; else goto c8QZK;
       c8QZL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8QZK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8QZJ::I64;
           R2 = lvl29_r8PPI_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.915467567 UTC

[section ""data" . Foreign.Marshal.Array.moveArray_closure" {
     Foreign.Marshal.Array.moveArray_closure:
         const Foreign.Marshal.Array.moveArray_info;
         const 0;
 },
 lvl33_s8PUZ_entry() //  [R1]
         { info_tbl: [(c8R04,
                       label: lvl33_s8PUZ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R04: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8R05; else goto c8R06;
       c8R05: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8R06: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.moveArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PVi_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c8R0f,
                       label: sat_s8PVi_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R0f: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8R0t; else goto c8R0u;
       c8R0t: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8R0u: // global
           I64[Sp - 32] = block_c8R0c_info;
           _s8PUZ::P64 = P64[R1 + 4];
           R1 = R2;
           P64[Sp - 24] = _s8PUZ::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8R0O; else goto c8R0d;
       u8R0O: // global
           call _c8R0c(R1) args: 0, res: 0, upd: 0;
       c8R0d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8R0c() //  [R1]
         { info_tbl: [(c8R0c,
                       label: block_c8R0c_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R0c: // global
           I64[Sp] = block_c8R0i_info;
           _s8PV5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8PV5::I64;
           if (R1 & 7 != 0) goto u8R0N; else goto c8R0j;
       u8R0N: // global
           call _c8R0i(R1) args: 0, res: 0, upd: 0;
       c8R0j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8R0i() //  [R1]
         { info_tbl: [(c8R0i,
                       label: block_c8R0i_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R0i: // global
           I64[Sp] = block_c8R0n_info;
           _s8PV7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s8PV7::I64;
           if (R1 & 7 != 0) goto u8R0P; else goto c8R0o;
       u8R0P: // global
           call _c8R0n(R1) args: 0, res: 0, upd: 0;
       c8R0o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8R0n() //  [R1]
         { info_tbl: [(c8R0n,
                       label: block_c8R0n_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R0n: // global
           I64[Sp] = block_c8R0s_info;
           _s8PV9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PV9::I64;
           if (R1 & 7 != 0) goto u8R0Q; else goto c8R0y;
       u8R0Q: // global
           call _c8R0s(R1) args: 0, res: 0, upd: 0;
       c8R0y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8R0s() //  [R1]
         { info_tbl: [(c8R0s,
                       label: block_c8R0s_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R0s: // global
           (_s8PVh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(I64[Sp + 16], I64[Sp + 24], I64[Sp + 8] * I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.moveArray_entry() //  [R2]
         { info_tbl: [(c8R0R,
                       label: Foreign.Marshal.Array.moveArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R0R: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8R0V; else goto c8R0U;
       c8R0V: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.moveArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8R0U: // global
           I64[Hp - 32] = lvl33_s8PUZ_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8PVi_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.931710808 UTC

[section ""data" . Foreign.Marshal.Array.lengthArray1_closure" {
     Foreign.Marshal.Array.lengthArray1_closure:
         const Foreign.Marshal.Array.lengthArray1_info;
 },
 sat_s8PVy_entry() //  [R1]
         { info_tbl: [(c8R1P,
                       label: sat_s8PVy_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R1P: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8R1W; else goto c8R1X;
       c8R1W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8R1X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8R1M_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8R21; else goto c8R1N;
       u8R21: // global
           call _c8R1M(R1) args: 0, res: 0, upd: 0;
       c8R1N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8R1M() //  [R1]
         { info_tbl: [(c8R1M,
                       label: block_c8R1M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R1M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8R20; else goto c8R1Z;
       c8R20: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8R1Z: // global
           _s8PVx::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8PVx::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Array.lengthArray1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8R22,
                       label: Foreign.Marshal.Array.lengthArray1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R22: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c8R23; else goto c8R24;
       c8R23: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.lengthArray1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8R24: // global
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = Foreign.Marshal.Array.lengthArray2_closure+1;
           Sp = Sp - 40;
           call _c8R1A() args: 0, res: 0, upd: 0;
     }
 },
 _c8R1A() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R1A: // global
           I64[Sp - 8] = block_c8R1C_info;
           R2 = P64[Sp];
           I64[Sp - 32] = stg_ap_ppv_info;
           P64[Sp - 24] = P64[Sp + 24];
           P64[Sp - 16] = P64[Sp + 32];
           Sp = Sp - 32;
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8R1C() //  [R1]
         { info_tbl: [(c8R1C,
                       label: block_c8R1C_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R1C: // global
           I64[Sp] = block_c8R1E_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R1;
           P64[Sp - 8] = P64[Sp + 24];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8R1E() //  [R1]
         { info_tbl: [(c8R1E,
                       label: block_c8R1E_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R1E: // global
           _s8PVp::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto c8R28; else goto c8R2f;
       c8R28: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8R2b; else goto c8R2a;
       c8R2b: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8R2a: // global
           I64[Hp - 16] = sat_s8PVy_info;
           P64[Hp] = _s8PVp::P64;
           P64[Sp + 40] = Hp - 16;
           Sp = Sp + 8;
           call _c8R1A() args: 0, res: 0, upd: 0;
       c8R2f: // global
           R1 = _s8PVp::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.944601442 UTC

[section ""data" . Foreign.Marshal.Array.lengthArray0_closure" {
     Foreign.Marshal.Array.lengthArray0_closure:
         const Foreign.Marshal.Array.lengthArray0_info;
 },
 Foreign.Marshal.Array.lengthArray0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8R2T,
                       label: Foreign.Marshal.Array.lengthArray0_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R2T: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.lengthArray1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.948188776 UTC

[section ""data" . Foreign.Marshal.Array.peekArray2_closure" {
     Foreign.Marshal.Array.peekArray2_closure:
         const Foreign.Marshal.Array.peekArray2_info;
 },
 Foreign.Marshal.Array.peekArray2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8R36,
                       label: Foreign.Marshal.Array.peekArray2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R36: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8R37; else goto c8R38;
       c8R37: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.peekArray2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8R38: // global
           I64[Sp - 24] = block_c8R34_info;
           _s8PVC::P64 = R5;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           _s8PVz::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s8PVz::P64;
           P64[Sp - 8] = _s8PVC::P64;
           Sp = Sp - 24;
           call Foreign.Marshal.Array.lengthArray1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8R34() //  [R1]
         { info_tbl: [(c8R34,
                       label: block_c8R34_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R34: // global
           R4 = P64[Sp + 16];
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Array.peekArray1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.954183256 UTC

[section ""data" . Foreign.Marshal.Array.peekArray0_closure" {
     Foreign.Marshal.Array.peekArray0_closure:
         const Foreign.Marshal.Array.peekArray0_info;
 },
 Foreign.Marshal.Array.peekArray0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8R3m,
                       label: Foreign.Marshal.Array.peekArray0_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R3m: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.peekArray2_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.957890847 UTC

[section ""data" . lvl30_r8PPJ_closure" {
     lvl30_r8PPJ_closure:
         const GHC.Types.I#_con_info;
         const 276;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.959495368 UTC

[section ""data" . lvl31_r8PPK_closure" {
     lvl31_r8PPK_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl30_r8PPJ_closure+1;
         const lvl7_r8PPm_closure+1;
         const lvl30_r8PPJ_closure+1;
         const lvl8_r8PPn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.961225381 UTC

[section ""data" . lvl32_r8PPL_closure" {
     lvl32_r8PPL_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl31_r8PPK_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.963545644 UTC

[section ""data" . Foreign.Marshal.Array.advancePtr1_closure" {
     Foreign.Marshal.Array.advancePtr1_closure:
         const Foreign.Marshal.Array.advancePtr1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.advancePtr1_entry() //  [R1]
         { info_tbl: [(c8R3C,
                       label: Foreign.Marshal.Array.advancePtr1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R3C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8R3D; else goto c8R3E;
       c8R3D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8R3E: // global
           (_c8R3z::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8R3z::I64 == 0) goto c8R3B; else goto c8R3A;
       c8R3B: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8R3A: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8R3z::I64;
           R2 = lvl32_r8PPL_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.968436882 UTC

[section ""data" . Foreign.Marshal.Array.advancePtr_closure" {
     Foreign.Marshal.Array.advancePtr_closure:
         const Foreign.Marshal.Array.advancePtr_info;
         const 0;
 },
 lvl33_s8PVI_entry() //  [R1]
         { info_tbl: [(c8R3U,
                       label: lvl33_s8PVI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R3U: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8R3V; else goto c8R3W;
       c8R3V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8R3W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.advancePtr1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8PVT_entry() //  [R1, R2, R3]
         { info_tbl: [(c8R45,
                       label: sat_s8PVT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R45: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8R4p; else goto c8R4q;
       c8R4p: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8R4q: // global
           I64[Sp - 24] = block_c8R42_info;
           _s8PVI::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s8PVI::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8R4x; else goto c8R43;
       u8R4x: // global
           call _c8R42(R1) args: 0, res: 0, upd: 0;
       c8R43: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8R42() //  [R1]
         { info_tbl: [(c8R42,
                       label: block_c8R42_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R42: // global
           I64[Sp] = block_c8R48_info;
           _s8PVM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8PVM::I64;
           if (R1 & 7 != 0) goto u8R4w; else goto c8R49;
       u8R4w: // global
           call _c8R48(R1) args: 0, res: 0, upd: 0;
       c8R49: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8R48() //  [R1]
         { info_tbl: [(c8R48,
                       label: block_c8R48_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R48: // global
           I64[Sp] = block_c8R4d_info;
           _s8PVO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8PVO::I64;
           if (R1 & 7 != 0) goto u8R4y; else goto c8R4e;
       u8R4y: // global
           call _c8R4d(R1) args: 0, res: 0, upd: 0;
       c8R4e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8R4d() //  [R1]
         { info_tbl: [(c8R4d,
                       label: block_c8R4d_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R4d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8R4v; else goto c8R4u;
       c8R4v: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8R4u: // global
           _s8PVS::I64 = I64[Sp + 16] + I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8PVS::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.advancePtr_entry() //  [R2]
         { info_tbl: [(c8R4z,
                       label: Foreign.Marshal.Array.advancePtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8R4z: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8R4D; else goto c8R4C;
       c8R4D: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.advancePtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8R4C: // global
           I64[Hp - 32] = lvl33_s8PVI_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8PVT_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.982246281 UTC

[section ""data" . Foreign.Marshal.Array.$trModule3_closure" {
     Foreign.Marshal.Array.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Array.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.983890544 UTC

[section ""data" . Foreign.Marshal.Array.$trModule1_closure" {
     Foreign.Marshal.Array.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Array.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.985791389 UTC

[section ""data" . Foreign.Marshal.Array.$trModule_closure" {
     Foreign.Marshal.Array.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Marshal.Array.$trModule3_closure+1;
         const Foreign.Marshal.Array.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:03:59.987492551 UTC

[section ""relreadonly" . S8PWD_srt" {
     S8PWD_srt:
         const GHC.Err.undefined_closure;
         const lvl10_r8PPp_closure;
         const Foreign.Marshal.Array.mallocArray1_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Array.mallocArray_closure;
         const Foreign.Marshal.Array.$wmallocArray0_closure;
         const Foreign.Marshal.Array.mallocArray2_closure;
         const lvl13_r8PPs_closure;
         const Foreign.Marshal.Array.callocArray1_closure;
         const Foreign.Marshal.Alloc.calloc1_closure;
         const Foreign.Marshal.Array.callocArray_closure;
         const Foreign.Marshal.Array.$wcallocArray0_closure;
         const Foreign.Marshal.Array.callocArray2_closure;
         const lvl16_r8PPv_closure;
         const Foreign.Marshal.Array.allocaArray1_closure;
         const Foreign.Marshal.Array.allocaArray_closure;
         const Foreign.Marshal.Array.allocaArray0_closure;
         const lvl21_r8PPA_closure;
         const Foreign.Marshal.Array.reallocArray1_closure;
         const Foreign.Marshal.Alloc.realloc2_closure;
         const Foreign.Marshal.Array.reallocArray_closure;
         const Foreign.Marshal.Array.$wreallocArray0_closure;
         const Foreign.Marshal.Array.reallocArray2_closure;
         const Foreign.Marshal.Array.withArrayLen_closure;
         const Foreign.Marshal.Array.withArray_closure;
         const Foreign.Marshal.Array.newArray1_closure;
         const Foreign.Marshal.Array.withArrayLen0_closure;
         const Foreign.Marshal.Array.withArray0_closure;
         const Foreign.Marshal.Array.newArray3_closure;
         const lvl26_r8PPF_closure;
         const Foreign.Marshal.Array.copyArray1_closure;
         const Foreign.Marshal.Array.copyArray_closure;
         const lvl29_r8PPI_closure;
         const GHC.Err.undefined_closure;
         const Foreign.Marshal.Array.moveArray1_closure;
         const Foreign.Marshal.Array.moveArray_closure;
         const lvl32_r8PPL_closure;
         const Foreign.Marshal.Array.advancePtr1_closure;
         const Foreign.Marshal.Array.advancePtr_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.385181406 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:04:01.387223764 UTC

[section ""cstring" . lvl_r8PPf_bytes" {
     lvl_r8PPf_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.389174461 UTC

[section ""data" . lvl1_r8PPg_closure" {
     lvl1_r8PPg_closure:
         const lvl1_r8PPg_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r8PPg_entry() //  [R1]
         { info_tbl: [(c8Rbr,
                       label: lvl1_r8PPg_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rbr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Rbs; else goto c8Rbt;
       c8Rbs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Rbt: // global
           (_c8Rbo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Rbo::I64 == 0) goto c8Rbq; else goto c8Rbp;
       c8Rbq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Rbp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Rbo::I64;
           R2 = lvl_r8PPf_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.393233303 UTC

[section ""cstring" . Foreign.Marshal.Array.$trModule4_bytes" {
     Foreign.Marshal.Array.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.395067805 UTC

[section ""data" . lvl2_r8PPh_closure" {
     lvl2_r8PPh_closure:
         const lvl2_r8PPh_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r8PPh_entry() //  [R1]
         { info_tbl: [(c8RbJ,
                       label: lvl2_r8PPh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RbJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8RbK; else goto c8RbL;
       c8RbK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8RbL: // global
           (_c8RbG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8RbG::I64 == 0) goto c8RbI; else goto c8RbH;
       c8RbI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8RbH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8RbG::I64;
           R2 = Foreign.Marshal.Array.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.398839584 UTC

[section ""cstring" . Foreign.Marshal.Array.$trModule2_bytes" {
     Foreign.Marshal.Array.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,77,97,114,115,104,97,108,46,65,114,114,97,121]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.400655236 UTC

[section ""data" . lvl3_r8PPi_closure" {
     lvl3_r8PPi_closure:
         const lvl3_r8PPi_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r8PPi_entry() //  [R1]
         { info_tbl: [(c8Rc1,
                       label: lvl3_r8PPi_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rc1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Rc2; else goto c8Rc3;
       c8Rc2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Rc3: // global
           (_c8RbY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8RbY::I64 == 0) goto c8Rc0; else goto c8RbZ;
       c8Rc0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8RbZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8RbY::I64;
           R2 = Foreign.Marshal.Array.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.404573725 UTC

[section ""cstring" . lvl4_r8PPj_bytes" {
     lvl4_r8PPj_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,77,97,114,115,104,97,108,47,65,114,114,97,121,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.406473978 UTC

[section ""data" . lvl5_r8PPk_closure" {
     lvl5_r8PPk_closure:
         const lvl5_r8PPk_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r8PPk_entry() //  [R1]
         { info_tbl: [(c8Rcj,
                       label: lvl5_r8PPk_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rcj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Rck; else goto c8Rcl;
       c8Rck: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Rcl: // global
           (_c8Rcg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Rcg::I64 == 0) goto c8Rci; else goto c8Rch;
       c8Rci: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Rch: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Rcg::I64;
           R2 = lvl4_r8PPj_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.410464215 UTC

[section ""data" . lvl6_r8PPl_closure" {
     lvl6_r8PPl_closure:
         const GHC.Types.I#_con_info;
         const 86;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.412133108 UTC

[section ""data" . lvl7_r8PPm_closure" {
     lvl7_r8PPm_closure:
         const GHC.Types.I#_con_info;
         const 25;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.414212061 UTC

[section ""data" . lvl8_r8PPn_closure" {
     lvl8_r8PPn_closure:
         const GHC.Types.I#_con_info;
         const 34;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.416507864 UTC

[section ""data" . lvl9_r8PPo_closure" {
     lvl9_r8PPo_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl6_r8PPl_closure+1;
         const lvl7_r8PPm_closure+1;
         const lvl6_r8PPl_closure+1;
         const lvl8_r8PPn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.418331631 UTC

[section ""data" . lvl10_r8PPp_closure" {
     lvl10_r8PPp_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl9_r8PPo_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.420353282 UTC

[section ""data" . Foreign.Marshal.Array.mallocArray1_closure" {
     Foreign.Marshal.Array.mallocArray1_closure:
         const Foreign.Marshal.Array.mallocArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.mallocArray1_entry() //  [R1]
         { info_tbl: [(c8RcF,
                       label: Foreign.Marshal.Array.mallocArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RcF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8RcG; else goto c8RcH;
       c8RcG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8RcH: // global
           (_c8RcC::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8RcC::I64 == 0) goto c8RcE; else goto c8RcD;
       c8RcE: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8RcD: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8RcC::I64;
           R2 = lvl10_r8PPp_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.425406045 UTC

[section ""data" . Foreign.Marshal.Array.mallocArray_closure" {
     Foreign.Marshal.Array.mallocArray_closure:
         const Foreign.Marshal.Array.mallocArray_info;
         const 0;
 },
 lvl33_s8R5e_entry() //  [R1]
         { info_tbl: [(c8RcZ,
                       label: lvl33_s8R5e_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RcZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Rd0; else goto c8Rd1;
       c8Rd0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Rd1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.mallocArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8R5t_entry() //  [R1, R2]
         { info_tbl: [(c8Rda,
                       label: sat_s8R5t_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rda: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Rde; else goto c8Rdf;
       c8Rde: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Rdf: // global
           I64[Sp - 16] = block_c8Rd7_info;
           _s8R5e::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _s8R5e::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8RdE; else goto c8Rd8;
       u8RdE: // global
           call _c8Rd7(R1) args: 0, res: 0, upd: 0;
       c8Rd8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Rd7() //  [R1]
         { info_tbl: [(c8Rd7,
                       label: block_c8Rd7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rd7: // global
           I64[Sp] = block_c8Rdd_info;
           _s8R5i::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8R5i::I64;
           if (R1 & 7 != 0) goto u8RdD; else goto c8Rdh;
       u8RdD: // global
           call _c8Rdd(R1) args: 0, res: 0, upd: 0;
       c8Rdh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Rdd() //  [R1]
         { info_tbl: [(c8Rdd,
                       label: block_c8Rdd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rdd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Rdn; else goto c8Rdm;
       c8Rdn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Rdm: // global
           (_s8R5q::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[Sp + 8] * I64[R1 + 7]);
           if (_s8R5q::I64 == 0) goto c8RdC; else goto c8RdB;
       c8RdC: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8RdB: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8R5q::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.mallocArray_entry() //  [R2]
         { info_tbl: [(c8RdF,
                       label: Foreign.Marshal.Array.mallocArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RdF: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8RdJ; else goto c8RdI;
       c8RdJ: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.mallocArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8RdI: // global
           I64[Hp - 32] = lvl33_s8R5e_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8R5t_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.438338397 UTC

[section ""data" . Foreign.Marshal.Array.$wmallocArray0_closure" {
     Foreign.Marshal.Array.$wmallocArray0_closure:
         const Foreign.Marshal.Array.$wmallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.$wmallocArray0_entry() //  [R2, R3]
         { info_tbl: [(c8Ren,
                       label: Foreign.Marshal.Array.$wmallocArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ren: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Reo; else goto c8Rep;
       c8Reo: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.$wmallocArray0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Rep: // global
           I64[Sp - 16] = block_c8Rel_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.mallocArray1_closure;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8Rel() //  [R1]
         { info_tbl: [(c8Rel,
                       label: block_c8Rel_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rel: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Reu; else goto c8Ret;
       c8Reu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Ret: // global
           (_s8R5F::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc((I64[Sp + 8] + 1) * I64[R1 + 7]);
           if (_s8R5F::I64 == 0) goto c8ReM; else goto c8ReL;
       c8ReM: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8ReL: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8R5F::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.444908927 UTC

[section ""data" . Foreign.Marshal.Array.mallocArray2_closure" {
     Foreign.Marshal.Array.mallocArray2_closure:
         const Foreign.Marshal.Array.mallocArray2_info;
         const 0;
 },
 Foreign.Marshal.Array.mallocArray2_entry() //  [R2, R3]
         { info_tbl: [(c8Rfa,
                       label: Foreign.Marshal.Array.mallocArray2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rfa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Rfb; else goto c8Rfc;
       c8Rfb: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.mallocArray2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Rfc: // global
           I64[Sp - 16] = block_c8Rf7_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Rfg; else goto c8Rf8;
       u8Rfg: // global
           call _c8Rf7(R1) args: 0, res: 0, upd: 0;
       c8Rf8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Rf7() //  [R1]
         { info_tbl: [(c8Rf7,
                       label: block_c8Rf7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rf7: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.Marshal.Array.$wmallocArray0_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.450640288 UTC

[section ""data" . Foreign.Marshal.Array.mallocArray0_closure" {
     Foreign.Marshal.Array.mallocArray0_closure:
         const Foreign.Marshal.Array.mallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.mallocArray0_entry() //  [R2, R3]
         { info_tbl: [(c8Rfv,
                       label: Foreign.Marshal.Array.mallocArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rfv: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.mallocArray2_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.454696468 UTC

[section ""data" . lvl11_r8PPq_closure" {
     lvl11_r8PPq_closure:
         const GHC.Types.I#_con_info;
         const 100;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.456326693 UTC

[section ""data" . lvl12_r8PPr_closure" {
     lvl12_r8PPr_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl11_r8PPq_closure+1;
         const lvl7_r8PPm_closure+1;
         const lvl11_r8PPq_closure+1;
         const lvl8_r8PPn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.458420436 UTC

[section ""data" . lvl13_r8PPs_closure" {
     lvl13_r8PPs_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl12_r8PPr_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.460409394 UTC

[section ""data" . Foreign.Marshal.Array.callocArray1_closure" {
     Foreign.Marshal.Array.callocArray1_closure:
         const Foreign.Marshal.Array.callocArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.callocArray1_entry() //  [R1]
         { info_tbl: [(c8RfL,
                       label: Foreign.Marshal.Array.callocArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RfL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8RfM; else goto c8RfN;
       c8RfM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8RfN: // global
           (_c8RfI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8RfI::I64 == 0) goto c8RfK; else goto c8RfJ;
       c8RfK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8RfJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8RfI::I64;
           R2 = lvl13_r8PPs_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.465454058 UTC

[section ""data" . Foreign.Marshal.Array.callocArray_closure" {
     Foreign.Marshal.Array.callocArray_closure:
         const Foreign.Marshal.Array.callocArray_info;
         const 0;
 },
 lvl33_s8R5O_entry() //  [R1]
         { info_tbl: [(c8Rg4,
                       label: lvl33_s8R5O_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rg4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Rg5; else goto c8Rg6;
       c8Rg5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Rg6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.callocArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8R63_entry() //  [R1, R2]
         { info_tbl: [(c8Rgf,
                       label: sat_s8R63_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rgf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Rgj; else goto c8Rgk;
       c8Rgj: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Rgk: // global
           I64[Sp - 16] = block_c8Rgc_info;
           _s8R5O::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _s8R5O::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8RgK; else goto c8Rgd;
       u8RgK: // global
           call _c8Rgc(R1) args: 0, res: 0, upd: 0;
       c8Rgd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Rgc() //  [R1]
         { info_tbl: [(c8Rgc,
                       label: block_c8Rgc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rgc: // global
           I64[Sp] = block_c8Rgi_info;
           _s8R5S::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8R5S::I64;
           if (R1 & 7 != 0) goto u8RgJ; else goto c8Rgm;
       u8RgJ: // global
           call _c8Rgi(R1) args: 0, res: 0, upd: 0;
       c8Rgm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Rgi() //  [R1]
         { info_tbl: [(c8Rgi,
                       label: block_c8Rgi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rgi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Rgs; else goto c8Rgr;
       c8Rgs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Rgr: // global
           (_s8R60::I64) = call "ccall" arg hints:  [,]  result hints:  [PtrHint] calloc(1, I64[Sp + 8] * I64[R1 + 7]);
           if (_s8R60::I64 == 0) goto c8RgI; else goto c8RgH;
       c8RgI: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.calloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8RgH: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8R60::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.callocArray_entry() //  [R2]
         { info_tbl: [(c8RgL,
                       label: Foreign.Marshal.Array.callocArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RgL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8RgP; else goto c8RgO;
       c8RgP: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.callocArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8RgO: // global
           I64[Hp - 32] = lvl33_s8R5O_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8R63_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.477749928 UTC

[section ""data" . Foreign.Marshal.Array.$wcallocArray0_closure" {
     Foreign.Marshal.Array.$wcallocArray0_closure:
         const Foreign.Marshal.Array.$wcallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.$wcallocArray0_entry() //  [R2, R3]
         { info_tbl: [(c8Rht,
                       label: Foreign.Marshal.Array.$wcallocArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rht: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Rhu; else goto c8Rhv;
       c8Rhu: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.$wcallocArray0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Rhv: // global
           I64[Sp - 16] = block_c8Rhr_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.callocArray1_closure;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8Rhr() //  [R1]
         { info_tbl: [(c8Rhr,
                       label: block_c8Rhr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rhr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8RhA; else goto c8Rhz;
       c8RhA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Rhz: // global
           (_s8R6f::I64) = call "ccall" arg hints:  [,]  result hints:  [PtrHint] calloc(1, (I64[Sp + 8] + 1) * I64[R1 + 7]);
           if (_s8R6f::I64 == 0) goto c8RhT; else goto c8RhS;
       c8RhT: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.calloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8RhS: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8R6f::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.484306583 UTC

[section ""data" . Foreign.Marshal.Array.callocArray2_closure" {
     Foreign.Marshal.Array.callocArray2_closure:
         const Foreign.Marshal.Array.callocArray2_info;
         const 0;
 },
 Foreign.Marshal.Array.callocArray2_entry() //  [R2, R3]
         { info_tbl: [(c8Rih,
                       label: Foreign.Marshal.Array.callocArray2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rih: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Rii; else goto c8Rij;
       c8Rii: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.callocArray2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Rij: // global
           I64[Sp - 16] = block_c8Rie_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Rin; else goto c8Rif;
       u8Rin: // global
           call _c8Rie(R1) args: 0, res: 0, upd: 0;
       c8Rif: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Rie() //  [R1]
         { info_tbl: [(c8Rie,
                       label: block_c8Rie_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rie: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.Marshal.Array.$wcallocArray0_entry(R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.490603094 UTC

[section ""data" . Foreign.Marshal.Array.callocArray0_closure" {
     Foreign.Marshal.Array.callocArray0_closure:
         const Foreign.Marshal.Array.callocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.callocArray0_entry() //  [R2, R3]
         { info_tbl: [(c8RiC,
                       label: Foreign.Marshal.Array.callocArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RiC: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.callocArray2_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.494417992 UTC

[section ""data" . lvl14_r8PPt_closure" {
     lvl14_r8PPt_closure:
         const GHC.Types.I#_con_info;
         const 115;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.495999973 UTC

[section ""data" . lvl15_r8PPu_closure" {
     lvl15_r8PPu_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl14_r8PPt_closure+1;
         const lvl7_r8PPm_closure+1;
         const lvl14_r8PPt_closure+1;
         const lvl8_r8PPn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.497728234 UTC

[section ""data" . lvl16_r8PPv_closure" {
     lvl16_r8PPv_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl15_r8PPu_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.499690234 UTC

[section ""data" . Foreign.Marshal.Array.allocaArray1_closure" {
     Foreign.Marshal.Array.allocaArray1_closure:
         const Foreign.Marshal.Array.allocaArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.allocaArray1_entry() //  [R1]
         { info_tbl: [(c8RiS,
                       label: Foreign.Marshal.Array.allocaArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RiS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8RiT; else goto c8RiU;
       c8RiT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8RiU: // global
           (_c8RiP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8RiP::I64 == 0) goto c8RiR; else goto c8RiQ;
       c8RiR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8RiQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8RiP::I64;
           R2 = lvl16_r8PPv_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.505375917 UTC

[section ""data" . Foreign.Marshal.Array.allocaArray_closure" {
     Foreign.Marshal.Array.allocaArray_closure:
         const Foreign.Marshal.Array.allocaArray_info;
         const 0;
 },
 lvl33_s8R6o_entry() //  [R1]
         { info_tbl: [(c8Rjb,
                       label: lvl33_s8R6o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rjb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Rjc; else goto c8Rjd;
       c8Rjc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Rjd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.allocaArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 ds1_s8R6p_entry() //  [R1]
         { info_tbl: [(c8Rji,
                       label: ds1_s8R6p_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rji: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Rjj; else goto c8Rjk;
       c8Rjj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Rjk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.allocaArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.alignment_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8R6M_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Rjt,
                       label: sat_s8R6M_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rjt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8RjC; else goto c8RjD;
       c8RjC: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8RjD: // global
           I64[Sp - 32] = block_c8Rjq_info;
           _s8R6o::P64 = P64[R1 + 5];
           _s8R6p::P64 = P64[R1 + 13];
           R1 = R2;
           P64[Sp - 24] = _s8R6o::P64;
           P64[Sp - 16] = _s8R6p::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8Rk2; else goto c8Rjr;
       u8Rk2: // global
           call _c8Rjq(R1) args: 0, res: 0, upd: 0;
       c8Rjr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Rjq() //  [R1]
         { info_tbl: [(c8Rjq,
                       label: block_c8Rjq_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rjq: // global
           I64[Sp] = block_c8Rjw_info;
           _s8R6u::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8R6u::I64;
           if (R1 & 7 != 0) goto u8Rk1; else goto c8Rjx;
       u8Rk1: // global
           call _c8Rjw(R1) args: 0, res: 0, upd: 0;
       c8Rjx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Rjw() //  [R1]
         { info_tbl: [(c8Rjw,
                       label: block_c8Rjw_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rjw: // global
           I64[Sp] = block_c8RjB_info;
           _s8R6w::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8R6w::I64;
           if (R1 & 7 != 0) goto u8Rk3; else goto c8RjG;
       u8Rk3: // global
           call _c8RjB(R1) args: 0, res: 0, upd: 0;
       c8RjG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8RjB() //  [R1]
         { info_tbl: [(c8RjB,
                       label: block_c8RjB_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RjB: // global
           _s8R6z::I64 = I64[Sp + 8] * I64[Sp + 16];
           I64[Sp + 16] = block_c8RjO_info;
           R2 = I64[R1 + 7];
           R1 = _s8R6z::I64;
           Sp = Sp + 16;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8RjO() //  [R1]
         { info_tbl: [(c8RjO,
                       label: block_c8RjO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RjO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8RjS; else goto c8RjR;
       c8RjS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8RjR: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           P64[Hp] = R1 + 16;
           I64[Sp] = block_c8RjX_info;
           R2 = Hp - 7;
           _s8R6F::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8R6F::P64;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8RjX() //  [R1]
         { info_tbl: [(c8RjX,
                       label: block_c8RjX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RjX: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.allocaArray_entry() //  [R2]
         { info_tbl: [(c8Rk4,
                       label: Foreign.Marshal.Array.allocaArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rk4: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8Rk8; else goto c8Rk7;
       c8Rk8: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = Foreign.Marshal.Array.allocaArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Rk7: // global
           I64[Hp - 64] = lvl33_s8R6o_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = ds1_s8R6p_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_s8R6M_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R1 = Hp - 13;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.525091736 UTC

[section ""data" . Foreign.Marshal.Array.allocaArray0_closure" {
     Foreign.Marshal.Array.allocaArray0_closure:
         const Foreign.Marshal.Array.allocaArray0_info;
         const 0;
 },
 sat_s8R6S_entry() //  [R1]
         { info_tbl: [(c8Rld,
                       label: sat_s8R6S_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rld: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Rlk; else goto c8Rll;
       c8Rlk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Rll: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8Rla_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Rlp; else goto c8Rlb;
       u8Rlp: // global
           call _c8Rla(R1) args: 0, res: 0, upd: 0;
       c8Rlb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8Rla() //  [R1]
         { info_tbl: [(c8Rla,
                       label: block_c8Rla_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rla: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Rlo; else goto c8Rln;
       c8Rlo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8Rln: // global
           _s8R6R::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8R6R::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Array.allocaArray0_entry() //  [R2, R3]
         { info_tbl: [(c8Rlq,
                       label: Foreign.Marshal.Array.allocaArray0_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rlq: // global
           _s8R6O::P64 = R3;
           _s8R6N::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Rlr; else goto c8Rls;
       c8Rls: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Rlu; else goto c8Rlt;
       c8Rlu: // global
           HpAlloc = 24;
           goto c8Rlr;
       c8Rlr: // global
           R3 = _s8R6O::P64;
           R2 = _s8R6N::P64;
           R1 = Foreign.Marshal.Array.allocaArray0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Rlt: // global
           I64[Hp - 16] = sat_s8R6S_info;
           P64[Hp] = _s8R6O::P64;
           R2 = _s8R6N::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 16;
           Sp = Sp - 16;
           call Foreign.Marshal.Array.allocaArray_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.534064425 UTC

[section ""data" . lvl17_r8PPw_closure" {
     lvl17_r8PPw_closure:
         const GHC.Types.I#_con_info;
         const 133;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.535739943 UTC

[section ""data" . lvl18_r8PPx_closure" {
     lvl18_r8PPx_closure:
         const GHC.Types.I#_con_info;
         const 27;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.537374416 UTC

[section ""data" . lvl19_r8PPy_closure" {
     lvl19_r8PPy_closure:
         const GHC.Types.I#_con_info;
         const 36;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.539020974 UTC

[section ""data" . lvl20_r8PPz_closure" {
     lvl20_r8PPz_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl17_r8PPw_closure+1;
         const lvl18_r8PPx_closure+1;
         const lvl17_r8PPw_closure+1;
         const lvl19_r8PPy_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.540819345 UTC

[section ""data" . lvl21_r8PPA_closure" {
     lvl21_r8PPA_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl20_r8PPz_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.542884064 UTC

[section ""data" . Foreign.Marshal.Array.reallocArray1_closure" {
     Foreign.Marshal.Array.reallocArray1_closure:
         const Foreign.Marshal.Array.reallocArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.reallocArray1_entry() //  [R1]
         { info_tbl: [(c8Rm1,
                       label: Foreign.Marshal.Array.reallocArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rm1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Rm2; else goto c8Rm3;
       c8Rm2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Rm3: // global
           (_c8RlY::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8RlY::I64 == 0) goto c8Rm0; else goto c8RlZ;
       c8Rm0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8RlZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8RlY::I64;
           R2 = lvl21_r8PPA_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.547997769 UTC

[section ""data" . Foreign.Marshal.Array.reallocArray_closure" {
     Foreign.Marshal.Array.reallocArray_closure:
         const Foreign.Marshal.Array.reallocArray_info;
         const 0;
 },
 lvl33_s8R6U_entry() //  [R1]
         { info_tbl: [(c8Rmk,
                       label: lvl33_s8R6U_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rmk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Rml; else goto c8Rmm;
       c8Rml: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Rmm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.reallocArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8R7f_entry() //  [R1, R2, R3]
         { info_tbl: [(c8Rmv,
                       label: sat_s8R7f_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rmv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8RmE; else goto c8RmF;
       c8RmE: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8RmF: // global
           I64[Sp - 24] = block_c8Rms_info;
           _s8R6U::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 16] = _s8R6U::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Rnm; else goto c8Rmt;
       u8Rnm: // global
           call _c8Rms(R1) args: 0, res: 0, upd: 0;
       c8Rmt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Rms() //  [R1]
         { info_tbl: [(c8Rms,
                       label: block_c8Rms_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rms: // global
           I64[Sp] = block_c8Rmy_info;
           _s8R6Z::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8R6Z::I64;
           if (R1 & 7 != 0) goto u8Rnl; else goto c8Rmz;
       u8Rnl: // global
           call _c8Rmy(R1) args: 0, res: 0, upd: 0;
       c8Rmz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Rmy() //  [R1]
         { info_tbl: [(c8Rmy,
                       label: block_c8Rmy_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rmy: // global
           I64[Sp] = block_c8RmD_info;
           _s8R71::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8R71::I64;
           if (R1 & 7 != 0) goto u8Rnn; else goto c8RmI;
       u8Rnn: // global
           call _c8RmD(R1) args: 0, res: 0, upd: 0;
       c8RmI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8RmD() //  [R1]
         { info_tbl: [(c8RmD,
                       label: block_c8RmD_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RmD: // global
           _s8R73::I64 = I64[R1 + 7];
           _s8R74::I64 = I64[Sp + 8] * I64[Sp + 16];
           if (_s8R74::I64 != 0) goto u8Rnj; else goto c8Rnd;
       u8Rnj: // global
           I64[Sp + 8] = _s8R74::I64;
           I64[Sp + 16] = _s8R73::I64;
           Sp = Sp + 8;
           call _c8RmT() args: 0, res: 0, upd: 0;
       c8Rnd: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(_s8R73::I64);
           R1 = GHC.Ptr.nullPtr_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8RmT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RmT: // global
           Hp = Hp + 16;
           _s8R74::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c8RmX; else goto c8RmW;
       c8RmX: // global
           HpAlloc = 16;
           I64[Sp] = block_c8RmQ_info;
           R1 = _s8R74::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8RmW: // global
           (_s8R79::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp + 8], _s8R74::I64);
           if (_s8R79::I64 == 0) goto c8Rna; else goto c8Rn9;
       c8Rna: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Rn9: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8R79::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8RmQ() //  [R1]
         { info_tbl: [(c8RmQ,
                       label: block_c8RmQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RmQ: // global
           I64[Sp] = R1;
           call _c8RmT() args: 0, res: 0, upd: 0;
     }
 },
 Foreign.Marshal.Array.reallocArray_entry() //  [R2]
         { info_tbl: [(c8Rnq,
                       label: Foreign.Marshal.Array.reallocArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rnq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Rnu; else goto c8Rnt;
       c8Rnu: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.reallocArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Rnt: // global
           I64[Hp - 32] = lvl33_s8R6U_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8R7f_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 5;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.566752777 UTC

[section ""data" . Foreign.Marshal.Array.$wreallocArray0_closure" {
     Foreign.Marshal.Array.$wreallocArray0_closure:
         const Foreign.Marshal.Array.$wreallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.$wreallocArray0_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Roj,
                       label: Foreign.Marshal.Array.$wreallocArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 20} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Roj: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8Rok; else goto c8Rol;
       c8Rok: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.$wreallocArray0_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Rol: // global
           I64[Sp - 24] = block_c8Roh_info;
           R2 = R2;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = Foreign.Marshal.Array.reallocArray1_closure;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 40;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8Roh() //  [R1]
         { info_tbl: [(c8Roh,
                       label: block_c8Roh_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Roh: // global
           _s8R7n::I64 = (I64[Sp + 16] + 1) * I64[R1 + 7];
           if (_s8R7n::I64 != 0) goto u8RoY; else goto c8RoS;
       u8RoY: // global
           I64[Sp + 16] = _s8R7n::I64;
           Sp = Sp + 8;
           call _c8Roy() args: 0, res: 0, upd: 0;
       c8RoS: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[Sp + 8]);
           R1 = GHC.Ptr.nullPtr_closure;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Roy() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Roy: // global
           Hp = Hp + 16;
           _s8R7n::I64 = I64[Sp + 8];
           if (Hp > HpLim) (likely: False) goto c8RoC; else goto c8RoB;
       c8RoC: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c8Rov_info;
           R1 = _s8R7n::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8RoB: // global
           (_s8R7s::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp], _s8R7n::I64);
           if (_s8R7s::I64 == 0) goto c8RoP; else goto c8RoO;
       c8RoP: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8RoO: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8R7s::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Rov() //  [R1]
         { info_tbl: [(c8Rov,
                       label: block_c8Rov_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rov: // global
           I64[Sp + 16] = R1;
           Sp = Sp + 8;
           call _c8Roy() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.576315507 UTC

[section ""data" . Foreign.Marshal.Array.reallocArray2_closure" {
     Foreign.Marshal.Array.reallocArray2_closure:
         const Foreign.Marshal.Array.reallocArray2_info;
         const 0;
 },
 Foreign.Marshal.Array.reallocArray2_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Rpw,
                       label: Foreign.Marshal.Array.reallocArray2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rpw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8RpA; else goto c8RpB;
       c8RpA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.reallocArray2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8RpB: // global
           I64[Sp - 24] = block_c8Rpt_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8RpJ; else goto c8Rpu;
       u8RpJ: // global
           call _c8Rpt(R1) args: 0, res: 0, upd: 0;
       c8Rpu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Rpt() //  [R1]
         { info_tbl: [(c8Rpt,
                       label: block_c8Rpt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rpt: // global
           I64[Sp] = block_c8Rpz_info;
           _s8R7D::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8R7D::I64;
           if (R1 & 7 != 0) goto u8RpI; else goto c8RpD;
       u8RpI: // global
           call _c8Rpz(R1) args: 0, res: 0, upd: 0;
       c8RpD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Rpz() //  [R1]
         { info_tbl: [(c8Rpz,
                       label: block_c8Rpz_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rpz: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Array.$wreallocArray0_entry(R4,
                                                            R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.583859926 UTC

[section ""data" . Foreign.Marshal.Array.reallocArray0_closure" {
     Foreign.Marshal.Array.reallocArray0_closure:
         const Foreign.Marshal.Array.reallocArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.reallocArray0_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Rq3,
                       label: Foreign.Marshal.Array.reallocArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rq3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.reallocArray2_entry(R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.587493127 UTC

[section ""data" . Foreign.Marshal.Array.lengthArray2_closure" {
     Foreign.Marshal.Array.lengthArray2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.590223782 UTC

[section ""data" . Foreign.Marshal.Array.$wpeekArray_closure" {
     Foreign.Marshal.Array.$wpeekArray_closure:
         const Foreign.Marshal.Array.$wpeekArray_info;
 },
 Foreign.Marshal.Array.$wpeekArray_entry() //  [R2, R3, R4]
         { info_tbl: [(c8RqB,
                       label: Foreign.Marshal.Array.$wpeekArray_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RqB: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8RqC; else goto c8RqD;
       c8RqC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.$wpeekArray_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8RqD: // global
           if (%MO_S_Gt_W64(R3, 0)) goto c8Rqz; else goto c8RqA;
       c8Rqz: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           I64[Sp - 16] = R3 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 40;
           call _c8Rqp() args: 0, res: 0, upd: 0;
       c8RqA: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Rqp() //  []
         { info_tbl: [(c8Rqp,
                       label: block_c8Rqp_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rqp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8RqQ; else goto c8RqP;
       c8RqQ: // global
           HpAlloc = 16;
           I64[Sp] = block_c8Rqp_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8RqP: // global
           _s8R7G::P64 = P64[Sp + 8];
           _s8R7I::P64 = P64[Sp + 16];
           _s8R7W::I64 = I64[Sp + 24];
           if (_s8R7W::I64 != 0) goto c8RqS; else goto c8RqW;
       c8RqS: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8R7W::I64;
           I64[Sp] = block_c8Rqv_info;
           R2 = _s8R7G::P64;
           I64[Sp - 24] = stg_ap_ppv_info;
           P64[Sp - 16] = _s8R7I::P64;
           P64[Sp - 8] = Hp - 7;
           I64[Sp + 24] = _s8R7W::I64;
           Sp = Sp - 24;
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 8, upd: 8;
       c8RqW: // global
           Hp = Hp - 16;
           I64[Sp + 24] = block_c8RqH_info;
           R2 = _s8R7G::P64;
           I64[Sp] = stg_ap_ppv_info;
           P64[Sp + 8] = _s8R7I::P64;
           P64[Sp + 16] = Foreign.Marshal.Array.lengthArray2_closure+1;
           P64[Sp + 32] = P64[Sp + 32];
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8Rqv() //  [R1]
         { info_tbl: [(c8Rqv,
                       label: block_c8Rqv_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rqv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8RqV; else goto c8RqU;
       c8RqV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8RqU: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 32];
           I64[Sp + 24] = I64[Sp + 24] - 1;
           P64[Sp + 32] = Hp - 14;
           call _c8Rqp() args: 0, res: 0, upd: 0;
     }
 },
 _c8RqH() //  [R1]
         { info_tbl: [(c8RqH,
                       label: block_c8RqH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RqH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8RqN; else goto c8RqM;
       c8RqN: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8RqM: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.601487186 UTC

[section ""data" . Foreign.Marshal.Array.peekArray1_closure" {
     Foreign.Marshal.Array.peekArray1_closure:
         const Foreign.Marshal.Array.peekArray1_info;
 },
 Foreign.Marshal.Array.peekArray1_entry() //  [R2, R3, R4]
         { info_tbl: [(c8RrH,
                       label: Foreign.Marshal.Array.peekArray1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RrH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8RrI; else goto c8RrJ;
       c8RrI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.peekArray1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8RrJ: // global
           I64[Sp - 24] = block_c8RrE_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8RrN; else goto c8RrF;
       u8RrN: // global
           call _c8RrE(R1) args: 0, res: 0, upd: 0;
       c8RrF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8RrE() //  [R1]
         { info_tbl: [(c8RrE,
                       label: block_c8RrE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RrE: // global
           R4 = P64[Sp + 16];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Array.$wpeekArray_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.607775848 UTC

[section ""data" . Foreign.Marshal.Array.peekArray_closure" {
     Foreign.Marshal.Array.peekArray_closure:
         const Foreign.Marshal.Array.peekArray_info;
 },
 Foreign.Marshal.Array.peekArray_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Rs2,
                       label: Foreign.Marshal.Array.peekArray_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rs2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.peekArray1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.611684885 UTC

[section ""data" . Foreign.Marshal.Array.newArray2_closure" {
     Foreign.Marshal.Array.newArray2_closure:
         const Foreign.Marshal.Array.newArray2_info;
 },
 Foreign.Marshal.Array.newArray2_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Rsf,
                       label: Foreign.Marshal.Array.newArray2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rsf: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c8Rsg; else goto c8Rsh;
       c8Rsg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.newArray2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Rsh: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           I64[Sp - 8] = 0;
           Sp = Sp - 32;
           call _c8Rsi() args: 0, res: 0, upd: 0;
     }
 },
 _c8Rsi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rsi: // global
           I64[Sp - 8] = block_c8Rsl_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8RsJ; else goto c8Rsn;
       u8RsJ: // global
           call _c8Rsl(R1) args: 0, res: 0, upd: 0;
       c8Rsn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Rsl() //  [R1]
         { info_tbl: [(c8Rsl,
                       label: block_c8Rsl_info
                       rep:StackRep [False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rsl: // global
           if (R1 & 7 == 1) goto c8Rst; else goto c8Rsy;
       c8Rst: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8Rsy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8RsB; else goto c8RsA;
       c8RsB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8RsA: // global
           _s8R8j::P64 = P64[R1 + 6];
           _s8R8k::P64 = P64[R1 + 14];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 32];
           I64[Sp] = block_c8Rsx_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_pppv_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = Hp - 7;
           P64[Sp - 8] = _s8R8j::P64;
           P64[Sp + 24] = _s8R8k::P64;
           Sp = Sp - 32;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _c8Rsx() //  []
         { info_tbl: [(c8Rsx,
                       label: block_c8Rsx_info
                       rep:StackRep [False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rsx: // global
           P64[Sp + 24] = P64[Sp + 24];
           I64[Sp + 32] = I64[Sp + 32] + 1;
           Sp = Sp + 8;
           call _c8Rsi() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.620880306 UTC

[section ""data" . Foreign.Marshal.Array.pokeArray_closure" {
     Foreign.Marshal.Array.pokeArray_closure:
         const Foreign.Marshal.Array.pokeArray_info;
 },
 Foreign.Marshal.Array.pokeArray_entry() //  [R2, R3, R4]
         { info_tbl: [(c8Rtf,
                       label: Foreign.Marshal.Array.pokeArray_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rtf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.newArray2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.624811206 UTC

[section ""data" . Foreign.Marshal.Array.withArrayLen_closure" {
     Foreign.Marshal.Array.withArrayLen_closure:
         const Foreign.Marshal.Array.withArrayLen_info;
         const 0;
 },
 len_s8R8t_entry() //  [R1]
         { info_tbl: [(c8Rtw,
                       label: len_s8R8t_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rtw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8RtA; else goto c8RtB;
       c8RtA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8RtB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8Rtu_info;
           R3 = 0;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8Rtu() //  [R1]
         { info_tbl: [(c8Rtu,
                       label: block_c8Rtu_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rtu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8RtE; else goto c8RtD;
       c8RtE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c8RtD: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8R8A_entry() //  [R1, R2]
         { info_tbl: [(c8RtM,
                       label: sat_s8R8A_info
                       rep:HeapRep 4 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RtM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8RtN; else goto c8RtO;
       c8RtN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8RtO: // global
           I64[Sp - 32] = block_c8RtK_info;
           R4 = P64[R1 + 14];
           R3 = R2;
           _s8R8v::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 22];
           P64[Sp - 16] = P64[R1 + 30];
           P64[Sp - 8] = _s8R8v::P64;
           Sp = Sp - 32;
           call Foreign.Marshal.Array.newArray2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8RtK() //  []
         { info_tbl: [(c8RtK,
                       label: block_c8RtK_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RtK: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.withArrayLen_entry() //  [R2, R3, R4]
         { info_tbl: [(c8RtQ,
                       label: Foreign.Marshal.Array.withArrayLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RtQ: // global
           _s8R8s::P64 = R4;
           _s8R8r::P64 = R3;
           _s8R8q::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8RtR; else goto c8RtS;
       c8RtS: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto c8RtU; else goto c8RtT;
       c8RtU: // global
           HpAlloc = 64;
           goto c8RtR;
       c8RtR: // global
           R4 = _s8R8s::P64;
           R3 = _s8R8r::P64;
           R2 = _s8R8q::P64;
           R1 = Foreign.Marshal.Array.withArrayLen_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8RtT: // global
           I64[Hp - 56] = len_s8R8t_info;
           P64[Hp - 40] = _s8R8r::P64;
           I64[Hp - 32] = sat_s8R8A_info;
           P64[Hp - 24] = _s8R8q::P64;
           P64[Hp - 16] = _s8R8r::P64;
           P64[Hp - 8] = _s8R8s::P64;
           _c8Rtq::P64 = Hp - 56;
           P64[Hp] = _c8Rtq::P64;
           R2 = _s8R8q::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _c8Rtq::P64;
           P64[Sp - 8] = Hp - 30;
           Sp = Sp - 24;
           call Foreign.Marshal.Array.allocaArray_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.63768674 UTC

[section ""data" . Foreign.Marshal.Array.withArray_closure" {
     Foreign.Marshal.Array.withArray_closure:
         const Foreign.Marshal.Array.withArray_info;
         const 0;
 },
 sat_s8R8L_entry() //  [R1, R2]
         { info_tbl: [(c8RuA,
                       label: sat_s8R8L_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RuA: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8RuB; else goto c8RuC;
       c8RuB: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8RuC: // global
           I64[Sp - 24] = block_c8Ruy_info;
           R4 = P64[R1 + 14];
           R3 = R2;
           _s8R8G::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = P64[R1 + 22];
           P64[Sp - 8] = _s8R8G::P64;
           Sp = Sp - 24;
           call Foreign.Marshal.Array.newArray2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ruy() //  []
         { info_tbl: [(c8Ruy,
                       label: block_c8Ruy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ruy: // global
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8R8F_entry() //  [R1]
         { info_tbl: [(c8RuK,
                       label: sat_s8R8F_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RuK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8RuO; else goto c8RuP;
       c8RuO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8RuP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8RuI_info;
           R3 = 0;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8RuI() //  [R1]
         { info_tbl: [(c8RuI,
                       label: block_c8RuI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RuI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8RuS; else goto c8RuR;
       c8RuS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c8RuR: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Array.withArray_entry() //  [R2, R3, R4]
         { info_tbl: [(c8RuT,
                       label: Foreign.Marshal.Array.withArray_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RuT: // global
           _s8R8D::P64 = R4;
           _s8R8C::P64 = R3;
           _s8R8B::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8RuU; else goto c8RuV;
       c8RuV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8RuX; else goto c8RuW;
       c8RuX: // global
           HpAlloc = 56;
           goto c8RuU;
       c8RuU: // global
           R4 = _s8R8D::P64;
           R3 = _s8R8C::P64;
           R2 = _s8R8B::P64;
           R1 = Foreign.Marshal.Array.withArray_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8RuW: // global
           I64[Hp - 48] = sat_s8R8L_info;
           P64[Hp - 40] = _s8R8B::P64;
           P64[Hp - 32] = _s8R8C::P64;
           P64[Hp - 24] = _s8R8D::P64;
           I64[Hp - 16] = sat_s8R8F_info;
           P64[Hp] = _s8R8C::P64;
           R2 = _s8R8B::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 46;
           Sp = Sp - 24;
           call Foreign.Marshal.Array.allocaArray_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.650689151 UTC

[section ""data" . Foreign.Marshal.Array.newArray1_closure" {
     Foreign.Marshal.Array.newArray1_closure:
         const Foreign.Marshal.Array.newArray1_info;
         const 0;
 },
 Foreign.Marshal.Array.newArray1_entry() //  [R2, R3]
         { info_tbl: [(c8Rvy,
                       label: Foreign.Marshal.Array.newArray1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rvy: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8RvC; else goto c8RvD;
       c8RvC: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.newArray1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8RvD: // global
           I64[Sp - 24] = block_c8Rvw_info;
           _s8R8N::P64 = R3;
           R3 = 0;
           _s8R8M::P64 = R2;
           R2 = _s8R8N::P64;
           P64[Sp - 16] = _s8R8M::P64;
           P64[Sp - 8] = _s8R8N::P64;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Rvw() //  [R1]
         { info_tbl: [(c8Rvw,
                       label: block_c8Rvw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rvw: // global
           I64[Sp - 8] = block_c8RvB_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = Foreign.Marshal.Array.mallocArray1_closure;
           I64[Sp] = R1;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8RvB() //  [R1]
         { info_tbl: [(c8RvB,
                       label: block_c8RvB_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RvB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8RvK; else goto c8RvJ;
       c8RvK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8RvJ: // global
           _s8R8M::P64 = P64[Sp + 16];
           _s8R8N::P64 = P64[Sp + 24];
           (_s8R8X::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(I64[Sp + 8] * I64[R1 + 7]);
           if (_s8R8X::I64 == 0) goto c8Rw2; else goto c8RvZ;
       c8Rw2: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 32;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8RvZ: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8R8X::I64;
           I64[Sp + 16] = block_c8RvX_info;
           R4 = _s8R8N::P64;
           _c8RvW::P64 = Hp - 7;
           R3 = _c8RvW::P64;
           R2 = _s8R8M::P64;
           P64[Sp + 24] = _c8RvW::P64;
           Sp = Sp + 16;
           call Foreign.Marshal.Array.newArray2_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8RvX() //  []
         { info_tbl: [(c8RvX,
                       label: block_c8RvX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RvX: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.660672154 UTC

[section ""data" . Foreign.Marshal.Array.newArray_closure" {
     Foreign.Marshal.Array.newArray_closure:
         const Foreign.Marshal.Array.newArray_info;
         const 0;
 },
 Foreign.Marshal.Array.newArray_entry() //  [R2, R3]
         { info_tbl: [(c8Rwu,
                       label: Foreign.Marshal.Array.newArray_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rwu: // global
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.newArray1_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.664837477 UTC

[section ""data" . Foreign.Marshal.Array.newArray4_closure" {
     Foreign.Marshal.Array.newArray4_closure:
         const Foreign.Marshal.Array.newArray4_info;
 },
 Foreign.Marshal.Array.newArray4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8RwJ,
                       label: Foreign.Marshal.Array.newArray4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RwJ: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8RwK; else goto c8RwL;
       c8RwK: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.newArray4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8RwL: // global
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           I64[Sp - 8] = 0;
           Sp = Sp - 40;
           call _c8RwS() args: 0, res: 0, upd: 0;
     }
 },
 _c8RwS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RwS: // global
           I64[Sp - 8] = block_c8RwV_info;
           R1 = P64[Sp + 24];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Rxn; else goto c8RwX;
       u8Rxn: // global
           call _c8RwV(R1) args: 0, res: 0, upd: 0;
       c8RwX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8RwV() //  [R1]
         { info_tbl: [(c8RwV,
                       label: block_c8RwV_info
                       rep:StackRep [False, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RwV: // global
           _s8R9e::I64 = I64[Sp + 40];
           if (R1 & 7 == 1) goto c8Rx3; else goto c8Rx8;
       c8Rx3: // global
           I64[Sp + 40] = _s8R9e::I64;
           Sp = Sp + 8;
           call _c8RwN() args: 0, res: 0, upd: 0;
       c8Rx8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Rxb; else goto c8Rxa;
       c8Rxb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Rxa: // global
           _s8R9h::P64 = P64[R1 + 6];
           _s8R9i::P64 = P64[R1 + 14];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8R9e::I64;
           I64[Sp] = block_c8Rx7_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_pppv_info;
           P64[Sp - 24] = P64[Sp + 24];
           P64[Sp - 16] = Hp - 7;
           P64[Sp - 8] = _s8R9h::P64;
           P64[Sp + 32] = _s8R9i::P64;
           Sp = Sp - 32;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 8, upd: 8;
     }
 },
 _c8RwN() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RwN: // global
           Hp = Hp + 16;
           _s8R99::I64 = I64[Sp + 32];
           if (Hp > HpLim) (likely: False) goto c8RwR; else goto c8RwQ;
       c8RwR: // global
           HpAlloc = 16;
           I64[Sp - 8] = block_c8RwM_info;
           R1 = _s8R99::I64;
           Sp = Sp - 8;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8RwQ: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8R99::I64;
           R2 = P64[Sp];
           _s8R94::P64 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pppv_info;
           P64[Sp + 24] = Hp - 7;
           P64[Sp + 32] = _s8R94::P64;
           Sp = Sp + 8;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 _c8RwM() //  [R1]
         { info_tbl: [(c8RwM,
                       label: block_c8RwM_info
                       rep:StackRep [False, False, False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RwM: // global
           I64[Sp + 40] = R1;
           Sp = Sp + 8;
           call _c8RwN() args: 0, res: 0, upd: 0;
     }
 },
 _c8Rx7() //  []
         { info_tbl: [(c8Rx7,
                       label: block_c8Rx7_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Rx7: // global
           P64[Sp + 32] = P64[Sp + 32];
           I64[Sp + 40] = I64[Sp + 40] + 1;
           Sp = Sp + 8;
           call _c8RwS() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.677106643 UTC

[section ""data" . Foreign.Marshal.Array.pokeArray0_closure" {
     Foreign.Marshal.Array.pokeArray0_closure:
         const Foreign.Marshal.Array.pokeArray0_info;
 },
 Foreign.Marshal.Array.pokeArray0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8Ry0,
                       label: Foreign.Marshal.Array.pokeArray0_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ry0: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.newArray4_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.682087451 UTC

[section ""data" . Foreign.Marshal.Array.withArrayLen0_closure" {
     Foreign.Marshal.Array.withArrayLen0_closure:
         const Foreign.Marshal.Array.withArrayLen0_info;
         const 0;
 },
 len_s8R9s_entry() //  [R1]
         { info_tbl: [(c8Ryh,
                       label: len_s8R9s_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ryh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Ryl; else goto c8Rym;
       c8Ryl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Rym: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8Ryf_info;
           R3 = 0;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8Ryf() //  [R1]
         { info_tbl: [(c8Ryf,
                       label: block_c8Ryf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ryf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Ryp; else goto c8Ryo;
       c8Ryp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c8Ryo: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8R9D_entry() //  [R1, R2]
         { info_tbl: [(c8Ryx,
                       label: sat_s8R9D_info
                       rep:HeapRep 5 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ryx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Ryy; else goto c8Ryz;
       c8Ryy: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Ryz: // global
           I64[Sp - 32] = block_c8Ryv_info;
           R5 = P64[R1 + 22];
           R4 = R2;
           R3 = P64[R1 + 14];
           _s8R9y::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 24] = P64[R1 + 30];
           P64[Sp - 16] = P64[R1 + 38];
           P64[Sp - 8] = _s8R9y::P64;
           Sp = Sp - 32;
           call Foreign.Marshal.Array.newArray4_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ryv() //  []
         { info_tbl: [(c8Ryv,
                       label: block_c8Ryv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ryv: // global
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8R9x_entry() //  [R1]
         { info_tbl: [(c8RyI,
                       label: sat_s8R9x_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RyI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8RyP; else goto c8RyQ;
       c8RyP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8RyQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8RyF_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8RyU; else goto c8RyG;
       u8RyU: // global
           call _c8RyF(R1) args: 0, res: 0, upd: 0;
       c8RyG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8RyF() //  [R1]
         { info_tbl: [(c8RyF,
                       label: block_c8RyF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RyF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8RyT; else goto c8RyS;
       c8RyT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8RyS: // global
           _s8R9w::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8R9w::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Array.withArrayLen0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8RyV,
                       label: Foreign.Marshal.Array.withArrayLen0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RyV: // global
           _s8R9r::P64 = R5;
           _s8R9q::P64 = R4;
           _s8R9p::P64 = R3;
           _s8R9o::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c8RyW; else goto c8RyX;
       c8RyX: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto c8RyZ; else goto c8RyY;
       c8RyZ: // global
           HpAlloc = 96;
           goto c8RyW;
       c8RyW: // global
           R5 = _s8R9r::P64;
           R4 = _s8R9q::P64;
           R3 = _s8R9p::P64;
           R2 = _s8R9o::P64;
           R1 = Foreign.Marshal.Array.withArrayLen0_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8RyY: // global
           I64[Hp - 88] = len_s8R9s_info;
           P64[Hp - 72] = _s8R9q::P64;
           I64[Hp - 64] = sat_s8R9D_info;
           P64[Hp - 56] = _s8R9o::P64;
           P64[Hp - 48] = _s8R9p::P64;
           P64[Hp - 40] = _s8R9q::P64;
           P64[Hp - 32] = _s8R9r::P64;
           _c8Ryb::P64 = Hp - 88;
           P64[Hp - 24] = _c8Ryb::P64;
           I64[Hp - 16] = sat_s8R9x_info;
           P64[Hp] = _c8Ryb::P64;
           R2 = _s8R9o::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 16;
           P64[Sp - 8] = Hp - 62;
           Sp = Sp - 24;
           call Foreign.Marshal.Array.allocaArray_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.698687669 UTC

[section ""data" . Foreign.Marshal.Array.withArray0_closure" {
     Foreign.Marshal.Array.withArray0_closure:
         const Foreign.Marshal.Array.withArray0_info;
         const 0;
 },
 sat_s8R9J_entry() //  [R1]
         { info_tbl: [(c8RzS,
                       label: sat_s8R9J_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RzS: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.withArray0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8RzV,
                       label: Foreign.Marshal.Array.withArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RzV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8RzZ; else goto c8RzY;
       c8RzZ: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.withArray0_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8RzY: // global
           I64[Hp - 8] = sat_s8R9J_info;
           P64[Hp] = R5;
           R5 = Hp - 7;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.withArrayLen0_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.70469657 UTC

[section ""data" . Foreign.Marshal.Array.newArray3_closure" {
     Foreign.Marshal.Array.newArray3_closure:
         const Foreign.Marshal.Array.newArray3_info;
         const 0;
 },
 Foreign.Marshal.Array.newArray3_entry() //  [R2, R3, R4]
         { info_tbl: [(c8RAe,
                       label: Foreign.Marshal.Array.newArray3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RAe: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8RAi; else goto c8RAj;
       c8RAi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.newArray3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8RAj: // global
           I64[Sp - 32] = block_c8RAc_info;
           _s8R9L::P64 = R3;
           R3 = 0;
           _s8R9K::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _s8R9K::P64;
           P64[Sp - 16] = _s8R9L::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8RAc() //  [R1]
         { info_tbl: [(c8RAc,
                       label: block_c8RAc_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RAc: // global
           I64[Sp - 8] = block_c8RAh_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_p_info;
           P64[Sp - 16] = Foreign.Marshal.Array.mallocArray1_closure;
           I64[Sp] = R1;
           Sp = Sp - 24;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8RAh() //  [R1]
         { info_tbl: [(c8RAh,
                       label: block_c8RAh_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RAh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8RAq; else goto c8RAp;
       c8RAq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8RAp: // global
           _s8R9K::P64 = P64[Sp + 16];
           _s8R9L::P64 = P64[Sp + 24];
           _s8R9M::P64 = P64[Sp + 32];
           (_s8R9X::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc((I64[Sp + 8] + 1) * I64[R1 + 7]);
           if (_s8R9X::I64 == 0) goto c8RAL; else goto c8RAI;
       c8RAL: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8RAI: // global
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8R9X::I64;
           I64[Sp + 24] = block_c8RAG_info;
           R5 = _s8R9M::P64;
           _c8RAF::P64 = Hp - 7;
           R4 = _c8RAF::P64;
           R3 = _s8R9L::P64;
           R2 = _s8R9K::P64;
           P64[Sp + 32] = _c8RAF::P64;
           Sp = Sp + 24;
           call Foreign.Marshal.Array.newArray4_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8RAG() //  []
         { info_tbl: [(c8RAG,
                       label: block_c8RAG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RAG: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.714952349 UTC

[section ""data" . Foreign.Marshal.Array.newArray0_closure" {
     Foreign.Marshal.Array.newArray0_closure:
         const Foreign.Marshal.Array.newArray0_info;
         const 0;
 },
 Foreign.Marshal.Array.newArray0_entry() //  [R2, R3, R4]
         { info_tbl: [(c8RBe,
                       label: Foreign.Marshal.Array.newArray0_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RBe: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.newArray3_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.718943404 UTC

[section ""data" . lvl22_r8PPB_closure" {
     lvl22_r8PPB_closure:
         const GHC.Types.I#_con_info;
         const 242;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.720659365 UTC

[section ""data" . lvl23_r8PPC_closure" {
     lvl23_r8PPC_closure:
         const GHC.Types.I#_con_info;
         const 21;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.722466865 UTC

[section ""data" . lvl24_r8PPD_closure" {
     lvl24_r8PPD_closure:
         const GHC.Types.I#_con_info;
         const 30;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.724260239 UTC

[section ""data" . lvl25_r8PPE_closure" {
     lvl25_r8PPE_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl22_r8PPB_closure+1;
         const lvl23_r8PPC_closure+1;
         const lvl22_r8PPB_closure+1;
         const lvl24_r8PPD_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.726413561 UTC

[section ""data" . lvl26_r8PPF_closure" {
     lvl26_r8PPF_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl25_r8PPE_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.728460657 UTC

[section ""data" . Foreign.Marshal.Array.copyArray1_closure" {
     Foreign.Marshal.Array.copyArray1_closure:
         const Foreign.Marshal.Array.copyArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.copyArray1_entry() //  [R1]
         { info_tbl: [(c8RBw,
                       label: Foreign.Marshal.Array.copyArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RBw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8RBx; else goto c8RBy;
       c8RBx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8RBy: // global
           (_c8RBt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8RBt::I64 == 0) goto c8RBv; else goto c8RBu;
       c8RBv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8RBu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8RBt::I64;
           R2 = lvl26_r8PPF_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.733800748 UTC

[section ""data" . Foreign.Marshal.Array.copyArray_closure" {
     Foreign.Marshal.Array.copyArray_closure:
         const Foreign.Marshal.Array.copyArray_info;
         const 0;
 },
 lvl33_s8Ra4_entry() //  [R1]
         { info_tbl: [(c8RBP,
                       label: lvl33_s8Ra4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RBP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8RBQ; else goto c8RBR;
       c8RBQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8RBR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.copyArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8Ran_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c8RC0,
                       label: sat_s8Ran_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RC0: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8RCe; else goto c8RCf;
       c8RCe: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8RCf: // global
           I64[Sp - 32] = block_c8RBX_info;
           _s8Ra4::P64 = P64[R1 + 4];
           R1 = R2;
           P64[Sp - 24] = _s8Ra4::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8RCz; else goto c8RBY;
       u8RCz: // global
           call _c8RBX(R1) args: 0, res: 0, upd: 0;
       c8RBY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8RBX() //  [R1]
         { info_tbl: [(c8RBX,
                       label: block_c8RBX_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RBX: // global
           I64[Sp] = block_c8RC3_info;
           _s8Raa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8Raa::I64;
           if (R1 & 7 != 0) goto u8RCy; else goto c8RC4;
       u8RCy: // global
           call _c8RC3(R1) args: 0, res: 0, upd: 0;
       c8RC4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8RC3() //  [R1]
         { info_tbl: [(c8RC3,
                       label: block_c8RC3_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RC3: // global
           I64[Sp] = block_c8RC8_info;
           _s8Rac::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s8Rac::I64;
           if (R1 & 7 != 0) goto u8RCA; else goto c8RC9;
       u8RCA: // global
           call _c8RC8(R1) args: 0, res: 0, upd: 0;
       c8RC9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8RC8() //  [R1]
         { info_tbl: [(c8RC8,
                       label: block_c8RC8_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RC8: // global
           I64[Sp] = block_c8RCd_info;
           _s8Rae::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8Rae::I64;
           if (R1 & 7 != 0) goto u8RCB; else goto c8RCj;
       u8RCB: // global
           call _c8RCd(R1) args: 0, res: 0, upd: 0;
       c8RCj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8RCd() //  [R1]
         { info_tbl: [(c8RCd,
                       label: block_c8RCd_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RCd: // global
           (_s8Ram::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memcpy(I64[Sp + 16], I64[Sp + 24], I64[Sp + 8] * I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.copyArray_entry() //  [R2]
         { info_tbl: [(c8RCC,
                       label: Foreign.Marshal.Array.copyArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RCC: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8RCG; else goto c8RCF;
       c8RCG: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.copyArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8RCF: // global
           I64[Hp - 32] = lvl33_s8Ra4_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8Ran_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.748781961 UTC

[section ""data" . lvl27_r8PPG_closure" {
     lvl27_r8PPG_closure:
         const GHC.Types.I#_con_info;
         const 251;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.750557107 UTC

[section ""data" . lvl28_r8PPH_closure" {
     lvl28_r8PPH_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl27_r8PPG_closure+1;
         const lvl23_r8PPC_closure+1;
         const lvl27_r8PPG_closure+1;
         const lvl24_r8PPD_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.752907328 UTC

[section ""data" . lvl29_r8PPI_closure" {
     lvl29_r8PPI_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl28_r8PPH_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.754945837 UTC

[section ""data" . Foreign.Marshal.Array.moveArray1_closure" {
     Foreign.Marshal.Array.moveArray1_closure:
         const Foreign.Marshal.Array.moveArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.moveArray1_entry() //  [R1]
         { info_tbl: [(c8RDx,
                       label: Foreign.Marshal.Array.moveArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RDx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8RDy; else goto c8RDz;
       c8RDy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8RDz: // global
           (_c8RDu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8RDu::I64 == 0) goto c8RDw; else goto c8RDv;
       c8RDw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8RDv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8RDu::I64;
           R2 = lvl29_r8PPI_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.760062928 UTC

[section ""data" . Foreign.Marshal.Array.moveArray_closure" {
     Foreign.Marshal.Array.moveArray_closure:
         const Foreign.Marshal.Array.moveArray_info;
         const 0;
 },
 lvl33_s8Rap_entry() //  [R1]
         { info_tbl: [(c8RDQ,
                       label: lvl33_s8Rap_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RDQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8RDR; else goto c8RDS;
       c8RDR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8RDS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.moveArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8RaI_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c8RE1,
                       label: sat_s8RaI_info
                       rep:HeapRep 1 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RE1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8REf; else goto c8REg;
       c8REf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8REg: // global
           I64[Sp - 32] = block_c8RDY_info;
           _s8Rap::P64 = P64[R1 + 4];
           R1 = R2;
           P64[Sp - 24] = _s8Rap::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8REA; else goto c8RDZ;
       u8REA: // global
           call _c8RDY(R1) args: 0, res: 0, upd: 0;
       c8RDZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8RDY() //  [R1]
         { info_tbl: [(c8RDY,
                       label: block_c8RDY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RDY: // global
           I64[Sp] = block_c8RE4_info;
           _s8Rav::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8Rav::I64;
           if (R1 & 7 != 0) goto u8REz; else goto c8RE5;
       u8REz: // global
           call _c8RE4(R1) args: 0, res: 0, upd: 0;
       c8RE5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8RE4() //  [R1]
         { info_tbl: [(c8RE4,
                       label: block_c8RE4_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RE4: // global
           I64[Sp] = block_c8RE9_info;
           _s8Rax::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s8Rax::I64;
           if (R1 & 7 != 0) goto u8REB; else goto c8REa;
       u8REB: // global
           call _c8RE9(R1) args: 0, res: 0, upd: 0;
       c8REa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8RE9() //  [R1]
         { info_tbl: [(c8RE9,
                       label: block_c8RE9_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RE9: // global
           I64[Sp] = block_c8REe_info;
           _s8Raz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8Raz::I64;
           if (R1 & 7 != 0) goto u8REC; else goto c8REk;
       u8REC: // global
           call _c8REe(R1) args: 0, res: 0, upd: 0;
       c8REk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8REe() //  [R1]
         { info_tbl: [(c8REe,
                       label: block_c8REe_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8REe: // global
           (_s8RaH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint,]  result hints:  [PtrHint] memmove(I64[Sp + 16], I64[Sp + 24], I64[Sp + 8] * I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.moveArray_entry() //  [R2]
         { info_tbl: [(c8RED,
                       label: Foreign.Marshal.Array.moveArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RED: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8REH; else goto c8REG;
       c8REH: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.moveArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8REG: // global
           I64[Hp - 32] = lvl33_s8Rap_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8RaI_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 4;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.775992131 UTC

[section ""data" . Foreign.Marshal.Array.lengthArray1_closure" {
     Foreign.Marshal.Array.lengthArray1_closure:
         const Foreign.Marshal.Array.lengthArray1_info;
 },
 sat_s8RaY_entry() //  [R1]
         { info_tbl: [(c8RFL,
                       label: sat_s8RaY_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RFL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8RFS; else goto c8RFT;
       c8RFS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8RFT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8RFI_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8RFX; else goto c8RFJ;
       u8RFX: // global
           call _c8RFI(R1) args: 0, res: 0, upd: 0;
       c8RFJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8RFI() //  [R1]
         { info_tbl: [(c8RFI,
                       label: block_c8RFI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RFI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8RFW; else goto c8RFV;
       c8RFW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8RFV: // global
           _s8RaX::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8RaX::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Marshal.Array.lengthArray1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8RFY,
                       label: Foreign.Marshal.Array.lengthArray1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RFY: // global
           if ((Sp + -72) < SpLim) (likely: False) goto c8RFZ; else goto c8RG0;
       c8RFZ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.lengthArray1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8RG0: // global
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = Foreign.Marshal.Array.lengthArray2_closure+1;
           Sp = Sp - 40;
           call _c8RFw() args: 0, res: 0, upd: 0;
     }
 },
 _c8RFw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RFw: // global
           I64[Sp - 8] = block_c8RFy_info;
           R2 = P64[Sp];
           I64[Sp - 32] = stg_ap_ppv_info;
           P64[Sp - 24] = P64[Sp + 24];
           P64[Sp - 16] = P64[Sp + 32];
           Sp = Sp - 32;
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8RFy() //  [R1]
         { info_tbl: [(c8RFy,
                       label: block_c8RFy_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RFy: // global
           I64[Sp] = block_c8RFA_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R1;
           P64[Sp - 8] = P64[Sp + 24];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c8RFA() //  [R1]
         { info_tbl: [(c8RFA,
                       label: block_c8RFA_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RFA: // global
           _s8RaP::P64 = P64[Sp + 40];
           if (R1 & 7 == 1) goto c8RG4; else goto c8RGb;
       c8RG4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8RG7; else goto c8RG6;
       c8RG7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8RG6: // global
           I64[Hp - 16] = sat_s8RaY_info;
           P64[Hp] = _s8RaP::P64;
           P64[Sp + 40] = Hp - 16;
           Sp = Sp + 8;
           call _c8RFw() args: 0, res: 0, upd: 0;
       c8RGb: // global
           R1 = _s8RaP::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.78943806 UTC

[section ""data" . Foreign.Marshal.Array.lengthArray0_closure" {
     Foreign.Marshal.Array.lengthArray0_closure:
         const Foreign.Marshal.Array.lengthArray0_info;
 },
 Foreign.Marshal.Array.lengthArray0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8RGY,
                       label: Foreign.Marshal.Array.lengthArray0_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RGY: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.lengthArray1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.7935223 UTC

[section ""data" . Foreign.Marshal.Array.peekArray2_closure" {
     Foreign.Marshal.Array.peekArray2_closure:
         const Foreign.Marshal.Array.peekArray2_info;
 },
 Foreign.Marshal.Array.peekArray2_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8RHb,
                       label: Foreign.Marshal.Array.peekArray2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RHb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8RHc; else goto c8RHd;
       c8RHc: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Marshal.Array.peekArray2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c8RHd: // global
           I64[Sp - 24] = block_c8RH9_info;
           _s8Rb2::P64 = R5;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           _s8RaZ::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s8RaZ::P64;
           P64[Sp - 8] = _s8Rb2::P64;
           Sp = Sp - 24;
           call Foreign.Marshal.Array.lengthArray1_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8RH9() //  [R1]
         { info_tbl: [(c8RH9,
                       label: block_c8RH9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RH9: // global
           R4 = P64[Sp + 16];
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.Marshal.Array.peekArray1_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.799288185 UTC

[section ""data" . Foreign.Marshal.Array.peekArray0_closure" {
     Foreign.Marshal.Array.peekArray0_closure:
         const Foreign.Marshal.Array.peekArray0_info;
 },
 Foreign.Marshal.Array.peekArray0_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c8RHs,
                       label: Foreign.Marshal.Array.peekArray0_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RHs: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.Marshal.Array.peekArray2_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.802665105 UTC

[section ""data" . lvl30_r8PPJ_closure" {
     lvl30_r8PPJ_closure:
         const GHC.Types.I#_con_info;
         const 276;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.804388293 UTC

[section ""data" . lvl31_r8PPK_closure" {
     lvl31_r8PPK_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r8PPh_closure;
         const lvl3_r8PPi_closure;
         const lvl5_r8PPk_closure;
         const lvl30_r8PPJ_closure+1;
         const lvl7_r8PPm_closure+1;
         const lvl30_r8PPJ_closure+1;
         const lvl8_r8PPn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.806290173 UTC

[section ""data" . lvl32_r8PPL_closure" {
     lvl32_r8PPL_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r8PPg_closure;
         const lvl31_r8PPK_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.808251212 UTC

[section ""data" . Foreign.Marshal.Array.advancePtr1_closure" {
     Foreign.Marshal.Array.advancePtr1_closure:
         const Foreign.Marshal.Array.advancePtr1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Marshal.Array.advancePtr1_entry() //  [R1]
         { info_tbl: [(c8RHI,
                       label: Foreign.Marshal.Array.advancePtr1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RHI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8RHJ; else goto c8RHK;
       c8RHJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8RHK: // global
           (_c8RHF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8RHF::I64 == 0) goto c8RHH; else goto c8RHG;
       c8RHH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8RHG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8RHF::I64;
           R2 = lvl32_r8PPL_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.813537018 UTC

[section ""data" . Foreign.Marshal.Array.advancePtr_closure" {
     Foreign.Marshal.Array.advancePtr_closure:
         const Foreign.Marshal.Array.advancePtr_info;
         const 0;
 },
 lvl33_s8Rb8_entry() //  [R1]
         { info_tbl: [(c8RI1,
                       label: lvl33_s8Rb8_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RI1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8RI2; else goto c8RI3;
       c8RI2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8RI3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Marshal.Array.advancePtr1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s8Rbj_entry() //  [R1, R2, R3]
         { info_tbl: [(c8RIc,
                       label: sat_s8Rbj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RIc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8RIw; else goto c8RIx;
       c8RIw: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8RIx: // global
           I64[Sp - 24] = block_c8RI9_info;
           _s8Rb8::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 16] = _s8Rb8::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8RIE; else goto c8RIa;
       u8RIE: // global
           call _c8RI9(R1) args: 0, res: 0, upd: 0;
       c8RIa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8RI9() //  [R1]
         { info_tbl: [(c8RI9,
                       label: block_c8RI9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RI9: // global
           I64[Sp] = block_c8RIf_info;
           _s8Rbc::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s8Rbc::I64;
           if (R1 & 7 != 0) goto u8RID; else goto c8RIg;
       u8RID: // global
           call _c8RIf(R1) args: 0, res: 0, upd: 0;
       c8RIg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8RIf() //  [R1]
         { info_tbl: [(c8RIf,
                       label: block_c8RIf_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RIf: // global
           I64[Sp] = block_c8RIk_info;
           _s8Rbe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s8Rbe::I64;
           if (R1 & 7 != 0) goto u8RIF; else goto c8RIl;
       u8RIF: // global
           call _c8RIk(R1) args: 0, res: 0, upd: 0;
       c8RIl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8RIk() //  [R1]
         { info_tbl: [(c8RIk,
                       label: block_c8RIk_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RIk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8RIC; else goto c8RIB;
       c8RIC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8RIB: // global
           _s8Rbi::I64 = I64[Sp + 16] + I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8Rbi::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Marshal.Array.advancePtr_entry() //  [R2]
         { info_tbl: [(c8RIG,
                       label: Foreign.Marshal.Array.advancePtr_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8RIG: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8RIK; else goto c8RIJ;
       c8RIK: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.Marshal.Array.advancePtr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8RIJ: // global
           I64[Hp - 32] = lvl33_s8Rb8_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8Rbj_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.827840298 UTC

[section ""data" . Foreign.Marshal.Array.$trModule3_closure" {
     Foreign.Marshal.Array.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Array.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.829648708 UTC

[section ""data" . Foreign.Marshal.Array.$trModule1_closure" {
     Foreign.Marshal.Array.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Marshal.Array.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.831308168 UTC

[section ""data" . Foreign.Marshal.Array.$trModule_closure" {
     Foreign.Marshal.Array.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Marshal.Array.$trModule3_closure+1;
         const Foreign.Marshal.Array.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:01.833088842 UTC

[section ""relreadonly" . S8RcI_srt" {
     S8RcI_srt:
         const GHC.Err.undefined_closure;
         const lvl10_r8PPp_closure;
         const Foreign.Marshal.Array.mallocArray1_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Array.mallocArray_closure;
         const Foreign.Marshal.Array.$wmallocArray0_closure;
         const Foreign.Marshal.Array.mallocArray2_closure;
         const lvl13_r8PPs_closure;
         const Foreign.Marshal.Array.callocArray1_closure;
         const Foreign.Marshal.Alloc.calloc1_closure;
         const Foreign.Marshal.Array.callocArray_closure;
         const Foreign.Marshal.Array.$wcallocArray0_closure;
         const Foreign.Marshal.Array.callocArray2_closure;
         const lvl16_r8PPv_closure;
         const Foreign.Marshal.Array.allocaArray1_closure;
         const Foreign.Marshal.Array.allocaArray_closure;
         const Foreign.Marshal.Array.allocaArray0_closure;
         const lvl21_r8PPA_closure;
         const Foreign.Marshal.Array.reallocArray1_closure;
         const Foreign.Marshal.Alloc.realloc2_closure;
         const Foreign.Marshal.Array.reallocArray_closure;
         const Foreign.Marshal.Array.$wreallocArray0_closure;
         const Foreign.Marshal.Array.reallocArray2_closure;
         const Foreign.Marshal.Array.withArrayLen_closure;
         const Foreign.Marshal.Array.withArray_closure;
         const Foreign.Marshal.Array.newArray1_closure;
         const Foreign.Marshal.Array.withArrayLen0_closure;
         const Foreign.Marshal.Array.withArray0_closure;
         const Foreign.Marshal.Array.newArray3_closure;
         const lvl26_r8PPF_closure;
         const Foreign.Marshal.Array.copyArray1_closure;
         const Foreign.Marshal.Array.copyArray_closure;
         const lvl29_r8PPI_closure;
         const GHC.Err.undefined_closure;
         const Foreign.Marshal.Array.moveArray1_closure;
         const Foreign.Marshal.Array.moveArray_closure;
         const lvl32_r8PPL_closure;
         const Foreign.Marshal.Array.advancePtr1_closure;
         const Foreign.Marshal.Array.advancePtr_closure;
 }]

