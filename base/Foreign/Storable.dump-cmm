
==================== Output Cmm ====================
2018-03-16 15:59:30.651767396 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:30.652792443 UTC

[section ""data" . Foreign.Storable.sizeOf_closure" {
     Foreign.Storable.sizeOf_closure:
         const Foreign.Storable.sizeOf_info;
 },
 Foreign.Storable.sizeOf_entry() //  [R2]
         { info_tbl: [(c4Fxl,
                       label: Foreign.Storable.sizeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Fxl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Fxm; else goto c4Fxn;
       c4Fxm: // global
           R2 = R2;
           R1 = Foreign.Storable.sizeOf_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Fxn: // global
           I64[Sp - 8] = block_c4Fxi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Fxr; else goto c4Fxj;
       u4Fxr: // global
           call _c4Fxi(R1) args: 0, res: 0, upd: 0;
       c4Fxj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Fxi() //  [R1]
         { info_tbl: [(c4Fxi,
                       label: block_c4Fxi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Fxi: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.654143663 UTC

[section ""data" . Foreign.Storable.alignment_closure" {
     Foreign.Storable.alignment_closure:
         const Foreign.Storable.alignment_info;
 },
 Foreign.Storable.alignment_entry() //  [R2]
         { info_tbl: [(c4Fxz,
                       label: Foreign.Storable.alignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Fxz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4FxA; else goto c4FxB;
       c4FxA: // global
           R2 = R2;
           R1 = Foreign.Storable.alignment_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4FxB: // global
           I64[Sp - 8] = block_c4Fxw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4FxF; else goto c4Fxx;
       u4FxF: // global
           call _c4Fxw(R1) args: 0, res: 0, upd: 0;
       c4Fxx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Fxw() //  [R1]
         { info_tbl: [(c4Fxw,
                       label: block_c4Fxw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Fxw: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.655313953 UTC

[section ""data" . Foreign.Storable.peekElemOff_closure" {
     Foreign.Storable.peekElemOff_closure:
         const Foreign.Storable.peekElemOff_info;
 },
 Foreign.Storable.peekElemOff_entry() //  [R2]
         { info_tbl: [(c4FxN,
                       label: Foreign.Storable.peekElemOff_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FxN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4FxO; else goto c4FxP;
       c4FxO: // global
           R2 = R2;
           R1 = Foreign.Storable.peekElemOff_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4FxP: // global
           I64[Sp - 8] = block_c4FxK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4FxT; else goto c4FxL;
       u4FxT: // global
           call _c4FxK(R1) args: 0, res: 0, upd: 0;
       c4FxL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FxK() //  [R1]
         { info_tbl: [(c4FxK,
                       label: block_c4FxK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FxK: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.656479631 UTC

[section ""data" . Foreign.Storable.pokeElemOff_closure" {
     Foreign.Storable.pokeElemOff_closure:
         const Foreign.Storable.pokeElemOff_info;
 },
 Foreign.Storable.pokeElemOff_entry() //  [R2]
         { info_tbl: [(c4Fy1,
                       label: Foreign.Storable.pokeElemOff_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Fy1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Fy2; else goto c4Fy3;
       c4Fy2: // global
           R2 = R2;
           R1 = Foreign.Storable.pokeElemOff_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Fy3: // global
           I64[Sp - 8] = block_c4FxY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Fy7; else goto c4FxZ;
       u4Fy7: // global
           call _c4FxY(R1) args: 0, res: 0, upd: 0;
       c4FxZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FxY() //  [R1]
         { info_tbl: [(c4FxY,
                       label: block_c4FxY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FxY: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.657714325 UTC

[section ""data" . Foreign.Storable.peekByteOff_closure" {
     Foreign.Storable.peekByteOff_closure:
         const Foreign.Storable.peekByteOff_info;
 },
 Foreign.Storable.peekByteOff_entry() //  [R2]
         { info_tbl: [(c4Fyf,
                       label: Foreign.Storable.peekByteOff_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Fyf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Fyg; else goto c4Fyh;
       c4Fyg: // global
           R2 = R2;
           R1 = Foreign.Storable.peekByteOff_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Fyh: // global
           I64[Sp - 8] = block_c4Fyc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Fyl; else goto c4Fyd;
       u4Fyl: // global
           call _c4Fyc(R1) args: 0, res: 0, upd: 0;
       c4Fyd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Fyc() //  [R1]
         { info_tbl: [(c4Fyc,
                       label: block_c4Fyc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Fyc: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.658838246 UTC

[section ""data" . Foreign.Storable.pokeByteOff_closure" {
     Foreign.Storable.pokeByteOff_closure:
         const Foreign.Storable.pokeByteOff_info;
 },
 Foreign.Storable.pokeByteOff_entry() //  [R2]
         { info_tbl: [(c4Fyt,
                       label: Foreign.Storable.pokeByteOff_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Fyt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Fyu; else goto c4Fyv;
       c4Fyu: // global
           R2 = R2;
           R1 = Foreign.Storable.pokeByteOff_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Fyv: // global
           I64[Sp - 8] = block_c4Fyq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Fyz; else goto c4Fyr;
       u4Fyz: // global
           call _c4Fyq(R1) args: 0, res: 0, upd: 0;
       c4Fyr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Fyq() //  [R1]
         { info_tbl: [(c4Fyq,
                       label: block_c4Fyq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Fyq: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.66003449 UTC

[section ""data" . Foreign.Storable.peek_closure" {
     Foreign.Storable.peek_closure:
         const Foreign.Storable.peek_info;
 },
 Foreign.Storable.peek_entry() //  [R2]
         { info_tbl: [(c4FyH,
                       label: Foreign.Storable.peek_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FyH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4FyI; else goto c4FyJ;
       c4FyI: // global
           R2 = R2;
           R1 = Foreign.Storable.peek_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4FyJ: // global
           I64[Sp - 8] = block_c4FyE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4FyN; else goto c4FyF;
       u4FyN: // global
           call _c4FyE(R1) args: 0, res: 0, upd: 0;
       c4FyF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FyE() //  [R1]
         { info_tbl: [(c4FyE,
                       label: block_c4FyE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FyE: // global
           R1 = P64[R1 + 55];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.661173256 UTC

[section ""data" . Foreign.Storable.poke_closure" {
     Foreign.Storable.poke_closure:
         const Foreign.Storable.poke_info;
 },
 Foreign.Storable.poke_entry() //  [R2]
         { info_tbl: [(c4FyV,
                       label: Foreign.Storable.poke_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FyV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4FyW; else goto c4FyX;
       c4FyW: // global
           R2 = R2;
           R1 = Foreign.Storable.poke_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4FyX: // global
           I64[Sp - 8] = block_c4FyS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Fz1; else goto c4FyT;
       u4Fz1: // global
           call _c4FyS(R1) args: 0, res: 0, upd: 0;
       c4FyT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FyS() //  [R1]
         { info_tbl: [(c4FyS,
                       label: block_c4FyS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FyS: // global
           R1 = P64[R1 + 63];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.662153817 UTC

[section ""data" . Foreign.Storable.$fStorable()7_closure" {
     Foreign.Storable.$fStorable()7_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.662851177 UTC

[section ""data" . Foreign.Storable.$fStorable()_$calignment_closure" {
     Foreign.Storable.$fStorable()_$calignment_closure:
         const Foreign.Storable.$fStorable()_$calignment_info;
 },
 Foreign.Storable.$fStorable()_$calignment_entry() //  []
         { info_tbl: [(c4Fz6,
                       label: Foreign.Storable.$fStorable()_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Fz6: // global
           R1 = Foreign.Storable.$fStorable()7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.663566024 UTC

[section ""data" . Foreign.Storable.$fStorable()8_closure" {
     Foreign.Storable.$fStorable()8_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.664242355 UTC

[section ""data" . Foreign.Storable.$fStorable()_$csizeOf_closure" {
     Foreign.Storable.$fStorable()_$csizeOf_closure:
         const Foreign.Storable.$fStorable()_$csizeOf_info;
 },
 Foreign.Storable.$fStorable()_$csizeOf_entry() //  []
         { info_tbl: [(c4Fzd,
                       label: Foreign.Storable.$fStorable()_$csizeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Fzd: // global
           R1 = Foreign.Storable.$fStorable()8_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.664933062 UTC

[section ""data" . Foreign.Storable.$fStorableBool7_closure" {
     Foreign.Storable.$fStorableBool7_closure:
         const GHC.Types.I#_con_info;
         const 4;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.665634463 UTC

[section ""data" . Foreign.Storable.$fStorableChar_$calignment_closure" {
     Foreign.Storable.$fStorableChar_$calignment_closure:
         const Foreign.Storable.$fStorableChar_$calignment_info;
 },
 Foreign.Storable.$fStorableChar_$calignment_entry() //  []
         { info_tbl: [(c4Fzk,
                       label: Foreign.Storable.$fStorableChar_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Fzk: // global
           R1 = Foreign.Storable.$fStorableBool7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.666322218 UTC

[section ""data" . Foreign.Storable.$fStorableDouble5_closure" {
     Foreign.Storable.$fStorableDouble5_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.667002224 UTC

[section ""data" . Foreign.Storable.$fStorableInt_$calignment_closure" {
     Foreign.Storable.$fStorableInt_$calignment_closure:
         const Foreign.Storable.$fStorableInt_$calignment_info;
 },
 Foreign.Storable.$fStorableInt_$calignment_entry() //  []
         { info_tbl: [(c4Fzr,
                       label: Foreign.Storable.$fStorableInt_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Fzr: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.667777365 UTC

[section ""data" . Foreign.Storable.$fStorableWord_$calignment_closure" {
     Foreign.Storable.$fStorableWord_$calignment_closure:
         const Foreign.Storable.$fStorableWord_$calignment_info;
 },
 Foreign.Storable.$fStorableWord_$calignment_entry() //  []
         { info_tbl: [(c4Fzy,
                       label: Foreign.Storable.$fStorableWord_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Fzy: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.668601049 UTC

[section ""data" . Foreign.Storable.$fStorablePtr_$calignment_closure" {
     Foreign.Storable.$fStorablePtr_$calignment_closure:
         const Foreign.Storable.$fStorablePtr_$calignment_info;
 },
 Foreign.Storable.$fStorablePtr_$calignment_entry() //  []
         { info_tbl: [(c4FzF,
                       label: Foreign.Storable.$fStorablePtr_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FzF: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.669478075 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr_$calignment_closure" {
     Foreign.Storable.$fStorableFunPtr_$calignment_closure:
         const Foreign.Storable.$fStorableFunPtr_$calignment_info;
 },
 Foreign.Storable.$fStorableFunPtr_$calignment_entry() //  []
         { info_tbl: [(c4FzM,
                       label: Foreign.Storable.$fStorableFunPtr_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FzM: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.670280574 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr_$calignment_closure" {
     Foreign.Storable.$fStorableStablePtr_$calignment_closure:
         const Foreign.Storable.$fStorableStablePtr_$calignment_info;
 },
 Foreign.Storable.$fStorableStablePtr_$calignment_entry() //  []
         { info_tbl: [(c4FzT,
                       label: Foreign.Storable.$fStorableStablePtr_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FzT: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.671063108 UTC

[section ""data" . Foreign.Storable.$fStorableFloat_$calignment_closure" {
     Foreign.Storable.$fStorableFloat_$calignment_closure:
         const Foreign.Storable.$fStorableFloat_$calignment_info;
 },
 Foreign.Storable.$fStorableFloat_$calignment_entry() //  []
         { info_tbl: [(c4FA0,
                       label: Foreign.Storable.$fStorableFloat_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FA0: // global
           R1 = Foreign.Storable.$fStorableBool7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.67188851 UTC

[section ""data" . Foreign.Storable.$fStorableDouble_$calignment_closure" {
     Foreign.Storable.$fStorableDouble_$calignment_closure:
         const Foreign.Storable.$fStorableDouble_$calignment_info;
 },
 Foreign.Storable.$fStorableDouble_$calignment_entry() //  []
         { info_tbl: [(c4FA7,
                       label: Foreign.Storable.$fStorableDouble_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FA7: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.67271236 UTC

[section ""data" . Foreign.Storable.$fStorableWord8_$calignment_closure" {
     Foreign.Storable.$fStorableWord8_$calignment_closure:
         const Foreign.Storable.$fStorableWord8_$calignment_info;
 },
 Foreign.Storable.$fStorableWord8_$calignment_entry() //  []
         { info_tbl: [(c4FAe,
                       label: Foreign.Storable.$fStorableWord8_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FAe: // global
           R1 = Foreign.Storable.$fStorable()7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.673455467 UTC

[section ""data" . Foreign.Storable.$fStorableInt10_closure" {
     Foreign.Storable.$fStorableInt10_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.674165158 UTC

[section ""data" . Foreign.Storable.$fStorableWord16_$calignment_closure" {
     Foreign.Storable.$fStorableWord16_$calignment_closure:
         const Foreign.Storable.$fStorableWord16_$calignment_info;
 },
 Foreign.Storable.$fStorableWord16_$calignment_entry() //  []
         { info_tbl: [(c4FAl,
                       label: Foreign.Storable.$fStorableWord16_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FAl: // global
           R1 = Foreign.Storable.$fStorableInt10_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.675006543 UTC

[section ""data" . Foreign.Storable.$fStorableWord32_$calignment_closure" {
     Foreign.Storable.$fStorableWord32_$calignment_closure:
         const Foreign.Storable.$fStorableWord32_$calignment_info;
 },
 Foreign.Storable.$fStorableWord32_$calignment_entry() //  []
         { info_tbl: [(c4FAs,
                       label: Foreign.Storable.$fStorableWord32_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FAs: // global
           R1 = Foreign.Storable.$fStorableBool7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.675896857 UTC

[section ""data" . Foreign.Storable.$fStorableWord64_$calignment_closure" {
     Foreign.Storable.$fStorableWord64_$calignment_closure:
         const Foreign.Storable.$fStorableWord64_$calignment_info;
 },
 Foreign.Storable.$fStorableWord64_$calignment_entry() //  []
         { info_tbl: [(c4FAz,
                       label: Foreign.Storable.$fStorableWord64_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FAz: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.677707699 UTC

[section ""data" . Foreign.Storable.$fStorableInt8_$calignment_closure" {
     Foreign.Storable.$fStorableInt8_$calignment_closure:
         const Foreign.Storable.$fStorableInt8_$calignment_info;
 },
 Foreign.Storable.$fStorableInt8_$calignment_entry() //  []
         { info_tbl: [(c4FAG,
                       label: Foreign.Storable.$fStorableInt8_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FAG: // global
           R1 = Foreign.Storable.$fStorable()7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.678498853 UTC

[section ""data" . Foreign.Storable.$fStorableInt16_$calignment_closure" {
     Foreign.Storable.$fStorableInt16_$calignment_closure:
         const Foreign.Storable.$fStorableInt16_$calignment_info;
 },
 Foreign.Storable.$fStorableInt16_$calignment_entry() //  []
         { info_tbl: [(c4FAN,
                       label: Foreign.Storable.$fStorableInt16_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FAN: // global
           R1 = Foreign.Storable.$fStorableInt10_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.679312507 UTC

[section ""data" . Foreign.Storable.$fStorableInt32_$calignment_closure" {
     Foreign.Storable.$fStorableInt32_$calignment_closure:
         const Foreign.Storable.$fStorableInt32_$calignment_info;
 },
 Foreign.Storable.$fStorableInt32_$calignment_entry() //  []
         { info_tbl: [(c4FAU,
                       label: Foreign.Storable.$fStorableInt32_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FAU: // global
           R1 = Foreign.Storable.$fStorableBool7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.680119035 UTC

[section ""data" . Foreign.Storable.$fStorableInt64_$calignment_closure" {
     Foreign.Storable.$fStorableInt64_$calignment_closure:
         const Foreign.Storable.$fStorableInt64_$calignment_info;
 },
 Foreign.Storable.$fStorableInt64_$calignment_entry() //  []
         { info_tbl: [(c4FB1,
                       label: Foreign.Storable.$fStorableInt64_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FB1: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.680824765 UTC

[section ""cstring" . lvl_r4Ff9_bytes" {
     lvl_r4Ff9_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.681818348 UTC

[section ""data" . lvl1_r4Ffa_closure" {
     lvl1_r4Ffa_closure:
         const lvl1_r4Ffa_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r4Ffa_entry() //  [R1]
         { info_tbl: [(c4FBa,
                       label: lvl1_r4Ffa_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FBa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FBb; else goto c4FBc;
       c4FBb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4FBc: // global
           (_c4FB7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4FB7::I64 == 0) goto c4FB9; else goto c4FB8;
       c4FB9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4FB8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4FB7::I64;
           R2 = lvl_r4Ff9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.682633122 UTC

[section ""cstring" . Foreign.Storable.$trModule4_bytes" {
     Foreign.Storable.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.683362829 UTC

[section ""data" . lvl2_r4Ffb_closure" {
     lvl2_r4Ffb_closure:
         const lvl2_r4Ffb_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r4Ffb_entry() //  [R1]
         { info_tbl: [(c4FBj,
                       label: lvl2_r4Ffb_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FBj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FBk; else goto c4FBl;
       c4FBk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4FBl: // global
           (_c4FBg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4FBg::I64 == 0) goto c4FBi; else goto c4FBh;
       c4FBi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4FBh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4FBg::I64;
           R2 = Foreign.Storable.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.684274878 UTC

[section ""cstring" . Foreign.Storable.$trModule2_bytes" {
     Foreign.Storable.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,83,116,111,114,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.68500002 UTC

[section ""data" . lvl3_r4Ffc_closure" {
     lvl3_r4Ffc_closure:
         const lvl3_r4Ffc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r4Ffc_entry() //  [R1]
         { info_tbl: [(c4FBs,
                       label: lvl3_r4Ffc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FBs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FBt; else goto c4FBu;
       c4FBt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4FBu: // global
           (_c4FBp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4FBp::I64 == 0) goto c4FBr; else goto c4FBq;
       c4FBr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4FBq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4FBp::I64;
           R2 = Foreign.Storable.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.685913284 UTC

[section ""cstring" . lvl4_r4Ffd_bytes" {
     lvl4_r4Ffd_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,83,116,111,114,97,98,108,101,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.686658592 UTC

[section ""data" . lvl5_r4Ffe_closure" {
     lvl5_r4Ffe_closure:
         const lvl5_r4Ffe_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r4Ffe_entry() //  [R1]
         { info_tbl: [(c4FBB,
                       label: lvl5_r4Ffe_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FBB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FBC; else goto c4FBD;
       c4FBC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4FBD: // global
           (_c4FBy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4FBy::I64 == 0) goto c4FBA; else goto c4FBz;
       c4FBA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4FBz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4FBy::I64;
           R2 = lvl4_r4Ffd_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.68756803 UTC

[section ""data" . lvl6_r4Fff_closure" {
     lvl6_r4Fff_closure:
         const GHC.Types.I#_con_info;
         const 238;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.688132534 UTC

[section ""data" . lvl7_r4Ffg_closure" {
     lvl7_r4Ffg_closure:
         const GHC.Types.I#_con_info;
         const 30;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.68867107 UTC

[section ""data" . lvl8_r4Ffh_closure" {
     lvl8_r4Ffh_closure:
         const GHC.Types.I#_con_info;
         const 39;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.68931502 UTC

[section ""data" . lvl9_r4Ffi_closure" {
     lvl9_r4Ffi_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r4Ffb_closure;
         const lvl3_r4Ffc_closure;
         const lvl5_r4Ffe_closure;
         const lvl6_r4Fff_closure+1;
         const lvl7_r4Ffg_closure+1;
         const lvl6_r4Fff_closure+1;
         const lvl8_r4Ffh_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.690049454 UTC

[section ""data" . lvl10_r4Ffj_closure" {
     lvl10_r4Ffj_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r4Ffa_closure;
         const lvl9_r4Ffi_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.690954254 UTC

[section ""data" . Foreign.Storable.$fStorableRatio8_closure" {
     Foreign.Storable.$fStorableRatio8_closure:
         const Foreign.Storable.$fStorableRatio8_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Storable.$fStorableRatio8_entry() //  [R1]
         { info_tbl: [(c4FBK,
                       label: Foreign.Storable.$fStorableRatio8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FBK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FBL; else goto c4FBM;
       c4FBL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4FBM: // global
           (_c4FBH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4FBH::I64 == 0) goto c4FBJ; else goto c4FBI;
       c4FBJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4FBI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4FBH::I64;
           R2 = lvl10_r4Ffj_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.692331722 UTC

[section ""data" . Foreign.Storable.$fStorableRatio_$calignment_closure" {
     Foreign.Storable.$fStorableRatio_$calignment_closure:
         const Foreign.Storable.$fStorableRatio_$calignment_info;
         const 0;
 },
 lvl20_s4Fh7_entry() //  [R1]
         { info_tbl: [(c4FBW,
                       label: lvl20_s4Fh7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FBW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4FBX; else goto c4FBY;
       c4FBX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4FBY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Storable.$fStorableRatio8_closure;
           Sp = Sp - 32;
           call Foreign.Storable.alignment_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s4Fh9_entry() //  [R1]
         { info_tbl: [(c4FC4,
                       label: sat_s4Fh9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FC4: // global
           R1 = P64[R1 + 7] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Storable.$fStorableRatio_$calignment_entry() //  [R2, R3]
         { info_tbl: [(c4FC7,
                       label: Foreign.Storable.$fStorableRatio_$calignment_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FC7: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4FCb; else goto c4FCa;
       c4FCb: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio_$calignment_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FCa: // global
           I64[Hp - 32] = lvl20_s4Fh7_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s4Fh9_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.693743427 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint_$calignment_closure" {
     Foreign.Storable.$fStorableFingerprint_$calignment_closure:
         const Foreign.Storable.$fStorableFingerprint_$calignment_info;
 },
 Foreign.Storable.$fStorableFingerprint_$calignment_entry() //  []
         { info_tbl: [(c4FCg,
                       label: Foreign.Storable.$fStorableFingerprint_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FCg: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.694428472 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint7_closure" {
     Foreign.Storable.$fStorableFingerprint7_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.695061361 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint_$csizeOf_closure" {
     Foreign.Storable.$fStorableFingerprint_$csizeOf_closure:
         const Foreign.Storable.$fStorableFingerprint_$csizeOf_info;
 },
 Foreign.Storable.$fStorableFingerprint_$csizeOf_entry() //  []
         { info_tbl: [(c4FCn,
                       label: Foreign.Storable.$fStorableFingerprint_$csizeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FCn: // global
           R1 = Foreign.Storable.$fStorableFingerprint7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.695991583 UTC

[section ""data" . Foreign.Storable.$dmpoke_closure" {
     Foreign.Storable.$dmpoke_closure:
         const Foreign.Storable.$dmpoke_info;
 },
 Foreign.Storable.$dmpoke_entry() //  [R2, R3]
         { info_tbl: [(c4FCu,
                       label: Foreign.Storable.$dmpoke_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FCu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4FCv; else goto c4FCw;
       c4FCv: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$dmpoke_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FCw: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = Foreign.Storable.$fStorable()8_closure+1;
           Sp = Sp - 24;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.696985271 UTC

[section ""data" . Foreign.Storable.$dmpeek_closure" {
     Foreign.Storable.$dmpeek_closure:
         const Foreign.Storable.$dmpeek_info;
 },
 Foreign.Storable.$dmpeek_entry() //  [R2, R3]
         { info_tbl: [(c4FCB,
                       label: Foreign.Storable.$dmpeek_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FCB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4FCC; else goto c4FCD;
       c4FCC: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$dmpeek_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FCD: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = Foreign.Storable.$fStorable()8_closure+1;
           Sp = Sp - 24;
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.698996594 UTC

[section ""data" . Foreign.Storable.$dmpokeByteOff_closure" {
     Foreign.Storable.$dmpokeByteOff_closure:
         const Foreign.Storable.$dmpokeByteOff_info;
 },
 sat_s4Fho_entry() //  [R1]
         { info_tbl: [(c4FCP,
                       label: sat_s4Fho_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FCP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4FD1; else goto c4FD2;
       c4FD1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4FD2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4FCM_info;
           _s4Fhi::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4Fhi::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4FD8; else goto c4FCN;
       u4FD8: // global
           call _c4FCM(R1) args: 0, res: 0, upd: 0;
       c4FCN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4FCM() //  [R1]
         { info_tbl: [(c4FCM,
                       label: block_c4FCM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FCM: // global
           I64[Sp] = block_c4FCS_info;
           _s4Fhk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fhk::I64;
           if (R1 & 7 != 0) goto u4FD7; else goto c4FCT;
       u4FD7: // global
           call _c4FCS(R1) args: 0, res: 0, upd: 0;
       c4FCT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4FCS() //  [R1]
         { info_tbl: [(c4FCS,
                       label: block_c4FCS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FCS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FD6; else goto c4FD5;
       c4FD6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4FD5: // global
           _s4Fhn::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fhn::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$dmpokeByteOff_entry() //  [R2, R3, R4]
         { info_tbl: [(c4FD9,
                       label: Foreign.Storable.$dmpokeByteOff_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FD9: // global
           _s4Fhi::P64 = R4;
           _s4Fhh::P64 = R3;
           _s4Fhg::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c4FDa; else goto c4FDb;
       c4FDb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4FDd; else goto c4FDc;
       c4FDd: // global
           HpAlloc = 32;
           goto c4FDa;
       c4FDa: // global
           R4 = _s4Fhi::P64;
           R3 = _s4Fhh::P64;
           R2 = _s4Fhg::P64;
           R1 = Foreign.Storable.$dmpokeByteOff_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FDc: // global
           I64[Hp - 24] = sat_s4Fho_info;
           P64[Hp - 8] = _s4Fhh::P64;
           P64[Hp] = _s4Fhi::P64;
           R2 = _s4Fhg::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call Foreign.Storable.poke_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.701360027 UTC

[section ""data" . Foreign.Storable.$dmpeekByteOff_closure" {
     Foreign.Storable.$dmpeekByteOff_closure:
         const Foreign.Storable.$dmpeekByteOff_info;
 },
 sat_s4Fhx_entry() //  [R1]
         { info_tbl: [(c4FDp,
                       label: sat_s4Fhx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FDp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4FDB; else goto c4FDC;
       c4FDB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4FDC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4FDm_info;
           _s4Fhr::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4Fhr::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4FDI; else goto c4FDn;
       u4FDI: // global
           call _c4FDm(R1) args: 0, res: 0, upd: 0;
       c4FDn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4FDm() //  [R1]
         { info_tbl: [(c4FDm,
                       label: block_c4FDm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FDm: // global
           I64[Sp] = block_c4FDs_info;
           _s4Fht::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fht::I64;
           if (R1 & 7 != 0) goto u4FDH; else goto c4FDt;
       u4FDH: // global
           call _c4FDs(R1) args: 0, res: 0, upd: 0;
       c4FDt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4FDs() //  [R1]
         { info_tbl: [(c4FDs,
                       label: block_c4FDs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FDs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FDG; else goto c4FDF;
       c4FDG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4FDF: // global
           _s4Fhw::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fhw::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$dmpeekByteOff_entry() //  [R2, R3, R4]
         { info_tbl: [(c4FDJ,
                       label: Foreign.Storable.$dmpeekByteOff_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FDJ: // global
           _s4Fhr::P64 = R4;
           _s4Fhq::P64 = R3;
           _s4Fhp::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c4FDK; else goto c4FDL;
       c4FDL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4FDN; else goto c4FDM;
       c4FDN: // global
           HpAlloc = 32;
           goto c4FDK;
       c4FDK: // global
           R4 = _s4Fhr::P64;
           R3 = _s4Fhq::P64;
           R2 = _s4Fhp::P64;
           R1 = Foreign.Storable.$dmpeekByteOff_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FDM: // global
           I64[Hp - 24] = sat_s4Fhx_info;
           P64[Hp - 8] = _s4Fhq::P64;
           P64[Hp] = _s4Fhr::P64;
           R2 = _s4Fhp::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.703393963 UTC

[section ""data" . Foreign.Storable.$fStorableInt17_closure" {
     Foreign.Storable.$fStorableInt17_closure:
         const Foreign.Storable.$fStorableInt17_info;
 },
 Foreign.Storable.$fStorableInt17_entry() //  [R2]
         { info_tbl: [(c4FDV,
                       label: Foreign.Storable.$fStorableInt17_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FDV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4FDZ; else goto c4FE0;
       c4FDZ: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt17_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4FE0: // global
           I64[Sp - 8] = block_c4FDS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4FE4; else goto c4FDT;
       u4FE4: // global
           call _c4FDS(R1) args: 0, res: 0, upd: 0;
       c4FDT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FDS() //  [R1]
         { info_tbl: [(c4FDS,
                       label: block_c4FDS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FDS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FE3; else goto c4FE2;
       c4FE3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FE2: // global
           _s4FhE::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4FhE::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.704871528 UTC

[section ""data" . Foreign.Storable.$fStorableInt19_closure" {
     Foreign.Storable.$fStorableInt19_closure:
         const Foreign.Storable.$fStorableInt19_info;
 },
 Foreign.Storable.$fStorableInt19_entry() //  [R2, R3]
         { info_tbl: [(c4FEc,
                       label: Foreign.Storable.$fStorableInt19_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FEc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FEo; else goto c4FEp;
       c4FEo: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt19_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FEp: // global
           I64[Sp - 16] = block_c4FE9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FEv; else goto c4FEa;
       u4FEv: // global
           call _c4FE9(R1) args: 0, res: 0, upd: 0;
       c4FEa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FE9() //  [R1]
         { info_tbl: [(c4FE9,
                       label: block_c4FE9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FE9: // global
           I64[Sp] = block_c4FEf_info;
           _s4FhK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FhK::I64;
           if (R1 & 7 != 0) goto u4FEu; else goto c4FEg;
       u4FEu: // global
           call _c4FEf(R1) args: 0, res: 0, upd: 0;
       c4FEg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FEf() //  [R1]
         { info_tbl: [(c4FEf,
                       label: block_c4FEf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FEf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FEt; else goto c4FEs;
       c4FEt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FEs: // global
           _s4FhQ::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4FhQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.706560584 UTC

[section ""data" . Foreign.Storable.$fStorableInt15_closure" {
     Foreign.Storable.$fStorableInt15_closure:
         const Foreign.Storable.$fStorableInt15_info;
 },
 Foreign.Storable.$fStorableInt15_entry() //  [R2, R3]
         { info_tbl: [(c4FED,
                       label: Foreign.Storable.$fStorableInt15_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FED: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FEH; else goto c4FEI;
       c4FEH: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt15_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FEI: // global
           I64[Sp - 16] = block_c4FEA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FEQ; else goto c4FEB;
       u4FEQ: // global
           call _c4FEA(R1) args: 0, res: 0, upd: 0;
       c4FEB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FEA() //  [R1]
         { info_tbl: [(c4FEA,
                       label: block_c4FEA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FEA: // global
           I64[Sp] = block_c4FEG_info;
           _s4FhW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FhW::I64;
           if (R1 & 7 != 0) goto u4FEP; else goto c4FEK;
       u4FEP: // global
           call _c4FEG(R1) args: 0, res: 0, upd: 0;
       c4FEK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FEG() //  [R1]
         { info_tbl: [(c4FEG,
                       label: block_c4FEG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FEG: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.708231661 UTC

[section ""data" . Foreign.Storable.$fStorableInt18_closure" {
     Foreign.Storable.$fStorableInt18_closure:
         const Foreign.Storable.$fStorableInt18_info;
 },
 Foreign.Storable.$fStorableInt18_entry() //  [R2, R3, R4]
         { info_tbl: [(c4FEY,
                       label: Foreign.Storable.$fStorableInt18_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FEY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4FF7; else goto c4FF8;
       c4FF7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt18_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FF8: // global
           I64[Sp - 24] = block_c4FEV_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4FFi; else goto c4FEW;
       u4FFi: // global
           call _c4FEV(R1) args: 0, res: 0, upd: 0;
       c4FEW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FEV() //  [R1]
         { info_tbl: [(c4FEV,
                       label: block_c4FEV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FEV: // global
           I64[Sp] = block_c4FF1_info;
           _s4Fi5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fi5::I64;
           if (R1 & 7 != 0) goto u4FFh; else goto c4FF2;
       u4FFh: // global
           call _c4FF1(R1) args: 0, res: 0, upd: 0;
       c4FF2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FF1() //  [R1]
         { info_tbl: [(c4FF1,
                       label: block_c4FF1_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FF1: // global
           I64[Sp] = block_c4FF6_info;
           _s4Fi7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fi7::I64;
           if (R1 & 7 != 0) goto u4FFj; else goto c4FFb;
       u4FFj: // global
           call _c4FF6(R1) args: 0, res: 0, upd: 0;
       c4FFb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FF6() //  [R1]
         { info_tbl: [(c4FF6,
                       label: block_c4FF6_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FF6: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.709843192 UTC

[section ""data" . Foreign.Storable.$fStorableInt64_closure" {
     Foreign.Storable.$fStorableInt64_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt64_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt64_$calignment_closure+1;
         const GHC.Storable.readInt64OffPtr1_closure+3;
         const GHC.Storable.writeInt64OffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt19_closure+3;
         const Foreign.Storable.$fStorableInt18_closure+4;
         const Foreign.Storable.$fStorableInt17_closure+2;
         const Foreign.Storable.$fStorableInt15_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.710865691 UTC

[section ""data" . Foreign.Storable.$fStorableInt12_closure" {
     Foreign.Storable.$fStorableInt12_closure:
         const Foreign.Storable.$fStorableInt12_info;
 },
 Foreign.Storable.$fStorableInt12_entry() //  [R2]
         { info_tbl: [(c4FFr,
                       label: Foreign.Storable.$fStorableInt12_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FFr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4FFv; else goto c4FFw;
       c4FFv: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt12_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4FFw: // global
           I64[Sp - 8] = block_c4FFo_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4FFA; else goto c4FFp;
       u4FFA: // global
           call _c4FFo(R1) args: 0, res: 0, upd: 0;
       c4FFp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FFo() //  [R1]
         { info_tbl: [(c4FFo,
                       label: block_c4FFo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FFo: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FFz; else goto c4FFy;
       c4FFz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FFy: // global
           _s4Fii::I64 = %MO_SS_Conv_W32_W64(I32[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4Fii::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.712462643 UTC

[section ""data" . Foreign.Storable.$fStorableInt14_closure" {
     Foreign.Storable.$fStorableInt14_closure:
         const Foreign.Storable.$fStorableInt14_info;
 },
 Foreign.Storable.$fStorableInt14_entry() //  [R2, R3]
         { info_tbl: [(c4FFI,
                       label: Foreign.Storable.$fStorableInt14_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FFI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FFU; else goto c4FFV;
       c4FFU: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt14_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FFV: // global
           I64[Sp - 16] = block_c4FFF_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FG1; else goto c4FFG;
       u4FG1: // global
           call _c4FFF(R1) args: 0, res: 0, upd: 0;
       c4FFG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FFF() //  [R1]
         { info_tbl: [(c4FFF,
                       label: block_c4FFF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FFF: // global
           I64[Sp] = block_c4FFL_info;
           _s4Fio::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fio::I64;
           if (R1 & 7 != 0) goto u4FG0; else goto c4FFM;
       u4FG0: // global
           call _c4FFL(R1) args: 0, res: 0, upd: 0;
       c4FFM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FFL() //  [R1]
         { info_tbl: [(c4FFL,
                       label: block_c4FFL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FFL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FFZ; else goto c4FFY;
       c4FFZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FFY: // global
           _s4Fiu::I64 = %MO_SS_Conv_W32_W64(I32[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4Fiu::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.714314411 UTC

[section ""data" . Foreign.Storable.$fStorableInt11_closure" {
     Foreign.Storable.$fStorableInt11_closure:
         const Foreign.Storable.$fStorableInt11_info;
 },
 Foreign.Storable.$fStorableInt11_entry() //  [R2, R3]
         { info_tbl: [(c4FG9,
                       label: Foreign.Storable.$fStorableInt11_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FG9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FGd; else goto c4FGe;
       c4FGd: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt11_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FGe: // global
           I64[Sp - 16] = block_c4FG6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FGm; else goto c4FG7;
       u4FGm: // global
           call _c4FG6(R1) args: 0, res: 0, upd: 0;
       c4FG7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FG6() //  [R1]
         { info_tbl: [(c4FG6,
                       label: block_c4FG6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FG6: // global
           I64[Sp] = block_c4FGc_info;
           _s4FiA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FiA::I64;
           if (R1 & 7 != 0) goto u4FGl; else goto c4FGg;
       u4FGl: // global
           call _c4FGc(R1) args: 0, res: 0, upd: 0;
       c4FGg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FGc() //  [R1]
         { info_tbl: [(c4FGc,
                       label: block_c4FGc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FGc: // global
           I32[I64[Sp + 8]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.716029573 UTC

[section ""data" . Foreign.Storable.$fStorableInt13_closure" {
     Foreign.Storable.$fStorableInt13_closure:
         const Foreign.Storable.$fStorableInt13_info;
 },
 Foreign.Storable.$fStorableInt13_entry() //  [R2, R3, R4]
         { info_tbl: [(c4FGu,
                       label: Foreign.Storable.$fStorableInt13_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FGu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4FGD; else goto c4FGE;
       c4FGD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt13_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FGE: // global
           I64[Sp - 24] = block_c4FGr_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4FGO; else goto c4FGs;
       u4FGO: // global
           call _c4FGr(R1) args: 0, res: 0, upd: 0;
       c4FGs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FGr() //  [R1]
         { info_tbl: [(c4FGr,
                       label: block_c4FGr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FGr: // global
           I64[Sp] = block_c4FGx_info;
           _s4FiJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FiJ::I64;
           if (R1 & 7 != 0) goto u4FGN; else goto c4FGy;
       u4FGN: // global
           call _c4FGx(R1) args: 0, res: 0, upd: 0;
       c4FGy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FGx() //  [R1]
         { info_tbl: [(c4FGx,
                       label: block_c4FGx_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FGx: // global
           I64[Sp] = block_c4FGC_info;
           _s4FiL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FiL::I64;
           if (R1 & 7 != 0) goto u4FGP; else goto c4FGH;
       u4FGP: // global
           call _c4FGC(R1) args: 0, res: 0, upd: 0;
       c4FGH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FGC() //  [R1]
         { info_tbl: [(c4FGC,
                       label: block_c4FGC_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FGC: // global
           I32[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.71884187 UTC

[section ""data" . Foreign.Storable.$fStorableInt32_closure" {
     Foreign.Storable.$fStorableInt32_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt32_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt32_$calignment_closure+1;
         const GHC.Storable.readInt32OffPtr1_closure+3;
         const GHC.Storable.writeInt32OffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt14_closure+3;
         const Foreign.Storable.$fStorableInt13_closure+4;
         const Foreign.Storable.$fStorableInt12_closure+2;
         const Foreign.Storable.$fStorableInt11_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.719676193 UTC

[section ""data" . Foreign.Storable.$fStorableBool_$csizeOf_closure" {
     Foreign.Storable.$fStorableBool_$csizeOf_closure:
         const Foreign.Storable.$fStorableBool_$csizeOf_info;
 },
 Foreign.Storable.$fStorableBool_$csizeOf_entry() //  []
         { info_tbl: [(c4FGU,
                       label: Foreign.Storable.$fStorableBool_$csizeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FGU: // global
           R1 = Foreign.Storable.$fStorableBool7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.720858201 UTC

[section ""data" . Foreign.Storable.$fStorableBool5_closure" {
     Foreign.Storable.$fStorableBool5_closure:
         const Foreign.Storable.$fStorableBool5_info;
 },
 Foreign.Storable.$fStorableBool5_entry() //  [R2, R3, R4]
         { info_tbl: [(c4FH4,
                       label: Foreign.Storable.$fStorableBool5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FH4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4FH8; else goto c4FH9;
       c4FH8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FH9: // global
           I64[Sp - 24] = block_c4FH1_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4FHu; else goto c4FH2;
       u4FHu: // global
           call _c4FH1(R1) args: 0, res: 0, upd: 0;
       c4FH2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FH1() //  [R1]
         { info_tbl: [(c4FH1,
                       label: block_c4FH1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FH1: // global
           I64[Sp] = block_c4FH7_info;
           _s4FiW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FiW::I64;
           if (R1 & 7 != 0) goto u4FHt; else goto c4FHb;
       u4FHt: // global
           call _c4FH7(R1) args: 0, res: 0, upd: 0;
       c4FHb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FH7() //  [R1]
         { info_tbl: [(c4FH7,
                       label: block_c4FH7_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FH7: // global
           I64[Sp] = block_c4FHf_info;
           _s4FiY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FiY::I64;
           if (R1 & 7 != 0) goto u4FHv; else goto c4FHh;
       u4FHv: // global
           call _c4FHf(R1) args: 0, res: 0, upd: 0;
       c4FHh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FHf() //  [R1]
         { info_tbl: [(c4FHf,
                       label: block_c4FHf_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FHf: // global
           _s4FiW::I64 = I64[Sp + 8];
           _s4FiY::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto c4FHn; else goto c4FHr;
       c4FHn: // global
           I32[_s4FiW::I64 + (_s4FiY::I64 << 2)] = 0 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4FHr: // global
           I32[_s4FiW::I64 + (_s4FiY::I64 << 2)] = 1 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.722834005 UTC

[section ""data" . Foreign.Storable.$fStorableInt6_closure" {
     Foreign.Storable.$fStorableInt6_closure:
         const Foreign.Storable.$fStorableInt6_info;
 },
 Foreign.Storable.$fStorableInt6_entry() //  [R2]
         { info_tbl: [(c4FHD,
                       label: Foreign.Storable.$fStorableInt6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FHD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4FHH; else goto c4FHI;
       c4FHH: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4FHI: // global
           I64[Sp - 8] = block_c4FHA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4FHM; else goto c4FHB;
       u4FHM: // global
           call _c4FHA(R1) args: 0, res: 0, upd: 0;
       c4FHB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FHA() //  [R1]
         { info_tbl: [(c4FHA,
                       label: block_c4FHA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FHA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FHL; else goto c4FHK;
       c4FHL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FHK: // global
           _s4Fj8::I64 = %MO_SS_Conv_W16_W64(I16[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4Fj8::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.724343066 UTC

[section ""data" . Foreign.Storable.$fStorableInt9_closure" {
     Foreign.Storable.$fStorableInt9_closure:
         const Foreign.Storable.$fStorableInt9_info;
 },
 Foreign.Storable.$fStorableInt9_entry() //  [R2, R3]
         { info_tbl: [(c4FHU,
                       label: Foreign.Storable.$fStorableInt9_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FHU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FI6; else goto c4FI7;
       c4FI6: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt9_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FI7: // global
           I64[Sp - 16] = block_c4FHR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FId; else goto c4FHS;
       u4FId: // global
           call _c4FHR(R1) args: 0, res: 0, upd: 0;
       c4FHS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FHR() //  [R1]
         { info_tbl: [(c4FHR,
                       label: block_c4FHR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FHR: // global
           I64[Sp] = block_c4FHX_info;
           _s4Fje::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fje::I64;
           if (R1 & 7 != 0) goto u4FIc; else goto c4FHY;
       u4FIc: // global
           call _c4FHX(R1) args: 0, res: 0, upd: 0;
       c4FHY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FHX() //  [R1]
         { info_tbl: [(c4FHX,
                       label: block_c4FHX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FHX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FIb; else goto c4FIa;
       c4FIb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FIa: // global
           _s4Fjk::I64 = %MO_SS_Conv_W16_W64(I16[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4Fjk::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.726504575 UTC

[section ""data" . Foreign.Storable.$fStorableInt5_closure" {
     Foreign.Storable.$fStorableInt5_closure:
         const Foreign.Storable.$fStorableInt5_info;
 },
 Foreign.Storable.$fStorableInt5_entry() //  [R2, R3]
         { info_tbl: [(c4FIl,
                       label: Foreign.Storable.$fStorableInt5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FIl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FIp; else goto c4FIq;
       c4FIp: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FIq: // global
           I64[Sp - 16] = block_c4FIi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FIy; else goto c4FIj;
       u4FIy: // global
           call _c4FIi(R1) args: 0, res: 0, upd: 0;
       c4FIj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FIi() //  [R1]
         { info_tbl: [(c4FIi,
                       label: block_c4FIi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FIi: // global
           I64[Sp] = block_c4FIo_info;
           _s4Fjq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fjq::I64;
           if (R1 & 7 != 0) goto u4FIx; else goto c4FIs;
       u4FIx: // global
           call _c4FIo(R1) args: 0, res: 0, upd: 0;
       c4FIs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FIo() //  [R1]
         { info_tbl: [(c4FIo,
                       label: block_c4FIo_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FIo: // global
           I16[I64[Sp + 8]] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.728048939 UTC

[section ""data" . Foreign.Storable.$fStorableInt7_closure" {
     Foreign.Storable.$fStorableInt7_closure:
         const Foreign.Storable.$fStorableInt7_info;
 },
 Foreign.Storable.$fStorableInt7_entry() //  [R2, R3, R4]
         { info_tbl: [(c4FIG,
                       label: Foreign.Storable.$fStorableInt7_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FIG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4FIP; else goto c4FIQ;
       c4FIP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt7_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FIQ: // global
           I64[Sp - 24] = block_c4FID_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4FJ0; else goto c4FIE;
       u4FJ0: // global
           call _c4FID(R1) args: 0, res: 0, upd: 0;
       c4FIE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FID() //  [R1]
         { info_tbl: [(c4FID,
                       label: block_c4FID_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FID: // global
           I64[Sp] = block_c4FIJ_info;
           _s4Fjz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fjz::I64;
           if (R1 & 7 != 0) goto u4FIZ; else goto c4FIK;
       u4FIZ: // global
           call _c4FIJ(R1) args: 0, res: 0, upd: 0;
       c4FIK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FIJ() //  [R1]
         { info_tbl: [(c4FIJ,
                       label: block_c4FIJ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FIJ: // global
           I64[Sp] = block_c4FIO_info;
           _s4FjB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FjB::I64;
           if (R1 & 7 != 0) goto u4FJ1; else goto c4FIT;
       u4FJ1: // global
           call _c4FIO(R1) args: 0, res: 0, upd: 0;
       c4FIT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FIO() //  [R1]
         { info_tbl: [(c4FIO,
                       label: block_c4FIO_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FIO: // global
           I16[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.729583623 UTC

[section ""data" . Foreign.Storable.$fStorableInt16_closure" {
     Foreign.Storable.$fStorableInt16_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt16_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt16_$calignment_closure+1;
         const GHC.Storable.readInt16OffPtr1_closure+3;
         const GHC.Storable.writeInt16OffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt9_closure+3;
         const Foreign.Storable.$fStorableInt7_closure+4;
         const Foreign.Storable.$fStorableInt6_closure+2;
         const Foreign.Storable.$fStorableInt5_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.730532664 UTC

[section ""data" . Foreign.Storable.$fStorableInt21_closure" {
     Foreign.Storable.$fStorableInt21_closure:
         const Foreign.Storable.$fStorableInt21_info;
 },
 Foreign.Storable.$fStorableInt21_entry() //  [R2]
         { info_tbl: [(c4FJ9,
                       label: Foreign.Storable.$fStorableInt21_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FJ9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4FJd; else goto c4FJe;
       c4FJd: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt21_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4FJe: // global
           I64[Sp - 8] = block_c4FJ6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4FJi; else goto c4FJ7;
       u4FJi: // global
           call _c4FJ6(R1) args: 0, res: 0, upd: 0;
       c4FJ7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FJ6() //  [R1]
         { info_tbl: [(c4FJ6,
                       label: block_c4FJ6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FJ6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FJh; else goto c4FJg;
       c4FJh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FJg: // global
           _s4FjM::I64 = %MO_SS_Conv_W8_W64(I8[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4FjM::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.731982696 UTC

[section ""data" . Foreign.Storable.$fStorableInt23_closure" {
     Foreign.Storable.$fStorableInt23_closure:
         const Foreign.Storable.$fStorableInt23_info;
 },
 Foreign.Storable.$fStorableInt23_entry() //  [R2, R3]
         { info_tbl: [(c4FJq,
                       label: Foreign.Storable.$fStorableInt23_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FJq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FJC; else goto c4FJD;
       c4FJC: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt23_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FJD: // global
           I64[Sp - 16] = block_c4FJn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FJJ; else goto c4FJo;
       u4FJJ: // global
           call _c4FJn(R1) args: 0, res: 0, upd: 0;
       c4FJo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FJn() //  [R1]
         { info_tbl: [(c4FJn,
                       label: block_c4FJn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FJn: // global
           I64[Sp] = block_c4FJt_info;
           _s4FjS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FjS::I64;
           if (R1 & 7 != 0) goto u4FJI; else goto c4FJu;
       u4FJI: // global
           call _c4FJt(R1) args: 0, res: 0, upd: 0;
       c4FJu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FJt() //  [R1]
         { info_tbl: [(c4FJt,
                       label: block_c4FJt_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FJt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FJH; else goto c4FJG;
       c4FJH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FJG: // global
           _s4FjY::I64 = %MO_SS_Conv_W8_W64(I8[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4FjY::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.733641534 UTC

[section ""data" . Foreign.Storable.$fStorableInt20_closure" {
     Foreign.Storable.$fStorableInt20_closure:
         const Foreign.Storable.$fStorableInt20_info;
 },
 Foreign.Storable.$fStorableInt20_entry() //  [R2, R3]
         { info_tbl: [(c4FJR,
                       label: Foreign.Storable.$fStorableInt20_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FJR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FJV; else goto c4FJW;
       c4FJV: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt20_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FJW: // global
           I64[Sp - 16] = block_c4FJO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FK4; else goto c4FJP;
       u4FK4: // global
           call _c4FJO(R1) args: 0, res: 0, upd: 0;
       c4FJP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FJO() //  [R1]
         { info_tbl: [(c4FJO,
                       label: block_c4FJO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FJO: // global
           I64[Sp] = block_c4FJU_info;
           _s4Fk4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fk4::I64;
           if (R1 & 7 != 0) goto u4FK3; else goto c4FJY;
       u4FK3: // global
           call _c4FJU(R1) args: 0, res: 0, upd: 0;
       c4FJY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FJU() //  [R1]
         { info_tbl: [(c4FJU,
                       label: block_c4FJU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FJU: // global
           I8[I64[Sp + 8]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.7352042 UTC

[section ""data" . Foreign.Storable.$fStorableInt22_closure" {
     Foreign.Storable.$fStorableInt22_closure:
         const Foreign.Storable.$fStorableInt22_info;
 },
 Foreign.Storable.$fStorableInt22_entry() //  [R2, R3, R4]
         { info_tbl: [(c4FKc,
                       label: Foreign.Storable.$fStorableInt22_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FKc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4FKl; else goto c4FKm;
       c4FKl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt22_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FKm: // global
           I64[Sp - 24] = block_c4FK9_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4FKw; else goto c4FKa;
       u4FKw: // global
           call _c4FK9(R1) args: 0, res: 0, upd: 0;
       c4FKa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FK9() //  [R1]
         { info_tbl: [(c4FK9,
                       label: block_c4FK9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FK9: // global
           I64[Sp] = block_c4FKf_info;
           _s4Fkd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fkd::I64;
           if (R1 & 7 != 0) goto u4FKv; else goto c4FKg;
       u4FKv: // global
           call _c4FKf(R1) args: 0, res: 0, upd: 0;
       c4FKg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FKf() //  [R1]
         { info_tbl: [(c4FKf,
                       label: block_c4FKf_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FKf: // global
           I64[Sp] = block_c4FKk_info;
           _s4Fkf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fkf::I64;
           if (R1 & 7 != 0) goto u4FKx; else goto c4FKp;
       u4FKx: // global
           call _c4FKk(R1) args: 0, res: 0, upd: 0;
       c4FKp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FKk() //  [R1]
         { info_tbl: [(c4FKk,
                       label: block_c4FKk_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FKk: // global
           I8[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.736654219 UTC

[section ""data" . Foreign.Storable.$fStorableInt8_closure" {
     Foreign.Storable.$fStorableInt8_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt8_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt8_$calignment_closure+1;
         const GHC.Storable.readInt8OffPtr1_closure+3;
         const GHC.Storable.writeInt8OffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt23_closure+3;
         const Foreign.Storable.$fStorableInt22_closure+4;
         const Foreign.Storable.$fStorableInt21_closure+2;
         const Foreign.Storable.$fStorableInt20_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.737706795 UTC

[section ""data" . Foreign.Storable.$fStorableWord15_closure" {
     Foreign.Storable.$fStorableWord15_closure:
         const Foreign.Storable.$fStorableWord15_info;
 },
 Foreign.Storable.$fStorableWord15_entry() //  [R2]
         { info_tbl: [(c4FKF,
                       label: Foreign.Storable.$fStorableWord15_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FKF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4FKJ; else goto c4FKK;
       c4FKJ: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord15_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4FKK: // global
           I64[Sp - 8] = block_c4FKC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4FKO; else goto c4FKD;
       u4FKO: // global
           call _c4FKC(R1) args: 0, res: 0, upd: 0;
       c4FKD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FKC() //  [R1]
         { info_tbl: [(c4FKC,
                       label: block_c4FKC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FKC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FKN; else goto c4FKM;
       c4FKN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FKM: // global
           _s4Fkq::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4Fkq::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.739158719 UTC

[section ""data" . Foreign.Storable.$fStorableWord18_closure" {
     Foreign.Storable.$fStorableWord18_closure:
         const Foreign.Storable.$fStorableWord18_info;
 },
 Foreign.Storable.$fStorableWord18_entry() //  [R2, R3]
         { info_tbl: [(c4FKW,
                       label: Foreign.Storable.$fStorableWord18_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FKW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FL8; else goto c4FL9;
       c4FL8: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord18_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FL9: // global
           I64[Sp - 16] = block_c4FKT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FLf; else goto c4FKU;
       u4FLf: // global
           call _c4FKT(R1) args: 0, res: 0, upd: 0;
       c4FKU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FKT() //  [R1]
         { info_tbl: [(c4FKT,
                       label: block_c4FKT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FKT: // global
           I64[Sp] = block_c4FKZ_info;
           _s4Fkw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fkw::I64;
           if (R1 & 7 != 0) goto u4FLe; else goto c4FL0;
       u4FLe: // global
           call _c4FKZ(R1) args: 0, res: 0, upd: 0;
       c4FL0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FKZ() //  [R1]
         { info_tbl: [(c4FKZ,
                       label: block_c4FKZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FKZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FLd; else goto c4FLc;
       c4FLd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FLc: // global
           _s4FkC::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4FkC::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.740779999 UTC

[section ""data" . Foreign.Storable.$fStorableWord14_closure" {
     Foreign.Storable.$fStorableWord14_closure:
         const Foreign.Storable.$fStorableWord14_info;
 },
 Foreign.Storable.$fStorableWord14_entry() //  [R2, R3]
         { info_tbl: [(c4FLn,
                       label: Foreign.Storable.$fStorableWord14_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FLn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FLr; else goto c4FLs;
       c4FLr: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord14_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FLs: // global
           I64[Sp - 16] = block_c4FLk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FLA; else goto c4FLl;
       u4FLA: // global
           call _c4FLk(R1) args: 0, res: 0, upd: 0;
       c4FLl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FLk() //  [R1]
         { info_tbl: [(c4FLk,
                       label: block_c4FLk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FLk: // global
           I64[Sp] = block_c4FLq_info;
           _s4FkI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FkI::I64;
           if (R1 & 7 != 0) goto u4FLz; else goto c4FLu;
       u4FLz: // global
           call _c4FLq(R1) args: 0, res: 0, upd: 0;
       c4FLu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FLq() //  [R1]
         { info_tbl: [(c4FLq,
                       label: block_c4FLq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FLq: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.742662838 UTC

[section ""data" . Foreign.Storable.$fStorableWord17_closure" {
     Foreign.Storable.$fStorableWord17_closure:
         const Foreign.Storable.$fStorableWord17_info;
 },
 Foreign.Storable.$fStorableWord17_entry() //  [R2, R3, R4]
         { info_tbl: [(c4FLI,
                       label: Foreign.Storable.$fStorableWord17_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FLI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4FLR; else goto c4FLS;
       c4FLR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord17_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FLS: // global
           I64[Sp - 24] = block_c4FLF_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4FM2; else goto c4FLG;
       u4FM2: // global
           call _c4FLF(R1) args: 0, res: 0, upd: 0;
       c4FLG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FLF() //  [R1]
         { info_tbl: [(c4FLF,
                       label: block_c4FLF_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FLF: // global
           I64[Sp] = block_c4FLL_info;
           _s4FkR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FkR::I64;
           if (R1 & 7 != 0) goto u4FM1; else goto c4FLM;
       u4FM1: // global
           call _c4FLL(R1) args: 0, res: 0, upd: 0;
       c4FLM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FLL() //  [R1]
         { info_tbl: [(c4FLL,
                       label: block_c4FLL_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FLL: // global
           I64[Sp] = block_c4FLQ_info;
           _s4FkT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FkT::I64;
           if (R1 & 7 != 0) goto u4FM3; else goto c4FLV;
       u4FM3: // global
           call _c4FLQ(R1) args: 0, res: 0, upd: 0;
       c4FLV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FLQ() //  [R1]
         { info_tbl: [(c4FLQ,
                       label: block_c4FLQ_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FLQ: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.744151821 UTC

[section ""data" . Foreign.Storable.$fStorableWord64_closure" {
     Foreign.Storable.$fStorableWord64_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableWord64_$calignment_closure+1;
         const Foreign.Storable.$fStorableWord64_$calignment_closure+1;
         const GHC.Storable.readWord64OffPtr1_closure+3;
         const GHC.Storable.writeWord64OffPtr1_closure+4;
         const Foreign.Storable.$fStorableWord18_closure+3;
         const Foreign.Storable.$fStorableWord17_closure+4;
         const Foreign.Storable.$fStorableWord15_closure+2;
         const Foreign.Storable.$fStorableWord14_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.74532598 UTC

[section ""data" . Foreign.Storable.$fStorableWord11_closure" {
     Foreign.Storable.$fStorableWord11_closure:
         const Foreign.Storable.$fStorableWord11_info;
 },
 Foreign.Storable.$fStorableWord11_entry() //  [R2]
         { info_tbl: [(c4FMb,
                       label: Foreign.Storable.$fStorableWord11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FMb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4FMf; else goto c4FMg;
       c4FMf: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord11_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4FMg: // global
           I64[Sp - 8] = block_c4FM8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4FMk; else goto c4FM9;
       u4FMk: // global
           call _c4FM8(R1) args: 0, res: 0, upd: 0;
       c4FM9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FM8() //  [R1]
         { info_tbl: [(c4FM8,
                       label: block_c4FM8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FM8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FMj; else goto c4FMi;
       c4FMj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FMi: // global
           _s4Fl4::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s4Fl4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.746787704 UTC

[section ""data" . Foreign.Storable.$fStorableWord13_closure" {
     Foreign.Storable.$fStorableWord13_closure:
         const Foreign.Storable.$fStorableWord13_info;
 },
 Foreign.Storable.$fStorableWord13_entry() //  [R2, R3]
         { info_tbl: [(c4FMs,
                       label: Foreign.Storable.$fStorableWord13_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FMs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FME; else goto c4FMF;
       c4FME: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord13_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FMF: // global
           I64[Sp - 16] = block_c4FMp_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FML; else goto c4FMq;
       u4FML: // global
           call _c4FMp(R1) args: 0, res: 0, upd: 0;
       c4FMq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FMp() //  [R1]
         { info_tbl: [(c4FMp,
                       label: block_c4FMp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FMp: // global
           I64[Sp] = block_c4FMv_info;
           _s4Fla::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fla::I64;
           if (R1 & 7 != 0) goto u4FMK; else goto c4FMw;
       u4FMK: // global
           call _c4FMv(R1) args: 0, res: 0, upd: 0;
       c4FMw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FMv() //  [R1]
         { info_tbl: [(c4FMv,
                       label: block_c4FMv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FMv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FMJ; else goto c4FMI;
       c4FMJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FMI: // global
           _s4Flg::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s4Flg::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.748421295 UTC

[section ""data" . Foreign.Storable.$fStorableWord10_closure" {
     Foreign.Storable.$fStorableWord10_closure:
         const Foreign.Storable.$fStorableWord10_info;
 },
 Foreign.Storable.$fStorableWord10_entry() //  [R2, R3]
         { info_tbl: [(c4FMT,
                       label: Foreign.Storable.$fStorableWord10_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FMT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FMX; else goto c4FMY;
       c4FMX: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord10_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FMY: // global
           I64[Sp - 16] = block_c4FMQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FN6; else goto c4FMR;
       u4FN6: // global
           call _c4FMQ(R1) args: 0, res: 0, upd: 0;
       c4FMR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FMQ() //  [R1]
         { info_tbl: [(c4FMQ,
                       label: block_c4FMQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FMQ: // global
           I64[Sp] = block_c4FMW_info;
           _s4Flm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Flm::I64;
           if (R1 & 7 != 0) goto u4FN5; else goto c4FN0;
       u4FN5: // global
           call _c4FMW(R1) args: 0, res: 0, upd: 0;
       c4FN0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FMW() //  [R1]
         { info_tbl: [(c4FMW,
                       label: block_c4FMW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FMW: // global
           I32[I64[Sp + 8]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.750260076 UTC

[section ""data" . Foreign.Storable.$fStorableWord12_closure" {
     Foreign.Storable.$fStorableWord12_closure:
         const Foreign.Storable.$fStorableWord12_info;
 },
 Foreign.Storable.$fStorableWord12_entry() //  [R2, R3, R4]
         { info_tbl: [(c4FNe,
                       label: Foreign.Storable.$fStorableWord12_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FNe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4FNn; else goto c4FNo;
       c4FNn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord12_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FNo: // global
           I64[Sp - 24] = block_c4FNb_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4FNy; else goto c4FNc;
       u4FNy: // global
           call _c4FNb(R1) args: 0, res: 0, upd: 0;
       c4FNc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FNb() //  [R1]
         { info_tbl: [(c4FNb,
                       label: block_c4FNb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FNb: // global
           I64[Sp] = block_c4FNh_info;
           _s4Flv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Flv::I64;
           if (R1 & 7 != 0) goto u4FNx; else goto c4FNi;
       u4FNx: // global
           call _c4FNh(R1) args: 0, res: 0, upd: 0;
       c4FNi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FNh() //  [R1]
         { info_tbl: [(c4FNh,
                       label: block_c4FNh_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FNh: // global
           I64[Sp] = block_c4FNm_info;
           _s4Flx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Flx::I64;
           if (R1 & 7 != 0) goto u4FNz; else goto c4FNr;
       u4FNz: // global
           call _c4FNm(R1) args: 0, res: 0, upd: 0;
       c4FNr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FNm() //  [R1]
         { info_tbl: [(c4FNm,
                       label: block_c4FNm_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FNm: // global
           I32[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.751826443 UTC

[section ""data" . Foreign.Storable.$fStorableWord32_closure" {
     Foreign.Storable.$fStorableWord32_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableWord32_$calignment_closure+1;
         const Foreign.Storable.$fStorableWord32_$calignment_closure+1;
         const GHC.Storable.readWord32OffPtr1_closure+3;
         const GHC.Storable.writeWord32OffPtr1_closure+4;
         const Foreign.Storable.$fStorableWord13_closure+3;
         const Foreign.Storable.$fStorableWord12_closure+4;
         const Foreign.Storable.$fStorableWord11_closure+2;
         const Foreign.Storable.$fStorableWord10_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.753206519 UTC

[section ""data" . Foreign.Storable.$fStorableWord6_closure" {
     Foreign.Storable.$fStorableWord6_closure:
         const Foreign.Storable.$fStorableWord6_info;
 },
 Foreign.Storable.$fStorableWord6_entry() //  [R2]
         { info_tbl: [(c4FNH,
                       label: Foreign.Storable.$fStorableWord6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FNH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4FNL; else goto c4FNM;
       c4FNL: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4FNM: // global
           I64[Sp - 8] = block_c4FNE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4FNQ; else goto c4FNF;
       u4FNQ: // global
           call _c4FNE(R1) args: 0, res: 0, upd: 0;
       c4FNF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FNE() //  [R1]
         { info_tbl: [(c4FNE,
                       label: block_c4FNE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FNE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FNP; else goto c4FNO;
       c4FNP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FNO: // global
           _s4FlI::I64 = %MO_UU_Conv_W16_W64(I16[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s4FlI::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.755352941 UTC

[section ""data" . Foreign.Storable.$fStorableWord9_closure" {
     Foreign.Storable.$fStorableWord9_closure:
         const Foreign.Storable.$fStorableWord9_info;
 },
 Foreign.Storable.$fStorableWord9_entry() //  [R2, R3]
         { info_tbl: [(c4FNY,
                       label: Foreign.Storable.$fStorableWord9_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FNY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FOa; else goto c4FOb;
       c4FOa: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord9_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FOb: // global
           I64[Sp - 16] = block_c4FNV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FOh; else goto c4FNW;
       u4FOh: // global
           call _c4FNV(R1) args: 0, res: 0, upd: 0;
       c4FNW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FNV() //  [R1]
         { info_tbl: [(c4FNV,
                       label: block_c4FNV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FNV: // global
           I64[Sp] = block_c4FO1_info;
           _s4FlO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FlO::I64;
           if (R1 & 7 != 0) goto u4FOg; else goto c4FO2;
       u4FOg: // global
           call _c4FO1(R1) args: 0, res: 0, upd: 0;
       c4FO2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FO1() //  [R1]
         { info_tbl: [(c4FO1,
                       label: block_c4FO1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FO1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FOf; else goto c4FOe;
       c4FOf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FOe: // global
           _s4FlU::I64 = %MO_UU_Conv_W16_W64(I16[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s4FlU::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.757726465 UTC

[section ""data" . Foreign.Storable.$fStorableWord5_closure" {
     Foreign.Storable.$fStorableWord5_closure:
         const Foreign.Storable.$fStorableWord5_info;
 },
 Foreign.Storable.$fStorableWord5_entry() //  [R2, R3]
         { info_tbl: [(c4FOp,
                       label: Foreign.Storable.$fStorableWord5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FOp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FOt; else goto c4FOu;
       c4FOt: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FOu: // global
           I64[Sp - 16] = block_c4FOm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FOC; else goto c4FOn;
       u4FOC: // global
           call _c4FOm(R1) args: 0, res: 0, upd: 0;
       c4FOn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FOm() //  [R1]
         { info_tbl: [(c4FOm,
                       label: block_c4FOm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FOm: // global
           I64[Sp] = block_c4FOs_info;
           _s4Fm0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fm0::I64;
           if (R1 & 7 != 0) goto u4FOB; else goto c4FOw;
       u4FOB: // global
           call _c4FOs(R1) args: 0, res: 0, upd: 0;
       c4FOw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FOs() //  [R1]
         { info_tbl: [(c4FOs,
                       label: block_c4FOs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FOs: // global
           I16[I64[Sp + 8]] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.759955495 UTC

[section ""data" . Foreign.Storable.$fStorableWord7_closure" {
     Foreign.Storable.$fStorableWord7_closure:
         const Foreign.Storable.$fStorableWord7_info;
 },
 Foreign.Storable.$fStorableWord7_entry() //  [R2, R3, R4]
         { info_tbl: [(c4FOK,
                       label: Foreign.Storable.$fStorableWord7_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FOK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4FOT; else goto c4FOU;
       c4FOT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord7_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FOU: // global
           I64[Sp - 24] = block_c4FOH_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4FP4; else goto c4FOI;
       u4FP4: // global
           call _c4FOH(R1) args: 0, res: 0, upd: 0;
       c4FOI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FOH() //  [R1]
         { info_tbl: [(c4FOH,
                       label: block_c4FOH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FOH: // global
           I64[Sp] = block_c4FON_info;
           _s4Fm9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fm9::I64;
           if (R1 & 7 != 0) goto u4FP3; else goto c4FOO;
       u4FP3: // global
           call _c4FON(R1) args: 0, res: 0, upd: 0;
       c4FOO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FON() //  [R1]
         { info_tbl: [(c4FON,
                       label: block_c4FON_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FON: // global
           I64[Sp] = block_c4FOS_info;
           _s4Fmb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fmb::I64;
           if (R1 & 7 != 0) goto u4FP5; else goto c4FOX;
       u4FP5: // global
           call _c4FOS(R1) args: 0, res: 0, upd: 0;
       c4FOX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FOS() //  [R1]
         { info_tbl: [(c4FOS,
                       label: block_c4FOS_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FOS: // global
           I16[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.762304439 UTC

[section ""data" . Foreign.Storable.$fStorableWord16_closure" {
     Foreign.Storable.$fStorableWord16_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableWord16_$calignment_closure+1;
         const Foreign.Storable.$fStorableWord16_$calignment_closure+1;
         const GHC.Storable.readWord16OffPtr1_closure+3;
         const GHC.Storable.writeWord16OffPtr1_closure+4;
         const Foreign.Storable.$fStorableWord9_closure+3;
         const Foreign.Storable.$fStorableWord7_closure+4;
         const Foreign.Storable.$fStorableWord6_closure+2;
         const Foreign.Storable.$fStorableWord5_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.766012422 UTC

[section ""data" . Foreign.Storable.$fStorableDouble2_closure" {
     Foreign.Storable.$fStorableDouble2_closure:
         const Foreign.Storable.$fStorableDouble2_info;
 },
 Foreign.Storable.$fStorableDouble2_entry() //  [R2]
         { info_tbl: [(c4FPd,
                       label: Foreign.Storable.$fStorableDouble2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FPd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4FPh; else goto c4FPi;
       c4FPh: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableDouble2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4FPi: // global
           I64[Sp - 8] = block_c4FPa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4FPm; else goto c4FPb;
       u4FPm: // global
           call _c4FPa(R1) args: 0, res: 0, upd: 0;
       c4FPb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FPa() //  [R1]
         { info_tbl: [(c4FPa,
                       label: block_c4FPa_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FPa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FPl; else goto c4FPk;
       c4FPl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FPk: // global
           _s4Fmm::F64 = F64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _s4Fmm::F64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.76809303 UTC

[section ""data" . Foreign.Storable.$fStorableDouble4_closure" {
     Foreign.Storable.$fStorableDouble4_closure:
         const Foreign.Storable.$fStorableDouble4_info;
 },
 Foreign.Storable.$fStorableDouble4_entry() //  [R2, R3]
         { info_tbl: [(c4FPu,
                       label: Foreign.Storable.$fStorableDouble4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FPu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FPG; else goto c4FPH;
       c4FPG: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableDouble4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FPH: // global
           I64[Sp - 16] = block_c4FPr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FPN; else goto c4FPs;
       u4FPN: // global
           call _c4FPr(R1) args: 0, res: 0, upd: 0;
       c4FPs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FPr() //  [R1]
         { info_tbl: [(c4FPr,
                       label: block_c4FPr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FPr: // global
           I64[Sp] = block_c4FPx_info;
           _s4Fms::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fms::I64;
           if (R1 & 7 != 0) goto u4FPM; else goto c4FPy;
       u4FPM: // global
           call _c4FPx(R1) args: 0, res: 0, upd: 0;
       c4FPy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FPx() //  [R1]
         { info_tbl: [(c4FPx,
                       label: block_c4FPx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FPx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FPL; else goto c4FPK;
       c4FPL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FPK: // global
           _s4Fmy::F64 = F64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _s4Fmy::F64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.77080935 UTC

[section ""data" . Foreign.Storable.$fStorableDouble1_closure" {
     Foreign.Storable.$fStorableDouble1_closure:
         const Foreign.Storable.$fStorableDouble1_info;
 },
 Foreign.Storable.$fStorableDouble1_entry() //  [R2, R3]
         { info_tbl: [(c4FPV,
                       label: Foreign.Storable.$fStorableDouble1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FPV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FPZ; else goto c4FQ0;
       c4FPZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableDouble1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FQ0: // global
           I64[Sp - 16] = block_c4FPS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FQ8; else goto c4FPT;
       u4FQ8: // global
           call _c4FPS(R1) args: 0, res: 0, upd: 0;
       c4FPT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FPS() //  [R1]
         { info_tbl: [(c4FPS,
                       label: block_c4FPS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FPS: // global
           I64[Sp] = block_c4FPY_info;
           _s4FmE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FmE::I64;
           if (R1 & 7 != 0) goto u4FQ7; else goto c4FQ2;
       u4FQ7: // global
           call _c4FPY(R1) args: 0, res: 0, upd: 0;
       c4FQ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FPY() //  [R1]
         { info_tbl: [(c4FPY,
                       label: block_c4FPY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FPY: // global
           F64[I64[Sp + 8]] = F64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.773151829 UTC

[section ""data" . Foreign.Storable.$fStorableDouble3_closure" {
     Foreign.Storable.$fStorableDouble3_closure:
         const Foreign.Storable.$fStorableDouble3_info;
 },
 Foreign.Storable.$fStorableDouble3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4FQg,
                       label: Foreign.Storable.$fStorableDouble3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FQg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4FQp; else goto c4FQq;
       c4FQp: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableDouble3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FQq: // global
           I64[Sp - 24] = block_c4FQd_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4FQA; else goto c4FQe;
       u4FQA: // global
           call _c4FQd(R1) args: 0, res: 0, upd: 0;
       c4FQe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FQd() //  [R1]
         { info_tbl: [(c4FQd,
                       label: block_c4FQd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FQd: // global
           I64[Sp] = block_c4FQj_info;
           _s4FmN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FmN::I64;
           if (R1 & 7 != 0) goto u4FQz; else goto c4FQk;
       u4FQz: // global
           call _c4FQj(R1) args: 0, res: 0, upd: 0;
       c4FQk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FQj() //  [R1]
         { info_tbl: [(c4FQj,
                       label: block_c4FQj_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FQj: // global
           I64[Sp] = block_c4FQo_info;
           _s4FmP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FmP::I64;
           if (R1 & 7 != 0) goto u4FQB; else goto c4FQt;
       u4FQB: // global
           call _c4FQo(R1) args: 0, res: 0, upd: 0;
       c4FQt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FQo() //  [R1]
         { info_tbl: [(c4FQo,
                       label: block_c4FQo_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FQo: // global
           F64[I64[Sp + 8] + I64[Sp + 16]] = F64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.775231814 UTC

[section ""data" . Foreign.Storable.$fStorableDouble_closure" {
     Foreign.Storable.$fStorableDouble_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableDouble_$calignment_closure+1;
         const Foreign.Storable.$fStorableDouble_$calignment_closure+1;
         const GHC.Storable.readDoubleOffPtr1_closure+3;
         const GHC.Storable.writeDoubleOffPtr1_closure+4;
         const Foreign.Storable.$fStorableDouble4_closure+3;
         const Foreign.Storable.$fStorableDouble3_closure+4;
         const Foreign.Storable.$fStorableDouble2_closure+2;
         const Foreign.Storable.$fStorableDouble1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.776355686 UTC

[section ""data" . Foreign.Storable.$fStorableFloat2_closure" {
     Foreign.Storable.$fStorableFloat2_closure:
         const Foreign.Storable.$fStorableFloat2_info;
 },
 Foreign.Storable.$fStorableFloat2_entry() //  [R2]
         { info_tbl: [(c4FQJ,
                       label: Foreign.Storable.$fStorableFloat2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FQJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4FQN; else goto c4FQO;
       c4FQN: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFloat2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4FQO: // global
           I64[Sp - 8] = block_c4FQG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4FQS; else goto c4FQH;
       u4FQS: // global
           call _c4FQG(R1) args: 0, res: 0, upd: 0;
       c4FQH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FQG() //  [R1]
         { info_tbl: [(c4FQG,
                       label: block_c4FQG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FQG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FQR; else goto c4FQQ;
       c4FQR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FQQ: // global
           _s4Fn0::F32 = F32[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _s4Fn0::F32;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.77892566 UTC

[section ""data" . Foreign.Storable.$fStorableFloat4_closure" {
     Foreign.Storable.$fStorableFloat4_closure:
         const Foreign.Storable.$fStorableFloat4_info;
 },
 Foreign.Storable.$fStorableFloat4_entry() //  [R2, R3]
         { info_tbl: [(c4FR0,
                       label: Foreign.Storable.$fStorableFloat4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FR0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FRc; else goto c4FRd;
       c4FRc: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFloat4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FRd: // global
           I64[Sp - 16] = block_c4FQX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FRj; else goto c4FQY;
       u4FRj: // global
           call _c4FQX(R1) args: 0, res: 0, upd: 0;
       c4FQY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FQX() //  [R1]
         { info_tbl: [(c4FQX,
                       label: block_c4FQX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FQX: // global
           I64[Sp] = block_c4FR3_info;
           _s4Fn6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fn6::I64;
           if (R1 & 7 != 0) goto u4FRi; else goto c4FR4;
       u4FRi: // global
           call _c4FR3(R1) args: 0, res: 0, upd: 0;
       c4FR4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FR3() //  [R1]
         { info_tbl: [(c4FR3,
                       label: block_c4FR3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FR3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FRh; else goto c4FRg;
       c4FRh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FRg: // global
           _s4Fnc::F32 = F32[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _s4Fnc::F32;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.781747962 UTC

[section ""data" . Foreign.Storable.$fStorableFloat1_closure" {
     Foreign.Storable.$fStorableFloat1_closure:
         const Foreign.Storable.$fStorableFloat1_info;
 },
 Foreign.Storable.$fStorableFloat1_entry() //  [R2, R3]
         { info_tbl: [(c4FRr,
                       label: Foreign.Storable.$fStorableFloat1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FRr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FRv; else goto c4FRw;
       c4FRv: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFloat1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FRw: // global
           I64[Sp - 16] = block_c4FRo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FRE; else goto c4FRp;
       u4FRE: // global
           call _c4FRo(R1) args: 0, res: 0, upd: 0;
       c4FRp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FRo() //  [R1]
         { info_tbl: [(c4FRo,
                       label: block_c4FRo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FRo: // global
           I64[Sp] = block_c4FRu_info;
           _s4Fni::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fni::I64;
           if (R1 & 7 != 0) goto u4FRD; else goto c4FRy;
       u4FRD: // global
           call _c4FRu(R1) args: 0, res: 0, upd: 0;
       c4FRy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FRu() //  [R1]
         { info_tbl: [(c4FRu,
                       label: block_c4FRu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FRu: // global
           F32[I64[Sp + 8]] = F32[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.784421609 UTC

[section ""data" . Foreign.Storable.$fStorableFloat3_closure" {
     Foreign.Storable.$fStorableFloat3_closure:
         const Foreign.Storable.$fStorableFloat3_info;
 },
 Foreign.Storable.$fStorableFloat3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4FRM,
                       label: Foreign.Storable.$fStorableFloat3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FRM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4FRV; else goto c4FRW;
       c4FRV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFloat3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FRW: // global
           I64[Sp - 24] = block_c4FRJ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4FS6; else goto c4FRK;
       u4FS6: // global
           call _c4FRJ(R1) args: 0, res: 0, upd: 0;
       c4FRK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FRJ() //  [R1]
         { info_tbl: [(c4FRJ,
                       label: block_c4FRJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FRJ: // global
           I64[Sp] = block_c4FRP_info;
           _s4Fnr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fnr::I64;
           if (R1 & 7 != 0) goto u4FS5; else goto c4FRQ;
       u4FS5: // global
           call _c4FRP(R1) args: 0, res: 0, upd: 0;
       c4FRQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FRP() //  [R1]
         { info_tbl: [(c4FRP,
                       label: block_c4FRP_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FRP: // global
           I64[Sp] = block_c4FRU_info;
           _s4Fnt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fnt::I64;
           if (R1 & 7 != 0) goto u4FS7; else goto c4FRZ;
       u4FS7: // global
           call _c4FRU(R1) args: 0, res: 0, upd: 0;
       c4FRZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FRU() //  [R1]
         { info_tbl: [(c4FRU,
                       label: block_c4FRU_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FRU: // global
           F32[I64[Sp + 8] + I64[Sp + 16]] = F32[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.786960695 UTC

[section ""data" . Foreign.Storable.$fStorableFloat_closure" {
     Foreign.Storable.$fStorableFloat_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableFloat_$calignment_closure+1;
         const Foreign.Storable.$fStorableFloat_$calignment_closure+1;
         const GHC.Storable.readFloatOffPtr1_closure+3;
         const GHC.Storable.writeFloatOffPtr1_closure+4;
         const Foreign.Storable.$fStorableFloat4_closure+3;
         const Foreign.Storable.$fStorableFloat3_closure+4;
         const Foreign.Storable.$fStorableFloat2_closure+2;
         const Foreign.Storable.$fStorableFloat1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.788166875 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr2_closure" {
     Foreign.Storable.$fStorableStablePtr2_closure:
         const Foreign.Storable.$fStorableStablePtr2_info;
 },
 Foreign.Storable.$fStorableStablePtr2_entry() //  [R2]
         { info_tbl: [(c4FSf,
                       label: Foreign.Storable.$fStorableStablePtr2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FSf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4FSj; else goto c4FSk;
       c4FSj: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableStablePtr2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4FSk: // global
           I64[Sp - 8] = block_c4FSc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4FSo; else goto c4FSd;
       u4FSo: // global
           call _c4FSc(R1) args: 0, res: 0, upd: 0;
       c4FSd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FSc() //  [R1]
         { info_tbl: [(c4FSc,
                       label: block_c4FSc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FSc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FSn; else goto c4FSm;
       c4FSn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FSm: // global
           _s4FnE::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Stable.StablePtr_con_info;
           I64[Hp] = _s4FnE::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.790927557 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr4_closure" {
     Foreign.Storable.$fStorableStablePtr4_closure:
         const Foreign.Storable.$fStorableStablePtr4_info;
 },
 Foreign.Storable.$fStorableStablePtr4_entry() //  [R2, R3]
         { info_tbl: [(c4FSw,
                       label: Foreign.Storable.$fStorableStablePtr4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FSw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FSI; else goto c4FSJ;
       c4FSI: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableStablePtr4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FSJ: // global
           I64[Sp - 16] = block_c4FSt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FSP; else goto c4FSu;
       u4FSP: // global
           call _c4FSt(R1) args: 0, res: 0, upd: 0;
       c4FSu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FSt() //  [R1]
         { info_tbl: [(c4FSt,
                       label: block_c4FSt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FSt: // global
           I64[Sp] = block_c4FSz_info;
           _s4FnK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FnK::I64;
           if (R1 & 7 != 0) goto u4FSO; else goto c4FSA;
       u4FSO: // global
           call _c4FSz(R1) args: 0, res: 0, upd: 0;
       c4FSA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FSz() //  [R1]
         { info_tbl: [(c4FSz,
                       label: block_c4FSz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FSz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FSN; else goto c4FSM;
       c4FSN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FSM: // global
           _s4FnQ::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Stable.StablePtr_con_info;
           I64[Hp] = _s4FnQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.793755754 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr1_closure" {
     Foreign.Storable.$fStorableStablePtr1_closure:
         const Foreign.Storable.$fStorableStablePtr1_info;
 },
 Foreign.Storable.$fStorableStablePtr1_entry() //  [R2, R3]
         { info_tbl: [(c4FSX,
                       label: Foreign.Storable.$fStorableStablePtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FSX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FT1; else goto c4FT2;
       c4FT1: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableStablePtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FT2: // global
           I64[Sp - 16] = block_c4FSU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FTa; else goto c4FSV;
       u4FTa: // global
           call _c4FSU(R1) args: 0, res: 0, upd: 0;
       c4FSV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FSU() //  [R1]
         { info_tbl: [(c4FSU,
                       label: block_c4FSU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FSU: // global
           I64[Sp] = block_c4FT0_info;
           _s4FnW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FnW::I64;
           if (R1 & 7 != 0) goto u4FT9; else goto c4FT4;
       u4FT9: // global
           call _c4FT0(R1) args: 0, res: 0, upd: 0;
       c4FT4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FT0() //  [R1]
         { info_tbl: [(c4FT0,
                       label: block_c4FT0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FT0: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.796632716 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr3_closure" {
     Foreign.Storable.$fStorableStablePtr3_closure:
         const Foreign.Storable.$fStorableStablePtr3_info;
 },
 Foreign.Storable.$fStorableStablePtr3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4FTi,
                       label: Foreign.Storable.$fStorableStablePtr3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FTi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4FTr; else goto c4FTs;
       c4FTr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableStablePtr3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FTs: // global
           I64[Sp - 24] = block_c4FTf_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4FTC; else goto c4FTg;
       u4FTC: // global
           call _c4FTf(R1) args: 0, res: 0, upd: 0;
       c4FTg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FTf() //  [R1]
         { info_tbl: [(c4FTf,
                       label: block_c4FTf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FTf: // global
           I64[Sp] = block_c4FTl_info;
           _s4Fo5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fo5::I64;
           if (R1 & 7 != 0) goto u4FTB; else goto c4FTm;
       u4FTB: // global
           call _c4FTl(R1) args: 0, res: 0, upd: 0;
       c4FTm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FTl() //  [R1]
         { info_tbl: [(c4FTl,
                       label: block_c4FTl_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FTl: // global
           I64[Sp] = block_c4FTq_info;
           _s4Fo7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fo7::I64;
           if (R1 & 7 != 0) goto u4FTD; else goto c4FTv;
       u4FTD: // global
           call _c4FTq(R1) args: 0, res: 0, upd: 0;
       c4FTv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FTq() //  [R1]
         { info_tbl: [(c4FTq,
                       label: block_c4FTq_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FTq: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.799197899 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr_closure" {
     Foreign.Storable.$fStorableStablePtr_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableStablePtr_$calignment_closure+1;
         const Foreign.Storable.$fStorableStablePtr_$calignment_closure+1;
         const GHC.Storable.readStablePtrOffPtr1_closure+3;
         const GHC.Storable.writeStablePtrOffPtr1_closure+4;
         const Foreign.Storable.$fStorableStablePtr4_closure+3;
         const Foreign.Storable.$fStorableStablePtr3_closure+4;
         const Foreign.Storable.$fStorableStablePtr2_closure+2;
         const Foreign.Storable.$fStorableStablePtr1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.800772744 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr2_closure" {
     Foreign.Storable.$fStorableFunPtr2_closure:
         const Foreign.Storable.$fStorableFunPtr2_info;
 },
 Foreign.Storable.$fStorableFunPtr2_entry() //  [R2]
         { info_tbl: [(c4FTL,
                       label: Foreign.Storable.$fStorableFunPtr2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FTL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4FTP; else goto c4FTQ;
       c4FTP: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFunPtr2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4FTQ: // global
           I64[Sp - 8] = block_c4FTI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4FTU; else goto c4FTJ;
       u4FTU: // global
           call _c4FTI(R1) args: 0, res: 0, upd: 0;
       c4FTJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FTI() //  [R1]
         { info_tbl: [(c4FTI,
                       label: block_c4FTI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FTI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FTT; else goto c4FTS;
       c4FTT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FTS: // global
           _s4Foi::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = _s4Foi::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.803369187 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr4_closure" {
     Foreign.Storable.$fStorableFunPtr4_closure:
         const Foreign.Storable.$fStorableFunPtr4_info;
 },
 Foreign.Storable.$fStorableFunPtr4_entry() //  [R2, R3]
         { info_tbl: [(c4FU2,
                       label: Foreign.Storable.$fStorableFunPtr4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FU2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FUe; else goto c4FUf;
       c4FUe: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFunPtr4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FUf: // global
           I64[Sp - 16] = block_c4FTZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FUl; else goto c4FU0;
       u4FUl: // global
           call _c4FTZ(R1) args: 0, res: 0, upd: 0;
       c4FU0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FTZ() //  [R1]
         { info_tbl: [(c4FTZ,
                       label: block_c4FTZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FTZ: // global
           I64[Sp] = block_c4FU5_info;
           _s4Foo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Foo::I64;
           if (R1 & 7 != 0) goto u4FUk; else goto c4FU6;
       u4FUk: // global
           call _c4FU5(R1) args: 0, res: 0, upd: 0;
       c4FU6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FU5() //  [R1]
         { info_tbl: [(c4FU5,
                       label: block_c4FU5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FU5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FUj; else goto c4FUi;
       c4FUj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FUi: // global
           _s4Fou::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = _s4Fou::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.806617057 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr1_closure" {
     Foreign.Storable.$fStorableFunPtr1_closure:
         const Foreign.Storable.$fStorableFunPtr1_info;
 },
 Foreign.Storable.$fStorableFunPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4FUt,
                       label: Foreign.Storable.$fStorableFunPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FUt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FUx; else goto c4FUy;
       c4FUx: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFunPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FUy: // global
           I64[Sp - 16] = block_c4FUq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FUG; else goto c4FUr;
       u4FUG: // global
           call _c4FUq(R1) args: 0, res: 0, upd: 0;
       c4FUr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FUq() //  [R1]
         { info_tbl: [(c4FUq,
                       label: block_c4FUq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FUq: // global
           I64[Sp] = block_c4FUw_info;
           _s4FoA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FoA::I64;
           if (R1 & 7 != 0) goto u4FUF; else goto c4FUA;
       u4FUF: // global
           call _c4FUw(R1) args: 0, res: 0, upd: 0;
       c4FUA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FUw() //  [R1]
         { info_tbl: [(c4FUw,
                       label: block_c4FUw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FUw: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.80955953 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr3_closure" {
     Foreign.Storable.$fStorableFunPtr3_closure:
         const Foreign.Storable.$fStorableFunPtr3_info;
 },
 Foreign.Storable.$fStorableFunPtr3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4FUO,
                       label: Foreign.Storable.$fStorableFunPtr3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FUO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4FUX; else goto c4FUY;
       c4FUX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFunPtr3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FUY: // global
           I64[Sp - 24] = block_c4FUL_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4FV8; else goto c4FUM;
       u4FV8: // global
           call _c4FUL(R1) args: 0, res: 0, upd: 0;
       c4FUM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FUL() //  [R1]
         { info_tbl: [(c4FUL,
                       label: block_c4FUL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FUL: // global
           I64[Sp] = block_c4FUR_info;
           _s4FoJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FoJ::I64;
           if (R1 & 7 != 0) goto u4FV7; else goto c4FUS;
       u4FV7: // global
           call _c4FUR(R1) args: 0, res: 0, upd: 0;
       c4FUS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FUR() //  [R1]
         { info_tbl: [(c4FUR,
                       label: block_c4FUR_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FUR: // global
           I64[Sp] = block_c4FUW_info;
           _s4FoL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FoL::I64;
           if (R1 & 7 != 0) goto u4FV9; else goto c4FV1;
       u4FV9: // global
           call _c4FUW(R1) args: 0, res: 0, upd: 0;
       c4FV1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FUW() //  [R1]
         { info_tbl: [(c4FUW,
                       label: block_c4FUW_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FUW: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.812034926 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr_closure" {
     Foreign.Storable.$fStorableFunPtr_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableFunPtr_$calignment_closure+1;
         const Foreign.Storable.$fStorableFunPtr_$calignment_closure+1;
         const GHC.Storable.readFunPtrOffPtr1_closure+3;
         const GHC.Storable.writeFunPtrOffPtr1_closure+4;
         const Foreign.Storable.$fStorableFunPtr4_closure+3;
         const Foreign.Storable.$fStorableFunPtr3_closure+4;
         const Foreign.Storable.$fStorableFunPtr2_closure+2;
         const Foreign.Storable.$fStorableFunPtr1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.81369765 UTC

[section ""data" . Foreign.Storable.$fStorablePtr2_closure" {
     Foreign.Storable.$fStorablePtr2_closure:
         const Foreign.Storable.$fStorablePtr2_info;
 },
 Foreign.Storable.$fStorablePtr2_entry() //  [R2]
         { info_tbl: [(c4FVh,
                       label: Foreign.Storable.$fStorablePtr2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FVh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4FVl; else goto c4FVm;
       c4FVl: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorablePtr2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4FVm: // global
           I64[Sp - 8] = block_c4FVe_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4FVq; else goto c4FVf;
       u4FVq: // global
           call _c4FVe(R1) args: 0, res: 0, upd: 0;
       c4FVf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FVe() //  [R1]
         { info_tbl: [(c4FVe,
                       label: block_c4FVe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FVe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FVp; else goto c4FVo;
       c4FVp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FVo: // global
           _s4FoW::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4FoW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.816123667 UTC

[section ""data" . Foreign.Storable.$fStorablePtr4_closure" {
     Foreign.Storable.$fStorablePtr4_closure:
         const Foreign.Storable.$fStorablePtr4_info;
 },
 Foreign.Storable.$fStorablePtr4_entry() //  [R2, R3]
         { info_tbl: [(c4FVy,
                       label: Foreign.Storable.$fStorablePtr4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FVy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FVK; else goto c4FVL;
       c4FVK: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorablePtr4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FVL: // global
           I64[Sp - 16] = block_c4FVv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FVR; else goto c4FVw;
       u4FVR: // global
           call _c4FVv(R1) args: 0, res: 0, upd: 0;
       c4FVw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FVv() //  [R1]
         { info_tbl: [(c4FVv,
                       label: block_c4FVv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FVv: // global
           I64[Sp] = block_c4FVB_info;
           _s4Fp2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fp2::I64;
           if (R1 & 7 != 0) goto u4FVQ; else goto c4FVC;
       u4FVQ: // global
           call _c4FVB(R1) args: 0, res: 0, upd: 0;
       c4FVC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FVB() //  [R1]
         { info_tbl: [(c4FVB,
                       label: block_c4FVB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FVB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FVP; else goto c4FVO;
       c4FVP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FVO: // global
           _s4Fp8::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fp8::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.818809781 UTC

[section ""data" . Foreign.Storable.$fStorablePtr1_closure" {
     Foreign.Storable.$fStorablePtr1_closure:
         const Foreign.Storable.$fStorablePtr1_info;
 },
 Foreign.Storable.$fStorablePtr1_entry() //  [R2, R3]
         { info_tbl: [(c4FVZ,
                       label: Foreign.Storable.$fStorablePtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FVZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FW3; else goto c4FW4;
       c4FW3: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorablePtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FW4: // global
           I64[Sp - 16] = block_c4FVW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FWc; else goto c4FVX;
       u4FWc: // global
           call _c4FVW(R1) args: 0, res: 0, upd: 0;
       c4FVX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FVW() //  [R1]
         { info_tbl: [(c4FVW,
                       label: block_c4FVW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FVW: // global
           I64[Sp] = block_c4FW2_info;
           _s4Fpe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fpe::I64;
           if (R1 & 7 != 0) goto u4FWb; else goto c4FW6;
       u4FWb: // global
           call _c4FW2(R1) args: 0, res: 0, upd: 0;
       c4FW6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FW2() //  [R1]
         { info_tbl: [(c4FW2,
                       label: block_c4FW2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FW2: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.820505542 UTC

[section ""data" . Foreign.Storable.$fStorablePtr3_closure" {
     Foreign.Storable.$fStorablePtr3_closure:
         const Foreign.Storable.$fStorablePtr3_info;
 },
 Foreign.Storable.$fStorablePtr3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4FWk,
                       label: Foreign.Storable.$fStorablePtr3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FWk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4FWt; else goto c4FWu;
       c4FWt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorablePtr3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FWu: // global
           I64[Sp - 24] = block_c4FWh_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4FWE; else goto c4FWi;
       u4FWE: // global
           call _c4FWh(R1) args: 0, res: 0, upd: 0;
       c4FWi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FWh() //  [R1]
         { info_tbl: [(c4FWh,
                       label: block_c4FWh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FWh: // global
           I64[Sp] = block_c4FWn_info;
           _s4Fpn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fpn::I64;
           if (R1 & 7 != 0) goto u4FWD; else goto c4FWo;
       u4FWD: // global
           call _c4FWn(R1) args: 0, res: 0, upd: 0;
       c4FWo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FWn() //  [R1]
         { info_tbl: [(c4FWn,
                       label: block_c4FWn_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FWn: // global
           I64[Sp] = block_c4FWs_info;
           _s4Fpp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fpp::I64;
           if (R1 & 7 != 0) goto u4FWF; else goto c4FWx;
       u4FWF: // global
           call _c4FWs(R1) args: 0, res: 0, upd: 0;
       c4FWx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FWs() //  [R1]
         { info_tbl: [(c4FWs,
                       label: block_c4FWs_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FWs: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.822127775 UTC

[section ""data" . Foreign.Storable.$fStorablePtr_closure" {
     Foreign.Storable.$fStorablePtr_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorablePtr_$calignment_closure+1;
         const Foreign.Storable.$fStorablePtr_$calignment_closure+1;
         const GHC.Storable.readPtrOffPtr1_closure+3;
         const GHC.Storable.writePtrOffPtr1_closure+4;
         const Foreign.Storable.$fStorablePtr4_closure+3;
         const Foreign.Storable.$fStorablePtr3_closure+4;
         const Foreign.Storable.$fStorablePtr2_closure+2;
         const Foreign.Storable.$fStorablePtr1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.82318011 UTC

[section ""data" . Foreign.Storable.$fStorableWord2_closure" {
     Foreign.Storable.$fStorableWord2_closure:
         const Foreign.Storable.$fStorableWord2_info;
 },
 Foreign.Storable.$fStorableWord2_entry() //  [R2]
         { info_tbl: [(c4FWN,
                       label: Foreign.Storable.$fStorableWord2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FWN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4FWR; else goto c4FWS;
       c4FWR: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4FWS: // global
           I64[Sp - 8] = block_c4FWK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4FWW; else goto c4FWL;
       u4FWW: // global
           call _c4FWK(R1) args: 0, res: 0, upd: 0;
       c4FWL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FWK() //  [R1]
         { info_tbl: [(c4FWK,
                       label: block_c4FWK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FWK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FWV; else goto c4FWU;
       c4FWV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FWU: // global
           _s4FpA::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s4FpA::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.824794881 UTC

[section ""data" . Foreign.Storable.$fStorableWord4_closure" {
     Foreign.Storable.$fStorableWord4_closure:
         const Foreign.Storable.$fStorableWord4_info;
 },
 Foreign.Storable.$fStorableWord4_entry() //  [R2, R3]
         { info_tbl: [(c4FX4,
                       label: Foreign.Storable.$fStorableWord4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FX4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FXg; else goto c4FXh;
       c4FXg: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FXh: // global
           I64[Sp - 16] = block_c4FX1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FXn; else goto c4FX2;
       u4FXn: // global
           call _c4FX1(R1) args: 0, res: 0, upd: 0;
       c4FX2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FX1() //  [R1]
         { info_tbl: [(c4FX1,
                       label: block_c4FX1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FX1: // global
           I64[Sp] = block_c4FX7_info;
           _s4FpG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FpG::I64;
           if (R1 & 7 != 0) goto u4FXm; else goto c4FX8;
       u4FXm: // global
           call _c4FX7(R1) args: 0, res: 0, upd: 0;
       c4FX8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FX7() //  [R1]
         { info_tbl: [(c4FX7,
                       label: block_c4FX7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FX7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FXl; else goto c4FXk;
       c4FXl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FXk: // global
           _s4FpM::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s4FpM::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.826704712 UTC

[section ""data" . Foreign.Storable.$fStorableWord1_closure" {
     Foreign.Storable.$fStorableWord1_closure:
         const Foreign.Storable.$fStorableWord1_info;
 },
 Foreign.Storable.$fStorableWord1_entry() //  [R2, R3]
         { info_tbl: [(c4FXv,
                       label: Foreign.Storable.$fStorableWord1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FXv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FXz; else goto c4FXA;
       c4FXz: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FXA: // global
           I64[Sp - 16] = block_c4FXs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FXI; else goto c4FXt;
       u4FXI: // global
           call _c4FXs(R1) args: 0, res: 0, upd: 0;
       c4FXt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FXs() //  [R1]
         { info_tbl: [(c4FXs,
                       label: block_c4FXs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FXs: // global
           I64[Sp] = block_c4FXy_info;
           _s4FpS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FpS::I64;
           if (R1 & 7 != 0) goto u4FXH; else goto c4FXC;
       u4FXH: // global
           call _c4FXy(R1) args: 0, res: 0, upd: 0;
       c4FXC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FXy() //  [R1]
         { info_tbl: [(c4FXy,
                       label: block_c4FXy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FXy: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.830138926 UTC

[section ""data" . Foreign.Storable.$fStorableWord3_closure" {
     Foreign.Storable.$fStorableWord3_closure:
         const Foreign.Storable.$fStorableWord3_info;
 },
 Foreign.Storable.$fStorableWord3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4FXQ,
                       label: Foreign.Storable.$fStorableWord3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FXQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4FXZ; else goto c4FY0;
       c4FXZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FY0: // global
           I64[Sp - 24] = block_c4FXN_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4FYa; else goto c4FXO;
       u4FYa: // global
           call _c4FXN(R1) args: 0, res: 0, upd: 0;
       c4FXO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FXN() //  [R1]
         { info_tbl: [(c4FXN,
                       label: block_c4FXN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FXN: // global
           I64[Sp] = block_c4FXT_info;
           _s4Fq1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fq1::I64;
           if (R1 & 7 != 0) goto u4FY9; else goto c4FXU;
       u4FY9: // global
           call _c4FXT(R1) args: 0, res: 0, upd: 0;
       c4FXU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FXT() //  [R1]
         { info_tbl: [(c4FXT,
                       label: block_c4FXT_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FXT: // global
           I64[Sp] = block_c4FXY_info;
           _s4Fq3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fq3::I64;
           if (R1 & 7 != 0) goto u4FYb; else goto c4FY3;
       u4FYb: // global
           call _c4FXY(R1) args: 0, res: 0, upd: 0;
       c4FY3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FXY() //  [R1]
         { info_tbl: [(c4FXY,
                       label: block_c4FXY_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FXY: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.831678041 UTC

[section ""data" . Foreign.Storable.$fStorableWord_closure" {
     Foreign.Storable.$fStorableWord_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableWord_$calignment_closure+1;
         const Foreign.Storable.$fStorableWord_$calignment_closure+1;
         const GHC.Storable.readWordOffPtr1_closure+3;
         const GHC.Storable.writeWordOffPtr1_closure+4;
         const Foreign.Storable.$fStorableWord4_closure+3;
         const Foreign.Storable.$fStorableWord3_closure+4;
         const Foreign.Storable.$fStorableWord2_closure+2;
         const Foreign.Storable.$fStorableWord1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.83270027 UTC

[section ""data" . Foreign.Storable.$fStorableInt2_closure" {
     Foreign.Storable.$fStorableInt2_closure:
         const Foreign.Storable.$fStorableInt2_info;
 },
 Foreign.Storable.$fStorableInt2_entry() //  [R2]
         { info_tbl: [(c4FYj,
                       label: Foreign.Storable.$fStorableInt2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FYj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4FYn; else goto c4FYo;
       c4FYn: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4FYo: // global
           I64[Sp - 8] = block_c4FYg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4FYs; else goto c4FYh;
       u4FYs: // global
           call _c4FYg(R1) args: 0, res: 0, upd: 0;
       c4FYh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FYg() //  [R1]
         { info_tbl: [(c4FYg,
                       label: block_c4FYg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FYg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FYr; else goto c4FYq;
       c4FYr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FYq: // global
           _s4Fqe::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4Fqe::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.83428143 UTC

[section ""data" . Foreign.Storable.$fStorableInt4_closure" {
     Foreign.Storable.$fStorableInt4_closure:
         const Foreign.Storable.$fStorableInt4_info;
 },
 Foreign.Storable.$fStorableInt4_entry() //  [R2, R3]
         { info_tbl: [(c4FYA,
                       label: Foreign.Storable.$fStorableInt4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FYA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FYM; else goto c4FYN;
       c4FYM: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FYN: // global
           I64[Sp - 16] = block_c4FYx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FYT; else goto c4FYy;
       u4FYT: // global
           call _c4FYx(R1) args: 0, res: 0, upd: 0;
       c4FYy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FYx() //  [R1]
         { info_tbl: [(c4FYx,
                       label: block_c4FYx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FYx: // global
           I64[Sp] = block_c4FYD_info;
           _s4Fqk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fqk::I64;
           if (R1 & 7 != 0) goto u4FYS; else goto c4FYE;
       u4FYS: // global
           call _c4FYD(R1) args: 0, res: 0, upd: 0;
       c4FYE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FYD() //  [R1]
         { info_tbl: [(c4FYD,
                       label: block_c4FYD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FYD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FYR; else goto c4FYQ;
       c4FYR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FYQ: // global
           _s4Fqq::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4Fqq::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.835961264 UTC

[section ""data" . Foreign.Storable.$fStorableInt1_closure" {
     Foreign.Storable.$fStorableInt1_closure:
         const Foreign.Storable.$fStorableInt1_info;
 },
 Foreign.Storable.$fStorableInt1_entry() //  [R2, R3]
         { info_tbl: [(c4FZ1,
                       label: Foreign.Storable.$fStorableInt1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FZ1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4FZ5; else goto c4FZ6;
       c4FZ5: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FZ6: // global
           I64[Sp - 16] = block_c4FYY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4FZe; else goto c4FYZ;
       u4FZe: // global
           call _c4FYY(R1) args: 0, res: 0, upd: 0;
       c4FYZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FYY() //  [R1]
         { info_tbl: [(c4FYY,
                       label: block_c4FYY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FYY: // global
           I64[Sp] = block_c4FZ4_info;
           _s4Fqw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fqw::I64;
           if (R1 & 7 != 0) goto u4FZd; else goto c4FZ8;
       u4FZd: // global
           call _c4FZ4(R1) args: 0, res: 0, upd: 0;
       c4FZ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FZ4() //  [R1]
         { info_tbl: [(c4FZ4,
                       label: block_c4FZ4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FZ4: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.837613254 UTC

[section ""data" . Foreign.Storable.$fStorableInt3_closure" {
     Foreign.Storable.$fStorableInt3_closure:
         const Foreign.Storable.$fStorableInt3_info;
 },
 Foreign.Storable.$fStorableInt3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4FZm,
                       label: Foreign.Storable.$fStorableInt3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FZm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4FZv; else goto c4FZw;
       c4FZv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4FZw: // global
           I64[Sp - 24] = block_c4FZj_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4FZG; else goto c4FZk;
       u4FZG: // global
           call _c4FZj(R1) args: 0, res: 0, upd: 0;
       c4FZk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FZj() //  [R1]
         { info_tbl: [(c4FZj,
                       label: block_c4FZj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FZj: // global
           I64[Sp] = block_c4FZp_info;
           _s4FqF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FqF::I64;
           if (R1 & 7 != 0) goto u4FZF; else goto c4FZq;
       u4FZF: // global
           call _c4FZp(R1) args: 0, res: 0, upd: 0;
       c4FZq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FZp() //  [R1]
         { info_tbl: [(c4FZp,
                       label: block_c4FZp_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FZp: // global
           I64[Sp] = block_c4FZu_info;
           _s4FqH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FqH::I64;
           if (R1 & 7 != 0) goto u4FZH; else goto c4FZz;
       u4FZH: // global
           call _c4FZu(R1) args: 0, res: 0, upd: 0;
       c4FZz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FZu() //  [R1]
         { info_tbl: [(c4FZu,
                       label: block_c4FZu_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FZu: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.839070643 UTC

[section ""data" . Foreign.Storable.$fStorableInt_closure" {
     Foreign.Storable.$fStorableInt_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt_$calignment_closure+1;
         const GHC.Storable.readIntOffPtr1_closure+3;
         const GHC.Storable.writeIntOffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt4_closure+3;
         const Foreign.Storable.$fStorableInt3_closure+4;
         const Foreign.Storable.$fStorableInt2_closure+2;
         const Foreign.Storable.$fStorableInt1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.840110822 UTC

[section ""data" . Foreign.Storable.$fStorableChar2_closure" {
     Foreign.Storable.$fStorableChar2_closure:
         const Foreign.Storable.$fStorableChar2_info;
 },
 Foreign.Storable.$fStorableChar2_entry() //  [R2]
         { info_tbl: [(c4FZP,
                       label: Foreign.Storable.$fStorableChar2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FZP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4FZT; else goto c4FZU;
       c4FZT: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableChar2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4FZU: // global
           I64[Sp - 8] = block_c4FZM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4FZY; else goto c4FZN;
       u4FZY: // global
           call _c4FZM(R1) args: 0, res: 0, upd: 0;
       c4FZN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4FZM() //  [R1]
         { info_tbl: [(c4FZM,
                       label: block_c4FZM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4FZM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4FZX; else goto c4FZW;
       c4FZX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4FZW: // global
           _s4FqS::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s4FqS::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.842034896 UTC

[section ""data" . Foreign.Storable.$fStorableChar4_closure" {
     Foreign.Storable.$fStorableChar4_closure:
         const Foreign.Storable.$fStorableChar4_info;
 },
 Foreign.Storable.$fStorableChar4_entry() //  [R2, R3]
         { info_tbl: [(c4G06,
                       label: Foreign.Storable.$fStorableChar4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G06: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4G0i; else goto c4G0j;
       c4G0i: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableChar4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4G0j: // global
           I64[Sp - 16] = block_c4G03_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4G0p; else goto c4G04;
       u4G0p: // global
           call _c4G03(R1) args: 0, res: 0, upd: 0;
       c4G04: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G03() //  [R1]
         { info_tbl: [(c4G03,
                       label: block_c4G03_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G03: // global
           I64[Sp] = block_c4G09_info;
           _s4FqY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FqY::I64;
           if (R1 & 7 != 0) goto u4G0o; else goto c4G0a;
       u4G0o: // global
           call _c4G09(R1) args: 0, res: 0, upd: 0;
       c4G0a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G09() //  [R1]
         { info_tbl: [(c4G09,
                       label: block_c4G09_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G09: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4G0n; else goto c4G0m;
       c4G0n: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4G0m: // global
           _s4Fr4::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s4Fr4::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.843777109 UTC

[section ""data" . Foreign.Storable.$fStorableChar1_closure" {
     Foreign.Storable.$fStorableChar1_closure:
         const Foreign.Storable.$fStorableChar1_info;
 },
 Foreign.Storable.$fStorableChar1_entry() //  [R2, R3]
         { info_tbl: [(c4G0x,
                       label: Foreign.Storable.$fStorableChar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G0x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4G0B; else goto c4G0C;
       c4G0B: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableChar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4G0C: // global
           I64[Sp - 16] = block_c4G0u_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4G0K; else goto c4G0v;
       u4G0K: // global
           call _c4G0u(R1) args: 0, res: 0, upd: 0;
       c4G0v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G0u() //  [R1]
         { info_tbl: [(c4G0u,
                       label: block_c4G0u_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G0u: // global
           I64[Sp] = block_c4G0A_info;
           _s4Fra::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fra::I64;
           if (R1 & 7 != 0) goto u4G0J; else goto c4G0E;
       u4G0J: // global
           call _c4G0A(R1) args: 0, res: 0, upd: 0;
       c4G0E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G0A() //  [R1]
         { info_tbl: [(c4G0A,
                       label: block_c4G0A_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G0A: // global
           I32[I64[Sp + 8]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.84560828 UTC

[section ""data" . Foreign.Storable.$fStorableChar3_closure" {
     Foreign.Storable.$fStorableChar3_closure:
         const Foreign.Storable.$fStorableChar3_info;
 },
 Foreign.Storable.$fStorableChar3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4G0S,
                       label: Foreign.Storable.$fStorableChar3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G0S: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4G11; else goto c4G12;
       c4G11: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableChar3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4G12: // global
           I64[Sp - 24] = block_c4G0P_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4G1c; else goto c4G0Q;
       u4G1c: // global
           call _c4G0P(R1) args: 0, res: 0, upd: 0;
       c4G0Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G0P() //  [R1]
         { info_tbl: [(c4G0P,
                       label: block_c4G0P_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G0P: // global
           I64[Sp] = block_c4G0V_info;
           _s4Frj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Frj::I64;
           if (R1 & 7 != 0) goto u4G1b; else goto c4G0W;
       u4G1b: // global
           call _c4G0V(R1) args: 0, res: 0, upd: 0;
       c4G0W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G0V() //  [R1]
         { info_tbl: [(c4G0V,
                       label: block_c4G0V_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G0V: // global
           I64[Sp] = block_c4G10_info;
           _s4Frl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Frl::I64;
           if (R1 & 7 != 0) goto u4G1d; else goto c4G15;
       u4G1d: // global
           call _c4G10(R1) args: 0, res: 0, upd: 0;
       c4G15: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G10() //  [R1]
         { info_tbl: [(c4G10,
                       label: block_c4G10_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G10: // global
           I32[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.847094711 UTC

[section ""data" . Foreign.Storable.$fStorableChar_closure" {
     Foreign.Storable.$fStorableChar_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableChar_$calignment_closure+1;
         const Foreign.Storable.$fStorableChar_$calignment_closure+1;
         const GHC.Storable.readWideCharOffPtr1_closure+3;
         const GHC.Storable.writeWideCharOffPtr1_closure+4;
         const Foreign.Storable.$fStorableChar4_closure+3;
         const Foreign.Storable.$fStorableChar3_closure+4;
         const Foreign.Storable.$fStorableChar2_closure+2;
         const Foreign.Storable.$fStorableChar1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.847747906 UTC

[section ""data" . Foreign.Storable.$trModule3_closure" {
     Foreign.Storable.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Storable.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.848320936 UTC

[section ""data" . Foreign.Storable.$trModule1_closure" {
     Foreign.Storable.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Storable.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.848882726 UTC

[section ""data" . Foreign.Storable.$trModule_closure" {
     Foreign.Storable.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Storable.$trModule3_closure+1;
         const Foreign.Storable.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.849566947 UTC

[section ""data" . $krep_r4Ffk_closure" {
     $krep_r4Ffk_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.850178691 UTC

[section ""data" . Foreign.Storable.$tcStorable1_closure" {
     Foreign.Storable.$tcStorable1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep_r4Ffk_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.850741596 UTC

[section ""cstring" . Foreign.Storable.$tcStorable3_bytes" {
     Foreign.Storable.$tcStorable3_bytes:
         I8[] [83,116,111,114,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.851283863 UTC

[section ""data" . Foreign.Storable.$tcStorable2_closure" {
     Foreign.Storable.$tcStorable2_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Storable.$tcStorable3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.851871498 UTC

[section ""data" . Foreign.Storable.$tcStorable_closure" {
     Foreign.Storable.$tcStorable_closure:
         const GHC.Types.TyCon_con_info;
         const Foreign.Storable.$trModule_closure+1;
         const Foreign.Storable.$tcStorable2_closure+1;
         const Foreign.Storable.$tcStorable1_closure+4;
         const 9192657549155052097;
         const 13909834202100645491;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.852948269 UTC

[section ""data" . Foreign.Storable.$fStorableWord20_closure" {
     Foreign.Storable.$fStorableWord20_closure:
         const Foreign.Storable.$fStorableWord20_info;
 },
 Foreign.Storable.$fStorableWord20_entry() //  [R2]
         { info_tbl: [(c4G1l,
                       label: Foreign.Storable.$fStorableWord20_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G1l: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4G1p; else goto c4G1q;
       c4G1p: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord20_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4G1q: // global
           I64[Sp - 8] = block_c4G1i_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4G1u; else goto c4G1j;
       u4G1u: // global
           call _c4G1i(R1) args: 0, res: 0, upd: 0;
       c4G1j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G1i() //  [R1]
         { info_tbl: [(c4G1i,
                       label: block_c4G1i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G1i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4G1t; else goto c4G1s;
       c4G1t: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4G1s: // global
           _s4Frw::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s4Frw::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.854615717 UTC

[section ""data" . Foreign.Storable.$fStorableWord22_closure" {
     Foreign.Storable.$fStorableWord22_closure:
         const Foreign.Storable.$fStorableWord22_info;
 },
 Foreign.Storable.$fStorableWord22_entry() //  [R2, R3]
         { info_tbl: [(c4G1C,
                       label: Foreign.Storable.$fStorableWord22_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G1C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4G1O; else goto c4G1P;
       c4G1O: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord22_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4G1P: // global
           I64[Sp - 16] = block_c4G1z_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4G1V; else goto c4G1A;
       u4G1V: // global
           call _c4G1z(R1) args: 0, res: 0, upd: 0;
       c4G1A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G1z() //  [R1]
         { info_tbl: [(c4G1z,
                       label: block_c4G1z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G1z: // global
           I64[Sp] = block_c4G1F_info;
           _s4FrC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FrC::I64;
           if (R1 & 7 != 0) goto u4G1U; else goto c4G1G;
       u4G1U: // global
           call _c4G1F(R1) args: 0, res: 0, upd: 0;
       c4G1G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G1F() //  [R1]
         { info_tbl: [(c4G1F,
                       label: block_c4G1F_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G1F: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4G1T; else goto c4G1S;
       c4G1T: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4G1S: // global
           _s4FrI::I64 = %MO_UU_Conv_W8_W64(I8[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s4FrI::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.856301959 UTC

[section ""data" . Foreign.Storable.$fStorableWord19_closure" {
     Foreign.Storable.$fStorableWord19_closure:
         const Foreign.Storable.$fStorableWord19_info;
 },
 Foreign.Storable.$fStorableWord19_entry() //  [R2, R3]
         { info_tbl: [(c4G23,
                       label: Foreign.Storable.$fStorableWord19_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G23: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4G27; else goto c4G28;
       c4G27: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord19_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4G28: // global
           I64[Sp - 16] = block_c4G20_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4G2g; else goto c4G21;
       u4G2g: // global
           call _c4G20(R1) args: 0, res: 0, upd: 0;
       c4G21: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G20() //  [R1]
         { info_tbl: [(c4G20,
                       label: block_c4G20_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G20: // global
           I64[Sp] = block_c4G26_info;
           _s4FrO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FrO::I64;
           if (R1 & 7 != 0) goto u4G2f; else goto c4G2a;
       u4G2f: // global
           call _c4G26(R1) args: 0, res: 0, upd: 0;
       c4G2a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G26() //  [R1]
         { info_tbl: [(c4G26,
                       label: block_c4G26_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G26: // global
           I8[I64[Sp + 8]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.85822292 UTC

[section ""data" . Foreign.Storable.$fStorableWord21_closure" {
     Foreign.Storable.$fStorableWord21_closure:
         const Foreign.Storable.$fStorableWord21_info;
 },
 Foreign.Storable.$fStorableWord21_entry() //  [R2, R3, R4]
         { info_tbl: [(c4G2o,
                       label: Foreign.Storable.$fStorableWord21_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G2o: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4G2x; else goto c4G2y;
       c4G2x: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord21_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4G2y: // global
           I64[Sp - 24] = block_c4G2l_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4G2I; else goto c4G2m;
       u4G2I: // global
           call _c4G2l(R1) args: 0, res: 0, upd: 0;
       c4G2m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G2l() //  [R1]
         { info_tbl: [(c4G2l,
                       label: block_c4G2l_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G2l: // global
           I64[Sp] = block_c4G2r_info;
           _s4FrX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FrX::I64;
           if (R1 & 7 != 0) goto u4G2H; else goto c4G2s;
       u4G2H: // global
           call _c4G2r(R1) args: 0, res: 0, upd: 0;
       c4G2s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G2r() //  [R1]
         { info_tbl: [(c4G2r,
                       label: block_c4G2r_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G2r: // global
           I64[Sp] = block_c4G2w_info;
           _s4FrZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FrZ::I64;
           if (R1 & 7 != 0) goto u4G2J; else goto c4G2B;
       u4G2J: // global
           call _c4G2w(R1) args: 0, res: 0, upd: 0;
       c4G2B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G2w() //  [R1]
         { info_tbl: [(c4G2w,
                       label: block_c4G2w_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G2w: // global
           I8[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.859722472 UTC

[section ""data" . Foreign.Storable.$fStorableWord8_closure" {
     Foreign.Storable.$fStorableWord8_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableWord8_$calignment_closure+1;
         const Foreign.Storable.$fStorableWord8_$calignment_closure+1;
         const GHC.Storable.readWord8OffPtr1_closure+3;
         const GHC.Storable.writeWord8OffPtr1_closure+4;
         const Foreign.Storable.$fStorableWord22_closure+3;
         const Foreign.Storable.$fStorableWord21_closure+4;
         const Foreign.Storable.$fStorableWord20_closure+2;
         const Foreign.Storable.$fStorableWord19_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.86097743 UTC

[section ""data" . Foreign.Storable.$fStorableRatio2_closure" {
     Foreign.Storable.$fStorableRatio2_closure:
         const Foreign.Storable.$fStorableRatio2_info;
         const 0;
 },
 sat_s4Fse_entry() //  [R1]
         { info_tbl: [(c4G2W,
                       label: sat_s4Fse_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G2W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4G2X; else goto c4G2Y;
       c4G2X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4G2Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.%_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableRatio2_entry() //  [R2, R3, R4]
         { info_tbl: [(c4G2Z,
                       label: Foreign.Storable.$fStorableRatio2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G2Z: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c4G30; else goto c4G31;
       c4G30: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4G31: // global
           I64[Sp - 32] = block_c4G2O_info;
           _s4Fs4::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_pv_info;
           P64[Sp - 40] = R4;
           P64[Sp - 24] = _s4Fs4::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 48;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c4G2O() //  [R1]
         { info_tbl: [(c4G2O,
                       label: block_c4G2O_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G2O: // global
           _s4Fs4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4G2Q_info;
           R2 = _s4Fs4::P64;
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp] = Foreign.Storable.$fStorable()7_closure+1;
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c4G2Q() //  [R1]
         { info_tbl: [(c4G2Q,
                       label: block_c4G2Q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G2Q: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4G35; else goto c4G34;
       c4G35: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4G34: // global
           I64[Hp - 32] = sat_s4Fse_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.863286037 UTC

[section ""data" . Foreign.Storable.$fStorableRatio1_closure" {
     Foreign.Storable.$fStorableRatio1_closure:
         const Foreign.Storable.$fStorableRatio1_info;
 },
 Foreign.Storable.$fStorableRatio1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c4G3d,
                       label: Foreign.Storable.$fStorableRatio1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G3d: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c4G3h; else goto c4G3i;
       c4G3h: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4G3i: // global
           I64[Sp - 24] = block_c4G3a_info;
           R1 = R5;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4G3m; else goto c4G3b;
       u4G3m: // global
           call _c4G3a(R1) args: 0, res: 0, upd: 0;
       c4G3b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G3a() //  [R1]
         { info_tbl: [(c4G3a,
                       label: block_c4G3a_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G3a: // global
           I64[Sp - 8] = block_c4G3g_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_ppv_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 32;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c4G3g() //  []
         { info_tbl: [(c4G3g,
                       label: block_c4G3g_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G3g: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppv_info;
           _s4Fsm::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 16] = Foreign.Storable.$fStorable()7_closure+1;
           P64[Sp + 24] = _s4Fsm::P64;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.865374577 UTC

[section ""data" . Foreign.Storable.$fStorableBool6_closure" {
     Foreign.Storable.$fStorableBool6_closure:
         const Foreign.Storable.$fStorableBool6_info;
 },
 sat_s4FsB_entry() //  [R1]
         { info_tbl: [(c4G3J,
                       label: sat_s4FsB_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G3J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4G3K; else goto c4G3L;
       c4G3K: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4G3L: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c4G3I; else goto c4G3H;
       c4G3I: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4G3H: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableBool6_entry() //  [R2, R3]
         { info_tbl: [(c4G3M,
                       label: Foreign.Storable.$fStorableBool6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G3M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4G3N; else goto c4G3O;
       c4G3N: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4G3O: // global
           I64[Sp - 16] = block_c4G3r_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4G3U; else goto c4G3s;
       u4G3U: // global
           call _c4G3r(R1) args: 0, res: 0, upd: 0;
       c4G3s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G3r() //  [R1]
         { info_tbl: [(c4G3r,
                       label: block_c4G3r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G3r: // global
           I64[Sp] = block_c4G3w_info;
           _s4Fsu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fsu::I64;
           if (R1 & 7 != 0) goto u4G3T; else goto c4G3x;
       u4G3T: // global
           call _c4G3w(R1) args: 0, res: 0, upd: 0;
       c4G3x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G3w() //  [R1]
         { info_tbl: [(c4G3w,
                       label: block_c4G3w_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G3w: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4G3S; else goto c4G3R;
       c4G3S: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4G3R: // global
           _s4Fsz::I64 = %MO_SS_Conv_W32_W64(I32[I64[Sp + 8] + (I64[R1 + 7] << 2)]);
           I64[Hp - 16] = sat_s4FsB_info;
           I64[Hp] = _s4Fsz::I64;
           R1 = Hp - 16;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.867693483 UTC

[section ""data" . Foreign.Storable.$fStorableBool2_closure" {
     Foreign.Storable.$fStorableBool2_closure:
         const Foreign.Storable.$fStorableBool2_info;
 },
 sat_s4FsK_entry() //  [R1]
         { info_tbl: [(c4G4c,
                       label: sat_s4FsK_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G4c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4G4d; else goto c4G4e;
       c4G4d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4G4e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c4G4b; else goto c4G4a;
       c4G4b: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4G4a: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableBool2_entry() //  [R2]
         { info_tbl: [(c4G4f,
                       label: Foreign.Storable.$fStorableBool2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G4f: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4G4g; else goto c4G4h;
       c4G4g: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4G4h: // global
           I64[Sp - 8] = block_c4G3Z_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4G4l; else goto c4G40;
       u4G4l: // global
           call _c4G3Z(R1) args: 0, res: 0, upd: 0;
       c4G40: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G3Z() //  [R1]
         { info_tbl: [(c4G3Z,
                       label: block_c4G3Z_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G3Z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4G4k; else goto c4G4j;
       c4G4k: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4G4j: // global
           _s4FsI::I64 = %MO_SS_Conv_W32_W64(I32[I64[R1 + 7]]);
           I64[Hp - 16] = sat_s4FsK_info;
           I64[Hp] = _s4FsI::I64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.870102173 UTC

[section ""data" . Foreign.Storable.$fStorableBool4_closure" {
     Foreign.Storable.$fStorableBool4_closure:
         const Foreign.Storable.$fStorableBool4_info;
 },
 sat_s4FsX_entry() //  [R1]
         { info_tbl: [(c4G4L,
                       label: sat_s4FsX_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G4L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4G4M; else goto c4G4N;
       c4G4M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4G4N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c4G4K; else goto c4G4J;
       c4G4K: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4G4J: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableBool4_entry() //  [R2, R3]
         { info_tbl: [(c4G4O,
                       label: Foreign.Storable.$fStorableBool4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G4O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4G4P; else goto c4G4Q;
       c4G4P: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4G4Q: // global
           I64[Sp - 16] = block_c4G4q_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4G4W; else goto c4G4r;
       u4G4W: // global
           call _c4G4q(R1) args: 0, res: 0, upd: 0;
       c4G4r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G4q() //  [R1]
         { info_tbl: [(c4G4q,
                       label: block_c4G4q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G4q: // global
           I64[Sp] = block_c4G4v_info;
           _s4FsP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FsP::I64;
           if (R1 & 7 != 0) goto u4G4V; else goto c4G4w;
       u4G4V: // global
           call _c4G4v(R1) args: 0, res: 0, upd: 0;
       c4G4w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G4v() //  [R1]
         { info_tbl: [(c4G4v,
                       label: block_c4G4v_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G4v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4G4U; else goto c4G4T;
       c4G4U: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4G4T: // global
           _s4FsV::I64 = %MO_SS_Conv_W32_W64(I32[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 16] = sat_s4FsX_info;
           I64[Hp] = _s4FsV::I64;
           R1 = Hp - 16;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.874392013 UTC

[section ""data" . Foreign.Storable.$fStorableBool1_closure" {
     Foreign.Storable.$fStorableBool1_closure:
         const Foreign.Storable.$fStorableBool1_info;
 },
 Foreign.Storable.$fStorableBool1_entry() //  [R2, R3]
         { info_tbl: [(c4G54,
                       label: Foreign.Storable.$fStorableBool1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G54: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4G55; else goto c4G56;
       c4G55: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4G56: // global
           I64[Sp - 16] = block_c4G51_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4G5o; else goto c4G52;
       u4G5o: // global
           call _c4G51(R1) args: 0, res: 0, upd: 0;
       c4G52: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G51() //  [R1]
         { info_tbl: [(c4G51,
                       label: block_c4G51_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G51: // global
           I64[Sp] = block_c4G59_info;
           _s4Ft2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Ft2::I64;
           if (R1 & 7 != 0) goto u4G5n; else goto c4G5b;
       u4G5n: // global
           call _c4G59(R1) args: 0, res: 0, upd: 0;
       c4G5b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G59() //  [R1]
         { info_tbl: [(c4G59,
                       label: block_c4G59_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G59: // global
           _s4Ft2::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c4G5h; else goto c4G5l;
       c4G5h: // global
           I32[_s4Ft2::I64] = 0 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4G5l: // global
           I32[_s4Ft2::I64] = 1 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.877179529 UTC

[section ""data" . Foreign.Storable.$fStorableBool3_closure" {
     Foreign.Storable.$fStorableBool3_closure:
         const Foreign.Storable.$fStorableBool3_info;
 },
 Foreign.Storable.$fStorableBool3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4G5w,
                       label: Foreign.Storable.$fStorableBool3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G5w: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4G5A; else goto c4G5B;
       c4G5A: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4G5B: // global
           I64[Sp - 24] = block_c4G5t_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4G5Y; else goto c4G5u;
       u4G5Y: // global
           call _c4G5t(R1) args: 0, res: 0, upd: 0;
       c4G5u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G5t() //  [R1]
         { info_tbl: [(c4G5t,
                       label: block_c4G5t_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G5t: // global
           I64[Sp] = block_c4G5z_info;
           _s4Ftb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Ftb::I64;
           if (R1 & 7 != 0) goto u4G5X; else goto c4G5D;
       u4G5X: // global
           call _c4G5z(R1) args: 0, res: 0, upd: 0;
       c4G5D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G5z() //  [R1]
         { info_tbl: [(c4G5z,
                       label: block_c4G5z_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G5z: // global
           I64[Sp] = block_c4G5H_info;
           _s4Ftd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Ftd::I64;
           if (R1 & 7 != 0) goto u4G5Z; else goto c4G5J;
       u4G5Z: // global
           call _c4G5H(R1) args: 0, res: 0, upd: 0;
       c4G5J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G5H() //  [R1]
         { info_tbl: [(c4G5H,
                       label: block_c4G5H_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G5H: // global
           _s4Ftb::I64 = I64[Sp + 8];
           _s4Ftd::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto c4G5P; else goto c4G5T;
       c4G5P: // global
           I32[_s4Ftb::I64 + _s4Ftd::I64] = 0 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4G5T: // global
           I32[_s4Ftb::I64 + _s4Ftd::I64] = 1 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.879951788 UTC

[section ""data" . Foreign.Storable.$fStorableBool_closure" {
     Foreign.Storable.$fStorableBool_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableBool_$csizeOf_closure+1;
         const Foreign.Storable.$fStorableBool_$csizeOf_closure+1;
         const Foreign.Storable.$fStorableBool6_closure+3;
         const Foreign.Storable.$fStorableBool5_closure+4;
         const Foreign.Storable.$fStorableBool4_closure+3;
         const Foreign.Storable.$fStorableBool3_closure+4;
         const Foreign.Storable.$fStorableBool2_closure+2;
         const Foreign.Storable.$fStorableBool1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.881013823 UTC

[section ""data" . Foreign.Storable.$fStorable()2_closure" {
     Foreign.Storable.$fStorable()2_closure:
         const Foreign.Storable.$fStorable()2_info;
 },
 Foreign.Storable.$fStorable()2_entry() //  []
         { info_tbl: [(c4G64,
                       label: Foreign.Storable.$fStorable()2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G64: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.882358556 UTC

[section ""data" . Foreign.Storable.$fStorable()1_closure" {
     Foreign.Storable.$fStorable()1_closure:
         const Foreign.Storable.$fStorable()1_info;
 },
 Foreign.Storable.$fStorable()1_entry() //  []
         { info_tbl: [(c4G6b,
                       label: Foreign.Storable.$fStorable()1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G6b: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.883423017 UTC

[section ""data" . lvl11_r4Ffl_closure" {
     lvl11_r4Ffl_closure:
         const GHC.Types.I#_con_info;
         const 137;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.884278955 UTC

[section ""data" . lvl12_r4Ffm_closure" {
     lvl12_r4Ffm_closure:
         const GHC.Types.I#_con_info;
         const 31;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.885161817 UTC

[section ""data" . lvl13_r4Ffn_closure" {
     lvl13_r4Ffn_closure:
         const GHC.Types.I#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.886131452 UTC

[section ""data" . lvl14_r4Ffo_closure" {
     lvl14_r4Ffo_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r4Ffb_closure;
         const lvl3_r4Ffc_closure;
         const lvl5_r4Ffe_closure;
         const lvl11_r4Ffl_closure+1;
         const lvl12_r4Ffm_closure+1;
         const lvl11_r4Ffl_closure+1;
         const lvl13_r4Ffn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.887059363 UTC

[section ""data" . lvl15_r4Ffp_closure" {
     lvl15_r4Ffp_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r4Ffa_closure;
         const lvl14_r4Ffo_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.888124573 UTC

[section ""data" . lvl16_r4Ffq_closure" {
     lvl16_r4Ffq_closure:
         const lvl16_r4Ffq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_r4Ffq_entry() //  [R1]
         { info_tbl: [(c4G6k,
                       label: lvl16_r4Ffq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G6k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4G6l; else goto c4G6m;
       c4G6l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4G6m: // global
           (_c4G6h::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4G6h::I64 == 0) goto c4G6j; else goto c4G6i;
       c4G6j: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4G6i: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4G6h::I64;
           R2 = lvl15_r4Ffp_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.891054097 UTC

[section ""data" . Foreign.Storable.$dmpeekElemOff_closure" {
     Foreign.Storable.$dmpeekElemOff_closure:
         const Foreign.Storable.$dmpeekElemOff_info;
         const 0;
 },
 sat_s4Ftw_entry() //  [R1]
         { info_tbl: [(c4G6y,
                       label: sat_s4Ftw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G6y: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c4G6J; else goto c4G6K;
       c4G6J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4G6K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4G6v_info;
           _s4Fto::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s4Fto::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4G6P; else goto c4G6w;
       u4G6P: // global
           call _c4G6v(R1) args: 0, res: 0, upd: 0;
       c4G6w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4G6v() //  [R1]
         { info_tbl: [(c4G6v,
                       label: block_c4G6v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G6v: // global
           I64[Sp] = block_c4G6B_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = lvl16_r4Ffq_closure;
           I64[Sp + 8] = I64[R1 + 7];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c4G6B() //  [R1]
         { info_tbl: [(c4G6B,
                       label: block_c4G6B_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G6B: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4G6O; else goto c4G6N;
       c4G6O: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4G6N: // global
           _s4Ftv::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4Ftv::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$dmpeekElemOff_entry() //  [R2, R3, R4]
         { info_tbl: [(c4G6Q,
                       label: Foreign.Storable.$dmpeekElemOff_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G6Q: // global
           _s4Ftq::P64 = R4;
           _s4Ftp::P64 = R3;
           _s4Fto::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c4G6R; else goto c4G6S;
       c4G6S: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4G6U; else goto c4G6T;
       c4G6U: // global
           HpAlloc = 32;
           goto c4G6R;
       c4G6R: // global
           R4 = _s4Ftq::P64;
           R3 = _s4Ftp::P64;
           R2 = _s4Fto::P64;
           R1 = Foreign.Storable.$dmpeekElemOff_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4G6T: // global
           I64[Hp - 24] = sat_s4Ftw_info;
           P64[Hp - 8] = _s4Fto::P64;
           P64[Hp] = _s4Ftq::P64;
           R2 = _s4Fto::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s4Ftp::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Foreign.Storable.peekByteOff_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.895017458 UTC

[section ""data" . Foreign.Storable.$dmpokeElemOff_closure" {
     Foreign.Storable.$dmpokeElemOff_closure:
         const Foreign.Storable.$dmpokeElemOff_info;
 },
 sat_s4FtG_entry() //  [R1]
         { info_tbl: [(c4G76,
                       label: sat_s4FtG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G76: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c4G7h; else goto c4G7i;
       c4G7h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4G7i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4G73_info;
           _s4Ftx::P64 = P64[R1 + 16];
           _s4FtA::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _s4Ftx::P64;
           P64[Sp - 24] = _s4FtA::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u4G7n; else goto c4G74;
       u4G7n: // global
           call _c4G73(R1) args: 0, res: 0, upd: 0;
       c4G74: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4G73() //  [R1]
         { info_tbl: [(c4G73,
                       label: block_c4G73_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G73: // global
           _s4Ftx::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4G79_info;
           R2 = _s4Ftx::P64;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = P64[Sp + 16];
           I64[Sp + 16] = I64[R1 + 7];
           Sp = Sp - 8;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c4G79() //  [R1]
         { info_tbl: [(c4G79,
                       label: block_c4G79_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G79: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4G7m; else goto c4G7l;
       c4G7m: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4G7l: // global
           _s4FtF::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4FtF::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$dmpokeElemOff_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c4G7o,
                       label: Foreign.Storable.$dmpokeElemOff_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G7o: // global
           _s4FtA::P64 = R5;
           _s4Ftz::P64 = R4;
           _s4Fty::P64 = R3;
           _s4Ftx::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto c4G7p; else goto c4G7q;
       c4G7q: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4G7s; else goto c4G7r;
       c4G7s: // global
           HpAlloc = 40;
           goto c4G7p;
       c4G7p: // global
           R5 = _s4FtA::P64;
           R4 = _s4Ftz::P64;
           R3 = _s4Fty::P64;
           R2 = _s4Ftx::P64;
           R1 = Foreign.Storable.$dmpokeElemOff_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4G7r: // global
           I64[Hp - 32] = sat_s4FtG_info;
           P64[Hp - 16] = _s4Ftx::P64;
           P64[Hp - 8] = _s4Ftz::P64;
           P64[Hp] = _s4FtA::P64;
           R2 = _s4Ftx::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _s4Fty::P64;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _s4FtA::P64;
           Sp = Sp - 32;
           call Foreign.Storable.pokeByteOff_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.898522922 UTC

[section ""data" . Foreign.Storable.$fStorable()4_closure" {
     Foreign.Storable.$fStorable()4_closure:
         const Foreign.Storable.$fStorable()4_info;
 },
 Foreign.Storable.$fStorable()4_entry() //  []
         { info_tbl: [(c4G7x,
                       label: Foreign.Storable.$fStorable()4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G7x: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.899853609 UTC

[section ""data" . Foreign.Storable.$fStorable()6_closure" {
     Foreign.Storable.$fStorable()6_closure:
         const Foreign.Storable.$fStorable()6_info;
 },
 Foreign.Storable.$fStorable()6_entry() //  []
         { info_tbl: [(c4G7E,
                       label: Foreign.Storable.$fStorable()6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G7E: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.901142125 UTC

[section ""data" . Foreign.Storable.$fStorable()3_closure" {
     Foreign.Storable.$fStorable()3_closure:
         const Foreign.Storable.$fStorable()3_info;
 },
 Foreign.Storable.$fStorable()3_entry() //  []
         { info_tbl: [(c4G7L,
                       label: Foreign.Storable.$fStorable()3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G7L: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.902484007 UTC

[section ""data" . Foreign.Storable.$fStorable()5_closure" {
     Foreign.Storable.$fStorable()5_closure:
         const Foreign.Storable.$fStorable()5_info;
 },
 Foreign.Storable.$fStorable()5_entry() //  []
         { info_tbl: [(c4G7S,
                       label: Foreign.Storable.$fStorable()5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G7S: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.903645168 UTC

[section ""data" . Foreign.Storable.$fStorable()_closure" {
     Foreign.Storable.$fStorable()_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorable()_$csizeOf_closure+1;
         const Foreign.Storable.$fStorable()_$calignment_closure+1;
         const Foreign.Storable.$fStorable()6_closure+3;
         const Foreign.Storable.$fStorable()5_closure+4;
         const Foreign.Storable.$fStorable()4_closure+3;
         const Foreign.Storable.$fStorable()3_closure+4;
         const Foreign.Storable.$fStorable()2_closure+2;
         const Foreign.Storable.$fStorable()1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.904571001 UTC

[section ""data" . lvl17_r4Ffr_closure" {
     lvl17_r4Ffr_closure:
         const GHC.Types.I#_con_info;
         const 237;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.90581981 UTC

[section ""data" . lvl18_r4Ffs_closure" {
     lvl18_r4Ffs_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r4Ffb_closure;
         const lvl3_r4Ffc_closure;
         const lvl5_r4Ffe_closure;
         const lvl17_r4Ffr_closure+1;
         const lvl12_r4Ffm_closure+1;
         const lvl17_r4Ffr_closure+1;
         const lvl13_r4Ffn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.906761869 UTC

[section ""data" . lvl19_r4Fft_closure" {
     lvl19_r4Fft_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r4Ffa_closure;
         const lvl18_r4Ffs_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.908072663 UTC

[section ""data" . Foreign.Storable.$fStorableRatio6_closure" {
     Foreign.Storable.$fStorableRatio6_closure:
         const Foreign.Storable.$fStorableRatio6_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Storable.$fStorableRatio6_entry() //  [R1]
         { info_tbl: [(c4G81,
                       label: Foreign.Storable.$fStorableRatio6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G81: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4G82; else goto c4G83;
       c4G82: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4G83: // global
           (_c4G7Y::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4G7Y::I64 == 0) goto c4G80; else goto c4G7Z;
       c4G80: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4G7Z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4G7Y::I64;
           R2 = lvl19_r4Fft_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.910630636 UTC

[section ""data" . Foreign.Storable.$fStorableRatio_$csizeOf_closure" {
     Foreign.Storable.$fStorableRatio_$csizeOf_closure:
         const Foreign.Storable.$fStorableRatio_$csizeOf_info;
         const 0;
 },
 lvl20_s4FtX_entry() //  [R1]
         { info_tbl: [(c4G8c,
                       label: lvl20_s4FtX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G8c: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4G8d; else goto c4G8e;
       c4G8d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4G8e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Storable.$fStorableRatio6_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s4Fu2_entry() //  [R1, R2]
         { info_tbl: [(c4G8n,
                       label: sat_s4Fu2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G8n: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4G8u; else goto c4G8v;
       c4G8u: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4G8v: // global
           I64[Sp - 8] = block_c4G8k_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4G8z; else goto c4G8l;
       u4G8z: // global
           call _c4G8k(R1) args: 0, res: 0, upd: 0;
       c4G8l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4G8k() //  [R1]
         { info_tbl: [(c4G8k,
                       label: block_c4G8k_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G8k: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4G8y; else goto c4G8x;
       c4G8y: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4G8x: // global
           _s4Fu1::I64 = I64[R1 + 7] << 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4Fu1::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Storable.$fStorableRatio_$csizeOf_entry() //  [R2, R3]
         { info_tbl: [(c4G8A,
                       label: Foreign.Storable.$fStorableRatio_$csizeOf_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G8A: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4G8E; else goto c4G8D;
       c4G8E: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio_$csizeOf_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4G8D: // global
           I64[Hp - 32] = lvl20_s4FtX_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s4Fu2_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.914588666 UTC

[section ""data" . Foreign.Storable.$fStorableRatio4_closure" {
     Foreign.Storable.$fStorableRatio4_closure:
         const Foreign.Storable.$fStorableRatio4_info;
         const 0;
 },
 sat_s4Fud_entry() //  [R1]
         { info_tbl: [(c4G8Q,
                       label: sat_s4Fud_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G8Q: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4G92; else goto c4G93;
       c4G92: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4G93: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4G8N_info;
           _s4Fu6::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4Fu6::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4G99; else goto c4G8O;
       u4G99: // global
           call _c4G8N(R1) args: 0, res: 0, upd: 0;
       c4G8O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4G8N() //  [R1]
         { info_tbl: [(c4G8N,
                       label: block_c4G8N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G8N: // global
           I64[Sp] = block_c4G8T_info;
           _s4Fu9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fu9::I64;
           if (R1 & 7 != 0) goto u4G98; else goto c4G8U;
       u4G98: // global
           call _c4G8T(R1) args: 0, res: 0, upd: 0;
       c4G8U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4G8T() //  [R1]
         { info_tbl: [(c4G8T,
                       label: block_c4G8T_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G8T: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4G97; else goto c4G96;
       c4G97: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4G96: // global
           _s4Fuc::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fuc::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableRatio4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c4G9a,
                       label: Foreign.Storable.$fStorableRatio4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G9a: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4G9e; else goto c4G9d;
       c4G9e: // global
           HpAlloc = 32;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4G9d: // global
           I64[Hp - 24] = sat_s4Fud_info;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R4 = Hp - 24;
           R3 = R3;
           R2 = R2;
           call Foreign.Storable.$fStorableRatio2_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.918800285 UTC

[section ""data" . Foreign.Storable.$fStorableRatio7_closure" {
     Foreign.Storable.$fStorableRatio7_closure:
         const Foreign.Storable.$fStorableRatio7_info;
         const 0;
 },
 sat_s4Fus_entry() //  [R1]
         { info_tbl: [(c4G9q,
                       label: sat_s4Fus_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G9q: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c4G9M; else goto c4G9N;
       c4G9M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4G9N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4G9n_info;
           _s4Fue::P64 = P64[R1 + 16];
           _s4Fuh::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _s4Fue::P64;
           P64[Sp - 24] = _s4Fuh::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u4G9U; else goto c4G9o;
       u4G9U: // global
           call _c4G9n(R1) args: 0, res: 0, upd: 0;
       c4G9o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4G9n() //  [R1]
         { info_tbl: [(c4G9n,
                       label: block_c4G9n_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G9n: // global
           I64[Sp] = block_c4G9t_info;
           _s4Fuk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fuk::I64;
           if (R1 & 7 != 0) goto u4G9T; else goto c4G9u;
       u4G9T: // global
           call _c4G9t(R1) args: 0, res: 0, upd: 0;
       c4G9u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4G9t() //  [R1]
         { info_tbl: [(c4G9t,
                       label: block_c4G9t_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G9t: // global
           I64[Sp] = block_c4G9y_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Foreign.Storable.$fStorableRatio6_closure;
           I64[Sp + 8] = I64[R1 + 7];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c4G9y() //  [R1]
         { info_tbl: [(c4G9y,
                       label: block_c4G9y_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G9y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4G9S; else goto c4G9R;
       c4G9S: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4G9R: // global
           _s4Fur::I64 = I64[Sp + 16] + I64[Sp + 8] * (I64[R1 + 7] << 1);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fur::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableRatio7_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c4G9V,
                       label: Foreign.Storable.$fStorableRatio7_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4G9V: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4G9Z; else goto c4G9Y;
       c4G9Z: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio7_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4G9Y: // global
           I64[Hp - 32] = sat_s4Fus_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R4 = Hp - 32;
           R3 = R3;
           R2 = R2;
           call Foreign.Storable.$fStorableRatio2_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.923241169 UTC

[section ""data" . Foreign.Storable.$w$cpokeByteOff_closure" {
     Foreign.Storable.$w$cpokeByteOff_closure:
         const Foreign.Storable.$w$cpokeByteOff_info;
 },
 p_s4Fuz_entry() //  [R1]
         { info_tbl: [(c4Gab,
                       label: p_s4Fuz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gab: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4Gan; else goto c4Gao;
       c4Gan: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Gao: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4Ga8_info;
           _s4Fuv::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4Fuv::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4Gau; else goto c4Ga9;
       u4Gau: // global
           call _c4Ga8(R1) args: 0, res: 0, upd: 0;
       c4Ga9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4Ga8() //  [R1]
         { info_tbl: [(c4Ga8,
                       label: block_c4Ga8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ga8: // global
           I64[Sp] = block_c4Gae_info;
           _s4FuB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FuB::I64;
           if (R1 & 7 != 0) goto u4Gat; else goto c4Gaf;
       u4Gat: // global
           call _c4Gae(R1) args: 0, res: 0, upd: 0;
       c4Gaf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4Gae() //  [R1]
         { info_tbl: [(c4Gae,
                       label: block_c4Gae_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gae: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Gas; else goto c4Gar;
       c4Gas: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4Gar: // global
           _s4FuE::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4FuE::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$w$cpokeByteOff_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c4Gax,
                       label: Foreign.Storable.$w$cpokeByteOff_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gax: // global
           _s4Fux::P64 = R6;
           _s4Fuw::P64 = R5;
           _s4Fuv::P64 = R4;
           _s4Fuu::P64 = R3;
           _s4Fut::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto c4Gay; else goto c4Gaz;
       c4Gaz: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4GaB; else goto c4GaA;
       c4GaB: // global
           HpAlloc = 32;
           goto c4Gay;
       c4Gay: // global
           R6 = _s4Fux::P64;
           R5 = _s4Fuw::P64;
           R4 = _s4Fuv::P64;
           R3 = _s4Fuu::P64;
           R2 = _s4Fut::P64;
           R1 = Foreign.Storable.$w$cpokeByteOff_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GaA: // global
           I64[Hp - 24] = p_s4Fuz_info;
           P64[Hp - 8] = _s4Fuu::P64;
           P64[Hp] = _s4Fuv::P64;
           I64[Sp - 32] = block_c4Gav_info;
           R2 = _s4Fut::P64;
           I64[Sp - 56] = stg_ap_ppv_info;
           _c4Ga4::P64 = Hp - 24;
           P64[Sp - 48] = _c4Ga4::P64;
           P64[Sp - 40] = _s4Fuw::P64;
           P64[Sp - 24] = _c4Ga4::P64;
           P64[Sp - 16] = _s4Fut::P64;
           P64[Sp - 8] = _s4Fux::P64;
           Sp = Sp - 56;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c4Gav() //  []
         { info_tbl: [(c4Gav,
                       label: block_c4Gav_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gav: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppv_info;
           P64[Sp + 16] = Foreign.Storable.$fStorable()7_closure+1;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.926299106 UTC

[section ""data" . Foreign.Storable.$fStorableRatio3_closure" {
     Foreign.Storable.$fStorableRatio3_closure:
         const Foreign.Storable.$fStorableRatio3_info;
 },
 Foreign.Storable.$fStorableRatio3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c4GaK,
                       label: Foreign.Storable.$fStorableRatio3_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GaK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4GaL; else goto c4GaM;
       c4GaL: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GaM: // global
           I64[Sp - 32] = block_c4GaH_info;
           R1 = R6;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4GaQ; else goto c4GaI;
       u4GaQ: // global
           call _c4GaH(R1) args: 0, res: 0, upd: 0;
       c4GaI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GaH() //  [R1]
         { info_tbl: [(c4GaH,
                       label: block_c4GaH_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GaH: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Foreign.Storable.$w$cpokeByteOff_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.928227221 UTC

[section ""data" . Foreign.Storable.$w$cpokeElemOff_closure" {
     Foreign.Storable.$w$cpokeElemOff_closure:
         const Foreign.Storable.$w$cpokeElemOff_info;
         const 0;
 },
 p_s4FuX_entry() //  [R1]
         { info_tbl: [(c4Gb2,
                       label: p_s4FuX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gb2: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c4Gbo; else goto c4Gbp;
       c4Gbo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Gbp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4GaZ_info;
           _s4FuR::P64 = P64[R1 + 16];
           _s4FuT::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _s4FuR::P64;
           P64[Sp - 24] = _s4FuT::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u4Gbw; else goto c4Gb0;
       u4Gbw: // global
           call _c4GaZ(R1) args: 0, res: 0, upd: 0;
       c4Gb0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4GaZ() //  [R1]
         { info_tbl: [(c4GaZ,
                       label: block_c4GaZ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GaZ: // global
           I64[Sp] = block_c4Gb5_info;
           _s4FuZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FuZ::I64;
           if (R1 & 7 != 0) goto u4Gbv; else goto c4Gb6;
       u4Gbv: // global
           call _c4Gb5(R1) args: 0, res: 0, upd: 0;
       c4Gb6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4Gb5() //  [R1]
         { info_tbl: [(c4Gb5,
                       label: block_c4Gb5_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gb5: // global
           I64[Sp] = block_c4Gba_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Foreign.Storable.$fStorableRatio6_closure;
           I64[Sp + 8] = I64[R1 + 7];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c4Gba() //  [R1]
         { info_tbl: [(c4Gba,
                       label: block_c4Gba_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gba: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Gbu; else goto c4Gbt;
       c4Gbu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4Gbt: // global
           _s4Fv6::I64 = I64[Sp + 16] + I64[Sp + 8] * (I64[R1 + 7] << 1);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fv6::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$w$cpokeElemOff_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c4Gbz,
                       label: Foreign.Storable.$w$cpokeElemOff_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gbz: // global
           _s4FuV::P64 = R6;
           _s4FuU::P64 = R5;
           _s4FuT::P64 = R4;
           _s4FuS::P64 = R3;
           _s4FuR::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto c4GbA; else goto c4GbB;
       c4GbB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4GbD; else goto c4GbC;
       c4GbD: // global
           HpAlloc = 40;
           goto c4GbA;
       c4GbA: // global
           R6 = _s4FuV::P64;
           R5 = _s4FuU::P64;
           R4 = _s4FuT::P64;
           R3 = _s4FuS::P64;
           R2 = _s4FuR::P64;
           R1 = Foreign.Storable.$w$cpokeElemOff_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GbC: // global
           I64[Hp - 32] = p_s4FuX_info;
           P64[Hp - 16] = _s4FuR::P64;
           P64[Hp - 8] = _s4FuS::P64;
           P64[Hp] = _s4FuT::P64;
           I64[Sp - 32] = block_c4Gbx_info;
           R2 = _s4FuR::P64;
           I64[Sp - 56] = stg_ap_ppv_info;
           _c4GaV::P64 = Hp - 32;
           P64[Sp - 48] = _c4GaV::P64;
           P64[Sp - 40] = _s4FuU::P64;
           P64[Sp - 24] = _c4GaV::P64;
           P64[Sp - 16] = _s4FuR::P64;
           P64[Sp - 8] = _s4FuV::P64;
           Sp = Sp - 56;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c4Gbx() //  []
         { info_tbl: [(c4Gbx,
                       label: block_c4Gbx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gbx: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppv_info;
           P64[Sp + 16] = Foreign.Storable.$fStorable()7_closure+1;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.931445771 UTC

[section ""data" . Foreign.Storable.$fStorableRatio5_closure" {
     Foreign.Storable.$fStorableRatio5_closure:
         const Foreign.Storable.$fStorableRatio5_info;
         const 0;
 },
 Foreign.Storable.$fStorableRatio5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c4GbM,
                       label: Foreign.Storable.$fStorableRatio5_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GbM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4GbN; else goto c4GbO;
       c4GbN: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GbO: // global
           I64[Sp - 32] = block_c4GbJ_info;
           R1 = R6;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4GbS; else goto c4GbK;
       u4GbS: // global
           call _c4GbJ(R1) args: 0, res: 0, upd: 0;
       c4GbK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GbJ() //  [R1]
         { info_tbl: [(c4GbJ,
                       label: block_c4GbJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GbJ: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Foreign.Storable.$w$cpokeElemOff_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.935586033 UTC

[section ""data" . Foreign.Storable.$fStorableRatio_closure" {
     Foreign.Storable.$fStorableRatio_closure:
         const Foreign.Storable.$fStorableRatio_info;
         const 0;
 },
 sat_s4Fvs_entry() //  [R1, R2, R3]
         { info_tbl: [(c4Gc2,
                       label: sat_s4Fvs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gc2: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Foreign.Storable.$fStorableRatio1_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fvr_entry() //  [R1, R2]
         { info_tbl: [(c4Gca,
                       label: sat_s4Fvr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gca: // global
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Foreign.Storable.$fStorableRatio2_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fvq_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c4Gci,
                       label: sat_s4Fvq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gci: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           call Foreign.Storable.$fStorableRatio3_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fvp_entry() //  [R1, R2, R3]
         { info_tbl: [(c4Gcq,
                       label: sat_s4Fvp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gcq: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Foreign.Storable.$fStorableRatio4_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fvo_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c4Gcy,
                       label: sat_s4Fvo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gcy: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           call Foreign.Storable.$fStorableRatio5_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fvn_entry() //  [R1, R2, R3]
         { info_tbl: [(c4GcG,
                       label: sat_s4Fvn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GcG: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Foreign.Storable.$fStorableRatio7_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fvm_entry() //  [R1]
         { info_tbl: [(c4GcN,
                       label: sat_s4Fvm_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GcN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GcO; else goto c4GcP;
       c4GcO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GcP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.$fStorableRatio_$calignment_entry(R3,
                                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4Fvl_entry() //  [R1]
         { info_tbl: [(c4GcU,
                       label: sat_s4Fvl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GcU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GcV; else goto c4GcW;
       c4GcV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GcW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.$fStorableRatio_$csizeOf_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableRatio_entry() //  [R2, R3]
         { info_tbl: [(c4GcY,
                       label: Foreign.Storable.$fStorableRatio_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GcY: // global
           Hp = Hp + 280;
           if (Hp > HpLim) (likely: False) goto c4Gd2; else goto c4Gd1;
       c4Gd2: // global
           HpAlloc = 280;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Gd1: // global
           I64[Hp - 272] = sat_s4Fvs_info;
           P64[Hp - 264] = R2;
           P64[Hp - 256] = R3;
           I64[Hp - 248] = sat_s4Fvr_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           I64[Hp - 224] = sat_s4Fvq_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           I64[Hp - 200] = sat_s4Fvp_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_s4Fvo_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_s4Fvn_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = sat_s4Fvm_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_s4Fvl_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = Foreign.Storable.C:Storable_con_info;
           P64[Hp - 56] = Hp - 96;
           P64[Hp - 48] = Hp - 128;
           P64[Hp - 40] = Hp - 149;
           P64[Hp - 32] = Hp - 172;
           P64[Hp - 24] = Hp - 197;
           P64[Hp - 16] = Hp - 220;
           P64[Hp - 8] = Hp - 246;
           P64[Hp] = Hp - 269;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.941927271 UTC

[section ""data" . Foreign.Storable.$wpokeW64_closure" {
     Foreign.Storable.$wpokeW64_closure:
         const Foreign.Storable.$wpokeW64_info;
 },
 Foreign.Storable.$wpokeW64_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Gdw,
                       label: Foreign.Storable.$wpokeW64_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gdw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4Gdx; else goto u4GdE;
       c4Gdx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$wpokeW64_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u4GdE: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c4Gd4() args: 0, res: 0, upd: 0;
     }
 },
 _c4Gd4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gd4: // global
           _s4Fvx::I64 = I64[Sp + 8];
           if (_s4Fvx::I64 != 0) goto c4Gdu; else goto c4Gdv;
       c4Gdu: // global
           I64[Sp - 8] = block_c4Gd9_info;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fvx::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GdG; else goto c4Gda;
       u4GdG: // global
           call _c4Gd9(R1) args: 0, res: 0, upd: 0;
       c4Gda: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Gdv: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Gd9() //  [R1]
         { info_tbl: [(c4Gd9,
                       label: block_c4Gd9_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gd9: // global
           _s4Fvt::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4Gde_info;
           _s4Fvz::I64 = I64[R1 + 7];
           R1 = _s4Fvt::P64;
           I64[Sp + 16] = _s4Fvz::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4GdH; else goto c4Gdf;
       u4GdH: // global
           call _c4Gde(R1) args: 0, res: 0, upd: 0;
       c4Gdf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gde() //  [R1]
         { info_tbl: [(c4Gde,
                       label: block_c4Gde_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gde: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GdC; else goto c4GdB;
       c4GdC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GdB: // global
           _s4Fvx::I64 = I64[Sp + 16];
           _s4Fvz::I64 = I64[Sp + 8];
           I8[I64[R1 + 7] + (_s4Fvx::I64 + -1)] = %MO_UU_Conv_W64_W8(_s4Fvz::I64);
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4Fvz::I64 >> 8;
           P64[Sp] = R1;
           I64[Sp + 8] = _s4Fvx::I64 - 1;
           P64[Sp + 16] = Hp - 7;
           call _c4Gd4() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.944863259 UTC

[section ""data" . Foreign.Storable.$w$cpoke_closure" {
     Foreign.Storable.$w$cpoke_closure:
         const Foreign.Storable.$w$cpoke_info;
 },
 sat_s4FvT_entry() //  [R1]
         { info_tbl: [(c4GdZ,
                       label: sat_s4FvT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GdZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Ge6; else goto c4Ge7;
       c4Ge6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ge7: // global
           I64[Sp - 8] = block_c4GdW_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Geb; else goto c4GdX;
       u4Geb: // global
           call _c4GdW(R1) args: 0, res: 0, upd: 0;
       c4GdX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GdW() //  [R1]
         { info_tbl: [(c4GdW,
                       label: block_c4GdW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GdW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Gea; else goto c4Ge9;
       c4Gea: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Ge9: // global
           _s4FvS::I64 = I64[R1 + 7] + 8;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4FvS::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Storable.$w$cpoke_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Gec,
                       label: Foreign.Storable.$w$cpoke_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 20} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gec: // global
           _s4FvK::I64 = R4;
           _s4FvJ::I64 = R3;
           _s4FvI::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c4Ged; else goto c4Gee;
       c4Gee: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Geg; else goto c4Gef;
       c4Geg: // global
           HpAlloc = 16;
           goto c4Ged;
       c4Ged: // global
           R4 = _s4FvK::I64;
           R3 = _s4FvJ::I64;
           R2 = _s4FvI::P64;
           R1 = Foreign.Storable.$w$cpoke_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Gef: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4FvJ::I64;
           I64[Sp - 24] = block_c4GdP_info;
           R4 = Hp - 7;
           R3 = 8;
           R2 = _s4FvI::P64;
           P64[Sp - 16] = _s4FvI::P64;
           I64[Sp - 8] = _s4FvK::I64;
           Sp = Sp - 24;
           call Foreign.Storable.$wpokeW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4GdP() //  [R1]
         { info_tbl: [(c4GdP,
                       label: block_c4GdP_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GdP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4Gej; else goto c4Gei;
       c4Gej: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Gei: // global
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = sat_s4FvT_info;
           P64[Hp] = P64[Sp + 8];
           R4 = Hp - 31;
           R3 = 8;
           R2 = Hp - 16;
           Sp = Sp + 24;
           call Foreign.Storable.$wpokeW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.946988306 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint1_closure" {
     Foreign.Storable.$fStorableFingerprint1_closure:
         const Foreign.Storable.$fStorableFingerprint1_info;
 },
 Foreign.Storable.$fStorableFingerprint1_entry() //  [R2, R3]
         { info_tbl: [(c4Ger,
                       label: Foreign.Storable.$fStorableFingerprint1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ger: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Ges; else goto c4Get;
       c4Ges: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Get: // global
           I64[Sp - 16] = block_c4Geo_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Gex; else goto c4Gep;
       u4Gex: // global
           call _c4Geo(R1) args: 0, res: 0, upd: 0;
       c4Gep: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Geo() //  [R1]
         { info_tbl: [(c4Geo,
                       label: block_c4Geo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Geo: // global
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.Storable.$w$cpoke_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.948681155 UTC

[section ""data" . Foreign.Storable.$wpeekW64_closure" {
     Foreign.Storable.$wpeekW64_closure:
         const Foreign.Storable.$wpeekW64_info;
 },
 Foreign.Storable.$wpeekW64_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GeZ,
                       label: Foreign.Storable.$wpeekW64_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 20} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GeZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto u4Gfa; else goto u4Gf9;
       u4Gfa: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c4Gf0() args: 0, res: 0, upd: 0;
       u4Gf9: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c4Gez() args: 0, res: 0, upd: 0;
     }
 },
 _c4Gez() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gez: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Gf3; else goto c4Gf2;
       c4Gf3: // global
           HpAlloc = 16;
           call _c4Gf0() args: 0, res: 0, upd: 0;
       c4Gf2: // global
           _s4Fw5::I64 = I64[Sp + 8];
           if (_s4Fw5::I64 != 0) goto c4GeX; else goto c4GeY;
       c4GeX: // global
           Hp = Hp - 16;
           _s4Fw1::P64 = P64[Sp];
           I64[Sp] = block_c4GeE_info;
           R1 = _s4Fw1::P64;
           I64[Sp + 8] = _s4Fw5::I64;
           if (R1 & 7 != 0) goto u4Gfc; else goto c4GeF;
       u4Gfc: // global
           call _c4GeE(R1) args: 0, res: 0, upd: 0;
       c4GeF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4GeY: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Gf0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gf0: // global
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = Foreign.Storable.$wpeekW64_closure;
           Sp = Sp + 24;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4GeE() //  [R1]
         { info_tbl: [(c4GeE,
                       label: block_c4GeE_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GeE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Gf6; else goto c4Gf5;
       c4Gf6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Gf5: // global
           _s4Fw7::I64 = I64[R1 + 7];
           _s4Fwf::I64 = (I64[Sp + 16] << 8) | %MO_UU_Conv_W8_W64(I8[_s4Fw7::I64]);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fw7::I64 + 1;
           P64[Sp] = Hp - 7;
           I64[Sp + 8] = I64[Sp + 8] - 1;
           I64[Sp + 16] = _s4Fwf::I64;
           call _c4Gez() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.951301316 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint2_closure" {
     Foreign.Storable.$fStorableFingerprint2_closure:
         const Foreign.Storable.$fStorableFingerprint2_info;
 },
 sat_s4Fwp_entry() //  [R1]
         { info_tbl: [(c4Gfu,
                       label: sat_s4Fwp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gfu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4GfB; else goto c4GfC;
       c4GfB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GfC: // global
           I64[Sp - 8] = block_c4Gfr_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GfG; else goto c4Gfs;
       u4GfG: // global
           call _c4Gfr(R1) args: 0, res: 0, upd: 0;
       c4Gfs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gfr() //  [R1]
         { info_tbl: [(c4Gfr,
                       label: block_c4Gfr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gfr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GfF; else goto c4GfE;
       c4GfF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GfE: // global
           _s4Fwo::I64 = I64[R1 + 7] + 8;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fwo::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fwt_entry() //  [R1]
         { info_tbl: [(c4GfN,
                       label: sat_s4Fwt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GfN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GfO; else goto c4GfP;
       c4GfO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GfP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$WFingerprint_entry(R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableFingerprint2_entry() //  [R2]
         { info_tbl: [(c4GfQ,
                       label: Foreign.Storable.$fStorableFingerprint2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GfQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GfR; else goto c4GfS;
       c4GfR: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4GfS: // global
           I64[Sp - 16] = block_c4Gfl_info;
           R4 = 0;
           R3 = 8;
           _s4Fwh::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s4Fwh::P64;
           Sp = Sp - 16;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gfl() //  [R1]
         { info_tbl: [(c4Gfl,
                       label: block_c4Gfl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gfl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4GfV; else goto c4GfU;
       c4GfV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GfU: // global
           I64[Hp - 16] = sat_s4Fwp_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_c4GfH_info;
           R4 = 0;
           R3 = 8;
           R2 = Hp - 16;
           P64[Sp + 8] = R1;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4GfH() //  [R1]
         { info_tbl: [(c4GfH,
                       label: block_c4GfH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GfH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4GfY; else goto c4GfX;
       c4GfY: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GfX: // global
           I64[Hp - 24] = sat_s4Fwt_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.954117705 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint4_closure" {
     Foreign.Storable.$fStorableFingerprint4_closure:
         const Foreign.Storable.$fStorableFingerprint4_info;
 },
 sat_s4FwC_entry() //  [R1]
         { info_tbl: [(c4Gga,
                       label: sat_s4FwC_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gga: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4Ggm; else goto c4Ggn;
       c4Ggm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ggn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4Gg7_info;
           _s4Fwv::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4Fwv::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4Ggt; else goto c4Gg8;
       u4Ggt: // global
           call _c4Gg7(R1) args: 0, res: 0, upd: 0;
       c4Gg8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4Gg7() //  [R1]
         { info_tbl: [(c4Gg7,
                       label: block_c4Gg7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gg7: // global
           I64[Sp] = block_c4Ggd_info;
           _s4Fwy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fwy::I64;
           if (R1 & 7 != 0) goto u4Ggs; else goto c4Gge;
       u4Ggs: // global
           call _c4Ggd(R1) args: 0, res: 0, upd: 0;
       c4Gge: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4Ggd() //  [R1]
         { info_tbl: [(c4Ggd,
                       label: block_c4Ggd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ggd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Ggr; else goto c4Ggq;
       c4Ggr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4Ggq: // global
           _s4FwB::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4FwB::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableFingerprint4_entry() //  [R2, R3]
         { info_tbl: [(c4Ggu,
                       label: Foreign.Storable.$fStorableFingerprint4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ggu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4Ggy; else goto c4Ggx;
       c4Ggy: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Ggx: // global
           I64[Hp - 24] = sat_s4FwC_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           call Foreign.Storable.$fStorableFingerprint2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.956303877 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint6_closure" {
     Foreign.Storable.$fStorableFingerprint6_closure:
         const Foreign.Storable.$fStorableFingerprint6_info;
 },
 sat_s4FwM_entry() //  [R1]
         { info_tbl: [(c4GgK,
                       label: sat_s4FwM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GgK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4GgZ; else goto c4Gh0;
       c4GgZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Gh0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4GgH_info;
           _s4FwE::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4FwE::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4Gh6; else goto c4GgI;
       u4Gh6: // global
           call _c4GgH(R1) args: 0, res: 0, upd: 0;
       c4GgI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4GgH() //  [R1]
         { info_tbl: [(c4GgH,
                       label: block_c4GgH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GgH: // global
           I64[Sp] = block_c4GgN_info;
           _s4FwH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FwH::I64;
           if (R1 & 7 != 0) goto u4Gh5; else goto c4GgO;
       u4Gh5: // global
           call _c4GgN(R1) args: 0, res: 0, upd: 0;
       c4GgO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4GgN() //  [R1]
         { info_tbl: [(c4GgN,
                       label: block_c4GgN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GgN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Gh4; else goto c4Gh3;
       c4Gh4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4Gh3: // global
           _s4FwL::I64 = I64[Sp + 8] + (I64[R1 + 7] << 4);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4FwL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableFingerprint6_entry() //  [R2, R3]
         { info_tbl: [(c4Gh7,
                       label: Foreign.Storable.$fStorableFingerprint6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gh7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4Ghb; else goto c4Gha;
       c4Ghb: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Gha: // global
           I64[Hp - 24] = sat_s4FwM_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           call Foreign.Storable.$fStorableFingerprint2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.958733814 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint3_closure" {
     Foreign.Storable.$fStorableFingerprint3_closure:
         const Foreign.Storable.$fStorableFingerprint3_info;
 },
 sat_s4FwZ_entry() //  [R1]
         { info_tbl: [(c4Ghs,
                       label: sat_s4FwZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ghs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4GhE; else goto c4GhF;
       c4GhE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GhF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4Ghp_info;
           _s4FwO::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4FwO::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4GhL; else goto c4Ghq;
       u4GhL: // global
           call _c4Ghp(R1) args: 0, res: 0, upd: 0;
       c4Ghq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4Ghp() //  [R1]
         { info_tbl: [(c4Ghp,
                       label: block_c4Ghp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ghp: // global
           I64[Sp] = block_c4Ghv_info;
           _s4FwV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FwV::I64;
           if (R1 & 7 != 0) goto u4GhK; else goto c4Ghw;
       u4GhK: // global
           call _c4Ghv(R1) args: 0, res: 0, upd: 0;
       c4Ghw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4Ghv() //  [R1]
         { info_tbl: [(c4Ghv,
                       label: block_c4Ghv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ghv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GhJ; else goto c4GhI;
       c4GhJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4GhI: // global
           _s4FwY::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4FwY::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableFingerprint3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GhM,
                       label: Foreign.Storable.$fStorableFingerprint3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GhM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4GhN; else goto c4GhO;
       c4GhN: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GhO: // global
           I64[Sp - 24] = block_c4Ghg_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4GhS; else goto c4Ghh;
       u4GhS: // global
           call _c4Ghg(R1) args: 0, res: 0, upd: 0;
       c4Ghh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ghg() //  [R1]
         { info_tbl: [(c4Ghg,
                       label: block_c4Ghg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ghg: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4GhR; else goto c4GhQ;
       c4GhR: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GhQ: // global
           _s4FwS::I64 = I64[R1 + 7];
           _s4FwT::I64 = I64[R1 + 15];
           I64[Hp - 24] = sat_s4FwZ_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = _s4FwT::I64;
           R3 = _s4FwS::I64;
           R2 = Hp - 24;
           Sp = Sp + 24;
           call Foreign.Storable.$w$cpoke_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.96153605 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint5_closure" {
     Foreign.Storable.$fStorableFingerprint5_closure:
         const Foreign.Storable.$fStorableFingerprint5_info;
 },
 sat_s4Fxd_entry() //  [R1]
         { info_tbl: [(c4Gi9,
                       label: sat_s4Fxd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gi9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4Gio; else goto c4Gip;
       c4Gio: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Gip: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4Gi6_info;
           _s4Fx1::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4Fx1::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4Giv; else goto c4Gi7;
       u4Giv: // global
           call _c4Gi6(R1) args: 0, res: 0, upd: 0;
       c4Gi7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4Gi6() //  [R1]
         { info_tbl: [(c4Gi6,
                       label: block_c4Gi6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gi6: // global
           I64[Sp] = block_c4Gic_info;
           _s4Fx8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fx8::I64;
           if (R1 & 7 != 0) goto u4Giu; else goto c4Gid;
       u4Giu: // global
           call _c4Gic(R1) args: 0, res: 0, upd: 0;
       c4Gid: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4Gic() //  [R1]
         { info_tbl: [(c4Gic,
                       label: block_c4Gic_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gic: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Git; else goto c4Gis;
       c4Git: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4Gis: // global
           _s4Fxc::I64 = I64[Sp + 8] + (I64[R1 + 7] << 4);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fxc::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableFingerprint5_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Giw,
                       label: Foreign.Storable.$fStorableFingerprint5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Giw: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Gix; else goto c4Giy;
       c4Gix: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Giy: // global
           I64[Sp - 24] = block_c4GhX_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4GiC; else goto c4GhY;
       u4GiC: // global
           call _c4GhX(R1) args: 0, res: 0, upd: 0;
       c4GhY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GhX() //  [R1]
         { info_tbl: [(c4GhX,
                       label: block_c4GhX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GhX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4GiB; else goto c4GiA;
       c4GiB: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GiA: // global
           _s4Fx5::I64 = I64[R1 + 7];
           _s4Fx6::I64 = I64[R1 + 15];
           I64[Hp - 24] = sat_s4Fxd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = _s4Fx6::I64;
           R3 = _s4Fx5::I64;
           R2 = Hp - 24;
           Sp = Sp + 24;
           call Foreign.Storable.$w$cpoke_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.96347583 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint_closure" {
     Foreign.Storable.$fStorableFingerprint_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableFingerprint_$csizeOf_closure+1;
         const Foreign.Storable.$fStorableFingerprint_$calignment_closure+1;
         const Foreign.Storable.$fStorableFingerprint6_closure+3;
         const Foreign.Storable.$fStorableFingerprint5_closure+4;
         const Foreign.Storable.$fStorableFingerprint4_closure+3;
         const Foreign.Storable.$fStorableFingerprint3_closure+4;
         const Foreign.Storable.$fStorableFingerprint2_closure+2;
         const Foreign.Storable.$fStorableFingerprint1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.964491495 UTC

[section ""data" . Foreign.Storable.C:Storable_closure" {
     Foreign.Storable.C:Storable_closure:
         const Foreign.Storable.C:Storable_info;
 },
 Foreign.Storable.C:Storable_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GiE: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Foreign.Storable.C:Storable_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 32, res: 0, upd: 8;
     }
 },
 Foreign.Storable.C:Storable_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c4GiJ,
                       label: Foreign.Storable.C:Storable_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GiJ: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4GiN; else goto c4GiM;
       c4GiN: // global
           HpAlloc = 72;
           R1 = Foreign.Storable.C:Storable_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c4GiM: // global
           I64[Hp - 64] = Foreign.Storable.C:Storable_con_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = R6;
           P64[Hp - 16] = P64[Sp];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 63;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.965792366 UTC

[Foreign.Storable.C:Storable_con_entry() //  [R1]
         { info_tbl: [(c4GiO,
                       label: Foreign.Storable.C:Storable_con_info
                       rep:HeapRep 8 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,70,111,114,101,105,103,110,46,83,116,111,114,97,98,108,101,46,67,58,83,116,111,114,97,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GiO: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.966512288 UTC

[section ""relreadonly" . S4FBN_srt" {
     S4FBN_srt:
         const GHC.Err.undefined_closure;
         const lvl10_r4Ffj_closure;
         const Foreign.Storable.$fStorableRatio8_closure;
         const Foreign.Storable.$fStorableRatio_$calignment_closure;
         const GHC.Real.%_closure;
         const Foreign.Storable.$fStorableRatio2_closure;
         const lvl15_r4Ffp_closure;
         const lvl16_r4Ffq_closure;
         const Foreign.Storable.$dmpeekElemOff_closure;
         const lvl19_r4Fft_closure;
         const Foreign.Storable.$fStorableRatio6_closure;
         const Foreign.Storable.$fStorableRatio_$csizeOf_closure;
         const Foreign.Storable.$fStorableRatio4_closure;
         const Foreign.Storable.$fStorableRatio7_closure;
         const Foreign.Storable.$w$cpokeElemOff_closure;
         const Foreign.Storable.$fStorableRatio5_closure;
         const Foreign.Storable.$fStorableRatio_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.967141879 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:30.967989202 UTC

[section ""data" . Foreign.Storable.sizeOf_closure" {
     Foreign.Storable.sizeOf_closure:
         const Foreign.Storable.sizeOf_info;
 },
 Foreign.Storable.sizeOf_entry() //  [R2]
         { info_tbl: [(c4GiW,
                       label: Foreign.Storable.sizeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GiW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4GiX; else goto c4GiY;
       c4GiX: // global
           R2 = R2;
           R1 = Foreign.Storable.sizeOf_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4GiY: // global
           I64[Sp - 8] = block_c4GiT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Gj2; else goto c4GiU;
       u4Gj2: // global
           call _c4GiT(R1) args: 0, res: 0, upd: 0;
       c4GiU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GiT() //  [R1]
         { info_tbl: [(c4GiT,
                       label: block_c4GiT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GiT: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.969182324 UTC

[section ""data" . Foreign.Storable.alignment_closure" {
     Foreign.Storable.alignment_closure:
         const Foreign.Storable.alignment_info;
 },
 Foreign.Storable.alignment_entry() //  [R2]
         { info_tbl: [(c4Gja,
                       label: Foreign.Storable.alignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gja: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Gjb; else goto c4Gjc;
       c4Gjb: // global
           R2 = R2;
           R1 = Foreign.Storable.alignment_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Gjc: // global
           I64[Sp - 8] = block_c4Gj7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Gjg; else goto c4Gj8;
       u4Gjg: // global
           call _c4Gj7(R1) args: 0, res: 0, upd: 0;
       c4Gj8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gj7() //  [R1]
         { info_tbl: [(c4Gj7,
                       label: block_c4Gj7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gj7: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.970544035 UTC

[section ""data" . Foreign.Storable.peekElemOff_closure" {
     Foreign.Storable.peekElemOff_closure:
         const Foreign.Storable.peekElemOff_info;
 },
 Foreign.Storable.peekElemOff_entry() //  [R2]
         { info_tbl: [(c4Gjo,
                       label: Foreign.Storable.peekElemOff_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gjo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Gjp; else goto c4Gjq;
       c4Gjp: // global
           R2 = R2;
           R1 = Foreign.Storable.peekElemOff_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Gjq: // global
           I64[Sp - 8] = block_c4Gjl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Gju; else goto c4Gjm;
       u4Gju: // global
           call _c4Gjl(R1) args: 0, res: 0, upd: 0;
       c4Gjm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gjl() //  [R1]
         { info_tbl: [(c4Gjl,
                       label: block_c4Gjl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gjl: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.971717126 UTC

[section ""data" . Foreign.Storable.pokeElemOff_closure" {
     Foreign.Storable.pokeElemOff_closure:
         const Foreign.Storable.pokeElemOff_info;
 },
 Foreign.Storable.pokeElemOff_entry() //  [R2]
         { info_tbl: [(c4GjC,
                       label: Foreign.Storable.pokeElemOff_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GjC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4GjD; else goto c4GjE;
       c4GjD: // global
           R2 = R2;
           R1 = Foreign.Storable.pokeElemOff_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4GjE: // global
           I64[Sp - 8] = block_c4Gjz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GjI; else goto c4GjA;
       u4GjI: // global
           call _c4Gjz(R1) args: 0, res: 0, upd: 0;
       c4GjA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gjz() //  [R1]
         { info_tbl: [(c4Gjz,
                       label: block_c4Gjz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gjz: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.972895676 UTC

[section ""data" . Foreign.Storable.peekByteOff_closure" {
     Foreign.Storable.peekByteOff_closure:
         const Foreign.Storable.peekByteOff_info;
 },
 Foreign.Storable.peekByteOff_entry() //  [R2]
         { info_tbl: [(c4GjQ,
                       label: Foreign.Storable.peekByteOff_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GjQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4GjR; else goto c4GjS;
       c4GjR: // global
           R2 = R2;
           R1 = Foreign.Storable.peekByteOff_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4GjS: // global
           I64[Sp - 8] = block_c4GjN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GjW; else goto c4GjO;
       u4GjW: // global
           call _c4GjN(R1) args: 0, res: 0, upd: 0;
       c4GjO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GjN() //  [R1]
         { info_tbl: [(c4GjN,
                       label: block_c4GjN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GjN: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.974103927 UTC

[section ""data" . Foreign.Storable.pokeByteOff_closure" {
     Foreign.Storable.pokeByteOff_closure:
         const Foreign.Storable.pokeByteOff_info;
 },
 Foreign.Storable.pokeByteOff_entry() //  [R2]
         { info_tbl: [(c4Gk4,
                       label: Foreign.Storable.pokeByteOff_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gk4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Gk5; else goto c4Gk6;
       c4Gk5: // global
           R2 = R2;
           R1 = Foreign.Storable.pokeByteOff_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Gk6: // global
           I64[Sp - 8] = block_c4Gk1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Gka; else goto c4Gk2;
       u4Gka: // global
           call _c4Gk1(R1) args: 0, res: 0, upd: 0;
       c4Gk2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gk1() //  [R1]
         { info_tbl: [(c4Gk1,
                       label: block_c4Gk1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gk1: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.975303518 UTC

[section ""data" . Foreign.Storable.peek_closure" {
     Foreign.Storable.peek_closure:
         const Foreign.Storable.peek_info;
 },
 Foreign.Storable.peek_entry() //  [R2]
         { info_tbl: [(c4Gki,
                       label: Foreign.Storable.peek_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gki: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Gkj; else goto c4Gkk;
       c4Gkj: // global
           R2 = R2;
           R1 = Foreign.Storable.peek_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Gkk: // global
           I64[Sp - 8] = block_c4Gkf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Gko; else goto c4Gkg;
       u4Gko: // global
           call _c4Gkf(R1) args: 0, res: 0, upd: 0;
       c4Gkg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gkf() //  [R1]
         { info_tbl: [(c4Gkf,
                       label: block_c4Gkf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gkf: // global
           R1 = P64[R1 + 55];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.97647846 UTC

[section ""data" . Foreign.Storable.poke_closure" {
     Foreign.Storable.poke_closure:
         const Foreign.Storable.poke_info;
 },
 Foreign.Storable.poke_entry() //  [R2]
         { info_tbl: [(c4Gkw,
                       label: Foreign.Storable.poke_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gkw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Gkx; else goto c4Gky;
       c4Gkx: // global
           R2 = R2;
           R1 = Foreign.Storable.poke_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Gky: // global
           I64[Sp - 8] = block_c4Gkt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GkC; else goto c4Gku;
       u4GkC: // global
           call _c4Gkt(R1) args: 0, res: 0, upd: 0;
       c4Gku: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gkt() //  [R1]
         { info_tbl: [(c4Gkt,
                       label: block_c4Gkt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gkt: // global
           R1 = P64[R1 + 63];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.977478688 UTC

[section ""data" . Foreign.Storable.$fStorable()7_closure" {
     Foreign.Storable.$fStorable()7_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.978157384 UTC

[section ""data" . Foreign.Storable.$fStorable()_$calignment_closure" {
     Foreign.Storable.$fStorable()_$calignment_closure:
         const Foreign.Storable.$fStorable()_$calignment_info;
 },
 Foreign.Storable.$fStorable()_$calignment_entry() //  []
         { info_tbl: [(c4GkH,
                       label: Foreign.Storable.$fStorable()_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GkH: // global
           R1 = Foreign.Storable.$fStorable()7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.978886784 UTC

[section ""data" . Foreign.Storable.$fStorable()8_closure" {
     Foreign.Storable.$fStorable()8_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.979537643 UTC

[section ""data" . Foreign.Storable.$fStorable()_$csizeOf_closure" {
     Foreign.Storable.$fStorable()_$csizeOf_closure:
         const Foreign.Storable.$fStorable()_$csizeOf_info;
 },
 Foreign.Storable.$fStorable()_$csizeOf_entry() //  []
         { info_tbl: [(c4GkO,
                       label: Foreign.Storable.$fStorable()_$csizeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GkO: // global
           R1 = Foreign.Storable.$fStorable()8_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.980317315 UTC

[section ""data" . Foreign.Storable.$fStorableBool7_closure" {
     Foreign.Storable.$fStorableBool7_closure:
         const GHC.Types.I#_con_info;
         const 4;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.982584619 UTC

[section ""data" . Foreign.Storable.$fStorableChar_$calignment_closure" {
     Foreign.Storable.$fStorableChar_$calignment_closure:
         const Foreign.Storable.$fStorableChar_$calignment_info;
 },
 Foreign.Storable.$fStorableChar_$calignment_entry() //  []
         { info_tbl: [(c4GkV,
                       label: Foreign.Storable.$fStorableChar_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GkV: // global
           R1 = Foreign.Storable.$fStorableBool7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.983448652 UTC

[section ""data" . Foreign.Storable.$fStorableDouble5_closure" {
     Foreign.Storable.$fStorableDouble5_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.984181498 UTC

[section ""data" . Foreign.Storable.$fStorableInt_$calignment_closure" {
     Foreign.Storable.$fStorableInt_$calignment_closure:
         const Foreign.Storable.$fStorableInt_$calignment_info;
 },
 Foreign.Storable.$fStorableInt_$calignment_entry() //  []
         { info_tbl: [(c4Gl2,
                       label: Foreign.Storable.$fStorableInt_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gl2: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.984999866 UTC

[section ""data" . Foreign.Storable.$fStorableWord_$calignment_closure" {
     Foreign.Storable.$fStorableWord_$calignment_closure:
         const Foreign.Storable.$fStorableWord_$calignment_info;
 },
 Foreign.Storable.$fStorableWord_$calignment_entry() //  []
         { info_tbl: [(c4Gl9,
                       label: Foreign.Storable.$fStorableWord_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gl9: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.986037518 UTC

[section ""data" . Foreign.Storable.$fStorablePtr_$calignment_closure" {
     Foreign.Storable.$fStorablePtr_$calignment_closure:
         const Foreign.Storable.$fStorablePtr_$calignment_info;
 },
 Foreign.Storable.$fStorablePtr_$calignment_entry() //  []
         { info_tbl: [(c4Glg,
                       label: Foreign.Storable.$fStorablePtr_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Glg: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.986864956 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr_$calignment_closure" {
     Foreign.Storable.$fStorableFunPtr_$calignment_closure:
         const Foreign.Storable.$fStorableFunPtr_$calignment_info;
 },
 Foreign.Storable.$fStorableFunPtr_$calignment_entry() //  []
         { info_tbl: [(c4Gln,
                       label: Foreign.Storable.$fStorableFunPtr_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gln: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.987702806 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr_$calignment_closure" {
     Foreign.Storable.$fStorableStablePtr_$calignment_closure:
         const Foreign.Storable.$fStorableStablePtr_$calignment_info;
 },
 Foreign.Storable.$fStorableStablePtr_$calignment_entry() //  []
         { info_tbl: [(c4Glu,
                       label: Foreign.Storable.$fStorableStablePtr_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Glu: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.988497585 UTC

[section ""data" . Foreign.Storable.$fStorableFloat_$calignment_closure" {
     Foreign.Storable.$fStorableFloat_$calignment_closure:
         const Foreign.Storable.$fStorableFloat_$calignment_info;
 },
 Foreign.Storable.$fStorableFloat_$calignment_entry() //  []
         { info_tbl: [(c4GlB,
                       label: Foreign.Storable.$fStorableFloat_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GlB: // global
           R1 = Foreign.Storable.$fStorableBool7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.989363271 UTC

[section ""data" . Foreign.Storable.$fStorableDouble_$calignment_closure" {
     Foreign.Storable.$fStorableDouble_$calignment_closure:
         const Foreign.Storable.$fStorableDouble_$calignment_info;
 },
 Foreign.Storable.$fStorableDouble_$calignment_entry() //  []
         { info_tbl: [(c4GlI,
                       label: Foreign.Storable.$fStorableDouble_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GlI: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.990177846 UTC

[section ""data" . Foreign.Storable.$fStorableWord8_$calignment_closure" {
     Foreign.Storable.$fStorableWord8_$calignment_closure:
         const Foreign.Storable.$fStorableWord8_$calignment_info;
 },
 Foreign.Storable.$fStorableWord8_$calignment_entry() //  []
         { info_tbl: [(c4GlP,
                       label: Foreign.Storable.$fStorableWord8_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GlP: // global
           R1 = Foreign.Storable.$fStorable()7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.990892427 UTC

[section ""data" . Foreign.Storable.$fStorableInt10_closure" {
     Foreign.Storable.$fStorableInt10_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.991596495 UTC

[section ""data" . Foreign.Storable.$fStorableWord16_$calignment_closure" {
     Foreign.Storable.$fStorableWord16_$calignment_closure:
         const Foreign.Storable.$fStorableWord16_$calignment_info;
 },
 Foreign.Storable.$fStorableWord16_$calignment_entry() //  []
         { info_tbl: [(c4GlW,
                       label: Foreign.Storable.$fStorableWord16_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GlW: // global
           R1 = Foreign.Storable.$fStorableInt10_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.992430738 UTC

[section ""data" . Foreign.Storable.$fStorableWord32_$calignment_closure" {
     Foreign.Storable.$fStorableWord32_$calignment_closure:
         const Foreign.Storable.$fStorableWord32_$calignment_info;
 },
 Foreign.Storable.$fStorableWord32_$calignment_entry() //  []
         { info_tbl: [(c4Gm3,
                       label: Foreign.Storable.$fStorableWord32_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gm3: // global
           R1 = Foreign.Storable.$fStorableBool7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.993233446 UTC

[section ""data" . Foreign.Storable.$fStorableWord64_$calignment_closure" {
     Foreign.Storable.$fStorableWord64_$calignment_closure:
         const Foreign.Storable.$fStorableWord64_$calignment_info;
 },
 Foreign.Storable.$fStorableWord64_$calignment_entry() //  []
         { info_tbl: [(c4Gma,
                       label: Foreign.Storable.$fStorableWord64_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gma: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.994051209 UTC

[section ""data" . Foreign.Storable.$fStorableInt8_$calignment_closure" {
     Foreign.Storable.$fStorableInt8_$calignment_closure:
         const Foreign.Storable.$fStorableInt8_$calignment_info;
 },
 Foreign.Storable.$fStorableInt8_$calignment_entry() //  []
         { info_tbl: [(c4Gmh,
                       label: Foreign.Storable.$fStorableInt8_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gmh: // global
           R1 = Foreign.Storable.$fStorable()7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.994827526 UTC

[section ""data" . Foreign.Storable.$fStorableInt16_$calignment_closure" {
     Foreign.Storable.$fStorableInt16_$calignment_closure:
         const Foreign.Storable.$fStorableInt16_$calignment_info;
 },
 Foreign.Storable.$fStorableInt16_$calignment_entry() //  []
         { info_tbl: [(c4Gmo,
                       label: Foreign.Storable.$fStorableInt16_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gmo: // global
           R1 = Foreign.Storable.$fStorableInt10_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.995617362 UTC

[section ""data" . Foreign.Storable.$fStorableInt32_$calignment_closure" {
     Foreign.Storable.$fStorableInt32_$calignment_closure:
         const Foreign.Storable.$fStorableInt32_$calignment_info;
 },
 Foreign.Storable.$fStorableInt32_$calignment_entry() //  []
         { info_tbl: [(c4Gmv,
                       label: Foreign.Storable.$fStorableInt32_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gmv: // global
           R1 = Foreign.Storable.$fStorableBool7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.996380602 UTC

[section ""data" . Foreign.Storable.$fStorableInt64_$calignment_closure" {
     Foreign.Storable.$fStorableInt64_$calignment_closure:
         const Foreign.Storable.$fStorableInt64_$calignment_info;
 },
 Foreign.Storable.$fStorableInt64_$calignment_entry() //  []
         { info_tbl: [(c4GmC,
                       label: Foreign.Storable.$fStorableInt64_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GmC: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.997089125 UTC

[section ""cstring" . lvl_r4Ff9_bytes" {
     lvl_r4Ff9_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.997925694 UTC

[section ""data" . lvl1_r4Ffa_closure" {
     lvl1_r4Ffa_closure:
         const lvl1_r4Ffa_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r4Ffa_entry() //  [R1]
         { info_tbl: [(c4GmL,
                       label: lvl1_r4Ffa_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GmL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GmM; else goto c4GmN;
       c4GmM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GmN: // global
           (_c4GmI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4GmI::I64 == 0) goto c4GmK; else goto c4GmJ;
       c4GmK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4GmJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4GmI::I64;
           R2 = lvl_r4Ff9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.998832142 UTC

[section ""cstring" . Foreign.Storable.$trModule4_bytes" {
     Foreign.Storable.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:30.999654696 UTC

[section ""data" . lvl2_r4Ffb_closure" {
     lvl2_r4Ffb_closure:
         const lvl2_r4Ffb_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r4Ffb_entry() //  [R1]
         { info_tbl: [(c4GmU,
                       label: lvl2_r4Ffb_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GmU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GmV; else goto c4GmW;
       c4GmV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GmW: // global
           (_c4GmR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4GmR::I64 == 0) goto c4GmT; else goto c4GmS;
       c4GmT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4GmS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4GmR::I64;
           R2 = Foreign.Storable.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.000519085 UTC

[section ""cstring" . Foreign.Storable.$trModule2_bytes" {
     Foreign.Storable.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,83,116,111,114,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.001927 UTC

[section ""data" . lvl3_r4Ffc_closure" {
     lvl3_r4Ffc_closure:
         const lvl3_r4Ffc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r4Ffc_entry() //  [R1]
         { info_tbl: [(c4Gn3,
                       label: lvl3_r4Ffc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gn3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Gn4; else goto c4Gn5;
       c4Gn4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Gn5: // global
           (_c4Gn0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4Gn0::I64 == 0) goto c4Gn2; else goto c4Gn1;
       c4Gn2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4Gn1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4Gn0::I64;
           R2 = Foreign.Storable.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.002815363 UTC

[section ""cstring" . lvl4_r4Ffd_bytes" {
     lvl4_r4Ffd_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,83,116,111,114,97,98,108,101,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.003604629 UTC

[section ""data" . lvl5_r4Ffe_closure" {
     lvl5_r4Ffe_closure:
         const lvl5_r4Ffe_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r4Ffe_entry() //  [R1]
         { info_tbl: [(c4Gnc,
                       label: lvl5_r4Ffe_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gnc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Gnd; else goto c4Gne;
       c4Gnd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Gne: // global
           (_c4Gn9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4Gn9::I64 == 0) goto c4Gnb; else goto c4Gna;
       c4Gnb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4Gna: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4Gn9::I64;
           R2 = lvl4_r4Ffd_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.004463946 UTC

[section ""data" . lvl6_r4Fff_closure" {
     lvl6_r4Fff_closure:
         const GHC.Types.I#_con_info;
         const 238;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.004999209 UTC

[section ""data" . lvl7_r4Ffg_closure" {
     lvl7_r4Ffg_closure:
         const GHC.Types.I#_con_info;
         const 30;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.005596144 UTC

[section ""data" . lvl8_r4Ffh_closure" {
     lvl8_r4Ffh_closure:
         const GHC.Types.I#_con_info;
         const 39;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.00614304 UTC

[section ""data" . lvl9_r4Ffi_closure" {
     lvl9_r4Ffi_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r4Ffb_closure;
         const lvl3_r4Ffc_closure;
         const lvl5_r4Ffe_closure;
         const lvl6_r4Fff_closure+1;
         const lvl7_r4Ffg_closure+1;
         const lvl6_r4Fff_closure+1;
         const lvl8_r4Ffh_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.006729992 UTC

[section ""data" . lvl10_r4Ffj_closure" {
     lvl10_r4Ffj_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r4Ffa_closure;
         const lvl9_r4Ffi_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.007553745 UTC

[section ""data" . Foreign.Storable.$fStorableRatio8_closure" {
     Foreign.Storable.$fStorableRatio8_closure:
         const Foreign.Storable.$fStorableRatio8_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Storable.$fStorableRatio8_entry() //  [R1]
         { info_tbl: [(c4Gnl,
                       label: Foreign.Storable.$fStorableRatio8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gnl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Gnm; else goto c4Gnn;
       c4Gnm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Gnn: // global
           (_c4Gni::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4Gni::I64 == 0) goto c4Gnk; else goto c4Gnj;
       c4Gnk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4Gnj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4Gni::I64;
           R2 = lvl10_r4Ffj_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.008944103 UTC

[section ""data" . Foreign.Storable.$fStorableRatio_$calignment_closure" {
     Foreign.Storable.$fStorableRatio_$calignment_closure:
         const Foreign.Storable.$fStorableRatio_$calignment_info;
         const 0;
 },
 lvl20_s4Fh7_entry() //  [R1]
         { info_tbl: [(c4Gnw,
                       label: lvl20_s4Fh7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gnw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4Gnx; else goto c4Gny;
       c4Gnx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Gny: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Storable.$fStorableRatio8_closure;
           Sp = Sp - 32;
           call Foreign.Storable.alignment_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s4Fh9_entry() //  [R1]
         { info_tbl: [(c4GnE,
                       label: sat_s4Fh9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GnE: // global
           R1 = P64[R1 + 7] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Storable.$fStorableRatio_$calignment_entry() //  [R2, R3]
         { info_tbl: [(c4GnH,
                       label: Foreign.Storable.$fStorableRatio_$calignment_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GnH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4GnL; else goto c4GnK;
       c4GnL: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio_$calignment_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GnK: // global
           I64[Hp - 32] = lvl20_s4Fh7_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s4Fh9_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.0104054 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint_$calignment_closure" {
     Foreign.Storable.$fStorableFingerprint_$calignment_closure:
         const Foreign.Storable.$fStorableFingerprint_$calignment_info;
 },
 Foreign.Storable.$fStorableFingerprint_$calignment_entry() //  []
         { info_tbl: [(c4GnQ,
                       label: Foreign.Storable.$fStorableFingerprint_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GnQ: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.01110159 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint7_closure" {
     Foreign.Storable.$fStorableFingerprint7_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.011738896 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint_$csizeOf_closure" {
     Foreign.Storable.$fStorableFingerprint_$csizeOf_closure:
         const Foreign.Storable.$fStorableFingerprint_$csizeOf_info;
 },
 Foreign.Storable.$fStorableFingerprint_$csizeOf_entry() //  []
         { info_tbl: [(c4GnX,
                       label: Foreign.Storable.$fStorableFingerprint_$csizeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GnX: // global
           R1 = Foreign.Storable.$fStorableFingerprint7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.012568364 UTC

[section ""data" . Foreign.Storable.$dmpoke_closure" {
     Foreign.Storable.$dmpoke_closure:
         const Foreign.Storable.$dmpoke_info;
 },
 Foreign.Storable.$dmpoke_entry() //  [R2, R3]
         { info_tbl: [(c4Go4,
                       label: Foreign.Storable.$dmpoke_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Go4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Go5; else goto c4Go6;
       c4Go5: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$dmpoke_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Go6: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = Foreign.Storable.$fStorable()8_closure+1;
           Sp = Sp - 24;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.013607478 UTC

[section ""data" . Foreign.Storable.$dmpeek_closure" {
     Foreign.Storable.$dmpeek_closure:
         const Foreign.Storable.$dmpeek_info;
 },
 Foreign.Storable.$dmpeek_entry() //  [R2, R3]
         { info_tbl: [(c4Gob,
                       label: Foreign.Storable.$dmpeek_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gob: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Goc; else goto c4God;
       c4Goc: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$dmpeek_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4God: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = Foreign.Storable.$fStorable()8_closure+1;
           Sp = Sp - 24;
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.015080053 UTC

[section ""data" . Foreign.Storable.$dmpokeByteOff_closure" {
     Foreign.Storable.$dmpokeByteOff_closure:
         const Foreign.Storable.$dmpokeByteOff_info;
 },
 sat_s4Fho_entry() //  [R1]
         { info_tbl: [(c4Gop,
                       label: sat_s4Fho_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gop: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4GoB; else goto c4GoC;
       c4GoB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GoC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4Gom_info;
           _s4Fhi::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4Fhi::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4GoI; else goto c4Gon;
       u4GoI: // global
           call _c4Gom(R1) args: 0, res: 0, upd: 0;
       c4Gon: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4Gom() //  [R1]
         { info_tbl: [(c4Gom,
                       label: block_c4Gom_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gom: // global
           I64[Sp] = block_c4Gos_info;
           _s4Fhk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fhk::I64;
           if (R1 & 7 != 0) goto u4GoH; else goto c4Got;
       u4GoH: // global
           call _c4Gos(R1) args: 0, res: 0, upd: 0;
       c4Got: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4Gos() //  [R1]
         { info_tbl: [(c4Gos,
                       label: block_c4Gos_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gos: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GoG; else goto c4GoF;
       c4GoG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4GoF: // global
           _s4Fhn::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fhn::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$dmpokeByteOff_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GoJ,
                       label: Foreign.Storable.$dmpokeByteOff_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GoJ: // global
           _s4Fhi::P64 = R4;
           _s4Fhh::P64 = R3;
           _s4Fhg::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c4GoK; else goto c4GoL;
       c4GoL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4GoN; else goto c4GoM;
       c4GoN: // global
           HpAlloc = 32;
           goto c4GoK;
       c4GoK: // global
           R4 = _s4Fhi::P64;
           R3 = _s4Fhh::P64;
           R2 = _s4Fhg::P64;
           R1 = Foreign.Storable.$dmpokeByteOff_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GoM: // global
           I64[Hp - 24] = sat_s4Fho_info;
           P64[Hp - 8] = _s4Fhh::P64;
           P64[Hp] = _s4Fhi::P64;
           R2 = _s4Fhg::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call Foreign.Storable.poke_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.017498066 UTC

[section ""data" . Foreign.Storable.$dmpeekByteOff_closure" {
     Foreign.Storable.$dmpeekByteOff_closure:
         const Foreign.Storable.$dmpeekByteOff_info;
 },
 sat_s4Fhx_entry() //  [R1]
         { info_tbl: [(c4GoZ,
                       label: sat_s4Fhx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GoZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4Gpb; else goto c4Gpc;
       c4Gpb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Gpc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4GoW_info;
           _s4Fhr::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4Fhr::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4Gpi; else goto c4GoX;
       u4Gpi: // global
           call _c4GoW(R1) args: 0, res: 0, upd: 0;
       c4GoX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4GoW() //  [R1]
         { info_tbl: [(c4GoW,
                       label: block_c4GoW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GoW: // global
           I64[Sp] = block_c4Gp2_info;
           _s4Fht::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fht::I64;
           if (R1 & 7 != 0) goto u4Gph; else goto c4Gp3;
       u4Gph: // global
           call _c4Gp2(R1) args: 0, res: 0, upd: 0;
       c4Gp3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4Gp2() //  [R1]
         { info_tbl: [(c4Gp2,
                       label: block_c4Gp2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gp2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Gpg; else goto c4Gpf;
       c4Gpg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4Gpf: // global
           _s4Fhw::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fhw::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$dmpeekByteOff_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Gpj,
                       label: Foreign.Storable.$dmpeekByteOff_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gpj: // global
           _s4Fhr::P64 = R4;
           _s4Fhq::P64 = R3;
           _s4Fhp::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c4Gpk; else goto c4Gpl;
       c4Gpl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4Gpn; else goto c4Gpm;
       c4Gpn: // global
           HpAlloc = 32;
           goto c4Gpk;
       c4Gpk: // global
           R4 = _s4Fhr::P64;
           R3 = _s4Fhq::P64;
           R2 = _s4Fhp::P64;
           R1 = Foreign.Storable.$dmpeekByteOff_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Gpm: // global
           I64[Hp - 24] = sat_s4Fhx_info;
           P64[Hp - 8] = _s4Fhq::P64;
           P64[Hp] = _s4Fhr::P64;
           R2 = _s4Fhp::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.01948225 UTC

[section ""data" . Foreign.Storable.$fStorableInt17_closure" {
     Foreign.Storable.$fStorableInt17_closure:
         const Foreign.Storable.$fStorableInt17_info;
 },
 Foreign.Storable.$fStorableInt17_entry() //  [R2]
         { info_tbl: [(c4Gpv,
                       label: Foreign.Storable.$fStorableInt17_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gpv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Gpz; else goto c4GpA;
       c4Gpz: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt17_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4GpA: // global
           I64[Sp - 8] = block_c4Gps_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GpE; else goto c4Gpt;
       u4GpE: // global
           call _c4Gps(R1) args: 0, res: 0, upd: 0;
       c4Gpt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gps() //  [R1]
         { info_tbl: [(c4Gps,
                       label: block_c4Gps_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gps: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GpD; else goto c4GpC;
       c4GpD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GpC: // global
           _s4FhE::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4FhE::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.020946411 UTC

[section ""data" . Foreign.Storable.$fStorableInt19_closure" {
     Foreign.Storable.$fStorableInt19_closure:
         const Foreign.Storable.$fStorableInt19_info;
 },
 Foreign.Storable.$fStorableInt19_entry() //  [R2, R3]
         { info_tbl: [(c4GpM,
                       label: Foreign.Storable.$fStorableInt19_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GpM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GpY; else goto c4GpZ;
       c4GpY: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt19_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GpZ: // global
           I64[Sp - 16] = block_c4GpJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Gq5; else goto c4GpK;
       u4Gq5: // global
           call _c4GpJ(R1) args: 0, res: 0, upd: 0;
       c4GpK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GpJ() //  [R1]
         { info_tbl: [(c4GpJ,
                       label: block_c4GpJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GpJ: // global
           I64[Sp] = block_c4GpP_info;
           _s4FhK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FhK::I64;
           if (R1 & 7 != 0) goto u4Gq4; else goto c4GpQ;
       u4Gq4: // global
           call _c4GpP(R1) args: 0, res: 0, upd: 0;
       c4GpQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GpP() //  [R1]
         { info_tbl: [(c4GpP,
                       label: block_c4GpP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GpP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Gq3; else goto c4Gq2;
       c4Gq3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Gq2: // global
           _s4FhQ::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4FhQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.023927623 UTC

[section ""data" . Foreign.Storable.$fStorableInt15_closure" {
     Foreign.Storable.$fStorableInt15_closure:
         const Foreign.Storable.$fStorableInt15_info;
 },
 Foreign.Storable.$fStorableInt15_entry() //  [R2, R3]
         { info_tbl: [(c4Gqd,
                       label: Foreign.Storable.$fStorableInt15_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gqd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Gqh; else goto c4Gqi;
       c4Gqh: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt15_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Gqi: // global
           I64[Sp - 16] = block_c4Gqa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Gqq; else goto c4Gqb;
       u4Gqq: // global
           call _c4Gqa(R1) args: 0, res: 0, upd: 0;
       c4Gqb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gqa() //  [R1]
         { info_tbl: [(c4Gqa,
                       label: block_c4Gqa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gqa: // global
           I64[Sp] = block_c4Gqg_info;
           _s4FhW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FhW::I64;
           if (R1 & 7 != 0) goto u4Gqp; else goto c4Gqk;
       u4Gqp: // global
           call _c4Gqg(R1) args: 0, res: 0, upd: 0;
       c4Gqk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gqg() //  [R1]
         { info_tbl: [(c4Gqg,
                       label: block_c4Gqg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gqg: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.026174464 UTC

[section ""data" . Foreign.Storable.$fStorableInt18_closure" {
     Foreign.Storable.$fStorableInt18_closure:
         const Foreign.Storable.$fStorableInt18_info;
 },
 Foreign.Storable.$fStorableInt18_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Gqy,
                       label: Foreign.Storable.$fStorableInt18_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gqy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4GqH; else goto c4GqI;
       c4GqH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt18_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GqI: // global
           I64[Sp - 24] = block_c4Gqv_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4GqS; else goto c4Gqw;
       u4GqS: // global
           call _c4Gqv(R1) args: 0, res: 0, upd: 0;
       c4Gqw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gqv() //  [R1]
         { info_tbl: [(c4Gqv,
                       label: block_c4Gqv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gqv: // global
           I64[Sp] = block_c4GqB_info;
           _s4Fi5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fi5::I64;
           if (R1 & 7 != 0) goto u4GqR; else goto c4GqC;
       u4GqR: // global
           call _c4GqB(R1) args: 0, res: 0, upd: 0;
       c4GqC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GqB() //  [R1]
         { info_tbl: [(c4GqB,
                       label: block_c4GqB_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GqB: // global
           I64[Sp] = block_c4GqG_info;
           _s4Fi7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fi7::I64;
           if (R1 & 7 != 0) goto u4GqT; else goto c4GqL;
       u4GqT: // global
           call _c4GqG(R1) args: 0, res: 0, upd: 0;
       c4GqL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GqG() //  [R1]
         { info_tbl: [(c4GqG,
                       label: block_c4GqG_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GqG: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.027599426 UTC

[section ""data" . Foreign.Storable.$fStorableInt64_closure" {
     Foreign.Storable.$fStorableInt64_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt64_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt64_$calignment_closure+1;
         const GHC.Storable.readInt64OffPtr1_closure+3;
         const GHC.Storable.writeInt64OffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt19_closure+3;
         const Foreign.Storable.$fStorableInt18_closure+4;
         const Foreign.Storable.$fStorableInt17_closure+2;
         const Foreign.Storable.$fStorableInt15_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.028564917 UTC

[section ""data" . Foreign.Storable.$fStorableInt12_closure" {
     Foreign.Storable.$fStorableInt12_closure:
         const Foreign.Storable.$fStorableInt12_info;
 },
 Foreign.Storable.$fStorableInt12_entry() //  [R2]
         { info_tbl: [(c4Gr1,
                       label: Foreign.Storable.$fStorableInt12_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gr1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Gr5; else goto c4Gr6;
       c4Gr5: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt12_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Gr6: // global
           I64[Sp - 8] = block_c4GqY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Gra; else goto c4GqZ;
       u4Gra: // global
           call _c4GqY(R1) args: 0, res: 0, upd: 0;
       c4GqZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GqY() //  [R1]
         { info_tbl: [(c4GqY,
                       label: block_c4GqY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GqY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Gr9; else goto c4Gr8;
       c4Gr9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Gr8: // global
           _s4Fii::I64 = %MO_SS_Conv_W32_W64(I32[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4Fii::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.030096648 UTC

[section ""data" . Foreign.Storable.$fStorableInt14_closure" {
     Foreign.Storable.$fStorableInt14_closure:
         const Foreign.Storable.$fStorableInt14_info;
 },
 Foreign.Storable.$fStorableInt14_entry() //  [R2, R3]
         { info_tbl: [(c4Gri,
                       label: Foreign.Storable.$fStorableInt14_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gri: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Gru; else goto c4Grv;
       c4Gru: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt14_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Grv: // global
           I64[Sp - 16] = block_c4Grf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GrB; else goto c4Grg;
       u4GrB: // global
           call _c4Grf(R1) args: 0, res: 0, upd: 0;
       c4Grg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Grf() //  [R1]
         { info_tbl: [(c4Grf,
                       label: block_c4Grf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Grf: // global
           I64[Sp] = block_c4Grl_info;
           _s4Fio::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fio::I64;
           if (R1 & 7 != 0) goto u4GrA; else goto c4Grm;
       u4GrA: // global
           call _c4Grl(R1) args: 0, res: 0, upd: 0;
       c4Grm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Grl() //  [R1]
         { info_tbl: [(c4Grl,
                       label: block_c4Grl_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Grl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Grz; else goto c4Gry;
       c4Grz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Gry: // global
           _s4Fiu::I64 = %MO_SS_Conv_W32_W64(I32[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4Fiu::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.031719504 UTC

[section ""data" . Foreign.Storable.$fStorableInt11_closure" {
     Foreign.Storable.$fStorableInt11_closure:
         const Foreign.Storable.$fStorableInt11_info;
 },
 Foreign.Storable.$fStorableInt11_entry() //  [R2, R3]
         { info_tbl: [(c4GrJ,
                       label: Foreign.Storable.$fStorableInt11_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GrJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GrN; else goto c4GrO;
       c4GrN: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt11_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GrO: // global
           I64[Sp - 16] = block_c4GrG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GrW; else goto c4GrH;
       u4GrW: // global
           call _c4GrG(R1) args: 0, res: 0, upd: 0;
       c4GrH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GrG() //  [R1]
         { info_tbl: [(c4GrG,
                       label: block_c4GrG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GrG: // global
           I64[Sp] = block_c4GrM_info;
           _s4FiA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FiA::I64;
           if (R1 & 7 != 0) goto u4GrV; else goto c4GrQ;
       u4GrV: // global
           call _c4GrM(R1) args: 0, res: 0, upd: 0;
       c4GrQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GrM() //  [R1]
         { info_tbl: [(c4GrM,
                       label: block_c4GrM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GrM: // global
           I32[I64[Sp + 8]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.033374799 UTC

[section ""data" . Foreign.Storable.$fStorableInt13_closure" {
     Foreign.Storable.$fStorableInt13_closure:
         const Foreign.Storable.$fStorableInt13_info;
 },
 Foreign.Storable.$fStorableInt13_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Gs4,
                       label: Foreign.Storable.$fStorableInt13_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gs4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Gsd; else goto c4Gse;
       c4Gsd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt13_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Gse: // global
           I64[Sp - 24] = block_c4Gs1_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Gso; else goto c4Gs2;
       u4Gso: // global
           call _c4Gs1(R1) args: 0, res: 0, upd: 0;
       c4Gs2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gs1() //  [R1]
         { info_tbl: [(c4Gs1,
                       label: block_c4Gs1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gs1: // global
           I64[Sp] = block_c4Gs7_info;
           _s4FiJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FiJ::I64;
           if (R1 & 7 != 0) goto u4Gsn; else goto c4Gs8;
       u4Gsn: // global
           call _c4Gs7(R1) args: 0, res: 0, upd: 0;
       c4Gs8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gs7() //  [R1]
         { info_tbl: [(c4Gs7,
                       label: block_c4Gs7_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gs7: // global
           I64[Sp] = block_c4Gsc_info;
           _s4FiL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FiL::I64;
           if (R1 & 7 != 0) goto u4Gsp; else goto c4Gsh;
       u4Gsp: // global
           call _c4Gsc(R1) args: 0, res: 0, upd: 0;
       c4Gsh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gsc() //  [R1]
         { info_tbl: [(c4Gsc,
                       label: block_c4Gsc_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gsc: // global
           I32[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.034808263 UTC

[section ""data" . Foreign.Storable.$fStorableInt32_closure" {
     Foreign.Storable.$fStorableInt32_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt32_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt32_$calignment_closure+1;
         const GHC.Storable.readInt32OffPtr1_closure+3;
         const GHC.Storable.writeInt32OffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt14_closure+3;
         const Foreign.Storable.$fStorableInt13_closure+4;
         const Foreign.Storable.$fStorableInt12_closure+2;
         const Foreign.Storable.$fStorableInt11_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.035568394 UTC

[section ""data" . Foreign.Storable.$fStorableBool_$csizeOf_closure" {
     Foreign.Storable.$fStorableBool_$csizeOf_closure:
         const Foreign.Storable.$fStorableBool_$csizeOf_info;
 },
 Foreign.Storable.$fStorableBool_$csizeOf_entry() //  []
         { info_tbl: [(c4Gsu,
                       label: Foreign.Storable.$fStorableBool_$csizeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gsu: // global
           R1 = Foreign.Storable.$fStorableBool7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.036784459 UTC

[section ""data" . Foreign.Storable.$fStorableBool5_closure" {
     Foreign.Storable.$fStorableBool5_closure:
         const Foreign.Storable.$fStorableBool5_info;
 },
 Foreign.Storable.$fStorableBool5_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GsE,
                       label: Foreign.Storable.$fStorableBool5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GsE: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4GsI; else goto c4GsJ;
       c4GsI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GsJ: // global
           I64[Sp - 24] = block_c4GsB_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Gt4; else goto c4GsC;
       u4Gt4: // global
           call _c4GsB(R1) args: 0, res: 0, upd: 0;
       c4GsC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GsB() //  [R1]
         { info_tbl: [(c4GsB,
                       label: block_c4GsB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GsB: // global
           I64[Sp] = block_c4GsH_info;
           _s4FiW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FiW::I64;
           if (R1 & 7 != 0) goto u4Gt3; else goto c4GsL;
       u4Gt3: // global
           call _c4GsH(R1) args: 0, res: 0, upd: 0;
       c4GsL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GsH() //  [R1]
         { info_tbl: [(c4GsH,
                       label: block_c4GsH_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GsH: // global
           I64[Sp] = block_c4GsP_info;
           _s4FiY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FiY::I64;
           if (R1 & 7 != 0) goto u4Gt5; else goto c4GsR;
       u4Gt5: // global
           call _c4GsP(R1) args: 0, res: 0, upd: 0;
       c4GsR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GsP() //  [R1]
         { info_tbl: [(c4GsP,
                       label: block_c4GsP_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GsP: // global
           _s4FiW::I64 = I64[Sp + 8];
           _s4FiY::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto c4GsX; else goto c4Gt1;
       c4GsX: // global
           I32[_s4FiW::I64 + (_s4FiY::I64 << 2)] = 0 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Gt1: // global
           I32[_s4FiW::I64 + (_s4FiY::I64 << 2)] = 1 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.039058322 UTC

[section ""data" . Foreign.Storable.$fStorableInt6_closure" {
     Foreign.Storable.$fStorableInt6_closure:
         const Foreign.Storable.$fStorableInt6_info;
 },
 Foreign.Storable.$fStorableInt6_entry() //  [R2]
         { info_tbl: [(c4Gtd,
                       label: Foreign.Storable.$fStorableInt6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gtd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Gth; else goto c4Gti;
       c4Gth: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Gti: // global
           I64[Sp - 8] = block_c4Gta_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Gtm; else goto c4Gtb;
       u4Gtm: // global
           call _c4Gta(R1) args: 0, res: 0, upd: 0;
       c4Gtb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gta() //  [R1]
         { info_tbl: [(c4Gta,
                       label: block_c4Gta_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gta: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Gtl; else goto c4Gtk;
       c4Gtl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Gtk: // global
           _s4Fj8::I64 = %MO_SS_Conv_W16_W64(I16[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4Fj8::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.040788888 UTC

[section ""data" . Foreign.Storable.$fStorableInt9_closure" {
     Foreign.Storable.$fStorableInt9_closure:
         const Foreign.Storable.$fStorableInt9_info;
 },
 Foreign.Storable.$fStorableInt9_entry() //  [R2, R3]
         { info_tbl: [(c4Gtu,
                       label: Foreign.Storable.$fStorableInt9_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gtu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GtG; else goto c4GtH;
       c4GtG: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt9_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GtH: // global
           I64[Sp - 16] = block_c4Gtr_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GtN; else goto c4Gts;
       u4GtN: // global
           call _c4Gtr(R1) args: 0, res: 0, upd: 0;
       c4Gts: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gtr() //  [R1]
         { info_tbl: [(c4Gtr,
                       label: block_c4Gtr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gtr: // global
           I64[Sp] = block_c4Gtx_info;
           _s4Fje::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fje::I64;
           if (R1 & 7 != 0) goto u4GtM; else goto c4Gty;
       u4GtM: // global
           call _c4Gtx(R1) args: 0, res: 0, upd: 0;
       c4Gty: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gtx() //  [R1]
         { info_tbl: [(c4Gtx,
                       label: block_c4Gtx_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gtx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GtL; else goto c4GtK;
       c4GtL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GtK: // global
           _s4Fjk::I64 = %MO_SS_Conv_W16_W64(I16[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4Fjk::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.042522962 UTC

[section ""data" . Foreign.Storable.$fStorableInt5_closure" {
     Foreign.Storable.$fStorableInt5_closure:
         const Foreign.Storable.$fStorableInt5_info;
 },
 Foreign.Storable.$fStorableInt5_entry() //  [R2, R3]
         { info_tbl: [(c4GtV,
                       label: Foreign.Storable.$fStorableInt5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GtV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GtZ; else goto c4Gu0;
       c4GtZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Gu0: // global
           I64[Sp - 16] = block_c4GtS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Gu8; else goto c4GtT;
       u4Gu8: // global
           call _c4GtS(R1) args: 0, res: 0, upd: 0;
       c4GtT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GtS() //  [R1]
         { info_tbl: [(c4GtS,
                       label: block_c4GtS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GtS: // global
           I64[Sp] = block_c4GtY_info;
           _s4Fjq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fjq::I64;
           if (R1 & 7 != 0) goto u4Gu7; else goto c4Gu2;
       u4Gu7: // global
           call _c4GtY(R1) args: 0, res: 0, upd: 0;
       c4Gu2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GtY() //  [R1]
         { info_tbl: [(c4GtY,
                       label: block_c4GtY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GtY: // global
           I16[I64[Sp + 8]] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.044221898 UTC

[section ""data" . Foreign.Storable.$fStorableInt7_closure" {
     Foreign.Storable.$fStorableInt7_closure:
         const Foreign.Storable.$fStorableInt7_info;
 },
 Foreign.Storable.$fStorableInt7_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Gug,
                       label: Foreign.Storable.$fStorableInt7_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gug: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Gup; else goto c4Guq;
       c4Gup: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt7_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Guq: // global
           I64[Sp - 24] = block_c4Gud_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4GuA; else goto c4Gue;
       u4GuA: // global
           call _c4Gud(R1) args: 0, res: 0, upd: 0;
       c4Gue: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gud() //  [R1]
         { info_tbl: [(c4Gud,
                       label: block_c4Gud_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gud: // global
           I64[Sp] = block_c4Guj_info;
           _s4Fjz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fjz::I64;
           if (R1 & 7 != 0) goto u4Guz; else goto c4Guk;
       u4Guz: // global
           call _c4Guj(R1) args: 0, res: 0, upd: 0;
       c4Guk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Guj() //  [R1]
         { info_tbl: [(c4Guj,
                       label: block_c4Guj_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Guj: // global
           I64[Sp] = block_c4Guo_info;
           _s4FjB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FjB::I64;
           if (R1 & 7 != 0) goto u4GuB; else goto c4Gut;
       u4GuB: // global
           call _c4Guo(R1) args: 0, res: 0, upd: 0;
       c4Gut: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Guo() //  [R1]
         { info_tbl: [(c4Guo,
                       label: block_c4Guo_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Guo: // global
           I16[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.046298868 UTC

[section ""data" . Foreign.Storable.$fStorableInt16_closure" {
     Foreign.Storable.$fStorableInt16_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt16_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt16_$calignment_closure+1;
         const GHC.Storable.readInt16OffPtr1_closure+3;
         const GHC.Storable.writeInt16OffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt9_closure+3;
         const Foreign.Storable.$fStorableInt7_closure+4;
         const Foreign.Storable.$fStorableInt6_closure+2;
         const Foreign.Storable.$fStorableInt5_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.047316622 UTC

[section ""data" . Foreign.Storable.$fStorableInt21_closure" {
     Foreign.Storable.$fStorableInt21_closure:
         const Foreign.Storable.$fStorableInt21_info;
 },
 Foreign.Storable.$fStorableInt21_entry() //  [R2]
         { info_tbl: [(c4GuJ,
                       label: Foreign.Storable.$fStorableInt21_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GuJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4GuN; else goto c4GuO;
       c4GuN: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt21_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4GuO: // global
           I64[Sp - 8] = block_c4GuG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GuS; else goto c4GuH;
       u4GuS: // global
           call _c4GuG(R1) args: 0, res: 0, upd: 0;
       c4GuH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GuG() //  [R1]
         { info_tbl: [(c4GuG,
                       label: block_c4GuG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GuG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GuR; else goto c4GuQ;
       c4GuR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GuQ: // global
           _s4FjM::I64 = %MO_SS_Conv_W8_W64(I8[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4FjM::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.048887752 UTC

[section ""data" . Foreign.Storable.$fStorableInt23_closure" {
     Foreign.Storable.$fStorableInt23_closure:
         const Foreign.Storable.$fStorableInt23_info;
 },
 Foreign.Storable.$fStorableInt23_entry() //  [R2, R3]
         { info_tbl: [(c4Gv0,
                       label: Foreign.Storable.$fStorableInt23_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gv0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Gvc; else goto c4Gvd;
       c4Gvc: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt23_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Gvd: // global
           I64[Sp - 16] = block_c4GuX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Gvj; else goto c4GuY;
       u4Gvj: // global
           call _c4GuX(R1) args: 0, res: 0, upd: 0;
       c4GuY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GuX() //  [R1]
         { info_tbl: [(c4GuX,
                       label: block_c4GuX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GuX: // global
           I64[Sp] = block_c4Gv3_info;
           _s4FjS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FjS::I64;
           if (R1 & 7 != 0) goto u4Gvi; else goto c4Gv4;
       u4Gvi: // global
           call _c4Gv3(R1) args: 0, res: 0, upd: 0;
       c4Gv4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gv3() //  [R1]
         { info_tbl: [(c4Gv3,
                       label: block_c4Gv3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gv3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Gvh; else goto c4Gvg;
       c4Gvh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Gvg: // global
           _s4FjY::I64 = %MO_SS_Conv_W8_W64(I8[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4FjY::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.050576741 UTC

[section ""data" . Foreign.Storable.$fStorableInt20_closure" {
     Foreign.Storable.$fStorableInt20_closure:
         const Foreign.Storable.$fStorableInt20_info;
 },
 Foreign.Storable.$fStorableInt20_entry() //  [R2, R3]
         { info_tbl: [(c4Gvr,
                       label: Foreign.Storable.$fStorableInt20_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gvr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Gvv; else goto c4Gvw;
       c4Gvv: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt20_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Gvw: // global
           I64[Sp - 16] = block_c4Gvo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GvE; else goto c4Gvp;
       u4GvE: // global
           call _c4Gvo(R1) args: 0, res: 0, upd: 0;
       c4Gvp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gvo() //  [R1]
         { info_tbl: [(c4Gvo,
                       label: block_c4Gvo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gvo: // global
           I64[Sp] = block_c4Gvu_info;
           _s4Fk4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fk4::I64;
           if (R1 & 7 != 0) goto u4GvD; else goto c4Gvy;
       u4GvD: // global
           call _c4Gvu(R1) args: 0, res: 0, upd: 0;
       c4Gvy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gvu() //  [R1]
         { info_tbl: [(c4Gvu,
                       label: block_c4Gvu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gvu: // global
           I8[I64[Sp + 8]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.05231183 UTC

[section ""data" . Foreign.Storable.$fStorableInt22_closure" {
     Foreign.Storable.$fStorableInt22_closure:
         const Foreign.Storable.$fStorableInt22_info;
 },
 Foreign.Storable.$fStorableInt22_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GvM,
                       label: Foreign.Storable.$fStorableInt22_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GvM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4GvV; else goto c4GvW;
       c4GvV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt22_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GvW: // global
           I64[Sp - 24] = block_c4GvJ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Gw6; else goto c4GvK;
       u4Gw6: // global
           call _c4GvJ(R1) args: 0, res: 0, upd: 0;
       c4GvK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GvJ() //  [R1]
         { info_tbl: [(c4GvJ,
                       label: block_c4GvJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GvJ: // global
           I64[Sp] = block_c4GvP_info;
           _s4Fkd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fkd::I64;
           if (R1 & 7 != 0) goto u4Gw5; else goto c4GvQ;
       u4Gw5: // global
           call _c4GvP(R1) args: 0, res: 0, upd: 0;
       c4GvQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GvP() //  [R1]
         { info_tbl: [(c4GvP,
                       label: block_c4GvP_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GvP: // global
           I64[Sp] = block_c4GvU_info;
           _s4Fkf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fkf::I64;
           if (R1 & 7 != 0) goto u4Gw7; else goto c4GvZ;
       u4Gw7: // global
           call _c4GvU(R1) args: 0, res: 0, upd: 0;
       c4GvZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GvU() //  [R1]
         { info_tbl: [(c4GvU,
                       label: block_c4GvU_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GvU: // global
           I8[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.054069411 UTC

[section ""data" . Foreign.Storable.$fStorableInt8_closure" {
     Foreign.Storable.$fStorableInt8_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt8_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt8_$calignment_closure+1;
         const GHC.Storable.readInt8OffPtr1_closure+3;
         const GHC.Storable.writeInt8OffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt23_closure+3;
         const Foreign.Storable.$fStorableInt22_closure+4;
         const Foreign.Storable.$fStorableInt21_closure+2;
         const Foreign.Storable.$fStorableInt20_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.055217911 UTC

[section ""data" . Foreign.Storable.$fStorableWord15_closure" {
     Foreign.Storable.$fStorableWord15_closure:
         const Foreign.Storable.$fStorableWord15_info;
 },
 Foreign.Storable.$fStorableWord15_entry() //  [R2]
         { info_tbl: [(c4Gwf,
                       label: Foreign.Storable.$fStorableWord15_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gwf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Gwj; else goto c4Gwk;
       c4Gwj: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord15_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Gwk: // global
           I64[Sp - 8] = block_c4Gwc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Gwo; else goto c4Gwd;
       u4Gwo: // global
           call _c4Gwc(R1) args: 0, res: 0, upd: 0;
       c4Gwd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gwc() //  [R1]
         { info_tbl: [(c4Gwc,
                       label: block_c4Gwc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gwc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Gwn; else goto c4Gwm;
       c4Gwn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Gwm: // global
           _s4Fkq::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4Fkq::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.056953688 UTC

[section ""data" . Foreign.Storable.$fStorableWord18_closure" {
     Foreign.Storable.$fStorableWord18_closure:
         const Foreign.Storable.$fStorableWord18_info;
 },
 Foreign.Storable.$fStorableWord18_entry() //  [R2, R3]
         { info_tbl: [(c4Gww,
                       label: Foreign.Storable.$fStorableWord18_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gww: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GwI; else goto c4GwJ;
       c4GwI: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord18_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GwJ: // global
           I64[Sp - 16] = block_c4Gwt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GwP; else goto c4Gwu;
       u4GwP: // global
           call _c4Gwt(R1) args: 0, res: 0, upd: 0;
       c4Gwu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gwt() //  [R1]
         { info_tbl: [(c4Gwt,
                       label: block_c4Gwt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gwt: // global
           I64[Sp] = block_c4Gwz_info;
           _s4Fkw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fkw::I64;
           if (R1 & 7 != 0) goto u4GwO; else goto c4GwA;
       u4GwO: // global
           call _c4Gwz(R1) args: 0, res: 0, upd: 0;
       c4GwA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gwz() //  [R1]
         { info_tbl: [(c4Gwz,
                       label: block_c4Gwz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gwz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GwN; else goto c4GwM;
       c4GwN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GwM: // global
           _s4FkC::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4FkC::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.058890513 UTC

[section ""data" . Foreign.Storable.$fStorableWord14_closure" {
     Foreign.Storable.$fStorableWord14_closure:
         const Foreign.Storable.$fStorableWord14_info;
 },
 Foreign.Storable.$fStorableWord14_entry() //  [R2, R3]
         { info_tbl: [(c4GwX,
                       label: Foreign.Storable.$fStorableWord14_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GwX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Gx1; else goto c4Gx2;
       c4Gx1: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord14_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Gx2: // global
           I64[Sp - 16] = block_c4GwU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Gxa; else goto c4GwV;
       u4Gxa: // global
           call _c4GwU(R1) args: 0, res: 0, upd: 0;
       c4GwV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GwU() //  [R1]
         { info_tbl: [(c4GwU,
                       label: block_c4GwU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GwU: // global
           I64[Sp] = block_c4Gx0_info;
           _s4FkI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FkI::I64;
           if (R1 & 7 != 0) goto u4Gx9; else goto c4Gx4;
       u4Gx9: // global
           call _c4Gx0(R1) args: 0, res: 0, upd: 0;
       c4Gx4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gx0() //  [R1]
         { info_tbl: [(c4Gx0,
                       label: block_c4Gx0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gx0: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.060791702 UTC

[section ""data" . Foreign.Storable.$fStorableWord17_closure" {
     Foreign.Storable.$fStorableWord17_closure:
         const Foreign.Storable.$fStorableWord17_info;
 },
 Foreign.Storable.$fStorableWord17_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Gxi,
                       label: Foreign.Storable.$fStorableWord17_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gxi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Gxr; else goto c4Gxs;
       c4Gxr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord17_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Gxs: // global
           I64[Sp - 24] = block_c4Gxf_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4GxC; else goto c4Gxg;
       u4GxC: // global
           call _c4Gxf(R1) args: 0, res: 0, upd: 0;
       c4Gxg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gxf() //  [R1]
         { info_tbl: [(c4Gxf,
                       label: block_c4Gxf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gxf: // global
           I64[Sp] = block_c4Gxl_info;
           _s4FkR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FkR::I64;
           if (R1 & 7 != 0) goto u4GxB; else goto c4Gxm;
       u4GxB: // global
           call _c4Gxl(R1) args: 0, res: 0, upd: 0;
       c4Gxm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gxl() //  [R1]
         { info_tbl: [(c4Gxl,
                       label: block_c4Gxl_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gxl: // global
           I64[Sp] = block_c4Gxq_info;
           _s4FkT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FkT::I64;
           if (R1 & 7 != 0) goto u4GxD; else goto c4Gxv;
       u4GxD: // global
           call _c4Gxq(R1) args: 0, res: 0, upd: 0;
       c4Gxv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gxq() //  [R1]
         { info_tbl: [(c4Gxq,
                       label: block_c4Gxq_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gxq: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.062572674 UTC

[section ""data" . Foreign.Storable.$fStorableWord64_closure" {
     Foreign.Storable.$fStorableWord64_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableWord64_$calignment_closure+1;
         const Foreign.Storable.$fStorableWord64_$calignment_closure+1;
         const GHC.Storable.readWord64OffPtr1_closure+3;
         const GHC.Storable.writeWord64OffPtr1_closure+4;
         const Foreign.Storable.$fStorableWord18_closure+3;
         const Foreign.Storable.$fStorableWord17_closure+4;
         const Foreign.Storable.$fStorableWord15_closure+2;
         const Foreign.Storable.$fStorableWord14_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.063716912 UTC

[section ""data" . Foreign.Storable.$fStorableWord11_closure" {
     Foreign.Storable.$fStorableWord11_closure:
         const Foreign.Storable.$fStorableWord11_info;
 },
 Foreign.Storable.$fStorableWord11_entry() //  [R2]
         { info_tbl: [(c4GxL,
                       label: Foreign.Storable.$fStorableWord11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GxL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4GxP; else goto c4GxQ;
       c4GxP: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord11_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4GxQ: // global
           I64[Sp - 8] = block_c4GxI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GxU; else goto c4GxJ;
       u4GxU: // global
           call _c4GxI(R1) args: 0, res: 0, upd: 0;
       c4GxJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GxI() //  [R1]
         { info_tbl: [(c4GxI,
                       label: block_c4GxI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GxI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GxT; else goto c4GxS;
       c4GxT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GxS: // global
           _s4Fl4::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s4Fl4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.065366915 UTC

[section ""data" . Foreign.Storable.$fStorableWord13_closure" {
     Foreign.Storable.$fStorableWord13_closure:
         const Foreign.Storable.$fStorableWord13_info;
 },
 Foreign.Storable.$fStorableWord13_entry() //  [R2, R3]
         { info_tbl: [(c4Gy2,
                       label: Foreign.Storable.$fStorableWord13_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gy2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Gye; else goto c4Gyf;
       c4Gye: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord13_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Gyf: // global
           I64[Sp - 16] = block_c4GxZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Gyl; else goto c4Gy0;
       u4Gyl: // global
           call _c4GxZ(R1) args: 0, res: 0, upd: 0;
       c4Gy0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GxZ() //  [R1]
         { info_tbl: [(c4GxZ,
                       label: block_c4GxZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GxZ: // global
           I64[Sp] = block_c4Gy5_info;
           _s4Fla::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fla::I64;
           if (R1 & 7 != 0) goto u4Gyk; else goto c4Gy6;
       u4Gyk: // global
           call _c4Gy5(R1) args: 0, res: 0, upd: 0;
       c4Gy6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gy5() //  [R1]
         { info_tbl: [(c4Gy5,
                       label: block_c4Gy5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gy5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Gyj; else goto c4Gyi;
       c4Gyj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Gyi: // global
           _s4Flg::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s4Flg::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.067341138 UTC

[section ""data" . Foreign.Storable.$fStorableWord10_closure" {
     Foreign.Storable.$fStorableWord10_closure:
         const Foreign.Storable.$fStorableWord10_info;
 },
 Foreign.Storable.$fStorableWord10_entry() //  [R2, R3]
         { info_tbl: [(c4Gyt,
                       label: Foreign.Storable.$fStorableWord10_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gyt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Gyx; else goto c4Gyy;
       c4Gyx: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord10_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Gyy: // global
           I64[Sp - 16] = block_c4Gyq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GyG; else goto c4Gyr;
       u4GyG: // global
           call _c4Gyq(R1) args: 0, res: 0, upd: 0;
       c4Gyr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gyq() //  [R1]
         { info_tbl: [(c4Gyq,
                       label: block_c4Gyq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gyq: // global
           I64[Sp] = block_c4Gyw_info;
           _s4Flm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Flm::I64;
           if (R1 & 7 != 0) goto u4GyF; else goto c4GyA;
       u4GyF: // global
           call _c4Gyw(R1) args: 0, res: 0, upd: 0;
       c4GyA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gyw() //  [R1]
         { info_tbl: [(c4Gyw,
                       label: block_c4Gyw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gyw: // global
           I32[I64[Sp + 8]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.071743545 UTC

[section ""data" . Foreign.Storable.$fStorableWord12_closure" {
     Foreign.Storable.$fStorableWord12_closure:
         const Foreign.Storable.$fStorableWord12_info;
 },
 Foreign.Storable.$fStorableWord12_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GyO,
                       label: Foreign.Storable.$fStorableWord12_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GyO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4GyX; else goto c4GyY;
       c4GyX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord12_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GyY: // global
           I64[Sp - 24] = block_c4GyL_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Gz8; else goto c4GyM;
       u4Gz8: // global
           call _c4GyL(R1) args: 0, res: 0, upd: 0;
       c4GyM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GyL() //  [R1]
         { info_tbl: [(c4GyL,
                       label: block_c4GyL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GyL: // global
           I64[Sp] = block_c4GyR_info;
           _s4Flv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Flv::I64;
           if (R1 & 7 != 0) goto u4Gz7; else goto c4GyS;
       u4Gz7: // global
           call _c4GyR(R1) args: 0, res: 0, upd: 0;
       c4GyS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GyR() //  [R1]
         { info_tbl: [(c4GyR,
                       label: block_c4GyR_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GyR: // global
           I64[Sp] = block_c4GyW_info;
           _s4Flx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Flx::I64;
           if (R1 & 7 != 0) goto u4Gz9; else goto c4Gz1;
       u4Gz9: // global
           call _c4GyW(R1) args: 0, res: 0, upd: 0;
       c4Gz1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GyW() //  [R1]
         { info_tbl: [(c4GyW,
                       label: block_c4GyW_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GyW: // global
           I32[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.07401945 UTC

[section ""data" . Foreign.Storable.$fStorableWord32_closure" {
     Foreign.Storable.$fStorableWord32_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableWord32_$calignment_closure+1;
         const Foreign.Storable.$fStorableWord32_$calignment_closure+1;
         const GHC.Storable.readWord32OffPtr1_closure+3;
         const GHC.Storable.writeWord32OffPtr1_closure+4;
         const Foreign.Storable.$fStorableWord13_closure+3;
         const Foreign.Storable.$fStorableWord12_closure+4;
         const Foreign.Storable.$fStorableWord11_closure+2;
         const Foreign.Storable.$fStorableWord10_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.075184305 UTC

[section ""data" . Foreign.Storable.$fStorableWord6_closure" {
     Foreign.Storable.$fStorableWord6_closure:
         const Foreign.Storable.$fStorableWord6_info;
 },
 Foreign.Storable.$fStorableWord6_entry() //  [R2]
         { info_tbl: [(c4Gzh,
                       label: Foreign.Storable.$fStorableWord6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gzh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Gzl; else goto c4Gzm;
       c4Gzl: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Gzm: // global
           I64[Sp - 8] = block_c4Gze_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Gzq; else goto c4Gzf;
       u4Gzq: // global
           call _c4Gze(R1) args: 0, res: 0, upd: 0;
       c4Gzf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gze() //  [R1]
         { info_tbl: [(c4Gze,
                       label: block_c4Gze_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gze: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Gzp; else goto c4Gzo;
       c4Gzp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Gzo: // global
           _s4FlI::I64 = %MO_UU_Conv_W16_W64(I16[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s4FlI::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.076908875 UTC

[section ""data" . Foreign.Storable.$fStorableWord9_closure" {
     Foreign.Storable.$fStorableWord9_closure:
         const Foreign.Storable.$fStorableWord9_info;
 },
 Foreign.Storable.$fStorableWord9_entry() //  [R2, R3]
         { info_tbl: [(c4Gzy,
                       label: Foreign.Storable.$fStorableWord9_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gzy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GzK; else goto c4GzL;
       c4GzK: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord9_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GzL: // global
           I64[Sp - 16] = block_c4Gzv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GzR; else goto c4Gzw;
       u4GzR: // global
           call _c4Gzv(R1) args: 0, res: 0, upd: 0;
       c4Gzw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Gzv() //  [R1]
         { info_tbl: [(c4Gzv,
                       label: block_c4Gzv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Gzv: // global
           I64[Sp] = block_c4GzB_info;
           _s4FlO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FlO::I64;
           if (R1 & 7 != 0) goto u4GzQ; else goto c4GzC;
       u4GzQ: // global
           call _c4GzB(R1) args: 0, res: 0, upd: 0;
       c4GzC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GzB() //  [R1]
         { info_tbl: [(c4GzB,
                       label: block_c4GzB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GzB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GzP; else goto c4GzO;
       c4GzP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GzO: // global
           _s4FlU::I64 = %MO_UU_Conv_W16_W64(I16[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s4FlU::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.078627196 UTC

[section ""data" . Foreign.Storable.$fStorableWord5_closure" {
     Foreign.Storable.$fStorableWord5_closure:
         const Foreign.Storable.$fStorableWord5_info;
 },
 Foreign.Storable.$fStorableWord5_entry() //  [R2, R3]
         { info_tbl: [(c4GzZ,
                       label: Foreign.Storable.$fStorableWord5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GzZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GA3; else goto c4GA4;
       c4GA3: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GA4: // global
           I64[Sp - 16] = block_c4GzW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GAc; else goto c4GzX;
       u4GAc: // global
           call _c4GzW(R1) args: 0, res: 0, upd: 0;
       c4GzX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GzW() //  [R1]
         { info_tbl: [(c4GzW,
                       label: block_c4GzW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GzW: // global
           I64[Sp] = block_c4GA2_info;
           _s4Fm0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fm0::I64;
           if (R1 & 7 != 0) goto u4GAb; else goto c4GA6;
       u4GAb: // global
           call _c4GA2(R1) args: 0, res: 0, upd: 0;
       c4GA6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GA2() //  [R1]
         { info_tbl: [(c4GA2,
                       label: block_c4GA2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GA2: // global
           I16[I64[Sp + 8]] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.080243504 UTC

[section ""data" . Foreign.Storable.$fStorableWord7_closure" {
     Foreign.Storable.$fStorableWord7_closure:
         const Foreign.Storable.$fStorableWord7_info;
 },
 Foreign.Storable.$fStorableWord7_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GAk,
                       label: Foreign.Storable.$fStorableWord7_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GAk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4GAt; else goto c4GAu;
       c4GAt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord7_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GAu: // global
           I64[Sp - 24] = block_c4GAh_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4GAE; else goto c4GAi;
       u4GAE: // global
           call _c4GAh(R1) args: 0, res: 0, upd: 0;
       c4GAi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GAh() //  [R1]
         { info_tbl: [(c4GAh,
                       label: block_c4GAh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GAh: // global
           I64[Sp] = block_c4GAn_info;
           _s4Fm9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fm9::I64;
           if (R1 & 7 != 0) goto u4GAD; else goto c4GAo;
       u4GAD: // global
           call _c4GAn(R1) args: 0, res: 0, upd: 0;
       c4GAo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GAn() //  [R1]
         { info_tbl: [(c4GAn,
                       label: block_c4GAn_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GAn: // global
           I64[Sp] = block_c4GAs_info;
           _s4Fmb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fmb::I64;
           if (R1 & 7 != 0) goto u4GAF; else goto c4GAx;
       u4GAF: // global
           call _c4GAs(R1) args: 0, res: 0, upd: 0;
       c4GAx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GAs() //  [R1]
         { info_tbl: [(c4GAs,
                       label: block_c4GAs_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GAs: // global
           I16[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.081734789 UTC

[section ""data" . Foreign.Storable.$fStorableWord16_closure" {
     Foreign.Storable.$fStorableWord16_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableWord16_$calignment_closure+1;
         const Foreign.Storable.$fStorableWord16_$calignment_closure+1;
         const GHC.Storable.readWord16OffPtr1_closure+3;
         const GHC.Storable.writeWord16OffPtr1_closure+4;
         const Foreign.Storable.$fStorableWord9_closure+3;
         const Foreign.Storable.$fStorableWord7_closure+4;
         const Foreign.Storable.$fStorableWord6_closure+2;
         const Foreign.Storable.$fStorableWord5_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.082683726 UTC

[section ""data" . Foreign.Storable.$fStorableDouble2_closure" {
     Foreign.Storable.$fStorableDouble2_closure:
         const Foreign.Storable.$fStorableDouble2_info;
 },
 Foreign.Storable.$fStorableDouble2_entry() //  [R2]
         { info_tbl: [(c4GAN,
                       label: Foreign.Storable.$fStorableDouble2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GAN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4GAR; else goto c4GAS;
       c4GAR: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableDouble2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4GAS: // global
           I64[Sp - 8] = block_c4GAK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GAW; else goto c4GAL;
       u4GAW: // global
           call _c4GAK(R1) args: 0, res: 0, upd: 0;
       c4GAL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GAK() //  [R1]
         { info_tbl: [(c4GAK,
                       label: block_c4GAK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GAK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GAV; else goto c4GAU;
       c4GAV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GAU: // global
           _s4Fmm::F64 = F64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _s4Fmm::F64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.084541593 UTC

[section ""data" . Foreign.Storable.$fStorableDouble4_closure" {
     Foreign.Storable.$fStorableDouble4_closure:
         const Foreign.Storable.$fStorableDouble4_info;
 },
 Foreign.Storable.$fStorableDouble4_entry() //  [R2, R3]
         { info_tbl: [(c4GB4,
                       label: Foreign.Storable.$fStorableDouble4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GB4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GBg; else goto c4GBh;
       c4GBg: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableDouble4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GBh: // global
           I64[Sp - 16] = block_c4GB1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GBn; else goto c4GB2;
       u4GBn: // global
           call _c4GB1(R1) args: 0, res: 0, upd: 0;
       c4GB2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GB1() //  [R1]
         { info_tbl: [(c4GB1,
                       label: block_c4GB1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GB1: // global
           I64[Sp] = block_c4GB7_info;
           _s4Fms::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fms::I64;
           if (R1 & 7 != 0) goto u4GBm; else goto c4GB8;
       u4GBm: // global
           call _c4GB7(R1) args: 0, res: 0, upd: 0;
       c4GB8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GB7() //  [R1]
         { info_tbl: [(c4GB7,
                       label: block_c4GB7_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GB7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GBl; else goto c4GBk;
       c4GBl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GBk: // global
           _s4Fmy::F64 = F64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _s4Fmy::F64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.08653087 UTC

[section ""data" . Foreign.Storable.$fStorableDouble1_closure" {
     Foreign.Storable.$fStorableDouble1_closure:
         const Foreign.Storable.$fStorableDouble1_info;
 },
 Foreign.Storable.$fStorableDouble1_entry() //  [R2, R3]
         { info_tbl: [(c4GBv,
                       label: Foreign.Storable.$fStorableDouble1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GBv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GBz; else goto c4GBA;
       c4GBz: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableDouble1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GBA: // global
           I64[Sp - 16] = block_c4GBs_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GBI; else goto c4GBt;
       u4GBI: // global
           call _c4GBs(R1) args: 0, res: 0, upd: 0;
       c4GBt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GBs() //  [R1]
         { info_tbl: [(c4GBs,
                       label: block_c4GBs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GBs: // global
           I64[Sp] = block_c4GBy_info;
           _s4FmE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FmE::I64;
           if (R1 & 7 != 0) goto u4GBH; else goto c4GBC;
       u4GBH: // global
           call _c4GBy(R1) args: 0, res: 0, upd: 0;
       c4GBC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GBy() //  [R1]
         { info_tbl: [(c4GBy,
                       label: block_c4GBy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GBy: // global
           F64[I64[Sp + 8]] = F64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.088215435 UTC

[section ""data" . Foreign.Storable.$fStorableDouble3_closure" {
     Foreign.Storable.$fStorableDouble3_closure:
         const Foreign.Storable.$fStorableDouble3_info;
 },
 Foreign.Storable.$fStorableDouble3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GBQ,
                       label: Foreign.Storable.$fStorableDouble3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GBQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4GBZ; else goto c4GC0;
       c4GBZ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableDouble3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GC0: // global
           I64[Sp - 24] = block_c4GBN_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4GCa; else goto c4GBO;
       u4GCa: // global
           call _c4GBN(R1) args: 0, res: 0, upd: 0;
       c4GBO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GBN() //  [R1]
         { info_tbl: [(c4GBN,
                       label: block_c4GBN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GBN: // global
           I64[Sp] = block_c4GBT_info;
           _s4FmN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FmN::I64;
           if (R1 & 7 != 0) goto u4GC9; else goto c4GBU;
       u4GC9: // global
           call _c4GBT(R1) args: 0, res: 0, upd: 0;
       c4GBU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GBT() //  [R1]
         { info_tbl: [(c4GBT,
                       label: block_c4GBT_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GBT: // global
           I64[Sp] = block_c4GBY_info;
           _s4FmP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FmP::I64;
           if (R1 & 7 != 0) goto u4GCb; else goto c4GC3;
       u4GCb: // global
           call _c4GBY(R1) args: 0, res: 0, upd: 0;
       c4GC3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GBY() //  [R1]
         { info_tbl: [(c4GBY,
                       label: block_c4GBY_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GBY: // global
           F64[I64[Sp + 8] + I64[Sp + 16]] = F64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.090128685 UTC

[section ""data" . Foreign.Storable.$fStorableDouble_closure" {
     Foreign.Storable.$fStorableDouble_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableDouble_$calignment_closure+1;
         const Foreign.Storable.$fStorableDouble_$calignment_closure+1;
         const GHC.Storable.readDoubleOffPtr1_closure+3;
         const GHC.Storable.writeDoubleOffPtr1_closure+4;
         const Foreign.Storable.$fStorableDouble4_closure+3;
         const Foreign.Storable.$fStorableDouble3_closure+4;
         const Foreign.Storable.$fStorableDouble2_closure+2;
         const Foreign.Storable.$fStorableDouble1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.091335566 UTC

[section ""data" . Foreign.Storable.$fStorableFloat2_closure" {
     Foreign.Storable.$fStorableFloat2_closure:
         const Foreign.Storable.$fStorableFloat2_info;
 },
 Foreign.Storable.$fStorableFloat2_entry() //  [R2]
         { info_tbl: [(c4GCj,
                       label: Foreign.Storable.$fStorableFloat2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GCj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4GCn; else goto c4GCo;
       c4GCn: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFloat2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4GCo: // global
           I64[Sp - 8] = block_c4GCg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GCs; else goto c4GCh;
       u4GCs: // global
           call _c4GCg(R1) args: 0, res: 0, upd: 0;
       c4GCh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GCg() //  [R1]
         { info_tbl: [(c4GCg,
                       label: block_c4GCg_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GCg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GCr; else goto c4GCq;
       c4GCr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GCq: // global
           _s4Fn0::F32 = F32[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _s4Fn0::F32;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.093485735 UTC

[section ""data" . Foreign.Storable.$fStorableFloat4_closure" {
     Foreign.Storable.$fStorableFloat4_closure:
         const Foreign.Storable.$fStorableFloat4_info;
 },
 Foreign.Storable.$fStorableFloat4_entry() //  [R2, R3]
         { info_tbl: [(c4GCA,
                       label: Foreign.Storable.$fStorableFloat4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GCA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GCM; else goto c4GCN;
       c4GCM: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFloat4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GCN: // global
           I64[Sp - 16] = block_c4GCx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GCT; else goto c4GCy;
       u4GCT: // global
           call _c4GCx(R1) args: 0, res: 0, upd: 0;
       c4GCy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GCx() //  [R1]
         { info_tbl: [(c4GCx,
                       label: block_c4GCx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GCx: // global
           I64[Sp] = block_c4GCD_info;
           _s4Fn6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fn6::I64;
           if (R1 & 7 != 0) goto u4GCS; else goto c4GCE;
       u4GCS: // global
           call _c4GCD(R1) args: 0, res: 0, upd: 0;
       c4GCE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GCD() //  [R1]
         { info_tbl: [(c4GCD,
                       label: block_c4GCD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GCD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GCR; else goto c4GCQ;
       c4GCR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GCQ: // global
           _s4Fnc::F32 = F32[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _s4Fnc::F32;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.095789505 UTC

[section ""data" . Foreign.Storable.$fStorableFloat1_closure" {
     Foreign.Storable.$fStorableFloat1_closure:
         const Foreign.Storable.$fStorableFloat1_info;
 },
 Foreign.Storable.$fStorableFloat1_entry() //  [R2, R3]
         { info_tbl: [(c4GD1,
                       label: Foreign.Storable.$fStorableFloat1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GD1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GD5; else goto c4GD6;
       c4GD5: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFloat1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GD6: // global
           I64[Sp - 16] = block_c4GCY_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GDe; else goto c4GCZ;
       u4GDe: // global
           call _c4GCY(R1) args: 0, res: 0, upd: 0;
       c4GCZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GCY() //  [R1]
         { info_tbl: [(c4GCY,
                       label: block_c4GCY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GCY: // global
           I64[Sp] = block_c4GD4_info;
           _s4Fni::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fni::I64;
           if (R1 & 7 != 0) goto u4GDd; else goto c4GD8;
       u4GDd: // global
           call _c4GD4(R1) args: 0, res: 0, upd: 0;
       c4GD8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GD4() //  [R1]
         { info_tbl: [(c4GD4,
                       label: block_c4GD4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GD4: // global
           F32[I64[Sp + 8]] = F32[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.098119289 UTC

[section ""data" . Foreign.Storable.$fStorableFloat3_closure" {
     Foreign.Storable.$fStorableFloat3_closure:
         const Foreign.Storable.$fStorableFloat3_info;
 },
 Foreign.Storable.$fStorableFloat3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GDm,
                       label: Foreign.Storable.$fStorableFloat3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GDm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4GDv; else goto c4GDw;
       c4GDv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFloat3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GDw: // global
           I64[Sp - 24] = block_c4GDj_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4GDG; else goto c4GDk;
       u4GDG: // global
           call _c4GDj(R1) args: 0, res: 0, upd: 0;
       c4GDk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GDj() //  [R1]
         { info_tbl: [(c4GDj,
                       label: block_c4GDj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GDj: // global
           I64[Sp] = block_c4GDp_info;
           _s4Fnr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fnr::I64;
           if (R1 & 7 != 0) goto u4GDF; else goto c4GDq;
       u4GDF: // global
           call _c4GDp(R1) args: 0, res: 0, upd: 0;
       c4GDq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GDp() //  [R1]
         { info_tbl: [(c4GDp,
                       label: block_c4GDp_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GDp: // global
           I64[Sp] = block_c4GDu_info;
           _s4Fnt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fnt::I64;
           if (R1 & 7 != 0) goto u4GDH; else goto c4GDz;
       u4GDH: // global
           call _c4GDu(R1) args: 0, res: 0, upd: 0;
       c4GDz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GDu() //  [R1]
         { info_tbl: [(c4GDu,
                       label: block_c4GDu_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GDu: // global
           F32[I64[Sp + 8] + I64[Sp + 16]] = F32[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.100158789 UTC

[section ""data" . Foreign.Storable.$fStorableFloat_closure" {
     Foreign.Storable.$fStorableFloat_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableFloat_$calignment_closure+1;
         const Foreign.Storable.$fStorableFloat_$calignment_closure+1;
         const GHC.Storable.readFloatOffPtr1_closure+3;
         const GHC.Storable.writeFloatOffPtr1_closure+4;
         const Foreign.Storable.$fStorableFloat4_closure+3;
         const Foreign.Storable.$fStorableFloat3_closure+4;
         const Foreign.Storable.$fStorableFloat2_closure+2;
         const Foreign.Storable.$fStorableFloat1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.101804094 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr2_closure" {
     Foreign.Storable.$fStorableStablePtr2_closure:
         const Foreign.Storable.$fStorableStablePtr2_info;
 },
 Foreign.Storable.$fStorableStablePtr2_entry() //  [R2]
         { info_tbl: [(c4GDP,
                       label: Foreign.Storable.$fStorableStablePtr2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GDP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4GDT; else goto c4GDU;
       c4GDT: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableStablePtr2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4GDU: // global
           I64[Sp - 8] = block_c4GDM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GDY; else goto c4GDN;
       u4GDY: // global
           call _c4GDM(R1) args: 0, res: 0, upd: 0;
       c4GDN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GDM() //  [R1]
         { info_tbl: [(c4GDM,
                       label: block_c4GDM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GDM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GDX; else goto c4GDW;
       c4GDX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GDW: // global
           _s4FnE::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Stable.StablePtr_con_info;
           I64[Hp] = _s4FnE::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.103783787 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr4_closure" {
     Foreign.Storable.$fStorableStablePtr4_closure:
         const Foreign.Storable.$fStorableStablePtr4_info;
 },
 Foreign.Storable.$fStorableStablePtr4_entry() //  [R2, R3]
         { info_tbl: [(c4GE6,
                       label: Foreign.Storable.$fStorableStablePtr4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GE6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GEi; else goto c4GEj;
       c4GEi: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableStablePtr4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GEj: // global
           I64[Sp - 16] = block_c4GE3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GEp; else goto c4GE4;
       u4GEp: // global
           call _c4GE3(R1) args: 0, res: 0, upd: 0;
       c4GE4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GE3() //  [R1]
         { info_tbl: [(c4GE3,
                       label: block_c4GE3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GE3: // global
           I64[Sp] = block_c4GE9_info;
           _s4FnK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FnK::I64;
           if (R1 & 7 != 0) goto u4GEo; else goto c4GEa;
       u4GEo: // global
           call _c4GE9(R1) args: 0, res: 0, upd: 0;
       c4GEa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GE9() //  [R1]
         { info_tbl: [(c4GE9,
                       label: block_c4GE9_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GE9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GEn; else goto c4GEm;
       c4GEn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GEm: // global
           _s4FnQ::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Stable.StablePtr_con_info;
           I64[Hp] = _s4FnQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.105999536 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr1_closure" {
     Foreign.Storable.$fStorableStablePtr1_closure:
         const Foreign.Storable.$fStorableStablePtr1_info;
 },
 Foreign.Storable.$fStorableStablePtr1_entry() //  [R2, R3]
         { info_tbl: [(c4GEx,
                       label: Foreign.Storable.$fStorableStablePtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GEx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GEB; else goto c4GEC;
       c4GEB: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableStablePtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GEC: // global
           I64[Sp - 16] = block_c4GEu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GEK; else goto c4GEv;
       u4GEK: // global
           call _c4GEu(R1) args: 0, res: 0, upd: 0;
       c4GEv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GEu() //  [R1]
         { info_tbl: [(c4GEu,
                       label: block_c4GEu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GEu: // global
           I64[Sp] = block_c4GEA_info;
           _s4FnW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FnW::I64;
           if (R1 & 7 != 0) goto u4GEJ; else goto c4GEE;
       u4GEJ: // global
           call _c4GEA(R1) args: 0, res: 0, upd: 0;
       c4GEE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GEA() //  [R1]
         { info_tbl: [(c4GEA,
                       label: block_c4GEA_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GEA: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.108063451 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr3_closure" {
     Foreign.Storable.$fStorableStablePtr3_closure:
         const Foreign.Storable.$fStorableStablePtr3_info;
 },
 Foreign.Storable.$fStorableStablePtr3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GES,
                       label: Foreign.Storable.$fStorableStablePtr3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GES: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4GF1; else goto c4GF2;
       c4GF1: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableStablePtr3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GF2: // global
           I64[Sp - 24] = block_c4GEP_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4GFc; else goto c4GEQ;
       u4GFc: // global
           call _c4GEP(R1) args: 0, res: 0, upd: 0;
       c4GEQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GEP() //  [R1]
         { info_tbl: [(c4GEP,
                       label: block_c4GEP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GEP: // global
           I64[Sp] = block_c4GEV_info;
           _s4Fo5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fo5::I64;
           if (R1 & 7 != 0) goto u4GFb; else goto c4GEW;
       u4GFb: // global
           call _c4GEV(R1) args: 0, res: 0, upd: 0;
       c4GEW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GEV() //  [R1]
         { info_tbl: [(c4GEV,
                       label: block_c4GEV_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GEV: // global
           I64[Sp] = block_c4GF0_info;
           _s4Fo7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fo7::I64;
           if (R1 & 7 != 0) goto u4GFd; else goto c4GF5;
       u4GFd: // global
           call _c4GF0(R1) args: 0, res: 0, upd: 0;
       c4GF5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GF0() //  [R1]
         { info_tbl: [(c4GF0,
                       label: block_c4GF0_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GF0: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.110144454 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr_closure" {
     Foreign.Storable.$fStorableStablePtr_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableStablePtr_$calignment_closure+1;
         const Foreign.Storable.$fStorableStablePtr_$calignment_closure+1;
         const GHC.Storable.readStablePtrOffPtr1_closure+3;
         const GHC.Storable.writeStablePtrOffPtr1_closure+4;
         const Foreign.Storable.$fStorableStablePtr4_closure+3;
         const Foreign.Storable.$fStorableStablePtr3_closure+4;
         const Foreign.Storable.$fStorableStablePtr2_closure+2;
         const Foreign.Storable.$fStorableStablePtr1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.111351675 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr2_closure" {
     Foreign.Storable.$fStorableFunPtr2_closure:
         const Foreign.Storable.$fStorableFunPtr2_info;
 },
 Foreign.Storable.$fStorableFunPtr2_entry() //  [R2]
         { info_tbl: [(c4GFl,
                       label: Foreign.Storable.$fStorableFunPtr2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GFl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4GFp; else goto c4GFq;
       c4GFp: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFunPtr2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4GFq: // global
           I64[Sp - 8] = block_c4GFi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GFu; else goto c4GFj;
       u4GFu: // global
           call _c4GFi(R1) args: 0, res: 0, upd: 0;
       c4GFj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GFi() //  [R1]
         { info_tbl: [(c4GFi,
                       label: block_c4GFi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GFi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GFt; else goto c4GFs;
       c4GFt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GFs: // global
           _s4Foi::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = _s4Foi::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.113375984 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr4_closure" {
     Foreign.Storable.$fStorableFunPtr4_closure:
         const Foreign.Storable.$fStorableFunPtr4_info;
 },
 Foreign.Storable.$fStorableFunPtr4_entry() //  [R2, R3]
         { info_tbl: [(c4GFC,
                       label: Foreign.Storable.$fStorableFunPtr4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GFC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GFO; else goto c4GFP;
       c4GFO: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFunPtr4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GFP: // global
           I64[Sp - 16] = block_c4GFz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GFV; else goto c4GFA;
       u4GFV: // global
           call _c4GFz(R1) args: 0, res: 0, upd: 0;
       c4GFA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GFz() //  [R1]
         { info_tbl: [(c4GFz,
                       label: block_c4GFz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GFz: // global
           I64[Sp] = block_c4GFF_info;
           _s4Foo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Foo::I64;
           if (R1 & 7 != 0) goto u4GFU; else goto c4GFG;
       u4GFU: // global
           call _c4GFF(R1) args: 0, res: 0, upd: 0;
       c4GFG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GFF() //  [R1]
         { info_tbl: [(c4GFF,
                       label: block_c4GFF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GFF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GFT; else goto c4GFS;
       c4GFT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GFS: // global
           _s4Fou::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = _s4Fou::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.115588069 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr1_closure" {
     Foreign.Storable.$fStorableFunPtr1_closure:
         const Foreign.Storable.$fStorableFunPtr1_info;
 },
 Foreign.Storable.$fStorableFunPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4GG3,
                       label: Foreign.Storable.$fStorableFunPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GG3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GG7; else goto c4GG8;
       c4GG7: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFunPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GG8: // global
           I64[Sp - 16] = block_c4GG0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GGg; else goto c4GG1;
       u4GGg: // global
           call _c4GG0(R1) args: 0, res: 0, upd: 0;
       c4GG1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GG0() //  [R1]
         { info_tbl: [(c4GG0,
                       label: block_c4GG0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GG0: // global
           I64[Sp] = block_c4GG6_info;
           _s4FoA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FoA::I64;
           if (R1 & 7 != 0) goto u4GGf; else goto c4GGa;
       u4GGf: // global
           call _c4GG6(R1) args: 0, res: 0, upd: 0;
       c4GGa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GG6() //  [R1]
         { info_tbl: [(c4GG6,
                       label: block_c4GG6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GG6: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.117855728 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr3_closure" {
     Foreign.Storable.$fStorableFunPtr3_closure:
         const Foreign.Storable.$fStorableFunPtr3_info;
 },
 Foreign.Storable.$fStorableFunPtr3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GGo,
                       label: Foreign.Storable.$fStorableFunPtr3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GGo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4GGx; else goto c4GGy;
       c4GGx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFunPtr3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GGy: // global
           I64[Sp - 24] = block_c4GGl_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4GGI; else goto c4GGm;
       u4GGI: // global
           call _c4GGl(R1) args: 0, res: 0, upd: 0;
       c4GGm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GGl() //  [R1]
         { info_tbl: [(c4GGl,
                       label: block_c4GGl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GGl: // global
           I64[Sp] = block_c4GGr_info;
           _s4FoJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FoJ::I64;
           if (R1 & 7 != 0) goto u4GGH; else goto c4GGs;
       u4GGH: // global
           call _c4GGr(R1) args: 0, res: 0, upd: 0;
       c4GGs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GGr() //  [R1]
         { info_tbl: [(c4GGr,
                       label: block_c4GGr_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GGr: // global
           I64[Sp] = block_c4GGw_info;
           _s4FoL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FoL::I64;
           if (R1 & 7 != 0) goto u4GGJ; else goto c4GGB;
       u4GGJ: // global
           call _c4GGw(R1) args: 0, res: 0, upd: 0;
       c4GGB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GGw() //  [R1]
         { info_tbl: [(c4GGw,
                       label: block_c4GGw_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GGw: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.119860437 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr_closure" {
     Foreign.Storable.$fStorableFunPtr_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableFunPtr_$calignment_closure+1;
         const Foreign.Storable.$fStorableFunPtr_$calignment_closure+1;
         const GHC.Storable.readFunPtrOffPtr1_closure+3;
         const GHC.Storable.writeFunPtrOffPtr1_closure+4;
         const Foreign.Storable.$fStorableFunPtr4_closure+3;
         const Foreign.Storable.$fStorableFunPtr3_closure+4;
         const Foreign.Storable.$fStorableFunPtr2_closure+2;
         const Foreign.Storable.$fStorableFunPtr1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.121183467 UTC

[section ""data" . Foreign.Storable.$fStorablePtr2_closure" {
     Foreign.Storable.$fStorablePtr2_closure:
         const Foreign.Storable.$fStorablePtr2_info;
 },
 Foreign.Storable.$fStorablePtr2_entry() //  [R2]
         { info_tbl: [(c4GGR,
                       label: Foreign.Storable.$fStorablePtr2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GGR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4GGV; else goto c4GGW;
       c4GGV: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorablePtr2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4GGW: // global
           I64[Sp - 8] = block_c4GGO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GH0; else goto c4GGP;
       u4GH0: // global
           call _c4GGO(R1) args: 0, res: 0, upd: 0;
       c4GGP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GGO() //  [R1]
         { info_tbl: [(c4GGO,
                       label: block_c4GGO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GGO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GGZ; else goto c4GGY;
       c4GGZ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GGY: // global
           _s4FoW::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4FoW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.124763491 UTC

[section ""data" . Foreign.Storable.$fStorablePtr4_closure" {
     Foreign.Storable.$fStorablePtr4_closure:
         const Foreign.Storable.$fStorablePtr4_info;
 },
 Foreign.Storable.$fStorablePtr4_entry() //  [R2, R3]
         { info_tbl: [(c4GH8,
                       label: Foreign.Storable.$fStorablePtr4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GH8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GHk; else goto c4GHl;
       c4GHk: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorablePtr4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GHl: // global
           I64[Sp - 16] = block_c4GH5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GHr; else goto c4GH6;
       u4GHr: // global
           call _c4GH5(R1) args: 0, res: 0, upd: 0;
       c4GH6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GH5() //  [R1]
         { info_tbl: [(c4GH5,
                       label: block_c4GH5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GH5: // global
           I64[Sp] = block_c4GHb_info;
           _s4Fp2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fp2::I64;
           if (R1 & 7 != 0) goto u4GHq; else goto c4GHc;
       u4GHq: // global
           call _c4GHb(R1) args: 0, res: 0, upd: 0;
       c4GHc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GHb() //  [R1]
         { info_tbl: [(c4GHb,
                       label: block_c4GHb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GHb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GHp; else goto c4GHo;
       c4GHp: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GHo: // global
           _s4Fp8::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fp8::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.12653616 UTC

[section ""data" . Foreign.Storable.$fStorablePtr1_closure" {
     Foreign.Storable.$fStorablePtr1_closure:
         const Foreign.Storable.$fStorablePtr1_info;
 },
 Foreign.Storable.$fStorablePtr1_entry() //  [R2, R3]
         { info_tbl: [(c4GHz,
                       label: Foreign.Storable.$fStorablePtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GHz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GHD; else goto c4GHE;
       c4GHD: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorablePtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GHE: // global
           I64[Sp - 16] = block_c4GHw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GHM; else goto c4GHx;
       u4GHM: // global
           call _c4GHw(R1) args: 0, res: 0, upd: 0;
       c4GHx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GHw() //  [R1]
         { info_tbl: [(c4GHw,
                       label: block_c4GHw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GHw: // global
           I64[Sp] = block_c4GHC_info;
           _s4Fpe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fpe::I64;
           if (R1 & 7 != 0) goto u4GHL; else goto c4GHG;
       u4GHL: // global
           call _c4GHC(R1) args: 0, res: 0, upd: 0;
       c4GHG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GHC() //  [R1]
         { info_tbl: [(c4GHC,
                       label: block_c4GHC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GHC: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.128149867 UTC

[section ""data" . Foreign.Storable.$fStorablePtr3_closure" {
     Foreign.Storable.$fStorablePtr3_closure:
         const Foreign.Storable.$fStorablePtr3_info;
 },
 Foreign.Storable.$fStorablePtr3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GHU,
                       label: Foreign.Storable.$fStorablePtr3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GHU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4GI3; else goto c4GI4;
       c4GI3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorablePtr3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GI4: // global
           I64[Sp - 24] = block_c4GHR_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4GIe; else goto c4GHS;
       u4GIe: // global
           call _c4GHR(R1) args: 0, res: 0, upd: 0;
       c4GHS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GHR() //  [R1]
         { info_tbl: [(c4GHR,
                       label: block_c4GHR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GHR: // global
           I64[Sp] = block_c4GHX_info;
           _s4Fpn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fpn::I64;
           if (R1 & 7 != 0) goto u4GId; else goto c4GHY;
       u4GId: // global
           call _c4GHX(R1) args: 0, res: 0, upd: 0;
       c4GHY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GHX() //  [R1]
         { info_tbl: [(c4GHX,
                       label: block_c4GHX_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GHX: // global
           I64[Sp] = block_c4GI2_info;
           _s4Fpp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fpp::I64;
           if (R1 & 7 != 0) goto u4GIf; else goto c4GI7;
       u4GIf: // global
           call _c4GI2(R1) args: 0, res: 0, upd: 0;
       c4GI7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GI2() //  [R1]
         { info_tbl: [(c4GI2,
                       label: block_c4GI2_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GI2: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.129656667 UTC

[section ""data" . Foreign.Storable.$fStorablePtr_closure" {
     Foreign.Storable.$fStorablePtr_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorablePtr_$calignment_closure+1;
         const Foreign.Storable.$fStorablePtr_$calignment_closure+1;
         const GHC.Storable.readPtrOffPtr1_closure+3;
         const GHC.Storable.writePtrOffPtr1_closure+4;
         const Foreign.Storable.$fStorablePtr4_closure+3;
         const Foreign.Storable.$fStorablePtr3_closure+4;
         const Foreign.Storable.$fStorablePtr2_closure+2;
         const Foreign.Storable.$fStorablePtr1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.130639597 UTC

[section ""data" . Foreign.Storable.$fStorableWord2_closure" {
     Foreign.Storable.$fStorableWord2_closure:
         const Foreign.Storable.$fStorableWord2_info;
 },
 Foreign.Storable.$fStorableWord2_entry() //  [R2]
         { info_tbl: [(c4GIn,
                       label: Foreign.Storable.$fStorableWord2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GIn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4GIr; else goto c4GIs;
       c4GIr: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4GIs: // global
           I64[Sp - 8] = block_c4GIk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GIw; else goto c4GIl;
       u4GIw: // global
           call _c4GIk(R1) args: 0, res: 0, upd: 0;
       c4GIl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GIk() //  [R1]
         { info_tbl: [(c4GIk,
                       label: block_c4GIk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GIk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GIv; else goto c4GIu;
       c4GIv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GIu: // global
           _s4FpA::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s4FpA::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.132184784 UTC

[section ""data" . Foreign.Storable.$fStorableWord4_closure" {
     Foreign.Storable.$fStorableWord4_closure:
         const Foreign.Storable.$fStorableWord4_info;
 },
 Foreign.Storable.$fStorableWord4_entry() //  [R2, R3]
         { info_tbl: [(c4GIE,
                       label: Foreign.Storable.$fStorableWord4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GIE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GIQ; else goto c4GIR;
       c4GIQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GIR: // global
           I64[Sp - 16] = block_c4GIB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GIX; else goto c4GIC;
       u4GIX: // global
           call _c4GIB(R1) args: 0, res: 0, upd: 0;
       c4GIC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GIB() //  [R1]
         { info_tbl: [(c4GIB,
                       label: block_c4GIB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GIB: // global
           I64[Sp] = block_c4GIH_info;
           _s4FpG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FpG::I64;
           if (R1 & 7 != 0) goto u4GIW; else goto c4GII;
       u4GIW: // global
           call _c4GIH(R1) args: 0, res: 0, upd: 0;
       c4GII: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GIH() //  [R1]
         { info_tbl: [(c4GIH,
                       label: block_c4GIH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GIH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GIV; else goto c4GIU;
       c4GIV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GIU: // global
           _s4FpM::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s4FpM::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.134061264 UTC

[section ""data" . Foreign.Storable.$fStorableWord1_closure" {
     Foreign.Storable.$fStorableWord1_closure:
         const Foreign.Storable.$fStorableWord1_info;
 },
 Foreign.Storable.$fStorableWord1_entry() //  [R2, R3]
         { info_tbl: [(c4GJ5,
                       label: Foreign.Storable.$fStorableWord1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GJ5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GJ9; else goto c4GJa;
       c4GJ9: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GJa: // global
           I64[Sp - 16] = block_c4GJ2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GJi; else goto c4GJ3;
       u4GJi: // global
           call _c4GJ2(R1) args: 0, res: 0, upd: 0;
       c4GJ3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GJ2() //  [R1]
         { info_tbl: [(c4GJ2,
                       label: block_c4GJ2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GJ2: // global
           I64[Sp] = block_c4GJ8_info;
           _s4FpS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FpS::I64;
           if (R1 & 7 != 0) goto u4GJh; else goto c4GJc;
       u4GJh: // global
           call _c4GJ8(R1) args: 0, res: 0, upd: 0;
       c4GJc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GJ8() //  [R1]
         { info_tbl: [(c4GJ8,
                       label: block_c4GJ8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GJ8: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.13565851 UTC

[section ""data" . Foreign.Storable.$fStorableWord3_closure" {
     Foreign.Storable.$fStorableWord3_closure:
         const Foreign.Storable.$fStorableWord3_info;
 },
 Foreign.Storable.$fStorableWord3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GJq,
                       label: Foreign.Storable.$fStorableWord3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GJq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4GJz; else goto c4GJA;
       c4GJz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GJA: // global
           I64[Sp - 24] = block_c4GJn_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4GJK; else goto c4GJo;
       u4GJK: // global
           call _c4GJn(R1) args: 0, res: 0, upd: 0;
       c4GJo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GJn() //  [R1]
         { info_tbl: [(c4GJn,
                       label: block_c4GJn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GJn: // global
           I64[Sp] = block_c4GJt_info;
           _s4Fq1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fq1::I64;
           if (R1 & 7 != 0) goto u4GJJ; else goto c4GJu;
       u4GJJ: // global
           call _c4GJt(R1) args: 0, res: 0, upd: 0;
       c4GJu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GJt() //  [R1]
         { info_tbl: [(c4GJt,
                       label: block_c4GJt_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GJt: // global
           I64[Sp] = block_c4GJy_info;
           _s4Fq3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fq3::I64;
           if (R1 & 7 != 0) goto u4GJL; else goto c4GJD;
       u4GJL: // global
           call _c4GJy(R1) args: 0, res: 0, upd: 0;
       c4GJD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GJy() //  [R1]
         { info_tbl: [(c4GJy,
                       label: block_c4GJy_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GJy: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.137108572 UTC

[section ""data" . Foreign.Storable.$fStorableWord_closure" {
     Foreign.Storable.$fStorableWord_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableWord_$calignment_closure+1;
         const Foreign.Storable.$fStorableWord_$calignment_closure+1;
         const GHC.Storable.readWordOffPtr1_closure+3;
         const GHC.Storable.writeWordOffPtr1_closure+4;
         const Foreign.Storable.$fStorableWord4_closure+3;
         const Foreign.Storable.$fStorableWord3_closure+4;
         const Foreign.Storable.$fStorableWord2_closure+2;
         const Foreign.Storable.$fStorableWord1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.138133017 UTC

[section ""data" . Foreign.Storable.$fStorableInt2_closure" {
     Foreign.Storable.$fStorableInt2_closure:
         const Foreign.Storable.$fStorableInt2_info;
 },
 Foreign.Storable.$fStorableInt2_entry() //  [R2]
         { info_tbl: [(c4GJT,
                       label: Foreign.Storable.$fStorableInt2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GJT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4GJX; else goto c4GJY;
       c4GJX: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4GJY: // global
           I64[Sp - 8] = block_c4GJQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GK2; else goto c4GJR;
       u4GK2: // global
           call _c4GJQ(R1) args: 0, res: 0, upd: 0;
       c4GJR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GJQ() //  [R1]
         { info_tbl: [(c4GJQ,
                       label: block_c4GJQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GJQ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GK1; else goto c4GK0;
       c4GK1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GK0: // global
           _s4Fqe::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4Fqe::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.139624373 UTC

[section ""data" . Foreign.Storable.$fStorableInt4_closure" {
     Foreign.Storable.$fStorableInt4_closure:
         const Foreign.Storable.$fStorableInt4_info;
 },
 Foreign.Storable.$fStorableInt4_entry() //  [R2, R3]
         { info_tbl: [(c4GKa,
                       label: Foreign.Storable.$fStorableInt4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GKa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GKm; else goto c4GKn;
       c4GKm: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GKn: // global
           I64[Sp - 16] = block_c4GK7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GKt; else goto c4GK8;
       u4GKt: // global
           call _c4GK7(R1) args: 0, res: 0, upd: 0;
       c4GK8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GK7() //  [R1]
         { info_tbl: [(c4GK7,
                       label: block_c4GK7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GK7: // global
           I64[Sp] = block_c4GKd_info;
           _s4Fqk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fqk::I64;
           if (R1 & 7 != 0) goto u4GKs; else goto c4GKe;
       u4GKs: // global
           call _c4GKd(R1) args: 0, res: 0, upd: 0;
       c4GKe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GKd() //  [R1]
         { info_tbl: [(c4GKd,
                       label: block_c4GKd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GKd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GKr; else goto c4GKq;
       c4GKr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GKq: // global
           _s4Fqq::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4Fqq::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.141360457 UTC

[section ""data" . Foreign.Storable.$fStorableInt1_closure" {
     Foreign.Storable.$fStorableInt1_closure:
         const Foreign.Storable.$fStorableInt1_info;
 },
 Foreign.Storable.$fStorableInt1_entry() //  [R2, R3]
         { info_tbl: [(c4GKB,
                       label: Foreign.Storable.$fStorableInt1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GKB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GKF; else goto c4GKG;
       c4GKF: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GKG: // global
           I64[Sp - 16] = block_c4GKy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GKO; else goto c4GKz;
       u4GKO: // global
           call _c4GKy(R1) args: 0, res: 0, upd: 0;
       c4GKz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GKy() //  [R1]
         { info_tbl: [(c4GKy,
                       label: block_c4GKy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GKy: // global
           I64[Sp] = block_c4GKE_info;
           _s4Fqw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fqw::I64;
           if (R1 & 7 != 0) goto u4GKN; else goto c4GKI;
       u4GKN: // global
           call _c4GKE(R1) args: 0, res: 0, upd: 0;
       c4GKI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GKE() //  [R1]
         { info_tbl: [(c4GKE,
                       label: block_c4GKE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GKE: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.142960269 UTC

[section ""data" . Foreign.Storable.$fStorableInt3_closure" {
     Foreign.Storable.$fStorableInt3_closure:
         const Foreign.Storable.$fStorableInt3_info;
 },
 Foreign.Storable.$fStorableInt3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GKW,
                       label: Foreign.Storable.$fStorableInt3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GKW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4GL5; else goto c4GL6;
       c4GL5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GL6: // global
           I64[Sp - 24] = block_c4GKT_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4GLg; else goto c4GKU;
       u4GLg: // global
           call _c4GKT(R1) args: 0, res: 0, upd: 0;
       c4GKU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GKT() //  [R1]
         { info_tbl: [(c4GKT,
                       label: block_c4GKT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GKT: // global
           I64[Sp] = block_c4GKZ_info;
           _s4FqF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FqF::I64;
           if (R1 & 7 != 0) goto u4GLf; else goto c4GL0;
       u4GLf: // global
           call _c4GKZ(R1) args: 0, res: 0, upd: 0;
       c4GL0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GKZ() //  [R1]
         { info_tbl: [(c4GKZ,
                       label: block_c4GKZ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GKZ: // global
           I64[Sp] = block_c4GL4_info;
           _s4FqH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FqH::I64;
           if (R1 & 7 != 0) goto u4GLh; else goto c4GL9;
       u4GLh: // global
           call _c4GL4(R1) args: 0, res: 0, upd: 0;
       c4GL9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GL4() //  [R1]
         { info_tbl: [(c4GL4,
                       label: block_c4GL4_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GL4: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.144427365 UTC

[section ""data" . Foreign.Storable.$fStorableInt_closure" {
     Foreign.Storable.$fStorableInt_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt_$calignment_closure+1;
         const GHC.Storable.readIntOffPtr1_closure+3;
         const GHC.Storable.writeIntOffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt4_closure+3;
         const Foreign.Storable.$fStorableInt3_closure+4;
         const Foreign.Storable.$fStorableInt2_closure+2;
         const Foreign.Storable.$fStorableInt1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.145422418 UTC

[section ""data" . Foreign.Storable.$fStorableChar2_closure" {
     Foreign.Storable.$fStorableChar2_closure:
         const Foreign.Storable.$fStorableChar2_info;
 },
 Foreign.Storable.$fStorableChar2_entry() //  [R2]
         { info_tbl: [(c4GLp,
                       label: Foreign.Storable.$fStorableChar2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GLp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4GLt; else goto c4GLu;
       c4GLt: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableChar2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4GLu: // global
           I64[Sp - 8] = block_c4GLm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GLy; else goto c4GLn;
       u4GLy: // global
           call _c4GLm(R1) args: 0, res: 0, upd: 0;
       c4GLn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GLm() //  [R1]
         { info_tbl: [(c4GLm,
                       label: block_c4GLm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GLm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GLx; else goto c4GLw;
       c4GLx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GLw: // global
           _s4FqS::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s4FqS::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.146925987 UTC

[section ""data" . Foreign.Storable.$fStorableChar4_closure" {
     Foreign.Storable.$fStorableChar4_closure:
         const Foreign.Storable.$fStorableChar4_info;
 },
 Foreign.Storable.$fStorableChar4_entry() //  [R2, R3]
         { info_tbl: [(c4GLG,
                       label: Foreign.Storable.$fStorableChar4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GLG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GLS; else goto c4GLT;
       c4GLS: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableChar4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GLT: // global
           I64[Sp - 16] = block_c4GLD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GLZ; else goto c4GLE;
       u4GLZ: // global
           call _c4GLD(R1) args: 0, res: 0, upd: 0;
       c4GLE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GLD() //  [R1]
         { info_tbl: [(c4GLD,
                       label: block_c4GLD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GLD: // global
           I64[Sp] = block_c4GLJ_info;
           _s4FqY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FqY::I64;
           if (R1 & 7 != 0) goto u4GLY; else goto c4GLK;
       u4GLY: // global
           call _c4GLJ(R1) args: 0, res: 0, upd: 0;
       c4GLK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GLJ() //  [R1]
         { info_tbl: [(c4GLJ,
                       label: block_c4GLJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GLJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GLX; else goto c4GLW;
       c4GLX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GLW: // global
           _s4Fr4::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s4Fr4::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.148574994 UTC

[section ""data" . Foreign.Storable.$fStorableChar1_closure" {
     Foreign.Storable.$fStorableChar1_closure:
         const Foreign.Storable.$fStorableChar1_info;
 },
 Foreign.Storable.$fStorableChar1_entry() //  [R2, R3]
         { info_tbl: [(c4GM7,
                       label: Foreign.Storable.$fStorableChar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GM7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GMb; else goto c4GMc;
       c4GMb: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableChar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GMc: // global
           I64[Sp - 16] = block_c4GM4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GMk; else goto c4GM5;
       u4GMk: // global
           call _c4GM4(R1) args: 0, res: 0, upd: 0;
       c4GM5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GM4() //  [R1]
         { info_tbl: [(c4GM4,
                       label: block_c4GM4_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GM4: // global
           I64[Sp] = block_c4GMa_info;
           _s4Fra::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fra::I64;
           if (R1 & 7 != 0) goto u4GMj; else goto c4GMe;
       u4GMj: // global
           call _c4GMa(R1) args: 0, res: 0, upd: 0;
       c4GMe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GMa() //  [R1]
         { info_tbl: [(c4GMa,
                       label: block_c4GMa_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GMa: // global
           I32[I64[Sp + 8]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.150706675 UTC

[section ""data" . Foreign.Storable.$fStorableChar3_closure" {
     Foreign.Storable.$fStorableChar3_closure:
         const Foreign.Storable.$fStorableChar3_info;
 },
 Foreign.Storable.$fStorableChar3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GMs,
                       label: Foreign.Storable.$fStorableChar3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GMs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4GMB; else goto c4GMC;
       c4GMB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableChar3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GMC: // global
           I64[Sp - 24] = block_c4GMp_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4GMM; else goto c4GMq;
       u4GMM: // global
           call _c4GMp(R1) args: 0, res: 0, upd: 0;
       c4GMq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GMp() //  [R1]
         { info_tbl: [(c4GMp,
                       label: block_c4GMp_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GMp: // global
           I64[Sp] = block_c4GMv_info;
           _s4Frj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Frj::I64;
           if (R1 & 7 != 0) goto u4GML; else goto c4GMw;
       u4GML: // global
           call _c4GMv(R1) args: 0, res: 0, upd: 0;
       c4GMw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GMv() //  [R1]
         { info_tbl: [(c4GMv,
                       label: block_c4GMv_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GMv: // global
           I64[Sp] = block_c4GMA_info;
           _s4Frl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Frl::I64;
           if (R1 & 7 != 0) goto u4GMN; else goto c4GMF;
       u4GMN: // global
           call _c4GMA(R1) args: 0, res: 0, upd: 0;
       c4GMF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GMA() //  [R1]
         { info_tbl: [(c4GMA,
                       label: block_c4GMA_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GMA: // global
           I32[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.152450084 UTC

[section ""data" . Foreign.Storable.$fStorableChar_closure" {
     Foreign.Storable.$fStorableChar_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableChar_$calignment_closure+1;
         const Foreign.Storable.$fStorableChar_$calignment_closure+1;
         const GHC.Storable.readWideCharOffPtr1_closure+3;
         const GHC.Storable.writeWideCharOffPtr1_closure+4;
         const Foreign.Storable.$fStorableChar4_closure+3;
         const Foreign.Storable.$fStorableChar3_closure+4;
         const Foreign.Storable.$fStorableChar2_closure+2;
         const Foreign.Storable.$fStorableChar1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.153404863 UTC

[section ""data" . Foreign.Storable.$trModule3_closure" {
     Foreign.Storable.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Storable.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.154283341 UTC

[section ""data" . Foreign.Storable.$trModule1_closure" {
     Foreign.Storable.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Storable.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.155127644 UTC

[section ""data" . Foreign.Storable.$trModule_closure" {
     Foreign.Storable.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Storable.$trModule3_closure+1;
         const Foreign.Storable.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.155950925 UTC

[section ""data" . $krep_r4Ffk_closure" {
     $krep_r4Ffk_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.156703994 UTC

[section ""data" . Foreign.Storable.$tcStorable1_closure" {
     Foreign.Storable.$tcStorable1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep_r4Ffk_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.15757085 UTC

[section ""cstring" . Foreign.Storable.$tcStorable3_bytes" {
     Foreign.Storable.$tcStorable3_bytes:
         I8[] [83,116,111,114,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.158292184 UTC

[section ""data" . Foreign.Storable.$tcStorable2_closure" {
     Foreign.Storable.$tcStorable2_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Storable.$tcStorable3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.159073398 UTC

[section ""data" . Foreign.Storable.$tcStorable_closure" {
     Foreign.Storable.$tcStorable_closure:
         const GHC.Types.TyCon_con_info;
         const Foreign.Storable.$trModule_closure+1;
         const Foreign.Storable.$tcStorable2_closure+1;
         const Foreign.Storable.$tcStorable1_closure+4;
         const 9192657549155052097;
         const 13909834202100645491;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.160448467 UTC

[section ""data" . Foreign.Storable.$fStorableWord20_closure" {
     Foreign.Storable.$fStorableWord20_closure:
         const Foreign.Storable.$fStorableWord20_info;
 },
 Foreign.Storable.$fStorableWord20_entry() //  [R2]
         { info_tbl: [(c4GMV,
                       label: Foreign.Storable.$fStorableWord20_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GMV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4GMZ; else goto c4GN0;
       c4GMZ: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord20_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4GN0: // global
           I64[Sp - 8] = block_c4GMS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GN4; else goto c4GMT;
       u4GN4: // global
           call _c4GMS(R1) args: 0, res: 0, upd: 0;
       c4GMT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GMS() //  [R1]
         { info_tbl: [(c4GMS,
                       label: block_c4GMS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GMS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GN3; else goto c4GN2;
       c4GN3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GN2: // global
           _s4Frw::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s4Frw::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.16297466 UTC

[section ""data" . Foreign.Storable.$fStorableWord22_closure" {
     Foreign.Storable.$fStorableWord22_closure:
         const Foreign.Storable.$fStorableWord22_info;
 },
 Foreign.Storable.$fStorableWord22_entry() //  [R2, R3]
         { info_tbl: [(c4GNc,
                       label: Foreign.Storable.$fStorableWord22_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GNc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GNo; else goto c4GNp;
       c4GNo: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord22_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GNp: // global
           I64[Sp - 16] = block_c4GN9_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GNv; else goto c4GNa;
       u4GNv: // global
           call _c4GN9(R1) args: 0, res: 0, upd: 0;
       c4GNa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GN9() //  [R1]
         { info_tbl: [(c4GN9,
                       label: block_c4GN9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GN9: // global
           I64[Sp] = block_c4GNf_info;
           _s4FrC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FrC::I64;
           if (R1 & 7 != 0) goto u4GNu; else goto c4GNg;
       u4GNu: // global
           call _c4GNf(R1) args: 0, res: 0, upd: 0;
       c4GNg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GNf() //  [R1]
         { info_tbl: [(c4GNf,
                       label: block_c4GNf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GNf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GNt; else goto c4GNs;
       c4GNt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GNs: // global
           _s4FrI::I64 = %MO_UU_Conv_W8_W64(I8[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s4FrI::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.165140904 UTC

[section ""data" . Foreign.Storable.$fStorableWord19_closure" {
     Foreign.Storable.$fStorableWord19_closure:
         const Foreign.Storable.$fStorableWord19_info;
 },
 Foreign.Storable.$fStorableWord19_entry() //  [R2, R3]
         { info_tbl: [(c4GND,
                       label: Foreign.Storable.$fStorableWord19_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GND: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GNH; else goto c4GNI;
       c4GNH: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord19_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GNI: // global
           I64[Sp - 16] = block_c4GNA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GNQ; else goto c4GNB;
       u4GNQ: // global
           call _c4GNA(R1) args: 0, res: 0, upd: 0;
       c4GNB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GNA() //  [R1]
         { info_tbl: [(c4GNA,
                       label: block_c4GNA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GNA: // global
           I64[Sp] = block_c4GNG_info;
           _s4FrO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FrO::I64;
           if (R1 & 7 != 0) goto u4GNP; else goto c4GNK;
       u4GNP: // global
           call _c4GNG(R1) args: 0, res: 0, upd: 0;
       c4GNK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GNG() //  [R1]
         { info_tbl: [(c4GNG,
                       label: block_c4GNG_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GNG: // global
           I8[I64[Sp + 8]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.167391152 UTC

[section ""data" . Foreign.Storable.$fStorableWord21_closure" {
     Foreign.Storable.$fStorableWord21_closure:
         const Foreign.Storable.$fStorableWord21_info;
 },
 Foreign.Storable.$fStorableWord21_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GNY,
                       label: Foreign.Storable.$fStorableWord21_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GNY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4GO7; else goto c4GO8;
       c4GO7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord21_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GO8: // global
           I64[Sp - 24] = block_c4GNV_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4GOi; else goto c4GNW;
       u4GOi: // global
           call _c4GNV(R1) args: 0, res: 0, upd: 0;
       c4GNW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GNV() //  [R1]
         { info_tbl: [(c4GNV,
                       label: block_c4GNV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GNV: // global
           I64[Sp] = block_c4GO1_info;
           _s4FrX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FrX::I64;
           if (R1 & 7 != 0) goto u4GOh; else goto c4GO2;
       u4GOh: // global
           call _c4GO1(R1) args: 0, res: 0, upd: 0;
       c4GO2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GO1() //  [R1]
         { info_tbl: [(c4GO1,
                       label: block_c4GO1_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GO1: // global
           I64[Sp] = block_c4GO6_info;
           _s4FrZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FrZ::I64;
           if (R1 & 7 != 0) goto u4GOj; else goto c4GOb;
       u4GOj: // global
           call _c4GO6(R1) args: 0, res: 0, upd: 0;
       c4GOb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GO6() //  [R1]
         { info_tbl: [(c4GO6,
                       label: block_c4GO6_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GO6: // global
           I8[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.169544963 UTC

[section ""data" . Foreign.Storable.$fStorableWord8_closure" {
     Foreign.Storable.$fStorableWord8_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableWord8_$calignment_closure+1;
         const Foreign.Storable.$fStorableWord8_$calignment_closure+1;
         const GHC.Storable.readWord8OffPtr1_closure+3;
         const GHC.Storable.writeWord8OffPtr1_closure+4;
         const Foreign.Storable.$fStorableWord22_closure+3;
         const Foreign.Storable.$fStorableWord21_closure+4;
         const Foreign.Storable.$fStorableWord20_closure+2;
         const Foreign.Storable.$fStorableWord19_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.172952056 UTC

[section ""data" . Foreign.Storable.$fStorableRatio2_closure" {
     Foreign.Storable.$fStorableRatio2_closure:
         const Foreign.Storable.$fStorableRatio2_info;
         const 0;
 },
 sat_s4Fse_entry() //  [R1]
         { info_tbl: [(c4GOw,
                       label: sat_s4Fse_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GOw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GOx; else goto c4GOy;
       c4GOx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GOy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.%_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableRatio2_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GOz,
                       label: Foreign.Storable.$fStorableRatio2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GOz: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c4GOA; else goto c4GOB;
       c4GOA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GOB: // global
           I64[Sp - 32] = block_c4GOo_info;
           _s4Fs4::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_pv_info;
           P64[Sp - 40] = R4;
           P64[Sp - 24] = _s4Fs4::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 48;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c4GOo() //  [R1]
         { info_tbl: [(c4GOo,
                       label: block_c4GOo_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GOo: // global
           _s4Fs4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4GOq_info;
           R2 = _s4Fs4::P64;
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp] = Foreign.Storable.$fStorable()7_closure+1;
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c4GOq() //  [R1]
         { info_tbl: [(c4GOq,
                       label: block_c4GOq_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GOq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4GOF; else goto c4GOE;
       c4GOF: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GOE: // global
           I64[Hp - 32] = sat_s4Fse_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.175752115 UTC

[section ""data" . Foreign.Storable.$fStorableRatio1_closure" {
     Foreign.Storable.$fStorableRatio1_closure:
         const Foreign.Storable.$fStorableRatio1_info;
 },
 Foreign.Storable.$fStorableRatio1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c4GON,
                       label: Foreign.Storable.$fStorableRatio1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GON: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c4GOR; else goto c4GOS;
       c4GOR: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GOS: // global
           I64[Sp - 24] = block_c4GOK_info;
           R1 = R5;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4GOW; else goto c4GOL;
       u4GOW: // global
           call _c4GOK(R1) args: 0, res: 0, upd: 0;
       c4GOL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GOK() //  [R1]
         { info_tbl: [(c4GOK,
                       label: block_c4GOK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GOK: // global
           I64[Sp - 8] = block_c4GOQ_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_ppv_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 32;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c4GOQ() //  []
         { info_tbl: [(c4GOQ,
                       label: block_c4GOQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GOQ: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppv_info;
           _s4Fsm::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 16] = Foreign.Storable.$fStorable()7_closure+1;
           P64[Sp + 24] = _s4Fsm::P64;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.178268774 UTC

[section ""data" . Foreign.Storable.$fStorableBool6_closure" {
     Foreign.Storable.$fStorableBool6_closure:
         const Foreign.Storable.$fStorableBool6_info;
 },
 sat_s4FsB_entry() //  [R1]
         { info_tbl: [(c4GPj,
                       label: sat_s4FsB_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GPj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GPk; else goto c4GPl;
       c4GPk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GPl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c4GPi; else goto c4GPh;
       c4GPi: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4GPh: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableBool6_entry() //  [R2, R3]
         { info_tbl: [(c4GPm,
                       label: Foreign.Storable.$fStorableBool6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GPm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GPn; else goto c4GPo;
       c4GPn: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GPo: // global
           I64[Sp - 16] = block_c4GP1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GPu; else goto c4GP2;
       u4GPu: // global
           call _c4GP1(R1) args: 0, res: 0, upd: 0;
       c4GP2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GP1() //  [R1]
         { info_tbl: [(c4GP1,
                       label: block_c4GP1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GP1: // global
           I64[Sp] = block_c4GP6_info;
           _s4Fsu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fsu::I64;
           if (R1 & 7 != 0) goto u4GPt; else goto c4GP7;
       u4GPt: // global
           call _c4GP6(R1) args: 0, res: 0, upd: 0;
       c4GP7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GP6() //  [R1]
         { info_tbl: [(c4GP6,
                       label: block_c4GP6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GP6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4GPs; else goto c4GPr;
       c4GPs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GPr: // global
           _s4Fsz::I64 = %MO_SS_Conv_W32_W64(I32[I64[Sp + 8] + (I64[R1 + 7] << 2)]);
           I64[Hp - 16] = sat_s4FsB_info;
           I64[Hp] = _s4Fsz::I64;
           R1 = Hp - 16;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.181061353 UTC

[section ""data" . Foreign.Storable.$fStorableBool2_closure" {
     Foreign.Storable.$fStorableBool2_closure:
         const Foreign.Storable.$fStorableBool2_info;
 },
 sat_s4FsK_entry() //  [R1]
         { info_tbl: [(c4GPM,
                       label: sat_s4FsK_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GPM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GPN; else goto c4GPO;
       c4GPN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GPO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c4GPL; else goto c4GPK;
       c4GPL: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4GPK: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableBool2_entry() //  [R2]
         { info_tbl: [(c4GPP,
                       label: Foreign.Storable.$fStorableBool2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GPP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4GPQ; else goto c4GPR;
       c4GPQ: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4GPR: // global
           I64[Sp - 8] = block_c4GPz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GPV; else goto c4GPA;
       u4GPV: // global
           call _c4GPz(R1) args: 0, res: 0, upd: 0;
       c4GPA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GPz() //  [R1]
         { info_tbl: [(c4GPz,
                       label: block_c4GPz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GPz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4GPU; else goto c4GPT;
       c4GPU: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GPT: // global
           _s4FsI::I64 = %MO_SS_Conv_W32_W64(I32[I64[R1 + 7]]);
           I64[Hp - 16] = sat_s4FsK_info;
           I64[Hp] = _s4FsI::I64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.183707769 UTC

[section ""data" . Foreign.Storable.$fStorableBool4_closure" {
     Foreign.Storable.$fStorableBool4_closure:
         const Foreign.Storable.$fStorableBool4_info;
 },
 sat_s4FsX_entry() //  [R1]
         { info_tbl: [(c4GQl,
                       label: sat_s4FsX_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GQl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GQm; else goto c4GQn;
       c4GQm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GQn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c4GQk; else goto c4GQj;
       c4GQk: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4GQj: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableBool4_entry() //  [R2, R3]
         { info_tbl: [(c4GQo,
                       label: Foreign.Storable.$fStorableBool4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GQo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GQp; else goto c4GQq;
       c4GQp: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GQq: // global
           I64[Sp - 16] = block_c4GQ0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GQw; else goto c4GQ1;
       u4GQw: // global
           call _c4GQ0(R1) args: 0, res: 0, upd: 0;
       c4GQ1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GQ0() //  [R1]
         { info_tbl: [(c4GQ0,
                       label: block_c4GQ0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GQ0: // global
           I64[Sp] = block_c4GQ5_info;
           _s4FsP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FsP::I64;
           if (R1 & 7 != 0) goto u4GQv; else goto c4GQ6;
       u4GQv: // global
           call _c4GQ5(R1) args: 0, res: 0, upd: 0;
       c4GQ6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GQ5() //  [R1]
         { info_tbl: [(c4GQ5,
                       label: block_c4GQ5_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GQ5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4GQu; else goto c4GQt;
       c4GQu: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GQt: // global
           _s4FsV::I64 = %MO_SS_Conv_W32_W64(I32[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 16] = sat_s4FsX_info;
           I64[Hp] = _s4FsV::I64;
           R1 = Hp - 16;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.186433071 UTC

[section ""data" . Foreign.Storable.$fStorableBool1_closure" {
     Foreign.Storable.$fStorableBool1_closure:
         const Foreign.Storable.$fStorableBool1_info;
 },
 Foreign.Storable.$fStorableBool1_entry() //  [R2, R3]
         { info_tbl: [(c4GQE,
                       label: Foreign.Storable.$fStorableBool1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GQE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GQF; else goto c4GQG;
       c4GQF: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GQG: // global
           I64[Sp - 16] = block_c4GQB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4GQY; else goto c4GQC;
       u4GQY: // global
           call _c4GQB(R1) args: 0, res: 0, upd: 0;
       c4GQC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GQB() //  [R1]
         { info_tbl: [(c4GQB,
                       label: block_c4GQB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GQB: // global
           I64[Sp] = block_c4GQJ_info;
           _s4Ft2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Ft2::I64;
           if (R1 & 7 != 0) goto u4GQX; else goto c4GQL;
       u4GQX: // global
           call _c4GQJ(R1) args: 0, res: 0, upd: 0;
       c4GQL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GQJ() //  [R1]
         { info_tbl: [(c4GQJ,
                       label: block_c4GQJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GQJ: // global
           _s4Ft2::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c4GQR; else goto c4GQV;
       c4GQR: // global
           I32[_s4Ft2::I64] = 0 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4GQV: // global
           I32[_s4Ft2::I64] = 1 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.188764513 UTC

[section ""data" . Foreign.Storable.$fStorableBool3_closure" {
     Foreign.Storable.$fStorableBool3_closure:
         const Foreign.Storable.$fStorableBool3_info;
 },
 Foreign.Storable.$fStorableBool3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GR6,
                       label: Foreign.Storable.$fStorableBool3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GR6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4GRa; else goto c4GRb;
       c4GRa: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GRb: // global
           I64[Sp - 24] = block_c4GR3_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4GRy; else goto c4GR4;
       u4GRy: // global
           call _c4GR3(R1) args: 0, res: 0, upd: 0;
       c4GR4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GR3() //  [R1]
         { info_tbl: [(c4GR3,
                       label: block_c4GR3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GR3: // global
           I64[Sp] = block_c4GR9_info;
           _s4Ftb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Ftb::I64;
           if (R1 & 7 != 0) goto u4GRx; else goto c4GRd;
       u4GRx: // global
           call _c4GR9(R1) args: 0, res: 0, upd: 0;
       c4GRd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GR9() //  [R1]
         { info_tbl: [(c4GR9,
                       label: block_c4GR9_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GR9: // global
           I64[Sp] = block_c4GRh_info;
           _s4Ftd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Ftd::I64;
           if (R1 & 7 != 0) goto u4GRz; else goto c4GRj;
       u4GRz: // global
           call _c4GRh(R1) args: 0, res: 0, upd: 0;
       c4GRj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GRh() //  [R1]
         { info_tbl: [(c4GRh,
                       label: block_c4GRh_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GRh: // global
           _s4Ftb::I64 = I64[Sp + 8];
           _s4Ftd::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto c4GRp; else goto c4GRt;
       c4GRp: // global
           I32[_s4Ftb::I64 + _s4Ftd::I64] = 0 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4GRt: // global
           I32[_s4Ftb::I64 + _s4Ftd::I64] = 1 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.190985884 UTC

[section ""data" . Foreign.Storable.$fStorableBool_closure" {
     Foreign.Storable.$fStorableBool_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableBool_$csizeOf_closure+1;
         const Foreign.Storable.$fStorableBool_$csizeOf_closure+1;
         const Foreign.Storable.$fStorableBool6_closure+3;
         const Foreign.Storable.$fStorableBool5_closure+4;
         const Foreign.Storable.$fStorableBool4_closure+3;
         const Foreign.Storable.$fStorableBool3_closure+4;
         const Foreign.Storable.$fStorableBool2_closure+2;
         const Foreign.Storable.$fStorableBool1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.1919482 UTC

[section ""data" . Foreign.Storable.$fStorable()2_closure" {
     Foreign.Storable.$fStorable()2_closure:
         const Foreign.Storable.$fStorable()2_info;
 },
 Foreign.Storable.$fStorable()2_entry() //  []
         { info_tbl: [(c4GRE,
                       label: Foreign.Storable.$fStorable()2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GRE: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.192990415 UTC

[section ""data" . Foreign.Storable.$fStorable()1_closure" {
     Foreign.Storable.$fStorable()1_closure:
         const Foreign.Storable.$fStorable()1_info;
 },
 Foreign.Storable.$fStorable()1_entry() //  []
         { info_tbl: [(c4GRL,
                       label: Foreign.Storable.$fStorable()1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GRL: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.194037781 UTC

[section ""data" . lvl11_r4Ffl_closure" {
     lvl11_r4Ffl_closure:
         const GHC.Types.I#_con_info;
         const 137;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.194740134 UTC

[section ""data" . lvl12_r4Ffm_closure" {
     lvl12_r4Ffm_closure:
         const GHC.Types.I#_con_info;
         const 31;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.19548465 UTC

[section ""data" . lvl13_r4Ffn_closure" {
     lvl13_r4Ffn_closure:
         const GHC.Types.I#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.196225778 UTC

[section ""data" . lvl14_r4Ffo_closure" {
     lvl14_r4Ffo_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r4Ffb_closure;
         const lvl3_r4Ffc_closure;
         const lvl5_r4Ffe_closure;
         const lvl11_r4Ffl_closure+1;
         const lvl12_r4Ffm_closure+1;
         const lvl11_r4Ffl_closure+1;
         const lvl13_r4Ffn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.197038038 UTC

[section ""data" . lvl15_r4Ffp_closure" {
     lvl15_r4Ffp_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r4Ffa_closure;
         const lvl14_r4Ffo_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.198194148 UTC

[section ""data" . lvl16_r4Ffq_closure" {
     lvl16_r4Ffq_closure:
         const lvl16_r4Ffq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_r4Ffq_entry() //  [R1]
         { info_tbl: [(c4GRU,
                       label: lvl16_r4Ffq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GRU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GRV; else goto c4GRW;
       c4GRV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GRW: // global
           (_c4GRR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4GRR::I64 == 0) goto c4GRT; else goto c4GRS;
       c4GRT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4GRS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4GRR::I64;
           R2 = lvl15_r4Ffp_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.200258544 UTC

[section ""data" . Foreign.Storable.$dmpeekElemOff_closure" {
     Foreign.Storable.$dmpeekElemOff_closure:
         const Foreign.Storable.$dmpeekElemOff_info;
         const 0;
 },
 sat_s4Ftw_entry() //  [R1]
         { info_tbl: [(c4GS8,
                       label: sat_s4Ftw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GS8: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c4GSj; else goto c4GSk;
       c4GSj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GSk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4GS5_info;
           _s4Fto::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s4Fto::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4GSp; else goto c4GS6;
       u4GSp: // global
           call _c4GS5(R1) args: 0, res: 0, upd: 0;
       c4GS6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4GS5() //  [R1]
         { info_tbl: [(c4GS5,
                       label: block_c4GS5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GS5: // global
           I64[Sp] = block_c4GSb_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = lvl16_r4Ffq_closure;
           I64[Sp + 8] = I64[R1 + 7];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c4GSb() //  [R1]
         { info_tbl: [(c4GSb,
                       label: block_c4GSb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GSb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GSo; else goto c4GSn;
       c4GSo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4GSn: // global
           _s4Ftv::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4Ftv::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$dmpeekElemOff_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GSq,
                       label: Foreign.Storable.$dmpeekElemOff_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GSq: // global
           _s4Ftq::P64 = R4;
           _s4Ftp::P64 = R3;
           _s4Fto::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c4GSr; else goto c4GSs;
       c4GSs: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4GSu; else goto c4GSt;
       c4GSu: // global
           HpAlloc = 32;
           goto c4GSr;
       c4GSr: // global
           R4 = _s4Ftq::P64;
           R3 = _s4Ftp::P64;
           R2 = _s4Fto::P64;
           R1 = Foreign.Storable.$dmpeekElemOff_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GSt: // global
           I64[Hp - 24] = sat_s4Ftw_info;
           P64[Hp - 8] = _s4Fto::P64;
           P64[Hp] = _s4Ftq::P64;
           R2 = _s4Fto::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s4Ftp::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Foreign.Storable.peekByteOff_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.203717691 UTC

[section ""data" . Foreign.Storable.$dmpokeElemOff_closure" {
     Foreign.Storable.$dmpokeElemOff_closure:
         const Foreign.Storable.$dmpokeElemOff_info;
 },
 sat_s4FtG_entry() //  [R1]
         { info_tbl: [(c4GSG,
                       label: sat_s4FtG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GSG: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c4GSR; else goto c4GSS;
       c4GSR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GSS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4GSD_info;
           _s4Ftx::P64 = P64[R1 + 16];
           _s4FtA::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _s4Ftx::P64;
           P64[Sp - 24] = _s4FtA::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u4GSX; else goto c4GSE;
       u4GSX: // global
           call _c4GSD(R1) args: 0, res: 0, upd: 0;
       c4GSE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4GSD() //  [R1]
         { info_tbl: [(c4GSD,
                       label: block_c4GSD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GSD: // global
           _s4Ftx::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4GSJ_info;
           R2 = _s4Ftx::P64;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = P64[Sp + 16];
           I64[Sp + 16] = I64[R1 + 7];
           Sp = Sp - 8;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c4GSJ() //  [R1]
         { info_tbl: [(c4GSJ,
                       label: block_c4GSJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GSJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GSW; else goto c4GSV;
       c4GSW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4GSV: // global
           _s4FtF::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4FtF::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$dmpokeElemOff_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c4GSY,
                       label: Foreign.Storable.$dmpokeElemOff_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GSY: // global
           _s4FtA::P64 = R5;
           _s4Ftz::P64 = R4;
           _s4Fty::P64 = R3;
           _s4Ftx::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto c4GSZ; else goto c4GT0;
       c4GT0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4GT2; else goto c4GT1;
       c4GT2: // global
           HpAlloc = 40;
           goto c4GSZ;
       c4GSZ: // global
           R5 = _s4FtA::P64;
           R4 = _s4Ftz::P64;
           R3 = _s4Fty::P64;
           R2 = _s4Ftx::P64;
           R1 = Foreign.Storable.$dmpokeElemOff_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GT1: // global
           I64[Hp - 32] = sat_s4FtG_info;
           P64[Hp - 16] = _s4Ftx::P64;
           P64[Hp - 8] = _s4Ftz::P64;
           P64[Hp] = _s4FtA::P64;
           R2 = _s4Ftx::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _s4Fty::P64;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _s4FtA::P64;
           Sp = Sp - 32;
           call Foreign.Storable.pokeByteOff_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.206325314 UTC

[section ""data" . Foreign.Storable.$fStorable()4_closure" {
     Foreign.Storable.$fStorable()4_closure:
         const Foreign.Storable.$fStorable()4_info;
 },
 Foreign.Storable.$fStorable()4_entry() //  []
         { info_tbl: [(c4GT7,
                       label: Foreign.Storable.$fStorable()4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GT7: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.207352069 UTC

[section ""data" . Foreign.Storable.$fStorable()6_closure" {
     Foreign.Storable.$fStorable()6_closure:
         const Foreign.Storable.$fStorable()6_info;
 },
 Foreign.Storable.$fStorable()6_entry() //  []
         { info_tbl: [(c4GTe,
                       label: Foreign.Storable.$fStorable()6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GTe: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.208455971 UTC

[section ""data" . Foreign.Storable.$fStorable()3_closure" {
     Foreign.Storable.$fStorable()3_closure:
         const Foreign.Storable.$fStorable()3_info;
 },
 Foreign.Storable.$fStorable()3_entry() //  []
         { info_tbl: [(c4GTl,
                       label: Foreign.Storable.$fStorable()3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GTl: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.209676626 UTC

[section ""data" . Foreign.Storable.$fStorable()5_closure" {
     Foreign.Storable.$fStorable()5_closure:
         const Foreign.Storable.$fStorable()5_info;
 },
 Foreign.Storable.$fStorable()5_entry() //  []
         { info_tbl: [(c4GTs,
                       label: Foreign.Storable.$fStorable()5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GTs: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.210619919 UTC

[section ""data" . Foreign.Storable.$fStorable()_closure" {
     Foreign.Storable.$fStorable()_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorable()_$csizeOf_closure+1;
         const Foreign.Storable.$fStorable()_$calignment_closure+1;
         const Foreign.Storable.$fStorable()6_closure+3;
         const Foreign.Storable.$fStorable()5_closure+4;
         const Foreign.Storable.$fStorable()4_closure+3;
         const Foreign.Storable.$fStorable()3_closure+4;
         const Foreign.Storable.$fStorable()2_closure+2;
         const Foreign.Storable.$fStorable()1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.211466319 UTC

[section ""data" . lvl17_r4Ffr_closure" {
     lvl17_r4Ffr_closure:
         const GHC.Types.I#_con_info;
         const 237;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.21227184 UTC

[section ""data" . lvl18_r4Ffs_closure" {
     lvl18_r4Ffs_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r4Ffb_closure;
         const lvl3_r4Ffc_closure;
         const lvl5_r4Ffe_closure;
         const lvl17_r4Ffr_closure+1;
         const lvl12_r4Ffm_closure+1;
         const lvl17_r4Ffr_closure+1;
         const lvl13_r4Ffn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.213070627 UTC

[section ""data" . lvl19_r4Fft_closure" {
     lvl19_r4Fft_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r4Ffa_closure;
         const lvl18_r4Ffs_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.214564127 UTC

[section ""data" . Foreign.Storable.$fStorableRatio6_closure" {
     Foreign.Storable.$fStorableRatio6_closure:
         const Foreign.Storable.$fStorableRatio6_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Storable.$fStorableRatio6_entry() //  [R1]
         { info_tbl: [(c4GTB,
                       label: Foreign.Storable.$fStorableRatio6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GTB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GTC; else goto c4GTD;
       c4GTC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GTD: // global
           (_c4GTy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4GTy::I64 == 0) goto c4GTA; else goto c4GTz;
       c4GTA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4GTz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4GTy::I64;
           R2 = lvl19_r4Fft_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.216653398 UTC

[section ""data" . Foreign.Storable.$fStorableRatio_$csizeOf_closure" {
     Foreign.Storable.$fStorableRatio_$csizeOf_closure:
         const Foreign.Storable.$fStorableRatio_$csizeOf_info;
         const 0;
 },
 lvl20_s4FtX_entry() //  [R1]
         { info_tbl: [(c4GTM,
                       label: lvl20_s4FtX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GTM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4GTN; else goto c4GTO;
       c4GTN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GTO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Storable.$fStorableRatio6_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s4Fu2_entry() //  [R1, R2]
         { info_tbl: [(c4GTX,
                       label: sat_s4Fu2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GTX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4GU4; else goto c4GU5;
       c4GU4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4GU5: // global
           I64[Sp - 8] = block_c4GTU_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GU9; else goto c4GTV;
       u4GU9: // global
           call _c4GTU(R1) args: 0, res: 0, upd: 0;
       c4GTV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GTU() //  [R1]
         { info_tbl: [(c4GTU,
                       label: block_c4GTU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GTU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GU8; else goto c4GU7;
       c4GU8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GU7: // global
           _s4Fu1::I64 = I64[R1 + 7] << 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4Fu1::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Storable.$fStorableRatio_$csizeOf_entry() //  [R2, R3]
         { info_tbl: [(c4GUa,
                       label: Foreign.Storable.$fStorableRatio_$csizeOf_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GUa: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4GUe; else goto c4GUd;
       c4GUe: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio_$csizeOf_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GUd: // global
           I64[Hp - 32] = lvl20_s4FtX_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s4Fu2_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.219743758 UTC

[section ""data" . Foreign.Storable.$fStorableRatio4_closure" {
     Foreign.Storable.$fStorableRatio4_closure:
         const Foreign.Storable.$fStorableRatio4_info;
         const 0;
 },
 sat_s4Fud_entry() //  [R1]
         { info_tbl: [(c4GUq,
                       label: sat_s4Fud_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GUq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4GUC; else goto c4GUD;
       c4GUC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GUD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4GUn_info;
           _s4Fu6::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4Fu6::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4GUJ; else goto c4GUo;
       u4GUJ: // global
           call _c4GUn(R1) args: 0, res: 0, upd: 0;
       c4GUo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4GUn() //  [R1]
         { info_tbl: [(c4GUn,
                       label: block_c4GUn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GUn: // global
           I64[Sp] = block_c4GUt_info;
           _s4Fu9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fu9::I64;
           if (R1 & 7 != 0) goto u4GUI; else goto c4GUu;
       u4GUI: // global
           call _c4GUt(R1) args: 0, res: 0, upd: 0;
       c4GUu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4GUt() //  [R1]
         { info_tbl: [(c4GUt,
                       label: block_c4GUt_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GUt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GUH; else goto c4GUG;
       c4GUH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4GUG: // global
           _s4Fuc::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fuc::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableRatio4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c4GUK,
                       label: Foreign.Storable.$fStorableRatio4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GUK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4GUO; else goto c4GUN;
       c4GUO: // global
           HpAlloc = 32;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GUN: // global
           I64[Hp - 24] = sat_s4Fud_info;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R4 = Hp - 24;
           R3 = R3;
           R2 = R2;
           call Foreign.Storable.$fStorableRatio2_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.222917099 UTC

[section ""data" . Foreign.Storable.$fStorableRatio7_closure" {
     Foreign.Storable.$fStorableRatio7_closure:
         const Foreign.Storable.$fStorableRatio7_info;
         const 0;
 },
 sat_s4Fus_entry() //  [R1]
         { info_tbl: [(c4GV0,
                       label: sat_s4Fus_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GV0: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c4GVm; else goto c4GVn;
       c4GVm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GVn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4GUX_info;
           _s4Fue::P64 = P64[R1 + 16];
           _s4Fuh::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _s4Fue::P64;
           P64[Sp - 24] = _s4Fuh::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u4GVu; else goto c4GUY;
       u4GVu: // global
           call _c4GUX(R1) args: 0, res: 0, upd: 0;
       c4GUY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4GUX() //  [R1]
         { info_tbl: [(c4GUX,
                       label: block_c4GUX_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GUX: // global
           I64[Sp] = block_c4GV3_info;
           _s4Fuk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fuk::I64;
           if (R1 & 7 != 0) goto u4GVt; else goto c4GV4;
       u4GVt: // global
           call _c4GV3(R1) args: 0, res: 0, upd: 0;
       c4GV4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4GV3() //  [R1]
         { info_tbl: [(c4GV3,
                       label: block_c4GV3_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GV3: // global
           I64[Sp] = block_c4GV8_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Foreign.Storable.$fStorableRatio6_closure;
           I64[Sp + 8] = I64[R1 + 7];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c4GV8() //  [R1]
         { info_tbl: [(c4GV8,
                       label: block_c4GV8_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GV8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GVs; else goto c4GVr;
       c4GVs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4GVr: // global
           _s4Fur::I64 = I64[Sp + 16] + I64[Sp + 8] * (I64[R1 + 7] << 1);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fur::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableRatio7_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c4GVv,
                       label: Foreign.Storable.$fStorableRatio7_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GVv: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4GVz; else goto c4GVy;
       c4GVz: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio7_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GVy: // global
           I64[Hp - 32] = sat_s4Fus_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R4 = Hp - 32;
           R3 = R3;
           R2 = R2;
           call Foreign.Storable.$fStorableRatio2_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.228062176 UTC

[section ""data" . Foreign.Storable.$w$cpokeByteOff_closure" {
     Foreign.Storable.$w$cpokeByteOff_closure:
         const Foreign.Storable.$w$cpokeByteOff_info;
 },
 p_s4Fuz_entry() //  [R1]
         { info_tbl: [(c4GVL,
                       label: p_s4Fuz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GVL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4GVX; else goto c4GVY;
       c4GVX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GVY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4GVI_info;
           _s4Fuv::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4Fuv::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4GW4; else goto c4GVJ;
       u4GW4: // global
           call _c4GVI(R1) args: 0, res: 0, upd: 0;
       c4GVJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4GVI() //  [R1]
         { info_tbl: [(c4GVI,
                       label: block_c4GVI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GVI: // global
           I64[Sp] = block_c4GVO_info;
           _s4FuB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FuB::I64;
           if (R1 & 7 != 0) goto u4GW3; else goto c4GVP;
       u4GW3: // global
           call _c4GVO(R1) args: 0, res: 0, upd: 0;
       c4GVP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4GVO() //  [R1]
         { info_tbl: [(c4GVO,
                       label: block_c4GVO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GVO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GW2; else goto c4GW1;
       c4GW2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4GW1: // global
           _s4FuE::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4FuE::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$w$cpokeByteOff_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c4GW7,
                       label: Foreign.Storable.$w$cpokeByteOff_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GW7: // global
           _s4Fux::P64 = R6;
           _s4Fuw::P64 = R5;
           _s4Fuv::P64 = R4;
           _s4Fuu::P64 = R3;
           _s4Fut::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto c4GW8; else goto c4GW9;
       c4GW9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4GWb; else goto c4GWa;
       c4GWb: // global
           HpAlloc = 32;
           goto c4GW8;
       c4GW8: // global
           R6 = _s4Fux::P64;
           R5 = _s4Fuw::P64;
           R4 = _s4Fuv::P64;
           R3 = _s4Fuu::P64;
           R2 = _s4Fut::P64;
           R1 = Foreign.Storable.$w$cpokeByteOff_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GWa: // global
           I64[Hp - 24] = p_s4Fuz_info;
           P64[Hp - 8] = _s4Fuu::P64;
           P64[Hp] = _s4Fuv::P64;
           I64[Sp - 32] = block_c4GW5_info;
           R2 = _s4Fut::P64;
           I64[Sp - 56] = stg_ap_ppv_info;
           _c4GVE::P64 = Hp - 24;
           P64[Sp - 48] = _c4GVE::P64;
           P64[Sp - 40] = _s4Fuw::P64;
           P64[Sp - 24] = _c4GVE::P64;
           P64[Sp - 16] = _s4Fut::P64;
           P64[Sp - 8] = _s4Fux::P64;
           Sp = Sp - 56;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c4GW5() //  []
         { info_tbl: [(c4GW5,
                       label: block_c4GW5_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GW5: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppv_info;
           P64[Sp + 16] = Foreign.Storable.$fStorable()7_closure+1;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.230690941 UTC

[section ""data" . Foreign.Storable.$fStorableRatio3_closure" {
     Foreign.Storable.$fStorableRatio3_closure:
         const Foreign.Storable.$fStorableRatio3_info;
 },
 Foreign.Storable.$fStorableRatio3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c4GWk,
                       label: Foreign.Storable.$fStorableRatio3_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GWk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4GWl; else goto c4GWm;
       c4GWl: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GWm: // global
           I64[Sp - 32] = block_c4GWh_info;
           R1 = R6;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4GWq; else goto c4GWi;
       u4GWq: // global
           call _c4GWh(R1) args: 0, res: 0, upd: 0;
       c4GWi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GWh() //  [R1]
         { info_tbl: [(c4GWh,
                       label: block_c4GWh_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GWh: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Foreign.Storable.$w$cpokeByteOff_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.233191166 UTC

[section ""data" . Foreign.Storable.$w$cpokeElemOff_closure" {
     Foreign.Storable.$w$cpokeElemOff_closure:
         const Foreign.Storable.$w$cpokeElemOff_info;
         const 0;
 },
 p_s4FuX_entry() //  [R1]
         { info_tbl: [(c4GWC,
                       label: p_s4FuX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GWC: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c4GWY; else goto c4GWZ;
       c4GWY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GWZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4GWz_info;
           _s4FuR::P64 = P64[R1 + 16];
           _s4FuT::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _s4FuR::P64;
           P64[Sp - 24] = _s4FuT::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u4GX6; else goto c4GWA;
       u4GX6: // global
           call _c4GWz(R1) args: 0, res: 0, upd: 0;
       c4GWA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4GWz() //  [R1]
         { info_tbl: [(c4GWz,
                       label: block_c4GWz_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GWz: // global
           I64[Sp] = block_c4GWF_info;
           _s4FuZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FuZ::I64;
           if (R1 & 7 != 0) goto u4GX5; else goto c4GWG;
       u4GX5: // global
           call _c4GWF(R1) args: 0, res: 0, upd: 0;
       c4GWG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4GWF() //  [R1]
         { info_tbl: [(c4GWF,
                       label: block_c4GWF_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GWF: // global
           I64[Sp] = block_c4GWK_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Foreign.Storable.$fStorableRatio6_closure;
           I64[Sp + 8] = I64[R1 + 7];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c4GWK() //  [R1]
         { info_tbl: [(c4GWK,
                       label: block_c4GWK_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GWK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GX4; else goto c4GX3;
       c4GX4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4GX3: // global
           _s4Fv6::I64 = I64[Sp + 16] + I64[Sp + 8] * (I64[R1 + 7] << 1);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fv6::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$w$cpokeElemOff_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c4GX9,
                       label: Foreign.Storable.$w$cpokeElemOff_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GX9: // global
           _s4FuV::P64 = R6;
           _s4FuU::P64 = R5;
           _s4FuT::P64 = R4;
           _s4FuS::P64 = R3;
           _s4FuR::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto c4GXa; else goto c4GXb;
       c4GXb: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4GXd; else goto c4GXc;
       c4GXd: // global
           HpAlloc = 40;
           goto c4GXa;
       c4GXa: // global
           R6 = _s4FuV::P64;
           R5 = _s4FuU::P64;
           R4 = _s4FuT::P64;
           R3 = _s4FuS::P64;
           R2 = _s4FuR::P64;
           R1 = Foreign.Storable.$w$cpokeElemOff_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GXc: // global
           I64[Hp - 32] = p_s4FuX_info;
           P64[Hp - 16] = _s4FuR::P64;
           P64[Hp - 8] = _s4FuS::P64;
           P64[Hp] = _s4FuT::P64;
           I64[Sp - 32] = block_c4GX7_info;
           R2 = _s4FuR::P64;
           I64[Sp - 56] = stg_ap_ppv_info;
           _c4GWv::P64 = Hp - 32;
           P64[Sp - 48] = _c4GWv::P64;
           P64[Sp - 40] = _s4FuU::P64;
           P64[Sp - 24] = _c4GWv::P64;
           P64[Sp - 16] = _s4FuR::P64;
           P64[Sp - 8] = _s4FuV::P64;
           Sp = Sp - 56;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c4GX7() //  []
         { info_tbl: [(c4GX7,
                       label: block_c4GX7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GX7: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppv_info;
           P64[Sp + 16] = Foreign.Storable.$fStorable()7_closure+1;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.237384634 UTC

[section ""data" . Foreign.Storable.$fStorableRatio5_closure" {
     Foreign.Storable.$fStorableRatio5_closure:
         const Foreign.Storable.$fStorableRatio5_info;
         const 0;
 },
 Foreign.Storable.$fStorableRatio5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c4GXm,
                       label: Foreign.Storable.$fStorableRatio5_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GXm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4GXn; else goto c4GXo;
       c4GXn: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GXo: // global
           I64[Sp - 32] = block_c4GXj_info;
           R1 = R6;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4GXs; else goto c4GXk;
       u4GXs: // global
           call _c4GXj(R1) args: 0, res: 0, upd: 0;
       c4GXk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GXj() //  [R1]
         { info_tbl: [(c4GXj,
                       label: block_c4GXj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GXj: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Foreign.Storable.$w$cpokeElemOff_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.240496089 UTC

[section ""data" . Foreign.Storable.$fStorableRatio_closure" {
     Foreign.Storable.$fStorableRatio_closure:
         const Foreign.Storable.$fStorableRatio_info;
         const 0;
 },
 sat_s4Fvs_entry() //  [R1, R2, R3]
         { info_tbl: [(c4GXC,
                       label: sat_s4Fvs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GXC: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Foreign.Storable.$fStorableRatio1_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fvr_entry() //  [R1, R2]
         { info_tbl: [(c4GXK,
                       label: sat_s4Fvr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GXK: // global
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Foreign.Storable.$fStorableRatio2_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fvq_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c4GXS,
                       label: sat_s4Fvq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GXS: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           call Foreign.Storable.$fStorableRatio3_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fvp_entry() //  [R1, R2, R3]
         { info_tbl: [(c4GY0,
                       label: sat_s4Fvp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GY0: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Foreign.Storable.$fStorableRatio4_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fvo_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c4GY8,
                       label: sat_s4Fvo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GY8: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           call Foreign.Storable.$fStorableRatio5_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fvn_entry() //  [R1, R2, R3]
         { info_tbl: [(c4GYg,
                       label: sat_s4Fvn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GYg: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Foreign.Storable.$fStorableRatio7_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fvm_entry() //  [R1]
         { info_tbl: [(c4GYn,
                       label: sat_s4Fvm_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GYn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GYo; else goto c4GYp;
       c4GYo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GYp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.$fStorableRatio_$calignment_entry(R3,
                                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4Fvl_entry() //  [R1]
         { info_tbl: [(c4GYu,
                       label: sat_s4Fvl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GYu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4GYv; else goto c4GYw;
       c4GYv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GYw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.$fStorableRatio_$csizeOf_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableRatio_entry() //  [R2, R3]
         { info_tbl: [(c4GYy,
                       label: Foreign.Storable.$fStorableRatio_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GYy: // global
           Hp = Hp + 280;
           if (Hp > HpLim) (likely: False) goto c4GYC; else goto c4GYB;
       c4GYC: // global
           HpAlloc = 280;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GYB: // global
           I64[Hp - 272] = sat_s4Fvs_info;
           P64[Hp - 264] = R2;
           P64[Hp - 256] = R3;
           I64[Hp - 248] = sat_s4Fvr_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           I64[Hp - 224] = sat_s4Fvq_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           I64[Hp - 200] = sat_s4Fvp_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_s4Fvo_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_s4Fvn_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = sat_s4Fvm_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_s4Fvl_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = Foreign.Storable.C:Storable_con_info;
           P64[Hp - 56] = Hp - 96;
           P64[Hp - 48] = Hp - 128;
           P64[Hp - 40] = Hp - 149;
           P64[Hp - 32] = Hp - 172;
           P64[Hp - 24] = Hp - 197;
           P64[Hp - 16] = Hp - 220;
           P64[Hp - 8] = Hp - 246;
           P64[Hp] = Hp - 269;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.245232834 UTC

[section ""data" . Foreign.Storable.$wpokeW64_closure" {
     Foreign.Storable.$wpokeW64_closure:
         const Foreign.Storable.$wpokeW64_info;
 },
 Foreign.Storable.$wpokeW64_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GZ6,
                       label: Foreign.Storable.$wpokeW64_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GZ6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4GZ7; else goto u4GZe;
       c4GZ7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$wpokeW64_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u4GZe: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c4GYE() args: 0, res: 0, upd: 0;
     }
 },
 _c4GYE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GYE: // global
           _s4Fvx::I64 = I64[Sp + 8];
           if (_s4Fvx::I64 != 0) goto c4GZ4; else goto c4GZ5;
       c4GZ4: // global
           I64[Sp - 8] = block_c4GYJ_info;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fvx::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GZg; else goto c4GYK;
       u4GZg: // global
           call _c4GYJ(R1) args: 0, res: 0, upd: 0;
       c4GYK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4GZ5: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4GYJ() //  [R1]
         { info_tbl: [(c4GYJ,
                       label: block_c4GYJ_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GYJ: // global
           _s4Fvt::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4GYO_info;
           _s4Fvz::I64 = I64[R1 + 7];
           R1 = _s4Fvt::P64;
           I64[Sp + 16] = _s4Fvz::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4GZh; else goto c4GYP;
       u4GZh: // global
           call _c4GYO(R1) args: 0, res: 0, upd: 0;
       c4GYP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GYO() //  [R1]
         { info_tbl: [(c4GYO,
                       label: block_c4GYO_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GYO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GZc; else goto c4GZb;
       c4GZc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GZb: // global
           _s4Fvx::I64 = I64[Sp + 16];
           _s4Fvz::I64 = I64[Sp + 8];
           I8[I64[R1 + 7] + (_s4Fvx::I64 + -1)] = %MO_UU_Conv_W64_W8(_s4Fvz::I64);
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4Fvz::I64 >> 8;
           P64[Sp] = R1;
           I64[Sp + 8] = _s4Fvx::I64 - 1;
           P64[Sp + 16] = Hp - 7;
           call _c4GYE() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.248218505 UTC

[section ""data" . Foreign.Storable.$w$cpoke_closure" {
     Foreign.Storable.$w$cpoke_closure:
         const Foreign.Storable.$w$cpoke_info;
 },
 sat_s4FvT_entry() //  [R1]
         { info_tbl: [(c4GZz,
                       label: sat_s4FvT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GZz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4GZG; else goto c4GZH;
       c4GZG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4GZH: // global
           I64[Sp - 8] = block_c4GZw_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4GZL; else goto c4GZx;
       u4GZL: // global
           call _c4GZw(R1) args: 0, res: 0, upd: 0;
       c4GZx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GZw() //  [R1]
         { info_tbl: [(c4GZw,
                       label: block_c4GZw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GZw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GZK; else goto c4GZJ;
       c4GZK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GZJ: // global
           _s4FvS::I64 = I64[R1 + 7] + 8;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4FvS::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Storable.$w$cpoke_entry() //  [R2, R3, R4]
         { info_tbl: [(c4GZM,
                       label: Foreign.Storable.$w$cpoke_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 20} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GZM: // global
           _s4FvK::I64 = R4;
           _s4FvJ::I64 = R3;
           _s4FvI::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c4GZN; else goto c4GZO;
       c4GZO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4GZQ; else goto c4GZP;
       c4GZQ: // global
           HpAlloc = 16;
           goto c4GZN;
       c4GZN: // global
           R4 = _s4FvK::I64;
           R3 = _s4FvJ::I64;
           R2 = _s4FvI::P64;
           R1 = Foreign.Storable.$w$cpoke_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4GZP: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4FvJ::I64;
           I64[Sp - 24] = block_c4GZp_info;
           R4 = Hp - 7;
           R3 = 8;
           R2 = _s4FvI::P64;
           P64[Sp - 16] = _s4FvI::P64;
           I64[Sp - 8] = _s4FvK::I64;
           Sp = Sp - 24;
           call Foreign.Storable.$wpokeW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4GZp() //  [R1]
         { info_tbl: [(c4GZp,
                       label: block_c4GZp_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GZp: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4GZT; else goto c4GZS;
       c4GZT: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4GZS: // global
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = sat_s4FvT_info;
           P64[Hp] = P64[Sp + 8];
           R4 = Hp - 31;
           R3 = 8;
           R2 = Hp - 16;
           Sp = Sp + 24;
           call Foreign.Storable.$wpokeW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.250956241 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint1_closure" {
     Foreign.Storable.$fStorableFingerprint1_closure:
         const Foreign.Storable.$fStorableFingerprint1_info;
 },
 Foreign.Storable.$fStorableFingerprint1_entry() //  [R2, R3]
         { info_tbl: [(c4H01,
                       label: Foreign.Storable.$fStorableFingerprint1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H01: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4H02; else goto c4H03;
       c4H02: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4H03: // global
           I64[Sp - 16] = block_c4GZY_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4H07; else goto c4GZZ;
       u4H07: // global
           call _c4GZY(R1) args: 0, res: 0, upd: 0;
       c4GZZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4GZY() //  [R1]
         { info_tbl: [(c4GZY,
                       label: block_c4GZY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4GZY: // global
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.Storable.$w$cpoke_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.253216002 UTC

[section ""data" . Foreign.Storable.$wpeekW64_closure" {
     Foreign.Storable.$wpeekW64_closure:
         const Foreign.Storable.$wpeekW64_info;
 },
 Foreign.Storable.$wpeekW64_entry() //  [R2, R3, R4]
         { info_tbl: [(c4H0z,
                       label: Foreign.Storable.$wpeekW64_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 20} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H0z: // global
           if ((Sp + -24) < SpLim) (likely: False) goto u4H0K; else goto u4H0J;
       u4H0K: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c4H0A() args: 0, res: 0, upd: 0;
       u4H0J: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c4H09() args: 0, res: 0, upd: 0;
     }
 },
 _c4H09() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H09: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4H0D; else goto c4H0C;
       c4H0D: // global
           HpAlloc = 16;
           call _c4H0A() args: 0, res: 0, upd: 0;
       c4H0C: // global
           _s4Fw5::I64 = I64[Sp + 8];
           if (_s4Fw5::I64 != 0) goto c4H0x; else goto c4H0y;
       c4H0x: // global
           Hp = Hp - 16;
           _s4Fw1::P64 = P64[Sp];
           I64[Sp] = block_c4H0e_info;
           R1 = _s4Fw1::P64;
           I64[Sp + 8] = _s4Fw5::I64;
           if (R1 & 7 != 0) goto u4H0M; else goto c4H0f;
       u4H0M: // global
           call _c4H0e(R1) args: 0, res: 0, upd: 0;
       c4H0f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4H0y: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4H0A() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H0A: // global
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = Foreign.Storable.$wpeekW64_closure;
           Sp = Sp + 24;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4H0e() //  [R1]
         { info_tbl: [(c4H0e,
                       label: block_c4H0e_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H0e: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4H0G; else goto c4H0F;
       c4H0G: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4H0F: // global
           _s4Fw7::I64 = I64[R1 + 7];
           _s4Fwf::I64 = (I64[Sp + 16] << 8) | %MO_UU_Conv_W8_W64(I8[_s4Fw7::I64]);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fw7::I64 + 1;
           P64[Sp] = Hp - 7;
           I64[Sp + 8] = I64[Sp + 8] - 1;
           I64[Sp + 16] = _s4Fwf::I64;
           call _c4H09() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.256615459 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint2_closure" {
     Foreign.Storable.$fStorableFingerprint2_closure:
         const Foreign.Storable.$fStorableFingerprint2_info;
 },
 sat_s4Fwp_entry() //  [R1]
         { info_tbl: [(c4H14,
                       label: sat_s4Fwp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H14: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4H1b; else goto c4H1c;
       c4H1b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4H1c: // global
           I64[Sp - 8] = block_c4H11_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4H1g; else goto c4H12;
       u4H1g: // global
           call _c4H11(R1) args: 0, res: 0, upd: 0;
       c4H12: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4H11() //  [R1]
         { info_tbl: [(c4H11,
                       label: block_c4H11_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H11: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4H1f; else goto c4H1e;
       c4H1f: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4H1e: // global
           _s4Fwo::I64 = I64[R1 + 7] + 8;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fwo::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fwt_entry() //  [R1]
         { info_tbl: [(c4H1n,
                       label: sat_s4Fwt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H1n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4H1o; else goto c4H1p;
       c4H1o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4H1p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$WFingerprint_entry(R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableFingerprint2_entry() //  [R2]
         { info_tbl: [(c4H1q,
                       label: Foreign.Storable.$fStorableFingerprint2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H1q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4H1r; else goto c4H1s;
       c4H1r: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4H1s: // global
           I64[Sp - 16] = block_c4H0V_info;
           R4 = 0;
           R3 = 8;
           _s4Fwh::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s4Fwh::P64;
           Sp = Sp - 16;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4H0V() //  [R1]
         { info_tbl: [(c4H0V,
                       label: block_c4H0V_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H0V: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4H1v; else goto c4H1u;
       c4H1v: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4H1u: // global
           I64[Hp - 16] = sat_s4Fwp_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_c4H1h_info;
           R4 = 0;
           R3 = 8;
           R2 = Hp - 16;
           P64[Sp + 8] = R1;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4H1h() //  [R1]
         { info_tbl: [(c4H1h,
                       label: block_c4H1h_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H1h: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4H1y; else goto c4H1x;
       c4H1y: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4H1x: // global
           I64[Hp - 24] = sat_s4Fwt_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.260380254 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint4_closure" {
     Foreign.Storable.$fStorableFingerprint4_closure:
         const Foreign.Storable.$fStorableFingerprint4_info;
 },
 sat_s4FwC_entry() //  [R1]
         { info_tbl: [(c4H1K,
                       label: sat_s4FwC_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H1K: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4H1W; else goto c4H1X;
       c4H1W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4H1X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4H1H_info;
           _s4Fwv::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4Fwv::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4H23; else goto c4H1I;
       u4H23: // global
           call _c4H1H(R1) args: 0, res: 0, upd: 0;
       c4H1I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4H1H() //  [R1]
         { info_tbl: [(c4H1H,
                       label: block_c4H1H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H1H: // global
           I64[Sp] = block_c4H1N_info;
           _s4Fwy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fwy::I64;
           if (R1 & 7 != 0) goto u4H22; else goto c4H1O;
       u4H22: // global
           call _c4H1N(R1) args: 0, res: 0, upd: 0;
       c4H1O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4H1N() //  [R1]
         { info_tbl: [(c4H1N,
                       label: block_c4H1N_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H1N: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4H21; else goto c4H20;
       c4H21: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4H20: // global
           _s4FwB::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4FwB::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableFingerprint4_entry() //  [R2, R3]
         { info_tbl: [(c4H24,
                       label: Foreign.Storable.$fStorableFingerprint4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H24: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4H28; else goto c4H27;
       c4H28: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4H27: // global
           I64[Hp - 24] = sat_s4FwC_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           call Foreign.Storable.$fStorableFingerprint2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.263402132 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint6_closure" {
     Foreign.Storable.$fStorableFingerprint6_closure:
         const Foreign.Storable.$fStorableFingerprint6_info;
 },
 sat_s4FwM_entry() //  [R1]
         { info_tbl: [(c4H2k,
                       label: sat_s4FwM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H2k: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4H2z; else goto c4H2A;
       c4H2z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4H2A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4H2h_info;
           _s4FwE::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4FwE::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4H2G; else goto c4H2i;
       u4H2G: // global
           call _c4H2h(R1) args: 0, res: 0, upd: 0;
       c4H2i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4H2h() //  [R1]
         { info_tbl: [(c4H2h,
                       label: block_c4H2h_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H2h: // global
           I64[Sp] = block_c4H2n_info;
           _s4FwH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FwH::I64;
           if (R1 & 7 != 0) goto u4H2F; else goto c4H2o;
       u4H2F: // global
           call _c4H2n(R1) args: 0, res: 0, upd: 0;
       c4H2o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4H2n() //  [R1]
         { info_tbl: [(c4H2n,
                       label: block_c4H2n_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H2n: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4H2E; else goto c4H2D;
       c4H2E: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4H2D: // global
           _s4FwL::I64 = I64[Sp + 8] + (I64[R1 + 7] << 4);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4FwL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableFingerprint6_entry() //  [R2, R3]
         { info_tbl: [(c4H2H,
                       label: Foreign.Storable.$fStorableFingerprint6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H2H: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4H2L; else goto c4H2K;
       c4H2L: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4H2K: // global
           I64[Hp - 24] = sat_s4FwM_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           call Foreign.Storable.$fStorableFingerprint2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.266371946 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint3_closure" {
     Foreign.Storable.$fStorableFingerprint3_closure:
         const Foreign.Storable.$fStorableFingerprint3_info;
 },
 sat_s4FwZ_entry() //  [R1]
         { info_tbl: [(c4H32,
                       label: sat_s4FwZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H32: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4H3e; else goto c4H3f;
       c4H3e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4H3f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4H2Z_info;
           _s4FwO::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4FwO::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4H3l; else goto c4H30;
       u4H3l: // global
           call _c4H2Z(R1) args: 0, res: 0, upd: 0;
       c4H30: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4H2Z() //  [R1]
         { info_tbl: [(c4H2Z,
                       label: block_c4H2Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H2Z: // global
           I64[Sp] = block_c4H35_info;
           _s4FwV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FwV::I64;
           if (R1 & 7 != 0) goto u4H3k; else goto c4H36;
       u4H3k: // global
           call _c4H35(R1) args: 0, res: 0, upd: 0;
       c4H36: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4H35() //  [R1]
         { info_tbl: [(c4H35,
                       label: block_c4H35_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H35: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4H3j; else goto c4H3i;
       c4H3j: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4H3i: // global
           _s4FwY::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4FwY::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableFingerprint3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4H3m,
                       label: Foreign.Storable.$fStorableFingerprint3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H3m: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4H3n; else goto c4H3o;
       c4H3n: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4H3o: // global
           I64[Sp - 24] = block_c4H2Q_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4H3s; else goto c4H2R;
       u4H3s: // global
           call _c4H2Q(R1) args: 0, res: 0, upd: 0;
       c4H2R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4H2Q() //  [R1]
         { info_tbl: [(c4H2Q,
                       label: block_c4H2Q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H2Q: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4H3r; else goto c4H3q;
       c4H3r: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4H3q: // global
           _s4FwS::I64 = I64[R1 + 7];
           _s4FwT::I64 = I64[R1 + 15];
           I64[Hp - 24] = sat_s4FwZ_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = _s4FwT::I64;
           R3 = _s4FwS::I64;
           R2 = Hp - 24;
           Sp = Sp + 24;
           call Foreign.Storable.$w$cpoke_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.269850533 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint5_closure" {
     Foreign.Storable.$fStorableFingerprint5_closure:
         const Foreign.Storable.$fStorableFingerprint5_info;
 },
 sat_s4Fxd_entry() //  [R1]
         { info_tbl: [(c4H3J,
                       label: sat_s4Fxd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H3J: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4H3Y; else goto c4H3Z;
       c4H3Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4H3Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4H3G_info;
           _s4Fx1::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4Fx1::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4H45; else goto c4H3H;
       u4H45: // global
           call _c4H3G(R1) args: 0, res: 0, upd: 0;
       c4H3H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4H3G() //  [R1]
         { info_tbl: [(c4H3G,
                       label: block_c4H3G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H3G: // global
           I64[Sp] = block_c4H3M_info;
           _s4Fx8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fx8::I64;
           if (R1 & 7 != 0) goto u4H44; else goto c4H3N;
       u4H44: // global
           call _c4H3M(R1) args: 0, res: 0, upd: 0;
       c4H3N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4H3M() //  [R1]
         { info_tbl: [(c4H3M,
                       label: block_c4H3M_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H3M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4H43; else goto c4H42;
       c4H43: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4H42: // global
           _s4Fxc::I64 = I64[Sp + 8] + (I64[R1 + 7] << 4);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fxc::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableFingerprint5_entry() //  [R2, R3, R4]
         { info_tbl: [(c4H46,
                       label: Foreign.Storable.$fStorableFingerprint5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H46: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4H47; else goto c4H48;
       c4H47: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4H48: // global
           I64[Sp - 24] = block_c4H3x_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4H4c; else goto c4H3y;
       u4H4c: // global
           call _c4H3x(R1) args: 0, res: 0, upd: 0;
       c4H3y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4H3x() //  [R1]
         { info_tbl: [(c4H3x,
                       label: block_c4H3x_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H3x: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4H4b; else goto c4H4a;
       c4H4b: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4H4a: // global
           _s4Fx5::I64 = I64[R1 + 7];
           _s4Fx6::I64 = I64[R1 + 15];
           I64[Hp - 24] = sat_s4Fxd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = _s4Fx6::I64;
           R3 = _s4Fx5::I64;
           R2 = Hp - 24;
           Sp = Sp + 24;
           call Foreign.Storable.$w$cpoke_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.272718743 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint_closure" {
     Foreign.Storable.$fStorableFingerprint_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableFingerprint_$csizeOf_closure+1;
         const Foreign.Storable.$fStorableFingerprint_$calignment_closure+1;
         const Foreign.Storable.$fStorableFingerprint6_closure+3;
         const Foreign.Storable.$fStorableFingerprint5_closure+4;
         const Foreign.Storable.$fStorableFingerprint4_closure+3;
         const Foreign.Storable.$fStorableFingerprint3_closure+4;
         const Foreign.Storable.$fStorableFingerprint2_closure+2;
         const Foreign.Storable.$fStorableFingerprint1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.27438948 UTC

[section ""data" . Foreign.Storable.C:Storable_closure" {
     Foreign.Storable.C:Storable_closure:
         const Foreign.Storable.C:Storable_info;
 },
 Foreign.Storable.C:Storable_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H4e: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Foreign.Storable.C:Storable_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 32, res: 0, upd: 8;
     }
 },
 Foreign.Storable.C:Storable_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c4H4j,
                       label: Foreign.Storable.C:Storable_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H4j: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4H4n; else goto c4H4m;
       c4H4n: // global
           HpAlloc = 72;
           R1 = Foreign.Storable.C:Storable_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c4H4m: // global
           I64[Hp - 64] = Foreign.Storable.C:Storable_con_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = R6;
           P64[Hp - 16] = P64[Sp];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 63;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.275946544 UTC

[Foreign.Storable.C:Storable_con_entry() //  [R1]
         { info_tbl: [(c4H4o,
                       label: Foreign.Storable.C:Storable_con_info
                       rep:HeapRep 8 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,70,111,114,101,105,103,110,46,83,116,111,114,97,98,108,101,46,67,58,83,116,111,114,97,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H4o: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.276673745 UTC

[section ""relreadonly" . S4FBN_srt" {
     S4FBN_srt:
         const GHC.Err.undefined_closure;
         const lvl10_r4Ffj_closure;
         const Foreign.Storable.$fStorableRatio8_closure;
         const Foreign.Storable.$fStorableRatio_$calignment_closure;
         const GHC.Real.%_closure;
         const Foreign.Storable.$fStorableRatio2_closure;
         const lvl15_r4Ffp_closure;
         const lvl16_r4Ffq_closure;
         const Foreign.Storable.$dmpeekElemOff_closure;
         const lvl19_r4Fft_closure;
         const Foreign.Storable.$fStorableRatio6_closure;
         const Foreign.Storable.$fStorableRatio_$csizeOf_closure;
         const Foreign.Storable.$fStorableRatio4_closure;
         const Foreign.Storable.$fStorableRatio7_closure;
         const Foreign.Storable.$w$cpokeElemOff_closure;
         const Foreign.Storable.$fStorableRatio5_closure;
         const Foreign.Storable.$fStorableRatio_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.277657813 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:31.279163344 UTC

[section ""data" . Foreign.Storable.sizeOf_closure" {
     Foreign.Storable.sizeOf_closure:
         const Foreign.Storable.sizeOf_info;
 },
 Foreign.Storable.sizeOf_entry() //  [R2]
         { info_tbl: [(c4H4x,
                       label: Foreign.Storable.sizeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H4x: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4H4y; else goto c4H4z;
       c4H4y: // global
           R2 = R2;
           R1 = Foreign.Storable.sizeOf_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4H4z: // global
           I64[Sp - 8] = block_c4H4u_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4H4D; else goto c4H4v;
       u4H4D: // global
           call _c4H4u(R1) args: 0, res: 0, upd: 0;
       c4H4v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4H4u() //  [R1]
         { info_tbl: [(c4H4u,
                       label: block_c4H4u_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H4u: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.287126817 UTC

[section ""data" . Foreign.Storable.alignment_closure" {
     Foreign.Storable.alignment_closure:
         const Foreign.Storable.alignment_info;
 },
 Foreign.Storable.alignment_entry() //  [R2]
         { info_tbl: [(c4H4U,
                       label: Foreign.Storable.alignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H4U: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4H4V; else goto c4H4W;
       c4H4V: // global
           R2 = R2;
           R1 = Foreign.Storable.alignment_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4H4W: // global
           I64[Sp - 8] = block_c4H4R_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4H50; else goto c4H4S;
       u4H50: // global
           call _c4H4R(R1) args: 0, res: 0, upd: 0;
       c4H4S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4H4R() //  [R1]
         { info_tbl: [(c4H4R,
                       label: block_c4H4R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H4R: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.292771763 UTC

[section ""data" . Foreign.Storable.peekElemOff_closure" {
     Foreign.Storable.peekElemOff_closure:
         const Foreign.Storable.peekElemOff_info;
 },
 Foreign.Storable.peekElemOff_entry() //  [R2]
         { info_tbl: [(c4H5h,
                       label: Foreign.Storable.peekElemOff_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H5h: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4H5i; else goto c4H5j;
       c4H5i: // global
           R2 = R2;
           R1 = Foreign.Storable.peekElemOff_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4H5j: // global
           I64[Sp - 8] = block_c4H5e_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4H5n; else goto c4H5f;
       u4H5n: // global
           call _c4H5e(R1) args: 0, res: 0, upd: 0;
       c4H5f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4H5e() //  [R1]
         { info_tbl: [(c4H5e,
                       label: block_c4H5e_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H5e: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.29875308 UTC

[section ""data" . Foreign.Storable.pokeElemOff_closure" {
     Foreign.Storable.pokeElemOff_closure:
         const Foreign.Storable.pokeElemOff_info;
 },
 Foreign.Storable.pokeElemOff_entry() //  [R2]
         { info_tbl: [(c4H5E,
                       label: Foreign.Storable.pokeElemOff_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H5E: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4H5F; else goto c4H5G;
       c4H5F: // global
           R2 = R2;
           R1 = Foreign.Storable.pokeElemOff_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4H5G: // global
           I64[Sp - 8] = block_c4H5B_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4H5K; else goto c4H5C;
       u4H5K: // global
           call _c4H5B(R1) args: 0, res: 0, upd: 0;
       c4H5C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4H5B() //  [R1]
         { info_tbl: [(c4H5B,
                       label: block_c4H5B_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H5B: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.304411115 UTC

[section ""data" . Foreign.Storable.peekByteOff_closure" {
     Foreign.Storable.peekByteOff_closure:
         const Foreign.Storable.peekByteOff_info;
 },
 Foreign.Storable.peekByteOff_entry() //  [R2]
         { info_tbl: [(c4H61,
                       label: Foreign.Storable.peekByteOff_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H61: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4H62; else goto c4H63;
       c4H62: // global
           R2 = R2;
           R1 = Foreign.Storable.peekByteOff_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4H63: // global
           I64[Sp - 8] = block_c4H5Y_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4H67; else goto c4H5Z;
       u4H67: // global
           call _c4H5Y(R1) args: 0, res: 0, upd: 0;
       c4H5Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4H5Y() //  [R1]
         { info_tbl: [(c4H5Y,
                       label: block_c4H5Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H5Y: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.3101637 UTC

[section ""data" . Foreign.Storable.pokeByteOff_closure" {
     Foreign.Storable.pokeByteOff_closure:
         const Foreign.Storable.pokeByteOff_info;
 },
 Foreign.Storable.pokeByteOff_entry() //  [R2]
         { info_tbl: [(c4H6o,
                       label: Foreign.Storable.pokeByteOff_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H6o: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4H6p; else goto c4H6q;
       c4H6p: // global
           R2 = R2;
           R1 = Foreign.Storable.pokeByteOff_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4H6q: // global
           I64[Sp - 8] = block_c4H6l_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4H6u; else goto c4H6m;
       u4H6u: // global
           call _c4H6l(R1) args: 0, res: 0, upd: 0;
       c4H6m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4H6l() //  [R1]
         { info_tbl: [(c4H6l,
                       label: block_c4H6l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H6l: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.31603758 UTC

[section ""data" . Foreign.Storable.peek_closure" {
     Foreign.Storable.peek_closure:
         const Foreign.Storable.peek_info;
 },
 Foreign.Storable.peek_entry() //  [R2]
         { info_tbl: [(c4H6L,
                       label: Foreign.Storable.peek_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H6L: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4H6M; else goto c4H6N;
       c4H6M: // global
           R2 = R2;
           R1 = Foreign.Storable.peek_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4H6N: // global
           I64[Sp - 8] = block_c4H6I_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4H6R; else goto c4H6J;
       u4H6R: // global
           call _c4H6I(R1) args: 0, res: 0, upd: 0;
       c4H6J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4H6I() //  [R1]
         { info_tbl: [(c4H6I,
                       label: block_c4H6I_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H6I: // global
           R1 = P64[R1 + 55];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.32548169 UTC

[section ""data" . Foreign.Storable.poke_closure" {
     Foreign.Storable.poke_closure:
         const Foreign.Storable.poke_info;
 },
 Foreign.Storable.poke_entry() //  [R2]
         { info_tbl: [(c4H78,
                       label: Foreign.Storable.poke_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H78: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4H79; else goto c4H7a;
       c4H79: // global
           R2 = R2;
           R1 = Foreign.Storable.poke_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4H7a: // global
           I64[Sp - 8] = block_c4H75_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4H7e; else goto c4H76;
       u4H7e: // global
           call _c4H75(R1) args: 0, res: 0, upd: 0;
       c4H76: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4H75() //  [R1]
         { info_tbl: [(c4H75,
                       label: block_c4H75_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H75: // global
           R1 = P64[R1 + 63];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.333385939 UTC

[section ""data" . Foreign.Storable.$fStorable()7_closure" {
     Foreign.Storable.$fStorable()7_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.336181443 UTC

[section ""data" . Foreign.Storable.$fStorable()_$calignment_closure" {
     Foreign.Storable.$fStorable()_$calignment_closure:
         const Foreign.Storable.$fStorable()_$calignment_info;
 },
 Foreign.Storable.$fStorable()_$calignment_entry() //  []
         { info_tbl: [(c4H7t,
                       label: Foreign.Storable.$fStorable()_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H7t: // global
           R1 = Foreign.Storable.$fStorable()7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.341302873 UTC

[section ""data" . Foreign.Storable.$fStorable()8_closure" {
     Foreign.Storable.$fStorable()8_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.344191816 UTC

[section ""data" . Foreign.Storable.$fStorable()_$csizeOf_closure" {
     Foreign.Storable.$fStorable()_$csizeOf_closure:
         const Foreign.Storable.$fStorable()_$csizeOf_info;
 },
 Foreign.Storable.$fStorable()_$csizeOf_entry() //  []
         { info_tbl: [(c4H7G,
                       label: Foreign.Storable.$fStorable()_$csizeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H7G: // global
           R1 = Foreign.Storable.$fStorable()8_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.349322541 UTC

[section ""data" . Foreign.Storable.$fStorableBool7_closure" {
     Foreign.Storable.$fStorableBool7_closure:
         const GHC.Types.I#_con_info;
         const 4;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.352404406 UTC

[section ""data" . Foreign.Storable.$fStorableChar_$calignment_closure" {
     Foreign.Storable.$fStorableChar_$calignment_closure:
         const Foreign.Storable.$fStorableChar_$calignment_info;
 },
 Foreign.Storable.$fStorableChar_$calignment_entry() //  []
         { info_tbl: [(c4H7T,
                       label: Foreign.Storable.$fStorableChar_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H7T: // global
           R1 = Foreign.Storable.$fStorableBool7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.358105819 UTC

[section ""data" . Foreign.Storable.$fStorableDouble5_closure" {
     Foreign.Storable.$fStorableDouble5_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.360930963 UTC

[section ""data" . Foreign.Storable.$fStorableInt_$calignment_closure" {
     Foreign.Storable.$fStorableInt_$calignment_closure:
         const Foreign.Storable.$fStorableInt_$calignment_info;
 },
 Foreign.Storable.$fStorableInt_$calignment_entry() //  []
         { info_tbl: [(c4H86,
                       label: Foreign.Storable.$fStorableInt_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H86: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.367088644 UTC

[section ""data" . Foreign.Storable.$fStorableWord_$calignment_closure" {
     Foreign.Storable.$fStorableWord_$calignment_closure:
         const Foreign.Storable.$fStorableWord_$calignment_info;
 },
 Foreign.Storable.$fStorableWord_$calignment_entry() //  []
         { info_tbl: [(c4H8i,
                       label: Foreign.Storable.$fStorableWord_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H8i: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.372971323 UTC

[section ""data" . Foreign.Storable.$fStorablePtr_$calignment_closure" {
     Foreign.Storable.$fStorablePtr_$calignment_closure:
         const Foreign.Storable.$fStorablePtr_$calignment_info;
 },
 Foreign.Storable.$fStorablePtr_$calignment_entry() //  []
         { info_tbl: [(c4H8u,
                       label: Foreign.Storable.$fStorablePtr_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H8u: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.378523639 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr_$calignment_closure" {
     Foreign.Storable.$fStorableFunPtr_$calignment_closure:
         const Foreign.Storable.$fStorableFunPtr_$calignment_info;
 },
 Foreign.Storable.$fStorableFunPtr_$calignment_entry() //  []
         { info_tbl: [(c4H8G,
                       label: Foreign.Storable.$fStorableFunPtr_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H8G: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.384090404 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr_$calignment_closure" {
     Foreign.Storable.$fStorableStablePtr_$calignment_closure:
         const Foreign.Storable.$fStorableStablePtr_$calignment_info;
 },
 Foreign.Storable.$fStorableStablePtr_$calignment_entry() //  []
         { info_tbl: [(c4H8S,
                       label: Foreign.Storable.$fStorableStablePtr_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H8S: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.389492484 UTC

[section ""data" . Foreign.Storable.$fStorableFloat_$calignment_closure" {
     Foreign.Storable.$fStorableFloat_$calignment_closure:
         const Foreign.Storable.$fStorableFloat_$calignment_info;
 },
 Foreign.Storable.$fStorableFloat_$calignment_entry() //  []
         { info_tbl: [(c4H94,
                       label: Foreign.Storable.$fStorableFloat_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H94: // global
           R1 = Foreign.Storable.$fStorableBool7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.393133711 UTC

[section ""data" . Foreign.Storable.$fStorableDouble_$calignment_closure" {
     Foreign.Storable.$fStorableDouble_$calignment_closure:
         const Foreign.Storable.$fStorableDouble_$calignment_info;
 },
 Foreign.Storable.$fStorableDouble_$calignment_entry() //  []
         { info_tbl: [(c4H9g,
                       label: Foreign.Storable.$fStorableDouble_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H9g: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.397152506 UTC

[section ""data" . Foreign.Storable.$fStorableWord8_$calignment_closure" {
     Foreign.Storable.$fStorableWord8_$calignment_closure:
         const Foreign.Storable.$fStorableWord8_$calignment_info;
 },
 Foreign.Storable.$fStorableWord8_$calignment_entry() //  []
         { info_tbl: [(c4H9s,
                       label: Foreign.Storable.$fStorableWord8_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H9s: // global
           R1 = Foreign.Storable.$fStorable()7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.400542031 UTC

[section ""data" . Foreign.Storable.$fStorableInt10_closure" {
     Foreign.Storable.$fStorableInt10_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.402618409 UTC

[section ""data" . Foreign.Storable.$fStorableWord16_$calignment_closure" {
     Foreign.Storable.$fStorableWord16_$calignment_closure:
         const Foreign.Storable.$fStorableWord16_$calignment_info;
 },
 Foreign.Storable.$fStorableWord16_$calignment_entry() //  []
         { info_tbl: [(c4H9F,
                       label: Foreign.Storable.$fStorableWord16_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H9F: // global
           R1 = Foreign.Storable.$fStorableInt10_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.406979436 UTC

[section ""data" . Foreign.Storable.$fStorableWord32_$calignment_closure" {
     Foreign.Storable.$fStorableWord32_$calignment_closure:
         const Foreign.Storable.$fStorableWord32_$calignment_info;
 },
 Foreign.Storable.$fStorableWord32_$calignment_entry() //  []
         { info_tbl: [(c4H9R,
                       label: Foreign.Storable.$fStorableWord32_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4H9R: // global
           R1 = Foreign.Storable.$fStorableBool7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.411163578 UTC

[section ""data" . Foreign.Storable.$fStorableWord64_$calignment_closure" {
     Foreign.Storable.$fStorableWord64_$calignment_closure:
         const Foreign.Storable.$fStorableWord64_$calignment_info;
 },
 Foreign.Storable.$fStorableWord64_$calignment_entry() //  []
         { info_tbl: [(c4Ha3,
                       label: Foreign.Storable.$fStorableWord64_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ha3: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.414836855 UTC

[section ""data" . Foreign.Storable.$fStorableInt8_$calignment_closure" {
     Foreign.Storable.$fStorableInt8_$calignment_closure:
         const Foreign.Storable.$fStorableInt8_$calignment_info;
 },
 Foreign.Storable.$fStorableInt8_$calignment_entry() //  []
         { info_tbl: [(c4Haf,
                       label: Foreign.Storable.$fStorableInt8_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Haf: // global
           R1 = Foreign.Storable.$fStorable()7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.41841633 UTC

[section ""data" . Foreign.Storable.$fStorableInt16_$calignment_closure" {
     Foreign.Storable.$fStorableInt16_$calignment_closure:
         const Foreign.Storable.$fStorableInt16_$calignment_info;
 },
 Foreign.Storable.$fStorableInt16_$calignment_entry() //  []
         { info_tbl: [(c4Har,
                       label: Foreign.Storable.$fStorableInt16_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Har: // global
           R1 = Foreign.Storable.$fStorableInt10_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.422062744 UTC

[section ""data" . Foreign.Storable.$fStorableInt32_$calignment_closure" {
     Foreign.Storable.$fStorableInt32_$calignment_closure:
         const Foreign.Storable.$fStorableInt32_$calignment_info;
 },
 Foreign.Storable.$fStorableInt32_$calignment_entry() //  []
         { info_tbl: [(c4HaD,
                       label: Foreign.Storable.$fStorableInt32_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HaD: // global
           R1 = Foreign.Storable.$fStorableBool7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.425780572 UTC

[section ""data" . Foreign.Storable.$fStorableInt64_$calignment_closure" {
     Foreign.Storable.$fStorableInt64_$calignment_closure:
         const Foreign.Storable.$fStorableInt64_$calignment_info;
 },
 Foreign.Storable.$fStorableInt64_$calignment_entry() //  []
         { info_tbl: [(c4HaP,
                       label: Foreign.Storable.$fStorableInt64_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HaP: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.428943741 UTC

[section ""cstring" . lvl_r4Ff9_bytes" {
     lvl_r4Ff9_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.431005174 UTC

[section ""data" . lvl1_r4Ffa_closure" {
     lvl1_r4Ffa_closure:
         const lvl1_r4Ffa_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r4Ffa_entry() //  [R1]
         { info_tbl: [(c4Hb4,
                       label: lvl1_r4Ffa_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hb4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Hb5; else goto c4Hb6;
       c4Hb5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Hb6: // global
           (_c4Hb1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4Hb1::I64 == 0) goto c4Hb3; else goto c4Hb2;
       c4Hb3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4Hb2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4Hb1::I64;
           R2 = lvl_r4Ff9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.434986459 UTC

[section ""cstring" . Foreign.Storable.$trModule4_bytes" {
     Foreign.Storable.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.437615012 UTC

[section ""data" . lvl2_r4Ffb_closure" {
     lvl2_r4Ffb_closure:
         const lvl2_r4Ffb_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r4Ffb_entry() //  [R1]
         { info_tbl: [(c4Hbl,
                       label: lvl2_r4Ffb_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hbl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Hbm; else goto c4Hbn;
       c4Hbm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Hbn: // global
           (_c4Hbi::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4Hbi::I64 == 0) goto c4Hbk; else goto c4Hbj;
       c4Hbk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4Hbj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4Hbi::I64;
           R2 = Foreign.Storable.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.441744185 UTC

[section ""cstring" . Foreign.Storable.$trModule2_bytes" {
     Foreign.Storable.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,83,116,111,114,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.443760849 UTC

[section ""data" . lvl3_r4Ffc_closure" {
     lvl3_r4Ffc_closure:
         const lvl3_r4Ffc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r4Ffc_entry() //  [R1]
         { info_tbl: [(c4HbC,
                       label: lvl3_r4Ffc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HbC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HbD; else goto c4HbE;
       c4HbD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4HbE: // global
           (_c4Hbz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4Hbz::I64 == 0) goto c4HbB; else goto c4HbA;
       c4HbB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4HbA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4Hbz::I64;
           R2 = Foreign.Storable.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.447765073 UTC

[section ""cstring" . lvl4_r4Ffd_bytes" {
     lvl4_r4Ffd_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,83,116,111,114,97,98,108,101,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.450645549 UTC

[section ""data" . lvl5_r4Ffe_closure" {
     lvl5_r4Ffe_closure:
         const lvl5_r4Ffe_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r4Ffe_entry() //  [R1]
         { info_tbl: [(c4HbT,
                       label: lvl5_r4Ffe_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HbT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HbU; else goto c4HbV;
       c4HbU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4HbV: // global
           (_c4HbQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4HbQ::I64 == 0) goto c4HbS; else goto c4HbR;
       c4HbS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4HbR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4HbQ::I64;
           R2 = lvl4_r4Ffd_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.454817241 UTC

[section ""data" . lvl6_r4Fff_closure" {
     lvl6_r4Fff_closure:
         const GHC.Types.I#_con_info;
         const 238;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.456532298 UTC

[section ""data" . lvl7_r4Ffg_closure" {
     lvl7_r4Ffg_closure:
         const GHC.Types.I#_con_info;
         const 30;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.458314623 UTC

[section ""data" . lvl8_r4Ffh_closure" {
     lvl8_r4Ffh_closure:
         const GHC.Types.I#_con_info;
         const 39;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.460042432 UTC

[section ""data" . lvl9_r4Ffi_closure" {
     lvl9_r4Ffi_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r4Ffb_closure;
         const lvl3_r4Ffc_closure;
         const lvl5_r4Ffe_closure;
         const lvl6_r4Fff_closure+1;
         const lvl7_r4Ffg_closure+1;
         const lvl6_r4Fff_closure+1;
         const lvl8_r4Ffh_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.461890682 UTC

[section ""data" . lvl10_r4Ffj_closure" {
     lvl10_r4Ffj_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r4Ffa_closure;
         const lvl9_r4Ffi_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.463938239 UTC

[section ""data" . Foreign.Storable.$fStorableRatio8_closure" {
     Foreign.Storable.$fStorableRatio8_closure:
         const Foreign.Storable.$fStorableRatio8_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Storable.$fStorableRatio8_entry() //  [R1]
         { info_tbl: [(c4Hce,
                       label: Foreign.Storable.$fStorableRatio8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hce: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Hcf; else goto c4Hcg;
       c4Hcf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Hcg: // global
           (_c4Hcb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4Hcb::I64 == 0) goto c4Hcd; else goto c4Hcc;
       c4Hcd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4Hcc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4Hcb::I64;
           R2 = lvl10_r4Ffj_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.468968881 UTC

[section ""data" . Foreign.Storable.$fStorableRatio_$calignment_closure" {
     Foreign.Storable.$fStorableRatio_$calignment_closure:
         const Foreign.Storable.$fStorableRatio_$calignment_info;
         const 0;
 },
 lvl20_s4Fh7_entry() //  [R1]
         { info_tbl: [(c4Hcw,
                       label: lvl20_s4Fh7_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hcw: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4Hcx; else goto c4Hcy;
       c4Hcx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Hcy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Storable.$fStorableRatio8_closure;
           Sp = Sp - 32;
           call Foreign.Storable.alignment_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s4Fh9_entry() //  [R1]
         { info_tbl: [(c4HcE,
                       label: sat_s4Fh9_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HcE: // global
           R1 = P64[R1 + 7] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Storable.$fStorableRatio_$calignment_entry() //  [R2, R3]
         { info_tbl: [(c4HcH,
                       label: Foreign.Storable.$fStorableRatio_$calignment_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HcH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4HcL; else goto c4HcK;
       c4HcL: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio_$calignment_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HcK: // global
           I64[Hp - 32] = lvl20_s4Fh7_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s4Fh9_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.477452934 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint_$calignment_closure" {
     Foreign.Storable.$fStorableFingerprint_$calignment_closure:
         const Foreign.Storable.$fStorableFingerprint_$calignment_info;
 },
 Foreign.Storable.$fStorableFingerprint_$calignment_entry() //  []
         { info_tbl: [(c4Hd5,
                       label: Foreign.Storable.$fStorableFingerprint_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hd5: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.480875948 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint7_closure" {
     Foreign.Storable.$fStorableFingerprint7_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.482839697 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint_$csizeOf_closure" {
     Foreign.Storable.$fStorableFingerprint_$csizeOf_closure:
         const Foreign.Storable.$fStorableFingerprint_$csizeOf_info;
 },
 Foreign.Storable.$fStorableFingerprint_$csizeOf_entry() //  []
         { info_tbl: [(c4Hdi,
                       label: Foreign.Storable.$fStorableFingerprint_$csizeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hdi: // global
           R1 = Foreign.Storable.$fStorableFingerprint7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.486968442 UTC

[section ""data" . Foreign.Storable.$dmpoke_closure" {
     Foreign.Storable.$dmpoke_closure:
         const Foreign.Storable.$dmpoke_info;
 },
 Foreign.Storable.$dmpoke_entry() //  [R2, R3]
         { info_tbl: [(c4Hdu,
                       label: Foreign.Storable.$dmpoke_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hdu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Hdv; else goto c4Hdw;
       c4Hdv: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$dmpoke_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Hdw: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = Foreign.Storable.$fStorable()8_closure+1;
           Sp = Sp - 24;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.491200457 UTC

[section ""data" . Foreign.Storable.$dmpeek_closure" {
     Foreign.Storable.$dmpeek_closure:
         const Foreign.Storable.$dmpeek_info;
 },
 Foreign.Storable.$dmpeek_entry() //  [R2, R3]
         { info_tbl: [(c4HdG,
                       label: Foreign.Storable.$dmpeek_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HdG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4HdH; else goto c4HdI;
       c4HdH: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$dmpeek_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HdI: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = Foreign.Storable.$fStorable()8_closure+1;
           Sp = Sp - 24;
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.495667445 UTC

[section ""data" . Foreign.Storable.$dmpokeByteOff_closure" {
     Foreign.Storable.$dmpokeByteOff_closure:
         const Foreign.Storable.$dmpokeByteOff_info;
 },
 sat_s4Fho_entry() //  [R1]
         { info_tbl: [(c4HdZ,
                       label: sat_s4Fho_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HdZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4Heb; else goto c4Hec;
       c4Heb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Hec: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4HdW_info;
           _s4Fhi::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4Fhi::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4Hei; else goto c4HdX;
       u4Hei: // global
           call _c4HdW(R1) args: 0, res: 0, upd: 0;
       c4HdX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4HdW() //  [R1]
         { info_tbl: [(c4HdW,
                       label: block_c4HdW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HdW: // global
           I64[Sp] = block_c4He2_info;
           _s4Fhk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fhk::I64;
           if (R1 & 7 != 0) goto u4Heh; else goto c4He3;
       u4Heh: // global
           call _c4He2(R1) args: 0, res: 0, upd: 0;
       c4He3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4He2() //  [R1]
         { info_tbl: [(c4He2,
                       label: block_c4He2_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4He2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Heg; else goto c4Hef;
       c4Heg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4Hef: // global
           _s4Fhn::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fhn::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$dmpokeByteOff_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Hej,
                       label: Foreign.Storable.$dmpokeByteOff_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hej: // global
           _s4Fhi::P64 = R4;
           _s4Fhh::P64 = R3;
           _s4Fhg::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c4Hek; else goto c4Hel;
       c4Hel: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4Hen; else goto c4Hem;
       c4Hen: // global
           HpAlloc = 32;
           goto c4Hek;
       c4Hek: // global
           R4 = _s4Fhi::P64;
           R3 = _s4Fhh::P64;
           R2 = _s4Fhg::P64;
           R1 = Foreign.Storable.$dmpokeByteOff_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Hem: // global
           I64[Hp - 24] = sat_s4Fho_info;
           P64[Hp - 8] = _s4Fhh::P64;
           P64[Hp] = _s4Fhi::P64;
           R2 = _s4Fhg::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call Foreign.Storable.poke_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.507215868 UTC

[section ""data" . Foreign.Storable.$dmpeekByteOff_closure" {
     Foreign.Storable.$dmpeekByteOff_closure:
         const Foreign.Storable.$dmpeekByteOff_info;
 },
 sat_s4Fhx_entry() //  [R1]
         { info_tbl: [(c4HeU,
                       label: sat_s4Fhx_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HeU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4Hf6; else goto c4Hf7;
       c4Hf6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Hf7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4HeR_info;
           _s4Fhr::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4Fhr::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4Hfd; else goto c4HeS;
       u4Hfd: // global
           call _c4HeR(R1) args: 0, res: 0, upd: 0;
       c4HeS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4HeR() //  [R1]
         { info_tbl: [(c4HeR,
                       label: block_c4HeR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HeR: // global
           I64[Sp] = block_c4HeX_info;
           _s4Fht::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fht::I64;
           if (R1 & 7 != 0) goto u4Hfc; else goto c4HeY;
       u4Hfc: // global
           call _c4HeX(R1) args: 0, res: 0, upd: 0;
       c4HeY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4HeX() //  [R1]
         { info_tbl: [(c4HeX,
                       label: block_c4HeX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HeX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Hfb; else goto c4Hfa;
       c4Hfb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4Hfa: // global
           _s4Fhw::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fhw::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$dmpeekByteOff_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Hfe,
                       label: Foreign.Storable.$dmpeekByteOff_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hfe: // global
           _s4Fhr::P64 = R4;
           _s4Fhq::P64 = R3;
           _s4Fhp::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c4Hff; else goto c4Hfg;
       c4Hfg: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4Hfi; else goto c4Hfh;
       c4Hfi: // global
           HpAlloc = 32;
           goto c4Hff;
       c4Hff: // global
           R4 = _s4Fhr::P64;
           R3 = _s4Fhq::P64;
           R2 = _s4Fhp::P64;
           R1 = Foreign.Storable.$dmpeekByteOff_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Hfh: // global
           I64[Hp - 24] = sat_s4Fhx_info;
           P64[Hp - 8] = _s4Fhq::P64;
           P64[Hp] = _s4Fhr::P64;
           R2 = _s4Fhp::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.518421834 UTC

[section ""data" . Foreign.Storable.$fStorableInt17_closure" {
     Foreign.Storable.$fStorableInt17_closure:
         const Foreign.Storable.$fStorableInt17_info;
 },
 Foreign.Storable.$fStorableInt17_entry() //  [R2]
         { info_tbl: [(c4HfL,
                       label: Foreign.Storable.$fStorableInt17_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HfL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4HfP; else goto c4HfQ;
       c4HfP: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt17_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4HfQ: // global
           I64[Sp - 8] = block_c4HfI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4HfU; else goto c4HfJ;
       u4HfU: // global
           call _c4HfI(R1) args: 0, res: 0, upd: 0;
       c4HfJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HfI() //  [R1]
         { info_tbl: [(c4HfI,
                       label: block_c4HfI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HfI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HfT; else goto c4HfS;
       c4HfT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HfS: // global
           _s4FhE::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4FhE::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.524788511 UTC

[section ""data" . Foreign.Storable.$fStorableInt19_closure" {
     Foreign.Storable.$fStorableInt19_closure:
         const Foreign.Storable.$fStorableInt19_info;
 },
 Foreign.Storable.$fStorableInt19_entry() //  [R2, R3]
         { info_tbl: [(c4Hgd,
                       label: Foreign.Storable.$fStorableInt19_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hgd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Hgp; else goto c4Hgq;
       c4Hgp: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt19_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Hgq: // global
           I64[Sp - 16] = block_c4Hga_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Hgw; else goto c4Hgb;
       u4Hgw: // global
           call _c4Hga(R1) args: 0, res: 0, upd: 0;
       c4Hgb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hga() //  [R1]
         { info_tbl: [(c4Hga,
                       label: block_c4Hga_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hga: // global
           I64[Sp] = block_c4Hgg_info;
           _s4FhK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FhK::I64;
           if (R1 & 7 != 0) goto u4Hgv; else goto c4Hgh;
       u4Hgv: // global
           call _c4Hgg(R1) args: 0, res: 0, upd: 0;
       c4Hgh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hgg() //  [R1]
         { info_tbl: [(c4Hgg,
                       label: block_c4Hgg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hgg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Hgu; else goto c4Hgt;
       c4Hgu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Hgt: // global
           _s4FhQ::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4FhQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.533183164 UTC

[section ""data" . Foreign.Storable.$fStorableInt15_closure" {
     Foreign.Storable.$fStorableInt15_closure:
         const Foreign.Storable.$fStorableInt15_info;
 },
 Foreign.Storable.$fStorableInt15_entry() //  [R2, R3]
         { info_tbl: [(c4HgU,
                       label: Foreign.Storable.$fStorableInt15_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HgU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HgY; else goto c4HgZ;
       c4HgY: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt15_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HgZ: // global
           I64[Sp - 16] = block_c4HgR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Hh7; else goto c4HgS;
       u4Hh7: // global
           call _c4HgR(R1) args: 0, res: 0, upd: 0;
       c4HgS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HgR() //  [R1]
         { info_tbl: [(c4HgR,
                       label: block_c4HgR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HgR: // global
           I64[Sp] = block_c4HgX_info;
           _s4FhW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FhW::I64;
           if (R1 & 7 != 0) goto u4Hh6; else goto c4Hh1;
       u4Hh6: // global
           call _c4HgX(R1) args: 0, res: 0, upd: 0;
       c4Hh1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HgX() //  [R1]
         { info_tbl: [(c4HgX,
                       label: block_c4HgX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HgX: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.541138349 UTC

[section ""data" . Foreign.Storable.$fStorableInt18_closure" {
     Foreign.Storable.$fStorableInt18_closure:
         const Foreign.Storable.$fStorableInt18_info;
 },
 Foreign.Storable.$fStorableInt18_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Hhv,
                       label: Foreign.Storable.$fStorableInt18_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hhv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4HhE; else goto c4HhF;
       c4HhE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt18_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HhF: // global
           I64[Sp - 24] = block_c4Hhs_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4HhP; else goto c4Hht;
       u4HhP: // global
           call _c4Hhs(R1) args: 0, res: 0, upd: 0;
       c4Hht: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hhs() //  [R1]
         { info_tbl: [(c4Hhs,
                       label: block_c4Hhs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hhs: // global
           I64[Sp] = block_c4Hhy_info;
           _s4Fi5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fi5::I64;
           if (R1 & 7 != 0) goto u4HhO; else goto c4Hhz;
       u4HhO: // global
           call _c4Hhy(R1) args: 0, res: 0, upd: 0;
       c4Hhz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hhy() //  [R1]
         { info_tbl: [(c4Hhy,
                       label: block_c4Hhy_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hhy: // global
           I64[Sp] = block_c4HhD_info;
           _s4Fi7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fi7::I64;
           if (R1 & 7 != 0) goto u4HhQ; else goto c4HhI;
       u4HhQ: // global
           call _c4HhD(R1) args: 0, res: 0, upd: 0;
       c4HhI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HhD() //  [R1]
         { info_tbl: [(c4HhD,
                       label: block_c4HhD_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HhD: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.551614714 UTC

[section ""data" . Foreign.Storable.$fStorableInt64_closure" {
     Foreign.Storable.$fStorableInt64_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt64_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt64_$calignment_closure+1;
         const GHC.Storable.readInt64OffPtr1_closure+3;
         const GHC.Storable.writeInt64OffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt19_closure+3;
         const Foreign.Storable.$fStorableInt18_closure+4;
         const Foreign.Storable.$fStorableInt17_closure+2;
         const Foreign.Storable.$fStorableInt15_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.554176628 UTC

[section ""data" . Foreign.Storable.$fStorableInt12_closure" {
     Foreign.Storable.$fStorableInt12_closure:
         const Foreign.Storable.$fStorableInt12_info;
 },
 Foreign.Storable.$fStorableInt12_entry() //  [R2]
         { info_tbl: [(c4Hik,
                       label: Foreign.Storable.$fStorableInt12_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hik: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Hio; else goto c4Hip;
       c4Hio: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt12_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Hip: // global
           I64[Sp - 8] = block_c4Hih_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Hit; else goto c4Hii;
       u4Hit: // global
           call _c4Hih(R1) args: 0, res: 0, upd: 0;
       c4Hii: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hih() //  [R1]
         { info_tbl: [(c4Hih,
                       label: block_c4Hih_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hih: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4His; else goto c4Hir;
       c4His: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Hir: // global
           _s4Fii::I64 = %MO_SS_Conv_W32_W64(I32[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4Fii::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.560827255 UTC

[section ""data" . Foreign.Storable.$fStorableInt14_closure" {
     Foreign.Storable.$fStorableInt14_closure:
         const Foreign.Storable.$fStorableInt14_info;
 },
 Foreign.Storable.$fStorableInt14_entry() //  [R2, R3]
         { info_tbl: [(c4HiM,
                       label: Foreign.Storable.$fStorableInt14_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HiM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HiY; else goto c4HiZ;
       c4HiY: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt14_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HiZ: // global
           I64[Sp - 16] = block_c4HiJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Hj5; else goto c4HiK;
       u4Hj5: // global
           call _c4HiJ(R1) args: 0, res: 0, upd: 0;
       c4HiK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HiJ() //  [R1]
         { info_tbl: [(c4HiJ,
                       label: block_c4HiJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HiJ: // global
           I64[Sp] = block_c4HiP_info;
           _s4Fio::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fio::I64;
           if (R1 & 7 != 0) goto u4Hj4; else goto c4HiQ;
       u4Hj4: // global
           call _c4HiP(R1) args: 0, res: 0, upd: 0;
       c4HiQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HiP() //  [R1]
         { info_tbl: [(c4HiP,
                       label: block_c4HiP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HiP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Hj3; else goto c4Hj2;
       c4Hj3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Hj2: // global
           _s4Fiu::I64 = %MO_SS_Conv_W32_W64(I32[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4Fiu::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.569702652 UTC

[section ""data" . Foreign.Storable.$fStorableInt11_closure" {
     Foreign.Storable.$fStorableInt11_closure:
         const Foreign.Storable.$fStorableInt11_info;
 },
 Foreign.Storable.$fStorableInt11_entry() //  [R2, R3]
         { info_tbl: [(c4Hjt,
                       label: Foreign.Storable.$fStorableInt11_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hjt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Hjx; else goto c4Hjy;
       c4Hjx: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt11_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Hjy: // global
           I64[Sp - 16] = block_c4Hjq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HjG; else goto c4Hjr;
       u4HjG: // global
           call _c4Hjq(R1) args: 0, res: 0, upd: 0;
       c4Hjr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hjq() //  [R1]
         { info_tbl: [(c4Hjq,
                       label: block_c4Hjq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hjq: // global
           I64[Sp] = block_c4Hjw_info;
           _s4FiA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FiA::I64;
           if (R1 & 7 != 0) goto u4HjF; else goto c4HjA;
       u4HjF: // global
           call _c4Hjw(R1) args: 0, res: 0, upd: 0;
       c4HjA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hjw() //  [R1]
         { info_tbl: [(c4Hjw,
                       label: block_c4Hjw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hjw: // global
           I32[I64[Sp + 8]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.577983818 UTC

[section ""data" . Foreign.Storable.$fStorableInt13_closure" {
     Foreign.Storable.$fStorableInt13_closure:
         const Foreign.Storable.$fStorableInt13_info;
 },
 Foreign.Storable.$fStorableInt13_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Hk4,
                       label: Foreign.Storable.$fStorableInt13_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hk4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Hkd; else goto c4Hke;
       c4Hkd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt13_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Hke: // global
           I64[Sp - 24] = block_c4Hk1_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Hko; else goto c4Hk2;
       u4Hko: // global
           call _c4Hk1(R1) args: 0, res: 0, upd: 0;
       c4Hk2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hk1() //  [R1]
         { info_tbl: [(c4Hk1,
                       label: block_c4Hk1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hk1: // global
           I64[Sp] = block_c4Hk7_info;
           _s4FiJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FiJ::I64;
           if (R1 & 7 != 0) goto u4Hkn; else goto c4Hk8;
       u4Hkn: // global
           call _c4Hk7(R1) args: 0, res: 0, upd: 0;
       c4Hk8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hk7() //  [R1]
         { info_tbl: [(c4Hk7,
                       label: block_c4Hk7_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hk7: // global
           I64[Sp] = block_c4Hkc_info;
           _s4FiL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FiL::I64;
           if (R1 & 7 != 0) goto u4Hkp; else goto c4Hkh;
       u4Hkp: // global
           call _c4Hkc(R1) args: 0, res: 0, upd: 0;
       c4Hkh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hkc() //  [R1]
         { info_tbl: [(c4Hkc,
                       label: block_c4Hkc_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hkc: // global
           I32[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.587851616 UTC

[section ""data" . Foreign.Storable.$fStorableInt32_closure" {
     Foreign.Storable.$fStorableInt32_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt32_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt32_$calignment_closure+1;
         const GHC.Storable.readInt32OffPtr1_closure+3;
         const GHC.Storable.writeInt32OffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt14_closure+3;
         const Foreign.Storable.$fStorableInt13_closure+4;
         const Foreign.Storable.$fStorableInt12_closure+2;
         const Foreign.Storable.$fStorableInt11_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.591041432 UTC

[section ""data" . Foreign.Storable.$fStorableBool_$csizeOf_closure" {
     Foreign.Storable.$fStorableBool_$csizeOf_closure:
         const Foreign.Storable.$fStorableBool_$csizeOf_info;
 },
 Foreign.Storable.$fStorableBool_$csizeOf_entry() //  []
         { info_tbl: [(c4HkQ,
                       label: Foreign.Storable.$fStorableBool_$csizeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HkQ: // global
           R1 = Foreign.Storable.$fStorableBool7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.595123229 UTC

[section ""data" . Foreign.Storable.$fStorableBool5_closure" {
     Foreign.Storable.$fStorableBool5_closure:
         const Foreign.Storable.$fStorableBool5_info;
 },
 Foreign.Storable.$fStorableBool5_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Hl5,
                       label: Foreign.Storable.$fStorableBool5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hl5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Hl9; else goto c4Hla;
       c4Hl9: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Hla: // global
           I64[Sp - 24] = block_c4Hl2_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Hlv; else goto c4Hl3;
       u4Hlv: // global
           call _c4Hl2(R1) args: 0, res: 0, upd: 0;
       c4Hl3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hl2() //  [R1]
         { info_tbl: [(c4Hl2,
                       label: block_c4Hl2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hl2: // global
           I64[Sp] = block_c4Hl8_info;
           _s4FiW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FiW::I64;
           if (R1 & 7 != 0) goto u4Hlu; else goto c4Hlc;
       u4Hlu: // global
           call _c4Hl8(R1) args: 0, res: 0, upd: 0;
       c4Hlc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hl8() //  [R1]
         { info_tbl: [(c4Hl8,
                       label: block_c4Hl8_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hl8: // global
           I64[Sp] = block_c4Hlg_info;
           _s4FiY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FiY::I64;
           if (R1 & 7 != 0) goto u4Hlw; else goto c4Hli;
       u4Hlw: // global
           call _c4Hlg(R1) args: 0, res: 0, upd: 0;
       c4Hli: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hlg() //  [R1]
         { info_tbl: [(c4Hlg,
                       label: block_c4Hlg_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hlg: // global
           _s4FiW::I64 = I64[Sp + 8];
           _s4FiY::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto c4Hlo; else goto c4Hls;
       c4Hlo: // global
           I32[_s4FiW::I64 + (_s4FiY::I64 << 2)] = 0 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4Hls: // global
           I32[_s4FiW::I64 + (_s4FiY::I64 << 2)] = 1 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.605205624 UTC

[section ""data" . Foreign.Storable.$fStorableInt6_closure" {
     Foreign.Storable.$fStorableInt6_closure:
         const Foreign.Storable.$fStorableInt6_info;
 },
 Foreign.Storable.$fStorableInt6_entry() //  [R2]
         { info_tbl: [(c4HlZ,
                       label: Foreign.Storable.$fStorableInt6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HlZ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Hm3; else goto c4Hm4;
       c4Hm3: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Hm4: // global
           I64[Sp - 8] = block_c4HlW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Hm8; else goto c4HlX;
       u4Hm8: // global
           call _c4HlW(R1) args: 0, res: 0, upd: 0;
       c4HlX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HlW() //  [R1]
         { info_tbl: [(c4HlW,
                       label: block_c4HlW_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HlW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Hm7; else goto c4Hm6;
       c4Hm7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Hm6: // global
           _s4Fj8::I64 = %MO_SS_Conv_W16_W64(I16[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4Fj8::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.612417737 UTC

[section ""data" . Foreign.Storable.$fStorableInt9_closure" {
     Foreign.Storable.$fStorableInt9_closure:
         const Foreign.Storable.$fStorableInt9_info;
 },
 Foreign.Storable.$fStorableInt9_entry() //  [R2, R3]
         { info_tbl: [(c4Hmr,
                       label: Foreign.Storable.$fStorableInt9_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hmr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HmD; else goto c4HmE;
       c4HmD: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt9_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HmE: // global
           I64[Sp - 16] = block_c4Hmo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HmK; else goto c4Hmp;
       u4HmK: // global
           call _c4Hmo(R1) args: 0, res: 0, upd: 0;
       c4Hmp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hmo() //  [R1]
         { info_tbl: [(c4Hmo,
                       label: block_c4Hmo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hmo: // global
           I64[Sp] = block_c4Hmu_info;
           _s4Fje::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fje::I64;
           if (R1 & 7 != 0) goto u4HmJ; else goto c4Hmv;
       u4HmJ: // global
           call _c4Hmu(R1) args: 0, res: 0, upd: 0;
       c4Hmv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hmu() //  [R1]
         { info_tbl: [(c4Hmu,
                       label: block_c4Hmu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hmu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HmI; else goto c4HmH;
       c4HmI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HmH: // global
           _s4Fjk::I64 = %MO_SS_Conv_W16_W64(I16[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4Fjk::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.621045736 UTC

[section ""data" . Foreign.Storable.$fStorableInt5_closure" {
     Foreign.Storable.$fStorableInt5_closure:
         const Foreign.Storable.$fStorableInt5_info;
 },
 Foreign.Storable.$fStorableInt5_entry() //  [R2, R3]
         { info_tbl: [(c4Hn8,
                       label: Foreign.Storable.$fStorableInt5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hn8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Hnc; else goto c4Hnd;
       c4Hnc: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Hnd: // global
           I64[Sp - 16] = block_c4Hn5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Hnl; else goto c4Hn6;
       u4Hnl: // global
           call _c4Hn5(R1) args: 0, res: 0, upd: 0;
       c4Hn6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hn5() //  [R1]
         { info_tbl: [(c4Hn5,
                       label: block_c4Hn5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hn5: // global
           I64[Sp] = block_c4Hnb_info;
           _s4Fjq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fjq::I64;
           if (R1 & 7 != 0) goto u4Hnk; else goto c4Hnf;
       u4Hnk: // global
           call _c4Hnb(R1) args: 0, res: 0, upd: 0;
       c4Hnf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hnb() //  [R1]
         { info_tbl: [(c4Hnb,
                       label: block_c4Hnb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hnb: // global
           I16[I64[Sp + 8]] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.630539688 UTC

[section ""data" . Foreign.Storable.$fStorableInt7_closure" {
     Foreign.Storable.$fStorableInt7_closure:
         const Foreign.Storable.$fStorableInt7_info;
 },
 Foreign.Storable.$fStorableInt7_entry() //  [R2, R3, R4]
         { info_tbl: [(c4HnJ,
                       label: Foreign.Storable.$fStorableInt7_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HnJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4HnS; else goto c4HnT;
       c4HnS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt7_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HnT: // global
           I64[Sp - 24] = block_c4HnG_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Ho3; else goto c4HnH;
       u4Ho3: // global
           call _c4HnG(R1) args: 0, res: 0, upd: 0;
       c4HnH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HnG() //  [R1]
         { info_tbl: [(c4HnG,
                       label: block_c4HnG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HnG: // global
           I64[Sp] = block_c4HnM_info;
           _s4Fjz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fjz::I64;
           if (R1 & 7 != 0) goto u4Ho2; else goto c4HnN;
       u4Ho2: // global
           call _c4HnM(R1) args: 0, res: 0, upd: 0;
       c4HnN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HnM() //  [R1]
         { info_tbl: [(c4HnM,
                       label: block_c4HnM_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HnM: // global
           I64[Sp] = block_c4HnR_info;
           _s4FjB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FjB::I64;
           if (R1 & 7 != 0) goto u4Ho4; else goto c4HnW;
       u4Ho4: // global
           call _c4HnR(R1) args: 0, res: 0, upd: 0;
       c4HnW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HnR() //  [R1]
         { info_tbl: [(c4HnR,
                       label: block_c4HnR_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HnR: // global
           I16[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.640061021 UTC

[section ""data" . Foreign.Storable.$fStorableInt16_closure" {
     Foreign.Storable.$fStorableInt16_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt16_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt16_$calignment_closure+1;
         const GHC.Storable.readInt16OffPtr1_closure+3;
         const GHC.Storable.writeInt16OffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt9_closure+3;
         const Foreign.Storable.$fStorableInt7_closure+4;
         const Foreign.Storable.$fStorableInt6_closure+2;
         const Foreign.Storable.$fStorableInt5_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.64260907 UTC

[section ""data" . Foreign.Storable.$fStorableInt21_closure" {
     Foreign.Storable.$fStorableInt21_closure:
         const Foreign.Storable.$fStorableInt21_info;
 },
 Foreign.Storable.$fStorableInt21_entry() //  [R2]
         { info_tbl: [(c4Hoy,
                       label: Foreign.Storable.$fStorableInt21_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hoy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4HoC; else goto c4HoD;
       c4HoC: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt21_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4HoD: // global
           I64[Sp - 8] = block_c4Hov_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4HoH; else goto c4How;
       u4HoH: // global
           call _c4Hov(R1) args: 0, res: 0, upd: 0;
       c4How: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hov() //  [R1]
         { info_tbl: [(c4Hov,
                       label: block_c4Hov_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hov: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HoG; else goto c4HoF;
       c4HoG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HoF: // global
           _s4FjM::I64 = %MO_SS_Conv_W8_W64(I8[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4FjM::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.649698948 UTC

[section ""data" . Foreign.Storable.$fStorableInt23_closure" {
     Foreign.Storable.$fStorableInt23_closure:
         const Foreign.Storable.$fStorableInt23_info;
 },
 Foreign.Storable.$fStorableInt23_entry() //  [R2, R3]
         { info_tbl: [(c4Hp0,
                       label: Foreign.Storable.$fStorableInt23_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hp0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Hpc; else goto c4Hpd;
       c4Hpc: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt23_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Hpd: // global
           I64[Sp - 16] = block_c4HoX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Hpj; else goto c4HoY;
       u4Hpj: // global
           call _c4HoX(R1) args: 0, res: 0, upd: 0;
       c4HoY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HoX() //  [R1]
         { info_tbl: [(c4HoX,
                       label: block_c4HoX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HoX: // global
           I64[Sp] = block_c4Hp3_info;
           _s4FjS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FjS::I64;
           if (R1 & 7 != 0) goto u4Hpi; else goto c4Hp4;
       u4Hpi: // global
           call _c4Hp3(R1) args: 0, res: 0, upd: 0;
       c4Hp4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hp3() //  [R1]
         { info_tbl: [(c4Hp3,
                       label: block_c4Hp3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hp3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Hph; else goto c4Hpg;
       c4Hph: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Hpg: // global
           _s4FjY::I64 = %MO_SS_Conv_W8_W64(I8[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4FjY::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.658076021 UTC

[section ""data" . Foreign.Storable.$fStorableInt20_closure" {
     Foreign.Storable.$fStorableInt20_closure:
         const Foreign.Storable.$fStorableInt20_info;
 },
 Foreign.Storable.$fStorableInt20_entry() //  [R2, R3]
         { info_tbl: [(c4HpH,
                       label: Foreign.Storable.$fStorableInt20_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HpH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HpL; else goto c4HpM;
       c4HpL: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt20_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HpM: // global
           I64[Sp - 16] = block_c4HpE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HpU; else goto c4HpF;
       u4HpU: // global
           call _c4HpE(R1) args: 0, res: 0, upd: 0;
       c4HpF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HpE() //  [R1]
         { info_tbl: [(c4HpE,
                       label: block_c4HpE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HpE: // global
           I64[Sp] = block_c4HpK_info;
           _s4Fk4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fk4::I64;
           if (R1 & 7 != 0) goto u4HpT; else goto c4HpO;
       u4HpT: // global
           call _c4HpK(R1) args: 0, res: 0, upd: 0;
       c4HpO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HpK() //  [R1]
         { info_tbl: [(c4HpK,
                       label: block_c4HpK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HpK: // global
           I8[I64[Sp + 8]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.666764616 UTC

[section ""data" . Foreign.Storable.$fStorableInt22_closure" {
     Foreign.Storable.$fStorableInt22_closure:
         const Foreign.Storable.$fStorableInt22_info;
 },
 Foreign.Storable.$fStorableInt22_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Hqi,
                       label: Foreign.Storable.$fStorableInt22_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hqi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Hqr; else goto c4Hqs;
       c4Hqr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt22_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Hqs: // global
           I64[Sp - 24] = block_c4Hqf_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4HqC; else goto c4Hqg;
       u4HqC: // global
           call _c4Hqf(R1) args: 0, res: 0, upd: 0;
       c4Hqg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hqf() //  [R1]
         { info_tbl: [(c4Hqf,
                       label: block_c4Hqf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hqf: // global
           I64[Sp] = block_c4Hql_info;
           _s4Fkd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fkd::I64;
           if (R1 & 7 != 0) goto u4HqB; else goto c4Hqm;
       u4HqB: // global
           call _c4Hql(R1) args: 0, res: 0, upd: 0;
       c4Hqm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hql() //  [R1]
         { info_tbl: [(c4Hql,
                       label: block_c4Hql_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hql: // global
           I64[Sp] = block_c4Hqq_info;
           _s4Fkf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fkf::I64;
           if (R1 & 7 != 0) goto u4HqD; else goto c4Hqv;
       u4HqD: // global
           call _c4Hqq(R1) args: 0, res: 0, upd: 0;
       c4Hqv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hqq() //  [R1]
         { info_tbl: [(c4Hqq,
                       label: block_c4Hqq_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hqq: // global
           I8[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.676576919 UTC

[section ""data" . Foreign.Storable.$fStorableInt8_closure" {
     Foreign.Storable.$fStorableInt8_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt8_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt8_$calignment_closure+1;
         const GHC.Storable.readInt8OffPtr1_closure+3;
         const GHC.Storable.writeInt8OffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt23_closure+3;
         const Foreign.Storable.$fStorableInt22_closure+4;
         const Foreign.Storable.$fStorableInt21_closure+2;
         const Foreign.Storable.$fStorableInt20_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.679025474 UTC

[section ""data" . Foreign.Storable.$fStorableWord15_closure" {
     Foreign.Storable.$fStorableWord15_closure:
         const Foreign.Storable.$fStorableWord15_info;
 },
 Foreign.Storable.$fStorableWord15_entry() //  [R2]
         { info_tbl: [(c4Hr7,
                       label: Foreign.Storable.$fStorableWord15_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hr7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Hrb; else goto c4Hrc;
       c4Hrb: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord15_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Hrc: // global
           I64[Sp - 8] = block_c4Hr4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Hrg; else goto c4Hr5;
       u4Hrg: // global
           call _c4Hr4(R1) args: 0, res: 0, upd: 0;
       c4Hr5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hr4() //  [R1]
         { info_tbl: [(c4Hr4,
                       label: block_c4Hr4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hr4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Hrf; else goto c4Hre;
       c4Hrf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Hre: // global
           _s4Fkq::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4Fkq::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.685991367 UTC

[section ""data" . Foreign.Storable.$fStorableWord18_closure" {
     Foreign.Storable.$fStorableWord18_closure:
         const Foreign.Storable.$fStorableWord18_info;
 },
 Foreign.Storable.$fStorableWord18_entry() //  [R2, R3]
         { info_tbl: [(c4Hrz,
                       label: Foreign.Storable.$fStorableWord18_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hrz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HrL; else goto c4HrM;
       c4HrL: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord18_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HrM: // global
           I64[Sp - 16] = block_c4Hrw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HrS; else goto c4Hrx;
       u4HrS: // global
           call _c4Hrw(R1) args: 0, res: 0, upd: 0;
       c4Hrx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hrw() //  [R1]
         { info_tbl: [(c4Hrw,
                       label: block_c4Hrw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hrw: // global
           I64[Sp] = block_c4HrC_info;
           _s4Fkw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fkw::I64;
           if (R1 & 7 != 0) goto u4HrR; else goto c4HrD;
       u4HrR: // global
           call _c4HrC(R1) args: 0, res: 0, upd: 0;
       c4HrD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HrC() //  [R1]
         { info_tbl: [(c4HrC,
                       label: block_c4HrC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HrC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HrQ; else goto c4HrP;
       c4HrQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HrP: // global
           _s4FkC::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4FkC::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.694275428 UTC

[section ""data" . Foreign.Storable.$fStorableWord14_closure" {
     Foreign.Storable.$fStorableWord14_closure:
         const Foreign.Storable.$fStorableWord14_info;
 },
 Foreign.Storable.$fStorableWord14_entry() //  [R2, R3]
         { info_tbl: [(c4Hsg,
                       label: Foreign.Storable.$fStorableWord14_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hsg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Hsk; else goto c4Hsl;
       c4Hsk: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord14_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Hsl: // global
           I64[Sp - 16] = block_c4Hsd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Hst; else goto c4Hse;
       u4Hst: // global
           call _c4Hsd(R1) args: 0, res: 0, upd: 0;
       c4Hse: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hsd() //  [R1]
         { info_tbl: [(c4Hsd,
                       label: block_c4Hsd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hsd: // global
           I64[Sp] = block_c4Hsj_info;
           _s4FkI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FkI::I64;
           if (R1 & 7 != 0) goto u4Hss; else goto c4Hsn;
       u4Hss: // global
           call _c4Hsj(R1) args: 0, res: 0, upd: 0;
       c4Hsn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hsj() //  [R1]
         { info_tbl: [(c4Hsj,
                       label: block_c4Hsj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hsj: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.702595534 UTC

[section ""data" . Foreign.Storable.$fStorableWord17_closure" {
     Foreign.Storable.$fStorableWord17_closure:
         const Foreign.Storable.$fStorableWord17_info;
 },
 Foreign.Storable.$fStorableWord17_entry() //  [R2, R3, R4]
         { info_tbl: [(c4HsR,
                       label: Foreign.Storable.$fStorableWord17_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HsR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Ht0; else goto c4Ht1;
       c4Ht0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord17_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Ht1: // global
           I64[Sp - 24] = block_c4HsO_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Htb; else goto c4HsP;
       u4Htb: // global
           call _c4HsO(R1) args: 0, res: 0, upd: 0;
       c4HsP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HsO() //  [R1]
         { info_tbl: [(c4HsO,
                       label: block_c4HsO_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HsO: // global
           I64[Sp] = block_c4HsU_info;
           _s4FkR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FkR::I64;
           if (R1 & 7 != 0) goto u4Hta; else goto c4HsV;
       u4Hta: // global
           call _c4HsU(R1) args: 0, res: 0, upd: 0;
       c4HsV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HsU() //  [R1]
         { info_tbl: [(c4HsU,
                       label: block_c4HsU_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HsU: // global
           I64[Sp] = block_c4HsZ_info;
           _s4FkT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FkT::I64;
           if (R1 & 7 != 0) goto u4Htc; else goto c4Ht4;
       u4Htc: // global
           call _c4HsZ(R1) args: 0, res: 0, upd: 0;
       c4Ht4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HsZ() //  [R1]
         { info_tbl: [(c4HsZ,
                       label: block_c4HsZ_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HsZ: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.712507191 UTC

[section ""data" . Foreign.Storable.$fStorableWord64_closure" {
     Foreign.Storable.$fStorableWord64_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableWord64_$calignment_closure+1;
         const Foreign.Storable.$fStorableWord64_$calignment_closure+1;
         const GHC.Storable.readWord64OffPtr1_closure+3;
         const GHC.Storable.writeWord64OffPtr1_closure+4;
         const Foreign.Storable.$fStorableWord18_closure+3;
         const Foreign.Storable.$fStorableWord17_closure+4;
         const Foreign.Storable.$fStorableWord15_closure+2;
         const Foreign.Storable.$fStorableWord14_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.715293142 UTC

[section ""data" . Foreign.Storable.$fStorableWord11_closure" {
     Foreign.Storable.$fStorableWord11_closure:
         const Foreign.Storable.$fStorableWord11_info;
 },
 Foreign.Storable.$fStorableWord11_entry() //  [R2]
         { info_tbl: [(c4HtG,
                       label: Foreign.Storable.$fStorableWord11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HtG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4HtK; else goto c4HtL;
       c4HtK: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord11_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4HtL: // global
           I64[Sp - 8] = block_c4HtD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4HtP; else goto c4HtE;
       u4HtP: // global
           call _c4HtD(R1) args: 0, res: 0, upd: 0;
       c4HtE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HtD() //  [R1]
         { info_tbl: [(c4HtD,
                       label: block_c4HtD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HtD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HtO; else goto c4HtN;
       c4HtO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HtN: // global
           _s4Fl4::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s4Fl4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.721771957 UTC

[section ""data" . Foreign.Storable.$fStorableWord13_closure" {
     Foreign.Storable.$fStorableWord13_closure:
         const Foreign.Storable.$fStorableWord13_info;
 },
 Foreign.Storable.$fStorableWord13_entry() //  [R2, R3]
         { info_tbl: [(c4Hu8,
                       label: Foreign.Storable.$fStorableWord13_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hu8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Huk; else goto c4Hul;
       c4Huk: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord13_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Hul: // global
           I64[Sp - 16] = block_c4Hu5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Hur; else goto c4Hu6;
       u4Hur: // global
           call _c4Hu5(R1) args: 0, res: 0, upd: 0;
       c4Hu6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hu5() //  [R1]
         { info_tbl: [(c4Hu5,
                       label: block_c4Hu5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hu5: // global
           I64[Sp] = block_c4Hub_info;
           _s4Fla::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fla::I64;
           if (R1 & 7 != 0) goto u4Huq; else goto c4Huc;
       u4Huq: // global
           call _c4Hub(R1) args: 0, res: 0, upd: 0;
       c4Huc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hub() //  [R1]
         { info_tbl: [(c4Hub,
                       label: block_c4Hub_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hub: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Hup; else goto c4Huo;
       c4Hup: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Huo: // global
           _s4Flg::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s4Flg::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.730810851 UTC

[section ""data" . Foreign.Storable.$fStorableWord10_closure" {
     Foreign.Storable.$fStorableWord10_closure:
         const Foreign.Storable.$fStorableWord10_info;
 },
 Foreign.Storable.$fStorableWord10_entry() //  [R2, R3]
         { info_tbl: [(c4HuP,
                       label: Foreign.Storable.$fStorableWord10_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HuP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HuT; else goto c4HuU;
       c4HuT: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord10_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HuU: // global
           I64[Sp - 16] = block_c4HuM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Hv2; else goto c4HuN;
       u4Hv2: // global
           call _c4HuM(R1) args: 0, res: 0, upd: 0;
       c4HuN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HuM() //  [R1]
         { info_tbl: [(c4HuM,
                       label: block_c4HuM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HuM: // global
           I64[Sp] = block_c4HuS_info;
           _s4Flm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Flm::I64;
           if (R1 & 7 != 0) goto u4Hv1; else goto c4HuW;
       u4Hv1: // global
           call _c4HuS(R1) args: 0, res: 0, upd: 0;
       c4HuW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HuS() //  [R1]
         { info_tbl: [(c4HuS,
                       label: block_c4HuS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HuS: // global
           I32[I64[Sp + 8]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.738689574 UTC

[section ""data" . Foreign.Storable.$fStorableWord12_closure" {
     Foreign.Storable.$fStorableWord12_closure:
         const Foreign.Storable.$fStorableWord12_info;
 },
 Foreign.Storable.$fStorableWord12_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Hvq,
                       label: Foreign.Storable.$fStorableWord12_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hvq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Hvz; else goto c4HvA;
       c4Hvz: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord12_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HvA: // global
           I64[Sp - 24] = block_c4Hvn_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4HvK; else goto c4Hvo;
       u4HvK: // global
           call _c4Hvn(R1) args: 0, res: 0, upd: 0;
       c4Hvo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hvn() //  [R1]
         { info_tbl: [(c4Hvn,
                       label: block_c4Hvn_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hvn: // global
           I64[Sp] = block_c4Hvt_info;
           _s4Flv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Flv::I64;
           if (R1 & 7 != 0) goto u4HvJ; else goto c4Hvu;
       u4HvJ: // global
           call _c4Hvt(R1) args: 0, res: 0, upd: 0;
       c4Hvu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hvt() //  [R1]
         { info_tbl: [(c4Hvt,
                       label: block_c4Hvt_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hvt: // global
           I64[Sp] = block_c4Hvy_info;
           _s4Flx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Flx::I64;
           if (R1 & 7 != 0) goto u4HvL; else goto c4HvD;
       u4HvL: // global
           call _c4Hvy(R1) args: 0, res: 0, upd: 0;
       c4HvD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hvy() //  [R1]
         { info_tbl: [(c4Hvy,
                       label: block_c4Hvy_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hvy: // global
           I32[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.749695166 UTC

[section ""data" . Foreign.Storable.$fStorableWord32_closure" {
     Foreign.Storable.$fStorableWord32_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableWord32_$calignment_closure+1;
         const Foreign.Storable.$fStorableWord32_$calignment_closure+1;
         const GHC.Storable.readWord32OffPtr1_closure+3;
         const GHC.Storable.writeWord32OffPtr1_closure+4;
         const Foreign.Storable.$fStorableWord13_closure+3;
         const Foreign.Storable.$fStorableWord12_closure+4;
         const Foreign.Storable.$fStorableWord11_closure+2;
         const Foreign.Storable.$fStorableWord10_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.75314902 UTC

[section ""data" . Foreign.Storable.$fStorableWord6_closure" {
     Foreign.Storable.$fStorableWord6_closure:
         const Foreign.Storable.$fStorableWord6_info;
 },
 Foreign.Storable.$fStorableWord6_entry() //  [R2]
         { info_tbl: [(c4Hwf,
                       label: Foreign.Storable.$fStorableWord6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hwf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Hwj; else goto c4Hwk;
       c4Hwj: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Hwk: // global
           I64[Sp - 8] = block_c4Hwc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Hwo; else goto c4Hwd;
       u4Hwo: // global
           call _c4Hwc(R1) args: 0, res: 0, upd: 0;
       c4Hwd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hwc() //  [R1]
         { info_tbl: [(c4Hwc,
                       label: block_c4Hwc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hwc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Hwn; else goto c4Hwm;
       c4Hwn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Hwm: // global
           _s4FlI::I64 = %MO_UU_Conv_W16_W64(I16[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s4FlI::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.760594535 UTC

[section ""data" . Foreign.Storable.$fStorableWord9_closure" {
     Foreign.Storable.$fStorableWord9_closure:
         const Foreign.Storable.$fStorableWord9_info;
 },
 Foreign.Storable.$fStorableWord9_entry() //  [R2, R3]
         { info_tbl: [(c4HwH,
                       label: Foreign.Storable.$fStorableWord9_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HwH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HwT; else goto c4HwU;
       c4HwT: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord9_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HwU: // global
           I64[Sp - 16] = block_c4HwE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Hx0; else goto c4HwF;
       u4Hx0: // global
           call _c4HwE(R1) args: 0, res: 0, upd: 0;
       c4HwF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HwE() //  [R1]
         { info_tbl: [(c4HwE,
                       label: block_c4HwE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HwE: // global
           I64[Sp] = block_c4HwK_info;
           _s4FlO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FlO::I64;
           if (R1 & 7 != 0) goto u4HwZ; else goto c4HwL;
       u4HwZ: // global
           call _c4HwK(R1) args: 0, res: 0, upd: 0;
       c4HwL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HwK() //  [R1]
         { info_tbl: [(c4HwK,
                       label: block_c4HwK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HwK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HwY; else goto c4HwX;
       c4HwY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HwX: // global
           _s4FlU::I64 = %MO_UU_Conv_W16_W64(I16[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s4FlU::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.769196327 UTC

[section ""data" . Foreign.Storable.$fStorableWord5_closure" {
     Foreign.Storable.$fStorableWord5_closure:
         const Foreign.Storable.$fStorableWord5_info;
 },
 Foreign.Storable.$fStorableWord5_entry() //  [R2, R3]
         { info_tbl: [(c4Hxo,
                       label: Foreign.Storable.$fStorableWord5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hxo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Hxs; else goto c4Hxt;
       c4Hxs: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Hxt: // global
           I64[Sp - 16] = block_c4Hxl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HxB; else goto c4Hxm;
       u4HxB: // global
           call _c4Hxl(R1) args: 0, res: 0, upd: 0;
       c4Hxm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hxl() //  [R1]
         { info_tbl: [(c4Hxl,
                       label: block_c4Hxl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hxl: // global
           I64[Sp] = block_c4Hxr_info;
           _s4Fm0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fm0::I64;
           if (R1 & 7 != 0) goto u4HxA; else goto c4Hxv;
       u4HxA: // global
           call _c4Hxr(R1) args: 0, res: 0, upd: 0;
       c4Hxv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hxr() //  [R1]
         { info_tbl: [(c4Hxr,
                       label: block_c4Hxr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hxr: // global
           I16[I64[Sp + 8]] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.7777441 UTC

[section ""data" . Foreign.Storable.$fStorableWord7_closure" {
     Foreign.Storable.$fStorableWord7_closure:
         const Foreign.Storable.$fStorableWord7_info;
 },
 Foreign.Storable.$fStorableWord7_entry() //  [R2, R3, R4]
         { info_tbl: [(c4HxZ,
                       label: Foreign.Storable.$fStorableWord7_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HxZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Hy8; else goto c4Hy9;
       c4Hy8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord7_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Hy9: // global
           I64[Sp - 24] = block_c4HxW_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Hyj; else goto c4HxX;
       u4Hyj: // global
           call _c4HxW(R1) args: 0, res: 0, upd: 0;
       c4HxX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HxW() //  [R1]
         { info_tbl: [(c4HxW,
                       label: block_c4HxW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HxW: // global
           I64[Sp] = block_c4Hy2_info;
           _s4Fm9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fm9::I64;
           if (R1 & 7 != 0) goto u4Hyi; else goto c4Hy3;
       u4Hyi: // global
           call _c4Hy2(R1) args: 0, res: 0, upd: 0;
       c4Hy3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hy2() //  [R1]
         { info_tbl: [(c4Hy2,
                       label: block_c4Hy2_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hy2: // global
           I64[Sp] = block_c4Hy7_info;
           _s4Fmb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fmb::I64;
           if (R1 & 7 != 0) goto u4Hyk; else goto c4Hyc;
       u4Hyk: // global
           call _c4Hy7(R1) args: 0, res: 0, upd: 0;
       c4Hyc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hy7() //  [R1]
         { info_tbl: [(c4Hy7,
                       label: block_c4Hy7_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hy7: // global
           I16[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.788232291 UTC

[section ""data" . Foreign.Storable.$fStorableWord16_closure" {
     Foreign.Storable.$fStorableWord16_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableWord16_$calignment_closure+1;
         const Foreign.Storable.$fStorableWord16_$calignment_closure+1;
         const GHC.Storable.readWord16OffPtr1_closure+3;
         const GHC.Storable.writeWord16OffPtr1_closure+4;
         const Foreign.Storable.$fStorableWord9_closure+3;
         const Foreign.Storable.$fStorableWord7_closure+4;
         const Foreign.Storable.$fStorableWord6_closure+2;
         const Foreign.Storable.$fStorableWord5_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.7910799 UTC

[section ""data" . Foreign.Storable.$fStorableDouble2_closure" {
     Foreign.Storable.$fStorableDouble2_closure:
         const Foreign.Storable.$fStorableDouble2_info;
 },
 Foreign.Storable.$fStorableDouble2_entry() //  [R2]
         { info_tbl: [(c4HyO,
                       label: Foreign.Storable.$fStorableDouble2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HyO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4HyS; else goto c4HyT;
       c4HyS: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableDouble2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4HyT: // global
           I64[Sp - 8] = block_c4HyL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4HyX; else goto c4HyM;
       u4HyX: // global
           call _c4HyL(R1) args: 0, res: 0, upd: 0;
       c4HyM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HyL() //  [R1]
         { info_tbl: [(c4HyL,
                       label: block_c4HyL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HyL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HyW; else goto c4HyV;
       c4HyW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HyV: // global
           _s4Fmm::F64 = F64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _s4Fmm::F64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.797608164 UTC

[section ""data" . Foreign.Storable.$fStorableDouble4_closure" {
     Foreign.Storable.$fStorableDouble4_closure:
         const Foreign.Storable.$fStorableDouble4_info;
 },
 Foreign.Storable.$fStorableDouble4_entry() //  [R2, R3]
         { info_tbl: [(c4Hzg,
                       label: Foreign.Storable.$fStorableDouble4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hzg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Hzs; else goto c4Hzt;
       c4Hzs: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableDouble4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Hzt: // global
           I64[Sp - 16] = block_c4Hzd_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Hzz; else goto c4Hze;
       u4Hzz: // global
           call _c4Hzd(R1) args: 0, res: 0, upd: 0;
       c4Hze: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hzd() //  [R1]
         { info_tbl: [(c4Hzd,
                       label: block_c4Hzd_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hzd: // global
           I64[Sp] = block_c4Hzj_info;
           _s4Fms::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fms::I64;
           if (R1 & 7 != 0) goto u4Hzy; else goto c4Hzk;
       u4Hzy: // global
           call _c4Hzj(R1) args: 0, res: 0, upd: 0;
       c4Hzk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Hzj() //  [R1]
         { info_tbl: [(c4Hzj,
                       label: block_c4Hzj_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Hzj: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Hzx; else goto c4Hzw;
       c4Hzx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Hzw: // global
           _s4Fmy::F64 = F64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _s4Fmy::F64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.806069901 UTC

[section ""data" . Foreign.Storable.$fStorableDouble1_closure" {
     Foreign.Storable.$fStorableDouble1_closure:
         const Foreign.Storable.$fStorableDouble1_info;
 },
 Foreign.Storable.$fStorableDouble1_entry() //  [R2, R3]
         { info_tbl: [(c4HzX,
                       label: Foreign.Storable.$fStorableDouble1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HzX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HA1; else goto c4HA2;
       c4HA1: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableDouble1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HA2: // global
           I64[Sp - 16] = block_c4HzU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HAa; else goto c4HzV;
       u4HAa: // global
           call _c4HzU(R1) args: 0, res: 0, upd: 0;
       c4HzV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HzU() //  [R1]
         { info_tbl: [(c4HzU,
                       label: block_c4HzU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HzU: // global
           I64[Sp] = block_c4HA0_info;
           _s4FmE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FmE::I64;
           if (R1 & 7 != 0) goto u4HA9; else goto c4HA4;
       u4HA9: // global
           call _c4HA0(R1) args: 0, res: 0, upd: 0;
       c4HA4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HA0() //  [R1]
         { info_tbl: [(c4HA0,
                       label: block_c4HA0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HA0: // global
           F64[I64[Sp + 8]] = F64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.816068957 UTC

[section ""data" . Foreign.Storable.$fStorableDouble3_closure" {
     Foreign.Storable.$fStorableDouble3_closure:
         const Foreign.Storable.$fStorableDouble3_info;
 },
 Foreign.Storable.$fStorableDouble3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4HAy,
                       label: Foreign.Storable.$fStorableDouble3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HAy: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4HAH; else goto c4HAI;
       c4HAH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableDouble3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HAI: // global
           I64[Sp - 24] = block_c4HAv_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4HAS; else goto c4HAw;
       u4HAS: // global
           call _c4HAv(R1) args: 0, res: 0, upd: 0;
       c4HAw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HAv() //  [R1]
         { info_tbl: [(c4HAv,
                       label: block_c4HAv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HAv: // global
           I64[Sp] = block_c4HAB_info;
           _s4FmN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FmN::I64;
           if (R1 & 7 != 0) goto u4HAR; else goto c4HAC;
       u4HAR: // global
           call _c4HAB(R1) args: 0, res: 0, upd: 0;
       c4HAC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HAB() //  [R1]
         { info_tbl: [(c4HAB,
                       label: block_c4HAB_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HAB: // global
           I64[Sp] = block_c4HAG_info;
           _s4FmP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FmP::I64;
           if (R1 & 7 != 0) goto u4HAT; else goto c4HAL;
       u4HAT: // global
           call _c4HAG(R1) args: 0, res: 0, upd: 0;
       c4HAL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HAG() //  [R1]
         { info_tbl: [(c4HAG,
                       label: block_c4HAG_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HAG: // global
           F64[I64[Sp + 8] + I64[Sp + 16]] = F64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.826339484 UTC

[section ""data" . Foreign.Storable.$fStorableDouble_closure" {
     Foreign.Storable.$fStorableDouble_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableDouble_$calignment_closure+1;
         const Foreign.Storable.$fStorableDouble_$calignment_closure+1;
         const GHC.Storable.readDoubleOffPtr1_closure+3;
         const GHC.Storable.writeDoubleOffPtr1_closure+4;
         const Foreign.Storable.$fStorableDouble4_closure+3;
         const Foreign.Storable.$fStorableDouble3_closure+4;
         const Foreign.Storable.$fStorableDouble2_closure+2;
         const Foreign.Storable.$fStorableDouble1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.82985029 UTC

[section ""data" . Foreign.Storable.$fStorableFloat2_closure" {
     Foreign.Storable.$fStorableFloat2_closure:
         const Foreign.Storable.$fStorableFloat2_info;
 },
 Foreign.Storable.$fStorableFloat2_entry() //  [R2]
         { info_tbl: [(c4HBn,
                       label: Foreign.Storable.$fStorableFloat2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HBn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4HBr; else goto c4HBs;
       c4HBr: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFloat2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4HBs: // global
           I64[Sp - 8] = block_c4HBk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4HBw; else goto c4HBl;
       u4HBw: // global
           call _c4HBk(R1) args: 0, res: 0, upd: 0;
       c4HBl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HBk() //  [R1]
         { info_tbl: [(c4HBk,
                       label: block_c4HBk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HBk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HBv; else goto c4HBu;
       c4HBv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HBu: // global
           _s4Fn0::F32 = F32[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _s4Fn0::F32;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.836151216 UTC

[section ""data" . Foreign.Storable.$fStorableFloat4_closure" {
     Foreign.Storable.$fStorableFloat4_closure:
         const Foreign.Storable.$fStorableFloat4_info;
 },
 Foreign.Storable.$fStorableFloat4_entry() //  [R2, R3]
         { info_tbl: [(c4HBP,
                       label: Foreign.Storable.$fStorableFloat4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HBP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HC1; else goto c4HC2;
       c4HC1: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFloat4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HC2: // global
           I64[Sp - 16] = block_c4HBM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HC8; else goto c4HBN;
       u4HC8: // global
           call _c4HBM(R1) args: 0, res: 0, upd: 0;
       c4HBN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HBM() //  [R1]
         { info_tbl: [(c4HBM,
                       label: block_c4HBM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HBM: // global
           I64[Sp] = block_c4HBS_info;
           _s4Fn6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fn6::I64;
           if (R1 & 7 != 0) goto u4HC7; else goto c4HBT;
       u4HC7: // global
           call _c4HBS(R1) args: 0, res: 0, upd: 0;
       c4HBT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HBS() //  [R1]
         { info_tbl: [(c4HBS,
                       label: block_c4HBS_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HBS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HC6; else goto c4HC5;
       c4HC6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HC5: // global
           _s4Fnc::F32 = F32[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _s4Fnc::F32;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.844539237 UTC

[section ""data" . Foreign.Storable.$fStorableFloat1_closure" {
     Foreign.Storable.$fStorableFloat1_closure:
         const Foreign.Storable.$fStorableFloat1_info;
 },
 Foreign.Storable.$fStorableFloat1_entry() //  [R2, R3]
         { info_tbl: [(c4HCw,
                       label: Foreign.Storable.$fStorableFloat1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HCw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HCA; else goto c4HCB;
       c4HCA: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFloat1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HCB: // global
           I64[Sp - 16] = block_c4HCt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HCJ; else goto c4HCu;
       u4HCJ: // global
           call _c4HCt(R1) args: 0, res: 0, upd: 0;
       c4HCu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HCt() //  [R1]
         { info_tbl: [(c4HCt,
                       label: block_c4HCt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HCt: // global
           I64[Sp] = block_c4HCz_info;
           _s4Fni::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fni::I64;
           if (R1 & 7 != 0) goto u4HCI; else goto c4HCD;
       u4HCI: // global
           call _c4HCz(R1) args: 0, res: 0, upd: 0;
       c4HCD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HCz() //  [R1]
         { info_tbl: [(c4HCz,
                       label: block_c4HCz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HCz: // global
           F32[I64[Sp + 8]] = F32[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.852640859 UTC

[section ""data" . Foreign.Storable.$fStorableFloat3_closure" {
     Foreign.Storable.$fStorableFloat3_closure:
         const Foreign.Storable.$fStorableFloat3_info;
 },
 Foreign.Storable.$fStorableFloat3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4HD7,
                       label: Foreign.Storable.$fStorableFloat3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HD7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4HDg; else goto c4HDh;
       c4HDg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFloat3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HDh: // global
           I64[Sp - 24] = block_c4HD4_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4HDr; else goto c4HD5;
       u4HDr: // global
           call _c4HD4(R1) args: 0, res: 0, upd: 0;
       c4HD5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HD4() //  [R1]
         { info_tbl: [(c4HD4,
                       label: block_c4HD4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HD4: // global
           I64[Sp] = block_c4HDa_info;
           _s4Fnr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fnr::I64;
           if (R1 & 7 != 0) goto u4HDq; else goto c4HDb;
       u4HDq: // global
           call _c4HDa(R1) args: 0, res: 0, upd: 0;
       c4HDb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HDa() //  [R1]
         { info_tbl: [(c4HDa,
                       label: block_c4HDa_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HDa: // global
           I64[Sp] = block_c4HDf_info;
           _s4Fnt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fnt::I64;
           if (R1 & 7 != 0) goto u4HDs; else goto c4HDk;
       u4HDs: // global
           call _c4HDf(R1) args: 0, res: 0, upd: 0;
       c4HDk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HDf() //  [R1]
         { info_tbl: [(c4HDf,
                       label: block_c4HDf_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HDf: // global
           F32[I64[Sp + 8] + I64[Sp + 16]] = F32[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.862286313 UTC

[section ""data" . Foreign.Storable.$fStorableFloat_closure" {
     Foreign.Storable.$fStorableFloat_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableFloat_$calignment_closure+1;
         const Foreign.Storable.$fStorableFloat_$calignment_closure+1;
         const GHC.Storable.readFloatOffPtr1_closure+3;
         const GHC.Storable.writeFloatOffPtr1_closure+4;
         const Foreign.Storable.$fStorableFloat4_closure+3;
         const Foreign.Storable.$fStorableFloat3_closure+4;
         const Foreign.Storable.$fStorableFloat2_closure+2;
         const Foreign.Storable.$fStorableFloat1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.864788627 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr2_closure" {
     Foreign.Storable.$fStorableStablePtr2_closure:
         const Foreign.Storable.$fStorableStablePtr2_info;
 },
 Foreign.Storable.$fStorableStablePtr2_entry() //  [R2]
         { info_tbl: [(c4HDW,
                       label: Foreign.Storable.$fStorableStablePtr2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HDW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4HE0; else goto c4HE1;
       c4HE0: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableStablePtr2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4HE1: // global
           I64[Sp - 8] = block_c4HDT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4HE5; else goto c4HDU;
       u4HE5: // global
           call _c4HDT(R1) args: 0, res: 0, upd: 0;
       c4HDU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HDT() //  [R1]
         { info_tbl: [(c4HDT,
                       label: block_c4HDT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HDT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HE4; else goto c4HE3;
       c4HE4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HE3: // global
           _s4FnE::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Stable.StablePtr_con_info;
           I64[Hp] = _s4FnE::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.872539447 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr4_closure" {
     Foreign.Storable.$fStorableStablePtr4_closure:
         const Foreign.Storable.$fStorableStablePtr4_info;
 },
 Foreign.Storable.$fStorableStablePtr4_entry() //  [R2, R3]
         { info_tbl: [(c4HEo,
                       label: Foreign.Storable.$fStorableStablePtr4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HEo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HEA; else goto c4HEB;
       c4HEA: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableStablePtr4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HEB: // global
           I64[Sp - 16] = block_c4HEl_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HEH; else goto c4HEm;
       u4HEH: // global
           call _c4HEl(R1) args: 0, res: 0, upd: 0;
       c4HEm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HEl() //  [R1]
         { info_tbl: [(c4HEl,
                       label: block_c4HEl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HEl: // global
           I64[Sp] = block_c4HEr_info;
           _s4FnK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FnK::I64;
           if (R1 & 7 != 0) goto u4HEG; else goto c4HEs;
       u4HEG: // global
           call _c4HEr(R1) args: 0, res: 0, upd: 0;
       c4HEs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HEr() //  [R1]
         { info_tbl: [(c4HEr,
                       label: block_c4HEr_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HEr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HEF; else goto c4HEE;
       c4HEF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HEE: // global
           _s4FnQ::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Stable.StablePtr_con_info;
           I64[Hp] = _s4FnQ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.882305219 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr1_closure" {
     Foreign.Storable.$fStorableStablePtr1_closure:
         const Foreign.Storable.$fStorableStablePtr1_info;
 },
 Foreign.Storable.$fStorableStablePtr1_entry() //  [R2, R3]
         { info_tbl: [(c4HF5,
                       label: Foreign.Storable.$fStorableStablePtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HF5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HF9; else goto c4HFa;
       c4HF9: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableStablePtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HFa: // global
           I64[Sp - 16] = block_c4HF2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HFi; else goto c4HF3;
       u4HFi: // global
           call _c4HF2(R1) args: 0, res: 0, upd: 0;
       c4HF3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HF2() //  [R1]
         { info_tbl: [(c4HF2,
                       label: block_c4HF2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HF2: // global
           I64[Sp] = block_c4HF8_info;
           _s4FnW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FnW::I64;
           if (R1 & 7 != 0) goto u4HFh; else goto c4HFc;
       u4HFh: // global
           call _c4HF8(R1) args: 0, res: 0, upd: 0;
       c4HFc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HF8() //  [R1]
         { info_tbl: [(c4HF8,
                       label: block_c4HF8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HF8: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.890808506 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr3_closure" {
     Foreign.Storable.$fStorableStablePtr3_closure:
         const Foreign.Storable.$fStorableStablePtr3_info;
 },
 Foreign.Storable.$fStorableStablePtr3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4HFG,
                       label: Foreign.Storable.$fStorableStablePtr3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HFG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4HFP; else goto c4HFQ;
       c4HFP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableStablePtr3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HFQ: // global
           I64[Sp - 24] = block_c4HFD_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4HG0; else goto c4HFE;
       u4HG0: // global
           call _c4HFD(R1) args: 0, res: 0, upd: 0;
       c4HFE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HFD() //  [R1]
         { info_tbl: [(c4HFD,
                       label: block_c4HFD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HFD: // global
           I64[Sp] = block_c4HFJ_info;
           _s4Fo5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fo5::I64;
           if (R1 & 7 != 0) goto u4HFZ; else goto c4HFK;
       u4HFZ: // global
           call _c4HFJ(R1) args: 0, res: 0, upd: 0;
       c4HFK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HFJ() //  [R1]
         { info_tbl: [(c4HFJ,
                       label: block_c4HFJ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HFJ: // global
           I64[Sp] = block_c4HFO_info;
           _s4Fo7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fo7::I64;
           if (R1 & 7 != 0) goto u4HG1; else goto c4HFT;
       u4HG1: // global
           call _c4HFO(R1) args: 0, res: 0, upd: 0;
       c4HFT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HFO() //  [R1]
         { info_tbl: [(c4HFO,
                       label: block_c4HFO_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HFO: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.90391477 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr_closure" {
     Foreign.Storable.$fStorableStablePtr_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableStablePtr_$calignment_closure+1;
         const Foreign.Storable.$fStorableStablePtr_$calignment_closure+1;
         const GHC.Storable.readStablePtrOffPtr1_closure+3;
         const GHC.Storable.writeStablePtrOffPtr1_closure+4;
         const Foreign.Storable.$fStorableStablePtr4_closure+3;
         const Foreign.Storable.$fStorableStablePtr3_closure+4;
         const Foreign.Storable.$fStorableStablePtr2_closure+2;
         const Foreign.Storable.$fStorableStablePtr1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.906961216 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr2_closure" {
     Foreign.Storable.$fStorableFunPtr2_closure:
         const Foreign.Storable.$fStorableFunPtr2_info;
 },
 Foreign.Storable.$fStorableFunPtr2_entry() //  [R2]
         { info_tbl: [(c4HGv,
                       label: Foreign.Storable.$fStorableFunPtr2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HGv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4HGz; else goto c4HGA;
       c4HGz: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFunPtr2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4HGA: // global
           I64[Sp - 8] = block_c4HGs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4HGE; else goto c4HGt;
       u4HGE: // global
           call _c4HGs(R1) args: 0, res: 0, upd: 0;
       c4HGt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HGs() //  [R1]
         { info_tbl: [(c4HGs,
                       label: block_c4HGs_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HGs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HGD; else goto c4HGC;
       c4HGD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HGC: // global
           _s4Foi::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = _s4Foi::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.914662361 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr4_closure" {
     Foreign.Storable.$fStorableFunPtr4_closure:
         const Foreign.Storable.$fStorableFunPtr4_info;
 },
 Foreign.Storable.$fStorableFunPtr4_entry() //  [R2, R3]
         { info_tbl: [(c4HGX,
                       label: Foreign.Storable.$fStorableFunPtr4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HGX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HH9; else goto c4HHa;
       c4HH9: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFunPtr4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HHa: // global
           I64[Sp - 16] = block_c4HGU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HHg; else goto c4HGV;
       u4HHg: // global
           call _c4HGU(R1) args: 0, res: 0, upd: 0;
       c4HGV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HGU() //  [R1]
         { info_tbl: [(c4HGU,
                       label: block_c4HGU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HGU: // global
           I64[Sp] = block_c4HH0_info;
           _s4Foo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Foo::I64;
           if (R1 & 7 != 0) goto u4HHf; else goto c4HH1;
       u4HHf: // global
           call _c4HH0(R1) args: 0, res: 0, upd: 0;
       c4HH1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HH0() //  [R1]
         { info_tbl: [(c4HH0,
                       label: block_c4HH0_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HH0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HHe; else goto c4HHd;
       c4HHe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HHd: // global
           _s4Fou::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = _s4Fou::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.92299098 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr1_closure" {
     Foreign.Storable.$fStorableFunPtr1_closure:
         const Foreign.Storable.$fStorableFunPtr1_info;
 },
 Foreign.Storable.$fStorableFunPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4HHE,
                       label: Foreign.Storable.$fStorableFunPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HHE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HHI; else goto c4HHJ;
       c4HHI: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFunPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HHJ: // global
           I64[Sp - 16] = block_c4HHB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HHR; else goto c4HHC;
       u4HHR: // global
           call _c4HHB(R1) args: 0, res: 0, upd: 0;
       c4HHC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HHB() //  [R1]
         { info_tbl: [(c4HHB,
                       label: block_c4HHB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HHB: // global
           I64[Sp] = block_c4HHH_info;
           _s4FoA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FoA::I64;
           if (R1 & 7 != 0) goto u4HHQ; else goto c4HHL;
       u4HHQ: // global
           call _c4HHH(R1) args: 0, res: 0, upd: 0;
       c4HHL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HHH() //  [R1]
         { info_tbl: [(c4HHH,
                       label: block_c4HHH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HHH: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.931222956 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr3_closure" {
     Foreign.Storable.$fStorableFunPtr3_closure:
         const Foreign.Storable.$fStorableFunPtr3_info;
 },
 Foreign.Storable.$fStorableFunPtr3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4HIf,
                       label: Foreign.Storable.$fStorableFunPtr3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HIf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4HIo; else goto c4HIp;
       c4HIo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFunPtr3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HIp: // global
           I64[Sp - 24] = block_c4HIc_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4HIz; else goto c4HId;
       u4HIz: // global
           call _c4HIc(R1) args: 0, res: 0, upd: 0;
       c4HId: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HIc() //  [R1]
         { info_tbl: [(c4HIc,
                       label: block_c4HIc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HIc: // global
           I64[Sp] = block_c4HIi_info;
           _s4FoJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FoJ::I64;
           if (R1 & 7 != 0) goto u4HIy; else goto c4HIj;
       u4HIy: // global
           call _c4HIi(R1) args: 0, res: 0, upd: 0;
       c4HIj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HIi() //  [R1]
         { info_tbl: [(c4HIi,
                       label: block_c4HIi_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HIi: // global
           I64[Sp] = block_c4HIn_info;
           _s4FoL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FoL::I64;
           if (R1 & 7 != 0) goto u4HIA; else goto c4HIs;
       u4HIA: // global
           call _c4HIn(R1) args: 0, res: 0, upd: 0;
       c4HIs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HIn() //  [R1]
         { info_tbl: [(c4HIn,
                       label: block_c4HIn_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HIn: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.943727707 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr_closure" {
     Foreign.Storable.$fStorableFunPtr_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableFunPtr_$calignment_closure+1;
         const Foreign.Storable.$fStorableFunPtr_$calignment_closure+1;
         const GHC.Storable.readFunPtrOffPtr1_closure+3;
         const GHC.Storable.writeFunPtrOffPtr1_closure+4;
         const Foreign.Storable.$fStorableFunPtr4_closure+3;
         const Foreign.Storable.$fStorableFunPtr3_closure+4;
         const Foreign.Storable.$fStorableFunPtr2_closure+2;
         const Foreign.Storable.$fStorableFunPtr1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.946506394 UTC

[section ""data" . Foreign.Storable.$fStorablePtr2_closure" {
     Foreign.Storable.$fStorablePtr2_closure:
         const Foreign.Storable.$fStorablePtr2_info;
 },
 Foreign.Storable.$fStorablePtr2_entry() //  [R2]
         { info_tbl: [(c4HJ4,
                       label: Foreign.Storable.$fStorablePtr2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HJ4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4HJ8; else goto c4HJ9;
       c4HJ8: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorablePtr2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4HJ9: // global
           I64[Sp - 8] = block_c4HJ1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4HJd; else goto c4HJ2;
       u4HJd: // global
           call _c4HJ1(R1) args: 0, res: 0, upd: 0;
       c4HJ2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HJ1() //  [R1]
         { info_tbl: [(c4HJ1,
                       label: block_c4HJ1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HJ1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HJc; else goto c4HJb;
       c4HJc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HJb: // global
           _s4FoW::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4FoW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.953840591 UTC

[section ""data" . Foreign.Storable.$fStorablePtr4_closure" {
     Foreign.Storable.$fStorablePtr4_closure:
         const Foreign.Storable.$fStorablePtr4_info;
 },
 Foreign.Storable.$fStorablePtr4_entry() //  [R2, R3]
         { info_tbl: [(c4HJw,
                       label: Foreign.Storable.$fStorablePtr4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HJw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HJI; else goto c4HJJ;
       c4HJI: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorablePtr4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HJJ: // global
           I64[Sp - 16] = block_c4HJt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HJP; else goto c4HJu;
       u4HJP: // global
           call _c4HJt(R1) args: 0, res: 0, upd: 0;
       c4HJu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HJt() //  [R1]
         { info_tbl: [(c4HJt,
                       label: block_c4HJt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HJt: // global
           I64[Sp] = block_c4HJz_info;
           _s4Fp2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fp2::I64;
           if (R1 & 7 != 0) goto u4HJO; else goto c4HJA;
       u4HJO: // global
           call _c4HJz(R1) args: 0, res: 0, upd: 0;
       c4HJA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HJz() //  [R1]
         { info_tbl: [(c4HJz,
                       label: block_c4HJz_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HJz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HJN; else goto c4HJM;
       c4HJN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HJM: // global
           _s4Fp8::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fp8::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.964415439 UTC

[section ""data" . Foreign.Storable.$fStorablePtr1_closure" {
     Foreign.Storable.$fStorablePtr1_closure:
         const Foreign.Storable.$fStorablePtr1_info;
 },
 Foreign.Storable.$fStorablePtr1_entry() //  [R2, R3]
         { info_tbl: [(c4HKd,
                       label: Foreign.Storable.$fStorablePtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HKd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HKh; else goto c4HKi;
       c4HKh: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorablePtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HKi: // global
           I64[Sp - 16] = block_c4HKa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HKq; else goto c4HKb;
       u4HKq: // global
           call _c4HKa(R1) args: 0, res: 0, upd: 0;
       c4HKb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HKa() //  [R1]
         { info_tbl: [(c4HKa,
                       label: block_c4HKa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HKa: // global
           I64[Sp] = block_c4HKg_info;
           _s4Fpe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fpe::I64;
           if (R1 & 7 != 0) goto u4HKp; else goto c4HKk;
       u4HKp: // global
           call _c4HKg(R1) args: 0, res: 0, upd: 0;
       c4HKk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HKg() //  [R1]
         { info_tbl: [(c4HKg,
                       label: block_c4HKg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HKg: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.973365258 UTC

[section ""data" . Foreign.Storable.$fStorablePtr3_closure" {
     Foreign.Storable.$fStorablePtr3_closure:
         const Foreign.Storable.$fStorablePtr3_info;
 },
 Foreign.Storable.$fStorablePtr3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4HKO,
                       label: Foreign.Storable.$fStorablePtr3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HKO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4HKX; else goto c4HKY;
       c4HKX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorablePtr3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HKY: // global
           I64[Sp - 24] = block_c4HKL_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4HL8; else goto c4HKM;
       u4HL8: // global
           call _c4HKL(R1) args: 0, res: 0, upd: 0;
       c4HKM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HKL() //  [R1]
         { info_tbl: [(c4HKL,
                       label: block_c4HKL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HKL: // global
           I64[Sp] = block_c4HKR_info;
           _s4Fpn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fpn::I64;
           if (R1 & 7 != 0) goto u4HL7; else goto c4HKS;
       u4HL7: // global
           call _c4HKR(R1) args: 0, res: 0, upd: 0;
       c4HKS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HKR() //  [R1]
         { info_tbl: [(c4HKR,
                       label: block_c4HKR_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HKR: // global
           I64[Sp] = block_c4HKW_info;
           _s4Fpp::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fpp::I64;
           if (R1 & 7 != 0) goto u4HL9; else goto c4HL1;
       u4HL9: // global
           call _c4HKW(R1) args: 0, res: 0, upd: 0;
       c4HL1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HKW() //  [R1]
         { info_tbl: [(c4HKW,
                       label: block_c4HKW_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HKW: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.983629053 UTC

[section ""data" . Foreign.Storable.$fStorablePtr_closure" {
     Foreign.Storable.$fStorablePtr_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorablePtr_$calignment_closure+1;
         const Foreign.Storable.$fStorablePtr_$calignment_closure+1;
         const GHC.Storable.readPtrOffPtr1_closure+3;
         const GHC.Storable.writePtrOffPtr1_closure+4;
         const Foreign.Storable.$fStorablePtr4_closure+3;
         const Foreign.Storable.$fStorablePtr3_closure+4;
         const Foreign.Storable.$fStorablePtr2_closure+2;
         const Foreign.Storable.$fStorablePtr1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.98613806 UTC

[section ""data" . Foreign.Storable.$fStorableWord2_closure" {
     Foreign.Storable.$fStorableWord2_closure:
         const Foreign.Storable.$fStorableWord2_info;
 },
 Foreign.Storable.$fStorableWord2_entry() //  [R2]
         { info_tbl: [(c4HLD,
                       label: Foreign.Storable.$fStorableWord2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HLD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4HLH; else goto c4HLI;
       c4HLH: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4HLI: // global
           I64[Sp - 8] = block_c4HLA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4HLM; else goto c4HLB;
       u4HLM: // global
           call _c4HLA(R1) args: 0, res: 0, upd: 0;
       c4HLB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HLA() //  [R1]
         { info_tbl: [(c4HLA,
                       label: block_c4HLA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HLA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HLL; else goto c4HLK;
       c4HLL: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HLK: // global
           _s4FpA::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s4FpA::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:31.992562768 UTC

[section ""data" . Foreign.Storable.$fStorableWord4_closure" {
     Foreign.Storable.$fStorableWord4_closure:
         const Foreign.Storable.$fStorableWord4_info;
 },
 Foreign.Storable.$fStorableWord4_entry() //  [R2, R3]
         { info_tbl: [(c4HM5,
                       label: Foreign.Storable.$fStorableWord4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HM5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HMh; else goto c4HMi;
       c4HMh: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HMi: // global
           I64[Sp - 16] = block_c4HM2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HMo; else goto c4HM3;
       u4HMo: // global
           call _c4HM2(R1) args: 0, res: 0, upd: 0;
       c4HM3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HM2() //  [R1]
         { info_tbl: [(c4HM2,
                       label: block_c4HM2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HM2: // global
           I64[Sp] = block_c4HM8_info;
           _s4FpG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FpG::I64;
           if (R1 & 7 != 0) goto u4HMn; else goto c4HM9;
       u4HMn: // global
           call _c4HM8(R1) args: 0, res: 0, upd: 0;
       c4HM9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HM8() //  [R1]
         { info_tbl: [(c4HM8,
                       label: block_c4HM8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HM8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HMm; else goto c4HMl;
       c4HMm: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HMl: // global
           _s4FpM::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s4FpM::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.001693929 UTC

[section ""data" . Foreign.Storable.$fStorableWord1_closure" {
     Foreign.Storable.$fStorableWord1_closure:
         const Foreign.Storable.$fStorableWord1_info;
 },
 Foreign.Storable.$fStorableWord1_entry() //  [R2, R3]
         { info_tbl: [(c4HMM,
                       label: Foreign.Storable.$fStorableWord1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HMM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HMQ; else goto c4HMR;
       c4HMQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HMR: // global
           I64[Sp - 16] = block_c4HMJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HMZ; else goto c4HMK;
       u4HMZ: // global
           call _c4HMJ(R1) args: 0, res: 0, upd: 0;
       c4HMK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HMJ() //  [R1]
         { info_tbl: [(c4HMJ,
                       label: block_c4HMJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HMJ: // global
           I64[Sp] = block_c4HMP_info;
           _s4FpS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FpS::I64;
           if (R1 & 7 != 0) goto u4HMY; else goto c4HMT;
       u4HMY: // global
           call _c4HMP(R1) args: 0, res: 0, upd: 0;
       c4HMT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HMP() //  [R1]
         { info_tbl: [(c4HMP,
                       label: block_c4HMP_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HMP: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.01089549 UTC

[section ""data" . Foreign.Storable.$fStorableWord3_closure" {
     Foreign.Storable.$fStorableWord3_closure:
         const Foreign.Storable.$fStorableWord3_info;
 },
 Foreign.Storable.$fStorableWord3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4HNn,
                       label: Foreign.Storable.$fStorableWord3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HNn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4HNw; else goto c4HNx;
       c4HNw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HNx: // global
           I64[Sp - 24] = block_c4HNk_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4HNH; else goto c4HNl;
       u4HNH: // global
           call _c4HNk(R1) args: 0, res: 0, upd: 0;
       c4HNl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HNk() //  [R1]
         { info_tbl: [(c4HNk,
                       label: block_c4HNk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HNk: // global
           I64[Sp] = block_c4HNq_info;
           _s4Fq1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fq1::I64;
           if (R1 & 7 != 0) goto u4HNG; else goto c4HNr;
       u4HNG: // global
           call _c4HNq(R1) args: 0, res: 0, upd: 0;
       c4HNr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HNq() //  [R1]
         { info_tbl: [(c4HNq,
                       label: block_c4HNq_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HNq: // global
           I64[Sp] = block_c4HNv_info;
           _s4Fq3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fq3::I64;
           if (R1 & 7 != 0) goto u4HNI; else goto c4HNA;
       u4HNI: // global
           call _c4HNv(R1) args: 0, res: 0, upd: 0;
       c4HNA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HNv() //  [R1]
         { info_tbl: [(c4HNv,
                       label: block_c4HNv_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HNv: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.019898424 UTC

[section ""data" . Foreign.Storable.$fStorableWord_closure" {
     Foreign.Storable.$fStorableWord_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableWord_$calignment_closure+1;
         const Foreign.Storable.$fStorableWord_$calignment_closure+1;
         const GHC.Storable.readWordOffPtr1_closure+3;
         const GHC.Storable.writeWordOffPtr1_closure+4;
         const Foreign.Storable.$fStorableWord4_closure+3;
         const Foreign.Storable.$fStorableWord3_closure+4;
         const Foreign.Storable.$fStorableWord2_closure+2;
         const Foreign.Storable.$fStorableWord1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.022418097 UTC

[section ""data" . Foreign.Storable.$fStorableInt2_closure" {
     Foreign.Storable.$fStorableInt2_closure:
         const Foreign.Storable.$fStorableInt2_info;
 },
 Foreign.Storable.$fStorableInt2_entry() //  [R2]
         { info_tbl: [(c4HOc,
                       label: Foreign.Storable.$fStorableInt2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HOc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4HOg; else goto c4HOh;
       c4HOg: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4HOh: // global
           I64[Sp - 8] = block_c4HO9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4HOl; else goto c4HOa;
       u4HOl: // global
           call _c4HO9(R1) args: 0, res: 0, upd: 0;
       c4HOa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HO9() //  [R1]
         { info_tbl: [(c4HO9,
                       label: block_c4HO9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HO9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HOk; else goto c4HOj;
       c4HOk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HOj: // global
           _s4Fqe::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4Fqe::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.029132706 UTC

[section ""data" . Foreign.Storable.$fStorableInt4_closure" {
     Foreign.Storable.$fStorableInt4_closure:
         const Foreign.Storable.$fStorableInt4_info;
 },
 Foreign.Storable.$fStorableInt4_entry() //  [R2, R3]
         { info_tbl: [(c4HOE,
                       label: Foreign.Storable.$fStorableInt4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HOE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HOQ; else goto c4HOR;
       c4HOQ: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HOR: // global
           I64[Sp - 16] = block_c4HOB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HOX; else goto c4HOC;
       u4HOX: // global
           call _c4HOB(R1) args: 0, res: 0, upd: 0;
       c4HOC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HOB() //  [R1]
         { info_tbl: [(c4HOB,
                       label: block_c4HOB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HOB: // global
           I64[Sp] = block_c4HOH_info;
           _s4Fqk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fqk::I64;
           if (R1 & 7 != 0) goto u4HOW; else goto c4HOI;
       u4HOW: // global
           call _c4HOH(R1) args: 0, res: 0, upd: 0;
       c4HOI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HOH() //  [R1]
         { info_tbl: [(c4HOH,
                       label: block_c4HOH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HOH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HOV; else goto c4HOU;
       c4HOV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HOU: // global
           _s4Fqq::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4Fqq::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.038342216 UTC

[section ""data" . Foreign.Storable.$fStorableInt1_closure" {
     Foreign.Storable.$fStorableInt1_closure:
         const Foreign.Storable.$fStorableInt1_info;
 },
 Foreign.Storable.$fStorableInt1_entry() //  [R2, R3]
         { info_tbl: [(c4HPl,
                       label: Foreign.Storable.$fStorableInt1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HPl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HPp; else goto c4HPq;
       c4HPp: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HPq: // global
           I64[Sp - 16] = block_c4HPi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HPy; else goto c4HPj;
       u4HPy: // global
           call _c4HPi(R1) args: 0, res: 0, upd: 0;
       c4HPj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HPi() //  [R1]
         { info_tbl: [(c4HPi,
                       label: block_c4HPi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HPi: // global
           I64[Sp] = block_c4HPo_info;
           _s4Fqw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fqw::I64;
           if (R1 & 7 != 0) goto u4HPx; else goto c4HPs;
       u4HPx: // global
           call _c4HPo(R1) args: 0, res: 0, upd: 0;
       c4HPs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HPo() //  [R1]
         { info_tbl: [(c4HPo,
                       label: block_c4HPo_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HPo: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.046218102 UTC

[section ""data" . Foreign.Storable.$fStorableInt3_closure" {
     Foreign.Storable.$fStorableInt3_closure:
         const Foreign.Storable.$fStorableInt3_info;
 },
 Foreign.Storable.$fStorableInt3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4HPW,
                       label: Foreign.Storable.$fStorableInt3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HPW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4HQ5; else goto c4HQ6;
       c4HQ5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HQ6: // global
           I64[Sp - 24] = block_c4HPT_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4HQg; else goto c4HPU;
       u4HQg: // global
           call _c4HPT(R1) args: 0, res: 0, upd: 0;
       c4HPU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HPT() //  [R1]
         { info_tbl: [(c4HPT,
                       label: block_c4HPT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HPT: // global
           I64[Sp] = block_c4HPZ_info;
           _s4FqF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FqF::I64;
           if (R1 & 7 != 0) goto u4HQf; else goto c4HQ0;
       u4HQf: // global
           call _c4HPZ(R1) args: 0, res: 0, upd: 0;
       c4HQ0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HPZ() //  [R1]
         { info_tbl: [(c4HPZ,
                       label: block_c4HPZ_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HPZ: // global
           I64[Sp] = block_c4HQ4_info;
           _s4FqH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FqH::I64;
           if (R1 & 7 != 0) goto u4HQh; else goto c4HQ9;
       u4HQh: // global
           call _c4HQ4(R1) args: 0, res: 0, upd: 0;
       c4HQ9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HQ4() //  [R1]
         { info_tbl: [(c4HQ4,
                       label: block_c4HQ4_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HQ4: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.055913023 UTC

[section ""data" . Foreign.Storable.$fStorableInt_closure" {
     Foreign.Storable.$fStorableInt_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt_$calignment_closure+1;
         const GHC.Storable.readIntOffPtr1_closure+3;
         const GHC.Storable.writeIntOffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt4_closure+3;
         const Foreign.Storable.$fStorableInt3_closure+4;
         const Foreign.Storable.$fStorableInt2_closure+2;
         const Foreign.Storable.$fStorableInt1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.058315583 UTC

[section ""data" . Foreign.Storable.$fStorableChar2_closure" {
     Foreign.Storable.$fStorableChar2_closure:
         const Foreign.Storable.$fStorableChar2_info;
 },
 Foreign.Storable.$fStorableChar2_entry() //  [R2]
         { info_tbl: [(c4HQL,
                       label: Foreign.Storable.$fStorableChar2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HQL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4HQP; else goto c4HQQ;
       c4HQP: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableChar2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4HQQ: // global
           I64[Sp - 8] = block_c4HQI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4HQU; else goto c4HQJ;
       u4HQU: // global
           call _c4HQI(R1) args: 0, res: 0, upd: 0;
       c4HQJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HQI() //  [R1]
         { info_tbl: [(c4HQI,
                       label: block_c4HQI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HQI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HQT; else goto c4HQS;
       c4HQT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HQS: // global
           _s4FqS::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s4FqS::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.064777528 UTC

[section ""data" . Foreign.Storable.$fStorableChar4_closure" {
     Foreign.Storable.$fStorableChar4_closure:
         const Foreign.Storable.$fStorableChar4_info;
 },
 Foreign.Storable.$fStorableChar4_entry() //  [R2, R3]
         { info_tbl: [(c4HRd,
                       label: Foreign.Storable.$fStorableChar4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HRd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HRp; else goto c4HRq;
       c4HRp: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableChar4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HRq: // global
           I64[Sp - 16] = block_c4HRa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HRw; else goto c4HRb;
       u4HRw: // global
           call _c4HRa(R1) args: 0, res: 0, upd: 0;
       c4HRb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HRa() //  [R1]
         { info_tbl: [(c4HRa,
                       label: block_c4HRa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HRa: // global
           I64[Sp] = block_c4HRg_info;
           _s4FqY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FqY::I64;
           if (R1 & 7 != 0) goto u4HRv; else goto c4HRh;
       u4HRv: // global
           call _c4HRg(R1) args: 0, res: 0, upd: 0;
       c4HRh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HRg() //  [R1]
         { info_tbl: [(c4HRg,
                       label: block_c4HRg_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HRg: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HRu; else goto c4HRt;
       c4HRu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HRt: // global
           _s4Fr4::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s4Fr4::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.07415825 UTC

[section ""data" . Foreign.Storable.$fStorableChar1_closure" {
     Foreign.Storable.$fStorableChar1_closure:
         const Foreign.Storable.$fStorableChar1_info;
 },
 Foreign.Storable.$fStorableChar1_entry() //  [R2, R3]
         { info_tbl: [(c4HRU,
                       label: Foreign.Storable.$fStorableChar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HRU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HRY; else goto c4HRZ;
       c4HRY: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableChar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HRZ: // global
           I64[Sp - 16] = block_c4HRR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HS7; else goto c4HRS;
       u4HS7: // global
           call _c4HRR(R1) args: 0, res: 0, upd: 0;
       c4HRS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HRR() //  [R1]
         { info_tbl: [(c4HRR,
                       label: block_c4HRR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HRR: // global
           I64[Sp] = block_c4HRX_info;
           _s4Fra::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fra::I64;
           if (R1 & 7 != 0) goto u4HS6; else goto c4HS1;
       u4HS6: // global
           call _c4HRX(R1) args: 0, res: 0, upd: 0;
       c4HS1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HRX() //  [R1]
         { info_tbl: [(c4HRX,
                       label: block_c4HRX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HRX: // global
           I32[I64[Sp + 8]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.086505437 UTC

[section ""data" . Foreign.Storable.$fStorableChar3_closure" {
     Foreign.Storable.$fStorableChar3_closure:
         const Foreign.Storable.$fStorableChar3_info;
 },
 Foreign.Storable.$fStorableChar3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4HSv,
                       label: Foreign.Storable.$fStorableChar3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HSv: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4HSE; else goto c4HSF;
       c4HSE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableChar3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HSF: // global
           I64[Sp - 24] = block_c4HSs_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4HSP; else goto c4HSt;
       u4HSP: // global
           call _c4HSs(R1) args: 0, res: 0, upd: 0;
       c4HSt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HSs() //  [R1]
         { info_tbl: [(c4HSs,
                       label: block_c4HSs_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HSs: // global
           I64[Sp] = block_c4HSy_info;
           _s4Frj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Frj::I64;
           if (R1 & 7 != 0) goto u4HSO; else goto c4HSz;
       u4HSO: // global
           call _c4HSy(R1) args: 0, res: 0, upd: 0;
       c4HSz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HSy() //  [R1]
         { info_tbl: [(c4HSy,
                       label: block_c4HSy_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HSy: // global
           I64[Sp] = block_c4HSD_info;
           _s4Frl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Frl::I64;
           if (R1 & 7 != 0) goto u4HSQ; else goto c4HSI;
       u4HSQ: // global
           call _c4HSD(R1) args: 0, res: 0, upd: 0;
       c4HSI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HSD() //  [R1]
         { info_tbl: [(c4HSD,
                       label: block_c4HSD_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HSD: // global
           I32[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.096138365 UTC

[section ""data" . Foreign.Storable.$fStorableChar_closure" {
     Foreign.Storable.$fStorableChar_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableChar_$calignment_closure+1;
         const Foreign.Storable.$fStorableChar_$calignment_closure+1;
         const GHC.Storable.readWideCharOffPtr1_closure+3;
         const GHC.Storable.writeWideCharOffPtr1_closure+4;
         const Foreign.Storable.$fStorableChar4_closure+3;
         const Foreign.Storable.$fStorableChar3_closure+4;
         const Foreign.Storable.$fStorableChar2_closure+2;
         const Foreign.Storable.$fStorableChar1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.09804429 UTC

[section ""data" . Foreign.Storable.$trModule3_closure" {
     Foreign.Storable.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Storable.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.099700595 UTC

[section ""data" . Foreign.Storable.$trModule1_closure" {
     Foreign.Storable.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Storable.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.101431908 UTC

[section ""data" . Foreign.Storable.$trModule_closure" {
     Foreign.Storable.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Storable.$trModule3_closure+1;
         const Foreign.Storable.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.103205648 UTC

[section ""data" . $krep_r4Ffk_closure" {
     $krep_r4Ffk_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.104958315 UTC

[section ""data" . Foreign.Storable.$tcStorable1_closure" {
     Foreign.Storable.$tcStorable1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep_r4Ffk_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.107096815 UTC

[section ""cstring" . Foreign.Storable.$tcStorable3_bytes" {
     Foreign.Storable.$tcStorable3_bytes:
         I8[] [83,116,111,114,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.108769133 UTC

[section ""data" . Foreign.Storable.$tcStorable2_closure" {
     Foreign.Storable.$tcStorable2_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Storable.$tcStorable3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.110538746 UTC

[section ""data" . Foreign.Storable.$tcStorable_closure" {
     Foreign.Storable.$tcStorable_closure:
         const GHC.Types.TyCon_con_info;
         const Foreign.Storable.$trModule_closure+1;
         const Foreign.Storable.$tcStorable2_closure+1;
         const Foreign.Storable.$tcStorable1_closure+4;
         const 9192657549155052097;
         const 13909834202100645491;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.113627543 UTC

[section ""data" . Foreign.Storable.$fStorableWord20_closure" {
     Foreign.Storable.$fStorableWord20_closure:
         const Foreign.Storable.$fStorableWord20_info;
 },
 Foreign.Storable.$fStorableWord20_entry() //  [R2]
         { info_tbl: [(c4HTs,
                       label: Foreign.Storable.$fStorableWord20_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HTs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4HTw; else goto c4HTx;
       c4HTw: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord20_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4HTx: // global
           I64[Sp - 8] = block_c4HTp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4HTB; else goto c4HTq;
       u4HTB: // global
           call _c4HTp(R1) args: 0, res: 0, upd: 0;
       c4HTq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HTp() //  [R1]
         { info_tbl: [(c4HTp,
                       label: block_c4HTp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HTp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HTA; else goto c4HTz;
       c4HTA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HTz: // global
           _s4Frw::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s4Frw::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.119732403 UTC

[section ""data" . Foreign.Storable.$fStorableWord22_closure" {
     Foreign.Storable.$fStorableWord22_closure:
         const Foreign.Storable.$fStorableWord22_info;
 },
 Foreign.Storable.$fStorableWord22_entry() //  [R2, R3]
         { info_tbl: [(c4HTU,
                       label: Foreign.Storable.$fStorableWord22_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HTU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HU6; else goto c4HU7;
       c4HU6: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord22_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HU7: // global
           I64[Sp - 16] = block_c4HTR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HUd; else goto c4HTS;
       u4HUd: // global
           call _c4HTR(R1) args: 0, res: 0, upd: 0;
       c4HTS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HTR() //  [R1]
         { info_tbl: [(c4HTR,
                       label: block_c4HTR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HTR: // global
           I64[Sp] = block_c4HTX_info;
           _s4FrC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FrC::I64;
           if (R1 & 7 != 0) goto u4HUc; else goto c4HTY;
       u4HUc: // global
           call _c4HTX(R1) args: 0, res: 0, upd: 0;
       c4HTY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HTX() //  [R1]
         { info_tbl: [(c4HTX,
                       label: block_c4HTX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HTX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4HUb; else goto c4HUa;
       c4HUb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HUa: // global
           _s4FrI::I64 = %MO_UU_Conv_W8_W64(I8[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s4FrI::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.127686019 UTC

[section ""data" . Foreign.Storable.$fStorableWord19_closure" {
     Foreign.Storable.$fStorableWord19_closure:
         const Foreign.Storable.$fStorableWord19_info;
 },
 Foreign.Storable.$fStorableWord19_entry() //  [R2, R3]
         { info_tbl: [(c4HUB,
                       label: Foreign.Storable.$fStorableWord19_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HUB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HUF; else goto c4HUG;
       c4HUF: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord19_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HUG: // global
           I64[Sp - 16] = block_c4HUy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HUO; else goto c4HUz;
       u4HUO: // global
           call _c4HUy(R1) args: 0, res: 0, upd: 0;
       c4HUz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HUy() //  [R1]
         { info_tbl: [(c4HUy,
                       label: block_c4HUy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HUy: // global
           I64[Sp] = block_c4HUE_info;
           _s4FrO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FrO::I64;
           if (R1 & 7 != 0) goto u4HUN; else goto c4HUI;
       u4HUN: // global
           call _c4HUE(R1) args: 0, res: 0, upd: 0;
       c4HUI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HUE() //  [R1]
         { info_tbl: [(c4HUE,
                       label: block_c4HUE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HUE: // global
           I8[I64[Sp + 8]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.136123436 UTC

[section ""data" . Foreign.Storable.$fStorableWord21_closure" {
     Foreign.Storable.$fStorableWord21_closure:
         const Foreign.Storable.$fStorableWord21_info;
 },
 Foreign.Storable.$fStorableWord21_entry() //  [R2, R3, R4]
         { info_tbl: [(c4HVc,
                       label: Foreign.Storable.$fStorableWord21_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HVc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4HVl; else goto c4HVm;
       c4HVl: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord21_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HVm: // global
           I64[Sp - 24] = block_c4HV9_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4HVw; else goto c4HVa;
       u4HVw: // global
           call _c4HV9(R1) args: 0, res: 0, upd: 0;
       c4HVa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HV9() //  [R1]
         { info_tbl: [(c4HV9,
                       label: block_c4HV9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HV9: // global
           I64[Sp] = block_c4HVf_info;
           _s4FrX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FrX::I64;
           if (R1 & 7 != 0) goto u4HVv; else goto c4HVg;
       u4HVv: // global
           call _c4HVf(R1) args: 0, res: 0, upd: 0;
       c4HVg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HVf() //  [R1]
         { info_tbl: [(c4HVf,
                       label: block_c4HVf_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HVf: // global
           I64[Sp] = block_c4HVk_info;
           _s4FrZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FrZ::I64;
           if (R1 & 7 != 0) goto u4HVx; else goto c4HVp;
       u4HVx: // global
           call _c4HVk(R1) args: 0, res: 0, upd: 0;
       c4HVp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HVk() //  [R1]
         { info_tbl: [(c4HVk,
                       label: block_c4HVk_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HVk: // global
           I8[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.145696941 UTC

[section ""data" . Foreign.Storable.$fStorableWord8_closure" {
     Foreign.Storable.$fStorableWord8_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableWord8_$calignment_closure+1;
         const Foreign.Storable.$fStorableWord8_$calignment_closure+1;
         const GHC.Storable.readWord8OffPtr1_closure+3;
         const GHC.Storable.writeWord8OffPtr1_closure+4;
         const Foreign.Storable.$fStorableWord22_closure+3;
         const Foreign.Storable.$fStorableWord21_closure+4;
         const Foreign.Storable.$fStorableWord20_closure+2;
         const Foreign.Storable.$fStorableWord19_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.14836788 UTC

[section ""data" . Foreign.Storable.$fStorableRatio2_closure" {
     Foreign.Storable.$fStorableRatio2_closure:
         const Foreign.Storable.$fStorableRatio2_info;
         const 0;
 },
 sat_s4Fse_entry() //  [R1]
         { info_tbl: [(c4HW6,
                       label: sat_s4Fse_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HW6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HW7; else goto c4HW8;
       c4HW7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4HW8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.%_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableRatio2_entry() //  [R2, R3, R4]
         { info_tbl: [(c4HW9,
                       label: Foreign.Storable.$fStorableRatio2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HW9: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c4HWa; else goto c4HWb;
       c4HWa: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HWb: // global
           I64[Sp - 32] = block_c4HVY_info;
           _s4Fs4::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_pv_info;
           P64[Sp - 40] = R4;
           P64[Sp - 24] = _s4Fs4::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 48;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c4HVY() //  [R1]
         { info_tbl: [(c4HVY,
                       label: block_c4HVY_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HVY: // global
           _s4Fs4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4HW0_info;
           R2 = _s4Fs4::P64;
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp] = Foreign.Storable.$fStorable()7_closure+1;
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c4HW0() //  [R1]
         { info_tbl: [(c4HW0,
                       label: block_c4HW0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HW0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4HWf; else goto c4HWe;
       c4HWf: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HWe: // global
           I64[Hp - 32] = sat_s4Fse_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.159759699 UTC

[section ""data" . Foreign.Storable.$fStorableRatio1_closure" {
     Foreign.Storable.$fStorableRatio1_closure:
         const Foreign.Storable.$fStorableRatio1_info;
 },
 Foreign.Storable.$fStorableRatio1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c4HWG,
                       label: Foreign.Storable.$fStorableRatio1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HWG: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c4HWK; else goto c4HWL;
       c4HWK: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HWL: // global
           I64[Sp - 24] = block_c4HWD_info;
           R1 = R5;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4HWP; else goto c4HWE;
       u4HWP: // global
           call _c4HWD(R1) args: 0, res: 0, upd: 0;
       c4HWE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HWD() //  [R1]
         { info_tbl: [(c4HWD,
                       label: block_c4HWD_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HWD: // global
           I64[Sp - 8] = block_c4HWJ_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_ppv_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 32;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c4HWJ() //  []
         { info_tbl: [(c4HWJ,
                       label: block_c4HWJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HWJ: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppv_info;
           _s4Fsm::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 16] = Foreign.Storable.$fStorable()7_closure+1;
           P64[Sp + 24] = _s4Fsm::P64;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.168386138 UTC

[section ""data" . Foreign.Storable.$fStorableBool6_closure" {
     Foreign.Storable.$fStorableBool6_closure:
         const Foreign.Storable.$fStorableBool6_info;
 },
 sat_s4FsB_entry() //  [R1]
         { info_tbl: [(c4HXs,
                       label: sat_s4FsB_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HXs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HXt; else goto c4HXu;
       c4HXt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4HXu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c4HXr; else goto c4HXq;
       c4HXr: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4HXq: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableBool6_entry() //  [R2, R3]
         { info_tbl: [(c4HXv,
                       label: Foreign.Storable.$fStorableBool6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HXv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HXw; else goto c4HXx;
       c4HXw: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HXx: // global
           I64[Sp - 16] = block_c4HXa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HXD; else goto c4HXb;
       u4HXD: // global
           call _c4HXa(R1) args: 0, res: 0, upd: 0;
       c4HXb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HXa() //  [R1]
         { info_tbl: [(c4HXa,
                       label: block_c4HXa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HXa: // global
           I64[Sp] = block_c4HXf_info;
           _s4Fsu::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fsu::I64;
           if (R1 & 7 != 0) goto u4HXC; else goto c4HXg;
       u4HXC: // global
           call _c4HXf(R1) args: 0, res: 0, upd: 0;
       c4HXg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HXf() //  [R1]
         { info_tbl: [(c4HXf,
                       label: block_c4HXf_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HXf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4HXB; else goto c4HXA;
       c4HXB: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HXA: // global
           _s4Fsz::I64 = %MO_SS_Conv_W32_W64(I32[I64[Sp + 8] + (I64[R1 + 7] << 2)]);
           I64[Hp - 16] = sat_s4FsB_info;
           I64[Hp] = _s4Fsz::I64;
           R1 = Hp - 16;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.179283049 UTC

[section ""data" . Foreign.Storable.$fStorableBool2_closure" {
     Foreign.Storable.$fStorableBool2_closure:
         const Foreign.Storable.$fStorableBool2_info;
 },
 sat_s4FsK_entry() //  [R1]
         { info_tbl: [(c4HYh,
                       label: sat_s4FsK_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HYh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HYi; else goto c4HYj;
       c4HYi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4HYj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c4HYg; else goto c4HYf;
       c4HYg: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4HYf: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableBool2_entry() //  [R2]
         { info_tbl: [(c4HYk,
                       label: Foreign.Storable.$fStorableBool2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HYk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4HYl; else goto c4HYm;
       c4HYl: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4HYm: // global
           I64[Sp - 8] = block_c4HY4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4HYq; else goto c4HY5;
       u4HYq: // global
           call _c4HY4(R1) args: 0, res: 0, upd: 0;
       c4HY5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HY4() //  [R1]
         { info_tbl: [(c4HY4,
                       label: block_c4HY4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HY4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4HYp; else goto c4HYo;
       c4HYp: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HYo: // global
           _s4FsI::I64 = %MO_SS_Conv_W32_W64(I32[I64[R1 + 7]]);
           I64[Hp - 16] = sat_s4FsK_info;
           I64[Hp] = _s4FsI::I64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.188446141 UTC

[section ""data" . Foreign.Storable.$fStorableBool4_closure" {
     Foreign.Storable.$fStorableBool4_closure:
         const Foreign.Storable.$fStorableBool4_info;
 },
 sat_s4FsX_entry() //  [R1]
         { info_tbl: [(c4HZ7,
                       label: sat_s4FsX_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HZ7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HZ8; else goto c4HZ9;
       c4HZ8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4HZ9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c4HZ6; else goto c4HZ5;
       c4HZ6: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4HZ5: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableBool4_entry() //  [R2, R3]
         { info_tbl: [(c4HZa,
                       label: Foreign.Storable.$fStorableBool4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HZa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HZb; else goto c4HZc;
       c4HZb: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HZc: // global
           I64[Sp - 16] = block_c4HYM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4HZi; else goto c4HYN;
       u4HZi: // global
           call _c4HYM(R1) args: 0, res: 0, upd: 0;
       c4HYN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HYM() //  [R1]
         { info_tbl: [(c4HYM,
                       label: block_c4HYM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HYM: // global
           I64[Sp] = block_c4HYR_info;
           _s4FsP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FsP::I64;
           if (R1 & 7 != 0) goto u4HZh; else goto c4HYS;
       u4HZh: // global
           call _c4HYR(R1) args: 0, res: 0, upd: 0;
       c4HYS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HYR() //  [R1]
         { info_tbl: [(c4HYR,
                       label: block_c4HYR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HYR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4HZg; else goto c4HZf;
       c4HZg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4HZf: // global
           _s4FsV::I64 = %MO_SS_Conv_W32_W64(I32[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 16] = sat_s4FsX_info;
           I64[Hp] = _s4FsV::I64;
           R1 = Hp - 16;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.199874991 UTC

[section ""data" . Foreign.Storable.$fStorableBool1_closure" {
     Foreign.Storable.$fStorableBool1_closure:
         const Foreign.Storable.$fStorableBool1_info;
 },
 Foreign.Storable.$fStorableBool1_entry() //  [R2, R3]
         { info_tbl: [(c4HZM,
                       label: Foreign.Storable.$fStorableBool1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HZM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4HZN; else goto c4HZO;
       c4HZN: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4HZO: // global
           I64[Sp - 16] = block_c4HZJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4I06; else goto c4HZK;
       u4I06: // global
           call _c4HZJ(R1) args: 0, res: 0, upd: 0;
       c4HZK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HZJ() //  [R1]
         { info_tbl: [(c4HZJ,
                       label: block_c4HZJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HZJ: // global
           I64[Sp] = block_c4HZR_info;
           _s4Ft2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Ft2::I64;
           if (R1 & 7 != 0) goto u4I05; else goto c4HZT;
       u4I05: // global
           call _c4HZR(R1) args: 0, res: 0, upd: 0;
       c4HZT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4HZR() //  [R1]
         { info_tbl: [(c4HZR,
                       label: block_c4HZR_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4HZR: // global
           _s4Ft2::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c4HZZ; else goto c4I03;
       c4HZZ: // global
           I32[_s4Ft2::I64] = 0 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4I03: // global
           I32[_s4Ft2::I64] = 1 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.208339843 UTC

[section ""data" . Foreign.Storable.$fStorableBool3_closure" {
     Foreign.Storable.$fStorableBool3_closure:
         const Foreign.Storable.$fStorableBool3_info;
 },
 Foreign.Storable.$fStorableBool3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4I0v,
                       label: Foreign.Storable.$fStorableBool3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I0v: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4I0z; else goto c4I0A;
       c4I0z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4I0A: // global
           I64[Sp - 24] = block_c4I0s_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4I0X; else goto c4I0t;
       u4I0X: // global
           call _c4I0s(R1) args: 0, res: 0, upd: 0;
       c4I0t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4I0s() //  [R1]
         { info_tbl: [(c4I0s,
                       label: block_c4I0s_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I0s: // global
           I64[Sp] = block_c4I0y_info;
           _s4Ftb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Ftb::I64;
           if (R1 & 7 != 0) goto u4I0W; else goto c4I0C;
       u4I0W: // global
           call _c4I0y(R1) args: 0, res: 0, upd: 0;
       c4I0C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4I0y() //  [R1]
         { info_tbl: [(c4I0y,
                       label: block_c4I0y_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I0y: // global
           I64[Sp] = block_c4I0G_info;
           _s4Ftd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Ftd::I64;
           if (R1 & 7 != 0) goto u4I0Y; else goto c4I0I;
       u4I0Y: // global
           call _c4I0G(R1) args: 0, res: 0, upd: 0;
       c4I0I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4I0G() //  [R1]
         { info_tbl: [(c4I0G,
                       label: block_c4I0G_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I0G: // global
           _s4Ftb::I64 = I64[Sp + 8];
           _s4Ftd::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto c4I0O; else goto c4I0S;
       c4I0O: // global
           I32[_s4Ftb::I64 + _s4Ftd::I64] = 0 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4I0S: // global
           I32[_s4Ftb::I64 + _s4Ftd::I64] = 1 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.218532763 UTC

[section ""data" . Foreign.Storable.$fStorableBool_closure" {
     Foreign.Storable.$fStorableBool_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableBool_$csizeOf_closure+1;
         const Foreign.Storable.$fStorableBool_$csizeOf_closure+1;
         const Foreign.Storable.$fStorableBool6_closure+3;
         const Foreign.Storable.$fStorableBool5_closure+4;
         const Foreign.Storable.$fStorableBool4_closure+3;
         const Foreign.Storable.$fStorableBool3_closure+4;
         const Foreign.Storable.$fStorableBool2_closure+2;
         const Foreign.Storable.$fStorableBool1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.220802467 UTC

[section ""data" . Foreign.Storable.$fStorable()2_closure" {
     Foreign.Storable.$fStorable()2_closure:
         const Foreign.Storable.$fStorable()2_info;
 },
 Foreign.Storable.$fStorable()2_entry() //  []
         { info_tbl: [(c4I1p,
                       label: Foreign.Storable.$fStorable()2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I1p: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.224399886 UTC

[section ""data" . Foreign.Storable.$fStorable()1_closure" {
     Foreign.Storable.$fStorable()1_closure:
         const Foreign.Storable.$fStorable()1_info;
 },
 Foreign.Storable.$fStorable()1_entry() //  []
         { info_tbl: [(c4I1B,
                       label: Foreign.Storable.$fStorable()1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I1B: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.228660768 UTC

[section ""data" . lvl11_r4Ffl_closure" {
     lvl11_r4Ffl_closure:
         const GHC.Types.I#_con_info;
         const 137;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.230432958 UTC

[section ""data" . lvl12_r4Ffm_closure" {
     lvl12_r4Ffm_closure:
         const GHC.Types.I#_con_info;
         const 31;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.232135194 UTC

[section ""data" . lvl13_r4Ffn_closure" {
     lvl13_r4Ffn_closure:
         const GHC.Types.I#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.234513123 UTC

[section ""data" . lvl14_r4Ffo_closure" {
     lvl14_r4Ffo_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r4Ffb_closure;
         const lvl3_r4Ffc_closure;
         const lvl5_r4Ffe_closure;
         const lvl11_r4Ffl_closure+1;
         const lvl12_r4Ffm_closure+1;
         const lvl11_r4Ffl_closure+1;
         const lvl13_r4Ffn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.236311906 UTC

[section ""data" . lvl15_r4Ffp_closure" {
     lvl15_r4Ffp_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r4Ffa_closure;
         const lvl14_r4Ffo_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.238498649 UTC

[section ""data" . lvl16_r4Ffq_closure" {
     lvl16_r4Ffq_closure:
         const lvl16_r4Ffq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_r4Ffq_entry() //  [R1]
         { info_tbl: [(c4I1U,
                       label: lvl16_r4Ffq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I1U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4I1V; else goto c4I1W;
       c4I1V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4I1W: // global
           (_c4I1R::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4I1R::I64 == 0) goto c4I1T; else goto c4I1S;
       c4I1T: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4I1S: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4I1R::I64;
           R2 = lvl15_r4Ffp_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.243834061 UTC

[section ""data" . Foreign.Storable.$dmpeekElemOff_closure" {
     Foreign.Storable.$dmpeekElemOff_closure:
         const Foreign.Storable.$dmpeekElemOff_info;
         const 0;
 },
 sat_s4Ftw_entry() //  [R1]
         { info_tbl: [(c4I2f,
                       label: sat_s4Ftw_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I2f: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c4I2q; else goto c4I2r;
       c4I2q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4I2r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4I2c_info;
           _s4Fto::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s4Fto::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4I2w; else goto c4I2d;
       u4I2w: // global
           call _c4I2c(R1) args: 0, res: 0, upd: 0;
       c4I2d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4I2c() //  [R1]
         { info_tbl: [(c4I2c,
                       label: block_c4I2c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I2c: // global
           I64[Sp] = block_c4I2i_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = lvl16_r4Ffq_closure;
           I64[Sp + 8] = I64[R1 + 7];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c4I2i() //  [R1]
         { info_tbl: [(c4I2i,
                       label: block_c4I2i_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I2i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4I2v; else goto c4I2u;
       c4I2v: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4I2u: // global
           _s4Ftv::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4Ftv::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$dmpeekElemOff_entry() //  [R2, R3, R4]
         { info_tbl: [(c4I2x,
                       label: Foreign.Storable.$dmpeekElemOff_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I2x: // global
           _s4Ftq::P64 = R4;
           _s4Ftp::P64 = R3;
           _s4Fto::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c4I2y; else goto c4I2z;
       c4I2z: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4I2B; else goto c4I2A;
       c4I2B: // global
           HpAlloc = 32;
           goto c4I2y;
       c4I2y: // global
           R4 = _s4Ftq::P64;
           R3 = _s4Ftp::P64;
           R2 = _s4Fto::P64;
           R1 = Foreign.Storable.$dmpeekElemOff_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4I2A: // global
           I64[Hp - 24] = sat_s4Ftw_info;
           P64[Hp - 8] = _s4Fto::P64;
           P64[Hp] = _s4Ftq::P64;
           R2 = _s4Fto::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s4Ftp::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Foreign.Storable.peekByteOff_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.255586342 UTC

[section ""data" . Foreign.Storable.$dmpokeElemOff_closure" {
     Foreign.Storable.$dmpokeElemOff_closure:
         const Foreign.Storable.$dmpokeElemOff_info;
 },
 sat_s4FtG_entry() //  [R1]
         { info_tbl: [(c4I38,
                       label: sat_s4FtG_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I38: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c4I3j; else goto c4I3k;
       c4I3j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4I3k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4I35_info;
           _s4Ftx::P64 = P64[R1 + 16];
           _s4FtA::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _s4Ftx::P64;
           P64[Sp - 24] = _s4FtA::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u4I3p; else goto c4I36;
       u4I3p: // global
           call _c4I35(R1) args: 0, res: 0, upd: 0;
       c4I36: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4I35() //  [R1]
         { info_tbl: [(c4I35,
                       label: block_c4I35_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I35: // global
           _s4Ftx::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4I3b_info;
           R2 = _s4Ftx::P64;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = P64[Sp + 16];
           I64[Sp + 16] = I64[R1 + 7];
           Sp = Sp - 8;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c4I3b() //  [R1]
         { info_tbl: [(c4I3b,
                       label: block_c4I3b_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I3b: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4I3o; else goto c4I3n;
       c4I3o: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4I3n: // global
           _s4FtF::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4FtF::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$dmpokeElemOff_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c4I3q,
                       label: Foreign.Storable.$dmpokeElemOff_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I3q: // global
           _s4FtA::P64 = R5;
           _s4Ftz::P64 = R4;
           _s4Fty::P64 = R3;
           _s4Ftx::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto c4I3r; else goto c4I3s;
       c4I3s: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4I3u; else goto c4I3t;
       c4I3u: // global
           HpAlloc = 40;
           goto c4I3r;
       c4I3r: // global
           R5 = _s4FtA::P64;
           R4 = _s4Ftz::P64;
           R3 = _s4Fty::P64;
           R2 = _s4Ftx::P64;
           R1 = Foreign.Storable.$dmpokeElemOff_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4I3t: // global
           I64[Hp - 32] = sat_s4FtG_info;
           P64[Hp - 16] = _s4Ftx::P64;
           P64[Hp - 8] = _s4Ftz::P64;
           P64[Hp] = _s4FtA::P64;
           R2 = _s4Ftx::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _s4Fty::P64;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _s4FtA::P64;
           Sp = Sp - 32;
           call Foreign.Storable.pokeByteOff_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.267720993 UTC

[section ""data" . Foreign.Storable.$fStorable()4_closure" {
     Foreign.Storable.$fStorable()4_closure:
         const Foreign.Storable.$fStorable()4_info;
 },
 Foreign.Storable.$fStorable()4_entry() //  []
         { info_tbl: [(c4I3V,
                       label: Foreign.Storable.$fStorable()4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I3V: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.271581432 UTC

[section ""data" . Foreign.Storable.$fStorable()6_closure" {
     Foreign.Storable.$fStorable()6_closure:
         const Foreign.Storable.$fStorable()6_info;
 },
 Foreign.Storable.$fStorable()6_entry() //  []
         { info_tbl: [(c4I47,
                       label: Foreign.Storable.$fStorable()6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I47: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.275286703 UTC

[section ""data" . Foreign.Storable.$fStorable()3_closure" {
     Foreign.Storable.$fStorable()3_closure:
         const Foreign.Storable.$fStorable()3_info;
 },
 Foreign.Storable.$fStorable()3_entry() //  []
         { info_tbl: [(c4I4j,
                       label: Foreign.Storable.$fStorable()3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I4j: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.278883403 UTC

[section ""data" . Foreign.Storable.$fStorable()5_closure" {
     Foreign.Storable.$fStorable()5_closure:
         const Foreign.Storable.$fStorable()5_info;
 },
 Foreign.Storable.$fStorable()5_entry() //  []
         { info_tbl: [(c4I4v,
                       label: Foreign.Storable.$fStorable()5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I4v: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.282718384 UTC

[section ""data" . Foreign.Storable.$fStorable()_closure" {
     Foreign.Storable.$fStorable()_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorable()_$csizeOf_closure+1;
         const Foreign.Storable.$fStorable()_$calignment_closure+1;
         const Foreign.Storable.$fStorable()6_closure+3;
         const Foreign.Storable.$fStorable()5_closure+4;
         const Foreign.Storable.$fStorable()4_closure+3;
         const Foreign.Storable.$fStorable()3_closure+4;
         const Foreign.Storable.$fStorable()2_closure+2;
         const Foreign.Storable.$fStorable()1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.284619062 UTC

[section ""data" . lvl17_r4Ffr_closure" {
     lvl17_r4Ffr_closure:
         const GHC.Types.I#_con_info;
         const 237;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.286437142 UTC

[section ""data" . lvl18_r4Ffs_closure" {
     lvl18_r4Ffs_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r4Ffb_closure;
         const lvl3_r4Ffc_closure;
         const lvl5_r4Ffe_closure;
         const lvl17_r4Ffr_closure+1;
         const lvl12_r4Ffm_closure+1;
         const lvl17_r4Ffr_closure+1;
         const lvl13_r4Ffn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.288350795 UTC

[section ""data" . lvl19_r4Fft_closure" {
     lvl19_r4Fft_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r4Ffa_closure;
         const lvl18_r4Ffs_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.29055246 UTC

[section ""data" . Foreign.Storable.$fStorableRatio6_closure" {
     Foreign.Storable.$fStorableRatio6_closure:
         const Foreign.Storable.$fStorableRatio6_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Storable.$fStorableRatio6_entry() //  [R1]
         { info_tbl: [(c4I4N,
                       label: Foreign.Storable.$fStorableRatio6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I4N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4I4O; else goto c4I4P;
       c4I4O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4I4P: // global
           (_c4I4K::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4I4K::I64 == 0) goto c4I4M; else goto c4I4L;
       c4I4M: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4I4L: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4I4K::I64;
           R2 = lvl19_r4Fft_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.295545867 UTC

[section ""data" . Foreign.Storable.$fStorableRatio_$csizeOf_closure" {
     Foreign.Storable.$fStorableRatio_$csizeOf_closure:
         const Foreign.Storable.$fStorableRatio_$csizeOf_info;
         const 0;
 },
 lvl20_s4FtX_entry() //  [R1]
         { info_tbl: [(c4I55,
                       label: lvl20_s4FtX_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I55: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4I56; else goto c4I57;
       c4I56: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4I57: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Storable.$fStorableRatio6_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s4Fu2_entry() //  [R1, R2]
         { info_tbl: [(c4I5g,
                       label: sat_s4Fu2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I5g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4I5n; else goto c4I5o;
       c4I5n: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4I5o: // global
           I64[Sp - 8] = block_c4I5d_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4I5s; else goto c4I5e;
       u4I5s: // global
           call _c4I5d(R1) args: 0, res: 0, upd: 0;
       c4I5e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4I5d() //  [R1]
         { info_tbl: [(c4I5d,
                       label: block_c4I5d_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I5d: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4I5r; else goto c4I5q;
       c4I5r: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4I5q: // global
           _s4Fu1::I64 = I64[R1 + 7] << 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4Fu1::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Storable.$fStorableRatio_$csizeOf_entry() //  [R2, R3]
         { info_tbl: [(c4I5t,
                       label: Foreign.Storable.$fStorableRatio_$csizeOf_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I5t: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4I5x; else goto c4I5w;
       c4I5x: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio_$csizeOf_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4I5w: // global
           I64[Hp - 32] = lvl20_s4FtX_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s4Fu2_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.307648888 UTC

[section ""data" . Foreign.Storable.$fStorableRatio4_closure" {
     Foreign.Storable.$fStorableRatio4_closure:
         const Foreign.Storable.$fStorableRatio4_info;
         const 0;
 },
 sat_s4Fud_entry() //  [R1]
         { info_tbl: [(c4I62,
                       label: sat_s4Fud_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I62: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4I6e; else goto c4I6f;
       c4I6e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4I6f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4I5Z_info;
           _s4Fu6::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4Fu6::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4I6l; else goto c4I60;
       u4I6l: // global
           call _c4I5Z(R1) args: 0, res: 0, upd: 0;
       c4I60: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4I5Z() //  [R1]
         { info_tbl: [(c4I5Z,
                       label: block_c4I5Z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I5Z: // global
           I64[Sp] = block_c4I65_info;
           _s4Fu9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fu9::I64;
           if (R1 & 7 != 0) goto u4I6k; else goto c4I66;
       u4I6k: // global
           call _c4I65(R1) args: 0, res: 0, upd: 0;
       c4I66: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4I65() //  [R1]
         { info_tbl: [(c4I65,
                       label: block_c4I65_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I65: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4I6j; else goto c4I6i;
       c4I6j: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4I6i: // global
           _s4Fuc::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fuc::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableRatio4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c4I6m,
                       label: Foreign.Storable.$fStorableRatio4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I6m: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4I6q; else goto c4I6p;
       c4I6q: // global
           HpAlloc = 32;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4I6p: // global
           I64[Hp - 24] = sat_s4Fud_info;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R4 = Hp - 24;
           R3 = R3;
           R2 = R2;
           call Foreign.Storable.$fStorableRatio2_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.31867801 UTC

[section ""data" . Foreign.Storable.$fStorableRatio7_closure" {
     Foreign.Storable.$fStorableRatio7_closure:
         const Foreign.Storable.$fStorableRatio7_info;
         const 0;
 },
 sat_s4Fus_entry() //  [R1]
         { info_tbl: [(c4I6V,
                       label: sat_s4Fus_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I6V: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c4I7h; else goto c4I7i;
       c4I7h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4I7i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4I6S_info;
           _s4Fue::P64 = P64[R1 + 16];
           _s4Fuh::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _s4Fue::P64;
           P64[Sp - 24] = _s4Fuh::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u4I7p; else goto c4I6T;
       u4I7p: // global
           call _c4I6S(R1) args: 0, res: 0, upd: 0;
       c4I6T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4I6S() //  [R1]
         { info_tbl: [(c4I6S,
                       label: block_c4I6S_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I6S: // global
           I64[Sp] = block_c4I6Y_info;
           _s4Fuk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fuk::I64;
           if (R1 & 7 != 0) goto u4I7o; else goto c4I6Z;
       u4I7o: // global
           call _c4I6Y(R1) args: 0, res: 0, upd: 0;
       c4I6Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4I6Y() //  [R1]
         { info_tbl: [(c4I6Y,
                       label: block_c4I6Y_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I6Y: // global
           I64[Sp] = block_c4I73_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Foreign.Storable.$fStorableRatio6_closure;
           I64[Sp + 8] = I64[R1 + 7];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c4I73() //  [R1]
         { info_tbl: [(c4I73,
                       label: block_c4I73_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I73: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4I7n; else goto c4I7m;
       c4I7n: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4I7m: // global
           _s4Fur::I64 = I64[Sp + 16] + I64[Sp + 8] * (I64[R1 + 7] << 1);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fur::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableRatio7_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c4I7q,
                       label: Foreign.Storable.$fStorableRatio7_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I7q: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4I7u; else goto c4I7t;
       c4I7u: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio7_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4I7t: // global
           I64[Hp - 32] = sat_s4Fus_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R4 = Hp - 32;
           R3 = R3;
           R2 = R2;
           call Foreign.Storable.$fStorableRatio2_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.332418133 UTC

[section ""data" . Foreign.Storable.$w$cpokeByteOff_closure" {
     Foreign.Storable.$w$cpokeByteOff_closure:
         const Foreign.Storable.$w$cpokeByteOff_info;
 },
 p_s4Fuz_entry() //  [R1]
         { info_tbl: [(c4I85,
                       label: p_s4Fuz_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I85: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4I8h; else goto c4I8i;
       c4I8h: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4I8i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4I82_info;
           _s4Fuv::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4Fuv::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4I8o; else goto c4I83;
       u4I8o: // global
           call _c4I82(R1) args: 0, res: 0, upd: 0;
       c4I83: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4I82() //  [R1]
         { info_tbl: [(c4I82,
                       label: block_c4I82_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I82: // global
           I64[Sp] = block_c4I88_info;
           _s4FuB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FuB::I64;
           if (R1 & 7 != 0) goto u4I8n; else goto c4I89;
       u4I8n: // global
           call _c4I88(R1) args: 0, res: 0, upd: 0;
       c4I89: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4I88() //  [R1]
         { info_tbl: [(c4I88,
                       label: block_c4I88_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I88: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4I8m; else goto c4I8l;
       c4I8m: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4I8l: // global
           _s4FuE::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4FuE::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$w$cpokeByteOff_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c4I8r,
                       label: Foreign.Storable.$w$cpokeByteOff_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I8r: // global
           _s4Fux::P64 = R6;
           _s4Fuw::P64 = R5;
           _s4Fuv::P64 = R4;
           _s4Fuu::P64 = R3;
           _s4Fut::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto c4I8s; else goto c4I8t;
       c4I8t: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4I8v; else goto c4I8u;
       c4I8v: // global
           HpAlloc = 32;
           goto c4I8s;
       c4I8s: // global
           R6 = _s4Fux::P64;
           R5 = _s4Fuw::P64;
           R4 = _s4Fuv::P64;
           R3 = _s4Fuu::P64;
           R2 = _s4Fut::P64;
           R1 = Foreign.Storable.$w$cpokeByteOff_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4I8u: // global
           I64[Hp - 24] = p_s4Fuz_info;
           P64[Hp - 8] = _s4Fuu::P64;
           P64[Hp] = _s4Fuv::P64;
           I64[Sp - 32] = block_c4I8p_info;
           R2 = _s4Fut::P64;
           I64[Sp - 56] = stg_ap_ppv_info;
           _c4I7Y::P64 = Hp - 24;
           P64[Sp - 48] = _c4I7Y::P64;
           P64[Sp - 40] = _s4Fuw::P64;
           P64[Sp - 24] = _c4I7Y::P64;
           P64[Sp - 16] = _s4Fut::P64;
           P64[Sp - 8] = _s4Fux::P64;
           Sp = Sp - 56;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c4I8p() //  []
         { info_tbl: [(c4I8p,
                       label: block_c4I8p_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I8p: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppv_info;
           P64[Sp + 16] = Foreign.Storable.$fStorable()7_closure+1;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.347264669 UTC

[section ""data" . Foreign.Storable.$fStorableRatio3_closure" {
     Foreign.Storable.$fStorableRatio3_closure:
         const Foreign.Storable.$fStorableRatio3_info;
 },
 Foreign.Storable.$fStorableRatio3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c4I91,
                       label: Foreign.Storable.$fStorableRatio3_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I91: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4I92; else goto c4I93;
       c4I92: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4I93: // global
           I64[Sp - 32] = block_c4I8Y_info;
           R1 = R6;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4I97; else goto c4I8Z;
       u4I97: // global
           call _c4I8Y(R1) args: 0, res: 0, upd: 0;
       c4I8Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4I8Y() //  [R1]
         { info_tbl: [(c4I8Y,
                       label: block_c4I8Y_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I8Y: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Foreign.Storable.$w$cpokeByteOff_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.354273387 UTC

[section ""data" . Foreign.Storable.$w$cpokeElemOff_closure" {
     Foreign.Storable.$w$cpokeElemOff_closure:
         const Foreign.Storable.$w$cpokeElemOff_info;
         const 0;
 },
 p_s4FuX_entry() //  [R1]
         { info_tbl: [(c4I9s,
                       label: p_s4FuX_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I9s: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c4I9O; else goto c4I9P;
       c4I9O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4I9P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4I9p_info;
           _s4FuR::P64 = P64[R1 + 16];
           _s4FuT::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _s4FuR::P64;
           P64[Sp - 24] = _s4FuT::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u4I9W; else goto c4I9q;
       u4I9W: // global
           call _c4I9p(R1) args: 0, res: 0, upd: 0;
       c4I9q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4I9p() //  [R1]
         { info_tbl: [(c4I9p,
                       label: block_c4I9p_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I9p: // global
           I64[Sp] = block_c4I9v_info;
           _s4FuZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4FuZ::I64;
           if (R1 & 7 != 0) goto u4I9V; else goto c4I9w;
       u4I9V: // global
           call _c4I9v(R1) args: 0, res: 0, upd: 0;
       c4I9w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4I9v() //  [R1]
         { info_tbl: [(c4I9v,
                       label: block_c4I9v_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I9v: // global
           I64[Sp] = block_c4I9A_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Foreign.Storable.$fStorableRatio6_closure;
           I64[Sp + 8] = I64[R1 + 7];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c4I9A() //  [R1]
         { info_tbl: [(c4I9A,
                       label: block_c4I9A_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I9A: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4I9U; else goto c4I9T;
       c4I9U: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4I9T: // global
           _s4Fv6::I64 = I64[Sp + 16] + I64[Sp + 8] * (I64[R1 + 7] << 1);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fv6::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$w$cpokeElemOff_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c4I9Z,
                       label: Foreign.Storable.$w$cpokeElemOff_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I9Z: // global
           _s4FuV::P64 = R6;
           _s4FuU::P64 = R5;
           _s4FuT::P64 = R4;
           _s4FuS::P64 = R3;
           _s4FuR::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto c4Ia0; else goto c4Ia1;
       c4Ia1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4Ia3; else goto c4Ia2;
       c4Ia3: // global
           HpAlloc = 40;
           goto c4Ia0;
       c4Ia0: // global
           R6 = _s4FuV::P64;
           R5 = _s4FuU::P64;
           R4 = _s4FuT::P64;
           R3 = _s4FuS::P64;
           R2 = _s4FuR::P64;
           R1 = Foreign.Storable.$w$cpokeElemOff_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Ia2: // global
           I64[Hp - 32] = p_s4FuX_info;
           P64[Hp - 16] = _s4FuR::P64;
           P64[Hp - 8] = _s4FuS::P64;
           P64[Hp] = _s4FuT::P64;
           I64[Sp - 32] = block_c4I9X_info;
           R2 = _s4FuR::P64;
           I64[Sp - 56] = stg_ap_ppv_info;
           _c4I9l::P64 = Hp - 32;
           P64[Sp - 48] = _c4I9l::P64;
           P64[Sp - 40] = _s4FuU::P64;
           P64[Sp - 24] = _c4I9l::P64;
           P64[Sp - 16] = _s4FuR::P64;
           P64[Sp - 8] = _s4FuV::P64;
           Sp = Sp - 56;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c4I9X() //  []
         { info_tbl: [(c4I9X,
                       label: block_c4I9X_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4I9X: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppv_info;
           P64[Sp + 16] = Foreign.Storable.$fStorable()7_closure+1;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.368872738 UTC

[section ""data" . Foreign.Storable.$fStorableRatio5_closure" {
     Foreign.Storable.$fStorableRatio5_closure:
         const Foreign.Storable.$fStorableRatio5_info;
         const 0;
 },
 Foreign.Storable.$fStorableRatio5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c4IaF,
                       label: Foreign.Storable.$fStorableRatio5_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IaF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4IaG; else goto c4IaH;
       c4IaG: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4IaH: // global
           I64[Sp - 32] = block_c4IaC_info;
           R1 = R6;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4IaL; else goto c4IaD;
       u4IaL: // global
           call _c4IaC(R1) args: 0, res: 0, upd: 0;
       c4IaD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IaC() //  [R1]
         { info_tbl: [(c4IaC,
                       label: block_c4IaC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IaC: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Foreign.Storable.$w$cpokeElemOff_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.376508782 UTC

[section ""data" . Foreign.Storable.$fStorableRatio_closure" {
     Foreign.Storable.$fStorableRatio_closure:
         const Foreign.Storable.$fStorableRatio_info;
         const 0;
 },
 sat_s4Fvs_entry() //  [R1, R2, R3]
         { info_tbl: [(c4Ib4,
                       label: sat_s4Fvs_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ib4: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Foreign.Storable.$fStorableRatio1_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fvr_entry() //  [R1, R2]
         { info_tbl: [(c4Ibc,
                       label: sat_s4Fvr_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ibc: // global
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Foreign.Storable.$fStorableRatio2_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fvq_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c4Ibk,
                       label: sat_s4Fvq_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ibk: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           call Foreign.Storable.$fStorableRatio3_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fvp_entry() //  [R1, R2, R3]
         { info_tbl: [(c4Ibs,
                       label: sat_s4Fvp_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ibs: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Foreign.Storable.$fStorableRatio4_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fvo_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c4IbA,
                       label: sat_s4Fvo_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IbA: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           call Foreign.Storable.$fStorableRatio5_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fvn_entry() //  [R1, R2, R3]
         { info_tbl: [(c4IbI,
                       label: sat_s4Fvn_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IbI: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Foreign.Storable.$fStorableRatio7_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fvm_entry() //  [R1]
         { info_tbl: [(c4IbP,
                       label: sat_s4Fvm_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IbP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4IbQ; else goto c4IbR;
       c4IbQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4IbR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.$fStorableRatio_$calignment_entry(R3,
                                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4Fvl_entry() //  [R1]
         { info_tbl: [(c4IbW,
                       label: sat_s4Fvl_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IbW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4IbX; else goto c4IbY;
       c4IbX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4IbY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.$fStorableRatio_$csizeOf_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableRatio_entry() //  [R2, R3]
         { info_tbl: [(c4Ic0,
                       label: Foreign.Storable.$fStorableRatio_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ic0: // global
           Hp = Hp + 280;
           if (Hp > HpLim) (likely: False) goto c4Ic4; else goto c4Ic3;
       c4Ic4: // global
           HpAlloc = 280;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Ic3: // global
           I64[Hp - 272] = sat_s4Fvs_info;
           P64[Hp - 264] = R2;
           P64[Hp - 256] = R3;
           I64[Hp - 248] = sat_s4Fvr_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           I64[Hp - 224] = sat_s4Fvq_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           I64[Hp - 200] = sat_s4Fvp_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_s4Fvo_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_s4Fvn_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = sat_s4Fvm_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_s4Fvl_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = Foreign.Storable.C:Storable_con_info;
           P64[Hp - 56] = Hp - 96;
           P64[Hp - 48] = Hp - 128;
           P64[Hp - 40] = Hp - 149;
           P64[Hp - 32] = Hp - 172;
           P64[Hp - 24] = Hp - 197;
           P64[Hp - 16] = Hp - 220;
           P64[Hp - 8] = Hp - 246;
           P64[Hp] = Hp - 269;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.397975272 UTC

[section ""data" . Foreign.Storable.$wpokeW64_closure" {
     Foreign.Storable.$wpokeW64_closure:
         const Foreign.Storable.$wpokeW64_info;
 },
 Foreign.Storable.$wpokeW64_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Idb,
                       label: Foreign.Storable.$wpokeW64_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Idb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4Idc; else goto u4Idj;
       c4Idc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$wpokeW64_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u4Idj: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c4IcJ() args: 0, res: 0, upd: 0;
     }
 },
 _c4IcJ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IcJ: // global
           _s4Fvx::I64 = I64[Sp + 8];
           if (_s4Fvx::I64 != 0) goto c4Id9; else goto c4Ida;
       c4Id9: // global
           I64[Sp - 8] = block_c4IcO_info;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Fvx::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Idl; else goto c4IcP;
       u4Idl: // global
           call _c4IcO(R1) args: 0, res: 0, upd: 0;
       c4IcP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Ida: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4IcO() //  [R1]
         { info_tbl: [(c4IcO,
                       label: block_c4IcO_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IcO: // global
           _s4Fvt::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4IcT_info;
           _s4Fvz::I64 = I64[R1 + 7];
           R1 = _s4Fvt::P64;
           I64[Sp + 16] = _s4Fvz::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4Idm; else goto c4IcU;
       u4Idm: // global
           call _c4IcT(R1) args: 0, res: 0, upd: 0;
       c4IcU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IcT() //  [R1]
         { info_tbl: [(c4IcT,
                       label: block_c4IcT_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IcT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Idh; else goto c4Idg;
       c4Idh: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Idg: // global
           _s4Fvx::I64 = I64[Sp + 16];
           _s4Fvz::I64 = I64[Sp + 8];
           I8[I64[R1 + 7] + (_s4Fvx::I64 + -1)] = %MO_UU_Conv_W64_W8(_s4Fvz::I64);
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4Fvz::I64 >> 8;
           P64[Sp] = R1;
           I64[Sp + 8] = _s4Fvx::I64 - 1;
           P64[Sp + 16] = Hp - 7;
           call _c4IcJ() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.408326433 UTC

[section ""data" . Foreign.Storable.$w$cpoke_closure" {
     Foreign.Storable.$w$cpoke_closure:
         const Foreign.Storable.$w$cpoke_info;
 },
 sat_s4FvT_entry() //  [R1]
         { info_tbl: [(c4Ie0,
                       label: sat_s4FvT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ie0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Ie7; else goto c4Ie8;
       c4Ie7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ie8: // global
           I64[Sp - 8] = block_c4IdX_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Iec; else goto c4IdY;
       u4Iec: // global
           call _c4IdX(R1) args: 0, res: 0, upd: 0;
       c4IdY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IdX() //  [R1]
         { info_tbl: [(c4IdX,
                       label: block_c4IdX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IdX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Ieb; else goto c4Iea;
       c4Ieb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Iea: // global
           _s4FvS::I64 = I64[R1 + 7] + 8;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4FvS::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Storable.$w$cpoke_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Ied,
                       label: Foreign.Storable.$w$cpoke_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 20} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ied: // global
           _s4FvK::I64 = R4;
           _s4FvJ::I64 = R3;
           _s4FvI::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c4Iee; else goto c4Ief;
       c4Ief: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Ieh; else goto c4Ieg;
       c4Ieh: // global
           HpAlloc = 16;
           goto c4Iee;
       c4Iee: // global
           R4 = _s4FvK::I64;
           R3 = _s4FvJ::I64;
           R2 = _s4FvI::P64;
           R1 = Foreign.Storable.$w$cpoke_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Ieg: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4FvJ::I64;
           I64[Sp - 24] = block_c4IdQ_info;
           R4 = Hp - 7;
           R3 = 8;
           R2 = _s4FvI::P64;
           P64[Sp - 16] = _s4FvI::P64;
           I64[Sp - 8] = _s4FvK::I64;
           Sp = Sp - 24;
           call Foreign.Storable.$wpokeW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4IdQ() //  [R1]
         { info_tbl: [(c4IdQ,
                       label: block_c4IdQ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IdQ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4Iek; else goto c4Iej;
       c4Iek: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Iej: // global
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = sat_s4FvT_info;
           P64[Hp] = P64[Sp + 8];
           R4 = Hp - 31;
           R3 = 8;
           R2 = Hp - 16;
           Sp = Sp + 24;
           call Foreign.Storable.$wpokeW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.420722496 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint1_closure" {
     Foreign.Storable.$fStorableFingerprint1_closure:
         const Foreign.Storable.$fStorableFingerprint1_info;
 },
 Foreign.Storable.$fStorableFingerprint1_entry() //  [R2, R3]
         { info_tbl: [(c4IeM,
                       label: Foreign.Storable.$fStorableFingerprint1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IeM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4IeN; else goto c4IeO;
       c4IeN: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4IeO: // global
           I64[Sp - 16] = block_c4IeJ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4IeS; else goto c4IeK;
       u4IeS: // global
           call _c4IeJ(R1) args: 0, res: 0, upd: 0;
       c4IeK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IeJ() //  [R1]
         { info_tbl: [(c4IeJ,
                       label: block_c4IeJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IeJ: // global
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.Storable.$w$cpoke_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.431783883 UTC

[section ""data" . Foreign.Storable.$wpeekW64_closure" {
     Foreign.Storable.$wpeekW64_closure:
         const Foreign.Storable.$wpeekW64_info;
 },
 Foreign.Storable.$wpeekW64_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Ift,
                       label: Foreign.Storable.$wpeekW64_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 20} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ift: // global
           if ((Sp + -24) < SpLim) (likely: False) goto u4IfE; else goto u4IfD;
       u4IfE: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c4Ifu() args: 0, res: 0, upd: 0;
       u4IfD: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c4If3() args: 0, res: 0, upd: 0;
     }
 },
 _c4If3() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4If3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Ifx; else goto c4Ifw;
       c4Ifx: // global
           HpAlloc = 16;
           call _c4Ifu() args: 0, res: 0, upd: 0;
       c4Ifw: // global
           _s4Fw5::I64 = I64[Sp + 8];
           if (_s4Fw5::I64 != 0) goto c4Ifr; else goto c4Ifs;
       c4Ifr: // global
           Hp = Hp - 16;
           _s4Fw1::P64 = P64[Sp];
           I64[Sp] = block_c4If8_info;
           R1 = _s4Fw1::P64;
           I64[Sp + 8] = _s4Fw5::I64;
           if (R1 & 7 != 0) goto u4IfG; else goto c4If9;
       u4IfG: // global
           call _c4If8(R1) args: 0, res: 0, upd: 0;
       c4If9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4Ifs: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4Ifu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ifu: // global
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = Foreign.Storable.$wpeekW64_closure;
           Sp = Sp + 24;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4If8() //  [R1]
         { info_tbl: [(c4If8,
                       label: block_c4If8_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4If8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4IfA; else goto c4Ifz;
       c4IfA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Ifz: // global
           _s4Fw7::I64 = I64[R1 + 7];
           _s4Fwf::I64 = (I64[Sp + 16] << 8) | %MO_UU_Conv_W8_W64(I8[_s4Fw7::I64]);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fw7::I64 + 1;
           P64[Sp] = Hp - 7;
           I64[Sp + 8] = I64[Sp + 8] - 1;
           I64[Sp + 16] = _s4Fwf::I64;
           call _c4If3() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.446752279 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint2_closure" {
     Foreign.Storable.$fStorableFingerprint2_closure:
         const Foreign.Storable.$fStorableFingerprint2_info;
 },
 sat_s4Fwp_entry() //  [R1]
         { info_tbl: [(c4Igh,
                       label: sat_s4Fwp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Igh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Igo; else goto c4Igp;
       c4Igo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Igp: // global
           I64[Sp - 8] = block_c4Ige_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Igt; else goto c4Igf;
       u4Igt: // global
           call _c4Ige(R1) args: 0, res: 0, upd: 0;
       c4Igf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ige() //  [R1]
         { info_tbl: [(c4Ige,
                       label: block_c4Ige_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ige: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Igs; else goto c4Igr;
       c4Igs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Igr: // global
           _s4Fwo::I64 = I64[R1 + 7] + 8;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fwo::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4Fwt_entry() //  [R1]
         { info_tbl: [(c4IgA,
                       label: sat_s4Fwt_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IgA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4IgB; else goto c4IgC;
       c4IgB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4IgC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$WFingerprint_entry(R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableFingerprint2_entry() //  [R2]
         { info_tbl: [(c4IgD,
                       label: Foreign.Storable.$fStorableFingerprint2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IgD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4IgE; else goto c4IgF;
       c4IgE: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4IgF: // global
           I64[Sp - 16] = block_c4Ig8_info;
           R4 = 0;
           R3 = 8;
           _s4Fwh::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s4Fwh::P64;
           Sp = Sp - 16;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ig8() //  [R1]
         { info_tbl: [(c4Ig8,
                       label: block_c4Ig8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ig8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4IgI; else goto c4IgH;
       c4IgI: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4IgH: // global
           I64[Hp - 16] = sat_s4Fwp_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_c4Igu_info;
           R4 = 0;
           R3 = 8;
           R2 = Hp - 16;
           P64[Sp + 8] = R1;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4Igu() //  [R1]
         { info_tbl: [(c4Igu,
                       label: block_c4Igu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Igu: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4IgL; else goto c4IgK;
       c4IgL: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4IgK: // global
           I64[Hp - 24] = sat_s4Fwt_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.463998672 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint4_closure" {
     Foreign.Storable.$fStorableFingerprint4_closure:
         const Foreign.Storable.$fStorableFingerprint4_info;
 },
 sat_s4FwC_entry() //  [R1]
         { info_tbl: [(c4Ihp,
                       label: sat_s4FwC_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ihp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4IhB; else goto c4IhC;
       c4IhB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4IhC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4Ihm_info;
           _s4Fwv::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4Fwv::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4IhI; else goto c4Ihn;
       u4IhI: // global
           call _c4Ihm(R1) args: 0, res: 0, upd: 0;
       c4Ihn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4Ihm() //  [R1]
         { info_tbl: [(c4Ihm,
                       label: block_c4Ihm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ihm: // global
           I64[Sp] = block_c4Ihs_info;
           _s4Fwy::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fwy::I64;
           if (R1 & 7 != 0) goto u4IhH; else goto c4Iht;
       u4IhH: // global
           call _c4Ihs(R1) args: 0, res: 0, upd: 0;
       c4Iht: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4Ihs() //  [R1]
         { info_tbl: [(c4Ihs,
                       label: block_c4Ihs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ihs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4IhG; else goto c4IhF;
       c4IhG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4IhF: // global
           _s4FwB::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4FwB::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableFingerprint4_entry() //  [R2, R3]
         { info_tbl: [(c4IhJ,
                       label: Foreign.Storable.$fStorableFingerprint4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IhJ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4IhN; else goto c4IhM;
       c4IhN: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4IhM: // global
           I64[Hp - 24] = sat_s4FwC_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           call Foreign.Storable.$fStorableFingerprint2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.477904132 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint6_closure" {
     Foreign.Storable.$fStorableFingerprint6_closure:
         const Foreign.Storable.$fStorableFingerprint6_info;
 },
 sat_s4FwM_entry() //  [R1]
         { info_tbl: [(c4Iii,
                       label: sat_s4FwM_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Iii: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4Iix; else goto c4Iiy;
       c4Iix: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Iiy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4Iif_info;
           _s4FwE::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4FwE::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4IiE; else goto c4Iig;
       u4IiE: // global
           call _c4Iif(R1) args: 0, res: 0, upd: 0;
       c4Iig: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4Iif() //  [R1]
         { info_tbl: [(c4Iif,
                       label: block_c4Iif_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Iif: // global
           I64[Sp] = block_c4Iil_info;
           _s4FwH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FwH::I64;
           if (R1 & 7 != 0) goto u4IiD; else goto c4Iim;
       u4IiD: // global
           call _c4Iil(R1) args: 0, res: 0, upd: 0;
       c4Iim: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4Iil() //  [R1]
         { info_tbl: [(c4Iil,
                       label: block_c4Iil_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Iil: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4IiC; else goto c4IiB;
       c4IiC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4IiB: // global
           _s4FwL::I64 = I64[Sp + 8] + (I64[R1 + 7] << 4);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4FwL::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableFingerprint6_entry() //  [R2, R3]
         { info_tbl: [(c4IiF,
                       label: Foreign.Storable.$fStorableFingerprint6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IiF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4IiJ; else goto c4IiI;
       c4IiJ: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4IiI: // global
           I64[Hp - 24] = sat_s4FwM_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           call Foreign.Storable.$fStorableFingerprint2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.492741735 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint3_closure" {
     Foreign.Storable.$fStorableFingerprint3_closure:
         const Foreign.Storable.$fStorableFingerprint3_info;
 },
 sat_s4FwZ_entry() //  [R1]
         { info_tbl: [(c4Ijj,
                       label: sat_s4FwZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ijj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4Ijv; else goto c4Ijw;
       c4Ijv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4Ijw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4Ijg_info;
           _s4FwO::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4FwO::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4IjC; else goto c4Ijh;
       u4IjC: // global
           call _c4Ijg(R1) args: 0, res: 0, upd: 0;
       c4Ijh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4Ijg() //  [R1]
         { info_tbl: [(c4Ijg,
                       label: block_c4Ijg_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ijg: // global
           I64[Sp] = block_c4Ijm_info;
           _s4FwV::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4FwV::I64;
           if (R1 & 7 != 0) goto u4IjB; else goto c4Ijn;
       u4IjB: // global
           call _c4Ijm(R1) args: 0, res: 0, upd: 0;
       c4Ijn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4Ijm() //  [R1]
         { info_tbl: [(c4Ijm,
                       label: block_c4Ijm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ijm: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4IjA; else goto c4Ijz;
       c4IjA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4Ijz: // global
           _s4FwY::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4FwY::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableFingerprint3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4IjD,
                       label: Foreign.Storable.$fStorableFingerprint3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IjD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4IjE; else goto c4IjF;
       c4IjE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4IjF: // global
           I64[Sp - 24] = block_c4Ij7_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4IjJ; else goto c4Ij8;
       u4IjJ: // global
           call _c4Ij7(R1) args: 0, res: 0, upd: 0;
       c4Ij8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ij7() //  [R1]
         { info_tbl: [(c4Ij7,
                       label: block_c4Ij7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ij7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4IjI; else goto c4IjH;
       c4IjI: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4IjH: // global
           _s4FwS::I64 = I64[R1 + 7];
           _s4FwT::I64 = I64[R1 + 15];
           I64[Hp - 24] = sat_s4FwZ_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = _s4FwT::I64;
           R3 = _s4FwS::I64;
           R2 = Hp - 24;
           Sp = Sp + 24;
           call Foreign.Storable.$w$cpoke_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.509535335 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint5_closure" {
     Foreign.Storable.$fStorableFingerprint5_closure:
         const Foreign.Storable.$fStorableFingerprint5_info;
 },
 sat_s4Fxd_entry() //  [R1]
         { info_tbl: [(c4Ikq,
                       label: sat_s4Fxd_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ikq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4IkF; else goto c4IkG;
       c4IkF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4IkG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4Ikn_info;
           _s4Fx1::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4Fx1::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4IkM; else goto c4Iko;
       u4IkM: // global
           call _c4Ikn(R1) args: 0, res: 0, upd: 0;
       c4Iko: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4Ikn() //  [R1]
         { info_tbl: [(c4Ikn,
                       label: block_c4Ikn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ikn: // global
           I64[Sp] = block_c4Ikt_info;
           _s4Fx8::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Fx8::I64;
           if (R1 & 7 != 0) goto u4IkL; else goto c4Iku;
       u4IkL: // global
           call _c4Ikt(R1) args: 0, res: 0, upd: 0;
       c4Iku: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4Ikt() //  [R1]
         { info_tbl: [(c4Ikt,
                       label: block_c4Ikt_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ikt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4IkK; else goto c4IkJ;
       c4IkK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4IkJ: // global
           _s4Fxc::I64 = I64[Sp + 8] + (I64[R1 + 7] << 4);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Fxc::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableFingerprint5_entry() //  [R2, R3, R4]
         { info_tbl: [(c4IkN,
                       label: Foreign.Storable.$fStorableFingerprint5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IkN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4IkO; else goto c4IkP;
       c4IkO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4IkP: // global
           I64[Sp - 24] = block_c4Ike_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4IkT; else goto c4Ikf;
       u4IkT: // global
           call _c4Ike(R1) args: 0, res: 0, upd: 0;
       c4Ikf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ike() //  [R1]
         { info_tbl: [(c4Ike,
                       label: block_c4Ike_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ike: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4IkS; else goto c4IkR;
       c4IkS: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4IkR: // global
           _s4Fx5::I64 = I64[R1 + 7];
           _s4Fx6::I64 = I64[R1 + 15];
           I64[Hp - 24] = sat_s4Fxd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = _s4Fx6::I64;
           R3 = _s4Fx5::I64;
           R2 = Hp - 24;
           Sp = Sp + 24;
           call Foreign.Storable.$w$cpoke_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.524865651 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint_closure" {
     Foreign.Storable.$fStorableFingerprint_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableFingerprint_$csizeOf_closure+1;
         const Foreign.Storable.$fStorableFingerprint_$calignment_closure+1;
         const Foreign.Storable.$fStorableFingerprint6_closure+3;
         const Foreign.Storable.$fStorableFingerprint5_closure+4;
         const Foreign.Storable.$fStorableFingerprint4_closure+3;
         const Foreign.Storable.$fStorableFingerprint3_closure+4;
         const Foreign.Storable.$fStorableFingerprint2_closure+2;
         const Foreign.Storable.$fStorableFingerprint1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.528801516 UTC

[section ""data" . Foreign.Storable.C:Storable_closure" {
     Foreign.Storable.C:Storable_closure:
         const Foreign.Storable.C:Storable_info;
 },
 Foreign.Storable.C:Storable_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ilm: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Foreign.Storable.C:Storable_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 32, res: 0, upd: 8;
     }
 },
 Foreign.Storable.C:Storable_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c4Ilr,
                       label: Foreign.Storable.C:Storable_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ilr: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4Ilv; else goto c4Ilu;
       c4Ilv: // global
           HpAlloc = 72;
           R1 = Foreign.Storable.C:Storable_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c4Ilu: // global
           I64[Hp - 64] = Foreign.Storable.C:Storable_con_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = R6;
           P64[Hp - 16] = P64[Sp];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 63;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.537632361 UTC

[Foreign.Storable.C:Storable_con_entry() //  [R1]
         { info_tbl: [(c4IlG,
                       label: Foreign.Storable.C:Storable_con_info
                       rep:HeapRep 8 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,70,111,114,101,105,103,110,46,83,116,111,114,97,98,108,101,46,67,58,83,116,111,114,97,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IlG: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:32.541041507 UTC

[section ""relreadonly" . S4FBN_srt" {
     S4FBN_srt:
         const GHC.Err.undefined_closure;
         const lvl10_r4Ffj_closure;
         const Foreign.Storable.$fStorableRatio8_closure;
         const Foreign.Storable.$fStorableRatio_$calignment_closure;
         const GHC.Real.%_closure;
         const Foreign.Storable.$fStorableRatio2_closure;
         const lvl15_r4Ffp_closure;
         const lvl16_r4Ffq_closure;
         const Foreign.Storable.$dmpeekElemOff_closure;
         const lvl19_r4Fft_closure;
         const Foreign.Storable.$fStorableRatio6_closure;
         const Foreign.Storable.$fStorableRatio_$csizeOf_closure;
         const Foreign.Storable.$fStorableRatio4_closure;
         const Foreign.Storable.$fStorableRatio7_closure;
         const Foreign.Storable.$w$cpokeElemOff_closure;
         const Foreign.Storable.$fStorableRatio5_closure;
         const Foreign.Storable.$fStorableRatio_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.032229341 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:37.033750339 UTC

[section ""data" . Foreign.Storable.sizeOf_closure" {
     Foreign.Storable.sizeOf_closure:
         const Foreign.Storable.sizeOf_info;
 },
 Foreign.Storable.sizeOf_entry() //  [R2]
         { info_tbl: [(c4IDD,
                       label: Foreign.Storable.sizeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IDD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4IDE; else goto c4IDF;
       c4IDE: // global
           R2 = R2;
           R1 = Foreign.Storable.sizeOf_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4IDF: // global
           I64[Sp - 8] = block_c4IDA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4IDJ; else goto c4IDB;
       u4IDJ: // global
           call _c4IDA(R1) args: 0, res: 0, upd: 0;
       c4IDB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IDA() //  [R1]
         { info_tbl: [(c4IDA,
                       label: block_c4IDA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IDA: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.040052984 UTC

[section ""data" . Foreign.Storable.alignment_closure" {
     Foreign.Storable.alignment_closure:
         const Foreign.Storable.alignment_info;
 },
 Foreign.Storable.alignment_entry() //  [R2]
         { info_tbl: [(c4IE1,
                       label: Foreign.Storable.alignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IE1: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4IE2; else goto c4IE3;
       c4IE2: // global
           R2 = R2;
           R1 = Foreign.Storable.alignment_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4IE3: // global
           I64[Sp - 8] = block_c4IDY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4IE7; else goto c4IDZ;
       u4IE7: // global
           call _c4IDY(R1) args: 0, res: 0, upd: 0;
       c4IDZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IDY() //  [R1]
         { info_tbl: [(c4IDY,
                       label: block_c4IDY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IDY: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.047323441 UTC

[section ""data" . Foreign.Storable.peekElemOff_closure" {
     Foreign.Storable.peekElemOff_closure:
         const Foreign.Storable.peekElemOff_info;
 },
 Foreign.Storable.peekElemOff_entry() //  [R2]
         { info_tbl: [(c4IEp,
                       label: Foreign.Storable.peekElemOff_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IEp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4IEq; else goto c4IEr;
       c4IEq: // global
           R2 = R2;
           R1 = Foreign.Storable.peekElemOff_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4IEr: // global
           I64[Sp - 8] = block_c4IEm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4IEv; else goto c4IEn;
       u4IEv: // global
           call _c4IEm(R1) args: 0, res: 0, upd: 0;
       c4IEn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IEm() //  [R1]
         { info_tbl: [(c4IEm,
                       label: block_c4IEm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IEm: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.05343257 UTC

[section ""data" . Foreign.Storable.pokeElemOff_closure" {
     Foreign.Storable.pokeElemOff_closure:
         const Foreign.Storable.pokeElemOff_info;
 },
 Foreign.Storable.pokeElemOff_entry() //  [R2]
         { info_tbl: [(c4IEN,
                       label: Foreign.Storable.pokeElemOff_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IEN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4IEO; else goto c4IEP;
       c4IEO: // global
           R2 = R2;
           R1 = Foreign.Storable.pokeElemOff_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4IEP: // global
           I64[Sp - 8] = block_c4IEK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4IET; else goto c4IEL;
       u4IET: // global
           call _c4IEK(R1) args: 0, res: 0, upd: 0;
       c4IEL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IEK() //  [R1]
         { info_tbl: [(c4IEK,
                       label: block_c4IEK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IEK: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.059374305 UTC

[section ""data" . Foreign.Storable.peekByteOff_closure" {
     Foreign.Storable.peekByteOff_closure:
         const Foreign.Storable.peekByteOff_info;
 },
 Foreign.Storable.peekByteOff_entry() //  [R2]
         { info_tbl: [(c4IFb,
                       label: Foreign.Storable.peekByteOff_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IFb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4IFc; else goto c4IFd;
       c4IFc: // global
           R2 = R2;
           R1 = Foreign.Storable.peekByteOff_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4IFd: // global
           I64[Sp - 8] = block_c4IF8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4IFh; else goto c4IF9;
       u4IFh: // global
           call _c4IF8(R1) args: 0, res: 0, upd: 0;
       c4IF9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IF8() //  [R1]
         { info_tbl: [(c4IF8,
                       label: block_c4IF8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IF8: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.065441102 UTC

[section ""data" . Foreign.Storable.pokeByteOff_closure" {
     Foreign.Storable.pokeByteOff_closure:
         const Foreign.Storable.pokeByteOff_info;
 },
 Foreign.Storable.pokeByteOff_entry() //  [R2]
         { info_tbl: [(c4IFz,
                       label: Foreign.Storable.pokeByteOff_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IFz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4IFA; else goto c4IFB;
       c4IFA: // global
           R2 = R2;
           R1 = Foreign.Storable.pokeByteOff_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4IFB: // global
           I64[Sp - 8] = block_c4IFw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4IFF; else goto c4IFx;
       u4IFF: // global
           call _c4IFw(R1) args: 0, res: 0, upd: 0;
       c4IFx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IFw() //  [R1]
         { info_tbl: [(c4IFw,
                       label: block_c4IFw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IFw: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.075221187 UTC

[section ""data" . Foreign.Storable.peek_closure" {
     Foreign.Storable.peek_closure:
         const Foreign.Storable.peek_info;
 },
 Foreign.Storable.peek_entry() //  [R2]
         { info_tbl: [(c4IFX,
                       label: Foreign.Storable.peek_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IFX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4IFY; else goto c4IFZ;
       c4IFY: // global
           R2 = R2;
           R1 = Foreign.Storable.peek_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4IFZ: // global
           I64[Sp - 8] = block_c4IFU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4IG3; else goto c4IFV;
       u4IG3: // global
           call _c4IFU(R1) args: 0, res: 0, upd: 0;
       c4IFV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IFU() //  [R1]
         { info_tbl: [(c4IFU,
                       label: block_c4IFU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IFU: // global
           R1 = P64[R1 + 55];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.083831337 UTC

[section ""data" . Foreign.Storable.poke_closure" {
     Foreign.Storable.poke_closure:
         const Foreign.Storable.poke_info;
 },
 Foreign.Storable.poke_entry() //  [R2]
         { info_tbl: [(c4IGl,
                       label: Foreign.Storable.poke_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IGl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4IGm; else goto c4IGn;
       c4IGm: // global
           R2 = R2;
           R1 = Foreign.Storable.poke_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4IGn: // global
           I64[Sp - 8] = block_c4IGi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4IGr; else goto c4IGj;
       u4IGr: // global
           call _c4IGi(R1) args: 0, res: 0, upd: 0;
       c4IGj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IGi() //  [R1]
         { info_tbl: [(c4IGi,
                       label: block_c4IGi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IGi: // global
           R1 = P64[R1 + 63];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.090200571 UTC

[section ""data" . Foreign.Storable.$fStorable()7_closure" {
     Foreign.Storable.$fStorable()7_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.092074828 UTC

[section ""data" . Foreign.Storable.$fStorable()_$calignment_closure" {
     Foreign.Storable.$fStorable()_$calignment_closure:
         const Foreign.Storable.$fStorable()_$calignment_info;
 },
 Foreign.Storable.$fStorable()_$calignment_entry() //  []
         { info_tbl: [(c4IGH,
                       label: Foreign.Storable.$fStorable()_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IGH: // global
           R1 = Foreign.Storable.$fStorable()7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.09556825 UTC

[section ""data" . Foreign.Storable.$fStorable()8_closure" {
     Foreign.Storable.$fStorable()8_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.098144786 UTC

[section ""data" . Foreign.Storable.$fStorable()_$csizeOf_closure" {
     Foreign.Storable.$fStorable()_$csizeOf_closure:
         const Foreign.Storable.$fStorable()_$csizeOf_info;
 },
 Foreign.Storable.$fStorable()_$csizeOf_entry() //  []
         { info_tbl: [(c4IGU,
                       label: Foreign.Storable.$fStorable()_$csizeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IGU: // global
           R1 = Foreign.Storable.$fStorable()8_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.10219737 UTC

[section ""data" . Foreign.Storable.$fStorableBool7_closure" {
     Foreign.Storable.$fStorableBool7_closure:
         const GHC.Types.I#_con_info;
         const 4;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.10449321 UTC

[section ""data" . Foreign.Storable.$fStorableChar_$calignment_closure" {
     Foreign.Storable.$fStorableChar_$calignment_closure:
         const Foreign.Storable.$fStorableChar_$calignment_info;
 },
 Foreign.Storable.$fStorableChar_$calignment_entry() //  []
         { info_tbl: [(c4IH7,
                       label: Foreign.Storable.$fStorableChar_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IH7: // global
           R1 = Foreign.Storable.$fStorableBool7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.108005598 UTC

[section ""data" . Foreign.Storable.$fStorableDouble5_closure" {
     Foreign.Storable.$fStorableDouble5_closure:
         const GHC.Types.I#_con_info;
         const 8;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.110613489 UTC

[section ""data" . Foreign.Storable.$fStorableInt_$calignment_closure" {
     Foreign.Storable.$fStorableInt_$calignment_closure:
         const Foreign.Storable.$fStorableInt_$calignment_info;
 },
 Foreign.Storable.$fStorableInt_$calignment_entry() //  []
         { info_tbl: [(c4IHk,
                       label: Foreign.Storable.$fStorableInt_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IHk: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.114333888 UTC

[section ""data" . Foreign.Storable.$fStorableWord_$calignment_closure" {
     Foreign.Storable.$fStorableWord_$calignment_closure:
         const Foreign.Storable.$fStorableWord_$calignment_info;
 },
 Foreign.Storable.$fStorableWord_$calignment_entry() //  []
         { info_tbl: [(c4IHw,
                       label: Foreign.Storable.$fStorableWord_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IHw: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.118206025 UTC

[section ""data" . Foreign.Storable.$fStorablePtr_$calignment_closure" {
     Foreign.Storable.$fStorablePtr_$calignment_closure:
         const Foreign.Storable.$fStorablePtr_$calignment_info;
 },
 Foreign.Storable.$fStorablePtr_$calignment_entry() //  []
         { info_tbl: [(c4IHI,
                       label: Foreign.Storable.$fStorablePtr_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IHI: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.121894624 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr_$calignment_closure" {
     Foreign.Storable.$fStorableFunPtr_$calignment_closure:
         const Foreign.Storable.$fStorableFunPtr_$calignment_info;
 },
 Foreign.Storable.$fStorableFunPtr_$calignment_entry() //  []
         { info_tbl: [(c4IHU,
                       label: Foreign.Storable.$fStorableFunPtr_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IHU: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.126207385 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr_$calignment_closure" {
     Foreign.Storable.$fStorableStablePtr_$calignment_closure:
         const Foreign.Storable.$fStorableStablePtr_$calignment_info;
 },
 Foreign.Storable.$fStorableStablePtr_$calignment_entry() //  []
         { info_tbl: [(c4II6,
                       label: Foreign.Storable.$fStorableStablePtr_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4II6: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.129869498 UTC

[section ""data" . Foreign.Storable.$fStorableFloat_$calignment_closure" {
     Foreign.Storable.$fStorableFloat_$calignment_closure:
         const Foreign.Storable.$fStorableFloat_$calignment_info;
 },
 Foreign.Storable.$fStorableFloat_$calignment_entry() //  []
         { info_tbl: [(c4IIi,
                       label: Foreign.Storable.$fStorableFloat_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IIi: // global
           R1 = Foreign.Storable.$fStorableBool7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.133600587 UTC

[section ""data" . Foreign.Storable.$fStorableDouble_$calignment_closure" {
     Foreign.Storable.$fStorableDouble_$calignment_closure:
         const Foreign.Storable.$fStorableDouble_$calignment_info;
 },
 Foreign.Storable.$fStorableDouble_$calignment_entry() //  []
         { info_tbl: [(c4IIu,
                       label: Foreign.Storable.$fStorableDouble_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IIu: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.137062292 UTC

[section ""data" . Foreign.Storable.$fStorableWord8_$calignment_closure" {
     Foreign.Storable.$fStorableWord8_$calignment_closure:
         const Foreign.Storable.$fStorableWord8_$calignment_info;
 },
 Foreign.Storable.$fStorableWord8_$calignment_entry() //  []
         { info_tbl: [(c4IIG,
                       label: Foreign.Storable.$fStorableWord8_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IIG: // global
           R1 = Foreign.Storable.$fStorable()7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.140459911 UTC

[section ""data" . Foreign.Storable.$fStorableInt10_closure" {
     Foreign.Storable.$fStorableInt10_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.14305297 UTC

[section ""data" . Foreign.Storable.$fStorableWord16_$calignment_closure" {
     Foreign.Storable.$fStorableWord16_$calignment_closure:
         const Foreign.Storable.$fStorableWord16_$calignment_info;
 },
 Foreign.Storable.$fStorableWord16_$calignment_entry() //  []
         { info_tbl: [(c4IIT,
                       label: Foreign.Storable.$fStorableWord16_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IIT: // global
           R1 = Foreign.Storable.$fStorableInt10_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.147274667 UTC

[section ""data" . Foreign.Storable.$fStorableWord32_$calignment_closure" {
     Foreign.Storable.$fStorableWord32_$calignment_closure:
         const Foreign.Storable.$fStorableWord32_$calignment_info;
 },
 Foreign.Storable.$fStorableWord32_$calignment_entry() //  []
         { info_tbl: [(c4IJ5,
                       label: Foreign.Storable.$fStorableWord32_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IJ5: // global
           R1 = Foreign.Storable.$fStorableBool7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.151060581 UTC

[section ""data" . Foreign.Storable.$fStorableWord64_$calignment_closure" {
     Foreign.Storable.$fStorableWord64_$calignment_closure:
         const Foreign.Storable.$fStorableWord64_$calignment_info;
 },
 Foreign.Storable.$fStorableWord64_$calignment_entry() //  []
         { info_tbl: [(c4IJh,
                       label: Foreign.Storable.$fStorableWord64_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IJh: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.154830997 UTC

[section ""data" . Foreign.Storable.$fStorableInt8_$calignment_closure" {
     Foreign.Storable.$fStorableInt8_$calignment_closure:
         const Foreign.Storable.$fStorableInt8_$calignment_info;
 },
 Foreign.Storable.$fStorableInt8_$calignment_entry() //  []
         { info_tbl: [(c4IJt,
                       label: Foreign.Storable.$fStorableInt8_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IJt: // global
           R1 = Foreign.Storable.$fStorable()7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.158806441 UTC

[section ""data" . Foreign.Storable.$fStorableInt16_$calignment_closure" {
     Foreign.Storable.$fStorableInt16_$calignment_closure:
         const Foreign.Storable.$fStorableInt16_$calignment_info;
 },
 Foreign.Storable.$fStorableInt16_$calignment_entry() //  []
         { info_tbl: [(c4IJF,
                       label: Foreign.Storable.$fStorableInt16_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IJF: // global
           R1 = Foreign.Storable.$fStorableInt10_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.16248948 UTC

[section ""data" . Foreign.Storable.$fStorableInt32_$calignment_closure" {
     Foreign.Storable.$fStorableInt32_$calignment_closure:
         const Foreign.Storable.$fStorableInt32_$calignment_info;
 },
 Foreign.Storable.$fStorableInt32_$calignment_entry() //  []
         { info_tbl: [(c4IJR,
                       label: Foreign.Storable.$fStorableInt32_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IJR: // global
           R1 = Foreign.Storable.$fStorableBool7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.167798023 UTC

[section ""data" . Foreign.Storable.$fStorableInt64_$calignment_closure" {
     Foreign.Storable.$fStorableInt64_$calignment_closure:
         const Foreign.Storable.$fStorableInt64_$calignment_info;
 },
 Foreign.Storable.$fStorableInt64_$calignment_entry() //  []
         { info_tbl: [(c4IK3,
                       label: Foreign.Storable.$fStorableInt64_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IK3: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.173138556 UTC

[section ""cstring" . lvl_r4Ff9_bytes" {
     lvl_r4Ff9_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.175285048 UTC

[section ""data" . lvl1_r4Ffa_closure" {
     lvl1_r4Ffa_closure:
         const lvl1_r4Ffa_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r4Ffa_entry() //  [R1]
         { info_tbl: [(c4IKi,
                       label: lvl1_r4Ffa_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IKi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4IKj; else goto c4IKk;
       c4IKj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4IKk: // global
           (_c4IKf::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4IKf::I64 == 0) goto c4IKh; else goto c4IKg;
       c4IKh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4IKg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4IKf::I64;
           R2 = lvl_r4Ff9_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.180035825 UTC

[section ""cstring" . Foreign.Storable.$trModule4_bytes" {
     Foreign.Storable.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.182254997 UTC

[section ""data" . lvl2_r4Ffb_closure" {
     lvl2_r4Ffb_closure:
         const lvl2_r4Ffb_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r4Ffb_entry() //  [R1]
         { info_tbl: [(c4IKA,
                       label: lvl2_r4Ffb_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IKA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4IKB; else goto c4IKC;
       c4IKB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4IKC: // global
           (_c4IKx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4IKx::I64 == 0) goto c4IKz; else goto c4IKy;
       c4IKz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4IKy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4IKx::I64;
           R2 = Foreign.Storable.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.186578522 UTC

[section ""cstring" . Foreign.Storable.$trModule2_bytes" {
     Foreign.Storable.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,83,116,111,114,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.188598254 UTC

[section ""data" . lvl3_r4Ffc_closure" {
     lvl3_r4Ffc_closure:
         const lvl3_r4Ffc_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r4Ffc_entry() //  [R1]
         { info_tbl: [(c4IKS,
                       label: lvl3_r4Ffc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IKS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4IKT; else goto c4IKU;
       c4IKT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4IKU: // global
           (_c4IKP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4IKP::I64 == 0) goto c4IKR; else goto c4IKQ;
       c4IKR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4IKQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4IKP::I64;
           R2 = Foreign.Storable.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.192705365 UTC

[section ""cstring" . lvl4_r4Ffd_bytes" {
     lvl4_r4Ffd_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,83,116,111,114,97,98,108,101,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.194747241 UTC

[section ""data" . lvl5_r4Ffe_closure" {
     lvl5_r4Ffe_closure:
         const lvl5_r4Ffe_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r4Ffe_entry() //  [R1]
         { info_tbl: [(c4ILa,
                       label: lvl5_r4Ffe_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ILa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ILb; else goto c4ILc;
       c4ILb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ILc: // global
           (_c4IL7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4IL7::I64 == 0) goto c4IL9; else goto c4IL8;
       c4IL9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4IL8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4IL7::I64;
           R2 = lvl4_r4Ffd_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.19883055 UTC

[section ""data" . lvl6_r4Fff_closure" {
     lvl6_r4Fff_closure:
         const GHC.Types.I#_con_info;
         const 238;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.200457693 UTC

[section ""data" . lvl7_r4Ffg_closure" {
     lvl7_r4Ffg_closure:
         const GHC.Types.I#_con_info;
         const 30;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.202779547 UTC

[section ""data" . lvl8_r4Ffh_closure" {
     lvl8_r4Ffh_closure:
         const GHC.Types.I#_con_info;
         const 39;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.204494003 UTC

[section ""data" . lvl9_r4Ffi_closure" {
     lvl9_r4Ffi_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r4Ffb_closure;
         const lvl3_r4Ffc_closure;
         const lvl5_r4Ffe_closure;
         const lvl6_r4Fff_closure+1;
         const lvl7_r4Ffg_closure+1;
         const lvl6_r4Fff_closure+1;
         const lvl8_r4Ffh_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.206361858 UTC

[section ""data" . lvl10_r4Ffj_closure" {
     lvl10_r4Ffj_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r4Ffa_closure;
         const lvl9_r4Ffi_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.208497254 UTC

[section ""data" . Foreign.Storable.$fStorableRatio8_closure" {
     Foreign.Storable.$fStorableRatio8_closure:
         const Foreign.Storable.$fStorableRatio8_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Storable.$fStorableRatio8_entry() //  [R1]
         { info_tbl: [(c4ILw,
                       label: Foreign.Storable.$fStorableRatio8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ILw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ILx; else goto c4ILy;
       c4ILx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ILy: // global
           (_c4ILt::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4ILt::I64 == 0) goto c4ILv; else goto c4ILu;
       c4ILv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4ILu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4ILt::I64;
           R2 = lvl10_r4Ffj_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.21393626 UTC

[section ""data" . Foreign.Storable.$fStorableRatio_$calignment_closure" {
     Foreign.Storable.$fStorableRatio_$calignment_closure:
         const Foreign.Storable.$fStorableRatio_$calignment_info;
         const 0;
 },
 lvl20_s4Inp_entry() //  [R1]
         { info_tbl: [(c4ILQ,
                       label: lvl20_s4Inp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ILQ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4ILR; else goto c4ILS;
       c4ILR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ILS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Storable.$fStorableRatio8_closure;
           Sp = Sp - 32;
           call Foreign.Storable.alignment_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s4Inr_entry() //  [R1]
         { info_tbl: [(c4ILY,
                       label: sat_s4Inr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ILY: // global
           R1 = P64[R1 + 7] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Storable.$fStorableRatio_$calignment_entry() //  [R2, R3]
         { info_tbl: [(c4IM1,
                       label: Foreign.Storable.$fStorableRatio_$calignment_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IM1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4IM5; else goto c4IM4;
       c4IM5: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio_$calignment_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4IM4: // global
           I64[Hp - 32] = lvl20_s4Inp_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s4Inr_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.222069524 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint_$calignment_closure" {
     Foreign.Storable.$fStorableFingerprint_$calignment_closure:
         const Foreign.Storable.$fStorableFingerprint_$calignment_info;
 },
 Foreign.Storable.$fStorableFingerprint_$calignment_entry() //  []
         { info_tbl: [(c4IMu,
                       label: Foreign.Storable.$fStorableFingerprint_$calignment_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IMu: // global
           R1 = Foreign.Storable.$fStorableDouble5_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.225545841 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint7_closure" {
     Foreign.Storable.$fStorableFingerprint7_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.227559814 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint_$csizeOf_closure" {
     Foreign.Storable.$fStorableFingerprint_$csizeOf_closure:
         const Foreign.Storable.$fStorableFingerprint_$csizeOf_info;
 },
 Foreign.Storable.$fStorableFingerprint_$csizeOf_entry() //  []
         { info_tbl: [(c4IMH,
                       label: Foreign.Storable.$fStorableFingerprint_$csizeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IMH: // global
           R1 = Foreign.Storable.$fStorableFingerprint7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.231303121 UTC

[section ""data" . Foreign.Storable.$dmpoke_closure" {
     Foreign.Storable.$dmpoke_closure:
         const Foreign.Storable.$dmpoke_info;
 },
 Foreign.Storable.$dmpoke_entry() //  [R2, R3]
         { info_tbl: [(c4IMT,
                       label: Foreign.Storable.$dmpoke_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IMT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4IMU; else goto c4IMV;
       c4IMU: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$dmpoke_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4IMV: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = Foreign.Storable.$fStorable()8_closure+1;
           Sp = Sp - 24;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.235991861 UTC

[section ""data" . Foreign.Storable.$dmpeek_closure" {
     Foreign.Storable.$dmpeek_closure:
         const Foreign.Storable.$dmpeek_info;
 },
 Foreign.Storable.$dmpeek_entry() //  [R2, R3]
         { info_tbl: [(c4IN7,
                       label: Foreign.Storable.$dmpeek_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IN7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4IN8; else goto c4IN9;
       c4IN8: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$dmpeek_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4IN9: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = Foreign.Storable.$fStorable()8_closure+1;
           Sp = Sp - 24;
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.240693309 UTC

[section ""data" . Foreign.Storable.$dmpokeByteOff_closure" {
     Foreign.Storable.$dmpokeByteOff_closure:
         const Foreign.Storable.$dmpokeByteOff_info;
 },
 sat_s4InG_entry() //  [R1]
         { info_tbl: [(c4INs,
                       label: sat_s4InG_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4INs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4INE; else goto c4INF;
       c4INE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4INF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4INp_info;
           _s4InA::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4InA::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4INL; else goto c4INq;
       u4INL: // global
           call _c4INp(R1) args: 0, res: 0, upd: 0;
       c4INq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4INp() //  [R1]
         { info_tbl: [(c4INp,
                       label: block_c4INp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4INp: // global
           I64[Sp] = block_c4INv_info;
           _s4InC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4InC::I64;
           if (R1 & 7 != 0) goto u4INK; else goto c4INw;
       u4INK: // global
           call _c4INv(R1) args: 0, res: 0, upd: 0;
       c4INw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4INv() //  [R1]
         { info_tbl: [(c4INv,
                       label: block_c4INv_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4INv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4INJ; else goto c4INI;
       c4INJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4INI: // global
           _s4InF::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4InF::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$dmpokeByteOff_entry() //  [R2, R3, R4]
         { info_tbl: [(c4INM,
                       label: Foreign.Storable.$dmpokeByteOff_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4INM: // global
           _s4InA::P64 = R4;
           _s4Inz::P64 = R3;
           _s4Iny::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c4INN; else goto c4INO;
       c4INO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4INQ; else goto c4INP;
       c4INQ: // global
           HpAlloc = 32;
           goto c4INN;
       c4INN: // global
           R4 = _s4InA::P64;
           R3 = _s4Inz::P64;
           R2 = _s4Iny::P64;
           R1 = Foreign.Storable.$dmpokeByteOff_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4INP: // global
           I64[Hp - 24] = sat_s4InG_info;
           P64[Hp - 8] = _s4Inz::P64;
           P64[Hp] = _s4InA::P64;
           R2 = _s4Iny::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call Foreign.Storable.poke_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.252013506 UTC

[section ""data" . Foreign.Storable.$dmpeekByteOff_closure" {
     Foreign.Storable.$dmpeekByteOff_closure:
         const Foreign.Storable.$dmpeekByteOff_info;
 },
 sat_s4InP_entry() //  [R1]
         { info_tbl: [(c4IOt,
                       label: sat_s4InP_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IOt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4IOF; else goto c4IOG;
       c4IOF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4IOG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4IOq_info;
           _s4InJ::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4InJ::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4IOM; else goto c4IOr;
       u4IOM: // global
           call _c4IOq(R1) args: 0, res: 0, upd: 0;
       c4IOr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4IOq() //  [R1]
         { info_tbl: [(c4IOq,
                       label: block_c4IOq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IOq: // global
           I64[Sp] = block_c4IOw_info;
           _s4InL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4InL::I64;
           if (R1 & 7 != 0) goto u4IOL; else goto c4IOx;
       u4IOL: // global
           call _c4IOw(R1) args: 0, res: 0, upd: 0;
       c4IOx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4IOw() //  [R1]
         { info_tbl: [(c4IOw,
                       label: block_c4IOw_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IOw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4IOK; else goto c4IOJ;
       c4IOK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4IOJ: // global
           _s4InO::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4InO::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$dmpeekByteOff_entry() //  [R2, R3, R4]
         { info_tbl: [(c4ION,
                       label: Foreign.Storable.$dmpeekByteOff_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ION: // global
           _s4InJ::P64 = R4;
           _s4InI::P64 = R3;
           _s4InH::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c4IOO; else goto c4IOP;
       c4IOP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4IOR; else goto c4IOQ;
       c4IOR: // global
           HpAlloc = 32;
           goto c4IOO;
       c4IOO: // global
           R4 = _s4InJ::P64;
           R3 = _s4InI::P64;
           R2 = _s4InH::P64;
           R1 = Foreign.Storable.$dmpeekByteOff_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4IOQ: // global
           I64[Hp - 24] = sat_s4InP_info;
           P64[Hp - 8] = _s4InI::P64;
           P64[Hp] = _s4InJ::P64;
           R2 = _s4InH::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.263579913 UTC

[section ""data" . Foreign.Storable.$fStorableInt17_closure" {
     Foreign.Storable.$fStorableInt17_closure:
         const Foreign.Storable.$fStorableInt17_info;
 },
 Foreign.Storable.$fStorableInt17_entry() //  [R2]
         { info_tbl: [(c4IPq,
                       label: Foreign.Storable.$fStorableInt17_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IPq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4IPu; else goto c4IPv;
       c4IPu: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt17_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4IPv: // global
           I64[Sp - 8] = block_c4IPn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4IPz; else goto c4IPo;
       u4IPz: // global
           call _c4IPn(R1) args: 0, res: 0, upd: 0;
       c4IPo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IPn() //  [R1]
         { info_tbl: [(c4IPn,
                       label: block_c4IPn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IPn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4IPy; else goto c4IPx;
       c4IPy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4IPx: // global
           _s4InW::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4InW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.270245325 UTC

[section ""data" . Foreign.Storable.$fStorableInt19_closure" {
     Foreign.Storable.$fStorableInt19_closure:
         const Foreign.Storable.$fStorableInt19_info;
 },
 Foreign.Storable.$fStorableInt19_entry() //  [R2, R3]
         { info_tbl: [(c4IPU,
                       label: Foreign.Storable.$fStorableInt19_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IPU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4IQ6; else goto c4IQ7;
       c4IQ6: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt19_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4IQ7: // global
           I64[Sp - 16] = block_c4IPR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4IQd; else goto c4IPS;
       u4IQd: // global
           call _c4IPR(R1) args: 0, res: 0, upd: 0;
       c4IPS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IPR() //  [R1]
         { info_tbl: [(c4IPR,
                       label: block_c4IPR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IPR: // global
           I64[Sp] = block_c4IPX_info;
           _s4Io2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Io2::I64;
           if (R1 & 7 != 0) goto u4IQc; else goto c4IPY;
       u4IQc: // global
           call _c4IPX(R1) args: 0, res: 0, upd: 0;
       c4IPY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IPX() //  [R1]
         { info_tbl: [(c4IPX,
                       label: block_c4IPX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IPX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4IQb; else goto c4IQa;
       c4IQb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4IQa: // global
           _s4Io8::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Int.I64#_con_info;
           I64[Hp] = _s4Io8::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.27860229 UTC

[section ""data" . Foreign.Storable.$fStorableInt15_closure" {
     Foreign.Storable.$fStorableInt15_closure:
         const Foreign.Storable.$fStorableInt15_info;
 },
 Foreign.Storable.$fStorableInt15_entry() //  [R2, R3]
         { info_tbl: [(c4IQE,
                       label: Foreign.Storable.$fStorableInt15_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IQE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4IQI; else goto c4IQJ;
       c4IQI: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt15_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4IQJ: // global
           I64[Sp - 16] = block_c4IQB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4IQR; else goto c4IQC;
       u4IQR: // global
           call _c4IQB(R1) args: 0, res: 0, upd: 0;
       c4IQC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IQB() //  [R1]
         { info_tbl: [(c4IQB,
                       label: block_c4IQB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IQB: // global
           I64[Sp] = block_c4IQH_info;
           _s4Ioe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Ioe::I64;
           if (R1 & 7 != 0) goto u4IQQ; else goto c4IQL;
       u4IQQ: // global
           call _c4IQH(R1) args: 0, res: 0, upd: 0;
       c4IQL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IQH() //  [R1]
         { info_tbl: [(c4IQH,
                       label: block_c4IQH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IQH: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.287736179 UTC

[section ""data" . Foreign.Storable.$fStorableInt18_closure" {
     Foreign.Storable.$fStorableInt18_closure:
         const Foreign.Storable.$fStorableInt18_info;
 },
 Foreign.Storable.$fStorableInt18_entry() //  [R2, R3, R4]
         { info_tbl: [(c4IRi,
                       label: Foreign.Storable.$fStorableInt18_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IRi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4IRr; else goto c4IRs;
       c4IRr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt18_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4IRs: // global
           I64[Sp - 24] = block_c4IRf_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4IRC; else goto c4IRg;
       u4IRC: // global
           call _c4IRf(R1) args: 0, res: 0, upd: 0;
       c4IRg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IRf() //  [R1]
         { info_tbl: [(c4IRf,
                       label: block_c4IRf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IRf: // global
           I64[Sp] = block_c4IRl_info;
           _s4Ion::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Ion::I64;
           if (R1 & 7 != 0) goto u4IRB; else goto c4IRm;
       u4IRB: // global
           call _c4IRl(R1) args: 0, res: 0, upd: 0;
       c4IRm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IRl() //  [R1]
         { info_tbl: [(c4IRl,
                       label: block_c4IRl_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IRl: // global
           I64[Sp] = block_c4IRq_info;
           _s4Iop::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Iop::I64;
           if (R1 & 7 != 0) goto u4IRD; else goto c4IRv;
       u4IRD: // global
           call _c4IRq(R1) args: 0, res: 0, upd: 0;
       c4IRv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IRq() //  [R1]
         { info_tbl: [(c4IRq,
                       label: block_c4IRq_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IRq: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.297895948 UTC

[section ""data" . Foreign.Storable.$fStorableInt64_closure" {
     Foreign.Storable.$fStorableInt64_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt64_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt64_$calignment_closure+1;
         const GHC.Storable.readInt64OffPtr1_closure+3;
         const GHC.Storable.writeInt64OffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt19_closure+3;
         const Foreign.Storable.$fStorableInt18_closure+4;
         const Foreign.Storable.$fStorableInt17_closure+2;
         const Foreign.Storable.$fStorableInt15_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.300206889 UTC

[section ""data" . Foreign.Storable.$fStorableInt12_closure" {
     Foreign.Storable.$fStorableInt12_closure:
         const Foreign.Storable.$fStorableInt12_info;
 },
 Foreign.Storable.$fStorableInt12_entry() //  [R2]
         { info_tbl: [(c4ISb,
                       label: Foreign.Storable.$fStorableInt12_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ISb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ISf; else goto c4ISg;
       c4ISf: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt12_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ISg: // global
           I64[Sp - 8] = block_c4IS8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4ISk; else goto c4IS9;
       u4ISk: // global
           call _c4IS8(R1) args: 0, res: 0, upd: 0;
       c4IS9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IS8() //  [R1]
         { info_tbl: [(c4IS8,
                       label: block_c4IS8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IS8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ISj; else goto c4ISi;
       c4ISj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ISi: // global
           _s4IoA::I64 = %MO_SS_Conv_W32_W64(I32[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4IoA::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.306971306 UTC

[section ""data" . Foreign.Storable.$fStorableInt14_closure" {
     Foreign.Storable.$fStorableInt14_closure:
         const Foreign.Storable.$fStorableInt14_info;
 },
 Foreign.Storable.$fStorableInt14_entry() //  [R2, R3]
         { info_tbl: [(c4ISF,
                       label: Foreign.Storable.$fStorableInt14_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ISF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ISR; else goto c4ISS;
       c4ISR: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt14_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ISS: // global
           I64[Sp - 16] = block_c4ISC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ISY; else goto c4ISD;
       u4ISY: // global
           call _c4ISC(R1) args: 0, res: 0, upd: 0;
       c4ISD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ISC() //  [R1]
         { info_tbl: [(c4ISC,
                       label: block_c4ISC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ISC: // global
           I64[Sp] = block_c4ISI_info;
           _s4IoG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IoG::I64;
           if (R1 & 7 != 0) goto u4ISX; else goto c4ISJ;
       u4ISX: // global
           call _c4ISI(R1) args: 0, res: 0, upd: 0;
       c4ISJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ISI() //  [R1]
         { info_tbl: [(c4ISI,
                       label: block_c4ISI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ISI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4ISW; else goto c4ISV;
       c4ISW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4ISV: // global
           _s4IoM::I64 = %MO_SS_Conv_W32_W64(I32[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s4IoM::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.315140172 UTC

[section ""data" . Foreign.Storable.$fStorableInt11_closure" {
     Foreign.Storable.$fStorableInt11_closure:
         const Foreign.Storable.$fStorableInt11_info;
 },
 Foreign.Storable.$fStorableInt11_entry() //  [R2, R3]
         { info_tbl: [(c4ITp,
                       label: Foreign.Storable.$fStorableInt11_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ITp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ITt; else goto c4ITu;
       c4ITt: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt11_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ITu: // global
           I64[Sp - 16] = block_c4ITm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4ITC; else goto c4ITn;
       u4ITC: // global
           call _c4ITm(R1) args: 0, res: 0, upd: 0;
       c4ITn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ITm() //  [R1]
         { info_tbl: [(c4ITm,
                       label: block_c4ITm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ITm: // global
           I64[Sp] = block_c4ITs_info;
           _s4IoS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IoS::I64;
           if (R1 & 7 != 0) goto u4ITB; else goto c4ITw;
       u4ITB: // global
           call _c4ITs(R1) args: 0, res: 0, upd: 0;
       c4ITw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4ITs() //  [R1]
         { info_tbl: [(c4ITs,
                       label: block_c4ITs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ITs: // global
           I32[I64[Sp + 8]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.323403007 UTC

[section ""data" . Foreign.Storable.$fStorableInt13_closure" {
     Foreign.Storable.$fStorableInt13_closure:
         const Foreign.Storable.$fStorableInt13_info;
 },
 Foreign.Storable.$fStorableInt13_entry() //  [R2, R3, R4]
         { info_tbl: [(c4IU3,
                       label: Foreign.Storable.$fStorableInt13_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IU3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4IUc; else goto c4IUd;
       c4IUc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt13_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4IUd: // global
           I64[Sp - 24] = block_c4IU0_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4IUn; else goto c4IU1;
       u4IUn: // global
           call _c4IU0(R1) args: 0, res: 0, upd: 0;
       c4IU1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IU0() //  [R1]
         { info_tbl: [(c4IU0,
                       label: block_c4IU0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IU0: // global
           I64[Sp] = block_c4IU6_info;
           _s4Ip1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Ip1::I64;
           if (R1 & 7 != 0) goto u4IUm; else goto c4IU7;
       u4IUm: // global
           call _c4IU6(R1) args: 0, res: 0, upd: 0;
       c4IU7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IU6() //  [R1]
         { info_tbl: [(c4IU6,
                       label: block_c4IU6_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IU6: // global
           I64[Sp] = block_c4IUb_info;
           _s4Ip3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Ip3::I64;
           if (R1 & 7 != 0) goto u4IUo; else goto c4IUg;
       u4IUo: // global
           call _c4IUb(R1) args: 0, res: 0, upd: 0;
       c4IUg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IUb() //  [R1]
         { info_tbl: [(c4IUb,
                       label: block_c4IUb_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IUb: // global
           I32[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.333518408 UTC

[section ""data" . Foreign.Storable.$fStorableInt32_closure" {
     Foreign.Storable.$fStorableInt32_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt32_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt32_$calignment_closure+1;
         const GHC.Storable.readInt32OffPtr1_closure+3;
         const GHC.Storable.writeInt32OffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt14_closure+3;
         const Foreign.Storable.$fStorableInt13_closure+4;
         const Foreign.Storable.$fStorableInt12_closure+2;
         const Foreign.Storable.$fStorableInt11_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.335706599 UTC

[section ""data" . Foreign.Storable.$fStorableBool_$csizeOf_closure" {
     Foreign.Storable.$fStorableBool_$csizeOf_closure:
         const Foreign.Storable.$fStorableBool_$csizeOf_info;
 },
 Foreign.Storable.$fStorableBool_$csizeOf_entry() //  []
         { info_tbl: [(c4IUT,
                       label: Foreign.Storable.$fStorableBool_$csizeOf_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IUT: // global
           R1 = Foreign.Storable.$fStorableBool7_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.339695582 UTC

[section ""data" . Foreign.Storable.$fStorableBool5_closure" {
     Foreign.Storable.$fStorableBool5_closure:
         const Foreign.Storable.$fStorableBool5_info;
 },
 Foreign.Storable.$fStorableBool5_entry() //  [R2, R3, R4]
         { info_tbl: [(c4IV8,
                       label: Foreign.Storable.$fStorableBool5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IV8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4IVc; else goto c4IVd;
       c4IVc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4IVd: // global
           I64[Sp - 24] = block_c4IV5_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4IVy; else goto c4IV6;
       u4IVy: // global
           call _c4IV5(R1) args: 0, res: 0, upd: 0;
       c4IV6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IV5() //  [R1]
         { info_tbl: [(c4IV5,
                       label: block_c4IV5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IV5: // global
           I64[Sp] = block_c4IVb_info;
           _s4Ipe::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Ipe::I64;
           if (R1 & 7 != 0) goto u4IVx; else goto c4IVf;
       u4IVx: // global
           call _c4IVb(R1) args: 0, res: 0, upd: 0;
       c4IVf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IVb() //  [R1]
         { info_tbl: [(c4IVb,
                       label: block_c4IVb_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IVb: // global
           I64[Sp] = block_c4IVj_info;
           _s4Ipg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Ipg::I64;
           if (R1 & 7 != 0) goto u4IVz; else goto c4IVl;
       u4IVz: // global
           call _c4IVj(R1) args: 0, res: 0, upd: 0;
       c4IVl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IVj() //  [R1]
         { info_tbl: [(c4IVj,
                       label: block_c4IVj_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IVj: // global
           _s4Ipe::I64 = I64[Sp + 8];
           _s4Ipg::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto c4IVr; else goto c4IVv;
       c4IVr: // global
           I32[_s4Ipe::I64 + (_s4Ipg::I64 << 2)] = 0 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4IVv: // global
           I32[_s4Ipe::I64 + (_s4Ipg::I64 << 2)] = 1 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.350025364 UTC

[section ""data" . Foreign.Storable.$fStorableInt6_closure" {
     Foreign.Storable.$fStorableInt6_closure:
         const Foreign.Storable.$fStorableInt6_info;
 },
 Foreign.Storable.$fStorableInt6_entry() //  [R2]
         { info_tbl: [(c4IW7,
                       label: Foreign.Storable.$fStorableInt6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IW7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4IWb; else goto c4IWc;
       c4IWb: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4IWc: // global
           I64[Sp - 8] = block_c4IW4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4IWg; else goto c4IW5;
       u4IWg: // global
           call _c4IW4(R1) args: 0, res: 0, upd: 0;
       c4IW5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IW4() //  [R1]
         { info_tbl: [(c4IW4,
                       label: block_c4IW4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IW4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4IWf; else goto c4IWe;
       c4IWf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4IWe: // global
           _s4Ipq::I64 = %MO_SS_Conv_W16_W64(I16[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4Ipq::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.356555085 UTC

[section ""data" . Foreign.Storable.$fStorableInt9_closure" {
     Foreign.Storable.$fStorableInt9_closure:
         const Foreign.Storable.$fStorableInt9_info;
 },
 Foreign.Storable.$fStorableInt9_entry() //  [R2, R3]
         { info_tbl: [(c4IWB,
                       label: Foreign.Storable.$fStorableInt9_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IWB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4IWN; else goto c4IWO;
       c4IWN: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt9_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4IWO: // global
           I64[Sp - 16] = block_c4IWy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4IWU; else goto c4IWz;
       u4IWU: // global
           call _c4IWy(R1) args: 0, res: 0, upd: 0;
       c4IWz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IWy() //  [R1]
         { info_tbl: [(c4IWy,
                       label: block_c4IWy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IWy: // global
           I64[Sp] = block_c4IWE_info;
           _s4Ipw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Ipw::I64;
           if (R1 & 7 != 0) goto u4IWT; else goto c4IWF;
       u4IWT: // global
           call _c4IWE(R1) args: 0, res: 0, upd: 0;
       c4IWF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IWE() //  [R1]
         { info_tbl: [(c4IWE,
                       label: block_c4IWE_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IWE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4IWS; else goto c4IWR;
       c4IWS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4IWR: // global
           _s4IpC::I64 = %MO_SS_Conv_W16_W64(I16[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I16#_con_info;
           I64[Hp] = _s4IpC::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.369835337 UTC

[section ""data" . Foreign.Storable.$fStorableInt5_closure" {
     Foreign.Storable.$fStorableInt5_closure:
         const Foreign.Storable.$fStorableInt5_info;
 },
 Foreign.Storable.$fStorableInt5_entry() //  [R2, R3]
         { info_tbl: [(c4IXl,
                       label: Foreign.Storable.$fStorableInt5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IXl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4IXp; else goto c4IXq;
       c4IXp: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4IXq: // global
           I64[Sp - 16] = block_c4IXi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4IXy; else goto c4IXj;
       u4IXy: // global
           call _c4IXi(R1) args: 0, res: 0, upd: 0;
       c4IXj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IXi() //  [R1]
         { info_tbl: [(c4IXi,
                       label: block_c4IXi_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IXi: // global
           I64[Sp] = block_c4IXo_info;
           _s4IpI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IpI::I64;
           if (R1 & 7 != 0) goto u4IXx; else goto c4IXs;
       u4IXx: // global
           call _c4IXo(R1) args: 0, res: 0, upd: 0;
       c4IXs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IXo() //  [R1]
         { info_tbl: [(c4IXo,
                       label: block_c4IXo_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IXo: // global
           I16[I64[Sp + 8]] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.381840989 UTC

[section ""data" . Foreign.Storable.$fStorableInt7_closure" {
     Foreign.Storable.$fStorableInt7_closure:
         const Foreign.Storable.$fStorableInt7_info;
 },
 Foreign.Storable.$fStorableInt7_entry() //  [R2, R3, R4]
         { info_tbl: [(c4IXZ,
                       label: Foreign.Storable.$fStorableInt7_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IXZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4IY8; else goto c4IY9;
       c4IY8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt7_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4IY9: // global
           I64[Sp - 24] = block_c4IXW_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4IYj; else goto c4IXX;
       u4IYj: // global
           call _c4IXW(R1) args: 0, res: 0, upd: 0;
       c4IXX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IXW() //  [R1]
         { info_tbl: [(c4IXW,
                       label: block_c4IXW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IXW: // global
           I64[Sp] = block_c4IY2_info;
           _s4IpR::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IpR::I64;
           if (R1 & 7 != 0) goto u4IYi; else goto c4IY3;
       u4IYi: // global
           call _c4IY2(R1) args: 0, res: 0, upd: 0;
       c4IY3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IY2() //  [R1]
         { info_tbl: [(c4IY2,
                       label: block_c4IY2_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IY2: // global
           I64[Sp] = block_c4IY7_info;
           _s4IpT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4IpT::I64;
           if (R1 & 7 != 0) goto u4IYk; else goto c4IYc;
       u4IYk: // global
           call _c4IY7(R1) args: 0, res: 0, upd: 0;
       c4IYc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IY7() //  [R1]
         { info_tbl: [(c4IY7,
                       label: block_c4IY7_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IY7: // global
           I16[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.391288321 UTC

[section ""data" . Foreign.Storable.$fStorableInt16_closure" {
     Foreign.Storable.$fStorableInt16_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt16_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt16_$calignment_closure+1;
         const GHC.Storable.readInt16OffPtr1_closure+3;
         const GHC.Storable.writeInt16OffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt9_closure+3;
         const Foreign.Storable.$fStorableInt7_closure+4;
         const Foreign.Storable.$fStorableInt6_closure+2;
         const Foreign.Storable.$fStorableInt5_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.394618885 UTC

[section ""data" . Foreign.Storable.$fStorableInt21_closure" {
     Foreign.Storable.$fStorableInt21_closure:
         const Foreign.Storable.$fStorableInt21_info;
 },
 Foreign.Storable.$fStorableInt21_entry() //  [R2]
         { info_tbl: [(c4IYS,
                       label: Foreign.Storable.$fStorableInt21_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IYS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4IYW; else goto c4IYX;
       c4IYW: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt21_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4IYX: // global
           I64[Sp - 8] = block_c4IYP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4IZ1; else goto c4IYQ;
       u4IZ1: // global
           call _c4IYP(R1) args: 0, res: 0, upd: 0;
       c4IYQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IYP() //  [R1]
         { info_tbl: [(c4IYP,
                       label: block_c4IYP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IYP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4IZ0; else goto c4IYZ;
       c4IZ0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4IYZ: // global
           _s4Iq4::I64 = %MO_SS_Conv_W8_W64(I8[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4Iq4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.404560227 UTC

[section ""data" . Foreign.Storable.$fStorableInt23_closure" {
     Foreign.Storable.$fStorableInt23_closure:
         const Foreign.Storable.$fStorableInt23_info;
 },
 Foreign.Storable.$fStorableInt23_entry() //  [R2, R3]
         { info_tbl: [(c4IZm,
                       label: Foreign.Storable.$fStorableInt23_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IZm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4IZy; else goto c4IZz;
       c4IZy: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt23_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4IZz: // global
           I64[Sp - 16] = block_c4IZj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4IZF; else goto c4IZk;
       u4IZF: // global
           call _c4IZj(R1) args: 0, res: 0, upd: 0;
       c4IZk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IZj() //  [R1]
         { info_tbl: [(c4IZj,
                       label: block_c4IZj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IZj: // global
           I64[Sp] = block_c4IZp_info;
           _s4Iqa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Iqa::I64;
           if (R1 & 7 != 0) goto u4IZE; else goto c4IZq;
       u4IZE: // global
           call _c4IZp(R1) args: 0, res: 0, upd: 0;
       c4IZq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4IZp() //  [R1]
         { info_tbl: [(c4IZp,
                       label: block_c4IZp_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4IZp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4IZD; else goto c4IZC;
       c4IZD: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4IZC: // global
           _s4Iqg::I64 = %MO_SS_Conv_W8_W64(I8[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s4Iqg::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.415741483 UTC

[section ""data" . Foreign.Storable.$fStorableInt20_closure" {
     Foreign.Storable.$fStorableInt20_closure:
         const Foreign.Storable.$fStorableInt20_info;
 },
 Foreign.Storable.$fStorableInt20_entry() //  [R2, R3]
         { info_tbl: [(c4J06,
                       label: Foreign.Storable.$fStorableInt20_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J06: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4J0a; else goto c4J0b;
       c4J0a: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt20_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4J0b: // global
           I64[Sp - 16] = block_c4J03_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4J0j; else goto c4J04;
       u4J0j: // global
           call _c4J03(R1) args: 0, res: 0, upd: 0;
       c4J04: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J03() //  [R1]
         { info_tbl: [(c4J03,
                       label: block_c4J03_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J03: // global
           I64[Sp] = block_c4J09_info;
           _s4Iqm::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Iqm::I64;
           if (R1 & 7 != 0) goto u4J0i; else goto c4J0d;
       u4J0i: // global
           call _c4J09(R1) args: 0, res: 0, upd: 0;
       c4J0d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J09() //  [R1]
         { info_tbl: [(c4J09,
                       label: block_c4J09_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J09: // global
           I8[I64[Sp + 8]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.424875807 UTC

[section ""data" . Foreign.Storable.$fStorableInt22_closure" {
     Foreign.Storable.$fStorableInt22_closure:
         const Foreign.Storable.$fStorableInt22_info;
 },
 Foreign.Storable.$fStorableInt22_entry() //  [R2, R3, R4]
         { info_tbl: [(c4J0K,
                       label: Foreign.Storable.$fStorableInt22_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J0K: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4J0T; else goto c4J0U;
       c4J0T: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt22_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4J0U: // global
           I64[Sp - 24] = block_c4J0H_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4J14; else goto c4J0I;
       u4J14: // global
           call _c4J0H(R1) args: 0, res: 0, upd: 0;
       c4J0I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J0H() //  [R1]
         { info_tbl: [(c4J0H,
                       label: block_c4J0H_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J0H: // global
           I64[Sp] = block_c4J0N_info;
           _s4Iqv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Iqv::I64;
           if (R1 & 7 != 0) goto u4J13; else goto c4J0O;
       u4J13: // global
           call _c4J0N(R1) args: 0, res: 0, upd: 0;
       c4J0O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J0N() //  [R1]
         { info_tbl: [(c4J0N,
                       label: block_c4J0N_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J0N: // global
           I64[Sp] = block_c4J0S_info;
           _s4Iqx::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Iqx::I64;
           if (R1 & 7 != 0) goto u4J15; else goto c4J0X;
       u4J15: // global
           call _c4J0S(R1) args: 0, res: 0, upd: 0;
       c4J0X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J0S() //  [R1]
         { info_tbl: [(c4J0S,
                       label: block_c4J0S_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J0S: // global
           I8[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.434543269 UTC

[section ""data" . Foreign.Storable.$fStorableInt8_closure" {
     Foreign.Storable.$fStorableInt8_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt8_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt8_$calignment_closure+1;
         const GHC.Storable.readInt8OffPtr1_closure+3;
         const GHC.Storable.writeInt8OffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt23_closure+3;
         const Foreign.Storable.$fStorableInt22_closure+4;
         const Foreign.Storable.$fStorableInt21_closure+2;
         const Foreign.Storable.$fStorableInt20_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.436898698 UTC

[section ""data" . Foreign.Storable.$fStorableWord15_closure" {
     Foreign.Storable.$fStorableWord15_closure:
         const Foreign.Storable.$fStorableWord15_info;
 },
 Foreign.Storable.$fStorableWord15_entry() //  [R2]
         { info_tbl: [(c4J1D,
                       label: Foreign.Storable.$fStorableWord15_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J1D: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4J1H; else goto c4J1I;
       c4J1H: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord15_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4J1I: // global
           I64[Sp - 8] = block_c4J1A_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4J1M; else goto c4J1B;
       u4J1M: // global
           call _c4J1A(R1) args: 0, res: 0, upd: 0;
       c4J1B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J1A() //  [R1]
         { info_tbl: [(c4J1A,
                       label: block_c4J1A_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J1A: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4J1L; else goto c4J1K;
       c4J1L: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4J1K: // global
           _s4IqI::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4IqI::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.443409944 UTC

[section ""data" . Foreign.Storable.$fStorableWord18_closure" {
     Foreign.Storable.$fStorableWord18_closure:
         const Foreign.Storable.$fStorableWord18_info;
 },
 Foreign.Storable.$fStorableWord18_entry() //  [R2, R3]
         { info_tbl: [(c4J27,
                       label: Foreign.Storable.$fStorableWord18_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J27: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4J2j; else goto c4J2k;
       c4J2j: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord18_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4J2k: // global
           I64[Sp - 16] = block_c4J24_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4J2q; else goto c4J25;
       u4J2q: // global
           call _c4J24(R1) args: 0, res: 0, upd: 0;
       c4J25: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J24() //  [R1]
         { info_tbl: [(c4J24,
                       label: block_c4J24_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J24: // global
           I64[Sp] = block_c4J2a_info;
           _s4IqO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IqO::I64;
           if (R1 & 7 != 0) goto u4J2p; else goto c4J2b;
       u4J2p: // global
           call _c4J2a(R1) args: 0, res: 0, upd: 0;
       c4J2b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J2a() //  [R1]
         { info_tbl: [(c4J2a,
                       label: block_c4J2a_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J2a: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4J2o; else goto c4J2n;
       c4J2o: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4J2n: // global
           _s4IqU::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4IqU::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.45252367 UTC

[section ""data" . Foreign.Storable.$fStorableWord14_closure" {
     Foreign.Storable.$fStorableWord14_closure:
         const Foreign.Storable.$fStorableWord14_info;
 },
 Foreign.Storable.$fStorableWord14_entry() //  [R2, R3]
         { info_tbl: [(c4J2R,
                       label: Foreign.Storable.$fStorableWord14_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J2R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4J2V; else goto c4J2W;
       c4J2V: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord14_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4J2W: // global
           I64[Sp - 16] = block_c4J2O_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4J34; else goto c4J2P;
       u4J34: // global
           call _c4J2O(R1) args: 0, res: 0, upd: 0;
       c4J2P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J2O() //  [R1]
         { info_tbl: [(c4J2O,
                       label: block_c4J2O_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J2O: // global
           I64[Sp] = block_c4J2U_info;
           _s4Ir0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Ir0::I64;
           if (R1 & 7 != 0) goto u4J33; else goto c4J2Y;
       u4J33: // global
           call _c4J2U(R1) args: 0, res: 0, upd: 0;
       c4J2Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J2U() //  [R1]
         { info_tbl: [(c4J2U,
                       label: block_c4J2U_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J2U: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.460589402 UTC

[section ""data" . Foreign.Storable.$fStorableWord17_closure" {
     Foreign.Storable.$fStorableWord17_closure:
         const Foreign.Storable.$fStorableWord17_info;
 },
 Foreign.Storable.$fStorableWord17_entry() //  [R2, R3, R4]
         { info_tbl: [(c4J3v,
                       label: Foreign.Storable.$fStorableWord17_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J3v: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4J3E; else goto c4J3F;
       c4J3E: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord17_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4J3F: // global
           I64[Sp - 24] = block_c4J3s_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4J3P; else goto c4J3t;
       u4J3P: // global
           call _c4J3s(R1) args: 0, res: 0, upd: 0;
       c4J3t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J3s() //  [R1]
         { info_tbl: [(c4J3s,
                       label: block_c4J3s_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J3s: // global
           I64[Sp] = block_c4J3y_info;
           _s4Ir9::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Ir9::I64;
           if (R1 & 7 != 0) goto u4J3O; else goto c4J3z;
       u4J3O: // global
           call _c4J3y(R1) args: 0, res: 0, upd: 0;
       c4J3z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J3y() //  [R1]
         { info_tbl: [(c4J3y,
                       label: block_c4J3y_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J3y: // global
           I64[Sp] = block_c4J3D_info;
           _s4Irb::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Irb::I64;
           if (R1 & 7 != 0) goto u4J3Q; else goto c4J3I;
       u4J3Q: // global
           call _c4J3D(R1) args: 0, res: 0, upd: 0;
       c4J3I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J3D() //  [R1]
         { info_tbl: [(c4J3D,
                       label: block_c4J3D_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J3D: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.471656143 UTC

[section ""data" . Foreign.Storable.$fStorableWord64_closure" {
     Foreign.Storable.$fStorableWord64_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableWord64_$calignment_closure+1;
         const Foreign.Storable.$fStorableWord64_$calignment_closure+1;
         const GHC.Storable.readWord64OffPtr1_closure+3;
         const GHC.Storable.writeWord64OffPtr1_closure+4;
         const Foreign.Storable.$fStorableWord18_closure+3;
         const Foreign.Storable.$fStorableWord17_closure+4;
         const Foreign.Storable.$fStorableWord15_closure+2;
         const Foreign.Storable.$fStorableWord14_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.474407583 UTC

[section ""data" . Foreign.Storable.$fStorableWord11_closure" {
     Foreign.Storable.$fStorableWord11_closure:
         const Foreign.Storable.$fStorableWord11_info;
 },
 Foreign.Storable.$fStorableWord11_entry() //  [R2]
         { info_tbl: [(c4J4o,
                       label: Foreign.Storable.$fStorableWord11_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J4o: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4J4s; else goto c4J4t;
       c4J4s: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord11_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4J4t: // global
           I64[Sp - 8] = block_c4J4l_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4J4x; else goto c4J4m;
       u4J4x: // global
           call _c4J4l(R1) args: 0, res: 0, upd: 0;
       c4J4m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J4l() //  [R1]
         { info_tbl: [(c4J4l,
                       label: block_c4J4l_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J4l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4J4w; else goto c4J4v;
       c4J4w: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4J4v: // global
           _s4Irm::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s4Irm::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.48109578 UTC

[section ""data" . Foreign.Storable.$fStorableWord13_closure" {
     Foreign.Storable.$fStorableWord13_closure:
         const Foreign.Storable.$fStorableWord13_info;
 },
 Foreign.Storable.$fStorableWord13_entry() //  [R2, R3]
         { info_tbl: [(c4J4S,
                       label: Foreign.Storable.$fStorableWord13_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J4S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4J54; else goto c4J55;
       c4J54: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord13_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4J55: // global
           I64[Sp - 16] = block_c4J4P_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4J5b; else goto c4J4Q;
       u4J5b: // global
           call _c4J4P(R1) args: 0, res: 0, upd: 0;
       c4J4Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J4P() //  [R1]
         { info_tbl: [(c4J4P,
                       label: block_c4J4P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J4P: // global
           I64[Sp] = block_c4J4V_info;
           _s4Irs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Irs::I64;
           if (R1 & 7 != 0) goto u4J5a; else goto c4J4W;
       u4J5a: // global
           call _c4J4V(R1) args: 0, res: 0, upd: 0;
       c4J4W: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J4V() //  [R1]
         { info_tbl: [(c4J4V,
                       label: block_c4J4V_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J4V: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4J59; else goto c4J58;
       c4J59: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4J58: // global
           _s4Iry::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _s4Iry::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.49002398 UTC

[section ""data" . Foreign.Storable.$fStorableWord10_closure" {
     Foreign.Storable.$fStorableWord10_closure:
         const Foreign.Storable.$fStorableWord10_info;
 },
 Foreign.Storable.$fStorableWord10_entry() //  [R2, R3]
         { info_tbl: [(c4J5C,
                       label: Foreign.Storable.$fStorableWord10_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J5C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4J5G; else goto c4J5H;
       c4J5G: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord10_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4J5H: // global
           I64[Sp - 16] = block_c4J5z_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4J5P; else goto c4J5A;
       u4J5P: // global
           call _c4J5z(R1) args: 0, res: 0, upd: 0;
       c4J5A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J5z() //  [R1]
         { info_tbl: [(c4J5z,
                       label: block_c4J5z_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J5z: // global
           I64[Sp] = block_c4J5F_info;
           _s4IrE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IrE::I64;
           if (R1 & 7 != 0) goto u4J5O; else goto c4J5J;
       u4J5O: // global
           call _c4J5F(R1) args: 0, res: 0, upd: 0;
       c4J5J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J5F() //  [R1]
         { info_tbl: [(c4J5F,
                       label: block_c4J5F_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J5F: // global
           I32[I64[Sp + 8]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.497753082 UTC

[section ""data" . Foreign.Storable.$fStorableWord12_closure" {
     Foreign.Storable.$fStorableWord12_closure:
         const Foreign.Storable.$fStorableWord12_info;
 },
 Foreign.Storable.$fStorableWord12_entry() //  [R2, R3, R4]
         { info_tbl: [(c4J6g,
                       label: Foreign.Storable.$fStorableWord12_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J6g: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4J6p; else goto c4J6q;
       c4J6p: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord12_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4J6q: // global
           I64[Sp - 24] = block_c4J6d_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4J6A; else goto c4J6e;
       u4J6A: // global
           call _c4J6d(R1) args: 0, res: 0, upd: 0;
       c4J6e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J6d() //  [R1]
         { info_tbl: [(c4J6d,
                       label: block_c4J6d_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J6d: // global
           I64[Sp] = block_c4J6j_info;
           _s4IrN::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IrN::I64;
           if (R1 & 7 != 0) goto u4J6z; else goto c4J6k;
       u4J6z: // global
           call _c4J6j(R1) args: 0, res: 0, upd: 0;
       c4J6k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J6j() //  [R1]
         { info_tbl: [(c4J6j,
                       label: block_c4J6j_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J6j: // global
           I64[Sp] = block_c4J6o_info;
           _s4IrP::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4IrP::I64;
           if (R1 & 7 != 0) goto u4J6B; else goto c4J6t;
       u4J6B: // global
           call _c4J6o(R1) args: 0, res: 0, upd: 0;
       c4J6t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J6o() //  [R1]
         { info_tbl: [(c4J6o,
                       label: block_c4J6o_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J6o: // global
           I32[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.512863339 UTC

[section ""data" . Foreign.Storable.$fStorableWord32_closure" {
     Foreign.Storable.$fStorableWord32_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableWord32_$calignment_closure+1;
         const Foreign.Storable.$fStorableWord32_$calignment_closure+1;
         const GHC.Storable.readWord32OffPtr1_closure+3;
         const GHC.Storable.writeWord32OffPtr1_closure+4;
         const Foreign.Storable.$fStorableWord13_closure+3;
         const Foreign.Storable.$fStorableWord12_closure+4;
         const Foreign.Storable.$fStorableWord11_closure+2;
         const Foreign.Storable.$fStorableWord10_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.516639068 UTC

[section ""data" . Foreign.Storable.$fStorableWord6_closure" {
     Foreign.Storable.$fStorableWord6_closure:
         const Foreign.Storable.$fStorableWord6_info;
 },
 Foreign.Storable.$fStorableWord6_entry() //  [R2]
         { info_tbl: [(c4J79,
                       label: Foreign.Storable.$fStorableWord6_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J79: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4J7d; else goto c4J7e;
       c4J7d: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord6_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4J7e: // global
           I64[Sp - 8] = block_c4J76_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4J7i; else goto c4J77;
       u4J7i: // global
           call _c4J76(R1) args: 0, res: 0, upd: 0;
       c4J77: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J76() //  [R1]
         { info_tbl: [(c4J76,
                       label: block_c4J76_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J76: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4J7h; else goto c4J7g;
       c4J7h: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4J7g: // global
           _s4Is0::I64 = %MO_UU_Conv_W16_W64(I16[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s4Is0::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.524901088 UTC

[section ""data" . Foreign.Storable.$fStorableWord9_closure" {
     Foreign.Storable.$fStorableWord9_closure:
         const Foreign.Storable.$fStorableWord9_info;
 },
 Foreign.Storable.$fStorableWord9_entry() //  [R2, R3]
         { info_tbl: [(c4J7D,
                       label: Foreign.Storable.$fStorableWord9_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J7D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4J7P; else goto c4J7Q;
       c4J7P: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord9_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4J7Q: // global
           I64[Sp - 16] = block_c4J7A_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4J7W; else goto c4J7B;
       u4J7W: // global
           call _c4J7A(R1) args: 0, res: 0, upd: 0;
       c4J7B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J7A() //  [R1]
         { info_tbl: [(c4J7A,
                       label: block_c4J7A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J7A: // global
           I64[Sp] = block_c4J7G_info;
           _s4Is6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Is6::I64;
           if (R1 & 7 != 0) goto u4J7V; else goto c4J7H;
       u4J7V: // global
           call _c4J7G(R1) args: 0, res: 0, upd: 0;
       c4J7H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J7G() //  [R1]
         { info_tbl: [(c4J7G,
                       label: block_c4J7G_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J7G: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4J7U; else goto c4J7T;
       c4J7U: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4J7T: // global
           _s4Isc::I64 = %MO_UU_Conv_W16_W64(I16[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W16#_con_info;
           I64[Hp] = _s4Isc::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.533460757 UTC

[section ""data" . Foreign.Storable.$fStorableWord5_closure" {
     Foreign.Storable.$fStorableWord5_closure:
         const Foreign.Storable.$fStorableWord5_info;
 },
 Foreign.Storable.$fStorableWord5_entry() //  [R2, R3]
         { info_tbl: [(c4J8n,
                       label: Foreign.Storable.$fStorableWord5_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J8n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4J8r; else goto c4J8s;
       c4J8r: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4J8s: // global
           I64[Sp - 16] = block_c4J8k_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4J8A; else goto c4J8l;
       u4J8A: // global
           call _c4J8k(R1) args: 0, res: 0, upd: 0;
       c4J8l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J8k() //  [R1]
         { info_tbl: [(c4J8k,
                       label: block_c4J8k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J8k: // global
           I64[Sp] = block_c4J8q_info;
           _s4Isi::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Isi::I64;
           if (R1 & 7 != 0) goto u4J8z; else goto c4J8u;
       u4J8z: // global
           call _c4J8q(R1) args: 0, res: 0, upd: 0;
       c4J8u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J8q() //  [R1]
         { info_tbl: [(c4J8q,
                       label: block_c4J8q_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J8q: // global
           I16[I64[Sp + 8]] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.541520374 UTC

[section ""data" . Foreign.Storable.$fStorableWord7_closure" {
     Foreign.Storable.$fStorableWord7_closure:
         const Foreign.Storable.$fStorableWord7_info;
 },
 Foreign.Storable.$fStorableWord7_entry() //  [R2, R3, R4]
         { info_tbl: [(c4J91,
                       label: Foreign.Storable.$fStorableWord7_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J91: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4J9a; else goto c4J9b;
       c4J9a: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord7_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4J9b: // global
           I64[Sp - 24] = block_c4J8Y_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4J9l; else goto c4J8Z;
       u4J9l: // global
           call _c4J8Y(R1) args: 0, res: 0, upd: 0;
       c4J8Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J8Y() //  [R1]
         { info_tbl: [(c4J8Y,
                       label: block_c4J8Y_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J8Y: // global
           I64[Sp] = block_c4J94_info;
           _s4Isr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Isr::I64;
           if (R1 & 7 != 0) goto u4J9k; else goto c4J95;
       u4J9k: // global
           call _c4J94(R1) args: 0, res: 0, upd: 0;
       c4J95: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J94() //  [R1]
         { info_tbl: [(c4J94,
                       label: block_c4J94_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J94: // global
           I64[Sp] = block_c4J99_info;
           _s4Ist::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Ist::I64;
           if (R1 & 7 != 0) goto u4J9m; else goto c4J9e;
       u4J9m: // global
           call _c4J99(R1) args: 0, res: 0, upd: 0;
       c4J9e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J99() //  [R1]
         { info_tbl: [(c4J99,
                       label: block_c4J99_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J99: // global
           I16[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W16(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.551802238 UTC

[section ""data" . Foreign.Storable.$fStorableWord16_closure" {
     Foreign.Storable.$fStorableWord16_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableWord16_$calignment_closure+1;
         const Foreign.Storable.$fStorableWord16_$calignment_closure+1;
         const GHC.Storable.readWord16OffPtr1_closure+3;
         const GHC.Storable.writeWord16OffPtr1_closure+4;
         const Foreign.Storable.$fStorableWord9_closure+3;
         const Foreign.Storable.$fStorableWord7_closure+4;
         const Foreign.Storable.$fStorableWord6_closure+2;
         const Foreign.Storable.$fStorableWord5_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.554212364 UTC

[section ""data" . Foreign.Storable.$fStorableDouble2_closure" {
     Foreign.Storable.$fStorableDouble2_closure:
         const Foreign.Storable.$fStorableDouble2_info;
 },
 Foreign.Storable.$fStorableDouble2_entry() //  [R2]
         { info_tbl: [(c4J9U,
                       label: Foreign.Storable.$fStorableDouble2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J9U: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4J9Y; else goto c4J9Z;
       c4J9Y: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableDouble2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4J9Z: // global
           I64[Sp - 8] = block_c4J9R_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Ja3; else goto c4J9S;
       u4Ja3: // global
           call _c4J9R(R1) args: 0, res: 0, upd: 0;
       c4J9S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4J9R() //  [R1]
         { info_tbl: [(c4J9R,
                       label: block_c4J9R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4J9R: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Ja2; else goto c4Ja1;
       c4Ja2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Ja1: // global
           _s4IsE::F64 = F64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _s4IsE::F64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.560631422 UTC

[section ""data" . Foreign.Storable.$fStorableDouble4_closure" {
     Foreign.Storable.$fStorableDouble4_closure:
         const Foreign.Storable.$fStorableDouble4_info;
 },
 Foreign.Storable.$fStorableDouble4_entry() //  [R2, R3]
         { info_tbl: [(c4Jao,
                       label: Foreign.Storable.$fStorableDouble4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jao: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JaA; else goto c4JaB;
       c4JaA: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableDouble4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JaB: // global
           I64[Sp - 16] = block_c4Jal_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4JaH; else goto c4Jam;
       u4JaH: // global
           call _c4Jal(R1) args: 0, res: 0, upd: 0;
       c4Jam: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jal() //  [R1]
         { info_tbl: [(c4Jal,
                       label: block_c4Jal_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jal: // global
           I64[Sp] = block_c4Jar_info;
           _s4IsK::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IsK::I64;
           if (R1 & 7 != 0) goto u4JaG; else goto c4Jas;
       u4JaG: // global
           call _c4Jar(R1) args: 0, res: 0, upd: 0;
       c4Jas: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jar() //  [R1]
         { info_tbl: [(c4Jar,
                       label: block_c4Jar_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jar: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JaF; else goto c4JaE;
       c4JaF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4JaE: // global
           _s4IsQ::F64 = F64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _s4IsQ::F64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.569210666 UTC

[section ""data" . Foreign.Storable.$fStorableDouble1_closure" {
     Foreign.Storable.$fStorableDouble1_closure:
         const Foreign.Storable.$fStorableDouble1_info;
 },
 Foreign.Storable.$fStorableDouble1_entry() //  [R2, R3]
         { info_tbl: [(c4Jb8,
                       label: Foreign.Storable.$fStorableDouble1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jb8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Jbc; else goto c4Jbd;
       c4Jbc: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableDouble1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Jbd: // global
           I64[Sp - 16] = block_c4Jb5_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Jbl; else goto c4Jb6;
       u4Jbl: // global
           call _c4Jb5(R1) args: 0, res: 0, upd: 0;
       c4Jb6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jb5() //  [R1]
         { info_tbl: [(c4Jb5,
                       label: block_c4Jb5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jb5: // global
           I64[Sp] = block_c4Jbb_info;
           _s4IsW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IsW::I64;
           if (R1 & 7 != 0) goto u4Jbk; else goto c4Jbf;
       u4Jbk: // global
           call _c4Jbb(R1) args: 0, res: 0, upd: 0;
       c4Jbf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jbb() //  [R1]
         { info_tbl: [(c4Jbb,
                       label: block_c4Jbb_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jbb: // global
           F64[I64[Sp + 8]] = F64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.577149747 UTC

[section ""data" . Foreign.Storable.$fStorableDouble3_closure" {
     Foreign.Storable.$fStorableDouble3_closure:
         const Foreign.Storable.$fStorableDouble3_info;
 },
 Foreign.Storable.$fStorableDouble3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4JbM,
                       label: Foreign.Storable.$fStorableDouble3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JbM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4JbV; else goto c4JbW;
       c4JbV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableDouble3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JbW: // global
           I64[Sp - 24] = block_c4JbJ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Jc6; else goto c4JbK;
       u4Jc6: // global
           call _c4JbJ(R1) args: 0, res: 0, upd: 0;
       c4JbK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JbJ() //  [R1]
         { info_tbl: [(c4JbJ,
                       label: block_c4JbJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JbJ: // global
           I64[Sp] = block_c4JbP_info;
           _s4It5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4It5::I64;
           if (R1 & 7 != 0) goto u4Jc5; else goto c4JbQ;
       u4Jc5: // global
           call _c4JbP(R1) args: 0, res: 0, upd: 0;
       c4JbQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JbP() //  [R1]
         { info_tbl: [(c4JbP,
                       label: block_c4JbP_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JbP: // global
           I64[Sp] = block_c4JbU_info;
           _s4It7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4It7::I64;
           if (R1 & 7 != 0) goto u4Jc7; else goto c4JbZ;
       u4Jc7: // global
           call _c4JbU(R1) args: 0, res: 0, upd: 0;
       c4JbZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JbU() //  [R1]
         { info_tbl: [(c4JbU,
                       label: block_c4JbU_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JbU: // global
           F64[I64[Sp + 8] + I64[Sp + 16]] = F64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.587068299 UTC

[section ""data" . Foreign.Storable.$fStorableDouble_closure" {
     Foreign.Storable.$fStorableDouble_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableDouble_$calignment_closure+1;
         const Foreign.Storable.$fStorableDouble_$calignment_closure+1;
         const GHC.Storable.readDoubleOffPtr1_closure+3;
         const GHC.Storable.writeDoubleOffPtr1_closure+4;
         const Foreign.Storable.$fStorableDouble4_closure+3;
         const Foreign.Storable.$fStorableDouble3_closure+4;
         const Foreign.Storable.$fStorableDouble2_closure+2;
         const Foreign.Storable.$fStorableDouble1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.590120688 UTC

[section ""data" . Foreign.Storable.$fStorableFloat2_closure" {
     Foreign.Storable.$fStorableFloat2_closure:
         const Foreign.Storable.$fStorableFloat2_info;
 },
 Foreign.Storable.$fStorableFloat2_entry() //  [R2]
         { info_tbl: [(c4JcF,
                       label: Foreign.Storable.$fStorableFloat2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JcF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4JcJ; else goto c4JcK;
       c4JcJ: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFloat2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4JcK: // global
           I64[Sp - 8] = block_c4JcC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4JcO; else goto c4JcD;
       u4JcO: // global
           call _c4JcC(R1) args: 0, res: 0, upd: 0;
       c4JcD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JcC() //  [R1]
         { info_tbl: [(c4JcC,
                       label: block_c4JcC_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JcC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JcN; else goto c4JcM;
       c4JcN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4JcM: // global
           _s4Iti::F32 = F32[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _s4Iti::F32;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.596459077 UTC

[section ""data" . Foreign.Storable.$fStorableFloat4_closure" {
     Foreign.Storable.$fStorableFloat4_closure:
         const Foreign.Storable.$fStorableFloat4_info;
 },
 Foreign.Storable.$fStorableFloat4_entry() //  [R2, R3]
         { info_tbl: [(c4Jd9,
                       label: Foreign.Storable.$fStorableFloat4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jd9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Jdl; else goto c4Jdm;
       c4Jdl: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFloat4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Jdm: // global
           I64[Sp - 16] = block_c4Jd6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Jds; else goto c4Jd7;
       u4Jds: // global
           call _c4Jd6(R1) args: 0, res: 0, upd: 0;
       c4Jd7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jd6() //  [R1]
         { info_tbl: [(c4Jd6,
                       label: block_c4Jd6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jd6: // global
           I64[Sp] = block_c4Jdc_info;
           _s4Ito::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Ito::I64;
           if (R1 & 7 != 0) goto u4Jdr; else goto c4Jdd;
       u4Jdr: // global
           call _c4Jdc(R1) args: 0, res: 0, upd: 0;
       c4Jdd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jdc() //  [R1]
         { info_tbl: [(c4Jdc,
                       label: block_c4Jdc_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jdc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Jdq; else goto c4Jdp;
       c4Jdq: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Jdp: // global
           _s4Itu::F32 = F32[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _s4Itu::F32;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.605040349 UTC

[section ""data" . Foreign.Storable.$fStorableFloat1_closure" {
     Foreign.Storable.$fStorableFloat1_closure:
         const Foreign.Storable.$fStorableFloat1_info;
 },
 Foreign.Storable.$fStorableFloat1_entry() //  [R2, R3]
         { info_tbl: [(c4JdT,
                       label: Foreign.Storable.$fStorableFloat1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JdT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JdX; else goto c4JdY;
       c4JdX: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFloat1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JdY: // global
           I64[Sp - 16] = block_c4JdQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Je6; else goto c4JdR;
       u4Je6: // global
           call _c4JdQ(R1) args: 0, res: 0, upd: 0;
       c4JdR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JdQ() //  [R1]
         { info_tbl: [(c4JdQ,
                       label: block_c4JdQ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JdQ: // global
           I64[Sp] = block_c4JdW_info;
           _s4ItA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ItA::I64;
           if (R1 & 7 != 0) goto u4Je5; else goto c4Je0;
       u4Je5: // global
           call _c4JdW(R1) args: 0, res: 0, upd: 0;
       c4Je0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JdW() //  [R1]
         { info_tbl: [(c4JdW,
                       label: block_c4JdW_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JdW: // global
           F32[I64[Sp + 8]] = F32[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.613025274 UTC

[section ""data" . Foreign.Storable.$fStorableFloat3_closure" {
     Foreign.Storable.$fStorableFloat3_closure:
         const Foreign.Storable.$fStorableFloat3_info;
 },
 Foreign.Storable.$fStorableFloat3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Jex,
                       label: Foreign.Storable.$fStorableFloat3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jex: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4JeG; else goto c4JeH;
       c4JeG: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFloat3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JeH: // global
           I64[Sp - 24] = block_c4Jeu_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4JeR; else goto c4Jev;
       u4JeR: // global
           call _c4Jeu(R1) args: 0, res: 0, upd: 0;
       c4Jev: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jeu() //  [R1]
         { info_tbl: [(c4Jeu,
                       label: block_c4Jeu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jeu: // global
           I64[Sp] = block_c4JeA_info;
           _s4ItJ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ItJ::I64;
           if (R1 & 7 != 0) goto u4JeQ; else goto c4JeB;
       u4JeQ: // global
           call _c4JeA(R1) args: 0, res: 0, upd: 0;
       c4JeB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JeA() //  [R1]
         { info_tbl: [(c4JeA,
                       label: block_c4JeA_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JeA: // global
           I64[Sp] = block_c4JeF_info;
           _s4ItL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4ItL::I64;
           if (R1 & 7 != 0) goto u4JeS; else goto c4JeK;
       u4JeS: // global
           call _c4JeF(R1) args: 0, res: 0, upd: 0;
       c4JeK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JeF() //  [R1]
         { info_tbl: [(c4JeF,
                       label: block_c4JeF_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JeF: // global
           F32[I64[Sp + 8] + I64[Sp + 16]] = F32[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.623059809 UTC

[section ""data" . Foreign.Storable.$fStorableFloat_closure" {
     Foreign.Storable.$fStorableFloat_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableFloat_$calignment_closure+1;
         const Foreign.Storable.$fStorableFloat_$calignment_closure+1;
         const GHC.Storable.readFloatOffPtr1_closure+3;
         const GHC.Storable.writeFloatOffPtr1_closure+4;
         const Foreign.Storable.$fStorableFloat4_closure+3;
         const Foreign.Storable.$fStorableFloat3_closure+4;
         const Foreign.Storable.$fStorableFloat2_closure+2;
         const Foreign.Storable.$fStorableFloat1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.625520141 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr2_closure" {
     Foreign.Storable.$fStorableStablePtr2_closure:
         const Foreign.Storable.$fStorableStablePtr2_info;
 },
 Foreign.Storable.$fStorableStablePtr2_entry() //  [R2]
         { info_tbl: [(c4Jfq,
                       label: Foreign.Storable.$fStorableStablePtr2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jfq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Jfu; else goto c4Jfv;
       c4Jfu: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableStablePtr2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Jfv: // global
           I64[Sp - 8] = block_c4Jfn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Jfz; else goto c4Jfo;
       u4Jfz: // global
           call _c4Jfn(R1) args: 0, res: 0, upd: 0;
       c4Jfo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jfn() //  [R1]
         { info_tbl: [(c4Jfn,
                       label: block_c4Jfn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jfn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Jfy; else goto c4Jfx;
       c4Jfy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Jfx: // global
           _s4ItW::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Stable.StablePtr_con_info;
           I64[Hp] = _s4ItW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.632569073 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr4_closure" {
     Foreign.Storable.$fStorableStablePtr4_closure:
         const Foreign.Storable.$fStorableStablePtr4_info;
 },
 Foreign.Storable.$fStorableStablePtr4_entry() //  [R2, R3]
         { info_tbl: [(c4JfU,
                       label: Foreign.Storable.$fStorableStablePtr4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JfU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Jg6; else goto c4Jg7;
       c4Jg6: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableStablePtr4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Jg7: // global
           I64[Sp - 16] = block_c4JfR_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Jgd; else goto c4JfS;
       u4Jgd: // global
           call _c4JfR(R1) args: 0, res: 0, upd: 0;
       c4JfS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JfR() //  [R1]
         { info_tbl: [(c4JfR,
                       label: block_c4JfR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JfR: // global
           I64[Sp] = block_c4JfX_info;
           _s4Iu2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Iu2::I64;
           if (R1 & 7 != 0) goto u4Jgc; else goto c4JfY;
       u4Jgc: // global
           call _c4JfX(R1) args: 0, res: 0, upd: 0;
       c4JfY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JfX() //  [R1]
         { info_tbl: [(c4JfX,
                       label: block_c4JfX_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JfX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Jgb; else goto c4Jga;
       c4Jgb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Jga: // global
           _s4Iu8::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Stable.StablePtr_con_info;
           I64[Hp] = _s4Iu8::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.641323304 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr1_closure" {
     Foreign.Storable.$fStorableStablePtr1_closure:
         const Foreign.Storable.$fStorableStablePtr1_info;
 },
 Foreign.Storable.$fStorableStablePtr1_entry() //  [R2, R3]
         { info_tbl: [(c4JgE,
                       label: Foreign.Storable.$fStorableStablePtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JgE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JgI; else goto c4JgJ;
       c4JgI: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableStablePtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JgJ: // global
           I64[Sp - 16] = block_c4JgB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4JgR; else goto c4JgC;
       u4JgR: // global
           call _c4JgB(R1) args: 0, res: 0, upd: 0;
       c4JgC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JgB() //  [R1]
         { info_tbl: [(c4JgB,
                       label: block_c4JgB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JgB: // global
           I64[Sp] = block_c4JgH_info;
           _s4Iue::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Iue::I64;
           if (R1 & 7 != 0) goto u4JgQ; else goto c4JgL;
       u4JgQ: // global
           call _c4JgH(R1) args: 0, res: 0, upd: 0;
       c4JgL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JgH() //  [R1]
         { info_tbl: [(c4JgH,
                       label: block_c4JgH_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JgH: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.649189111 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr3_closure" {
     Foreign.Storable.$fStorableStablePtr3_closure:
         const Foreign.Storable.$fStorableStablePtr3_info;
 },
 Foreign.Storable.$fStorableStablePtr3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Jhi,
                       label: Foreign.Storable.$fStorableStablePtr3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jhi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Jhr; else goto c4Jhs;
       c4Jhr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableStablePtr3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Jhs: // global
           I64[Sp - 24] = block_c4Jhf_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4JhC; else goto c4Jhg;
       u4JhC: // global
           call _c4Jhf(R1) args: 0, res: 0, upd: 0;
       c4Jhg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jhf() //  [R1]
         { info_tbl: [(c4Jhf,
                       label: block_c4Jhf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jhf: // global
           I64[Sp] = block_c4Jhl_info;
           _s4Iun::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Iun::I64;
           if (R1 & 7 != 0) goto u4JhB; else goto c4Jhm;
       u4JhB: // global
           call _c4Jhl(R1) args: 0, res: 0, upd: 0;
       c4Jhm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jhl() //  [R1]
         { info_tbl: [(c4Jhl,
                       label: block_c4Jhl_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jhl: // global
           I64[Sp] = block_c4Jhq_info;
           _s4Iup::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Iup::I64;
           if (R1 & 7 != 0) goto u4JhD; else goto c4Jhv;
       u4JhD: // global
           call _c4Jhq(R1) args: 0, res: 0, upd: 0;
       c4Jhv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jhq() //  [R1]
         { info_tbl: [(c4Jhq,
                       label: block_c4Jhq_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jhq: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.659408044 UTC

[section ""data" . Foreign.Storable.$fStorableStablePtr_closure" {
     Foreign.Storable.$fStorableStablePtr_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableStablePtr_$calignment_closure+1;
         const Foreign.Storable.$fStorableStablePtr_$calignment_closure+1;
         const GHC.Storable.readStablePtrOffPtr1_closure+3;
         const GHC.Storable.writeStablePtrOffPtr1_closure+4;
         const Foreign.Storable.$fStorableStablePtr4_closure+3;
         const Foreign.Storable.$fStorableStablePtr3_closure+4;
         const Foreign.Storable.$fStorableStablePtr2_closure+2;
         const Foreign.Storable.$fStorableStablePtr1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.661871147 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr2_closure" {
     Foreign.Storable.$fStorableFunPtr2_closure:
         const Foreign.Storable.$fStorableFunPtr2_info;
 },
 Foreign.Storable.$fStorableFunPtr2_entry() //  [R2]
         { info_tbl: [(c4Jib,
                       label: Foreign.Storable.$fStorableFunPtr2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jib: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Jif; else goto c4Jig;
       c4Jif: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFunPtr2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Jig: // global
           I64[Sp - 8] = block_c4Ji8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Jik; else goto c4Ji9;
       u4Jik: // global
           call _c4Ji8(R1) args: 0, res: 0, upd: 0;
       c4Ji9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Ji8() //  [R1]
         { info_tbl: [(c4Ji8,
                       label: block_c4Ji8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Ji8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Jij; else goto c4Jii;
       c4Jij: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Jii: // global
           _s4IuA::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = _s4IuA::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.668897776 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr4_closure" {
     Foreign.Storable.$fStorableFunPtr4_closure:
         const Foreign.Storable.$fStorableFunPtr4_info;
 },
 Foreign.Storable.$fStorableFunPtr4_entry() //  [R2, R3]
         { info_tbl: [(c4JiF,
                       label: Foreign.Storable.$fStorableFunPtr4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JiF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JiR; else goto c4JiS;
       c4JiR: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFunPtr4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JiS: // global
           I64[Sp - 16] = block_c4JiC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4JiY; else goto c4JiD;
       u4JiY: // global
           call _c4JiC(R1) args: 0, res: 0, upd: 0;
       c4JiD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JiC() //  [R1]
         { info_tbl: [(c4JiC,
                       label: block_c4JiC_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JiC: // global
           I64[Sp] = block_c4JiI_info;
           _s4IuG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IuG::I64;
           if (R1 & 7 != 0) goto u4JiX; else goto c4JiJ;
       u4JiX: // global
           call _c4JiI(R1) args: 0, res: 0, upd: 0;
       c4JiJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JiI() //  [R1]
         { info_tbl: [(c4JiI,
                       label: block_c4JiI_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JiI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JiW; else goto c4JiV;
       c4JiW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4JiV: // global
           _s4IuM::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Ptr.FunPtr_con_info;
           I64[Hp] = _s4IuM::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.677905999 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr1_closure" {
     Foreign.Storable.$fStorableFunPtr1_closure:
         const Foreign.Storable.$fStorableFunPtr1_info;
 },
 Foreign.Storable.$fStorableFunPtr1_entry() //  [R2, R3]
         { info_tbl: [(c4Jjp,
                       label: Foreign.Storable.$fStorableFunPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jjp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Jjt; else goto c4Jju;
       c4Jjt: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFunPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Jju: // global
           I64[Sp - 16] = block_c4Jjm_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4JjC; else goto c4Jjn;
       u4JjC: // global
           call _c4Jjm(R1) args: 0, res: 0, upd: 0;
       c4Jjn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jjm() //  [R1]
         { info_tbl: [(c4Jjm,
                       label: block_c4Jjm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jjm: // global
           I64[Sp] = block_c4Jjs_info;
           _s4IuS::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IuS::I64;
           if (R1 & 7 != 0) goto u4JjB; else goto c4Jjw;
       u4JjB: // global
           call _c4Jjs(R1) args: 0, res: 0, upd: 0;
       c4Jjw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jjs() //  [R1]
         { info_tbl: [(c4Jjs,
                       label: block_c4Jjs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jjs: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.686083724 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr3_closure" {
     Foreign.Storable.$fStorableFunPtr3_closure:
         const Foreign.Storable.$fStorableFunPtr3_info;
 },
 Foreign.Storable.$fStorableFunPtr3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Jk3,
                       label: Foreign.Storable.$fStorableFunPtr3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jk3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Jkc; else goto c4Jkd;
       c4Jkc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFunPtr3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Jkd: // global
           I64[Sp - 24] = block_c4Jk0_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Jkn; else goto c4Jk1;
       u4Jkn: // global
           call _c4Jk0(R1) args: 0, res: 0, upd: 0;
       c4Jk1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jk0() //  [R1]
         { info_tbl: [(c4Jk0,
                       label: block_c4Jk0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jk0: // global
           I64[Sp] = block_c4Jk6_info;
           _s4Iv1::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Iv1::I64;
           if (R1 & 7 != 0) goto u4Jkm; else goto c4Jk7;
       u4Jkm: // global
           call _c4Jk6(R1) args: 0, res: 0, upd: 0;
       c4Jk7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jk6() //  [R1]
         { info_tbl: [(c4Jk6,
                       label: block_c4Jk6_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jk6: // global
           I64[Sp] = block_c4Jkb_info;
           _s4Iv3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Iv3::I64;
           if (R1 & 7 != 0) goto u4Jko; else goto c4Jkg;
       u4Jko: // global
           call _c4Jkb(R1) args: 0, res: 0, upd: 0;
       c4Jkg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jkb() //  [R1]
         { info_tbl: [(c4Jkb,
                       label: block_c4Jkb_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jkb: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.700061022 UTC

[section ""data" . Foreign.Storable.$fStorableFunPtr_closure" {
     Foreign.Storable.$fStorableFunPtr_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableFunPtr_$calignment_closure+1;
         const Foreign.Storable.$fStorableFunPtr_$calignment_closure+1;
         const GHC.Storable.readFunPtrOffPtr1_closure+3;
         const GHC.Storable.writeFunPtrOffPtr1_closure+4;
         const Foreign.Storable.$fStorableFunPtr4_closure+3;
         const Foreign.Storable.$fStorableFunPtr3_closure+4;
         const Foreign.Storable.$fStorableFunPtr2_closure+2;
         const Foreign.Storable.$fStorableFunPtr1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.702564241 UTC

[section ""data" . Foreign.Storable.$fStorablePtr2_closure" {
     Foreign.Storable.$fStorablePtr2_closure:
         const Foreign.Storable.$fStorablePtr2_info;
 },
 Foreign.Storable.$fStorablePtr2_entry() //  [R2]
         { info_tbl: [(c4JkW,
                       label: Foreign.Storable.$fStorablePtr2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JkW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Jl0; else goto c4Jl1;
       c4Jl0: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorablePtr2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Jl1: // global
           I64[Sp - 8] = block_c4JkT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Jl5; else goto c4JkU;
       u4Jl5: // global
           call _c4JkT(R1) args: 0, res: 0, upd: 0;
       c4JkU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JkT() //  [R1]
         { info_tbl: [(c4JkT,
                       label: block_c4JkT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JkT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Jl4; else goto c4Jl3;
       c4Jl4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Jl3: // global
           _s4Ive::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Ive::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.709420226 UTC

[section ""data" . Foreign.Storable.$fStorablePtr4_closure" {
     Foreign.Storable.$fStorablePtr4_closure:
         const Foreign.Storable.$fStorablePtr4_info;
 },
 Foreign.Storable.$fStorablePtr4_entry() //  [R2, R3]
         { info_tbl: [(c4Jlq,
                       label: Foreign.Storable.$fStorablePtr4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jlq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JlC; else goto c4JlD;
       c4JlC: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorablePtr4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JlD: // global
           I64[Sp - 16] = block_c4Jln_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4JlJ; else goto c4Jlo;
       u4JlJ: // global
           call _c4Jln(R1) args: 0, res: 0, upd: 0;
       c4Jlo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jln() //  [R1]
         { info_tbl: [(c4Jln,
                       label: block_c4Jln_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jln: // global
           I64[Sp] = block_c4Jlt_info;
           _s4Ivk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Ivk::I64;
           if (R1 & 7 != 0) goto u4JlI; else goto c4Jlu;
       u4JlI: // global
           call _c4Jlt(R1) args: 0, res: 0, upd: 0;
       c4Jlu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jlt() //  [R1]
         { info_tbl: [(c4Jlt,
                       label: block_c4Jlt_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jlt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JlH; else goto c4JlG;
       c4JlH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4JlG: // global
           _s4Ivq::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4Ivq::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.718508798 UTC

[section ""data" . Foreign.Storable.$fStorablePtr1_closure" {
     Foreign.Storable.$fStorablePtr1_closure:
         const Foreign.Storable.$fStorablePtr1_info;
 },
 Foreign.Storable.$fStorablePtr1_entry() //  [R2, R3]
         { info_tbl: [(c4Jma,
                       label: Foreign.Storable.$fStorablePtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jma: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Jme; else goto c4Jmf;
       c4Jme: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorablePtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Jmf: // global
           I64[Sp - 16] = block_c4Jm7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Jmn; else goto c4Jm8;
       u4Jmn: // global
           call _c4Jm7(R1) args: 0, res: 0, upd: 0;
       c4Jm8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jm7() //  [R1]
         { info_tbl: [(c4Jm7,
                       label: block_c4Jm7_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jm7: // global
           I64[Sp] = block_c4Jmd_info;
           _s4Ivw::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Ivw::I64;
           if (R1 & 7 != 0) goto u4Jmm; else goto c4Jmh;
       u4Jmm: // global
           call _c4Jmd(R1) args: 0, res: 0, upd: 0;
       c4Jmh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jmd() //  [R1]
         { info_tbl: [(c4Jmd,
                       label: block_c4Jmd_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jmd: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.727765654 UTC

[section ""data" . Foreign.Storable.$fStorablePtr3_closure" {
     Foreign.Storable.$fStorablePtr3_closure:
         const Foreign.Storable.$fStorablePtr3_info;
 },
 Foreign.Storable.$fStorablePtr3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4JmO,
                       label: Foreign.Storable.$fStorablePtr3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JmO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4JmX; else goto c4JmY;
       c4JmX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorablePtr3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JmY: // global
           I64[Sp - 24] = block_c4JmL_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Jn8; else goto c4JmM;
       u4Jn8: // global
           call _c4JmL(R1) args: 0, res: 0, upd: 0;
       c4JmM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JmL() //  [R1]
         { info_tbl: [(c4JmL,
                       label: block_c4JmL_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JmL: // global
           I64[Sp] = block_c4JmR_info;
           _s4IvF::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IvF::I64;
           if (R1 & 7 != 0) goto u4Jn7; else goto c4JmS;
       u4Jn7: // global
           call _c4JmR(R1) args: 0, res: 0, upd: 0;
       c4JmS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JmR() //  [R1]
         { info_tbl: [(c4JmR,
                       label: block_c4JmR_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JmR: // global
           I64[Sp] = block_c4JmW_info;
           _s4IvH::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4IvH::I64;
           if (R1 & 7 != 0) goto u4Jn9; else goto c4Jn1;
       u4Jn9: // global
           call _c4JmW(R1) args: 0, res: 0, upd: 0;
       c4Jn1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JmW() //  [R1]
         { info_tbl: [(c4JmW,
                       label: block_c4JmW_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JmW: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.737293689 UTC

[section ""data" . Foreign.Storable.$fStorablePtr_closure" {
     Foreign.Storable.$fStorablePtr_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorablePtr_$calignment_closure+1;
         const Foreign.Storable.$fStorablePtr_$calignment_closure+1;
         const GHC.Storable.readPtrOffPtr1_closure+3;
         const GHC.Storable.writePtrOffPtr1_closure+4;
         const Foreign.Storable.$fStorablePtr4_closure+3;
         const Foreign.Storable.$fStorablePtr3_closure+4;
         const Foreign.Storable.$fStorablePtr2_closure+2;
         const Foreign.Storable.$fStorablePtr1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.74003148 UTC

[section ""data" . Foreign.Storable.$fStorableWord2_closure" {
     Foreign.Storable.$fStorableWord2_closure:
         const Foreign.Storable.$fStorableWord2_info;
 },
 Foreign.Storable.$fStorableWord2_entry() //  [R2]
         { info_tbl: [(c4JnH,
                       label: Foreign.Storable.$fStorableWord2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JnH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4JnL; else goto c4JnM;
       c4JnL: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4JnM: // global
           I64[Sp - 8] = block_c4JnE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4JnQ; else goto c4JnF;
       u4JnQ: // global
           call _c4JnE(R1) args: 0, res: 0, upd: 0;
       c4JnF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JnE() //  [R1]
         { info_tbl: [(c4JnE,
                       label: block_c4JnE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JnE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JnP; else goto c4JnO;
       c4JnP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4JnO: // global
           _s4IvS::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s4IvS::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.747304559 UTC

[section ""data" . Foreign.Storable.$fStorableWord4_closure" {
     Foreign.Storable.$fStorableWord4_closure:
         const Foreign.Storable.$fStorableWord4_info;
 },
 Foreign.Storable.$fStorableWord4_entry() //  [R2, R3]
         { info_tbl: [(c4Job,
                       label: Foreign.Storable.$fStorableWord4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Job: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Jon; else goto c4Joo;
       c4Jon: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Joo: // global
           I64[Sp - 16] = block_c4Jo8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Jou; else goto c4Jo9;
       u4Jou: // global
           call _c4Jo8(R1) args: 0, res: 0, upd: 0;
       c4Jo9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jo8() //  [R1]
         { info_tbl: [(c4Jo8,
                       label: block_c4Jo8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jo8: // global
           I64[Sp] = block_c4Joe_info;
           _s4IvY::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IvY::I64;
           if (R1 & 7 != 0) goto u4Jot; else goto c4Jof;
       u4Jot: // global
           call _c4Joe(R1) args: 0, res: 0, upd: 0;
       c4Jof: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Joe() //  [R1]
         { info_tbl: [(c4Joe,
                       label: block_c4Joe_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Joe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Jos; else goto c4Jor;
       c4Jos: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Jor: // global
           _s4Iw4::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _s4Iw4::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.756141876 UTC

[section ""data" . Foreign.Storable.$fStorableWord1_closure" {
     Foreign.Storable.$fStorableWord1_closure:
         const Foreign.Storable.$fStorableWord1_info;
 },
 Foreign.Storable.$fStorableWord1_entry() //  [R2, R3]
         { info_tbl: [(c4JoV,
                       label: Foreign.Storable.$fStorableWord1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JoV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JoZ; else goto c4Jp0;
       c4JoZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Jp0: // global
           I64[Sp - 16] = block_c4JoS_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Jp8; else goto c4JoT;
       u4Jp8: // global
           call _c4JoS(R1) args: 0, res: 0, upd: 0;
       c4JoT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JoS() //  [R1]
         { info_tbl: [(c4JoS,
                       label: block_c4JoS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JoS: // global
           I64[Sp] = block_c4JoY_info;
           _s4Iwa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Iwa::I64;
           if (R1 & 7 != 0) goto u4Jp7; else goto c4Jp2;
       u4Jp7: // global
           call _c4JoY(R1) args: 0, res: 0, upd: 0;
       c4Jp2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JoY() //  [R1]
         { info_tbl: [(c4JoY,
                       label: block_c4JoY_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JoY: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.764416004 UTC

[section ""data" . Foreign.Storable.$fStorableWord3_closure" {
     Foreign.Storable.$fStorableWord3_closure:
         const Foreign.Storable.$fStorableWord3_info;
 },
 Foreign.Storable.$fStorableWord3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Jpz,
                       label: Foreign.Storable.$fStorableWord3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jpz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4JpI; else goto c4JpJ;
       c4JpI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JpJ: // global
           I64[Sp - 24] = block_c4Jpw_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4JpT; else goto c4Jpx;
       u4JpT: // global
           call _c4Jpw(R1) args: 0, res: 0, upd: 0;
       c4Jpx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jpw() //  [R1]
         { info_tbl: [(c4Jpw,
                       label: block_c4Jpw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jpw: // global
           I64[Sp] = block_c4JpC_info;
           _s4Iwj::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Iwj::I64;
           if (R1 & 7 != 0) goto u4JpS; else goto c4JpD;
       u4JpS: // global
           call _c4JpC(R1) args: 0, res: 0, upd: 0;
       c4JpD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JpC() //  [R1]
         { info_tbl: [(c4JpC,
                       label: block_c4JpC_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JpC: // global
           I64[Sp] = block_c4JpH_info;
           _s4Iwl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Iwl::I64;
           if (R1 & 7 != 0) goto u4JpU; else goto c4JpM;
       u4JpU: // global
           call _c4JpH(R1) args: 0, res: 0, upd: 0;
       c4JpM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JpH() //  [R1]
         { info_tbl: [(c4JpH,
                       label: block_c4JpH_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JpH: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.774737623 UTC

[section ""data" . Foreign.Storable.$fStorableWord_closure" {
     Foreign.Storable.$fStorableWord_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableWord_$calignment_closure+1;
         const Foreign.Storable.$fStorableWord_$calignment_closure+1;
         const GHC.Storable.readWordOffPtr1_closure+3;
         const GHC.Storable.writeWordOffPtr1_closure+4;
         const Foreign.Storable.$fStorableWord4_closure+3;
         const Foreign.Storable.$fStorableWord3_closure+4;
         const Foreign.Storable.$fStorableWord2_closure+2;
         const Foreign.Storable.$fStorableWord1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.777139321 UTC

[section ""data" . Foreign.Storable.$fStorableInt2_closure" {
     Foreign.Storable.$fStorableInt2_closure:
         const Foreign.Storable.$fStorableInt2_info;
 },
 Foreign.Storable.$fStorableInt2_entry() //  [R2]
         { info_tbl: [(c4Jqs,
                       label: Foreign.Storable.$fStorableInt2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jqs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Jqw; else goto c4Jqx;
       c4Jqw: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Jqx: // global
           I64[Sp - 8] = block_c4Jqp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4JqB; else goto c4Jqq;
       u4JqB: // global
           call _c4Jqp(R1) args: 0, res: 0, upd: 0;
       c4Jqq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jqp() //  [R1]
         { info_tbl: [(c4Jqp,
                       label: block_c4Jqp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jqp: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JqA; else goto c4Jqz;
       c4JqA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Jqz: // global
           _s4Iww::I64 = I64[I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4Iww::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.784051881 UTC

[section ""data" . Foreign.Storable.$fStorableInt4_closure" {
     Foreign.Storable.$fStorableInt4_closure:
         const Foreign.Storable.$fStorableInt4_info;
 },
 Foreign.Storable.$fStorableInt4_entry() //  [R2, R3]
         { info_tbl: [(c4JqW,
                       label: Foreign.Storable.$fStorableInt4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JqW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Jr8; else goto c4Jr9;
       c4Jr8: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Jr9: // global
           I64[Sp - 16] = block_c4JqT_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Jrf; else goto c4JqU;
       u4Jrf: // global
           call _c4JqT(R1) args: 0, res: 0, upd: 0;
       c4JqU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JqT() //  [R1]
         { info_tbl: [(c4JqT,
                       label: block_c4JqT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JqT: // global
           I64[Sp] = block_c4JqZ_info;
           _s4IwC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IwC::I64;
           if (R1 & 7 != 0) goto u4Jre; else goto c4Jr0;
       u4Jre: // global
           call _c4JqZ(R1) args: 0, res: 0, upd: 0;
       c4Jr0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JqZ() //  [R1]
         { info_tbl: [(c4JqZ,
                       label: block_c4JqZ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JqZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Jrd; else goto c4Jrc;
       c4Jrd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Jrc: // global
           _s4IwI::I64 = I64[I64[Sp + 8] + I64[R1 + 7]];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4IwI::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.793567149 UTC

[section ""data" . Foreign.Storable.$fStorableInt1_closure" {
     Foreign.Storable.$fStorableInt1_closure:
         const Foreign.Storable.$fStorableInt1_info;
 },
 Foreign.Storable.$fStorableInt1_entry() //  [R2, R3]
         { info_tbl: [(c4JrG,
                       label: Foreign.Storable.$fStorableInt1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JrG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JrK; else goto c4JrL;
       c4JrK: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JrL: // global
           I64[Sp - 16] = block_c4JrD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4JrT; else goto c4JrE;
       u4JrT: // global
           call _c4JrD(R1) args: 0, res: 0, upd: 0;
       c4JrE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JrD() //  [R1]
         { info_tbl: [(c4JrD,
                       label: block_c4JrD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JrD: // global
           I64[Sp] = block_c4JrJ_info;
           _s4IwO::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IwO::I64;
           if (R1 & 7 != 0) goto u4JrS; else goto c4JrN;
       u4JrS: // global
           call _c4JrJ(R1) args: 0, res: 0, upd: 0;
       c4JrN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JrJ() //  [R1]
         { info_tbl: [(c4JrJ,
                       label: block_c4JrJ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JrJ: // global
           I64[I64[Sp + 8]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.803201982 UTC

[section ""data" . Foreign.Storable.$fStorableInt3_closure" {
     Foreign.Storable.$fStorableInt3_closure:
         const Foreign.Storable.$fStorableInt3_info;
 },
 Foreign.Storable.$fStorableInt3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Jsk,
                       label: Foreign.Storable.$fStorableInt3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jsk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Jst; else goto c4Jsu;
       c4Jst: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableInt3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Jsu: // global
           I64[Sp - 24] = block_c4Jsh_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4JsE; else goto c4Jsi;
       u4JsE: // global
           call _c4Jsh(R1) args: 0, res: 0, upd: 0;
       c4Jsi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jsh() //  [R1]
         { info_tbl: [(c4Jsh,
                       label: block_c4Jsh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jsh: // global
           I64[Sp] = block_c4Jsn_info;
           _s4IwX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IwX::I64;
           if (R1 & 7 != 0) goto u4JsD; else goto c4Jso;
       u4JsD: // global
           call _c4Jsn(R1) args: 0, res: 0, upd: 0;
       c4Jso: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jsn() //  [R1]
         { info_tbl: [(c4Jsn,
                       label: block_c4Jsn_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jsn: // global
           I64[Sp] = block_c4Jss_info;
           _s4IwZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4IwZ::I64;
           if (R1 & 7 != 0) goto u4JsF; else goto c4Jsx;
       u4JsF: // global
           call _c4Jss(R1) args: 0, res: 0, upd: 0;
       c4Jsx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jss() //  [R1]
         { info_tbl: [(c4Jss,
                       label: block_c4Jss_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jss: // global
           I64[I64[Sp + 8] + I64[Sp + 16]] = I64[R1 + 7];
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.817169939 UTC

[section ""data" . Foreign.Storable.$fStorableInt_closure" {
     Foreign.Storable.$fStorableInt_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableInt_$calignment_closure+1;
         const Foreign.Storable.$fStorableInt_$calignment_closure+1;
         const GHC.Storable.readIntOffPtr1_closure+3;
         const GHC.Storable.writeIntOffPtr1_closure+4;
         const Foreign.Storable.$fStorableInt4_closure+3;
         const Foreign.Storable.$fStorableInt3_closure+4;
         const Foreign.Storable.$fStorableInt2_closure+2;
         const Foreign.Storable.$fStorableInt1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.82012406 UTC

[section ""data" . Foreign.Storable.$fStorableChar2_closure" {
     Foreign.Storable.$fStorableChar2_closure:
         const Foreign.Storable.$fStorableChar2_info;
 },
 Foreign.Storable.$fStorableChar2_entry() //  [R2]
         { info_tbl: [(c4Jtd,
                       label: Foreign.Storable.$fStorableChar2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jtd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Jth; else goto c4Jti;
       c4Jth: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableChar2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Jti: // global
           I64[Sp - 8] = block_c4Jta_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Jtm; else goto c4Jtb;
       u4Jtm: // global
           call _c4Jta(R1) args: 0, res: 0, upd: 0;
       c4Jtb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jta() //  [R1]
         { info_tbl: [(c4Jta,
                       label: block_c4Jta_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jta: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Jtl; else goto c4Jtk;
       c4Jtl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Jtk: // global
           _s4Ixa::I64 = %MO_UU_Conv_W32_W64(I32[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s4Ixa::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.826880155 UTC

[section ""data" . Foreign.Storable.$fStorableChar4_closure" {
     Foreign.Storable.$fStorableChar4_closure:
         const Foreign.Storable.$fStorableChar4_info;
 },
 Foreign.Storable.$fStorableChar4_entry() //  [R2, R3]
         { info_tbl: [(c4JtH,
                       label: Foreign.Storable.$fStorableChar4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JtH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JtT; else goto c4JtU;
       c4JtT: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableChar4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JtU: // global
           I64[Sp - 16] = block_c4JtE_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Ju0; else goto c4JtF;
       u4Ju0: // global
           call _c4JtE(R1) args: 0, res: 0, upd: 0;
       c4JtF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JtE() //  [R1]
         { info_tbl: [(c4JtE,
                       label: block_c4JtE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JtE: // global
           I64[Sp] = block_c4JtK_info;
           _s4Ixg::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Ixg::I64;
           if (R1 & 7 != 0) goto u4JtZ; else goto c4JtL;
       u4JtZ: // global
           call _c4JtK(R1) args: 0, res: 0, upd: 0;
       c4JtL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JtK() //  [R1]
         { info_tbl: [(c4JtK,
                       label: block_c4JtK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JtK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JtY; else goto c4JtX;
       c4JtY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4JtX: // global
           _s4Ixm::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s4Ixm::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.835461163 UTC

[section ""data" . Foreign.Storable.$fStorableChar1_closure" {
     Foreign.Storable.$fStorableChar1_closure:
         const Foreign.Storable.$fStorableChar1_info;
 },
 Foreign.Storable.$fStorableChar1_entry() //  [R2, R3]
         { info_tbl: [(c4Jur,
                       label: Foreign.Storable.$fStorableChar1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jur: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Juv; else goto c4Juw;
       c4Juv: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableChar1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Juw: // global
           I64[Sp - 16] = block_c4Juo_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4JuE; else goto c4Jup;
       u4JuE: // global
           call _c4Juo(R1) args: 0, res: 0, upd: 0;
       c4Jup: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Juo() //  [R1]
         { info_tbl: [(c4Juo,
                       label: block_c4Juo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Juo: // global
           I64[Sp] = block_c4Juu_info;
           _s4Ixs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Ixs::I64;
           if (R1 & 7 != 0) goto u4JuD; else goto c4Juy;
       u4JuD: // global
           call _c4Juu(R1) args: 0, res: 0, upd: 0;
       c4Juy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Juu() //  [R1]
         { info_tbl: [(c4Juu,
                       label: block_c4Juu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Juu: // global
           I32[I64[Sp + 8]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.844696451 UTC

[section ""data" . Foreign.Storable.$fStorableChar3_closure" {
     Foreign.Storable.$fStorableChar3_closure:
         const Foreign.Storable.$fStorableChar3_info;
 },
 Foreign.Storable.$fStorableChar3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4Jv5,
                       label: Foreign.Storable.$fStorableChar3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jv5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Jve; else goto c4Jvf;
       c4Jve: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableChar3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Jvf: // global
           I64[Sp - 24] = block_c4Jv2_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Jvp; else goto c4Jv3;
       u4Jvp: // global
           call _c4Jv2(R1) args: 0, res: 0, upd: 0;
       c4Jv3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jv2() //  [R1]
         { info_tbl: [(c4Jv2,
                       label: block_c4Jv2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jv2: // global
           I64[Sp] = block_c4Jv8_info;
           _s4IxB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IxB::I64;
           if (R1 & 7 != 0) goto u4Jvo; else goto c4Jv9;
       u4Jvo: // global
           call _c4Jv8(R1) args: 0, res: 0, upd: 0;
       c4Jv9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jv8() //  [R1]
         { info_tbl: [(c4Jv8,
                       label: block_c4Jv8_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jv8: // global
           I64[Sp] = block_c4Jvd_info;
           _s4IxD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4IxD::I64;
           if (R1 & 7 != 0) goto u4Jvq; else goto c4Jvi;
       u4Jvq: // global
           call _c4Jvd(R1) args: 0, res: 0, upd: 0;
       c4Jvi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jvd() //  [R1]
         { info_tbl: [(c4Jvd,
                       label: block_c4Jvd_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jvd: // global
           I32[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.854691787 UTC

[section ""data" . Foreign.Storable.$fStorableChar_closure" {
     Foreign.Storable.$fStorableChar_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableChar_$calignment_closure+1;
         const Foreign.Storable.$fStorableChar_$calignment_closure+1;
         const GHC.Storable.readWideCharOffPtr1_closure+3;
         const GHC.Storable.writeWideCharOffPtr1_closure+4;
         const Foreign.Storable.$fStorableChar4_closure+3;
         const Foreign.Storable.$fStorableChar3_closure+4;
         const Foreign.Storable.$fStorableChar2_closure+2;
         const Foreign.Storable.$fStorableChar1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.856702782 UTC

[section ""data" . Foreign.Storable.$trModule3_closure" {
     Foreign.Storable.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Storable.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.858469713 UTC

[section ""data" . Foreign.Storable.$trModule1_closure" {
     Foreign.Storable.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Storable.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.86024596 UTC

[section ""data" . Foreign.Storable.$trModule_closure" {
     Foreign.Storable.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.Storable.$trModule3_closure+1;
         const Foreign.Storable.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.862158191 UTC

[section ""data" . $krep_r4Ffk_closure" {
     $krep_r4Ffk_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.864035919 UTC

[section ""data" . Foreign.Storable.$tcStorable1_closure" {
     Foreign.Storable.$tcStorable1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep_r4Ffk_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.866007161 UTC

[section ""cstring" . Foreign.Storable.$tcStorable3_bytes" {
     Foreign.Storable.$tcStorable3_bytes:
         I8[] [83,116,111,114,97,98,108,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.867857089 UTC

[section ""data" . Foreign.Storable.$tcStorable2_closure" {
     Foreign.Storable.$tcStorable2_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.Storable.$tcStorable3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.869858424 UTC

[section ""data" . Foreign.Storable.$tcStorable_closure" {
     Foreign.Storable.$tcStorable_closure:
         const GHC.Types.TyCon_con_info;
         const Foreign.Storable.$trModule_closure+1;
         const Foreign.Storable.$tcStorable2_closure+1;
         const Foreign.Storable.$tcStorable1_closure+4;
         const 9192657549155052097;
         const 13909834202100645491;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.872241933 UTC

[section ""data" . Foreign.Storable.$fStorableWord20_closure" {
     Foreign.Storable.$fStorableWord20_closure:
         const Foreign.Storable.$fStorableWord20_info;
 },
 Foreign.Storable.$fStorableWord20_entry() //  [R2]
         { info_tbl: [(c4Jw6,
                       label: Foreign.Storable.$fStorableWord20_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jw6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4Jwa; else goto c4Jwb;
       c4Jwa: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord20_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4Jwb: // global
           I64[Sp - 8] = block_c4Jw3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4Jwf; else goto c4Jw4;
       u4Jwf: // global
           call _c4Jw3(R1) args: 0, res: 0, upd: 0;
       c4Jw4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jw3() //  [R1]
         { info_tbl: [(c4Jw3,
                       label: block_c4Jw3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jw3: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4Jwe; else goto c4Jwd;
       c4Jwe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Jwd: // global
           _s4IxO::I64 = %MO_UU_Conv_W8_W64(I8[I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s4IxO::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.879219365 UTC

[section ""data" . Foreign.Storable.$fStorableWord22_closure" {
     Foreign.Storable.$fStorableWord22_closure:
         const Foreign.Storable.$fStorableWord22_info;
 },
 Foreign.Storable.$fStorableWord22_entry() //  [R2, R3]
         { info_tbl: [(c4JwA,
                       label: Foreign.Storable.$fStorableWord22_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JwA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JwM; else goto c4JwN;
       c4JwM: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord22_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JwN: // global
           I64[Sp - 16] = block_c4Jwx_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4JwT; else goto c4Jwy;
       u4JwT: // global
           call _c4Jwx(R1) args: 0, res: 0, upd: 0;
       c4Jwy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jwx() //  [R1]
         { info_tbl: [(c4Jwx,
                       label: block_c4Jwx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jwx: // global
           I64[Sp] = block_c4JwD_info;
           _s4IxU::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IxU::I64;
           if (R1 & 7 != 0) goto u4JwS; else goto c4JwE;
       u4JwS: // global
           call _c4JwD(R1) args: 0, res: 0, upd: 0;
       c4JwE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JwD() //  [R1]
         { info_tbl: [(c4JwD,
                       label: block_c4JwD_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JwD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JwR; else goto c4JwQ;
       c4JwR: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4JwQ: // global
           _s4Iy0::I64 = %MO_UU_Conv_W8_W64(I8[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s4Iy0::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.887390984 UTC

[section ""data" . Foreign.Storable.$fStorableWord19_closure" {
     Foreign.Storable.$fStorableWord19_closure:
         const Foreign.Storable.$fStorableWord19_info;
 },
 Foreign.Storable.$fStorableWord19_entry() //  [R2, R3]
         { info_tbl: [(c4Jxk,
                       label: Foreign.Storable.$fStorableWord19_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jxk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4Jxo; else goto c4Jxp;
       c4Jxo: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord19_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Jxp: // global
           I64[Sp - 16] = block_c4Jxh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4Jxx; else goto c4Jxi;
       u4Jxx: // global
           call _c4Jxh(R1) args: 0, res: 0, upd: 0;
       c4Jxi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jxh() //  [R1]
         { info_tbl: [(c4Jxh,
                       label: block_c4Jxh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jxh: // global
           I64[Sp] = block_c4Jxn_info;
           _s4Iy6::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Iy6::I64;
           if (R1 & 7 != 0) goto u4Jxw; else goto c4Jxr;
       u4Jxw: // global
           call _c4Jxn(R1) args: 0, res: 0, upd: 0;
       c4Jxr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jxn() //  [R1]
         { info_tbl: [(c4Jxn,
                       label: block_c4Jxn_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jxn: // global
           I8[I64[Sp + 8]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.895881678 UTC

[section ""data" . Foreign.Storable.$fStorableWord21_closure" {
     Foreign.Storable.$fStorableWord21_closure:
         const Foreign.Storable.$fStorableWord21_info;
 },
 Foreign.Storable.$fStorableWord21_entry() //  [R2, R3, R4]
         { info_tbl: [(c4JxY,
                       label: Foreign.Storable.$fStorableWord21_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JxY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4Jy7; else goto c4Jy8;
       c4Jy7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableWord21_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Jy8: // global
           I64[Sp - 24] = block_c4JxV_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4Jyi; else goto c4JxW;
       u4Jyi: // global
           call _c4JxV(R1) args: 0, res: 0, upd: 0;
       c4JxW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JxV() //  [R1]
         { info_tbl: [(c4JxV,
                       label: block_c4JxV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JxV: // global
           I64[Sp] = block_c4Jy1_info;
           _s4Iyf::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Iyf::I64;
           if (R1 & 7 != 0) goto u4Jyh; else goto c4Jy2;
       u4Jyh: // global
           call _c4Jy1(R1) args: 0, res: 0, upd: 0;
       c4Jy2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jy1() //  [R1]
         { info_tbl: [(c4Jy1,
                       label: block_c4Jy1_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jy1: // global
           I64[Sp] = block_c4Jy6_info;
           _s4Iyh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Iyh::I64;
           if (R1 & 7 != 0) goto u4Jyj; else goto c4Jyb;
       u4Jyj: // global
           call _c4Jy6(R1) args: 0, res: 0, upd: 0;
       c4Jyb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4Jy6() //  [R1]
         { info_tbl: [(c4Jy6,
                       label: block_c4Jy6_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4Jy6: // global
           I8[I64[Sp + 8] + I64[Sp + 16]] = %MO_UU_Conv_W64_W8(I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.906428783 UTC

[section ""data" . Foreign.Storable.$fStorableWord8_closure" {
     Foreign.Storable.$fStorableWord8_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableWord8_$calignment_closure+1;
         const Foreign.Storable.$fStorableWord8_$calignment_closure+1;
         const GHC.Storable.readWord8OffPtr1_closure+3;
         const GHC.Storable.writeWord8OffPtr1_closure+4;
         const Foreign.Storable.$fStorableWord22_closure+3;
         const Foreign.Storable.$fStorableWord21_closure+4;
         const Foreign.Storable.$fStorableWord20_closure+2;
         const Foreign.Storable.$fStorableWord19_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.909236137 UTC

[section ""data" . Foreign.Storable.$fStorableRatio2_closure" {
     Foreign.Storable.$fStorableRatio2_closure:
         const Foreign.Storable.$fStorableRatio2_info;
         const 0;
 },
 sat_s4Iyw_entry() //  [R1]
         { info_tbl: [(c4JyW,
                       label: sat_s4Iyw_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JyW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JyX; else goto c4JyY;
       c4JyX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JyY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Real.%_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableRatio2_entry() //  [R2, R3, R4]
         { info_tbl: [(c4JyZ,
                       label: Foreign.Storable.$fStorableRatio2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JyZ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c4Jz0; else goto c4Jz1;
       c4Jz0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4Jz1: // global
           I64[Sp - 32] = block_c4JyO_info;
           _s4Iym::P64 = R2;
           R2 = R2;
           I64[Sp - 48] = stg_ap_pv_info;
           P64[Sp - 40] = R4;
           P64[Sp - 24] = _s4Iym::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 48;
           call Foreign.Storable.peek_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c4JyO() //  [R1]
         { info_tbl: [(c4JyO,
                       label: block_c4JyO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JyO: // global
           _s4Iym::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4JyQ_info;
           R2 = _s4Iym::P64;
           I64[Sp - 16] = stg_ap_ppv_info;
           P64[Sp - 8] = P64[Sp + 24];
           P64[Sp] = Foreign.Storable.$fStorable()7_closure+1;
           P64[Sp + 24] = R1;
           Sp = Sp - 16;
           call Foreign.Storable.peekElemOff_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c4JyQ() //  [R1]
         { info_tbl: [(c4JyQ,
                       label: block_c4JyQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JyQ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4Jz5; else goto c4Jz4;
       c4Jz5: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4Jz4: // global
           I64[Hp - 32] = sat_s4Iyw_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.921138871 UTC

[section ""data" . Foreign.Storable.$fStorableRatio1_closure" {
     Foreign.Storable.$fStorableRatio1_closure:
         const Foreign.Storable.$fStorableRatio1_info;
 },
 Foreign.Storable.$fStorableRatio1_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c4JzD,
                       label: Foreign.Storable.$fStorableRatio1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JzD: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c4JzH; else goto c4JzI;
       c4JzH: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JzI: // global
           I64[Sp - 24] = block_c4JzA_info;
           R1 = R5;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4JzM; else goto c4JzB;
       u4JzM: // global
           call _c4JzA(R1) args: 0, res: 0, upd: 0;
       c4JzB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JzA() //  [R1]
         { info_tbl: [(c4JzA,
                       label: block_c4JzA_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JzA: // global
           I64[Sp - 8] = block_c4JzG_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_ppv_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 32;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c4JzG() //  []
         { info_tbl: [(c4JzG,
                       label: block_c4JzG_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JzG: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppv_info;
           _s4IyE::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 24];
           P64[Sp + 16] = Foreign.Storable.$fStorable()7_closure+1;
           P64[Sp + 24] = _s4IyE::P64;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.930378194 UTC

[section ""data" . Foreign.Storable.$fStorableBool6_closure" {
     Foreign.Storable.$fStorableBool6_closure:
         const Foreign.Storable.$fStorableBool6_info;
 },
 sat_s4IyT_entry() //  [R1]
         { info_tbl: [(c4JAu,
                       label: sat_s4IyT_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JAu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JAv; else goto c4JAw;
       c4JAv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JAw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c4JAt; else goto c4JAs;
       c4JAt: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4JAs: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableBool6_entry() //  [R2, R3]
         { info_tbl: [(c4JAx,
                       label: Foreign.Storable.$fStorableBool6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JAx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JAy; else goto c4JAz;
       c4JAy: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JAz: // global
           I64[Sp - 16] = block_c4JAc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4JAF; else goto c4JAd;
       u4JAF: // global
           call _c4JAc(R1) args: 0, res: 0, upd: 0;
       c4JAd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JAc() //  [R1]
         { info_tbl: [(c4JAc,
                       label: block_c4JAc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JAc: // global
           I64[Sp] = block_c4JAh_info;
           _s4IyM::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IyM::I64;
           if (R1 & 7 != 0) goto u4JAE; else goto c4JAi;
       u4JAE: // global
           call _c4JAh(R1) args: 0, res: 0, upd: 0;
       c4JAi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JAh() //  [R1]
         { info_tbl: [(c4JAh,
                       label: block_c4JAh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JAh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4JAD; else goto c4JAC;
       c4JAD: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4JAC: // global
           _s4IyR::I64 = %MO_SS_Conv_W32_W64(I32[I64[Sp + 8] + (I64[R1 + 7] << 2)]);
           I64[Hp - 16] = sat_s4IyT_info;
           I64[Hp] = _s4IyR::I64;
           R1 = Hp - 16;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.942306454 UTC

[section ""data" . Foreign.Storable.$fStorableBool2_closure" {
     Foreign.Storable.$fStorableBool2_closure:
         const Foreign.Storable.$fStorableBool2_info;
 },
 sat_s4Iz2_entry() //  [R1]
         { info_tbl: [(c4JBp,
                       label: sat_s4Iz2_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JBp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JBq; else goto c4JBr;
       c4JBq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JBr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c4JBo; else goto c4JBn;
       c4JBo: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4JBn: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableBool2_entry() //  [R2]
         { info_tbl: [(c4JBs,
                       label: Foreign.Storable.$fStorableBool2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JBs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4JBt; else goto c4JBu;
       c4JBt: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4JBu: // global
           I64[Sp - 8] = block_c4JBc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4JBy; else goto c4JBd;
       u4JBy: // global
           call _c4JBc(R1) args: 0, res: 0, upd: 0;
       c4JBd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JBc() //  [R1]
         { info_tbl: [(c4JBc,
                       label: block_c4JBc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JBc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4JBx; else goto c4JBw;
       c4JBx: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4JBw: // global
           _s4Iz0::I64 = %MO_SS_Conv_W32_W64(I32[I64[R1 + 7]]);
           I64[Hp - 16] = sat_s4Iz2_info;
           I64[Hp] = _s4Iz0::I64;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.952985427 UTC

[section ""data" . Foreign.Storable.$fStorableBool4_closure" {
     Foreign.Storable.$fStorableBool4_closure:
         const Foreign.Storable.$fStorableBool4_info;
 },
 sat_s4Izf_entry() //  [R1]
         { info_tbl: [(c4JCk,
                       label: sat_s4Izf_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JCk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JCl; else goto c4JCm;
       c4JCl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JCm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           if (I64[R1 + 16] == 0) goto c4JCj; else goto c4JCi;
       c4JCj: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       c4JCi: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableBool4_entry() //  [R2, R3]
         { info_tbl: [(c4JCn,
                       label: Foreign.Storable.$fStorableBool4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JCn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JCo; else goto c4JCp;
       c4JCo: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JCp: // global
           I64[Sp - 16] = block_c4JBZ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4JCv; else goto c4JC0;
       u4JCv: // global
           call _c4JBZ(R1) args: 0, res: 0, upd: 0;
       c4JC0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JBZ() //  [R1]
         { info_tbl: [(c4JBZ,
                       label: block_c4JBZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JBZ: // global
           I64[Sp] = block_c4JC4_info;
           _s4Iz7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Iz7::I64;
           if (R1 & 7 != 0) goto u4JCu; else goto c4JC5;
       u4JCu: // global
           call _c4JC4(R1) args: 0, res: 0, upd: 0;
       c4JC5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JC4() //  [R1]
         { info_tbl: [(c4JC4,
                       label: block_c4JC4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JC4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4JCt; else goto c4JCs;
       c4JCt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4JCs: // global
           _s4Izd::I64 = %MO_SS_Conv_W32_W64(I32[I64[Sp + 8] + I64[R1 + 7]]);
           I64[Hp - 16] = sat_s4Izf_info;
           I64[Hp] = _s4Izd::I64;
           R1 = Hp - 16;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.968283179 UTC

[section ""data" . Foreign.Storable.$fStorableBool1_closure" {
     Foreign.Storable.$fStorableBool1_closure:
         const Foreign.Storable.$fStorableBool1_info;
 },
 Foreign.Storable.$fStorableBool1_entry() //  [R2, R3]
         { info_tbl: [(c4JD5,
                       label: Foreign.Storable.$fStorableBool1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JD5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JD6; else goto c4JD7;
       c4JD6: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JD7: // global
           I64[Sp - 16] = block_c4JD2_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4JDp; else goto c4JD3;
       u4JDp: // global
           call _c4JD2(R1) args: 0, res: 0, upd: 0;
       c4JD3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JD2() //  [R1]
         { info_tbl: [(c4JD2,
                       label: block_c4JD2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JD2: // global
           I64[Sp] = block_c4JDa_info;
           _s4Izk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Izk::I64;
           if (R1 & 7 != 0) goto u4JDo; else goto c4JDc;
       u4JDo: // global
           call _c4JDa(R1) args: 0, res: 0, upd: 0;
       c4JDc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JDa() //  [R1]
         { info_tbl: [(c4JDa,
                       label: block_c4JDa_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JDa: // global
           _s4Izk::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto c4JDi; else goto c4JDm;
       c4JDi: // global
           I32[_s4Izk::I64] = 0 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4JDm: // global
           I32[_s4Izk::I64] = 1 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.976749373 UTC

[section ""data" . Foreign.Storable.$fStorableBool3_closure" {
     Foreign.Storable.$fStorableBool3_closure:
         const Foreign.Storable.$fStorableBool3_info;
 },
 Foreign.Storable.$fStorableBool3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4JDS,
                       label: Foreign.Storable.$fStorableBool3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JDS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4JDW; else goto c4JDX;
       c4JDW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableBool3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JDX: // global
           I64[Sp - 24] = block_c4JDP_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4JEk; else goto c4JDQ;
       u4JEk: // global
           call _c4JDP(R1) args: 0, res: 0, upd: 0;
       c4JDQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JDP() //  [R1]
         { info_tbl: [(c4JDP,
                       label: block_c4JDP_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JDP: // global
           I64[Sp] = block_c4JDV_info;
           _s4Izt::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4Izt::I64;
           if (R1 & 7 != 0) goto u4JEj; else goto c4JDZ;
       u4JEj: // global
           call _c4JDV(R1) args: 0, res: 0, upd: 0;
       c4JDZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JDV() //  [R1]
         { info_tbl: [(c4JDV,
                       label: block_c4JDV_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JDV: // global
           I64[Sp] = block_c4JE3_info;
           _s4Izv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4Izv::I64;
           if (R1 & 7 != 0) goto u4JEl; else goto c4JE5;
       u4JEl: // global
           call _c4JE3(R1) args: 0, res: 0, upd: 0;
       c4JE5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JE3() //  [R1]
         { info_tbl: [(c4JE3,
                       label: block_c4JE3_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JE3: // global
           _s4Izt::I64 = I64[Sp + 8];
           _s4Izv::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto c4JEb; else goto c4JEf;
       c4JEb: // global
           I32[_s4Izt::I64 + _s4Izv::I64] = 0 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4JEf: // global
           I32[_s4Izt::I64 + _s4Izv::I64] = 1 :: W32;
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.986626096 UTC

[section ""data" . Foreign.Storable.$fStorableBool_closure" {
     Foreign.Storable.$fStorableBool_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableBool_$csizeOf_closure+1;
         const Foreign.Storable.$fStorableBool_$csizeOf_closure+1;
         const Foreign.Storable.$fStorableBool6_closure+3;
         const Foreign.Storable.$fStorableBool5_closure+4;
         const Foreign.Storable.$fStorableBool4_closure+3;
         const Foreign.Storable.$fStorableBool3_closure+4;
         const Foreign.Storable.$fStorableBool2_closure+2;
         const Foreign.Storable.$fStorableBool1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.988810391 UTC

[section ""data" . Foreign.Storable.$fStorable()2_closure" {
     Foreign.Storable.$fStorable()2_closure:
         const Foreign.Storable.$fStorable()2_info;
 },
 Foreign.Storable.$fStorable()2_entry() //  []
         { info_tbl: [(c4JER,
                       label: Foreign.Storable.$fStorable()2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JER: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.99250126 UTC

[section ""data" . Foreign.Storable.$fStorable()1_closure" {
     Foreign.Storable.$fStorable()1_closure:
         const Foreign.Storable.$fStorable()1_info;
 },
 Foreign.Storable.$fStorable()1_entry() //  []
         { info_tbl: [(c4JF4,
                       label: Foreign.Storable.$fStorable()1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JF4: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.995942539 UTC

[section ""data" . lvl11_r4Ffl_closure" {
     lvl11_r4Ffl_closure:
         const GHC.Types.I#_con_info;
         const 137;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:37.998113211 UTC

[section ""data" . lvl12_r4Ffm_closure" {
     lvl12_r4Ffm_closure:
         const GHC.Types.I#_con_info;
         const 31;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.000252686 UTC

[section ""data" . lvl13_r4Ffn_closure" {
     lvl13_r4Ffn_closure:
         const GHC.Types.I#_con_info;
         const 40;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.002079141 UTC

[section ""data" . lvl14_r4Ffo_closure" {
     lvl14_r4Ffo_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r4Ffb_closure;
         const lvl3_r4Ffc_closure;
         const lvl5_r4Ffe_closure;
         const lvl11_r4Ffl_closure+1;
         const lvl12_r4Ffm_closure+1;
         const lvl11_r4Ffl_closure+1;
         const lvl13_r4Ffn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.010311933 UTC

[section ""data" . lvl15_r4Ffp_closure" {
     lvl15_r4Ffp_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r4Ffa_closure;
         const lvl14_r4Ffo_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.01297053 UTC

[section ""data" . lvl16_r4Ffq_closure" {
     lvl16_r4Ffq_closure:
         const lvl16_r4Ffq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_r4Ffq_entry() //  [R1]
         { info_tbl: [(c4JFo,
                       label: lvl16_r4Ffq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JFo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JFp; else goto c4JFq;
       c4JFp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JFq: // global
           (_c4JFl::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4JFl::I64 == 0) goto c4JFn; else goto c4JFm;
       c4JFn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4JFm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4JFl::I64;
           R2 = lvl15_r4Ffp_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.01788045 UTC

[section ""data" . Foreign.Storable.$dmpeekElemOff_closure" {
     Foreign.Storable.$dmpeekElemOff_closure:
         const Foreign.Storable.$dmpeekElemOff_info;
         const 0;
 },
 sat_s4IzO_entry() //  [R1]
         { info_tbl: [(c4JFK,
                       label: sat_s4IzO_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JFK: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c4JFV; else goto c4JFW;
       c4JFV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JFW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4JFH_info;
           _s4IzG::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s4IzG::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4JG1; else goto c4JFI;
       u4JG1: // global
           call _c4JFH(R1) args: 0, res: 0, upd: 0;
       c4JFI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4JFH() //  [R1]
         { info_tbl: [(c4JFH,
                       label: block_c4JFH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JFH: // global
           I64[Sp] = block_c4JFN_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = lvl16_r4Ffq_closure;
           I64[Sp + 8] = I64[R1 + 7];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c4JFN() //  [R1]
         { info_tbl: [(c4JFN,
                       label: block_c4JFN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JFN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JG0; else goto c4JFZ;
       c4JG0: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4JFZ: // global
           _s4IzN::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4IzN::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$dmpeekElemOff_entry() //  [R2, R3, R4]
         { info_tbl: [(c4JG2,
                       label: Foreign.Storable.$dmpeekElemOff_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JG2: // global
           _s4IzI::P64 = R4;
           _s4IzH::P64 = R3;
           _s4IzG::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c4JG3; else goto c4JG4;
       c4JG4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4JG6; else goto c4JG5;
       c4JG6: // global
           HpAlloc = 32;
           goto c4JG3;
       c4JG3: // global
           R4 = _s4IzI::P64;
           R3 = _s4IzH::P64;
           R2 = _s4IzG::P64;
           R1 = Foreign.Storable.$dmpeekElemOff_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JG5: // global
           I64[Hp - 24] = sat_s4IzO_info;
           P64[Hp - 8] = _s4IzG::P64;
           P64[Hp] = _s4IzI::P64;
           R2 = _s4IzG::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s4IzH::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call Foreign.Storable.peekByteOff_entry(R2) args: 32, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.029110064 UTC

[section ""data" . Foreign.Storable.$dmpokeElemOff_closure" {
     Foreign.Storable.$dmpokeElemOff_closure:
         const Foreign.Storable.$dmpokeElemOff_info;
 },
 sat_s4IzY_entry() //  [R1]
         { info_tbl: [(c4JGL,
                       label: sat_s4IzY_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JGL: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c4JGW; else goto c4JGX;
       c4JGW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JGX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4JGI_info;
           _s4IzP::P64 = P64[R1 + 16];
           _s4IzS::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _s4IzP::P64;
           P64[Sp - 24] = _s4IzS::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u4JH2; else goto c4JGJ;
       u4JH2: // global
           call _c4JGI(R1) args: 0, res: 0, upd: 0;
       c4JGJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4JGI() //  [R1]
         { info_tbl: [(c4JGI,
                       label: block_c4JGI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JGI: // global
           _s4IzP::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4JGO_info;
           R2 = _s4IzP::P64;
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = P64[Sp + 16];
           I64[Sp + 16] = I64[R1 + 7];
           Sp = Sp - 8;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c4JGO() //  [R1]
         { info_tbl: [(c4JGO,
                       label: block_c4JGO_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JGO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JH1; else goto c4JH0;
       c4JH1: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4JH0: // global
           _s4IzX::I64 = I64[Sp + 8] * I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4IzX::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$dmpokeElemOff_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c4JH3,
                       label: Foreign.Storable.$dmpokeElemOff_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JH3: // global
           _s4IzS::P64 = R5;
           _s4IzR::P64 = R4;
           _s4IzQ::P64 = R3;
           _s4IzP::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto c4JH4; else goto c4JH5;
       c4JH5: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4JH7; else goto c4JH6;
       c4JH7: // global
           HpAlloc = 40;
           goto c4JH4;
       c4JH4: // global
           R5 = _s4IzS::P64;
           R4 = _s4IzR::P64;
           R3 = _s4IzQ::P64;
           R2 = _s4IzP::P64;
           R1 = Foreign.Storable.$dmpokeElemOff_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JH6: // global
           I64[Hp - 32] = sat_s4IzY_info;
           P64[Hp - 16] = _s4IzP::P64;
           P64[Hp - 8] = _s4IzR::P64;
           P64[Hp] = _s4IzS::P64;
           R2 = _s4IzP::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _s4IzQ::P64;
           P64[Sp - 16] = Hp - 32;
           P64[Sp - 8] = _s4IzS::P64;
           Sp = Sp - 32;
           call Foreign.Storable.pokeByteOff_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.039918523 UTC

[section ""data" . Foreign.Storable.$fStorable()4_closure" {
     Foreign.Storable.$fStorable()4_closure:
         const Foreign.Storable.$fStorable()4_info;
 },
 Foreign.Storable.$fStorable()4_entry() //  []
         { info_tbl: [(c4JHF,
                       label: Foreign.Storable.$fStorable()4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JHF: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.043635238 UTC

[section ""data" . Foreign.Storable.$fStorable()6_closure" {
     Foreign.Storable.$fStorable()6_closure:
         const Foreign.Storable.$fStorable()6_info;
 },
 Foreign.Storable.$fStorable()6_entry() //  []
         { info_tbl: [(c4JHS,
                       label: Foreign.Storable.$fStorable()6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JHS: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.047917299 UTC

[section ""data" . Foreign.Storable.$fStorable()3_closure" {
     Foreign.Storable.$fStorable()3_closure:
         const Foreign.Storable.$fStorable()3_info;
 },
 Foreign.Storable.$fStorable()3_entry() //  []
         { info_tbl: [(c4JI5,
                       label: Foreign.Storable.$fStorable()3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JI5: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.052916819 UTC

[section ""data" . Foreign.Storable.$fStorable()5_closure" {
     Foreign.Storable.$fStorable()5_closure:
         const Foreign.Storable.$fStorable()5_info;
 },
 Foreign.Storable.$fStorable()5_entry() //  []
         { info_tbl: [(c4JIi,
                       label: Foreign.Storable.$fStorable()5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JIi: // global
           R1 = GHC.Tuple.()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.056517593 UTC

[section ""data" . Foreign.Storable.$fStorable()_closure" {
     Foreign.Storable.$fStorable()_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorable()_$csizeOf_closure+1;
         const Foreign.Storable.$fStorable()_$calignment_closure+1;
         const Foreign.Storable.$fStorable()6_closure+3;
         const Foreign.Storable.$fStorable()5_closure+4;
         const Foreign.Storable.$fStorable()4_closure+3;
         const Foreign.Storable.$fStorable()3_closure+4;
         const Foreign.Storable.$fStorable()2_closure+2;
         const Foreign.Storable.$fStorable()1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.05905243 UTC

[section ""data" . lvl17_r4Ffr_closure" {
     lvl17_r4Ffr_closure:
         const GHC.Types.I#_con_info;
         const 237;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.061699604 UTC

[section ""data" . lvl18_r4Ffs_closure" {
     lvl18_r4Ffs_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r4Ffb_closure;
         const lvl3_r4Ffc_closure;
         const lvl5_r4Ffe_closure;
         const lvl17_r4Ffr_closure+1;
         const lvl12_r4Ffm_closure+1;
         const lvl17_r4Ffr_closure+1;
         const lvl13_r4Ffn_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.064299472 UTC

[section ""data" . lvl19_r4Fft_closure" {
     lvl19_r4Fft_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r4Ffa_closure;
         const lvl18_r4Ffs_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.06743068 UTC

[section ""data" . Foreign.Storable.$fStorableRatio6_closure" {
     Foreign.Storable.$fStorableRatio6_closure:
         const Foreign.Storable.$fStorableRatio6_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.Storable.$fStorableRatio6_entry() //  [R1]
         { info_tbl: [(c4JIB,
                       label: Foreign.Storable.$fStorableRatio6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JIB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JIC; else goto c4JID;
       c4JIC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JID: // global
           (_c4JIy::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4JIy::I64 == 0) goto c4JIA; else goto c4JIz;
       c4JIA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4JIz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4JIy::I64;
           R2 = lvl19_r4Fft_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.075893535 UTC

[section ""data" . Foreign.Storable.$fStorableRatio_$csizeOf_closure" {
     Foreign.Storable.$fStorableRatio_$csizeOf_closure:
         const Foreign.Storable.$fStorableRatio_$csizeOf_info;
         const 0;
 },
 lvl20_s4IAf_entry() //  [R1]
         { info_tbl: [(c4JIU,
                       label: lvl20_s4IAf_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JIU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4JIV; else goto c4JIW;
       c4JIV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JIW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.Storable.$fStorableRatio6_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s4IAk_entry() //  [R1, R2]
         { info_tbl: [(c4JJ5,
                       label: sat_s4IAk_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JJ5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4JJc; else goto c4JJd;
       c4JJc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4JJd: // global
           I64[Sp - 8] = block_c4JJ2_info;
           R1 = P64[R1 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4JJh; else goto c4JJ3;
       u4JJh: // global
           call _c4JJ2(R1) args: 0, res: 0, upd: 0;
       c4JJ3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JJ2() //  [R1]
         { info_tbl: [(c4JJ2,
                       label: block_c4JJ2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JJ2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JJg; else goto c4JJf;
       c4JJg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4JJf: // global
           _s4IAj::I64 = I64[R1 + 7] << 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s4IAj::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Storable.$fStorableRatio_$csizeOf_entry() //  [R2, R3]
         { info_tbl: [(c4JJi,
                       label: Foreign.Storable.$fStorableRatio_$csizeOf_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JJi: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4JJm; else goto c4JJl;
       c4JJm: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio_$csizeOf_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JJl: // global
           I64[Hp - 32] = lvl20_s4IAf_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s4IAk_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.08921897 UTC

[section ""data" . Foreign.Storable.$fStorableRatio4_closure" {
     Foreign.Storable.$fStorableRatio4_closure:
         const Foreign.Storable.$fStorableRatio4_info;
         const 0;
 },
 sat_s4IAv_entry() //  [R1]
         { info_tbl: [(c4JJY,
                       label: sat_s4IAv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JJY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4JKa; else goto c4JKb;
       c4JKa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JKb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4JJV_info;
           _s4IAo::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4IAo::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4JKh; else goto c4JJW;
       u4JKh: // global
           call _c4JJV(R1) args: 0, res: 0, upd: 0;
       c4JJW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4JJV() //  [R1]
         { info_tbl: [(c4JJV,
                       label: block_c4JJV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JJV: // global
           I64[Sp] = block_c4JK1_info;
           _s4IAr::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IAr::I64;
           if (R1 & 7 != 0) goto u4JKg; else goto c4JK2;
       u4JKg: // global
           call _c4JK1(R1) args: 0, res: 0, upd: 0;
       c4JK2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4JK1() //  [R1]
         { info_tbl: [(c4JK1,
                       label: block_c4JK1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JK1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JKf; else goto c4JKe;
       c4JKf: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4JKe: // global
           _s4IAu::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4IAu::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableRatio4_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c4JKi,
                       label: Foreign.Storable.$fStorableRatio4_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JKi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4JKm; else goto c4JKl;
       c4JKm: // global
           HpAlloc = 32;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio4_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JKl: // global
           I64[Hp - 24] = sat_s4IAv_info;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R4 = Hp - 24;
           R3 = R3;
           R2 = R2;
           call Foreign.Storable.$fStorableRatio2_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.1035454 UTC

[section ""data" . Foreign.Storable.$fStorableRatio7_closure" {
     Foreign.Storable.$fStorableRatio7_closure:
         const Foreign.Storable.$fStorableRatio7_info;
         const 0;
 },
 sat_s4IAK_entry() //  [R1]
         { info_tbl: [(c4JKW,
                       label: sat_s4IAK_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JKW: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c4JLi; else goto c4JLj;
       c4JLi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JLj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4JKT_info;
           _s4IAw::P64 = P64[R1 + 16];
           _s4IAz::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _s4IAw::P64;
           P64[Sp - 24] = _s4IAz::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u4JLq; else goto c4JKU;
       u4JLq: // global
           call _c4JKT(R1) args: 0, res: 0, upd: 0;
       c4JKU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4JKT() //  [R1]
         { info_tbl: [(c4JKT,
                       label: block_c4JKT_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JKT: // global
           I64[Sp] = block_c4JKZ_info;
           _s4IAC::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4IAC::I64;
           if (R1 & 7 != 0) goto u4JLp; else goto c4JL0;
       u4JLp: // global
           call _c4JKZ(R1) args: 0, res: 0, upd: 0;
       c4JL0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4JKZ() //  [R1]
         { info_tbl: [(c4JKZ,
                       label: block_c4JKZ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JKZ: // global
           I64[Sp] = block_c4JL4_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Foreign.Storable.$fStorableRatio6_closure;
           I64[Sp + 8] = I64[R1 + 7];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c4JL4() //  [R1]
         { info_tbl: [(c4JL4,
                       label: block_c4JL4_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JL4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JLo; else goto c4JLn;
       c4JLo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4JLn: // global
           _s4IAJ::I64 = I64[Sp + 16] + I64[Sp + 8] * (I64[R1 + 7] << 1);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4IAJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableRatio7_entry() //  [R2, R3, R4, R5]
         { info_tbl: [(c4JLr,
                       label: Foreign.Storable.$fStorableRatio7_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JLr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4JLv; else goto c4JLu;
       c4JLv: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio7_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JLu: // global
           I64[Hp - 32] = sat_s4IAK_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R4 = Hp - 32;
           R3 = R3;
           R2 = R2;
           call Foreign.Storable.$fStorableRatio2_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.118125097 UTC

[section ""data" . Foreign.Storable.$w$cpokeByteOff_closure" {
     Foreign.Storable.$w$cpokeByteOff_closure:
         const Foreign.Storable.$w$cpokeByteOff_info;
 },
 p_s4IAR_entry() //  [R1]
         { info_tbl: [(c4JMe,
                       label: p_s4IAR_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JMe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4JMq; else goto c4JMr;
       c4JMq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JMr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4JMb_info;
           _s4IAN::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4IAN::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4JMx; else goto c4JMc;
       u4JMx: // global
           call _c4JMb(R1) args: 0, res: 0, upd: 0;
       c4JMc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4JMb() //  [R1]
         { info_tbl: [(c4JMb,
                       label: block_c4JMb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JMb: // global
           I64[Sp] = block_c4JMh_info;
           _s4IAT::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IAT::I64;
           if (R1 & 7 != 0) goto u4JMw; else goto c4JMi;
       u4JMw: // global
           call _c4JMh(R1) args: 0, res: 0, upd: 0;
       c4JMi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4JMh() //  [R1]
         { info_tbl: [(c4JMh,
                       label: block_c4JMh_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JMh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JMv; else goto c4JMu;
       c4JMv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4JMu: // global
           _s4IAW::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4IAW::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$w$cpokeByteOff_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c4JMA,
                       label: Foreign.Storable.$w$cpokeByteOff_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JMA: // global
           _s4IAP::P64 = R6;
           _s4IAO::P64 = R5;
           _s4IAN::P64 = R4;
           _s4IAM::P64 = R3;
           _s4IAL::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto c4JMB; else goto c4JMC;
       c4JMC: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4JME; else goto c4JMD;
       c4JME: // global
           HpAlloc = 32;
           goto c4JMB;
       c4JMB: // global
           R6 = _s4IAP::P64;
           R5 = _s4IAO::P64;
           R4 = _s4IAN::P64;
           R3 = _s4IAM::P64;
           R2 = _s4IAL::P64;
           R1 = Foreign.Storable.$w$cpokeByteOff_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JMD: // global
           I64[Hp - 24] = p_s4IAR_info;
           P64[Hp - 8] = _s4IAM::P64;
           P64[Hp] = _s4IAN::P64;
           I64[Sp - 32] = block_c4JMy_info;
           R2 = _s4IAL::P64;
           I64[Sp - 56] = stg_ap_ppv_info;
           _c4JM7::P64 = Hp - 24;
           P64[Sp - 48] = _c4JM7::P64;
           P64[Sp - 40] = _s4IAO::P64;
           P64[Sp - 24] = _c4JM7::P64;
           P64[Sp - 16] = _s4IAL::P64;
           P64[Sp - 8] = _s4IAP::P64;
           Sp = Sp - 56;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c4JMy() //  []
         { info_tbl: [(c4JMy,
                       label: block_c4JMy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JMy: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppv_info;
           P64[Sp + 16] = Foreign.Storable.$fStorable()7_closure+1;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.131074749 UTC

[section ""data" . Foreign.Storable.$fStorableRatio3_closure" {
     Foreign.Storable.$fStorableRatio3_closure:
         const Foreign.Storable.$fStorableRatio3_info;
 },
 Foreign.Storable.$fStorableRatio3_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c4JNj,
                       label: Foreign.Storable.$fStorableRatio3_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JNj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4JNk; else goto c4JNl;
       c4JNk: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JNl: // global
           I64[Sp - 32] = block_c4JNg_info;
           R1 = R6;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4JNp; else goto c4JNh;
       u4JNp: // global
           call _c4JNg(R1) args: 0, res: 0, upd: 0;
       c4JNh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JNg() //  [R1]
         { info_tbl: [(c4JNg,
                       label: block_c4JNg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JNg: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Foreign.Storable.$w$cpokeByteOff_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.141880101 UTC

[section ""data" . Foreign.Storable.$w$cpokeElemOff_closure" {
     Foreign.Storable.$w$cpokeElemOff_closure:
         const Foreign.Storable.$w$cpokeElemOff_info;
         const 0;
 },
 p_s4IBf_entry() //  [R1]
         { info_tbl: [(c4JNL,
                       label: p_s4IBf_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JNL: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c4JO7; else goto c4JO8;
       c4JO7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JO8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4JNI_info;
           _s4IB9::P64 = P64[R1 + 16];
           _s4IBb::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _s4IB9::P64;
           P64[Sp - 24] = _s4IBb::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u4JOf; else goto c4JNJ;
       u4JOf: // global
           call _c4JNI(R1) args: 0, res: 0, upd: 0;
       c4JNJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4JNI() //  [R1]
         { info_tbl: [(c4JNI,
                       label: block_c4JNI_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JNI: // global
           I64[Sp] = block_c4JNO_info;
           _s4IBh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4IBh::I64;
           if (R1 & 7 != 0) goto u4JOe; else goto c4JNP;
       u4JOe: // global
           call _c4JNO(R1) args: 0, res: 0, upd: 0;
       c4JNP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4JNO() //  [R1]
         { info_tbl: [(c4JNO,
                       label: block_c4JNO_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JNO: // global
           I64[Sp] = block_c4JNT_info;
           R2 = P64[Sp + 8];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Foreign.Storable.$fStorableRatio6_closure;
           I64[Sp + 8] = I64[R1 + 7];
           Sp = Sp - 16;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 24;
     }
 },
 _c4JNT() //  [R1]
         { info_tbl: [(c4JNT,
                       label: block_c4JNT_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JNT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JOd; else goto c4JOc;
       c4JOd: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4JOc: // global
           _s4IBo::I64 = I64[Sp + 16] + I64[Sp + 8] * (I64[R1 + 7] << 1);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4IBo::I64;
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$w$cpokeElemOff_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c4JOi,
                       label: Foreign.Storable.$w$cpokeElemOff_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JOi: // global
           _s4IBd::P64 = R6;
           _s4IBc::P64 = R5;
           _s4IBb::P64 = R4;
           _s4IBa::P64 = R3;
           _s4IB9::P64 = R2;
           if ((Sp + -56) < SpLim) (likely: False) goto c4JOj; else goto c4JOk;
       c4JOk: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4JOm; else goto c4JOl;
       c4JOm: // global
           HpAlloc = 40;
           goto c4JOj;
       c4JOj: // global
           R6 = _s4IBd::P64;
           R5 = _s4IBc::P64;
           R4 = _s4IBb::P64;
           R3 = _s4IBa::P64;
           R2 = _s4IB9::P64;
           R1 = Foreign.Storable.$w$cpokeElemOff_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JOl: // global
           I64[Hp - 32] = p_s4IBf_info;
           P64[Hp - 16] = _s4IB9::P64;
           P64[Hp - 8] = _s4IBa::P64;
           P64[Hp] = _s4IBb::P64;
           I64[Sp - 32] = block_c4JOg_info;
           R2 = _s4IB9::P64;
           I64[Sp - 56] = stg_ap_ppv_info;
           _c4JNE::P64 = Hp - 32;
           P64[Sp - 48] = _c4JNE::P64;
           P64[Sp - 40] = _s4IBc::P64;
           P64[Sp - 24] = _c4JNE::P64;
           P64[Sp - 16] = _s4IB9::P64;
           P64[Sp - 8] = _s4IBd::P64;
           Sp = Sp - 56;
           call Foreign.Storable.poke_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 _c4JOg() //  []
         { info_tbl: [(c4JOg,
                       label: block_c4JOg_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JOg: // global
           R2 = P64[Sp + 16];
           I64[Sp] = stg_ap_pppv_info;
           P64[Sp + 16] = Foreign.Storable.$fStorable()7_closure+1;
           call Foreign.Storable.pokeElemOff_entry(R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.16195868 UTC

[section ""data" . Foreign.Storable.$fStorableRatio5_closure" {
     Foreign.Storable.$fStorableRatio5_closure:
         const Foreign.Storable.$fStorableRatio5_info;
         const 0;
 },
 Foreign.Storable.$fStorableRatio5_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c4JPa,
                       label: Foreign.Storable.$fStorableRatio5_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JPa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4JPb; else goto c4JPc;
       c4JPb: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JPc: // global
           I64[Sp - 32] = block_c4JP7_info;
           R1 = R6;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4JPg; else goto c4JP8;
       u4JPg: // global
           call _c4JP7(R1) args: 0, res: 0, upd: 0;
       c4JP8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JP7() //  [R1]
         { info_tbl: [(c4JP7,
                       label: block_c4JP7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JP7: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Foreign.Storable.$w$cpokeElemOff_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.171466021 UTC

[section ""data" . Foreign.Storable.$fStorableRatio_closure" {
     Foreign.Storable.$fStorableRatio_closure:
         const Foreign.Storable.$fStorableRatio_info;
         const 0;
 },
 sat_s4IBK_entry() //  [R1, R2, R3]
         { info_tbl: [(c4JPA,
                       label: sat_s4IBK_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JPA: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Foreign.Storable.$fStorableRatio1_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4IBJ_entry() //  [R1, R2]
         { info_tbl: [(c4JPI,
                       label: sat_s4IBJ_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JPI: // global
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call Foreign.Storable.$fStorableRatio2_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4IBI_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c4JPQ,
                       label: sat_s4IBI_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JPQ: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           call Foreign.Storable.$fStorableRatio3_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4IBH_entry() //  [R1, R2, R3]
         { info_tbl: [(c4JPY,
                       label: sat_s4IBH_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JPY: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Foreign.Storable.$fStorableRatio4_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4IBG_entry() //  [R1, R2, R3, R4]
         { info_tbl: [(c4JQ6,
                       label: sat_s4IBG_info
                       rep:HeapRep 2 ptrs { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JQ6: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 12];
           R2 = P64[R1 + 4];
           call Foreign.Storable.$fStorableRatio5_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4IBF_entry() //  [R1, R2, R3]
         { info_tbl: [(c4JQe,
                       label: sat_s4IBF_info
                       rep:HeapRep 2 ptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JQe: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call Foreign.Storable.$fStorableRatio7_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4IBE_entry() //  [R1]
         { info_tbl: [(c4JQl,
                       label: sat_s4IBE_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JQl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JQm; else goto c4JQn;
       c4JQm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JQn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.$fStorableRatio_$calignment_entry(R3,
                                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4IBD_entry() //  [R1]
         { info_tbl: [(c4JQs,
                       label: sat_s4IBD_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JQs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JQt; else goto c4JQu;
       c4JQt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JQu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call Foreign.Storable.$fStorableRatio_$csizeOf_entry(R3,
                                                                R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableRatio_entry() //  [R2, R3]
         { info_tbl: [(c4JQw,
                       label: Foreign.Storable.$fStorableRatio_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JQw: // global
           Hp = Hp + 280;
           if (Hp > HpLim) (likely: False) goto c4JQA; else goto c4JQz;
       c4JQA: // global
           HpAlloc = 280;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableRatio_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JQz: // global
           I64[Hp - 272] = sat_s4IBK_info;
           P64[Hp - 264] = R2;
           P64[Hp - 256] = R3;
           I64[Hp - 248] = sat_s4IBJ_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           I64[Hp - 224] = sat_s4IBI_info;
           P64[Hp - 216] = R2;
           P64[Hp - 208] = R3;
           I64[Hp - 200] = sat_s4IBH_info;
           P64[Hp - 192] = R2;
           P64[Hp - 184] = R3;
           I64[Hp - 176] = sat_s4IBG_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           I64[Hp - 152] = sat_s4IBF_info;
           P64[Hp - 144] = R2;
           P64[Hp - 136] = R3;
           I64[Hp - 128] = sat_s4IBE_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_s4IBD_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = Foreign.Storable.C:Storable_con_info;
           P64[Hp - 56] = Hp - 96;
           P64[Hp - 48] = Hp - 128;
           P64[Hp - 40] = Hp - 149;
           P64[Hp - 32] = Hp - 172;
           P64[Hp - 24] = Hp - 197;
           P64[Hp - 16] = Hp - 220;
           P64[Hp - 8] = Hp - 246;
           P64[Hp] = Hp - 269;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.194360006 UTC

[section ""data" . Foreign.Storable.$wpokeW64_closure" {
     Foreign.Storable.$wpokeW64_closure:
         const Foreign.Storable.$wpokeW64_info;
 },
 Foreign.Storable.$wpokeW64_entry() //  [R2, R3, R4]
         { info_tbl: [(c4JRS,
                       label: Foreign.Storable.$wpokeW64_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JRS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4JRT; else goto u4JS0;
       c4JRT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$wpokeW64_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       u4JS0: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c4JRq() args: 0, res: 0, upd: 0;
     }
 },
 _c4JRq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JRq: // global
           _s4IBP::I64 = I64[Sp + 8];
           if (_s4IBP::I64 != 0) goto c4JRQ; else goto c4JRR;
       c4JRQ: // global
           I64[Sp - 8] = block_c4JRv_info;
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s4IBP::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4JS2; else goto c4JRw;
       u4JS2: // global
           call _c4JRv(R1) args: 0, res: 0, upd: 0;
       c4JRw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4JRR: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4JRv() //  [R1]
         { info_tbl: [(c4JRv,
                       label: block_c4JRv_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JRv: // global
           _s4IBL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4JRA_info;
           _s4IBR::I64 = I64[R1 + 7];
           R1 = _s4IBL::P64;
           I64[Sp + 16] = _s4IBR::I64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u4JS3; else goto c4JRB;
       u4JS3: // global
           call _c4JRA(R1) args: 0, res: 0, upd: 0;
       c4JRB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JRA() //  [R1]
         { info_tbl: [(c4JRA,
                       label: block_c4JRA_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JRA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JRY; else goto c4JRX;
       c4JRY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4JRX: // global
           _s4IBP::I64 = I64[Sp + 16];
           _s4IBR::I64 = I64[Sp + 8];
           I8[I64[R1 + 7] + (_s4IBP::I64 + -1)] = %MO_UU_Conv_W64_W8(_s4IBR::I64);
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4IBR::I64 >> 8;
           P64[Sp] = R1;
           I64[Sp + 8] = _s4IBP::I64 - 1;
           P64[Sp + 16] = Hp - 7;
           call _c4JRq() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.205443351 UTC

[section ""data" . Foreign.Storable.$w$cpoke_closure" {
     Foreign.Storable.$w$cpoke_closure:
         const Foreign.Storable.$w$cpoke_info;
 },
 sat_s4ICb_entry() //  [R1]
         { info_tbl: [(c4JSL,
                       label: sat_s4ICb_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JSL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4JSS; else goto c4JST;
       c4JSS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JST: // global
           I64[Sp - 8] = block_c4JSI_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4JSX; else goto c4JSJ;
       u4JSX: // global
           call _c4JSI(R1) args: 0, res: 0, upd: 0;
       c4JSJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JSI() //  [R1]
         { info_tbl: [(c4JSI,
                       label: block_c4JSI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JSI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JSW; else goto c4JSV;
       c4JSW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4JSV: // global
           _s4ICa::I64 = I64[R1 + 7] + 8;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4ICa::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.Storable.$w$cpoke_entry() //  [R2, R3, R4]
         { info_tbl: [(c4JSY,
                       label: Foreign.Storable.$w$cpoke_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 20} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JSY: // global
           _s4IC2::I64 = R4;
           _s4IC1::I64 = R3;
           _s4IC0::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto c4JSZ; else goto c4JT0;
       c4JT0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JT2; else goto c4JT1;
       c4JT2: // global
           HpAlloc = 16;
           goto c4JSZ;
       c4JSZ: // global
           R4 = _s4IC2::I64;
           R3 = _s4IC1::I64;
           R2 = _s4IC0::P64;
           R1 = Foreign.Storable.$w$cpoke_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JT1: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _s4IC1::I64;
           I64[Sp - 24] = block_c4JSB_info;
           R4 = Hp - 7;
           R3 = 8;
           R2 = _s4IC0::P64;
           P64[Sp - 16] = _s4IC0::P64;
           I64[Sp - 8] = _s4IC2::I64;
           Sp = Sp - 24;
           call Foreign.Storable.$wpokeW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4JSB() //  [R1]
         { info_tbl: [(c4JSB,
                       label: block_c4JSB_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JSB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4JT5; else goto c4JT4;
       c4JT5: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4JT4: // global
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           I64[Hp - 24] = I64[Sp + 16];
           I64[Hp - 16] = sat_s4ICb_info;
           P64[Hp] = P64[Sp + 8];
           R4 = Hp - 31;
           R3 = 8;
           R2 = Hp - 16;
           Sp = Sp + 24;
           call Foreign.Storable.$wpokeW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.216751593 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint1_closure" {
     Foreign.Storable.$fStorableFingerprint1_closure:
         const Foreign.Storable.$fStorableFingerprint1_info;
 },
 Foreign.Storable.$fStorableFingerprint1_entry() //  [R2, R3]
         { info_tbl: [(c4JTD,
                       label: Foreign.Storable.$fStorableFingerprint1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JTD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JTE; else goto c4JTF;
       c4JTE: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JTF: // global
           I64[Sp - 16] = block_c4JTA_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u4JTJ; else goto c4JTB;
       u4JTJ: // global
           call _c4JTA(R1) args: 0, res: 0, upd: 0;
       c4JTB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JTA() //  [R1]
         { info_tbl: [(c4JTA,
                       label: block_c4JTA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JTA: // global
           R4 = I64[R1 + 15];
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.Storable.$w$cpoke_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.224947012 UTC

[section ""data" . Foreign.Storable.$wpeekW64_closure" {
     Foreign.Storable.$wpeekW64_closure:
         const Foreign.Storable.$wpeekW64_info;
 },
 Foreign.Storable.$wpeekW64_entry() //  [R2, R3, R4]
         { info_tbl: [(c4JUl,
                       label: Foreign.Storable.$wpeekW64_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 20} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JUl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto u4JUw; else goto u4JUv;
       u4JUw: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c4JUm() args: 0, res: 0, upd: 0;
       u4JUv: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _c4JTV() args: 0, res: 0, upd: 0;
     }
 },
 _c4JTV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JTV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JUp; else goto c4JUo;
       c4JUp: // global
           HpAlloc = 16;
           call _c4JUm() args: 0, res: 0, upd: 0;
       c4JUo: // global
           _s4ICn::I64 = I64[Sp + 8];
           if (_s4ICn::I64 != 0) goto c4JUj; else goto c4JUk;
       c4JUj: // global
           Hp = Hp - 16;
           _s4ICj::P64 = P64[Sp];
           I64[Sp] = block_c4JU0_info;
           R1 = _s4ICj::P64;
           I64[Sp + 8] = _s4ICn::I64;
           if (R1 & 7 != 0) goto u4JUy; else goto c4JU1;
       u4JUy: // global
           call _c4JU0(R1) args: 0, res: 0, upd: 0;
       c4JU1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c4JUk: // global
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 7;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4JUm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JUm: // global
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = P64[Sp];
           R1 = Foreign.Storable.$wpeekW64_closure;
           Sp = Sp + 24;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4JU0() //  [R1]
         { info_tbl: [(c4JU0,
                       label: block_c4JU0_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JU0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JUs; else goto c4JUr;
       c4JUs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4JUr: // global
           _s4ICp::I64 = I64[R1 + 7];
           _s4ICx::I64 = (I64[Sp + 16] << 8) | %MO_UU_Conv_W8_W64(I8[_s4ICp::I64]);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4ICp::I64 + 1;
           P64[Sp] = Hp - 7;
           I64[Sp + 8] = I64[Sp + 8] - 1;
           I64[Sp + 16] = _s4ICx::I64;
           call _c4JTV() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.238476909 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint2_closure" {
     Foreign.Storable.$fStorableFingerprint2_closure:
         const Foreign.Storable.$fStorableFingerprint2_info;
 },
 sat_s4ICH_entry() //  [R1]
         { info_tbl: [(c4JVc,
                       label: sat_s4ICH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JVc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4JVj; else goto c4JVk;
       c4JVj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JVk: // global
           I64[Sp - 8] = block_c4JV9_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4JVo; else goto c4JVa;
       u4JVo: // global
           call _c4JV9(R1) args: 0, res: 0, upd: 0;
       c4JVa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JV9() //  [R1]
         { info_tbl: [(c4JV9,
                       label: block_c4JV9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JV9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JVn; else goto c4JVm;
       c4JVn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4JVm: // global
           _s4ICG::I64 = I64[R1 + 7] + 8;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4ICG::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4ICL_entry() //  [R1]
         { info_tbl: [(c4JVv,
                       label: sat_s4ICL_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JVv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JVw; else goto c4JVx;
       c4JVw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JVx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Fingerprint.Type.$WFingerprint_entry(R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableFingerprint2_entry() //  [R2]
         { info_tbl: [(c4JVy,
                       label: Foreign.Storable.$fStorableFingerprint2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JVy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4JVz; else goto c4JVA;
       c4JVz: // global
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4JVA: // global
           I64[Sp - 16] = block_c4JV3_info;
           R4 = 0;
           R3 = 8;
           _s4ICz::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s4ICz::P64;
           Sp = Sp - 16;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4JV3() //  [R1]
         { info_tbl: [(c4JV3,
                       label: block_c4JV3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JV3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4JVD; else goto c4JVC;
       c4JVD: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4JVC: // global
           I64[Hp - 16] = sat_s4ICH_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp] = block_c4JVp_info;
           R4 = 0;
           R3 = 8;
           R2 = Hp - 16;
           P64[Sp + 8] = R1;
           call Foreign.Storable.$wpeekW64_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4JVp() //  [R1]
         { info_tbl: [(c4JVp,
                       label: block_c4JVp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JVp: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4JVG; else goto c4JVF;
       c4JVG: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4JVF: // global
           I64[Hp - 24] = sat_s4ICL_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.262497255 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint4_closure" {
     Foreign.Storable.$fStorableFingerprint4_closure:
         const Foreign.Storable.$fStorableFingerprint4_info;
 },
 sat_s4ICU_entry() //  [R1]
         { info_tbl: [(c4JWr,
                       label: sat_s4ICU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JWr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4JWD; else goto c4JWE;
       c4JWD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JWE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4JWo_info;
           _s4ICN::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4ICN::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4JWK; else goto c4JWp;
       u4JWK: // global
           call _c4JWo(R1) args: 0, res: 0, upd: 0;
       c4JWp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4JWo() //  [R1]
         { info_tbl: [(c4JWo,
                       label: block_c4JWo_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JWo: // global
           I64[Sp] = block_c4JWu_info;
           _s4ICQ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ICQ::I64;
           if (R1 & 7 != 0) goto u4JWJ; else goto c4JWv;
       u4JWJ: // global
           call _c4JWu(R1) args: 0, res: 0, upd: 0;
       c4JWv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4JWu() //  [R1]
         { info_tbl: [(c4JWu,
                       label: block_c4JWu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JWu: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JWI; else goto c4JWH;
       c4JWI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4JWH: // global
           _s4ICT::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4ICT::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableFingerprint4_entry() //  [R2, R3]
         { info_tbl: [(c4JWL,
                       label: Foreign.Storable.$fStorableFingerprint4_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JWL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4JWP; else goto c4JWO;
       c4JWP: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint4_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JWO: // global
           I64[Hp - 24] = sat_s4ICU_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           call Foreign.Storable.$fStorableFingerprint2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.279473722 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint6_closure" {
     Foreign.Storable.$fStorableFingerprint6_closure:
         const Foreign.Storable.$fStorableFingerprint6_info;
 },
 sat_s4ID4_entry() //  [R1]
         { info_tbl: [(c4JXp,
                       label: sat_s4ID4_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JXp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4JXE; else goto c4JXF;
       c4JXE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JXF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4JXm_info;
           _s4ICW::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4ICW::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4JXL; else goto c4JXn;
       u4JXL: // global
           call _c4JXm(R1) args: 0, res: 0, upd: 0;
       c4JXn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4JXm() //  [R1]
         { info_tbl: [(c4JXm,
                       label: block_c4JXm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JXm: // global
           I64[Sp] = block_c4JXs_info;
           _s4ICZ::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4ICZ::I64;
           if (R1 & 7 != 0) goto u4JXK; else goto c4JXt;
       u4JXK: // global
           call _c4JXs(R1) args: 0, res: 0, upd: 0;
       c4JXt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4JXs() //  [R1]
         { info_tbl: [(c4JXs,
                       label: block_c4JXs_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JXs: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JXJ; else goto c4JXI;
       c4JXJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4JXI: // global
           _s4ID3::I64 = I64[Sp + 8] + (I64[R1 + 7] << 4);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4ID3::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableFingerprint6_entry() //  [R2, R3]
         { info_tbl: [(c4JXM,
                       label: Foreign.Storable.$fStorableFingerprint6_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JXM: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4JXQ; else goto c4JXP;
       c4JXQ: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint6_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JXP: // global
           I64[Hp - 24] = sat_s4ID4_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           call Foreign.Storable.$fStorableFingerprint2_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.296708876 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint3_closure" {
     Foreign.Storable.$fStorableFingerprint3_closure:
         const Foreign.Storable.$fStorableFingerprint3_info;
 },
 sat_s4IDh_entry() //  [R1]
         { info_tbl: [(c4JYv,
                       label: sat_s4IDh_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JYv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4JYH; else goto c4JYI;
       c4JYH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JYI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4JYs_info;
           _s4ID6::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4ID6::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4JYO; else goto c4JYt;
       u4JYO: // global
           call _c4JYs(R1) args: 0, res: 0, upd: 0;
       c4JYt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4JYs() //  [R1]
         { info_tbl: [(c4JYs,
                       label: block_c4JYs_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JYs: // global
           I64[Sp] = block_c4JYy_info;
           _s4IDd::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IDd::I64;
           if (R1 & 7 != 0) goto u4JYN; else goto c4JYz;
       u4JYN: // global
           call _c4JYy(R1) args: 0, res: 0, upd: 0;
       c4JYz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4JYy() //  [R1]
         { info_tbl: [(c4JYy,
                       label: block_c4JYy_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JYy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4JYM; else goto c4JYL;
       c4JYM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4JYL: // global
           _s4IDg::I64 = I64[Sp + 8] + I64[R1 + 7];
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4IDg::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableFingerprint3_entry() //  [R2, R3, R4]
         { info_tbl: [(c4JYP,
                       label: Foreign.Storable.$fStorableFingerprint3_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JYP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4JYQ; else goto c4JYR;
       c4JYQ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4JYR: // global
           I64[Sp - 24] = block_c4JYj_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4JYV; else goto c4JYk;
       u4JYV: // global
           call _c4JYj(R1) args: 0, res: 0, upd: 0;
       c4JYk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JYj() //  [R1]
         { info_tbl: [(c4JYj,
                       label: block_c4JYj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JYj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4JYU; else goto c4JYT;
       c4JYU: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4JYT: // global
           _s4IDa::I64 = I64[R1 + 7];
           _s4IDb::I64 = I64[R1 + 15];
           I64[Hp - 24] = sat_s4IDh_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = _s4IDb::I64;
           R3 = _s4IDa::I64;
           R2 = Hp - 24;
           Sp = Sp + 24;
           call Foreign.Storable.$w$cpoke_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.316790145 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint5_closure" {
     Foreign.Storable.$fStorableFingerprint5_closure:
         const Foreign.Storable.$fStorableFingerprint5_info;
 },
 sat_s4IDv_entry() //  [R1]
         { info_tbl: [(c4JZI,
                       label: sat_s4IDv_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JZI: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c4JZX; else goto c4JZY;
       c4JZX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4JZY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_c4JZF_info;
           _s4IDj::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s4IDj::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u4K04; else goto c4JZG;
       u4K04: // global
           call _c4JZF(R1) args: 0, res: 0, upd: 0;
       c4JZG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4JZF() //  [R1]
         { info_tbl: [(c4JZF,
                       label: block_c4JZF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JZF: // global
           I64[Sp] = block_c4JZL_info;
           _s4IDq::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s4IDq::I64;
           if (R1 & 7 != 0) goto u4K03; else goto c4JZM;
       u4K03: // global
           call _c4JZL(R1) args: 0, res: 0, upd: 0;
       c4JZM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c4JZL() //  [R1]
         { info_tbl: [(c4JZL,
                       label: block_c4JZL_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JZL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4K02; else goto c4K01;
       c4K02: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c4K01: // global
           _s4IDu::I64 = I64[Sp + 8] + (I64[R1 + 7] << 4);
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s4IDu::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.Storable.$fStorableFingerprint5_entry() //  [R2, R3, R4]
         { info_tbl: [(c4K05,
                       label: Foreign.Storable.$fStorableFingerprint5_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4K05: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4K06; else goto c4K07;
       c4K06: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.Storable.$fStorableFingerprint5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4K07: // global
           I64[Sp - 24] = block_c4JZw_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u4K0b; else goto c4JZx;
       u4K0b: // global
           call _c4JZw(R1) args: 0, res: 0, upd: 0;
       c4JZx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4JZw() //  [R1]
         { info_tbl: [(c4JZw,
                       label: block_c4JZw_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4JZw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c4K0a; else goto c4K09;
       c4K0a: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4K09: // global
           _s4IDn::I64 = I64[R1 + 7];
           _s4IDo::I64 = I64[R1 + 15];
           I64[Hp - 24] = sat_s4IDv_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = _s4IDo::I64;
           R3 = _s4IDn::I64;
           R2 = Hp - 24;
           Sp = Sp + 24;
           call Foreign.Storable.$w$cpoke_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.333156529 UTC

[section ""data" . Foreign.Storable.$fStorableFingerprint_closure" {
     Foreign.Storable.$fStorableFingerprint_closure:
         const Foreign.Storable.C:Storable_con_info;
         const Foreign.Storable.$fStorableFingerprint_$csizeOf_closure+1;
         const Foreign.Storable.$fStorableFingerprint_$calignment_closure+1;
         const Foreign.Storable.$fStorableFingerprint6_closure+3;
         const Foreign.Storable.$fStorableFingerprint5_closure+4;
         const Foreign.Storable.$fStorableFingerprint4_closure+3;
         const Foreign.Storable.$fStorableFingerprint3_closure+4;
         const Foreign.Storable.$fStorableFingerprint2_closure+2;
         const Foreign.Storable.$fStorableFingerprint1_closure+3;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.336162232 UTC

[section ""data" . Foreign.Storable.C:Storable_closure" {
     Foreign.Storable.C:Storable_closure:
         const Foreign.Storable.C:Storable_info;
 },
 Foreign.Storable.C:Storable_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4K0K: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Foreign.Storable.C:Storable_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2,
                                                  R1) args: 32, res: 0, upd: 8;
     }
 },
 Foreign.Storable.C:Storable_entry() //  [R2, R3, R4, R5, R6]
         { info_tbl: [(c4K0P,
                       label: Foreign.Storable.C:Storable_info
                       rep:HeapRep static {
                             Fun {arity: 8
                                  fun_type: ArgGen [False, False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4K0P: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c4K0T; else goto c4K0S;
       c4K0T: // global
           HpAlloc = 72;
           R1 = Foreign.Storable.C:Storable_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       c4K0S: // global
           I64[Hp - 64] = Foreign.Storable.C:Storable_con_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           P64[Hp - 24] = R6;
           P64[Hp - 16] = P64[Sp];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R1 = Hp - 63;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.343747117 UTC

[Foreign.Storable.C:Storable_con_entry() //  [R1]
         { info_tbl: [(c4K15,
                       label: Foreign.Storable.C:Storable_con_info
                       rep:HeapRep 8 ptrs {
                             Con {tag: 0
                                  descr:[98,97,115,101,58,70,111,114,101,105,103,110,46,83,116,111,114,97,98,108,101,46,67,58,83,116,111,114,97,98,108,101]} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4K15: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:38.348351077 UTC

[section ""relreadonly" . S4ILz_srt" {
     S4ILz_srt:
         const GHC.Err.undefined_closure;
         const lvl10_r4Ffj_closure;
         const Foreign.Storable.$fStorableRatio8_closure;
         const Foreign.Storable.$fStorableRatio_$calignment_closure;
         const GHC.Real.%_closure;
         const Foreign.Storable.$fStorableRatio2_closure;
         const lvl15_r4Ffp_closure;
         const lvl16_r4Ffq_closure;
         const Foreign.Storable.$dmpeekElemOff_closure;
         const lvl19_r4Fft_closure;
         const Foreign.Storable.$fStorableRatio6_closure;
         const Foreign.Storable.$fStorableRatio_$csizeOf_closure;
         const Foreign.Storable.$fStorableRatio4_closure;
         const Foreign.Storable.$fStorableRatio7_closure;
         const Foreign.Storable.$w$cpokeElemOff_closure;
         const Foreign.Storable.$fStorableRatio5_closure;
         const Foreign.Storable.$fStorableRatio_closure;
 }]

