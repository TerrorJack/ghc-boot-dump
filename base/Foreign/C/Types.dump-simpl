
==================== Tidy Core ====================
2018-03-16 15:59:48.551840549 UTC

Result size of Tidy Core
  = {terms: 3,598, types: 1,171, coercions: 12,896, joins: 0/0}

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCUIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CUIntMax
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CUIntMax
                       GHC.Word.$fShowWord64_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Word64 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CUIntMax -> [Char] -> [Char] :: *))
                       GHC.Word.$fShowWord64_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <[Char]>_R
                               :: (Word64 -> [Char] :: *) ~R# (CUIntMax -> [Char] :: *))
                       GHC.Word.$fShowWord64_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CUIntMax[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Word64] -> [Char] -> [Char] :: *)
                                  ~R# ([CUIntMax] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCUIntMax
  = GHC.Show.C:Show
      @ CUIntMax
      (GHC.Word.$fShowWord64_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Word64 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CUIntMax -> [Char] -> [Char] :: *)))
      (GHC.Word.$fShowWord64_$cshow
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <[Char]>_R
               :: (Word64 -> [Char] :: *) ~R# (CUIntMax -> [Char] :: *)))
      (GHC.Word.$fShowWord64_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CUIntMax[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Word64] -> [Char] -> [Char] :: *)
                  ~R# ([CUIntMax] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCUIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CUIntMax
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CUIntMax
                       GHC.Read.$fReadWord64_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CUIntMax[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Word64, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CUIntMax, [Char])] :: *))
                       GHC.Read.$fReadWord64_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CUIntMax[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Word64], [Char])] :: *)
                                  ~R# ([Char] -> [([CUIntMax], [Char])] :: *))
                       GHC.Read.$fReadWord13
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Word64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      (Foreign.C.Types.N:CUIntMax[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Word64 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CUIntMax :: *))
                       GHC.Read.$fReadWord11
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Word64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                        ([Foreign.C.Types.N:CUIntMax[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Word64] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CUIntMax] :: *))]
Foreign.C.Types.$fReadCUIntMax
  = GHC.Read.C:Read
      @ CUIntMax
      (GHC.Read.$fReadWord64_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CUIntMax[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Word64, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CUIntMax, [Char])] :: *)))
      (GHC.Read.$fReadWord64_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CUIntMax[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Word64], [Char])] :: *)
                  ~R# ([Char] -> [([CUIntMax], [Char])] :: *)))
      (GHC.Read.$fReadWord13
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Word64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                      (Foreign.C.Types.N:CUIntMax[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Word64 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CUIntMax :: *)))
      (GHC.Read.$fReadWord11
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Word64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        ([Foreign.C.Types.N:CUIntMax[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Word64] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CUIntMax] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.C.Types.$fBoundedCUIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded CUIntMax
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: CUIntMax
                          GHC.Word.$fBitsWord7
                          `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                  :: (Word64 :: *) ~R# (CUIntMax :: *))
                          GHC.Word.$fBoundedWord64_$cmaxBound
                          `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                  :: (Word64 :: *) ~R# (CUIntMax :: *))]
Foreign.C.Types.$fBoundedCUIntMax
  = GHC.Enum.C:Bounded
      @ CUIntMax
      (GHC.Word.$fBitsWord7
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 :: *) ~R# (CUIntMax :: *)))
      (GHC.Word.$fBoundedWord64_$cmaxBound
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 :: *) ~R# (CUIntMax :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCUIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CUIntMax
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CUIntMax
                                   Foreign.Storable.$fStorableWord64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Int>_R
                                           :: (Word64 -> Int :: *) ~R# (CUIntMax -> Int :: *))
                                   Foreign.Storable.$fStorableWord64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Int>_R
                                           :: (Word64 -> Int :: *) ~R# (CUIntMax -> Int :: *))
                                   GHC.Storable.readWord64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word64, CUIntMax))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CUIntMax[0]))
                                           :: (GHC.Ptr.Ptr Word64
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUIntMax -> Int -> IO CUIntMax :: *))
                                   GHC.Storable.writeWord64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word64, CUIntMax))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Word64
                                               -> Int
                                               -> Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUIntMax
                                                   -> Int -> CUIntMax -> IO () :: *))
                                   Foreign.Storable.$fStorableWord18
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CUIntMax[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word64 #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> IO CUIntMax :: *))
                                   Foreign.Storable.$fStorableWord17
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CUIntMax -> IO () :: *))
                                   Foreign.Storable.$fStorableWord15
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word64, CUIntMax))_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CUIntMax[0]))
                                           :: (GHC.Ptr.Ptr Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUIntMax -> IO CUIntMax :: *))
                                   Foreign.Storable.$fStorableWord14
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word64, CUIntMax))_R
                                           ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Word64
                                               -> Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUIntMax -> CUIntMax -> IO () :: *))]
Foreign.C.Types.$fStorableCUIntMax
  = Foreign.Storable.C:Storable
      @ CUIntMax
      (Foreign.Storable.$fStorableWord64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CUIntMax -> Int :: *)))
      (Foreign.Storable.$fStorableWord64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CUIntMax -> Int :: *)))
      (GHC.Storable.readWord64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word64, CUIntMax))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUIntMax[0]))
               :: (GHC.Ptr.Ptr Word64
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CUIntMax -> Int -> IO CUIntMax :: *)))
      (GHC.Storable.writeWord64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word64, CUIntMax))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Word64
                   -> Int
                   -> Word64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CUIntMax -> Int -> CUIntMax -> IO () :: *)))
      (Foreign.Storable.$fStorableWord18
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUIntMax[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word64 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CUIntMax :: *)))
      (Foreign.Storable.$fStorableWord17
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Word64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CUIntMax -> IO () :: *)))
      (Foreign.Storable.$fStorableWord15
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word64, CUIntMax))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUIntMax[0]))
               :: (GHC.Ptr.Ptr Word64
                   -> State# RealWorld -> (# State# RealWorld, Word64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CUIntMax -> IO CUIntMax :: *)))
      (Foreign.Storable.$fStorableWord14
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word64, CUIntMax))_R
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Word64
                   -> Word64 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CUIntMax -> CUIntMax -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCUIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CUIntMax
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CUIntMax
                       GHC.Word.$fEnumWord64_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                               :: (Word64 -> Word64 :: *) ~R# (CUIntMax -> CUIntMax :: *))
                       GHC.Word.$fEnumWord64_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                               :: (Word64 -> Word64 :: *) ~R# (CUIntMax -> CUIntMax :: *))
                       GHC.Word.$fEnumWord64_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                               :: (Int -> Word64 :: *) ~R# (Int -> CUIntMax :: *))
                       GHC.Word.$fEnumWord64_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Int>_R
                               :: (Word64 -> Int :: *) ~R# (CUIntMax -> Int :: *))
                       GHC.Word.$fEnumWord64_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUIntMax[0])])_R
                               :: (Word64 -> [Word64] :: *) ~R# (CUIntMax -> [CUIntMax] :: *))
                       GHC.Word.$fEnumWord64_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUIntMax[0])])_R
                               :: (Word64 -> Word64 -> [Word64] :: *)
                                  ~R# (CUIntMax -> CUIntMax -> [CUIntMax] :: *))
                       GHC.Word.$fEnumWord64_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUIntMax[0])])_R
                               :: (Word64 -> Word64 -> [Word64] :: *)
                                  ~R# (CUIntMax -> CUIntMax -> [CUIntMax] :: *))
                       GHC.Word.$fEnumWord64_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUIntMax[0])])_R
                               :: (Word64 -> Word64 -> Word64 -> [Word64] :: *)
                                  ~R# (CUIntMax -> CUIntMax -> CUIntMax -> [CUIntMax] :: *))]
Foreign.C.Types.$fEnumCUIntMax
  = GHC.Enum.C:Enum
      @ CUIntMax
      (GHC.Word.$fEnumWord64_$csucc
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Word64 :: *) ~R# (CUIntMax -> CUIntMax :: *)))
      (GHC.Word.$fEnumWord64_$cpred
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Word64 :: *) ~R# (CUIntMax -> CUIntMax :: *)))
      (GHC.Word.$fEnumWord64_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Int -> Word64 :: *) ~R# (Int -> CUIntMax :: *)))
      (GHC.Word.$fEnumWord64_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CUIntMax -> Int :: *)))
      (GHC.Word.$fEnumWord64_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R ([Sym (Foreign.C.Types.N:CUIntMax[0])])_R
               :: (Word64 -> [Word64] :: *) ~R# (CUIntMax -> [CUIntMax] :: *)))
      (GHC.Word.$fEnumWord64_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R ([Sym (Foreign.C.Types.N:CUIntMax[0])])_R
               :: (Word64 -> Word64 -> [Word64] :: *)
                  ~R# (CUIntMax -> CUIntMax -> [CUIntMax] :: *)))
      (GHC.Word.$fEnumWord64_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R ([Sym (Foreign.C.Types.N:CUIntMax[0])])_R
               :: (Word64 -> Word64 -> [Word64] :: *)
                  ~R# (CUIntMax -> CUIntMax -> [CUIntMax] :: *)))
      (GHC.Word.$fEnumWord64_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R ([Sym (Foreign.C.Types.N:CUIntMax[0])])_R
               :: (Word64 -> Word64 -> Word64 -> [Word64] :: *)
                  ~R# (CUIntMax -> CUIntMax -> CUIntMax -> [CUIntMax] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCUIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CUIntMax
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CUIntMax
                     GHC.Word.$fNumWord64_$c+
                     `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                             ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                             ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                             :: (Word64 -> Word64 -> Word64 :: *)
                                ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *))
                     GHC.Word.$fNumWord64_$c-
                     `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                             ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                             ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                             :: (Word64 -> Word64 -> Word64 :: *)
                                ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *))
                     GHC.Word.$fNumWord64_$c*
                     `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                             ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                             ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                             :: (Word64 -> Word64 -> Word64 :: *)
                                ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *))
                     GHC.Word.$fNumWord64_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                             ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                             :: (Word64 -> Word64 :: *) ~R# (CUIntMax -> CUIntMax :: *))
                     GHC.Word.$fNumWord64_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                             ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                             :: (Word64 -> Word64 :: *) ~R# (CUIntMax -> CUIntMax :: *))
                     GHC.Word.$fNumWord64_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                             ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                             :: (Word64 -> Word64 :: *) ~R# (CUIntMax -> CUIntMax :: *))
                     GHC.Word.$fNumWord64_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                             :: (Integer -> Word64 :: *) ~R# (Integer -> CUIntMax :: *))]
Foreign.C.Types.$fNumCUIntMax
  = GHC.Num.C:Num
      @ CUIntMax
      (GHC.Word.$fNumWord64_$c+
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *)))
      (GHC.Word.$fNumWord64_$c-
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *)))
      (GHC.Word.$fNumWord64_$c*
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *)))
      (GHC.Word.$fNumWord64_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Word64 :: *) ~R# (CUIntMax -> CUIntMax :: *)))
      (GHC.Word.$fNumWord64_$cabs
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Word64 :: *) ~R# (CUIntMax -> CUIntMax :: *)))
      (GHC.Word.$fNumWord64_$csignum
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Word64 :: *) ~R# (CUIntMax -> CUIntMax :: *)))
      (GHC.Word.$fNumWord64_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Integer -> Word64 :: *) ~R# (Integer -> CUIntMax :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCUIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CUIntMax
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CUIntMax
                        GHC.Word.eqWord64
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R <Bool>_R
                                :: (Word64 -> Word64 -> Bool :: *)
                                   ~R# (CUIntMax -> CUIntMax -> Bool :: *))
                        GHC.Word.neWord64
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R <Bool>_R
                                :: (Word64 -> Word64 -> Bool :: *)
                                   ~R# (CUIntMax -> CUIntMax -> Bool :: *))]
Foreign.C.Types.$fEqCUIntMax
  = GHC.Classes.C:Eq
      @ CUIntMax
      (GHC.Word.eqWord64
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CUIntMax -> CUIntMax -> Bool :: *)))
      (GHC.Word.neWord64
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CUIntMax -> CUIntMax -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCUIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CUIntMax
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CUIntMax
                         Foreign.C.Types.$fEqCUIntMax
                         GHC.Word.$fOrdWord64_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                 ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                 ->_R <Ordering>_R
                                 :: (Word64 -> Word64 -> Ordering :: *)
                                    ~R# (CUIntMax -> CUIntMax -> Ordering :: *))
                         GHC.Word.ltWord64
                         `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                 ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                 ->_R <Bool>_R
                                 :: (Word64 -> Word64 -> Bool :: *)
                                    ~R# (CUIntMax -> CUIntMax -> Bool :: *))
                         GHC.Word.leWord64
                         `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                 ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                 ->_R <Bool>_R
                                 :: (Word64 -> Word64 -> Bool :: *)
                                    ~R# (CUIntMax -> CUIntMax -> Bool :: *))
                         GHC.Word.gtWord64
                         `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                 ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                 ->_R <Bool>_R
                                 :: (Word64 -> Word64 -> Bool :: *)
                                    ~R# (CUIntMax -> CUIntMax -> Bool :: *))
                         GHC.Word.geWord64
                         `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                 ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                 ->_R <Bool>_R
                                 :: (Word64 -> Word64 -> Bool :: *)
                                    ~R# (CUIntMax -> CUIntMax -> Bool :: *))
                         GHC.Word.$fOrdWord64_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                 ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                 ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                 :: (Word64 -> Word64 -> Word64 :: *)
                                    ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *))
                         GHC.Word.$fOrdWord64_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                 ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                 ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                 :: (Word64 -> Word64 -> Word64 :: *)
                                    ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *))]
Foreign.C.Types.$fOrdCUIntMax
  = GHC.Classes.C:Ord
      @ CUIntMax
      Foreign.C.Types.$fEqCUIntMax
      (GHC.Word.$fOrdWord64_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R <Ordering>_R
               :: (Word64 -> Word64 -> Ordering :: *)
                  ~R# (CUIntMax -> CUIntMax -> Ordering :: *)))
      (GHC.Word.ltWord64
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CUIntMax -> CUIntMax -> Bool :: *)))
      (GHC.Word.leWord64
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CUIntMax -> CUIntMax -> Bool :: *)))
      (GHC.Word.gtWord64
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CUIntMax -> CUIntMax -> Bool :: *)))
      (GHC.Word.geWord64
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CUIntMax -> CUIntMax -> Bool :: *)))
      (GHC.Word.$fOrdWord64_$cmax
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *)))
      (GHC.Word.$fOrdWord64_$cmin
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCUIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CUIntMax
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CUIntMax
                       Foreign.C.Types.$fNumCUIntMax
                       Foreign.C.Types.$fOrdCUIntMax
                       GHC.Word.$fRealWord64_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Ratio Integer>_R
                               :: (Word64 -> Ratio Integer :: *)
                                  ~R# (CUIntMax -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCUIntMax
  = GHC.Real.C:Real
      @ CUIntMax
      Foreign.C.Types.$fNumCUIntMax
      Foreign.C.Types.$fOrdCUIntMax
      (GHC.Word.$fRealWord64_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Ratio Integer>_R
               :: (Word64 -> Ratio Integer :: *)
                  ~R# (CUIntMax -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.C.Types.$fIntegralCUIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral CUIntMax
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: CUIntMax
                           Foreign.C.Types.$fRealCUIntMax
                           Foreign.C.Types.$fEnumCUIntMax
                           GHC.Word.$fIntegralWord64_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                   ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                   ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                   :: (Word64 -> Word64 -> Word64 :: *)
                                      ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *))
                           GHC.Word.$fIntegralWord64_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                   ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                   ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                   :: (Word64 -> Word64 -> Word64 :: *)
                                      ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *))
                           GHC.Word.$fIntegralWord64_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                   ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                   ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                   :: (Word64 -> Word64 -> Word64 :: *)
                                      ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *))
                           GHC.Word.$fIntegralWord64_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                   ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                   ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                   :: (Word64 -> Word64 -> Word64 :: *)
                                      ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *))
                           GHC.Word.$fIntegralWord64_$cquotRem
                           `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                   ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CUIntMax[0]))
                                           (Sym (Foreign.C.Types.N:CUIntMax[0])))_R
                                   :: (Word64 -> Word64 -> (Word64, Word64) :: *)
                                      ~R# (CUIntMax -> CUIntMax -> (CUIntMax, CUIntMax) :: *))
                           GHC.Word.$fIntegralWord64_$cdivMod
                           `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                   ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CUIntMax[0]))
                                           (Sym (Foreign.C.Types.N:CUIntMax[0])))_R
                                   :: (Word64 -> Word64 -> (Word64, Word64) :: *)
                                      ~R# (CUIntMax -> CUIntMax -> (CUIntMax, CUIntMax) :: *))
                           GHC.Word.$fIntegralWord64_$ctoInteger
                           `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Integer>_R
                                   :: (Word64 -> Integer :: *) ~R# (CUIntMax -> Integer :: *))]
Foreign.C.Types.$fIntegralCUIntMax
  = GHC.Real.C:Integral
      @ CUIntMax
      Foreign.C.Types.$fRealCUIntMax
      Foreign.C.Types.$fEnumCUIntMax
      (GHC.Word.$fIntegralWord64_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *)))
      (GHC.Word.$fIntegralWord64_$cmod
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *)))
      (GHC.Word.$fIntegralWord64_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *)))
      (GHC.Word.$fIntegralWord64_$cmod
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *)))
      (GHC.Word.$fIntegralWord64_$cquotRem
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CUIntMax[0]))
                       (Sym (Foreign.C.Types.N:CUIntMax[0])))_R
               :: (Word64 -> Word64 -> (Word64, Word64) :: *)
                  ~R# (CUIntMax -> CUIntMax -> (CUIntMax, CUIntMax) :: *)))
      (GHC.Word.$fIntegralWord64_$cdivMod
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CUIntMax[0]))
                       (Sym (Foreign.C.Types.N:CUIntMax[0])))_R
               :: (Word64 -> Word64 -> (Word64, Word64) :: *)
                  ~R# (CUIntMax -> CUIntMax -> (CUIntMax, CUIntMax) :: *)))
      (GHC.Word.$fIntegralWord64_$ctoInteger
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Integer>_R
               :: (Word64 -> Integer :: *) ~R# (CUIntMax -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.C.Types.$fBitsCUIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits CUIntMax
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: CUIntMax
                        Foreign.C.Types.$fEqCUIntMax
                        GHC.Word.$fBitsWord64_$c.&.
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                :: (Word64 -> Word64 -> Word64 :: *)
                                   ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *))
                        GHC.Word.$fBitsWord64_$c.|.
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                :: (Word64 -> Word64 -> Word64 :: *)
                                   ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *))
                        GHC.Word.$fBitsWord64_$cxor
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                :: (Word64 -> Word64 -> Word64 :: *)
                                   ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *))
                        GHC.Word.$fBitsWord64_$ccomplement
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                :: (Word64 -> Word64 :: *) ~R# (CUIntMax -> CUIntMax :: *))
                        GHC.Word.$fBitsWord64_$cshift
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntMax -> Int -> CUIntMax :: *))
                        GHC.Word.$fBitsWord64_$crotate
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntMax -> Int -> CUIntMax :: *))
                        GHC.Word.$fBitsWord7
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                :: (Word64 :: *) ~R# (CUIntMax :: *))
                        GHC.Word.$fBitsWord64_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                :: (Int -> Word64 :: *) ~R# (Int -> CUIntMax :: *))
                        GHC.Word.$fBitsWord64_$csetBit
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntMax -> Int -> CUIntMax :: *))
                        GHC.Word.$fBitsWord64_$cclearBit
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntMax -> Int -> CUIntMax :: *))
                        GHC.Word.$fBitsWord64_$ccomplementBit
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntMax -> Int -> CUIntMax :: *))
                        GHC.Word.$fBitsWord64_$ctestBit
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Int -> Bool>_R
                                :: (Word64 -> Int -> Bool :: *) ~R# (CUIntMax -> Int -> Bool :: *))
                        GHC.Word.$fBitsWord64_$cbitSizeMaybe
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Maybe Int>_R
                                :: (Word64 -> Maybe Int :: *) ~R# (CUIntMax -> Maybe Int :: *))
                        GHC.Word.$fBitsWord64_$cfiniteBitSize
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Int>_R
                                :: (Word64 -> Int :: *) ~R# (CUIntMax -> Int :: *))
                        GHC.Word.$fBitsWord64_$cisSigned
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Bool>_R
                                :: (Word64 -> Bool :: *) ~R# (CUIntMax -> Bool :: *))
                        GHC.Word.$fBitsWord64_$cshiftL
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntMax -> Int -> CUIntMax :: *))
                        GHC.Word.$fBitsWord64_$cunsafeShiftL
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntMax -> Int -> CUIntMax :: *))
                        GHC.Word.$fBitsWord64_$cshiftR
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntMax -> Int -> CUIntMax :: *))
                        GHC.Word.$fBitsWord64_$cunsafeShiftR
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntMax -> Int -> CUIntMax :: *))
                        GHC.Word.$fBitsWord64_$crotateL
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntMax -> Int -> CUIntMax :: *))
                        GHC.Word.$fBitsWord64_$crotateR
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntMax -> Int -> CUIntMax :: *))
                        GHC.Word.$fBitsWord64_$cpopCount
                        `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Int>_R
                                :: (Word64 -> Int :: *) ~R# (CUIntMax -> Int :: *))]
Foreign.C.Types.$fBitsCUIntMax
  = Data.Bits.C:Bits
      @ CUIntMax
      Foreign.C.Types.$fEqCUIntMax
      (GHC.Word.$fBitsWord64_$c.&.
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *)))
      (GHC.Word.$fBitsWord64_$c.|.
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *)))
      (GHC.Word.$fBitsWord64_$cxor
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntMax -> CUIntMax -> CUIntMax :: *)))
      (GHC.Word.$fBitsWord64_$ccomplement
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Word64 :: *) ~R# (CUIntMax -> CUIntMax :: *)))
      (GHC.Word.$fBitsWord64_$cshift
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntMax -> Int -> CUIntMax :: *)))
      (GHC.Word.$fBitsWord64_$crotate
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntMax -> Int -> CUIntMax :: *)))
      (GHC.Word.$fBitsWord7
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 :: *) ~R# (CUIntMax :: *)))
      (GHC.Word.$fBitsWord64_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Int -> Word64 :: *) ~R# (Int -> CUIntMax :: *)))
      (GHC.Word.$fBitsWord64_$csetBit
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntMax -> Int -> CUIntMax :: *)))
      (GHC.Word.$fBitsWord64_$cclearBit
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntMax -> Int -> CUIntMax :: *)))
      (GHC.Word.$fBitsWord64_$ccomplementBit
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntMax -> Int -> CUIntMax :: *)))
      (GHC.Word.$fBitsWord64_$ctestBit
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Int -> Bool>_R
               :: (Word64 -> Int -> Bool :: *)
                  ~R# (CUIntMax -> Int -> Bool :: *)))
      (GHC.Word.$fBitsWord64_$cbitSizeMaybe
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Maybe Int>_R
               :: (Word64 -> Maybe Int :: *) ~R# (CUIntMax -> Maybe Int :: *)))
      (GHC.Word.$fBitsWord64_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CUIntMax -> Int :: *)))
      (GHC.Word.$fBitsWord64_$cisSigned
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Bool>_R
               :: (Word64 -> Bool :: *) ~R# (CUIntMax -> Bool :: *)))
      (GHC.Word.$fBitsWord64_$cshiftL
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntMax -> Int -> CUIntMax :: *)))
      (GHC.Word.$fBitsWord64_$cunsafeShiftL
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntMax -> Int -> CUIntMax :: *)))
      (GHC.Word.$fBitsWord64_$cshiftR
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntMax -> Int -> CUIntMax :: *)))
      (GHC.Word.$fBitsWord64_$cunsafeShiftR
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntMax -> Int -> CUIntMax :: *)))
      (GHC.Word.$fBitsWord64_$crotateL
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntMax -> Int -> CUIntMax :: *)))
      (GHC.Word.$fBitsWord64_$crotateR
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntMax -> Int -> CUIntMax :: *)))
      (GHC.Word.$fBitsWord64_$cpopCount
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CUIntMax -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.C.Types.$fFiniteBitsCUIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits CUIntMax
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: CUIntMax
                              Foreign.C.Types.$fBitsCUIntMax
                              GHC.Word.$fBitsWord64_$cfiniteBitSize
                              `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Int>_R
                                      :: (Word64 -> Int :: *) ~R# (CUIntMax -> Int :: *))
                              GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
                              `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Int>_R
                                      :: (Word64 -> Int :: *) ~R# (CUIntMax -> Int :: *))
                              GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros
                              `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Int>_R
                                      :: (Word64 -> Int :: *) ~R# (CUIntMax -> Int :: *))]
Foreign.C.Types.$fFiniteBitsCUIntMax
  = Data.Bits.C:FiniteBits
      @ CUIntMax
      Foreign.C.Types.$fBitsCUIntMax
      (GHC.Word.$fBitsWord64_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CUIntMax -> Int :: *)))
      (GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CUIntMax -> Int :: *)))
      (GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros
       `cast` (Sym (Foreign.C.Types.N:CUIntMax[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CUIntMax -> Int :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CIntMax
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CIntMax
                       GHC.Int.$fShowInt64_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Int64 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CIntMax -> [Char] -> [Char] :: *))
                       GHC.Int.$fShowInt64_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <[Char]>_R
                               :: (Int64 -> [Char] :: *) ~R# (CIntMax -> [Char] :: *))
                       GHC.Int.$fShowInt64_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CIntMax[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Int64] -> [Char] -> [Char] :: *)
                                  ~R# ([CIntMax] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCIntMax
  = GHC.Show.C:Show
      @ CIntMax
      (GHC.Int.$fShowInt64_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Int64 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CIntMax -> [Char] -> [Char] :: *)))
      (GHC.Int.$fShowInt64_$cshow
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <[Char]>_R
               :: (Int64 -> [Char] :: *) ~R# (CIntMax -> [Char] :: *)))
      (GHC.Int.$fShowInt64_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CIntMax[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Int64] -> [Char] -> [Char] :: *)
                  ~R# ([CIntMax] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CIntMax
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CIntMax
                       GHC.Int.$fReadInt64_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CIntMax[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Int64, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CIntMax, [Char])] :: *))
                       GHC.Int.$fReadInt64_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CIntMax[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Int64], [Char])] :: *)
                                  ~R# ([Char] -> [([CIntMax], [Char])] :: *))
                       GHC.Int.$fReadInt10
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Int64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     (Foreign.C.Types.N:CIntMax[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Int64 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CIntMax :: *))
                       GHC.Int.$fReadInt7
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Int64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       ([Foreign.C.Types.N:CIntMax[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Int64] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CIntMax] :: *))]
Foreign.C.Types.$fReadCIntMax
  = GHC.Read.C:Read
      @ CIntMax
      (GHC.Int.$fReadInt64_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CIntMax[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Int64, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CIntMax, [Char])] :: *)))
      (GHC.Int.$fReadInt64_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CIntMax[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Int64], [Char])] :: *)
                  ~R# ([Char] -> [([CIntMax], [Char])] :: *)))
      (GHC.Int.$fReadInt10
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Int64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                     (Foreign.C.Types.N:CIntMax[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Int64 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CIntMax :: *)))
      (GHC.Int.$fReadInt7
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Int64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       ([Foreign.C.Types.N:CIntMax[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Int64] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CIntMax] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.C.Types.$fBoundedCIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded CIntMax
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: CIntMax
                          GHC.Int.$fBoundedInt64_$cminBound
                          `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                  :: (Int64 :: *) ~R# (CIntMax :: *))
                          GHC.Int.$fBoundedInt64_$cmaxBound
                          `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                  :: (Int64 :: *) ~R# (CIntMax :: *))]
Foreign.C.Types.$fBoundedCIntMax
  = GHC.Enum.C:Bounded
      @ CIntMax
      (GHC.Int.$fBoundedInt64_$cminBound
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 :: *) ~R# (CIntMax :: *)))
      (GHC.Int.$fBoundedInt64_$cmaxBound
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 :: *) ~R# (CIntMax :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CIntMax
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CIntMax
                                   Foreign.Storable.$fStorableInt64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Int>_R
                                           :: (Int64 -> Int :: *) ~R# (CIntMax -> Int :: *))
                                   Foreign.Storable.$fStorableInt64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Int>_R
                                           :: (Int64 -> Int :: *) ~R# (CIntMax -> Int :: *))
                                   GHC.Storable.readInt64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CIntMax))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CIntMax[0]))
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CIntMax -> Int -> IO CIntMax :: *))
                                   GHC.Storable.writeInt64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CIntMax))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CIntMax
                                                   -> Int -> CIntMax -> IO () :: *))
                                   Foreign.Storable.$fStorableInt19
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CIntMax[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> IO CIntMax :: *))
                                   Foreign.Storable.$fStorableInt18
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CIntMax -> IO () :: *))
                                   Foreign.Storable.$fStorableInt17
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CIntMax))_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CIntMax[0]))
                                           :: (GHC.Ptr.Ptr Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CIntMax -> IO CIntMax :: *))
                                   Foreign.Storable.$fStorableInt15
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CIntMax))_R
                                           ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CIntMax -> CIntMax -> IO () :: *))]
Foreign.C.Types.$fStorableCIntMax
  = Foreign.Storable.C:Storable
      @ CIntMax
      (Foreign.Storable.$fStorableInt64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CIntMax -> Int :: *)))
      (Foreign.Storable.$fStorableInt64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CIntMax -> Int :: *)))
      (GHC.Storable.readInt64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CIntMax))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CIntMax[0]))
               :: (GHC.Ptr.Ptr Int64
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CIntMax -> Int -> IO CIntMax :: *)))
      (GHC.Storable.writeInt64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CIntMax))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int64
                   -> Int
                   -> Int64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CIntMax -> Int -> CIntMax -> IO () :: *)))
      (Foreign.Storable.$fStorableInt19
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CIntMax[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CIntMax :: *)))
      (Foreign.Storable.$fStorableInt18
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Int64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CIntMax -> IO () :: *)))
      (Foreign.Storable.$fStorableInt17
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CIntMax))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CIntMax[0]))
               :: (GHC.Ptr.Ptr Int64
                   -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CIntMax -> IO CIntMax :: *)))
      (Foreign.Storable.$fStorableInt15
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CIntMax))_R
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int64
                   -> Int64 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CIntMax -> CIntMax -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CIntMax
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CIntMax
                       GHC.Int.$fEnumInt64_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                               :: (Int64 -> Int64 :: *) ~R# (CIntMax -> CIntMax :: *))
                       GHC.Int.$fEnumInt64_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                               :: (Int64 -> Int64 :: *) ~R# (CIntMax -> CIntMax :: *))
                       GHC.Int.$fEnumInt64_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                               :: (Int -> Int64 :: *) ~R# (Int -> CIntMax :: *))
                       GHC.Int.$fEnumInt64_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Int>_R
                               :: (Int64 -> Int :: *) ~R# (CIntMax -> Int :: *))
                       GHC.Int.$fEnumInt64_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                               ->_R ([Sym (Foreign.C.Types.N:CIntMax[0])])_R
                               :: (Int64 -> [Int64] :: *) ~R# (CIntMax -> [CIntMax] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                               ->_R ([Sym (Foreign.C.Types.N:CIntMax[0])])_R
                               :: (Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CIntMax -> CIntMax -> [CIntMax] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                               ->_R ([Sym (Foreign.C.Types.N:CIntMax[0])])_R
                               :: (Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CIntMax -> CIntMax -> [CIntMax] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                               ->_R ([Sym (Foreign.C.Types.N:CIntMax[0])])_R
                               :: (Int64 -> Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CIntMax -> CIntMax -> CIntMax -> [CIntMax] :: *))]
Foreign.C.Types.$fEnumCIntMax
  = GHC.Enum.C:Enum
      @ CIntMax
      (GHC.Int.$fEnumInt64_$csucc
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int64 :: *) ~R# (CIntMax -> CIntMax :: *)))
      (GHC.Int.$fEnumInt64_$cpred
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int64 :: *) ~R# (CIntMax -> CIntMax :: *)))
      (GHC.Int.$fEnumInt64_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int -> Int64 :: *) ~R# (Int -> CIntMax :: *)))
      (GHC.Int.$fEnumInt64_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CIntMax -> Int :: *)))
      (GHC.Int.$fEnumInt64_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R ([Sym (Foreign.C.Types.N:CIntMax[0])])_R
               :: (Int64 -> [Int64] :: *) ~R# (CIntMax -> [CIntMax] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R ([Sym (Foreign.C.Types.N:CIntMax[0])])_R
               :: (Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CIntMax -> CIntMax -> [CIntMax] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R ([Sym (Foreign.C.Types.N:CIntMax[0])])_R
               :: (Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CIntMax -> CIntMax -> [CIntMax] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R ([Sym (Foreign.C.Types.N:CIntMax[0])])_R
               :: (Int64 -> Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CIntMax -> CIntMax -> CIntMax -> [CIntMax] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CIntMax
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CIntMax
                     GHC.Int.$fNumInt64_$c+
                     `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                             ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                             ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CIntMax -> CIntMax -> CIntMax :: *))
                     GHC.Int.$fNumInt64_$c-
                     `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                             ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                             ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CIntMax -> CIntMax -> CIntMax :: *))
                     GHC.Int.$fNumInt64_$c*
                     `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                             ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                             ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CIntMax -> CIntMax -> CIntMax :: *))
                     GHC.Int.$fNumInt64_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                             ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                             :: (Int64 -> Int64 :: *) ~R# (CIntMax -> CIntMax :: *))
                     GHC.Int.$fNumInt64_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                             ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                             :: (Int64 -> Int64 :: *) ~R# (CIntMax -> CIntMax :: *))
                     GHC.Int.$fNumInt64_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                             ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                             :: (Int64 -> Int64 :: *) ~R# (CIntMax -> CIntMax :: *))
                     GHC.Int.$fNumInt64_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                             :: (Integer -> Int64 :: *) ~R# (Integer -> CIntMax :: *))]
Foreign.C.Types.$fNumCIntMax
  = GHC.Num.C:Num
      @ CIntMax
      (GHC.Int.$fNumInt64_$c+
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntMax -> CIntMax -> CIntMax :: *)))
      (GHC.Int.$fNumInt64_$c-
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntMax -> CIntMax -> CIntMax :: *)))
      (GHC.Int.$fNumInt64_$c*
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntMax -> CIntMax -> CIntMax :: *)))
      (GHC.Int.$fNumInt64_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int64 :: *) ~R# (CIntMax -> CIntMax :: *)))
      (GHC.Int.$fNumInt64_$cabs
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int64 :: *) ~R# (CIntMax -> CIntMax :: *)))
      (GHC.Int.$fNumInt64_$csignum
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int64 :: *) ~R# (CIntMax -> CIntMax :: *)))
      (GHC.Int.$fNumInt64_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Integer -> Int64 :: *) ~R# (Integer -> CIntMax :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CIntMax
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CIntMax
                        GHC.Int.eqInt64
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R <Bool>_R
                                :: (Int64 -> Int64 -> Bool :: *)
                                   ~R# (CIntMax -> CIntMax -> Bool :: *))
                        GHC.Int.neInt64
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R <Bool>_R
                                :: (Int64 -> Int64 -> Bool :: *)
                                   ~R# (CIntMax -> CIntMax -> Bool :: *))]
Foreign.C.Types.$fEqCIntMax
  = GHC.Classes.C:Eq
      @ CIntMax
      (GHC.Int.eqInt64
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CIntMax -> CIntMax -> Bool :: *)))
      (GHC.Int.neInt64
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CIntMax -> CIntMax -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CIntMax
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CIntMax
                         Foreign.C.Types.$fEqCIntMax
                         GHC.Int.$fOrdInt64_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                 ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                 ->_R <Ordering>_R
                                 :: (Int64 -> Int64 -> Ordering :: *)
                                    ~R# (CIntMax -> CIntMax -> Ordering :: *))
                         GHC.Int.ltInt64
                         `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                 ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CIntMax -> CIntMax -> Bool :: *))
                         GHC.Int.leInt64
                         `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                 ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CIntMax -> CIntMax -> Bool :: *))
                         GHC.Int.gtInt64
                         `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                 ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CIntMax -> CIntMax -> Bool :: *))
                         GHC.Int.geInt64
                         `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                 ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CIntMax -> CIntMax -> Bool :: *))
                         GHC.Int.$fOrdInt64_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                 ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                 ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                 :: (Int64 -> Int64 -> Int64 :: *)
                                    ~R# (CIntMax -> CIntMax -> CIntMax :: *))
                         GHC.Int.$fOrdInt64_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                 ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                 ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                 :: (Int64 -> Int64 -> Int64 :: *)
                                    ~R# (CIntMax -> CIntMax -> CIntMax :: *))]
Foreign.C.Types.$fOrdCIntMax
  = GHC.Classes.C:Ord
      @ CIntMax
      Foreign.C.Types.$fEqCIntMax
      (GHC.Int.$fOrdInt64_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R <Ordering>_R
               :: (Int64 -> Int64 -> Ordering :: *)
                  ~R# (CIntMax -> CIntMax -> Ordering :: *)))
      (GHC.Int.ltInt64
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CIntMax -> CIntMax -> Bool :: *)))
      (GHC.Int.leInt64
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CIntMax -> CIntMax -> Bool :: *)))
      (GHC.Int.gtInt64
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CIntMax -> CIntMax -> Bool :: *)))
      (GHC.Int.geInt64
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CIntMax -> CIntMax -> Bool :: *)))
      (GHC.Int.$fOrdInt64_$cmax
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntMax -> CIntMax -> CIntMax :: *)))
      (GHC.Int.$fOrdInt64_$cmin
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntMax -> CIntMax -> CIntMax :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CIntMax
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CIntMax
                       Foreign.C.Types.$fNumCIntMax
                       Foreign.C.Types.$fOrdCIntMax
                       GHC.Int.$fRealInt64_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Ratio Integer>_R
                               :: (Int64 -> Ratio Integer :: *)
                                  ~R# (CIntMax -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCIntMax
  = GHC.Real.C:Real
      @ CIntMax
      Foreign.C.Types.$fNumCIntMax
      Foreign.C.Types.$fOrdCIntMax
      (GHC.Int.$fRealInt64_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Ratio Integer>_R
               :: (Int64 -> Ratio Integer :: *)
                  ~R# (CIntMax -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.C.Types.$fIntegralCIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral CIntMax
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: CIntMax
                           Foreign.C.Types.$fRealCIntMax
                           Foreign.C.Types.$fEnumCIntMax
                           GHC.Int.$fIntegralInt64_$cquot
                           `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                   ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                   ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                   :: (Int64 -> Int64 -> Int64 :: *)
                                      ~R# (CIntMax -> CIntMax -> CIntMax :: *))
                           GHC.Int.$fIntegralInt64_$crem
                           `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                   ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                   ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                   :: (Int64 -> Int64 -> Int64 :: *)
                                      ~R# (CIntMax -> CIntMax -> CIntMax :: *))
                           GHC.Int.$fIntegralInt64_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                   ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                   ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                   :: (Int64 -> Int64 -> Int64 :: *)
                                      ~R# (CIntMax -> CIntMax -> CIntMax :: *))
                           GHC.Int.$fIntegralInt64_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                   ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                   ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                   :: (Int64 -> Int64 -> Int64 :: *)
                                      ~R# (CIntMax -> CIntMax -> CIntMax :: *))
                           GHC.Int.$fIntegralInt64_$cquotRem
                           `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                   ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CIntMax[0]))
                                           (Sym (Foreign.C.Types.N:CIntMax[0])))_R
                                   :: (Int64 -> Int64 -> (Int64, Int64) :: *)
                                      ~R# (CIntMax -> CIntMax -> (CIntMax, CIntMax) :: *))
                           GHC.Int.$fIntegralInt64_$cdivMod
                           `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                   ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CIntMax[0]))
                                           (Sym (Foreign.C.Types.N:CIntMax[0])))_R
                                   :: (Int64 -> Int64 -> (Int64, Int64) :: *)
                                      ~R# (CIntMax -> CIntMax -> (CIntMax, CIntMax) :: *))
                           GHC.Int.$fIntegralInt64_$ctoInteger
                           `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Integer>_R
                                   :: (Int64 -> Integer :: *) ~R# (CIntMax -> Integer :: *))]
Foreign.C.Types.$fIntegralCIntMax
  = GHC.Real.C:Integral
      @ CIntMax
      Foreign.C.Types.$fRealCIntMax
      Foreign.C.Types.$fEnumCIntMax
      (GHC.Int.$fIntegralInt64_$cquot
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntMax -> CIntMax -> CIntMax :: *)))
      (GHC.Int.$fIntegralInt64_$crem
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntMax -> CIntMax -> CIntMax :: *)))
      (GHC.Int.$fIntegralInt64_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntMax -> CIntMax -> CIntMax :: *)))
      (GHC.Int.$fIntegralInt64_$cmod
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntMax -> CIntMax -> CIntMax :: *)))
      (GHC.Int.$fIntegralInt64_$cquotRem
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CIntMax[0]))
                       (Sym (Foreign.C.Types.N:CIntMax[0])))_R
               :: (Int64 -> Int64 -> (Int64, Int64) :: *)
                  ~R# (CIntMax -> CIntMax -> (CIntMax, CIntMax) :: *)))
      (GHC.Int.$fIntegralInt64_$cdivMod
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CIntMax[0]))
                       (Sym (Foreign.C.Types.N:CIntMax[0])))_R
               :: (Int64 -> Int64 -> (Int64, Int64) :: *)
                  ~R# (CIntMax -> CIntMax -> (CIntMax, CIntMax) :: *)))
      (GHC.Int.$fIntegralInt64_$ctoInteger
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Integer>_R
               :: (Int64 -> Integer :: *) ~R# (CIntMax -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.C.Types.$fBitsCIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits CIntMax
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: CIntMax
                        Foreign.C.Types.$fEqCIntMax
                        GHC.Int.$fBitsInt64_$c.&.
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                :: (Int64 -> Int64 -> Int64 :: *)
                                   ~R# (CIntMax -> CIntMax -> CIntMax :: *))
                        GHC.Int.$fBitsInt64_$c.|.
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                :: (Int64 -> Int64 -> Int64 :: *)
                                   ~R# (CIntMax -> CIntMax -> CIntMax :: *))
                        GHC.Int.$fBitsInt64_$cxor
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                :: (Int64 -> Int64 -> Int64 :: *)
                                   ~R# (CIntMax -> CIntMax -> CIntMax :: *))
                        GHC.Int.$fBitsInt64_$ccomplement
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                :: (Int64 -> Int64 :: *) ~R# (CIntMax -> CIntMax :: *))
                        GHC.Int.$fBitsInt64_$cshift
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntMax -> Int -> CIntMax :: *))
                        GHC.Int.$fBitsInt64_$crotate
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntMax -> Int -> CIntMax :: *))
                        GHC.Int.$fBitsInt10
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                :: (Int64 :: *) ~R# (CIntMax :: *))
                        GHC.Int.$fBitsInt64_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                :: (Int -> Int64 :: *) ~R# (Int -> CIntMax :: *))
                        GHC.Int.$fBitsInt64_$csetBit
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntMax -> Int -> CIntMax :: *))
                        GHC.Int.$fBitsInt64_$cclearBit
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntMax -> Int -> CIntMax :: *))
                        GHC.Int.$fBitsInt64_$ccomplementBit
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntMax -> Int -> CIntMax :: *))
                        GHC.Int.$fBitsInt64_$ctestBit
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Int -> Bool>_R
                                :: (Int64 -> Int -> Bool :: *) ~R# (CIntMax -> Int -> Bool :: *))
                        GHC.Int.$fBitsInt64_$cbitSizeMaybe
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Maybe Int>_R
                                :: (Int64 -> Maybe Int :: *) ~R# (CIntMax -> Maybe Int :: *))
                        GHC.Int.$fBitsInt64_$cfiniteBitSize
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Int>_R
                                :: (Int64 -> Int :: *) ~R# (CIntMax -> Int :: *))
                        GHC.Int.$fBitsInt64_$cisSigned
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Bool>_R
                                :: (Int64 -> Bool :: *) ~R# (CIntMax -> Bool :: *))
                        GHC.Int.$fBitsInt64_$cshiftL
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntMax -> Int -> CIntMax :: *))
                        GHC.Int.$fBitsInt64_$cunsafeShiftL
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntMax -> Int -> CIntMax :: *))
                        GHC.Int.$fBitsInt64_$cshiftR
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntMax -> Int -> CIntMax :: *))
                        GHC.Int.$fBitsInt64_$cunsafeShiftR
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntMax -> Int -> CIntMax :: *))
                        GHC.Int.$fBitsInt64_$crotateL
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntMax -> Int -> CIntMax :: *))
                        GHC.Int.$fBitsInt64_$crotateR
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntMax -> Int -> CIntMax :: *))
                        GHC.Int.$fBitsInt64_$cpopCount
                        `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Int>_R
                                :: (Int64 -> Int :: *) ~R# (CIntMax -> Int :: *))]
Foreign.C.Types.$fBitsCIntMax
  = Data.Bits.C:Bits
      @ CIntMax
      Foreign.C.Types.$fEqCIntMax
      (GHC.Int.$fBitsInt64_$c.&.
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntMax -> CIntMax -> CIntMax :: *)))
      (GHC.Int.$fBitsInt64_$c.|.
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntMax -> CIntMax -> CIntMax :: *)))
      (GHC.Int.$fBitsInt64_$cxor
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntMax -> CIntMax -> CIntMax :: *)))
      (GHC.Int.$fBitsInt64_$ccomplement
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int64 :: *) ~R# (CIntMax -> CIntMax :: *)))
      (GHC.Int.$fBitsInt64_$cshift
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntMax -> Int -> CIntMax :: *)))
      (GHC.Int.$fBitsInt64_$crotate
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntMax -> Int -> CIntMax :: *)))
      (GHC.Int.$fBitsInt10
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 :: *) ~R# (CIntMax :: *)))
      (GHC.Int.$fBitsInt64_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int -> Int64 :: *) ~R# (Int -> CIntMax :: *)))
      (GHC.Int.$fBitsInt64_$csetBit
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntMax -> Int -> CIntMax :: *)))
      (GHC.Int.$fBitsInt64_$cclearBit
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntMax -> Int -> CIntMax :: *)))
      (GHC.Int.$fBitsInt64_$ccomplementBit
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntMax -> Int -> CIntMax :: *)))
      (GHC.Int.$fBitsInt64_$ctestBit
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Int -> Bool>_R
               :: (Int64 -> Int -> Bool :: *) ~R# (CIntMax -> Int -> Bool :: *)))
      (GHC.Int.$fBitsInt64_$cbitSizeMaybe
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Maybe Int>_R
               :: (Int64 -> Maybe Int :: *) ~R# (CIntMax -> Maybe Int :: *)))
      (GHC.Int.$fBitsInt64_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CIntMax -> Int :: *)))
      (GHC.Int.$fBitsInt64_$cisSigned
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Bool>_R
               :: (Int64 -> Bool :: *) ~R# (CIntMax -> Bool :: *)))
      (GHC.Int.$fBitsInt64_$cshiftL
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntMax -> Int -> CIntMax :: *)))
      (GHC.Int.$fBitsInt64_$cunsafeShiftL
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntMax -> Int -> CIntMax :: *)))
      (GHC.Int.$fBitsInt64_$cshiftR
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntMax -> Int -> CIntMax :: *)))
      (GHC.Int.$fBitsInt64_$cunsafeShiftR
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntMax -> Int -> CIntMax :: *)))
      (GHC.Int.$fBitsInt64_$crotateL
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntMax -> Int -> CIntMax :: *)))
      (GHC.Int.$fBitsInt64_$crotateR
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntMax[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntMax -> Int -> CIntMax :: *)))
      (GHC.Int.$fBitsInt64_$cpopCount
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CIntMax -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.C.Types.$fFiniteBitsCIntMax [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits CIntMax
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: CIntMax
                              Foreign.C.Types.$fBitsCIntMax
                              GHC.Int.$fBitsInt64_$cfiniteBitSize
                              `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Int>_R
                                      :: (Int64 -> Int :: *) ~R# (CIntMax -> Int :: *))
                              GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros
                              `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Int>_R
                                      :: (Int64 -> Int :: *) ~R# (CIntMax -> Int :: *))
                              GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros
                              `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Int>_R
                                      :: (Int64 -> Int :: *) ~R# (CIntMax -> Int :: *))]
Foreign.C.Types.$fFiniteBitsCIntMax
  = Data.Bits.C:FiniteBits
      @ CIntMax
      Foreign.C.Types.$fBitsCIntMax
      (GHC.Int.$fBitsInt64_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CIntMax -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CIntMax -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros
       `cast` (Sym (Foreign.C.Types.N:CIntMax[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CIntMax -> Int :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCUIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CUIntPtr
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CUIntPtr
                       GHC.Word.$fShowWord64_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Word64 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CUIntPtr -> [Char] -> [Char] :: *))
                       GHC.Word.$fShowWord64_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <[Char]>_R
                               :: (Word64 -> [Char] :: *) ~R# (CUIntPtr -> [Char] :: *))
                       GHC.Word.$fShowWord64_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CUIntPtr[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Word64] -> [Char] -> [Char] :: *)
                                  ~R# ([CUIntPtr] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCUIntPtr
  = GHC.Show.C:Show
      @ CUIntPtr
      (GHC.Word.$fShowWord64_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Word64 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CUIntPtr -> [Char] -> [Char] :: *)))
      (GHC.Word.$fShowWord64_$cshow
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <[Char]>_R
               :: (Word64 -> [Char] :: *) ~R# (CUIntPtr -> [Char] :: *)))
      (GHC.Word.$fShowWord64_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CUIntPtr[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Word64] -> [Char] -> [Char] :: *)
                  ~R# ([CUIntPtr] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCUIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CUIntPtr
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CUIntPtr
                       GHC.Read.$fReadWord64_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CUIntPtr[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Word64, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CUIntPtr, [Char])] :: *))
                       GHC.Read.$fReadWord64_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CUIntPtr[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Word64], [Char])] :: *)
                                  ~R# ([Char] -> [([CUIntPtr], [Char])] :: *))
                       GHC.Read.$fReadWord13
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Word64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      (Foreign.C.Types.N:CUIntPtr[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Word64 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CUIntPtr :: *))
                       GHC.Read.$fReadWord11
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Word64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                        ([Foreign.C.Types.N:CUIntPtr[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Word64] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CUIntPtr] :: *))]
Foreign.C.Types.$fReadCUIntPtr
  = GHC.Read.C:Read
      @ CUIntPtr
      (GHC.Read.$fReadWord64_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CUIntPtr[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Word64, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CUIntPtr, [Char])] :: *)))
      (GHC.Read.$fReadWord64_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CUIntPtr[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Word64], [Char])] :: *)
                  ~R# ([Char] -> [([CUIntPtr], [Char])] :: *)))
      (GHC.Read.$fReadWord13
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Word64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                      (Foreign.C.Types.N:CUIntPtr[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Word64 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CUIntPtr :: *)))
      (GHC.Read.$fReadWord11
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Word64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        ([Foreign.C.Types.N:CUIntPtr[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Word64] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CUIntPtr] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.C.Types.$fBoundedCUIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded CUIntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: CUIntPtr
                          GHC.Word.$fBitsWord7
                          `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                  :: (Word64 :: *) ~R# (CUIntPtr :: *))
                          GHC.Word.$fBoundedWord64_$cmaxBound
                          `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                  :: (Word64 :: *) ~R# (CUIntPtr :: *))]
Foreign.C.Types.$fBoundedCUIntPtr
  = GHC.Enum.C:Bounded
      @ CUIntPtr
      (GHC.Word.$fBitsWord7
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 :: *) ~R# (CUIntPtr :: *)))
      (GHC.Word.$fBoundedWord64_$cmaxBound
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 :: *) ~R# (CUIntPtr :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCUIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CUIntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CUIntPtr
                                   Foreign.Storable.$fStorableWord64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Int>_R
                                           :: (Word64 -> Int :: *) ~R# (CUIntPtr -> Int :: *))
                                   Foreign.Storable.$fStorableWord64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Int>_R
                                           :: (Word64 -> Int :: *) ~R# (CUIntPtr -> Int :: *))
                                   GHC.Storable.readWord64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word64, CUIntPtr))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CUIntPtr[0]))
                                           :: (GHC.Ptr.Ptr Word64
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUIntPtr -> Int -> IO CUIntPtr :: *))
                                   GHC.Storable.writeWord64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word64, CUIntPtr))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Word64
                                               -> Int
                                               -> Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUIntPtr
                                                   -> Int -> CUIntPtr -> IO () :: *))
                                   Foreign.Storable.$fStorableWord18
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CUIntPtr[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word64 #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> IO CUIntPtr :: *))
                                   Foreign.Storable.$fStorableWord17
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CUIntPtr -> IO () :: *))
                                   Foreign.Storable.$fStorableWord15
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word64, CUIntPtr))_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CUIntPtr[0]))
                                           :: (GHC.Ptr.Ptr Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUIntPtr -> IO CUIntPtr :: *))
                                   Foreign.Storable.$fStorableWord14
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word64, CUIntPtr))_R
                                           ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Word64
                                               -> Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUIntPtr -> CUIntPtr -> IO () :: *))]
Foreign.C.Types.$fStorableCUIntPtr
  = Foreign.Storable.C:Storable
      @ CUIntPtr
      (Foreign.Storable.$fStorableWord64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CUIntPtr -> Int :: *)))
      (Foreign.Storable.$fStorableWord64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CUIntPtr -> Int :: *)))
      (GHC.Storable.readWord64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word64, CUIntPtr))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUIntPtr[0]))
               :: (GHC.Ptr.Ptr Word64
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CUIntPtr -> Int -> IO CUIntPtr :: *)))
      (GHC.Storable.writeWord64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word64, CUIntPtr))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Word64
                   -> Int
                   -> Word64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CUIntPtr -> Int -> CUIntPtr -> IO () :: *)))
      (Foreign.Storable.$fStorableWord18
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUIntPtr[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word64 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CUIntPtr :: *)))
      (Foreign.Storable.$fStorableWord17
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Word64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CUIntPtr -> IO () :: *)))
      (Foreign.Storable.$fStorableWord15
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word64, CUIntPtr))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUIntPtr[0]))
               :: (GHC.Ptr.Ptr Word64
                   -> State# RealWorld -> (# State# RealWorld, Word64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CUIntPtr -> IO CUIntPtr :: *)))
      (Foreign.Storable.$fStorableWord14
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word64, CUIntPtr))_R
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Word64
                   -> Word64 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CUIntPtr -> CUIntPtr -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCUIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CUIntPtr
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CUIntPtr
                       GHC.Word.$fEnumWord64_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                               :: (Word64 -> Word64 :: *) ~R# (CUIntPtr -> CUIntPtr :: *))
                       GHC.Word.$fEnumWord64_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                               :: (Word64 -> Word64 :: *) ~R# (CUIntPtr -> CUIntPtr :: *))
                       GHC.Word.$fEnumWord64_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                               :: (Int -> Word64 :: *) ~R# (Int -> CUIntPtr :: *))
                       GHC.Word.$fEnumWord64_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Int>_R
                               :: (Word64 -> Int :: *) ~R# (CUIntPtr -> Int :: *))
                       GHC.Word.$fEnumWord64_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUIntPtr[0])])_R
                               :: (Word64 -> [Word64] :: *) ~R# (CUIntPtr -> [CUIntPtr] :: *))
                       GHC.Word.$fEnumWord64_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUIntPtr[0])])_R
                               :: (Word64 -> Word64 -> [Word64] :: *)
                                  ~R# (CUIntPtr -> CUIntPtr -> [CUIntPtr] :: *))
                       GHC.Word.$fEnumWord64_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUIntPtr[0])])_R
                               :: (Word64 -> Word64 -> [Word64] :: *)
                                  ~R# (CUIntPtr -> CUIntPtr -> [CUIntPtr] :: *))
                       GHC.Word.$fEnumWord64_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUIntPtr[0])])_R
                               :: (Word64 -> Word64 -> Word64 -> [Word64] :: *)
                                  ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr -> [CUIntPtr] :: *))]
Foreign.C.Types.$fEnumCUIntPtr
  = GHC.Enum.C:Enum
      @ CUIntPtr
      (GHC.Word.$fEnumWord64_$csucc
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Word64 :: *) ~R# (CUIntPtr -> CUIntPtr :: *)))
      (GHC.Word.$fEnumWord64_$cpred
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Word64 :: *) ~R# (CUIntPtr -> CUIntPtr :: *)))
      (GHC.Word.$fEnumWord64_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Int -> Word64 :: *) ~R# (Int -> CUIntPtr :: *)))
      (GHC.Word.$fEnumWord64_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CUIntPtr -> Int :: *)))
      (GHC.Word.$fEnumWord64_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R ([Sym (Foreign.C.Types.N:CUIntPtr[0])])_R
               :: (Word64 -> [Word64] :: *) ~R# (CUIntPtr -> [CUIntPtr] :: *)))
      (GHC.Word.$fEnumWord64_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R ([Sym (Foreign.C.Types.N:CUIntPtr[0])])_R
               :: (Word64 -> Word64 -> [Word64] :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> [CUIntPtr] :: *)))
      (GHC.Word.$fEnumWord64_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R ([Sym (Foreign.C.Types.N:CUIntPtr[0])])_R
               :: (Word64 -> Word64 -> [Word64] :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> [CUIntPtr] :: *)))
      (GHC.Word.$fEnumWord64_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R ([Sym (Foreign.C.Types.N:CUIntPtr[0])])_R
               :: (Word64 -> Word64 -> Word64 -> [Word64] :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr -> [CUIntPtr] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCUIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CUIntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CUIntPtr
                     GHC.Word.$fNumWord64_$c+
                     `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                             ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                             ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                             :: (Word64 -> Word64 -> Word64 :: *)
                                ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *))
                     GHC.Word.$fNumWord64_$c-
                     `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                             ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                             ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                             :: (Word64 -> Word64 -> Word64 :: *)
                                ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *))
                     GHC.Word.$fNumWord64_$c*
                     `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                             ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                             ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                             :: (Word64 -> Word64 -> Word64 :: *)
                                ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *))
                     GHC.Word.$fNumWord64_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                             ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                             :: (Word64 -> Word64 :: *) ~R# (CUIntPtr -> CUIntPtr :: *))
                     GHC.Word.$fNumWord64_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                             ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                             :: (Word64 -> Word64 :: *) ~R# (CUIntPtr -> CUIntPtr :: *))
                     GHC.Word.$fNumWord64_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                             ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                             :: (Word64 -> Word64 :: *) ~R# (CUIntPtr -> CUIntPtr :: *))
                     GHC.Word.$fNumWord64_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                             :: (Integer -> Word64 :: *) ~R# (Integer -> CUIntPtr :: *))]
Foreign.C.Types.$fNumCUIntPtr
  = GHC.Num.C:Num
      @ CUIntPtr
      (GHC.Word.$fNumWord64_$c+
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *)))
      (GHC.Word.$fNumWord64_$c-
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *)))
      (GHC.Word.$fNumWord64_$c*
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *)))
      (GHC.Word.$fNumWord64_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Word64 :: *) ~R# (CUIntPtr -> CUIntPtr :: *)))
      (GHC.Word.$fNumWord64_$cabs
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Word64 :: *) ~R# (CUIntPtr -> CUIntPtr :: *)))
      (GHC.Word.$fNumWord64_$csignum
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Word64 :: *) ~R# (CUIntPtr -> CUIntPtr :: *)))
      (GHC.Word.$fNumWord64_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Integer -> Word64 :: *) ~R# (Integer -> CUIntPtr :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCUIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CUIntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CUIntPtr
                        GHC.Word.eqWord64
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R <Bool>_R
                                :: (Word64 -> Word64 -> Bool :: *)
                                   ~R# (CUIntPtr -> CUIntPtr -> Bool :: *))
                        GHC.Word.neWord64
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R <Bool>_R
                                :: (Word64 -> Word64 -> Bool :: *)
                                   ~R# (CUIntPtr -> CUIntPtr -> Bool :: *))]
Foreign.C.Types.$fEqCUIntPtr
  = GHC.Classes.C:Eq
      @ CUIntPtr
      (GHC.Word.eqWord64
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> Bool :: *)))
      (GHC.Word.neWord64
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCUIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CUIntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CUIntPtr
                         Foreign.C.Types.$fEqCUIntPtr
                         GHC.Word.$fOrdWord64_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                 ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                 ->_R <Ordering>_R
                                 :: (Word64 -> Word64 -> Ordering :: *)
                                    ~R# (CUIntPtr -> CUIntPtr -> Ordering :: *))
                         GHC.Word.ltWord64
                         `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                 ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                 ->_R <Bool>_R
                                 :: (Word64 -> Word64 -> Bool :: *)
                                    ~R# (CUIntPtr -> CUIntPtr -> Bool :: *))
                         GHC.Word.leWord64
                         `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                 ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                 ->_R <Bool>_R
                                 :: (Word64 -> Word64 -> Bool :: *)
                                    ~R# (CUIntPtr -> CUIntPtr -> Bool :: *))
                         GHC.Word.gtWord64
                         `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                 ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                 ->_R <Bool>_R
                                 :: (Word64 -> Word64 -> Bool :: *)
                                    ~R# (CUIntPtr -> CUIntPtr -> Bool :: *))
                         GHC.Word.geWord64
                         `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                 ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                 ->_R <Bool>_R
                                 :: (Word64 -> Word64 -> Bool :: *)
                                    ~R# (CUIntPtr -> CUIntPtr -> Bool :: *))
                         GHC.Word.$fOrdWord64_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                 ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                 ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                 :: (Word64 -> Word64 -> Word64 :: *)
                                    ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *))
                         GHC.Word.$fOrdWord64_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                 ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                 ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                 :: (Word64 -> Word64 -> Word64 :: *)
                                    ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *))]
Foreign.C.Types.$fOrdCUIntPtr
  = GHC.Classes.C:Ord
      @ CUIntPtr
      Foreign.C.Types.$fEqCUIntPtr
      (GHC.Word.$fOrdWord64_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R <Ordering>_R
               :: (Word64 -> Word64 -> Ordering :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> Ordering :: *)))
      (GHC.Word.ltWord64
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> Bool :: *)))
      (GHC.Word.leWord64
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> Bool :: *)))
      (GHC.Word.gtWord64
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> Bool :: *)))
      (GHC.Word.geWord64
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> Bool :: *)))
      (GHC.Word.$fOrdWord64_$cmax
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *)))
      (GHC.Word.$fOrdWord64_$cmin
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCUIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CUIntPtr
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CUIntPtr
                       Foreign.C.Types.$fNumCUIntPtr
                       Foreign.C.Types.$fOrdCUIntPtr
                       GHC.Word.$fRealWord64_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Ratio Integer>_R
                               :: (Word64 -> Ratio Integer :: *)
                                  ~R# (CUIntPtr -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCUIntPtr
  = GHC.Real.C:Real
      @ CUIntPtr
      Foreign.C.Types.$fNumCUIntPtr
      Foreign.C.Types.$fOrdCUIntPtr
      (GHC.Word.$fRealWord64_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Ratio Integer>_R
               :: (Word64 -> Ratio Integer :: *)
                  ~R# (CUIntPtr -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.C.Types.$fIntegralCUIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral CUIntPtr
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: CUIntPtr
                           Foreign.C.Types.$fRealCUIntPtr
                           Foreign.C.Types.$fEnumCUIntPtr
                           GHC.Word.$fIntegralWord64_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                   ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                   ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                   :: (Word64 -> Word64 -> Word64 :: *)
                                      ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *))
                           GHC.Word.$fIntegralWord64_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                   ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                   ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                   :: (Word64 -> Word64 -> Word64 :: *)
                                      ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *))
                           GHC.Word.$fIntegralWord64_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                   ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                   ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                   :: (Word64 -> Word64 -> Word64 :: *)
                                      ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *))
                           GHC.Word.$fIntegralWord64_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                   ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                   ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                   :: (Word64 -> Word64 -> Word64 :: *)
                                      ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *))
                           GHC.Word.$fIntegralWord64_$cquotRem
                           `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                   ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CUIntPtr[0]))
                                           (Sym (Foreign.C.Types.N:CUIntPtr[0])))_R
                                   :: (Word64 -> Word64 -> (Word64, Word64) :: *)
                                      ~R# (CUIntPtr -> CUIntPtr -> (CUIntPtr, CUIntPtr) :: *))
                           GHC.Word.$fIntegralWord64_$cdivMod
                           `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                   ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CUIntPtr[0]))
                                           (Sym (Foreign.C.Types.N:CUIntPtr[0])))_R
                                   :: (Word64 -> Word64 -> (Word64, Word64) :: *)
                                      ~R# (CUIntPtr -> CUIntPtr -> (CUIntPtr, CUIntPtr) :: *))
                           GHC.Word.$fIntegralWord64_$ctoInteger
                           `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Integer>_R
                                   :: (Word64 -> Integer :: *) ~R# (CUIntPtr -> Integer :: *))]
Foreign.C.Types.$fIntegralCUIntPtr
  = GHC.Real.C:Integral
      @ CUIntPtr
      Foreign.C.Types.$fRealCUIntPtr
      Foreign.C.Types.$fEnumCUIntPtr
      (GHC.Word.$fIntegralWord64_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *)))
      (GHC.Word.$fIntegralWord64_$cmod
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *)))
      (GHC.Word.$fIntegralWord64_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *)))
      (GHC.Word.$fIntegralWord64_$cmod
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *)))
      (GHC.Word.$fIntegralWord64_$cquotRem
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CUIntPtr[0]))
                       (Sym (Foreign.C.Types.N:CUIntPtr[0])))_R
               :: (Word64 -> Word64 -> (Word64, Word64) :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> (CUIntPtr, CUIntPtr) :: *)))
      (GHC.Word.$fIntegralWord64_$cdivMod
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CUIntPtr[0]))
                       (Sym (Foreign.C.Types.N:CUIntPtr[0])))_R
               :: (Word64 -> Word64 -> (Word64, Word64) :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> (CUIntPtr, CUIntPtr) :: *)))
      (GHC.Word.$fIntegralWord64_$ctoInteger
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Integer>_R
               :: (Word64 -> Integer :: *) ~R# (CUIntPtr -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.C.Types.$fBitsCUIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits CUIntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: CUIntPtr
                        Foreign.C.Types.$fEqCUIntPtr
                        GHC.Word.$fBitsWord64_$c.&.
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                :: (Word64 -> Word64 -> Word64 :: *)
                                   ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *))
                        GHC.Word.$fBitsWord64_$c.|.
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                :: (Word64 -> Word64 -> Word64 :: *)
                                   ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *))
                        GHC.Word.$fBitsWord64_$cxor
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                :: (Word64 -> Word64 -> Word64 :: *)
                                   ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *))
                        GHC.Word.$fBitsWord64_$ccomplement
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                :: (Word64 -> Word64 :: *) ~R# (CUIntPtr -> CUIntPtr :: *))
                        GHC.Word.$fBitsWord64_$cshift
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntPtr -> Int -> CUIntPtr :: *))
                        GHC.Word.$fBitsWord64_$crotate
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntPtr -> Int -> CUIntPtr :: *))
                        GHC.Word.$fBitsWord7
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                :: (Word64 :: *) ~R# (CUIntPtr :: *))
                        GHC.Word.$fBitsWord64_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                :: (Int -> Word64 :: *) ~R# (Int -> CUIntPtr :: *))
                        GHC.Word.$fBitsWord64_$csetBit
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntPtr -> Int -> CUIntPtr :: *))
                        GHC.Word.$fBitsWord64_$cclearBit
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntPtr -> Int -> CUIntPtr :: *))
                        GHC.Word.$fBitsWord64_$ccomplementBit
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntPtr -> Int -> CUIntPtr :: *))
                        GHC.Word.$fBitsWord64_$ctestBit
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Int -> Bool>_R
                                :: (Word64 -> Int -> Bool :: *) ~R# (CUIntPtr -> Int -> Bool :: *))
                        GHC.Word.$fBitsWord64_$cbitSizeMaybe
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Maybe Int>_R
                                :: (Word64 -> Maybe Int :: *) ~R# (CUIntPtr -> Maybe Int :: *))
                        GHC.Word.$fBitsWord64_$cfiniteBitSize
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Int>_R
                                :: (Word64 -> Int :: *) ~R# (CUIntPtr -> Int :: *))
                        GHC.Word.$fBitsWord64_$cisSigned
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Bool>_R
                                :: (Word64 -> Bool :: *) ~R# (CUIntPtr -> Bool :: *))
                        GHC.Word.$fBitsWord64_$cshiftL
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntPtr -> Int -> CUIntPtr :: *))
                        GHC.Word.$fBitsWord64_$cunsafeShiftL
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntPtr -> Int -> CUIntPtr :: *))
                        GHC.Word.$fBitsWord64_$cshiftR
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntPtr -> Int -> CUIntPtr :: *))
                        GHC.Word.$fBitsWord64_$cunsafeShiftR
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntPtr -> Int -> CUIntPtr :: *))
                        GHC.Word.$fBitsWord64_$crotateL
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntPtr -> Int -> CUIntPtr :: *))
                        GHC.Word.$fBitsWord64_$crotateR
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CUIntPtr -> Int -> CUIntPtr :: *))
                        GHC.Word.$fBitsWord64_$cpopCount
                        `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Int>_R
                                :: (Word64 -> Int :: *) ~R# (CUIntPtr -> Int :: *))]
Foreign.C.Types.$fBitsCUIntPtr
  = Data.Bits.C:Bits
      @ CUIntPtr
      Foreign.C.Types.$fEqCUIntPtr
      (GHC.Word.$fBitsWord64_$c.&.
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *)))
      (GHC.Word.$fBitsWord64_$c.|.
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *)))
      (GHC.Word.$fBitsWord64_$cxor
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CUIntPtr -> CUIntPtr -> CUIntPtr :: *)))
      (GHC.Word.$fBitsWord64_$ccomplement
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Word64 :: *) ~R# (CUIntPtr -> CUIntPtr :: *)))
      (GHC.Word.$fBitsWord64_$cshift
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntPtr -> Int -> CUIntPtr :: *)))
      (GHC.Word.$fBitsWord64_$crotate
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntPtr -> Int -> CUIntPtr :: *)))
      (GHC.Word.$fBitsWord7
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 :: *) ~R# (CUIntPtr :: *)))
      (GHC.Word.$fBitsWord64_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Int -> Word64 :: *) ~R# (Int -> CUIntPtr :: *)))
      (GHC.Word.$fBitsWord64_$csetBit
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntPtr -> Int -> CUIntPtr :: *)))
      (GHC.Word.$fBitsWord64_$cclearBit
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntPtr -> Int -> CUIntPtr :: *)))
      (GHC.Word.$fBitsWord64_$ccomplementBit
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntPtr -> Int -> CUIntPtr :: *)))
      (GHC.Word.$fBitsWord64_$ctestBit
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Int -> Bool>_R
               :: (Word64 -> Int -> Bool :: *)
                  ~R# (CUIntPtr -> Int -> Bool :: *)))
      (GHC.Word.$fBitsWord64_$cbitSizeMaybe
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Maybe Int>_R
               :: (Word64 -> Maybe Int :: *) ~R# (CUIntPtr -> Maybe Int :: *)))
      (GHC.Word.$fBitsWord64_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CUIntPtr -> Int :: *)))
      (GHC.Word.$fBitsWord64_$cisSigned
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Bool>_R
               :: (Word64 -> Bool :: *) ~R# (CUIntPtr -> Bool :: *)))
      (GHC.Word.$fBitsWord64_$cshiftL
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntPtr -> Int -> CUIntPtr :: *)))
      (GHC.Word.$fBitsWord64_$cunsafeShiftL
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntPtr -> Int -> CUIntPtr :: *)))
      (GHC.Word.$fBitsWord64_$cshiftR
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntPtr -> Int -> CUIntPtr :: *)))
      (GHC.Word.$fBitsWord64_$cunsafeShiftR
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntPtr -> Int -> CUIntPtr :: *)))
      (GHC.Word.$fBitsWord64_$crotateL
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntPtr -> Int -> CUIntPtr :: *)))
      (GHC.Word.$fBitsWord64_$crotateR
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CUIntPtr -> Int -> CUIntPtr :: *)))
      (GHC.Word.$fBitsWord64_$cpopCount
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CUIntPtr -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.C.Types.$fFiniteBitsCUIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits CUIntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: CUIntPtr
                              Foreign.C.Types.$fBitsCUIntPtr
                              GHC.Word.$fBitsWord64_$cfiniteBitSize
                              `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Int>_R
                                      :: (Word64 -> Int :: *) ~R# (CUIntPtr -> Int :: *))
                              GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
                              `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Int>_R
                                      :: (Word64 -> Int :: *) ~R# (CUIntPtr -> Int :: *))
                              GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros
                              `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Int>_R
                                      :: (Word64 -> Int :: *) ~R# (CUIntPtr -> Int :: *))]
Foreign.C.Types.$fFiniteBitsCUIntPtr
  = Data.Bits.C:FiniteBits
      @ CUIntPtr
      Foreign.C.Types.$fBitsCUIntPtr
      (GHC.Word.$fBitsWord64_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CUIntPtr -> Int :: *)))
      (GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CUIntPtr -> Int :: *)))
      (GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros
       `cast` (Sym (Foreign.C.Types.N:CUIntPtr[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CUIntPtr -> Int :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CIntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CIntPtr
                       GHC.Int.$fShowInt64_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Int64 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CIntPtr -> [Char] -> [Char] :: *))
                       GHC.Int.$fShowInt64_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <[Char]>_R
                               :: (Int64 -> [Char] :: *) ~R# (CIntPtr -> [Char] :: *))
                       GHC.Int.$fShowInt64_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CIntPtr[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Int64] -> [Char] -> [Char] :: *)
                                  ~R# ([CIntPtr] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCIntPtr
  = GHC.Show.C:Show
      @ CIntPtr
      (GHC.Int.$fShowInt64_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Int64 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CIntPtr -> [Char] -> [Char] :: *)))
      (GHC.Int.$fShowInt64_$cshow
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <[Char]>_R
               :: (Int64 -> [Char] :: *) ~R# (CIntPtr -> [Char] :: *)))
      (GHC.Int.$fShowInt64_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CIntPtr[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Int64] -> [Char] -> [Char] :: *)
                  ~R# ([CIntPtr] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CIntPtr
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CIntPtr
                       GHC.Int.$fReadInt64_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CIntPtr[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Int64, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CIntPtr, [Char])] :: *))
                       GHC.Int.$fReadInt64_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CIntPtr[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Int64], [Char])] :: *)
                                  ~R# ([Char] -> [([CIntPtr], [Char])] :: *))
                       GHC.Int.$fReadInt10
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Int64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     (Foreign.C.Types.N:CIntPtr[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Int64 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CIntPtr :: *))
                       GHC.Int.$fReadInt7
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Int64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       ([Foreign.C.Types.N:CIntPtr[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Int64] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CIntPtr] :: *))]
Foreign.C.Types.$fReadCIntPtr
  = GHC.Read.C:Read
      @ CIntPtr
      (GHC.Int.$fReadInt64_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CIntPtr[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Int64, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CIntPtr, [Char])] :: *)))
      (GHC.Int.$fReadInt64_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CIntPtr[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Int64], [Char])] :: *)
                  ~R# ([Char] -> [([CIntPtr], [Char])] :: *)))
      (GHC.Int.$fReadInt10
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Int64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                     (Foreign.C.Types.N:CIntPtr[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Int64 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CIntPtr :: *)))
      (GHC.Int.$fReadInt7
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Int64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       ([Foreign.C.Types.N:CIntPtr[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Int64] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CIntPtr] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.C.Types.$fBoundedCIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded CIntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: CIntPtr
                          GHC.Int.$fBoundedInt64_$cminBound
                          `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                  :: (Int64 :: *) ~R# (CIntPtr :: *))
                          GHC.Int.$fBoundedInt64_$cmaxBound
                          `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                  :: (Int64 :: *) ~R# (CIntPtr :: *))]
Foreign.C.Types.$fBoundedCIntPtr
  = GHC.Enum.C:Bounded
      @ CIntPtr
      (GHC.Int.$fBoundedInt64_$cminBound
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 :: *) ~R# (CIntPtr :: *)))
      (GHC.Int.$fBoundedInt64_$cmaxBound
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 :: *) ~R# (CIntPtr :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CIntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CIntPtr
                                   Foreign.Storable.$fStorableInt64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Int>_R
                                           :: (Int64 -> Int :: *) ~R# (CIntPtr -> Int :: *))
                                   Foreign.Storable.$fStorableInt64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Int>_R
                                           :: (Int64 -> Int :: *) ~R# (CIntPtr -> Int :: *))
                                   GHC.Storable.readInt64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CIntPtr))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CIntPtr[0]))
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CIntPtr -> Int -> IO CIntPtr :: *))
                                   GHC.Storable.writeInt64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CIntPtr))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CIntPtr
                                                   -> Int -> CIntPtr -> IO () :: *))
                                   Foreign.Storable.$fStorableInt19
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CIntPtr[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> IO CIntPtr :: *))
                                   Foreign.Storable.$fStorableInt18
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CIntPtr -> IO () :: *))
                                   Foreign.Storable.$fStorableInt17
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CIntPtr))_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CIntPtr[0]))
                                           :: (GHC.Ptr.Ptr Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CIntPtr -> IO CIntPtr :: *))
                                   Foreign.Storable.$fStorableInt15
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CIntPtr))_R
                                           ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CIntPtr -> CIntPtr -> IO () :: *))]
Foreign.C.Types.$fStorableCIntPtr
  = Foreign.Storable.C:Storable
      @ CIntPtr
      (Foreign.Storable.$fStorableInt64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CIntPtr -> Int :: *)))
      (Foreign.Storable.$fStorableInt64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CIntPtr -> Int :: *)))
      (GHC.Storable.readInt64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CIntPtr))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CIntPtr[0]))
               :: (GHC.Ptr.Ptr Int64
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CIntPtr -> Int -> IO CIntPtr :: *)))
      (GHC.Storable.writeInt64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CIntPtr))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int64
                   -> Int
                   -> Int64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CIntPtr -> Int -> CIntPtr -> IO () :: *)))
      (Foreign.Storable.$fStorableInt19
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CIntPtr[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CIntPtr :: *)))
      (Foreign.Storable.$fStorableInt18
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Int64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CIntPtr -> IO () :: *)))
      (Foreign.Storable.$fStorableInt17
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CIntPtr))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CIntPtr[0]))
               :: (GHC.Ptr.Ptr Int64
                   -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CIntPtr -> IO CIntPtr :: *)))
      (Foreign.Storable.$fStorableInt15
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CIntPtr))_R
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int64
                   -> Int64 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CIntPtr -> CIntPtr -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CIntPtr
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CIntPtr
                       GHC.Int.$fEnumInt64_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                               :: (Int64 -> Int64 :: *) ~R# (CIntPtr -> CIntPtr :: *))
                       GHC.Int.$fEnumInt64_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                               :: (Int64 -> Int64 :: *) ~R# (CIntPtr -> CIntPtr :: *))
                       GHC.Int.$fEnumInt64_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                               :: (Int -> Int64 :: *) ~R# (Int -> CIntPtr :: *))
                       GHC.Int.$fEnumInt64_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Int>_R
                               :: (Int64 -> Int :: *) ~R# (CIntPtr -> Int :: *))
                       GHC.Int.$fEnumInt64_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                               ->_R ([Sym (Foreign.C.Types.N:CIntPtr[0])])_R
                               :: (Int64 -> [Int64] :: *) ~R# (CIntPtr -> [CIntPtr] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                               ->_R ([Sym (Foreign.C.Types.N:CIntPtr[0])])_R
                               :: (Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CIntPtr -> CIntPtr -> [CIntPtr] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                               ->_R ([Sym (Foreign.C.Types.N:CIntPtr[0])])_R
                               :: (Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CIntPtr -> CIntPtr -> [CIntPtr] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                               ->_R ([Sym (Foreign.C.Types.N:CIntPtr[0])])_R
                               :: (Int64 -> Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CIntPtr -> CIntPtr -> CIntPtr -> [CIntPtr] :: *))]
Foreign.C.Types.$fEnumCIntPtr
  = GHC.Enum.C:Enum
      @ CIntPtr
      (GHC.Int.$fEnumInt64_$csucc
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int64 :: *) ~R# (CIntPtr -> CIntPtr :: *)))
      (GHC.Int.$fEnumInt64_$cpred
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int64 :: *) ~R# (CIntPtr -> CIntPtr :: *)))
      (GHC.Int.$fEnumInt64_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int -> Int64 :: *) ~R# (Int -> CIntPtr :: *)))
      (GHC.Int.$fEnumInt64_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CIntPtr -> Int :: *)))
      (GHC.Int.$fEnumInt64_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R ([Sym (Foreign.C.Types.N:CIntPtr[0])])_R
               :: (Int64 -> [Int64] :: *) ~R# (CIntPtr -> [CIntPtr] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R ([Sym (Foreign.C.Types.N:CIntPtr[0])])_R
               :: (Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CIntPtr -> CIntPtr -> [CIntPtr] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R ([Sym (Foreign.C.Types.N:CIntPtr[0])])_R
               :: (Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CIntPtr -> CIntPtr -> [CIntPtr] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R ([Sym (Foreign.C.Types.N:CIntPtr[0])])_R
               :: (Int64 -> Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CIntPtr -> CIntPtr -> CIntPtr -> [CIntPtr] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CIntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CIntPtr
                     GHC.Int.$fNumInt64_$c+
                     `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                             ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                             ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *))
                     GHC.Int.$fNumInt64_$c-
                     `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                             ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                             ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *))
                     GHC.Int.$fNumInt64_$c*
                     `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                             ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                             ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *))
                     GHC.Int.$fNumInt64_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                             ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                             :: (Int64 -> Int64 :: *) ~R# (CIntPtr -> CIntPtr :: *))
                     GHC.Int.$fNumInt64_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                             ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                             :: (Int64 -> Int64 :: *) ~R# (CIntPtr -> CIntPtr :: *))
                     GHC.Int.$fNumInt64_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                             ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                             :: (Int64 -> Int64 :: *) ~R# (CIntPtr -> CIntPtr :: *))
                     GHC.Int.$fNumInt64_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                             :: (Integer -> Int64 :: *) ~R# (Integer -> CIntPtr :: *))]
Foreign.C.Types.$fNumCIntPtr
  = GHC.Num.C:Num
      @ CIntPtr
      (GHC.Int.$fNumInt64_$c+
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *)))
      (GHC.Int.$fNumInt64_$c-
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *)))
      (GHC.Int.$fNumInt64_$c*
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *)))
      (GHC.Int.$fNumInt64_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int64 :: *) ~R# (CIntPtr -> CIntPtr :: *)))
      (GHC.Int.$fNumInt64_$cabs
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int64 :: *) ~R# (CIntPtr -> CIntPtr :: *)))
      (GHC.Int.$fNumInt64_$csignum
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int64 :: *) ~R# (CIntPtr -> CIntPtr :: *)))
      (GHC.Int.$fNumInt64_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Integer -> Int64 :: *) ~R# (Integer -> CIntPtr :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CIntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CIntPtr
                        GHC.Int.eqInt64
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R <Bool>_R
                                :: (Int64 -> Int64 -> Bool :: *)
                                   ~R# (CIntPtr -> CIntPtr -> Bool :: *))
                        GHC.Int.neInt64
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R <Bool>_R
                                :: (Int64 -> Int64 -> Bool :: *)
                                   ~R# (CIntPtr -> CIntPtr -> Bool :: *))]
Foreign.C.Types.$fEqCIntPtr
  = GHC.Classes.C:Eq
      @ CIntPtr
      (GHC.Int.eqInt64
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CIntPtr -> CIntPtr -> Bool :: *)))
      (GHC.Int.neInt64
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CIntPtr -> CIntPtr -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CIntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CIntPtr
                         Foreign.C.Types.$fEqCIntPtr
                         GHC.Int.$fOrdInt64_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                 ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                 ->_R <Ordering>_R
                                 :: (Int64 -> Int64 -> Ordering :: *)
                                    ~R# (CIntPtr -> CIntPtr -> Ordering :: *))
                         GHC.Int.ltInt64
                         `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                 ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CIntPtr -> CIntPtr -> Bool :: *))
                         GHC.Int.leInt64
                         `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                 ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CIntPtr -> CIntPtr -> Bool :: *))
                         GHC.Int.gtInt64
                         `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                 ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CIntPtr -> CIntPtr -> Bool :: *))
                         GHC.Int.geInt64
                         `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                 ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CIntPtr -> CIntPtr -> Bool :: *))
                         GHC.Int.$fOrdInt64_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                 ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                 ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                 :: (Int64 -> Int64 -> Int64 :: *)
                                    ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *))
                         GHC.Int.$fOrdInt64_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                 ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                 ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                 :: (Int64 -> Int64 -> Int64 :: *)
                                    ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *))]
Foreign.C.Types.$fOrdCIntPtr
  = GHC.Classes.C:Ord
      @ CIntPtr
      Foreign.C.Types.$fEqCIntPtr
      (GHC.Int.$fOrdInt64_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R <Ordering>_R
               :: (Int64 -> Int64 -> Ordering :: *)
                  ~R# (CIntPtr -> CIntPtr -> Ordering :: *)))
      (GHC.Int.ltInt64
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CIntPtr -> CIntPtr -> Bool :: *)))
      (GHC.Int.leInt64
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CIntPtr -> CIntPtr -> Bool :: *)))
      (GHC.Int.gtInt64
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CIntPtr -> CIntPtr -> Bool :: *)))
      (GHC.Int.geInt64
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CIntPtr -> CIntPtr -> Bool :: *)))
      (GHC.Int.$fOrdInt64_$cmax
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *)))
      (GHC.Int.$fOrdInt64_$cmin
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CIntPtr
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CIntPtr
                       Foreign.C.Types.$fNumCIntPtr
                       Foreign.C.Types.$fOrdCIntPtr
                       GHC.Int.$fRealInt64_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Ratio Integer>_R
                               :: (Int64 -> Ratio Integer :: *)
                                  ~R# (CIntPtr -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCIntPtr
  = GHC.Real.C:Real
      @ CIntPtr
      Foreign.C.Types.$fNumCIntPtr
      Foreign.C.Types.$fOrdCIntPtr
      (GHC.Int.$fRealInt64_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Ratio Integer>_R
               :: (Int64 -> Ratio Integer :: *)
                  ~R# (CIntPtr -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.C.Types.$fIntegralCIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral CIntPtr
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: CIntPtr
                           Foreign.C.Types.$fRealCIntPtr
                           Foreign.C.Types.$fEnumCIntPtr
                           GHC.Int.$fIntegralInt64_$cquot
                           `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                   ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                   ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                   :: (Int64 -> Int64 -> Int64 :: *)
                                      ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *))
                           GHC.Int.$fIntegralInt64_$crem
                           `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                   ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                   ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                   :: (Int64 -> Int64 -> Int64 :: *)
                                      ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *))
                           GHC.Int.$fIntegralInt64_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                   ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                   ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                   :: (Int64 -> Int64 -> Int64 :: *)
                                      ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *))
                           GHC.Int.$fIntegralInt64_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                   ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                   ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                   :: (Int64 -> Int64 -> Int64 :: *)
                                      ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *))
                           GHC.Int.$fIntegralInt64_$cquotRem
                           `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                   ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CIntPtr[0]))
                                           (Sym (Foreign.C.Types.N:CIntPtr[0])))_R
                                   :: (Int64 -> Int64 -> (Int64, Int64) :: *)
                                      ~R# (CIntPtr -> CIntPtr -> (CIntPtr, CIntPtr) :: *))
                           GHC.Int.$fIntegralInt64_$cdivMod
                           `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                   ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CIntPtr[0]))
                                           (Sym (Foreign.C.Types.N:CIntPtr[0])))_R
                                   :: (Int64 -> Int64 -> (Int64, Int64) :: *)
                                      ~R# (CIntPtr -> CIntPtr -> (CIntPtr, CIntPtr) :: *))
                           GHC.Int.$fIntegralInt64_$ctoInteger
                           `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Integer>_R
                                   :: (Int64 -> Integer :: *) ~R# (CIntPtr -> Integer :: *))]
Foreign.C.Types.$fIntegralCIntPtr
  = GHC.Real.C:Integral
      @ CIntPtr
      Foreign.C.Types.$fRealCIntPtr
      Foreign.C.Types.$fEnumCIntPtr
      (GHC.Int.$fIntegralInt64_$cquot
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *)))
      (GHC.Int.$fIntegralInt64_$crem
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *)))
      (GHC.Int.$fIntegralInt64_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *)))
      (GHC.Int.$fIntegralInt64_$cmod
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *)))
      (GHC.Int.$fIntegralInt64_$cquotRem
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CIntPtr[0]))
                       (Sym (Foreign.C.Types.N:CIntPtr[0])))_R
               :: (Int64 -> Int64 -> (Int64, Int64) :: *)
                  ~R# (CIntPtr -> CIntPtr -> (CIntPtr, CIntPtr) :: *)))
      (GHC.Int.$fIntegralInt64_$cdivMod
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CIntPtr[0]))
                       (Sym (Foreign.C.Types.N:CIntPtr[0])))_R
               :: (Int64 -> Int64 -> (Int64, Int64) :: *)
                  ~R# (CIntPtr -> CIntPtr -> (CIntPtr, CIntPtr) :: *)))
      (GHC.Int.$fIntegralInt64_$ctoInteger
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Integer>_R
               :: (Int64 -> Integer :: *) ~R# (CIntPtr -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.C.Types.$fBitsCIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits CIntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: CIntPtr
                        Foreign.C.Types.$fEqCIntPtr
                        GHC.Int.$fBitsInt64_$c.&.
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                :: (Int64 -> Int64 -> Int64 :: *)
                                   ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *))
                        GHC.Int.$fBitsInt64_$c.|.
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                :: (Int64 -> Int64 -> Int64 :: *)
                                   ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *))
                        GHC.Int.$fBitsInt64_$cxor
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                :: (Int64 -> Int64 -> Int64 :: *)
                                   ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *))
                        GHC.Int.$fBitsInt64_$ccomplement
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                :: (Int64 -> Int64 :: *) ~R# (CIntPtr -> CIntPtr :: *))
                        GHC.Int.$fBitsInt64_$cshift
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntPtr -> Int -> CIntPtr :: *))
                        GHC.Int.$fBitsInt64_$crotate
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntPtr -> Int -> CIntPtr :: *))
                        GHC.Int.$fBitsInt10
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                :: (Int64 :: *) ~R# (CIntPtr :: *))
                        GHC.Int.$fBitsInt64_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                :: (Int -> Int64 :: *) ~R# (Int -> CIntPtr :: *))
                        GHC.Int.$fBitsInt64_$csetBit
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntPtr -> Int -> CIntPtr :: *))
                        GHC.Int.$fBitsInt64_$cclearBit
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntPtr -> Int -> CIntPtr :: *))
                        GHC.Int.$fBitsInt64_$ccomplementBit
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntPtr -> Int -> CIntPtr :: *))
                        GHC.Int.$fBitsInt64_$ctestBit
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Int -> Bool>_R
                                :: (Int64 -> Int -> Bool :: *) ~R# (CIntPtr -> Int -> Bool :: *))
                        GHC.Int.$fBitsInt64_$cbitSizeMaybe
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Maybe Int>_R
                                :: (Int64 -> Maybe Int :: *) ~R# (CIntPtr -> Maybe Int :: *))
                        GHC.Int.$fBitsInt64_$cfiniteBitSize
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Int>_R
                                :: (Int64 -> Int :: *) ~R# (CIntPtr -> Int :: *))
                        GHC.Int.$fBitsInt64_$cisSigned
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Bool>_R
                                :: (Int64 -> Bool :: *) ~R# (CIntPtr -> Bool :: *))
                        GHC.Int.$fBitsInt64_$cshiftL
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntPtr -> Int -> CIntPtr :: *))
                        GHC.Int.$fBitsInt64_$cunsafeShiftL
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntPtr -> Int -> CIntPtr :: *))
                        GHC.Int.$fBitsInt64_$cshiftR
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntPtr -> Int -> CIntPtr :: *))
                        GHC.Int.$fBitsInt64_$cunsafeShiftR
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntPtr -> Int -> CIntPtr :: *))
                        GHC.Int.$fBitsInt64_$crotateL
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntPtr -> Int -> CIntPtr :: *))
                        GHC.Int.$fBitsInt64_$crotateR
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CIntPtr -> Int -> CIntPtr :: *))
                        GHC.Int.$fBitsInt64_$cpopCount
                        `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Int>_R
                                :: (Int64 -> Int :: *) ~R# (CIntPtr -> Int :: *))]
Foreign.C.Types.$fBitsCIntPtr
  = Data.Bits.C:Bits
      @ CIntPtr
      Foreign.C.Types.$fEqCIntPtr
      (GHC.Int.$fBitsInt64_$c.&.
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *)))
      (GHC.Int.$fBitsInt64_$c.|.
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *)))
      (GHC.Int.$fBitsInt64_$cxor
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CIntPtr -> CIntPtr -> CIntPtr :: *)))
      (GHC.Int.$fBitsInt64_$ccomplement
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int64 :: *) ~R# (CIntPtr -> CIntPtr :: *)))
      (GHC.Int.$fBitsInt64_$cshift
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntPtr -> Int -> CIntPtr :: *)))
      (GHC.Int.$fBitsInt64_$crotate
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntPtr -> Int -> CIntPtr :: *)))
      (GHC.Int.$fBitsInt10
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 :: *) ~R# (CIntPtr :: *)))
      (GHC.Int.$fBitsInt64_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int -> Int64 :: *) ~R# (Int -> CIntPtr :: *)))
      (GHC.Int.$fBitsInt64_$csetBit
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntPtr -> Int -> CIntPtr :: *)))
      (GHC.Int.$fBitsInt64_$cclearBit
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntPtr -> Int -> CIntPtr :: *)))
      (GHC.Int.$fBitsInt64_$ccomplementBit
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntPtr -> Int -> CIntPtr :: *)))
      (GHC.Int.$fBitsInt64_$ctestBit
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Int -> Bool>_R
               :: (Int64 -> Int -> Bool :: *) ~R# (CIntPtr -> Int -> Bool :: *)))
      (GHC.Int.$fBitsInt64_$cbitSizeMaybe
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Maybe Int>_R
               :: (Int64 -> Maybe Int :: *) ~R# (CIntPtr -> Maybe Int :: *)))
      (GHC.Int.$fBitsInt64_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CIntPtr -> Int :: *)))
      (GHC.Int.$fBitsInt64_$cisSigned
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Bool>_R
               :: (Int64 -> Bool :: *) ~R# (CIntPtr -> Bool :: *)))
      (GHC.Int.$fBitsInt64_$cshiftL
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntPtr -> Int -> CIntPtr :: *)))
      (GHC.Int.$fBitsInt64_$cunsafeShiftL
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntPtr -> Int -> CIntPtr :: *)))
      (GHC.Int.$fBitsInt64_$cshiftR
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntPtr -> Int -> CIntPtr :: *)))
      (GHC.Int.$fBitsInt64_$cunsafeShiftR
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntPtr -> Int -> CIntPtr :: *)))
      (GHC.Int.$fBitsInt64_$crotateL
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntPtr -> Int -> CIntPtr :: *)))
      (GHC.Int.$fBitsInt64_$crotateR
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CIntPtr -> Int -> CIntPtr :: *)))
      (GHC.Int.$fBitsInt64_$cpopCount
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CIntPtr -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.C.Types.$fFiniteBitsCIntPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits CIntPtr
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: CIntPtr
                              Foreign.C.Types.$fBitsCIntPtr
                              GHC.Int.$fBitsInt64_$cfiniteBitSize
                              `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Int>_R
                                      :: (Int64 -> Int :: *) ~R# (CIntPtr -> Int :: *))
                              GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros
                              `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Int>_R
                                      :: (Int64 -> Int :: *) ~R# (CIntPtr -> Int :: *))
                              GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros
                              `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Int>_R
                                      :: (Int64 -> Int :: *) ~R# (CIntPtr -> Int :: *))]
Foreign.C.Types.$fFiniteBitsCIntPtr
  = Data.Bits.C:FiniteBits
      @ CIntPtr
      Foreign.C.Types.$fBitsCIntPtr
      (GHC.Int.$fBitsInt64_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CIntPtr -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CIntPtr -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros
       `cast` (Sym (Foreign.C.Types.N:CIntPtr[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CIntPtr -> Int :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCSUSeconds [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CSUSeconds
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CSUSeconds
                       GHC.Int.$fShowInt64_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Int64 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CSUSeconds -> [Char] -> [Char] :: *))
                       GHC.Int.$fShowInt64_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0]) ->_R <[Char]>_R
                               :: (Int64 -> [Char] :: *) ~R# (CSUSeconds -> [Char] :: *))
                       GHC.Int.$fShowInt64_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CSUSeconds[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Int64] -> [Char] -> [Char] :: *)
                                  ~R# ([CSUSeconds] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCSUSeconds
  = GHC.Show.C:Show
      @ CSUSeconds
      (GHC.Int.$fShowInt64_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Int64 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CSUSeconds -> [Char] -> [Char] :: *)))
      (GHC.Int.$fShowInt64_$cshow
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0]) ->_R <[Char]>_R
               :: (Int64 -> [Char] :: *) ~R# (CSUSeconds -> [Char] :: *)))
      (GHC.Int.$fShowInt64_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CSUSeconds[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Int64] -> [Char] -> [Char] :: *)
                  ~R# ([CSUSeconds] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCSUSeconds [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CSUSeconds
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CSUSeconds
                       GHC.Int.$fReadInt64_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,)
                                         (Sym (Foreign.C.Types.N:CSUSeconds[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Int64, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CSUSeconds, [Char])] :: *))
                       GHC.Int.$fReadInt64_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CSUSeconds[0])])_R
                                         <[Char]>_R)_R])_R
                               :: ([Char] -> [([Int64], [Char])] :: *)
                                  ~R# ([Char] -> [([CSUSeconds], [Char])] :: *))
                       GHC.Int.$fReadInt10
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Int64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     (Foreign.C.Types.N:CSUSeconds[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Int64 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CSUSeconds :: *))
                       GHC.Int.$fReadInt7
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Int64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       ([Foreign.C.Types.N:CSUSeconds[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Int64] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CSUSeconds] :: *))]
Foreign.C.Types.$fReadCSUSeconds
  = GHC.Read.C:Read
      @ CSUSeconds
      (GHC.Int.$fReadInt64_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,)
                         (Sym (Foreign.C.Types.N:CSUSeconds[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Int64, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CSUSeconds, [Char])] :: *)))
      (GHC.Int.$fReadInt64_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CSUSeconds[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Int64], [Char])] :: *)
                  ~R# ([Char] -> [([CSUSeconds], [Char])] :: *)))
      (GHC.Int.$fReadInt10
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Int64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                     (Foreign.C.Types.N:CSUSeconds[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Int64 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CSUSeconds :: *)))
      (GHC.Int.$fReadInt7
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Int64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       ([Foreign.C.Types.N:CSUSeconds[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Int64] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CSUSeconds] :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCSUSeconds [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CSUSeconds
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CSUSeconds
                                   Foreign.Storable.$fStorableInt64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0]) ->_R <Int>_R
                                           :: (Int64 -> Int :: *) ~R# (CSUSeconds -> Int :: *))
                                   Foreign.Storable.$fStorableInt64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0]) ->_R <Int>_R
                                           :: (Int64 -> Int :: *) ~R# (CSUSeconds -> Int :: *))
                                   GHC.Storable.readInt64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CSUSeconds))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CSUSeconds[0]))
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CSUSeconds
                                                   -> Int -> IO CSUSeconds :: *))
                                   GHC.Storable.writeInt64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CSUSeconds))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CSUSeconds
                                                   -> Int -> CSUSeconds -> IO () :: *))
                                   Foreign.Storable.$fStorableInt19
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CSUSeconds[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> IO CSUSeconds :: *))
                                   Foreign.Storable.$fStorableInt18
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b
                                                   -> Int -> CSUSeconds -> IO () :: *))
                                   Foreign.Storable.$fStorableInt17
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CSUSeconds))_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CSUSeconds[0]))
                                           :: (GHC.Ptr.Ptr Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CSUSeconds -> IO CSUSeconds :: *))
                                   Foreign.Storable.$fStorableInt15
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CSUSeconds))_R
                                           ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CSUSeconds
                                                   -> CSUSeconds -> IO () :: *))]
Foreign.C.Types.$fStorableCSUSeconds
  = Foreign.Storable.C:Storable
      @ CSUSeconds
      (Foreign.Storable.$fStorableInt64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CSUSeconds -> Int :: *)))
      (Foreign.Storable.$fStorableInt64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CSUSeconds -> Int :: *)))
      (GHC.Storable.readInt64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CSUSeconds))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CSUSeconds[0]))
               :: (GHC.Ptr.Ptr Int64
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CSUSeconds -> Int -> IO CSUSeconds :: *)))
      (GHC.Storable.writeInt64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CSUSeconds))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int64
                   -> Int
                   -> Int64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CSUSeconds -> Int -> CSUSeconds -> IO () :: *)))
      (Foreign.Storable.$fStorableInt19
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CSUSeconds[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CSUSeconds :: *)))
      (Foreign.Storable.$fStorableInt18
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Int64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CSUSeconds -> IO () :: *)))
      (Foreign.Storable.$fStorableInt17
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CSUSeconds))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CSUSeconds[0]))
               :: (GHC.Ptr.Ptr Int64
                   -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CSUSeconds -> IO CSUSeconds :: *)))
      (Foreign.Storable.$fStorableInt15
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CSUSeconds))_R
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int64
                   -> Int64 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CSUSeconds -> CSUSeconds -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCSUSeconds [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CSUSeconds
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CSUSeconds
                       GHC.Int.$fEnumInt64_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                               :: (Int64 -> Int64 :: *) ~R# (CSUSeconds -> CSUSeconds :: *))
                       GHC.Int.$fEnumInt64_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                               :: (Int64 -> Int64 :: *) ~R# (CSUSeconds -> CSUSeconds :: *))
                       GHC.Int.$fEnumInt64_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                               :: (Int -> Int64 :: *) ~R# (Int -> CSUSeconds :: *))
                       GHC.Int.$fEnumInt64_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0]) ->_R <Int>_R
                               :: (Int64 -> Int :: *) ~R# (CSUSeconds -> Int :: *))
                       GHC.Int.$fEnumInt64_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                               ->_R ([Sym (Foreign.C.Types.N:CSUSeconds[0])])_R
                               :: (Int64 -> [Int64] :: *) ~R# (CSUSeconds -> [CSUSeconds] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                               ->_R ([Sym (Foreign.C.Types.N:CSUSeconds[0])])_R
                               :: (Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CSUSeconds -> CSUSeconds -> [CSUSeconds] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                               ->_R ([Sym (Foreign.C.Types.N:CSUSeconds[0])])_R
                               :: (Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CSUSeconds -> CSUSeconds -> [CSUSeconds] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                               ->_R ([Sym (Foreign.C.Types.N:CSUSeconds[0])])_R
                               :: (Int64 -> Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CSUSeconds
                                       -> CSUSeconds -> CSUSeconds -> [CSUSeconds] :: *))]
Foreign.C.Types.$fEnumCSUSeconds
  = GHC.Enum.C:Enum
      @ CSUSeconds
      (GHC.Int.$fEnumInt64_$csucc
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               :: (Int64 -> Int64 :: *) ~R# (CSUSeconds -> CSUSeconds :: *)))
      (GHC.Int.$fEnumInt64_$cpred
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               :: (Int64 -> Int64 :: *) ~R# (CSUSeconds -> CSUSeconds :: *)))
      (GHC.Int.$fEnumInt64_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               :: (Int -> Int64 :: *) ~R# (Int -> CSUSeconds :: *)))
      (GHC.Int.$fEnumInt64_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CSUSeconds -> Int :: *)))
      (GHC.Int.$fEnumInt64_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R ([Sym (Foreign.C.Types.N:CSUSeconds[0])])_R
               :: (Int64 -> [Int64] :: *) ~R# (CSUSeconds -> [CSUSeconds] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R ([Sym (Foreign.C.Types.N:CSUSeconds[0])])_R
               :: (Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CSUSeconds -> CSUSeconds -> [CSUSeconds] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R ([Sym (Foreign.C.Types.N:CSUSeconds[0])])_R
               :: (Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CSUSeconds -> CSUSeconds -> [CSUSeconds] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R ([Sym (Foreign.C.Types.N:CSUSeconds[0])])_R
               :: (Int64 -> Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CSUSeconds -> CSUSeconds -> CSUSeconds -> [CSUSeconds] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCSUSeconds [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CSUSeconds
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CSUSeconds
                     GHC.Int.$fNumInt64_$c+
                     `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                             ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                             ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CSUSeconds -> CSUSeconds -> CSUSeconds :: *))
                     GHC.Int.$fNumInt64_$c-
                     `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                             ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                             ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CSUSeconds -> CSUSeconds -> CSUSeconds :: *))
                     GHC.Int.$fNumInt64_$c*
                     `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                             ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                             ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CSUSeconds -> CSUSeconds -> CSUSeconds :: *))
                     GHC.Int.$fNumInt64_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                             ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                             :: (Int64 -> Int64 :: *) ~R# (CSUSeconds -> CSUSeconds :: *))
                     GHC.Int.$fNumInt64_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                             ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                             :: (Int64 -> Int64 :: *) ~R# (CSUSeconds -> CSUSeconds :: *))
                     GHC.Int.$fNumInt64_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                             ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                             :: (Int64 -> Int64 :: *) ~R# (CSUSeconds -> CSUSeconds :: *))
                     GHC.Int.$fNumInt64_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                             :: (Integer -> Int64 :: *) ~R# (Integer -> CSUSeconds :: *))]
Foreign.C.Types.$fNumCSUSeconds
  = GHC.Num.C:Num
      @ CSUSeconds
      (GHC.Int.$fNumInt64_$c+
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CSUSeconds -> CSUSeconds -> CSUSeconds :: *)))
      (GHC.Int.$fNumInt64_$c-
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CSUSeconds -> CSUSeconds -> CSUSeconds :: *)))
      (GHC.Int.$fNumInt64_$c*
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CSUSeconds -> CSUSeconds -> CSUSeconds :: *)))
      (GHC.Int.$fNumInt64_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               :: (Int64 -> Int64 :: *) ~R# (CSUSeconds -> CSUSeconds :: *)))
      (GHC.Int.$fNumInt64_$cabs
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               :: (Int64 -> Int64 :: *) ~R# (CSUSeconds -> CSUSeconds :: *)))
      (GHC.Int.$fNumInt64_$csignum
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               :: (Int64 -> Int64 :: *) ~R# (CSUSeconds -> CSUSeconds :: *)))
      (GHC.Int.$fNumInt64_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               :: (Integer -> Int64 :: *) ~R# (Integer -> CSUSeconds :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCSUSeconds [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CSUSeconds
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CSUSeconds
                        GHC.Int.eqInt64
                        `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                                ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                                ->_R <Bool>_R
                                :: (Int64 -> Int64 -> Bool :: *)
                                   ~R# (CSUSeconds -> CSUSeconds -> Bool :: *))
                        GHC.Int.neInt64
                        `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                                ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                                ->_R <Bool>_R
                                :: (Int64 -> Int64 -> Bool :: *)
                                   ~R# (CSUSeconds -> CSUSeconds -> Bool :: *))]
Foreign.C.Types.$fEqCSUSeconds
  = GHC.Classes.C:Eq
      @ CSUSeconds
      (GHC.Int.eqInt64
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CSUSeconds -> CSUSeconds -> Bool :: *)))
      (GHC.Int.neInt64
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CSUSeconds -> CSUSeconds -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCSUSeconds [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CSUSeconds
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CSUSeconds
                         Foreign.C.Types.$fEqCSUSeconds
                         GHC.Int.$fOrdInt64_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                                 ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                                 ->_R <Ordering>_R
                                 :: (Int64 -> Int64 -> Ordering :: *)
                                    ~R# (CSUSeconds -> CSUSeconds -> Ordering :: *))
                         GHC.Int.ltInt64
                         `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                                 ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CSUSeconds -> CSUSeconds -> Bool :: *))
                         GHC.Int.leInt64
                         `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                                 ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CSUSeconds -> CSUSeconds -> Bool :: *))
                         GHC.Int.gtInt64
                         `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                                 ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CSUSeconds -> CSUSeconds -> Bool :: *))
                         GHC.Int.geInt64
                         `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                                 ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CSUSeconds -> CSUSeconds -> Bool :: *))
                         GHC.Int.$fOrdInt64_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                                 ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                                 ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                                 :: (Int64 -> Int64 -> Int64 :: *)
                                    ~R# (CSUSeconds -> CSUSeconds -> CSUSeconds :: *))
                         GHC.Int.$fOrdInt64_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                                 ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                                 ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
                                 :: (Int64 -> Int64 -> Int64 :: *)
                                    ~R# (CSUSeconds -> CSUSeconds -> CSUSeconds :: *))]
Foreign.C.Types.$fOrdCSUSeconds
  = GHC.Classes.C:Ord
      @ CSUSeconds
      Foreign.C.Types.$fEqCSUSeconds
      (GHC.Int.$fOrdInt64_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R <Ordering>_R
               :: (Int64 -> Int64 -> Ordering :: *)
                  ~R# (CSUSeconds -> CSUSeconds -> Ordering :: *)))
      (GHC.Int.ltInt64
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CSUSeconds -> CSUSeconds -> Bool :: *)))
      (GHC.Int.leInt64
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CSUSeconds -> CSUSeconds -> Bool :: *)))
      (GHC.Int.gtInt64
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CSUSeconds -> CSUSeconds -> Bool :: *)))
      (GHC.Int.geInt64
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CSUSeconds -> CSUSeconds -> Bool :: *)))
      (GHC.Int.$fOrdInt64_$cmax
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CSUSeconds -> CSUSeconds -> CSUSeconds :: *)))
      (GHC.Int.$fOrdInt64_$cmin
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CSUSeconds[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CSUSeconds -> CSUSeconds -> CSUSeconds :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCSUSeconds [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CSUSeconds
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CSUSeconds
                       Foreign.C.Types.$fNumCSUSeconds
                       Foreign.C.Types.$fOrdCSUSeconds
                       GHC.Int.$fRealInt64_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
                               ->_R <Ratio Integer>_R
                               :: (Int64 -> Ratio Integer :: *)
                                  ~R# (CSUSeconds -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCSUSeconds
  = GHC.Real.C:Real
      @ CSUSeconds
      Foreign.C.Types.$fNumCSUSeconds
      Foreign.C.Types.$fOrdCSUSeconds
      (GHC.Int.$fRealInt64_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CSUSeconds[0])
               ->_R <Ratio Integer>_R
               :: (Int64 -> Ratio Integer :: *)
                  ~R# (CSUSeconds -> Ratio Integer :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCUSeconds [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CUSeconds
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CUSeconds
                       GHC.Word.$fShowWord32_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Word32 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CUSeconds -> [Char] -> [Char] :: *))
                       GHC.Word.$fShowWord32_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0]) ->_R <[Char]>_R
                               :: (Word32 -> [Char] :: *) ~R# (CUSeconds -> [Char] :: *))
                       GHC.Word.$fShowWord32_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CUSeconds[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Word32] -> [Char] -> [Char] :: *)
                                  ~R# ([CUSeconds] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCUSeconds
  = GHC.Show.C:Show
      @ CUSeconds
      (GHC.Word.$fShowWord32_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Word32 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CUSeconds -> [Char] -> [Char] :: *)))
      (GHC.Word.$fShowWord32_$cshow
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0]) ->_R <[Char]>_R
               :: (Word32 -> [Char] :: *) ~R# (CUSeconds -> [Char] :: *)))
      (GHC.Word.$fShowWord32_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CUSeconds[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Word32] -> [Char] -> [Char] :: *)
                  ~R# ([CUSeconds] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCUSeconds [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CUSeconds
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CUSeconds
                       GHC.Read.$fReadWord32_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,)
                                         (Sym (Foreign.C.Types.N:CUSeconds[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Word32, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CUSeconds, [Char])] :: *))
                       GHC.Read.$fReadWord32_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CUSeconds[0])])_R
                                         <[Char]>_R)_R])_R
                               :: ([Char] -> [([Word32], [Char])] :: *)
                                  ~R# ([Char] -> [([CUSeconds], [Char])] :: *))
                       GHC.Read.$fReadWord10
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Word32>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      (Foreign.C.Types.N:CUSeconds[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Word32 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CUSeconds :: *))
                       GHC.Read.$fReadWord7
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Word32]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                        ([Foreign.C.Types.N:CUSeconds[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Word32] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CUSeconds] :: *))]
Foreign.C.Types.$fReadCUSeconds
  = GHC.Read.C:Read
      @ CUSeconds
      (GHC.Read.$fReadWord32_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,)
                         (Sym (Foreign.C.Types.N:CUSeconds[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Word32, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CUSeconds, [Char])] :: *)))
      (GHC.Read.$fReadWord32_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CUSeconds[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Word32], [Char])] :: *)
                  ~R# ([Char] -> [([CUSeconds], [Char])] :: *)))
      (GHC.Read.$fReadWord10
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Word32>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                      (Foreign.C.Types.N:CUSeconds[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Word32 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CUSeconds :: *)))
      (GHC.Read.$fReadWord7
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Word32]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        ([Foreign.C.Types.N:CUSeconds[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Word32] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CUSeconds] :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCUSeconds [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CUSeconds
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CUSeconds
                                   Foreign.Storable.$fStorableWord32_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CUSeconds[0]) ->_R <Int>_R
                                           :: (Word32 -> Int :: *) ~R# (CUSeconds -> Int :: *))
                                   Foreign.Storable.$fStorableWord32_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CUSeconds[0]) ->_R <Int>_R
                                           :: (Word32 -> Int :: *) ~R# (CUSeconds -> Int :: *))
                                   GHC.Storable.readWord32OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word32, CUSeconds))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CUSeconds[0]))
                                           :: (GHC.Ptr.Ptr Word32
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word32 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUSeconds
                                                   -> Int -> IO CUSeconds :: *))
                                   GHC.Storable.writeWord32OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word32, CUSeconds))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Word32
                                               -> Int
                                               -> Word32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUSeconds
                                                   -> Int -> CUSeconds -> IO () :: *))
                                   Foreign.Storable.$fStorableWord13
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CUSeconds[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word32 #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> IO CUSeconds :: *))
                                   Foreign.Storable.$fStorableWord12
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Word32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CUSeconds -> IO () :: *))
                                   Foreign.Storable.$fStorableWord11
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word32, CUSeconds))_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CUSeconds[0]))
                                           :: (GHC.Ptr.Ptr Word32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word32 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUSeconds -> IO CUSeconds :: *))
                                   Foreign.Storable.$fStorableWord10
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word32, CUSeconds))_R
                                           ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Word32
                                               -> Word32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUSeconds
                                                   -> CUSeconds -> IO () :: *))]
Foreign.C.Types.$fStorableCUSeconds
  = Foreign.Storable.C:Storable
      @ CUSeconds
      (Foreign.Storable.$fStorableWord32_$calignment
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0]) ->_R <Int>_R
               :: (Word32 -> Int :: *) ~R# (CUSeconds -> Int :: *)))
      (Foreign.Storable.$fStorableWord32_$calignment
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0]) ->_R <Int>_R
               :: (Word32 -> Int :: *) ~R# (CUSeconds -> Int :: *)))
      (GHC.Storable.readWord32OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word32, CUSeconds))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUSeconds[0]))
               :: (GHC.Ptr.Ptr Word32
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word32 #) :: *)
                  ~R# (GHC.Ptr.Ptr CUSeconds -> Int -> IO CUSeconds :: *)))
      (GHC.Storable.writeWord32OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word32, CUSeconds))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Word32
                   -> Int
                   -> Word32
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CUSeconds -> Int -> CUSeconds -> IO () :: *)))
      (Foreign.Storable.$fStorableWord13
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUSeconds[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word32 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CUSeconds :: *)))
      (Foreign.Storable.$fStorableWord12
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Word32
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CUSeconds -> IO () :: *)))
      (Foreign.Storable.$fStorableWord11
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word32, CUSeconds))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUSeconds[0]))
               :: (GHC.Ptr.Ptr Word32
                   -> State# RealWorld -> (# State# RealWorld, Word32 #) :: *)
                  ~R# (GHC.Ptr.Ptr CUSeconds -> IO CUSeconds :: *)))
      (Foreign.Storable.$fStorableWord10
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word32, CUSeconds))_R
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Word32
                   -> Word32 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CUSeconds -> CUSeconds -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCUSeconds [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CUSeconds
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CUSeconds
                       GHC.Word.$fEnumWord32_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                               :: (Word32 -> Word32 :: *) ~R# (CUSeconds -> CUSeconds :: *))
                       GHC.Word.$fEnumWord32_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                               :: (Word32 -> Word32 :: *) ~R# (CUSeconds -> CUSeconds :: *))
                       GHC.Word.$fEnumWord32_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                               :: (Int -> Word32 :: *) ~R# (Int -> CUSeconds :: *))
                       GHC.Word.$fEnumWord32_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0]) ->_R <Int>_R
                               :: (Word32 -> Int :: *) ~R# (CUSeconds -> Int :: *))
                       GHC.Word.$fEnumWord32_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUSeconds[0])])_R
                               :: (Word32 -> [Word32] :: *) ~R# (CUSeconds -> [CUSeconds] :: *))
                       GHC.Word.$fEnumWord32_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUSeconds[0])])_R
                               :: (Word32 -> Word32 -> [Word32] :: *)
                                  ~R# (CUSeconds -> CUSeconds -> [CUSeconds] :: *))
                       GHC.Word.$fEnumWord32_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUSeconds[0])])_R
                               :: (Word32 -> Word32 -> [Word32] :: *)
                                  ~R# (CUSeconds -> CUSeconds -> [CUSeconds] :: *))
                       GHC.Word.$fEnumWord32_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUSeconds[0])])_R
                               :: (Word32 -> Word32 -> Word32 -> [Word32] :: *)
                                  ~R# (CUSeconds -> CUSeconds -> CUSeconds -> [CUSeconds] :: *))]
Foreign.C.Types.$fEnumCUSeconds
  = GHC.Enum.C:Enum
      @ CUSeconds
      (GHC.Word.$fEnumWord32_$csucc
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               :: (Word32 -> Word32 :: *) ~R# (CUSeconds -> CUSeconds :: *)))
      (GHC.Word.$fEnumWord32_$cpred
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               :: (Word32 -> Word32 :: *) ~R# (CUSeconds -> CUSeconds :: *)))
      (GHC.Word.$fEnumWord32_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               :: (Int -> Word32 :: *) ~R# (Int -> CUSeconds :: *)))
      (GHC.Word.$fEnumWord32_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0]) ->_R <Int>_R
               :: (Word32 -> Int :: *) ~R# (CUSeconds -> Int :: *)))
      (GHC.Word.$fEnumWord32_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R ([Sym (Foreign.C.Types.N:CUSeconds[0])])_R
               :: (Word32 -> [Word32] :: *) ~R# (CUSeconds -> [CUSeconds] :: *)))
      (GHC.Word.$fEnumWord32_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R ([Sym (Foreign.C.Types.N:CUSeconds[0])])_R
               :: (Word32 -> Word32 -> [Word32] :: *)
                  ~R# (CUSeconds -> CUSeconds -> [CUSeconds] :: *)))
      (GHC.Word.$fEnumWord32_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R ([Sym (Foreign.C.Types.N:CUSeconds[0])])_R
               :: (Word32 -> Word32 -> [Word32] :: *)
                  ~R# (CUSeconds -> CUSeconds -> [CUSeconds] :: *)))
      (GHC.Word.$fEnumWord32_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R ([Sym (Foreign.C.Types.N:CUSeconds[0])])_R
               :: (Word32 -> Word32 -> Word32 -> [Word32] :: *)
                  ~R# (CUSeconds -> CUSeconds -> CUSeconds -> [CUSeconds] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCUSeconds [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CUSeconds
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CUSeconds
                     GHC.Word.$fNumWord32_$c+
                     `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                             ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                             ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                             :: (Word32 -> Word32 -> Word32 :: *)
                                ~R# (CUSeconds -> CUSeconds -> CUSeconds :: *))
                     GHC.Word.$fNumWord32_$c-
                     `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                             ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                             ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                             :: (Word32 -> Word32 -> Word32 :: *)
                                ~R# (CUSeconds -> CUSeconds -> CUSeconds :: *))
                     GHC.Word.$fNumWord32_$c*
                     `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                             ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                             ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                             :: (Word32 -> Word32 -> Word32 :: *)
                                ~R# (CUSeconds -> CUSeconds -> CUSeconds :: *))
                     GHC.Word.$fNumWord32_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                             ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                             :: (Word32 -> Word32 :: *) ~R# (CUSeconds -> CUSeconds :: *))
                     GHC.Word.$fNumWord32_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                             ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                             :: (Word32 -> Word32 :: *) ~R# (CUSeconds -> CUSeconds :: *))
                     GHC.Word.$fNumWord32_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                             ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                             :: (Word32 -> Word32 :: *) ~R# (CUSeconds -> CUSeconds :: *))
                     GHC.Word.$fNumWord32_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                             :: (Integer -> Word32 :: *) ~R# (Integer -> CUSeconds :: *))]
Foreign.C.Types.$fNumCUSeconds
  = GHC.Num.C:Num
      @ CUSeconds
      (GHC.Word.$fNumWord32_$c+
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               :: (Word32 -> Word32 -> Word32 :: *)
                  ~R# (CUSeconds -> CUSeconds -> CUSeconds :: *)))
      (GHC.Word.$fNumWord32_$c-
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               :: (Word32 -> Word32 -> Word32 :: *)
                  ~R# (CUSeconds -> CUSeconds -> CUSeconds :: *)))
      (GHC.Word.$fNumWord32_$c*
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               :: (Word32 -> Word32 -> Word32 :: *)
                  ~R# (CUSeconds -> CUSeconds -> CUSeconds :: *)))
      (GHC.Word.$fNumWord32_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               :: (Word32 -> Word32 :: *) ~R# (CUSeconds -> CUSeconds :: *)))
      (GHC.Word.$fNumWord32_$cabs
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               :: (Word32 -> Word32 :: *) ~R# (CUSeconds -> CUSeconds :: *)))
      (GHC.Word.$fNumWord32_$csignum
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               :: (Word32 -> Word32 :: *) ~R# (CUSeconds -> CUSeconds :: *)))
      (GHC.Word.$fNumWord32_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               :: (Integer -> Word32 :: *) ~R# (Integer -> CUSeconds :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCUSeconds [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CUSeconds
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CUSeconds
                        GHC.Word.eqWord32
                        `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                                ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                                ->_R <Bool>_R
                                :: (Word32 -> Word32 -> Bool :: *)
                                   ~R# (CUSeconds -> CUSeconds -> Bool :: *))
                        GHC.Word.neWord32
                        `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                                ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                                ->_R <Bool>_R
                                :: (Word32 -> Word32 -> Bool :: *)
                                   ~R# (CUSeconds -> CUSeconds -> Bool :: *))]
Foreign.C.Types.$fEqCUSeconds
  = GHC.Classes.C:Eq
      @ CUSeconds
      (GHC.Word.eqWord32
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R <Bool>_R
               :: (Word32 -> Word32 -> Bool :: *)
                  ~R# (CUSeconds -> CUSeconds -> Bool :: *)))
      (GHC.Word.neWord32
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R <Bool>_R
               :: (Word32 -> Word32 -> Bool :: *)
                  ~R# (CUSeconds -> CUSeconds -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCUSeconds [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CUSeconds
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CUSeconds
                         Foreign.C.Types.$fEqCUSeconds
                         GHC.Word.$fOrdWord32_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                                 ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                                 ->_R <Ordering>_R
                                 :: (Word32 -> Word32 -> Ordering :: *)
                                    ~R# (CUSeconds -> CUSeconds -> Ordering :: *))
                         GHC.Word.ltWord32
                         `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                                 ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                                 ->_R <Bool>_R
                                 :: (Word32 -> Word32 -> Bool :: *)
                                    ~R# (CUSeconds -> CUSeconds -> Bool :: *))
                         GHC.Word.leWord32
                         `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                                 ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                                 ->_R <Bool>_R
                                 :: (Word32 -> Word32 -> Bool :: *)
                                    ~R# (CUSeconds -> CUSeconds -> Bool :: *))
                         GHC.Word.gtWord32
                         `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                                 ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                                 ->_R <Bool>_R
                                 :: (Word32 -> Word32 -> Bool :: *)
                                    ~R# (CUSeconds -> CUSeconds -> Bool :: *))
                         GHC.Word.geWord32
                         `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                                 ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                                 ->_R <Bool>_R
                                 :: (Word32 -> Word32 -> Bool :: *)
                                    ~R# (CUSeconds -> CUSeconds -> Bool :: *))
                         GHC.Word.$fOrdWord32_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                                 ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                                 ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                                 :: (Word32 -> Word32 -> Word32 :: *)
                                    ~R# (CUSeconds -> CUSeconds -> CUSeconds :: *))
                         GHC.Word.$fOrdWord32_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
                                 ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                                 ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
                                 :: (Word32 -> Word32 -> Word32 :: *)
                                    ~R# (CUSeconds -> CUSeconds -> CUSeconds :: *))]
Foreign.C.Types.$fOrdCUSeconds
  = GHC.Classes.C:Ord
      @ CUSeconds
      Foreign.C.Types.$fEqCUSeconds
      (GHC.Word.$fOrdWord32_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R <Ordering>_R
               :: (Word32 -> Word32 -> Ordering :: *)
                  ~R# (CUSeconds -> CUSeconds -> Ordering :: *)))
      (GHC.Word.ltWord32
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R <Bool>_R
               :: (Word32 -> Word32 -> Bool :: *)
                  ~R# (CUSeconds -> CUSeconds -> Bool :: *)))
      (GHC.Word.leWord32
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R <Bool>_R
               :: (Word32 -> Word32 -> Bool :: *)
                  ~R# (CUSeconds -> CUSeconds -> Bool :: *)))
      (GHC.Word.gtWord32
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R <Bool>_R
               :: (Word32 -> Word32 -> Bool :: *)
                  ~R# (CUSeconds -> CUSeconds -> Bool :: *)))
      (GHC.Word.geWord32
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R <Bool>_R
               :: (Word32 -> Word32 -> Bool :: *)
                  ~R# (CUSeconds -> CUSeconds -> Bool :: *)))
      (GHC.Word.$fOrdWord32_$cmax
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               :: (Word32 -> Word32 -> Word32 :: *)
                  ~R# (CUSeconds -> CUSeconds -> CUSeconds :: *)))
      (GHC.Word.$fOrdWord32_$cmin
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               ->_R Sym (Foreign.C.Types.N:CUSeconds[0])
               :: (Word32 -> Word32 -> Word32 :: *)
                  ~R# (CUSeconds -> CUSeconds -> CUSeconds :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCUSeconds [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CUSeconds
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CUSeconds
                       Foreign.C.Types.$fNumCUSeconds
                       Foreign.C.Types.$fOrdCUSeconds
                       GHC.Word.$fRealWord32_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0]) ->_R <Ratio Integer>_R
                               :: (Word32 -> Ratio Integer :: *)
                                  ~R# (CUSeconds -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCUSeconds
  = GHC.Real.C:Real
      @ CUSeconds
      Foreign.C.Types.$fNumCUSeconds
      Foreign.C.Types.$fOrdCUSeconds
      (GHC.Word.$fRealWord32_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CUSeconds[0]) ->_R <Ratio Integer>_R
               :: (Word32 -> Ratio Integer :: *)
                  ~R# (CUSeconds -> Ratio Integer :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCTime [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CTime
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CTime
                       GHC.Int.$fShowInt64_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CTime[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Int64 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CTime -> [Char] -> [Char] :: *))
                       GHC.Int.$fShowInt64_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CTime[0]) ->_R <[Char]>_R
                               :: (Int64 -> [Char] :: *) ~R# (CTime -> [Char] :: *))
                       GHC.Int.$fShowInt64_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CTime[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Int64] -> [Char] -> [Char] :: *)
                                  ~R# ([CTime] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCTime
  = GHC.Show.C:Show
      @ CTime
      (GHC.Int.$fShowInt64_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Int64 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CTime -> [Char] -> [Char] :: *)))
      (GHC.Int.$fShowInt64_$cshow
       `cast` (Sym (Foreign.C.Types.N:CTime[0]) ->_R <[Char]>_R
               :: (Int64 -> [Char] :: *) ~R# (CTime -> [Char] :: *)))
      (GHC.Int.$fShowInt64_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CTime[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Int64] -> [Char] -> [Char] :: *)
                  ~R# ([CTime] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCTime [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CTime
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CTime
                       GHC.Int.$fReadInt64_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CTime[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Int64, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CTime, [Char])] :: *))
                       GHC.Int.$fReadInt64_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CTime[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Int64], [Char])] :: *)
                                  ~R# ([Char] -> [([CTime], [Char])] :: *))
                       GHC.Int.$fReadInt10
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Int64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     (Foreign.C.Types.N:CTime[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Int64 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CTime :: *))
                       GHC.Int.$fReadInt7
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Int64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       ([Foreign.C.Types.N:CTime[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Int64] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CTime] :: *))]
Foreign.C.Types.$fReadCTime
  = GHC.Read.C:Read
      @ CTime
      (GHC.Int.$fReadInt64_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CTime[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Int64, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CTime, [Char])] :: *)))
      (GHC.Int.$fReadInt64_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CTime[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Int64], [Char])] :: *)
                  ~R# ([Char] -> [([CTime], [Char])] :: *)))
      (GHC.Int.$fReadInt10
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Int64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                     (Foreign.C.Types.N:CTime[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Int64 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CTime :: *)))
      (GHC.Int.$fReadInt7
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Int64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       ([Foreign.C.Types.N:CTime[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Int64] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CTime] :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCTime [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CTime
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CTime
                                   Foreign.Storable.$fStorableInt64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CTime[0]) ->_R <Int>_R
                                           :: (Int64 -> Int :: *) ~R# (CTime -> Int :: *))
                                   Foreign.Storable.$fStorableInt64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CTime[0]) ->_R <Int>_R
                                           :: (Int64 -> Int :: *) ~R# (CTime -> Int :: *))
                                   GHC.Storable.readInt64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CTime))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CTime[0]))
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CTime -> Int -> IO CTime :: *))
                                   GHC.Storable.writeInt64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CTime))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CTime[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CTime -> Int -> CTime -> IO () :: *))
                                   Foreign.Storable.$fStorableInt19
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CTime[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CTime :: *))
                                   Foreign.Storable.$fStorableInt18
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CTime[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CTime -> IO () :: *))
                                   Foreign.Storable.$fStorableInt17
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CTime))_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CTime[0]))
                                           :: (GHC.Ptr.Ptr Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CTime -> IO CTime :: *))
                                   Foreign.Storable.$fStorableInt15
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CTime))_R
                                           ->_R Sym (Foreign.C.Types.N:CTime[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CTime -> CTime -> IO () :: *))]
Foreign.C.Types.$fStorableCTime
  = Foreign.Storable.C:Storable
      @ CTime
      (Foreign.Storable.$fStorableInt64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CTime[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CTime -> Int :: *)))
      (Foreign.Storable.$fStorableInt64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CTime[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CTime -> Int :: *)))
      (GHC.Storable.readInt64OffPtr1
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Int64, CTime))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CTime[0]))
               :: (GHC.Ptr.Ptr Int64
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CTime -> Int -> IO CTime :: *)))
      (GHC.Storable.writeInt64OffPtr1
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Int64, CTime))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int64
                   -> Int
                   -> Int64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CTime -> Int -> CTime -> IO () :: *)))
      (Foreign.Storable.$fStorableInt19
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CTime[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CTime :: *)))
      (Foreign.Storable.$fStorableInt18
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Int64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CTime -> IO () :: *)))
      (Foreign.Storable.$fStorableInt17
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Int64, CTime))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CTime[0]))
               :: (GHC.Ptr.Ptr Int64
                   -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CTime -> IO CTime :: *)))
      (Foreign.Storable.$fStorableInt15
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Int64, CTime))_R
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int64
                   -> Int64 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CTime -> CTime -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCTime [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CTime
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CTime
                       GHC.Int.$fEnumInt64_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CTime[0])
                               ->_R Sym (Foreign.C.Types.N:CTime[0])
                               :: (Int64 -> Int64 :: *) ~R# (CTime -> CTime :: *))
                       GHC.Int.$fEnumInt64_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CTime[0])
                               ->_R Sym (Foreign.C.Types.N:CTime[0])
                               :: (Int64 -> Int64 :: *) ~R# (CTime -> CTime :: *))
                       GHC.Int.$fEnumInt64_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CTime[0])
                               :: (Int -> Int64 :: *) ~R# (Int -> CTime :: *))
                       GHC.Int.$fEnumInt64_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CTime[0]) ->_R <Int>_R
                               :: (Int64 -> Int :: *) ~R# (CTime -> Int :: *))
                       GHC.Int.$fEnumInt64_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CTime[0])
                               ->_R ([Sym (Foreign.C.Types.N:CTime[0])])_R
                               :: (Int64 -> [Int64] :: *) ~R# (CTime -> [CTime] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CTime[0])
                               ->_R Sym (Foreign.C.Types.N:CTime[0])
                               ->_R ([Sym (Foreign.C.Types.N:CTime[0])])_R
                               :: (Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CTime -> CTime -> [CTime] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CTime[0])
                               ->_R Sym (Foreign.C.Types.N:CTime[0])
                               ->_R ([Sym (Foreign.C.Types.N:CTime[0])])_R
                               :: (Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CTime -> CTime -> [CTime] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CTime[0])
                               ->_R Sym (Foreign.C.Types.N:CTime[0])
                               ->_R Sym (Foreign.C.Types.N:CTime[0])
                               ->_R ([Sym (Foreign.C.Types.N:CTime[0])])_R
                               :: (Int64 -> Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CTime -> CTime -> CTime -> [CTime] :: *))]
Foreign.C.Types.$fEnumCTime
  = GHC.Enum.C:Enum
      @ CTime
      (GHC.Int.$fEnumInt64_$csucc
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               :: (Int64 -> Int64 :: *) ~R# (CTime -> CTime :: *)))
      (GHC.Int.$fEnumInt64_$cpred
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               :: (Int64 -> Int64 :: *) ~R# (CTime -> CTime :: *)))
      (GHC.Int.$fEnumInt64_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CTime[0])
               :: (Int -> Int64 :: *) ~R# (Int -> CTime :: *)))
      (GHC.Int.$fEnumInt64_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CTime[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CTime -> Int :: *)))
      (GHC.Int.$fEnumInt64_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R ([Sym (Foreign.C.Types.N:CTime[0])])_R
               :: (Int64 -> [Int64] :: *) ~R# (CTime -> [CTime] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               ->_R ([Sym (Foreign.C.Types.N:CTime[0])])_R
               :: (Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CTime -> CTime -> [CTime] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               ->_R ([Sym (Foreign.C.Types.N:CTime[0])])_R
               :: (Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CTime -> CTime -> [CTime] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               ->_R ([Sym (Foreign.C.Types.N:CTime[0])])_R
               :: (Int64 -> Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CTime -> CTime -> CTime -> [CTime] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCTime [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CTime
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CTime
                     GHC.Int.$fNumInt64_$c+
                     `cast` (Sym (Foreign.C.Types.N:CTime[0])
                             ->_R Sym (Foreign.C.Types.N:CTime[0])
                             ->_R Sym (Foreign.C.Types.N:CTime[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CTime -> CTime -> CTime :: *))
                     GHC.Int.$fNumInt64_$c-
                     `cast` (Sym (Foreign.C.Types.N:CTime[0])
                             ->_R Sym (Foreign.C.Types.N:CTime[0])
                             ->_R Sym (Foreign.C.Types.N:CTime[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CTime -> CTime -> CTime :: *))
                     GHC.Int.$fNumInt64_$c*
                     `cast` (Sym (Foreign.C.Types.N:CTime[0])
                             ->_R Sym (Foreign.C.Types.N:CTime[0])
                             ->_R Sym (Foreign.C.Types.N:CTime[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CTime -> CTime -> CTime :: *))
                     GHC.Int.$fNumInt64_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CTime[0])
                             ->_R Sym (Foreign.C.Types.N:CTime[0])
                             :: (Int64 -> Int64 :: *) ~R# (CTime -> CTime :: *))
                     GHC.Int.$fNumInt64_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CTime[0])
                             ->_R Sym (Foreign.C.Types.N:CTime[0])
                             :: (Int64 -> Int64 :: *) ~R# (CTime -> CTime :: *))
                     GHC.Int.$fNumInt64_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CTime[0])
                             ->_R Sym (Foreign.C.Types.N:CTime[0])
                             :: (Int64 -> Int64 :: *) ~R# (CTime -> CTime :: *))
                     GHC.Int.$fNumInt64_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CTime[0])
                             :: (Integer -> Int64 :: *) ~R# (Integer -> CTime :: *))]
Foreign.C.Types.$fNumCTime
  = GHC.Num.C:Num
      @ CTime
      (GHC.Int.$fNumInt64_$c+
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CTime -> CTime -> CTime :: *)))
      (GHC.Int.$fNumInt64_$c-
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CTime -> CTime -> CTime :: *)))
      (GHC.Int.$fNumInt64_$c*
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CTime -> CTime -> CTime :: *)))
      (GHC.Int.$fNumInt64_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               :: (Int64 -> Int64 :: *) ~R# (CTime -> CTime :: *)))
      (GHC.Int.$fNumInt64_$cabs
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               :: (Int64 -> Int64 :: *) ~R# (CTime -> CTime :: *)))
      (GHC.Int.$fNumInt64_$csignum
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               :: (Int64 -> Int64 :: *) ~R# (CTime -> CTime :: *)))
      (GHC.Int.$fNumInt64_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CTime[0])
               :: (Integer -> Int64 :: *) ~R# (Integer -> CTime :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCTime [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CTime
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CTime
                        GHC.Int.eqInt64
                        `cast` (Sym (Foreign.C.Types.N:CTime[0])
                                ->_R Sym (Foreign.C.Types.N:CTime[0])
                                ->_R <Bool>_R
                                :: (Int64 -> Int64 -> Bool :: *) ~R# (CTime -> CTime -> Bool :: *))
                        GHC.Int.neInt64
                        `cast` (Sym (Foreign.C.Types.N:CTime[0])
                                ->_R Sym (Foreign.C.Types.N:CTime[0])
                                ->_R <Bool>_R
                                :: (Int64 -> Int64 -> Bool :: *)
                                   ~R# (CTime -> CTime -> Bool :: *))]
Foreign.C.Types.$fEqCTime
  = GHC.Classes.C:Eq
      @ CTime
      (GHC.Int.eqInt64
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CTime -> CTime -> Bool :: *)))
      (GHC.Int.neInt64
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CTime -> CTime -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCTime [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CTime
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CTime
                         Foreign.C.Types.$fEqCTime
                         GHC.Int.$fOrdInt64_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CTime[0])
                                 ->_R Sym (Foreign.C.Types.N:CTime[0])
                                 ->_R <Ordering>_R
                                 :: (Int64 -> Int64 -> Ordering :: *)
                                    ~R# (CTime -> CTime -> Ordering :: *))
                         GHC.Int.ltInt64
                         `cast` (Sym (Foreign.C.Types.N:CTime[0])
                                 ->_R Sym (Foreign.C.Types.N:CTime[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *) ~R# (CTime -> CTime -> Bool :: *))
                         GHC.Int.leInt64
                         `cast` (Sym (Foreign.C.Types.N:CTime[0])
                                 ->_R Sym (Foreign.C.Types.N:CTime[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *) ~R# (CTime -> CTime -> Bool :: *))
                         GHC.Int.gtInt64
                         `cast` (Sym (Foreign.C.Types.N:CTime[0])
                                 ->_R Sym (Foreign.C.Types.N:CTime[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *) ~R# (CTime -> CTime -> Bool :: *))
                         GHC.Int.geInt64
                         `cast` (Sym (Foreign.C.Types.N:CTime[0])
                                 ->_R Sym (Foreign.C.Types.N:CTime[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *) ~R# (CTime -> CTime -> Bool :: *))
                         GHC.Int.$fOrdInt64_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CTime[0])
                                 ->_R Sym (Foreign.C.Types.N:CTime[0])
                                 ->_R Sym (Foreign.C.Types.N:CTime[0])
                                 :: (Int64 -> Int64 -> Int64 :: *)
                                    ~R# (CTime -> CTime -> CTime :: *))
                         GHC.Int.$fOrdInt64_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CTime[0])
                                 ->_R Sym (Foreign.C.Types.N:CTime[0])
                                 ->_R Sym (Foreign.C.Types.N:CTime[0])
                                 :: (Int64 -> Int64 -> Int64 :: *)
                                    ~R# (CTime -> CTime -> CTime :: *))]
Foreign.C.Types.$fOrdCTime
  = GHC.Classes.C:Ord
      @ CTime
      Foreign.C.Types.$fEqCTime
      (GHC.Int.$fOrdInt64_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               ->_R <Ordering>_R
               :: (Int64 -> Int64 -> Ordering :: *)
                  ~R# (CTime -> CTime -> Ordering :: *)))
      (GHC.Int.ltInt64
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CTime -> CTime -> Bool :: *)))
      (GHC.Int.leInt64
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CTime -> CTime -> Bool :: *)))
      (GHC.Int.gtInt64
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CTime -> CTime -> Bool :: *)))
      (GHC.Int.geInt64
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CTime -> CTime -> Bool :: *)))
      (GHC.Int.$fOrdInt64_$cmax
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CTime -> CTime -> CTime :: *)))
      (GHC.Int.$fOrdInt64_$cmin
       `cast` (Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               ->_R Sym (Foreign.C.Types.N:CTime[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CTime -> CTime -> CTime :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCTime [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CTime
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CTime
                       Foreign.C.Types.$fNumCTime
                       Foreign.C.Types.$fOrdCTime
                       GHC.Int.$fRealInt64_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CTime[0]) ->_R <Ratio Integer>_R
                               :: (Int64 -> Ratio Integer :: *)
                                  ~R# (CTime -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCTime
  = GHC.Real.C:Real
      @ CTime
      Foreign.C.Types.$fNumCTime
      Foreign.C.Types.$fOrdCTime
      (GHC.Int.$fRealInt64_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CTime[0]) ->_R <Ratio Integer>_R
               :: (Int64 -> Ratio Integer :: *)
                  ~R# (CTime -> Ratio Integer :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCClock [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CClock
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CClock
                       GHC.Int.$fShowInt64_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CClock[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Int64 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CClock -> [Char] -> [Char] :: *))
                       GHC.Int.$fShowInt64_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CClock[0]) ->_R <[Char]>_R
                               :: (Int64 -> [Char] :: *) ~R# (CClock -> [Char] :: *))
                       GHC.Int.$fShowInt64_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CClock[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Int64] -> [Char] -> [Char] :: *)
                                  ~R# ([CClock] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCClock
  = GHC.Show.C:Show
      @ CClock
      (GHC.Int.$fShowInt64_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Int64 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CClock -> [Char] -> [Char] :: *)))
      (GHC.Int.$fShowInt64_$cshow
       `cast` (Sym (Foreign.C.Types.N:CClock[0]) ->_R <[Char]>_R
               :: (Int64 -> [Char] :: *) ~R# (CClock -> [Char] :: *)))
      (GHC.Int.$fShowInt64_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CClock[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Int64] -> [Char] -> [Char] :: *)
                  ~R# ([CClock] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCClock [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CClock
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CClock
                       GHC.Int.$fReadInt64_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CClock[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Int64, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CClock, [Char])] :: *))
                       GHC.Int.$fReadInt64_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CClock[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Int64], [Char])] :: *)
                                  ~R# ([Char] -> [([CClock], [Char])] :: *))
                       GHC.Int.$fReadInt10
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Int64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     (Foreign.C.Types.N:CClock[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Int64 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CClock :: *))
                       GHC.Int.$fReadInt7
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Int64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       ([Foreign.C.Types.N:CClock[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Int64] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CClock] :: *))]
Foreign.C.Types.$fReadCClock
  = GHC.Read.C:Read
      @ CClock
      (GHC.Int.$fReadInt64_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CClock[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Int64, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CClock, [Char])] :: *)))
      (GHC.Int.$fReadInt64_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CClock[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Int64], [Char])] :: *)
                  ~R# ([Char] -> [([CClock], [Char])] :: *)))
      (GHC.Int.$fReadInt10
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Int64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                     (Foreign.C.Types.N:CClock[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Int64 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CClock :: *)))
      (GHC.Int.$fReadInt7
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Int64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       ([Foreign.C.Types.N:CClock[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Int64] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CClock] :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCClock [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CClock
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CClock
                                   Foreign.Storable.$fStorableInt64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CClock[0]) ->_R <Int>_R
                                           :: (Int64 -> Int :: *) ~R# (CClock -> Int :: *))
                                   Foreign.Storable.$fStorableInt64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CClock[0]) ->_R <Int>_R
                                           :: (Int64 -> Int :: *) ~R# (CClock -> Int :: *))
                                   GHC.Storable.readInt64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CClock))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CClock[0]))
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CClock -> Int -> IO CClock :: *))
                                   GHC.Storable.writeInt64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CClock))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CClock[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CClock
                                                   -> Int -> CClock -> IO () :: *))
                                   Foreign.Storable.$fStorableInt19
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CClock[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> IO CClock :: *))
                                   Foreign.Storable.$fStorableInt18
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CClock[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CClock -> IO () :: *))
                                   Foreign.Storable.$fStorableInt17
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CClock))_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CClock[0]))
                                           :: (GHC.Ptr.Ptr Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CClock -> IO CClock :: *))
                                   Foreign.Storable.$fStorableInt15
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CClock))_R
                                           ->_R Sym (Foreign.C.Types.N:CClock[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CClock -> CClock -> IO () :: *))]
Foreign.C.Types.$fStorableCClock
  = Foreign.Storable.C:Storable
      @ CClock
      (Foreign.Storable.$fStorableInt64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CClock[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CClock -> Int :: *)))
      (Foreign.Storable.$fStorableInt64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CClock[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CClock -> Int :: *)))
      (GHC.Storable.readInt64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CClock))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CClock[0]))
               :: (GHC.Ptr.Ptr Int64
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CClock -> Int -> IO CClock :: *)))
      (GHC.Storable.writeInt64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CClock))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int64
                   -> Int
                   -> Int64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CClock -> Int -> CClock -> IO () :: *)))
      (Foreign.Storable.$fStorableInt19
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CClock[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CClock :: *)))
      (Foreign.Storable.$fStorableInt18
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Int64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CClock -> IO () :: *)))
      (Foreign.Storable.$fStorableInt17
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CClock))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CClock[0]))
               :: (GHC.Ptr.Ptr Int64
                   -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CClock -> IO CClock :: *)))
      (Foreign.Storable.$fStorableInt15
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CClock))_R
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int64
                   -> Int64 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CClock -> CClock -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCClock [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CClock
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CClock
                       GHC.Int.$fEnumInt64_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CClock[0])
                               ->_R Sym (Foreign.C.Types.N:CClock[0])
                               :: (Int64 -> Int64 :: *) ~R# (CClock -> CClock :: *))
                       GHC.Int.$fEnumInt64_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CClock[0])
                               ->_R Sym (Foreign.C.Types.N:CClock[0])
                               :: (Int64 -> Int64 :: *) ~R# (CClock -> CClock :: *))
                       GHC.Int.$fEnumInt64_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CClock[0])
                               :: (Int -> Int64 :: *) ~R# (Int -> CClock :: *))
                       GHC.Int.$fEnumInt64_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CClock[0]) ->_R <Int>_R
                               :: (Int64 -> Int :: *) ~R# (CClock -> Int :: *))
                       GHC.Int.$fEnumInt64_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CClock[0])
                               ->_R ([Sym (Foreign.C.Types.N:CClock[0])])_R
                               :: (Int64 -> [Int64] :: *) ~R# (CClock -> [CClock] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CClock[0])
                               ->_R Sym (Foreign.C.Types.N:CClock[0])
                               ->_R ([Sym (Foreign.C.Types.N:CClock[0])])_R
                               :: (Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CClock -> CClock -> [CClock] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CClock[0])
                               ->_R Sym (Foreign.C.Types.N:CClock[0])
                               ->_R ([Sym (Foreign.C.Types.N:CClock[0])])_R
                               :: (Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CClock -> CClock -> [CClock] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CClock[0])
                               ->_R Sym (Foreign.C.Types.N:CClock[0])
                               ->_R Sym (Foreign.C.Types.N:CClock[0])
                               ->_R ([Sym (Foreign.C.Types.N:CClock[0])])_R
                               :: (Int64 -> Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CClock -> CClock -> CClock -> [CClock] :: *))]
Foreign.C.Types.$fEnumCClock
  = GHC.Enum.C:Enum
      @ CClock
      (GHC.Int.$fEnumInt64_$csucc
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               :: (Int64 -> Int64 :: *) ~R# (CClock -> CClock :: *)))
      (GHC.Int.$fEnumInt64_$cpred
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               :: (Int64 -> Int64 :: *) ~R# (CClock -> CClock :: *)))
      (GHC.Int.$fEnumInt64_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CClock[0])
               :: (Int -> Int64 :: *) ~R# (Int -> CClock :: *)))
      (GHC.Int.$fEnumInt64_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CClock[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CClock -> Int :: *)))
      (GHC.Int.$fEnumInt64_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R ([Sym (Foreign.C.Types.N:CClock[0])])_R
               :: (Int64 -> [Int64] :: *) ~R# (CClock -> [CClock] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               ->_R ([Sym (Foreign.C.Types.N:CClock[0])])_R
               :: (Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CClock -> CClock -> [CClock] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               ->_R ([Sym (Foreign.C.Types.N:CClock[0])])_R
               :: (Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CClock -> CClock -> [CClock] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               ->_R ([Sym (Foreign.C.Types.N:CClock[0])])_R
               :: (Int64 -> Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CClock -> CClock -> CClock -> [CClock] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCClock [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CClock
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CClock
                     GHC.Int.$fNumInt64_$c+
                     `cast` (Sym (Foreign.C.Types.N:CClock[0])
                             ->_R Sym (Foreign.C.Types.N:CClock[0])
                             ->_R Sym (Foreign.C.Types.N:CClock[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CClock -> CClock -> CClock :: *))
                     GHC.Int.$fNumInt64_$c-
                     `cast` (Sym (Foreign.C.Types.N:CClock[0])
                             ->_R Sym (Foreign.C.Types.N:CClock[0])
                             ->_R Sym (Foreign.C.Types.N:CClock[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CClock -> CClock -> CClock :: *))
                     GHC.Int.$fNumInt64_$c*
                     `cast` (Sym (Foreign.C.Types.N:CClock[0])
                             ->_R Sym (Foreign.C.Types.N:CClock[0])
                             ->_R Sym (Foreign.C.Types.N:CClock[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CClock -> CClock -> CClock :: *))
                     GHC.Int.$fNumInt64_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CClock[0])
                             ->_R Sym (Foreign.C.Types.N:CClock[0])
                             :: (Int64 -> Int64 :: *) ~R# (CClock -> CClock :: *))
                     GHC.Int.$fNumInt64_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CClock[0])
                             ->_R Sym (Foreign.C.Types.N:CClock[0])
                             :: (Int64 -> Int64 :: *) ~R# (CClock -> CClock :: *))
                     GHC.Int.$fNumInt64_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CClock[0])
                             ->_R Sym (Foreign.C.Types.N:CClock[0])
                             :: (Int64 -> Int64 :: *) ~R# (CClock -> CClock :: *))
                     GHC.Int.$fNumInt64_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CClock[0])
                             :: (Integer -> Int64 :: *) ~R# (Integer -> CClock :: *))]
Foreign.C.Types.$fNumCClock
  = GHC.Num.C:Num
      @ CClock
      (GHC.Int.$fNumInt64_$c+
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CClock -> CClock -> CClock :: *)))
      (GHC.Int.$fNumInt64_$c-
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CClock -> CClock -> CClock :: *)))
      (GHC.Int.$fNumInt64_$c*
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CClock -> CClock -> CClock :: *)))
      (GHC.Int.$fNumInt64_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               :: (Int64 -> Int64 :: *) ~R# (CClock -> CClock :: *)))
      (GHC.Int.$fNumInt64_$cabs
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               :: (Int64 -> Int64 :: *) ~R# (CClock -> CClock :: *)))
      (GHC.Int.$fNumInt64_$csignum
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               :: (Int64 -> Int64 :: *) ~R# (CClock -> CClock :: *)))
      (GHC.Int.$fNumInt64_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CClock[0])
               :: (Integer -> Int64 :: *) ~R# (Integer -> CClock :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCClock [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CClock
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CClock
                        GHC.Int.eqInt64
                        `cast` (Sym (Foreign.C.Types.N:CClock[0])
                                ->_R Sym (Foreign.C.Types.N:CClock[0])
                                ->_R <Bool>_R
                                :: (Int64 -> Int64 -> Bool :: *)
                                   ~R# (CClock -> CClock -> Bool :: *))
                        GHC.Int.neInt64
                        `cast` (Sym (Foreign.C.Types.N:CClock[0])
                                ->_R Sym (Foreign.C.Types.N:CClock[0])
                                ->_R <Bool>_R
                                :: (Int64 -> Int64 -> Bool :: *)
                                   ~R# (CClock -> CClock -> Bool :: *))]
Foreign.C.Types.$fEqCClock
  = GHC.Classes.C:Eq
      @ CClock
      (GHC.Int.eqInt64
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CClock -> CClock -> Bool :: *)))
      (GHC.Int.neInt64
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CClock -> CClock -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCClock [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CClock
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CClock
                         Foreign.C.Types.$fEqCClock
                         GHC.Int.$fOrdInt64_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CClock[0])
                                 ->_R Sym (Foreign.C.Types.N:CClock[0])
                                 ->_R <Ordering>_R
                                 :: (Int64 -> Int64 -> Ordering :: *)
                                    ~R# (CClock -> CClock -> Ordering :: *))
                         GHC.Int.ltInt64
                         `cast` (Sym (Foreign.C.Types.N:CClock[0])
                                 ->_R Sym (Foreign.C.Types.N:CClock[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CClock -> CClock -> Bool :: *))
                         GHC.Int.leInt64
                         `cast` (Sym (Foreign.C.Types.N:CClock[0])
                                 ->_R Sym (Foreign.C.Types.N:CClock[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CClock -> CClock -> Bool :: *))
                         GHC.Int.gtInt64
                         `cast` (Sym (Foreign.C.Types.N:CClock[0])
                                 ->_R Sym (Foreign.C.Types.N:CClock[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CClock -> CClock -> Bool :: *))
                         GHC.Int.geInt64
                         `cast` (Sym (Foreign.C.Types.N:CClock[0])
                                 ->_R Sym (Foreign.C.Types.N:CClock[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CClock -> CClock -> Bool :: *))
                         GHC.Int.$fOrdInt64_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CClock[0])
                                 ->_R Sym (Foreign.C.Types.N:CClock[0])
                                 ->_R Sym (Foreign.C.Types.N:CClock[0])
                                 :: (Int64 -> Int64 -> Int64 :: *)
                                    ~R# (CClock -> CClock -> CClock :: *))
                         GHC.Int.$fOrdInt64_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CClock[0])
                                 ->_R Sym (Foreign.C.Types.N:CClock[0])
                                 ->_R Sym (Foreign.C.Types.N:CClock[0])
                                 :: (Int64 -> Int64 -> Int64 :: *)
                                    ~R# (CClock -> CClock -> CClock :: *))]
Foreign.C.Types.$fOrdCClock
  = GHC.Classes.C:Ord
      @ CClock
      Foreign.C.Types.$fEqCClock
      (GHC.Int.$fOrdInt64_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               ->_R <Ordering>_R
               :: (Int64 -> Int64 -> Ordering :: *)
                  ~R# (CClock -> CClock -> Ordering :: *)))
      (GHC.Int.ltInt64
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CClock -> CClock -> Bool :: *)))
      (GHC.Int.leInt64
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CClock -> CClock -> Bool :: *)))
      (GHC.Int.gtInt64
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CClock -> CClock -> Bool :: *)))
      (GHC.Int.geInt64
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CClock -> CClock -> Bool :: *)))
      (GHC.Int.$fOrdInt64_$cmax
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CClock -> CClock -> CClock :: *)))
      (GHC.Int.$fOrdInt64_$cmin
       `cast` (Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               ->_R Sym (Foreign.C.Types.N:CClock[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CClock -> CClock -> CClock :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCClock [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CClock
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CClock
                       Foreign.C.Types.$fNumCClock
                       Foreign.C.Types.$fOrdCClock
                       GHC.Int.$fRealInt64_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CClock[0]) ->_R <Ratio Integer>_R
                               :: (Int64 -> Ratio Integer :: *)
                                  ~R# (CClock -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCClock
  = GHC.Real.C:Real
      @ CClock
      Foreign.C.Types.$fNumCClock
      Foreign.C.Types.$fOrdCClock
      (GHC.Int.$fRealInt64_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CClock[0]) ->_R <Ratio Integer>_R
               :: (Int64 -> Ratio Integer :: *)
                  ~R# (CClock -> Ratio Integer :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCSigAtomic [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CSigAtomic
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CSigAtomic
                       GHC.Int.$fShowInt32_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Int32 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CSigAtomic -> [Char] -> [Char] :: *))
                       GHC.Int.$fShowInt32_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <[Char]>_R
                               :: (Int32 -> [Char] :: *) ~R# (CSigAtomic -> [Char] :: *))
                       GHC.Int.$fShowInt32_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CSigAtomic[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Int32] -> [Char] -> [Char] :: *)
                                  ~R# ([CSigAtomic] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCSigAtomic
  = GHC.Show.C:Show
      @ CSigAtomic
      (GHC.Int.$fShowInt32_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Int32 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CSigAtomic -> [Char] -> [Char] :: *)))
      (GHC.Int.$fShowInt32_$cshow
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <[Char]>_R
               :: (Int32 -> [Char] :: *) ~R# (CSigAtomic -> [Char] :: *)))
      (GHC.Int.$fShowInt32_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CSigAtomic[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Int32] -> [Char] -> [Char] :: *)
                  ~R# ([CSigAtomic] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCSigAtomic [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CSigAtomic
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CSigAtomic
                       GHC.Int.$fReadInt32_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,)
                                         (Sym (Foreign.C.Types.N:CSigAtomic[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Int32, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CSigAtomic, [Char])] :: *))
                       GHC.Int.$fReadInt32_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CSigAtomic[0])])_R
                                         <[Char]>_R)_R])_R
                               :: ([Char] -> [([Int32], [Char])] :: *)
                                  ~R# ([Char] -> [([CSigAtomic], [Char])] :: *))
                       GHC.Int.$fReadInt6
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Int32>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     (Foreign.C.Types.N:CSigAtomic[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Int32 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CSigAtomic :: *))
                       GHC.Int.$fReadInt4
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Int32]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       ([Foreign.C.Types.N:CSigAtomic[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Int32] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CSigAtomic] :: *))]
Foreign.C.Types.$fReadCSigAtomic
  = GHC.Read.C:Read
      @ CSigAtomic
      (GHC.Int.$fReadInt32_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,)
                         (Sym (Foreign.C.Types.N:CSigAtomic[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Int32, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CSigAtomic, [Char])] :: *)))
      (GHC.Int.$fReadInt32_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CSigAtomic[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Int32], [Char])] :: *)
                  ~R# ([Char] -> [([CSigAtomic], [Char])] :: *)))
      (GHC.Int.$fReadInt6
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Int32>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                     (Foreign.C.Types.N:CSigAtomic[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Int32 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CSigAtomic :: *)))
      (GHC.Int.$fReadInt4
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Int32]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       ([Foreign.C.Types.N:CSigAtomic[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Int32] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CSigAtomic] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.C.Types.$fBoundedCSigAtomic [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded CSigAtomic
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: CSigAtomic
                          GHC.Int.$fBoundedInt32_$cminBound
                          `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                  :: (Int32 :: *) ~R# (CSigAtomic :: *))
                          GHC.Int.$fBoundedInt32_$cmaxBound
                          `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                  :: (Int32 :: *) ~R# (CSigAtomic :: *))]
Foreign.C.Types.$fBoundedCSigAtomic
  = GHC.Enum.C:Bounded
      @ CSigAtomic
      (GHC.Int.$fBoundedInt32_$cminBound
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 :: *) ~R# (CSigAtomic :: *)))
      (GHC.Int.$fBoundedInt32_$cmaxBound
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 :: *) ~R# (CSigAtomic :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCSigAtomic [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CSigAtomic
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CSigAtomic
                                   Foreign.Storable.$fStorableInt32_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Int>_R
                                           :: (Int32 -> Int :: *) ~R# (CSigAtomic -> Int :: *))
                                   Foreign.Storable.$fStorableInt32_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Int>_R
                                           :: (Int32 -> Int :: *) ~R# (CSigAtomic -> Int :: *))
                                   GHC.Storable.readInt32OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int32, CSigAtomic))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CSigAtomic[0]))
                                           :: (GHC.Ptr.Ptr Int32
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int32 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CSigAtomic
                                                   -> Int -> IO CSigAtomic :: *))
                                   GHC.Storable.writeInt32OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int32, CSigAtomic))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int32
                                               -> Int
                                               -> Int32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CSigAtomic
                                                   -> Int -> CSigAtomic -> IO () :: *))
                                   Foreign.Storable.$fStorableInt14
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CSigAtomic[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int32 #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> IO CSigAtomic :: *))
                                   Foreign.Storable.$fStorableInt13
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Int32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b
                                                   -> Int -> CSigAtomic -> IO () :: *))
                                   Foreign.Storable.$fStorableInt12
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int32, CSigAtomic))_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CSigAtomic[0]))
                                           :: (GHC.Ptr.Ptr Int32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int32 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CSigAtomic -> IO CSigAtomic :: *))
                                   Foreign.Storable.$fStorableInt11
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int32, CSigAtomic))_R
                                           ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int32
                                               -> Int32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CSigAtomic
                                                   -> CSigAtomic -> IO () :: *))]
Foreign.C.Types.$fStorableCSigAtomic
  = Foreign.Storable.C:Storable
      @ CSigAtomic
      (Foreign.Storable.$fStorableInt32_$calignment
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CSigAtomic -> Int :: *)))
      (Foreign.Storable.$fStorableInt32_$calignment
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CSigAtomic -> Int :: *)))
      (GHC.Storable.readInt32OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int32, CSigAtomic))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CSigAtomic[0]))
               :: (GHC.Ptr.Ptr Int32
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int32 #) :: *)
                  ~R# (GHC.Ptr.Ptr CSigAtomic -> Int -> IO CSigAtomic :: *)))
      (GHC.Storable.writeInt32OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int32, CSigAtomic))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int32
                   -> Int
                   -> Int32
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CSigAtomic -> Int -> CSigAtomic -> IO () :: *)))
      (Foreign.Storable.$fStorableInt14
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CSigAtomic[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int32 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CSigAtomic :: *)))
      (Foreign.Storable.$fStorableInt13
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Int32
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CSigAtomic -> IO () :: *)))
      (Foreign.Storable.$fStorableInt12
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int32, CSigAtomic))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CSigAtomic[0]))
               :: (GHC.Ptr.Ptr Int32
                   -> State# RealWorld -> (# State# RealWorld, Int32 #) :: *)
                  ~R# (GHC.Ptr.Ptr CSigAtomic -> IO CSigAtomic :: *)))
      (Foreign.Storable.$fStorableInt11
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int32, CSigAtomic))_R
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int32
                   -> Int32 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CSigAtomic -> CSigAtomic -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCSigAtomic [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CSigAtomic
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CSigAtomic
                       GHC.Int.$fEnumInt32_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                               :: (Int32 -> Int32 :: *) ~R# (CSigAtomic -> CSigAtomic :: *))
                       GHC.Int.$fEnumInt32_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                               :: (Int32 -> Int32 :: *) ~R# (CSigAtomic -> CSigAtomic :: *))
                       GHC.Int.$fEnumInt32_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                               :: (Int -> Int32 :: *) ~R# (Int -> CSigAtomic :: *))
                       GHC.Int.$fEnumInt32_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Int>_R
                               :: (Int32 -> Int :: *) ~R# (CSigAtomic -> Int :: *))
                       GHC.Int.$fEnumInt32_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                               ->_R ([Sym (Foreign.C.Types.N:CSigAtomic[0])])_R
                               :: (Int32 -> [Int32] :: *) ~R# (CSigAtomic -> [CSigAtomic] :: *))
                       GHC.Int.$fEnumInt32_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                               ->_R ([Sym (Foreign.C.Types.N:CSigAtomic[0])])_R
                               :: (Int32 -> Int32 -> [Int32] :: *)
                                  ~R# (CSigAtomic -> CSigAtomic -> [CSigAtomic] :: *))
                       GHC.Int.$fEnumInt32_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                               ->_R ([Sym (Foreign.C.Types.N:CSigAtomic[0])])_R
                               :: (Int32 -> Int32 -> [Int32] :: *)
                                  ~R# (CSigAtomic -> CSigAtomic -> [CSigAtomic] :: *))
                       GHC.Int.$fEnumInt32_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                               ->_R ([Sym (Foreign.C.Types.N:CSigAtomic[0])])_R
                               :: (Int32 -> Int32 -> Int32 -> [Int32] :: *)
                                  ~R# (CSigAtomic
                                       -> CSigAtomic -> CSigAtomic -> [CSigAtomic] :: *))]
Foreign.C.Types.$fEnumCSigAtomic
  = GHC.Enum.C:Enum
      @ CSigAtomic
      (GHC.Int.$fEnumInt32_$csucc
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int32 :: *) ~R# (CSigAtomic -> CSigAtomic :: *)))
      (GHC.Int.$fEnumInt32_$cpred
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int32 :: *) ~R# (CSigAtomic -> CSigAtomic :: *)))
      (GHC.Int.$fEnumInt32_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int -> Int32 :: *) ~R# (Int -> CSigAtomic :: *)))
      (GHC.Int.$fEnumInt32_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CSigAtomic -> Int :: *)))
      (GHC.Int.$fEnumInt32_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R ([Sym (Foreign.C.Types.N:CSigAtomic[0])])_R
               :: (Int32 -> [Int32] :: *) ~R# (CSigAtomic -> [CSigAtomic] :: *)))
      (GHC.Int.$fEnumInt32_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R ([Sym (Foreign.C.Types.N:CSigAtomic[0])])_R
               :: (Int32 -> Int32 -> [Int32] :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> [CSigAtomic] :: *)))
      (GHC.Int.$fEnumInt32_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R ([Sym (Foreign.C.Types.N:CSigAtomic[0])])_R
               :: (Int32 -> Int32 -> [Int32] :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> [CSigAtomic] :: *)))
      (GHC.Int.$fEnumInt32_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R ([Sym (Foreign.C.Types.N:CSigAtomic[0])])_R
               :: (Int32 -> Int32 -> Int32 -> [Int32] :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic -> [CSigAtomic] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCSigAtomic [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CSigAtomic
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CSigAtomic
                     GHC.Int.$fNumInt32_$c+
                     `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                             ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                             ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                             :: (Int32 -> Int32 -> Int32 :: *)
                                ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *))
                     GHC.Int.$fNumInt32_$c-
                     `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                             ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                             ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                             :: (Int32 -> Int32 -> Int32 :: *)
                                ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *))
                     GHC.Int.$fNumInt32_$c*
                     `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                             ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                             ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                             :: (Int32 -> Int32 -> Int32 :: *)
                                ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *))
                     GHC.Int.$fNumInt32_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                             ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                             :: (Int32 -> Int32 :: *) ~R# (CSigAtomic -> CSigAtomic :: *))
                     GHC.Int.$fNumInt32_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                             ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                             :: (Int32 -> Int32 :: *) ~R# (CSigAtomic -> CSigAtomic :: *))
                     GHC.Int.$fNumInt32_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                             ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                             :: (Int32 -> Int32 :: *) ~R# (CSigAtomic -> CSigAtomic :: *))
                     GHC.Int.$fNumInt32_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                             :: (Integer -> Int32 :: *) ~R# (Integer -> CSigAtomic :: *))]
Foreign.C.Types.$fNumCSigAtomic
  = GHC.Num.C:Num
      @ CSigAtomic
      (GHC.Int.$fNumInt32_$c+
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *)))
      (GHC.Int.$fNumInt32_$c-
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *)))
      (GHC.Int.$fNumInt32_$c*
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *)))
      (GHC.Int.$fNumInt32_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int32 :: *) ~R# (CSigAtomic -> CSigAtomic :: *)))
      (GHC.Int.$fNumInt32_$cabs
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int32 :: *) ~R# (CSigAtomic -> CSigAtomic :: *)))
      (GHC.Int.$fNumInt32_$csignum
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int32 :: *) ~R# (CSigAtomic -> CSigAtomic :: *)))
      (GHC.Int.$fNumInt32_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Integer -> Int32 :: *) ~R# (Integer -> CSigAtomic :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCSigAtomic [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CSigAtomic
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CSigAtomic
                        GHC.Int.eqInt32
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R <Bool>_R
                                :: (Int32 -> Int32 -> Bool :: *)
                                   ~R# (CSigAtomic -> CSigAtomic -> Bool :: *))
                        GHC.Int.neInt32
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R <Bool>_R
                                :: (Int32 -> Int32 -> Bool :: *)
                                   ~R# (CSigAtomic -> CSigAtomic -> Bool :: *))]
Foreign.C.Types.$fEqCSigAtomic
  = GHC.Classes.C:Eq
      @ CSigAtomic
      (GHC.Int.eqInt32
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R <Bool>_R
               :: (Int32 -> Int32 -> Bool :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> Bool :: *)))
      (GHC.Int.neInt32
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R <Bool>_R
               :: (Int32 -> Int32 -> Bool :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCSigAtomic [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CSigAtomic
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CSigAtomic
                         Foreign.C.Types.$fEqCSigAtomic
                         GHC.Int.$fOrdInt32_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                 ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                 ->_R <Ordering>_R
                                 :: (Int32 -> Int32 -> Ordering :: *)
                                    ~R# (CSigAtomic -> CSigAtomic -> Ordering :: *))
                         GHC.Int.ltInt32
                         `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                 ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                 ->_R <Bool>_R
                                 :: (Int32 -> Int32 -> Bool :: *)
                                    ~R# (CSigAtomic -> CSigAtomic -> Bool :: *))
                         GHC.Int.leInt32
                         `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                 ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                 ->_R <Bool>_R
                                 :: (Int32 -> Int32 -> Bool :: *)
                                    ~R# (CSigAtomic -> CSigAtomic -> Bool :: *))
                         GHC.Int.gtInt32
                         `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                 ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                 ->_R <Bool>_R
                                 :: (Int32 -> Int32 -> Bool :: *)
                                    ~R# (CSigAtomic -> CSigAtomic -> Bool :: *))
                         GHC.Int.geInt32
                         `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                 ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                 ->_R <Bool>_R
                                 :: (Int32 -> Int32 -> Bool :: *)
                                    ~R# (CSigAtomic -> CSigAtomic -> Bool :: *))
                         GHC.Int.$fOrdInt32_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                 ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                 ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                 :: (Int32 -> Int32 -> Int32 :: *)
                                    ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *))
                         GHC.Int.$fOrdInt32_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                 ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                 ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                 :: (Int32 -> Int32 -> Int32 :: *)
                                    ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *))]
Foreign.C.Types.$fOrdCSigAtomic
  = GHC.Classes.C:Ord
      @ CSigAtomic
      Foreign.C.Types.$fEqCSigAtomic
      (GHC.Int.$fOrdInt32_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R <Ordering>_R
               :: (Int32 -> Int32 -> Ordering :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> Ordering :: *)))
      (GHC.Int.ltInt32
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R <Bool>_R
               :: (Int32 -> Int32 -> Bool :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> Bool :: *)))
      (GHC.Int.leInt32
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R <Bool>_R
               :: (Int32 -> Int32 -> Bool :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> Bool :: *)))
      (GHC.Int.gtInt32
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R <Bool>_R
               :: (Int32 -> Int32 -> Bool :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> Bool :: *)))
      (GHC.Int.geInt32
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R <Bool>_R
               :: (Int32 -> Int32 -> Bool :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> Bool :: *)))
      (GHC.Int.$fOrdInt32_$cmax
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *)))
      (GHC.Int.$fOrdInt32_$cmin
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCSigAtomic [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CSigAtomic
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CSigAtomic
                       Foreign.C.Types.$fNumCSigAtomic
                       Foreign.C.Types.$fOrdCSigAtomic
                       GHC.Int.$fRealInt32_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                               ->_R <Ratio Integer>_R
                               :: (Int32 -> Ratio Integer :: *)
                                  ~R# (CSigAtomic -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCSigAtomic
  = GHC.Real.C:Real
      @ CSigAtomic
      Foreign.C.Types.$fNumCSigAtomic
      Foreign.C.Types.$fOrdCSigAtomic
      (GHC.Int.$fRealInt32_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R <Ratio Integer>_R
               :: (Int32 -> Ratio Integer :: *)
                  ~R# (CSigAtomic -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.C.Types.$fIntegralCSigAtomic [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral CSigAtomic
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: CSigAtomic
                           Foreign.C.Types.$fRealCSigAtomic
                           Foreign.C.Types.$fEnumCSigAtomic
                           GHC.Int.$fIntegralInt32_$cquot
                           `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                   ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                   ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                   :: (Int32 -> Int32 -> Int32 :: *)
                                      ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *))
                           GHC.Int.$fIntegralInt32_$crem
                           `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                   ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                   ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                   :: (Int32 -> Int32 -> Int32 :: *)
                                      ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *))
                           GHC.Int.$fIntegralInt32_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                   ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                   ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                   :: (Int32 -> Int32 -> Int32 :: *)
                                      ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *))
                           GHC.Int.$fIntegralInt32_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                   ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                   ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                   :: (Int32 -> Int32 -> Int32 :: *)
                                      ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *))
                           GHC.Int.$fIntegralInt32_$cquotRem
                           `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                   ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CSigAtomic[0]))
                                           (Sym (Foreign.C.Types.N:CSigAtomic[0])))_R
                                   :: (Int32 -> Int32 -> (Int32, Int32) :: *)
                                      ~R# (CSigAtomic
                                           -> CSigAtomic -> (CSigAtomic, CSigAtomic) :: *))
                           GHC.Int.$fIntegralInt32_$cdivMod
                           `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                   ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CSigAtomic[0]))
                                           (Sym (Foreign.C.Types.N:CSigAtomic[0])))_R
                                   :: (Int32 -> Int32 -> (Int32, Int32) :: *)
                                      ~R# (CSigAtomic
                                           -> CSigAtomic -> (CSigAtomic, CSigAtomic) :: *))
                           GHC.Int.$fIntegralInt32_$ctoInteger
                           `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Integer>_R
                                   :: (Int32 -> Integer :: *) ~R# (CSigAtomic -> Integer :: *))]
Foreign.C.Types.$fIntegralCSigAtomic
  = GHC.Real.C:Integral
      @ CSigAtomic
      Foreign.C.Types.$fRealCSigAtomic
      Foreign.C.Types.$fEnumCSigAtomic
      (GHC.Int.$fIntegralInt32_$cquot
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *)))
      (GHC.Int.$fIntegralInt32_$crem
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *)))
      (GHC.Int.$fIntegralInt32_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *)))
      (GHC.Int.$fIntegralInt32_$cmod
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *)))
      (GHC.Int.$fIntegralInt32_$cquotRem
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CSigAtomic[0]))
                       (Sym (Foreign.C.Types.N:CSigAtomic[0])))_R
               :: (Int32 -> Int32 -> (Int32, Int32) :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> (CSigAtomic, CSigAtomic) :: *)))
      (GHC.Int.$fIntegralInt32_$cdivMod
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CSigAtomic[0]))
                       (Sym (Foreign.C.Types.N:CSigAtomic[0])))_R
               :: (Int32 -> Int32 -> (Int32, Int32) :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> (CSigAtomic, CSigAtomic) :: *)))
      (GHC.Int.$fIntegralInt32_$ctoInteger
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Integer>_R
               :: (Int32 -> Integer :: *) ~R# (CSigAtomic -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.C.Types.$fBitsCSigAtomic [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits CSigAtomic
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: CSigAtomic
                        Foreign.C.Types.$fEqCSigAtomic
                        GHC.Int.$fBitsInt32_$c.&.
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                :: (Int32 -> Int32 -> Int32 :: *)
                                   ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *))
                        GHC.Int.$fBitsInt32_$c.|.
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                :: (Int32 -> Int32 -> Int32 :: *)
                                   ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *))
                        GHC.Int.$fBitsInt32_$cxor
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                :: (Int32 -> Int32 -> Int32 :: *)
                                   ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *))
                        GHC.Int.$fBitsInt32_$ccomplement
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                :: (Int32 -> Int32 :: *) ~R# (CSigAtomic -> CSigAtomic :: *))
                        GHC.Int.$fBitsInt32_$cshift
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                :: (Int32 -> Int -> Int32 :: *)
                                   ~R# (CSigAtomic -> Int -> CSigAtomic :: *))
                        GHC.Int.$fBitsInt32_$crotate
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                :: (Int32 -> Int -> Int32 :: *)
                                   ~R# (CSigAtomic -> Int -> CSigAtomic :: *))
                        GHC.Int.$fBitsInt6
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                :: (Int32 :: *) ~R# (CSigAtomic :: *))
                        GHC.Int.$fBitsInt32_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                :: (Int -> Int32 :: *) ~R# (Int -> CSigAtomic :: *))
                        GHC.Int.$fBitsInt32_$csetBit
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                :: (Int32 -> Int -> Int32 :: *)
                                   ~R# (CSigAtomic -> Int -> CSigAtomic :: *))
                        GHC.Int.$fBitsInt32_$cclearBit
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                :: (Int32 -> Int -> Int32 :: *)
                                   ~R# (CSigAtomic -> Int -> CSigAtomic :: *))
                        GHC.Int.$fBitsInt32_$ccomplementBit
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                :: (Int32 -> Int -> Int32 :: *)
                                   ~R# (CSigAtomic -> Int -> CSigAtomic :: *))
                        GHC.Int.$fBitsInt32_$ctestBit
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Int -> Bool>_R
                                :: (Int32 -> Int -> Bool :: *)
                                   ~R# (CSigAtomic -> Int -> Bool :: *))
                        GHC.Int.$fBitsInt32_$cbitSizeMaybe
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Maybe Int>_R
                                :: (Int32 -> Maybe Int :: *) ~R# (CSigAtomic -> Maybe Int :: *))
                        GHC.Int.$fBitsInt32_$cfiniteBitSize
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Int>_R
                                :: (Int32 -> Int :: *) ~R# (CSigAtomic -> Int :: *))
                        GHC.Int.$fBitsInt32_$cisSigned
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Bool>_R
                                :: (Int32 -> Bool :: *) ~R# (CSigAtomic -> Bool :: *))
                        GHC.Int.$fBitsInt32_$cshiftL
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                :: (Int32 -> Int -> Int32 :: *)
                                   ~R# (CSigAtomic -> Int -> CSigAtomic :: *))
                        GHC.Int.$fBitsInt32_$cunsafeShiftL
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                :: (Int32 -> Int -> Int32 :: *)
                                   ~R# (CSigAtomic -> Int -> CSigAtomic :: *))
                        GHC.Int.$fBitsInt32_$cshiftR
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                :: (Int32 -> Int -> Int32 :: *)
                                   ~R# (CSigAtomic -> Int -> CSigAtomic :: *))
                        GHC.Int.$fBitsInt32_$cunsafeShiftR
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                :: (Int32 -> Int -> Int32 :: *)
                                   ~R# (CSigAtomic -> Int -> CSigAtomic :: *))
                        GHC.Int.$fBitsInt32_$crotateL
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                :: (Int32 -> Int -> Int32 :: *)
                                   ~R# (CSigAtomic -> Int -> CSigAtomic :: *))
                        GHC.Int.$fBitsInt32_$crotateR
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                                :: (Int32 -> Int -> Int32 :: *)
                                   ~R# (CSigAtomic -> Int -> CSigAtomic :: *))
                        GHC.Int.$fBitsInt32_$cpopCount
                        `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Int>_R
                                :: (Int32 -> Int :: *) ~R# (CSigAtomic -> Int :: *))]
Foreign.C.Types.$fBitsCSigAtomic
  = Data.Bits.C:Bits
      @ CSigAtomic
      Foreign.C.Types.$fEqCSigAtomic
      (GHC.Int.$fBitsInt32_$c.&.
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *)))
      (GHC.Int.$fBitsInt32_$c.|.
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *)))
      (GHC.Int.$fBitsInt32_$cxor
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CSigAtomic -> CSigAtomic -> CSigAtomic :: *)))
      (GHC.Int.$fBitsInt32_$ccomplement
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int32 :: *) ~R# (CSigAtomic -> CSigAtomic :: *)))
      (GHC.Int.$fBitsInt32_$cshift
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CSigAtomic -> Int -> CSigAtomic :: *)))
      (GHC.Int.$fBitsInt32_$crotate
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CSigAtomic -> Int -> CSigAtomic :: *)))
      (GHC.Int.$fBitsInt6
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 :: *) ~R# (CSigAtomic :: *)))
      (GHC.Int.$fBitsInt32_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int -> Int32 :: *) ~R# (Int -> CSigAtomic :: *)))
      (GHC.Int.$fBitsInt32_$csetBit
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CSigAtomic -> Int -> CSigAtomic :: *)))
      (GHC.Int.$fBitsInt32_$cclearBit
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CSigAtomic -> Int -> CSigAtomic :: *)))
      (GHC.Int.$fBitsInt32_$ccomplementBit
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CSigAtomic -> Int -> CSigAtomic :: *)))
      (GHC.Int.$fBitsInt32_$ctestBit
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Int -> Bool>_R
               :: (Int32 -> Int -> Bool :: *)
                  ~R# (CSigAtomic -> Int -> Bool :: *)))
      (GHC.Int.$fBitsInt32_$cbitSizeMaybe
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Maybe Int>_R
               :: (Int32 -> Maybe Int :: *) ~R# (CSigAtomic -> Maybe Int :: *)))
      (GHC.Int.$fBitsInt32_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CSigAtomic -> Int :: *)))
      (GHC.Int.$fBitsInt32_$cisSigned
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Bool>_R
               :: (Int32 -> Bool :: *) ~R# (CSigAtomic -> Bool :: *)))
      (GHC.Int.$fBitsInt32_$cshiftL
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CSigAtomic -> Int -> CSigAtomic :: *)))
      (GHC.Int.$fBitsInt32_$cunsafeShiftL
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CSigAtomic -> Int -> CSigAtomic :: *)))
      (GHC.Int.$fBitsInt32_$cshiftR
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CSigAtomic -> Int -> CSigAtomic :: *)))
      (GHC.Int.$fBitsInt32_$cunsafeShiftR
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CSigAtomic -> Int -> CSigAtomic :: *)))
      (GHC.Int.$fBitsInt32_$crotateL
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CSigAtomic -> Int -> CSigAtomic :: *)))
      (GHC.Int.$fBitsInt32_$crotateR
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CSigAtomic -> Int -> CSigAtomic :: *)))
      (GHC.Int.$fBitsInt32_$cpopCount
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CSigAtomic -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.C.Types.$fFiniteBitsCSigAtomic [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits CSigAtomic
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: CSigAtomic
                              Foreign.C.Types.$fBitsCSigAtomic
                              GHC.Int.$fBitsInt32_$cfiniteBitSize
                              `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Int>_R
                                      :: (Int32 -> Int :: *) ~R# (CSigAtomic -> Int :: *))
                              GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros
                              `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Int>_R
                                      :: (Int32 -> Int :: *) ~R# (CSigAtomic -> Int :: *))
                              GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros
                              `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Int>_R
                                      :: (Int32 -> Int :: *) ~R# (CSigAtomic -> Int :: *))]
Foreign.C.Types.$fFiniteBitsCSigAtomic
  = Data.Bits.C:FiniteBits
      @ CSigAtomic
      Foreign.C.Types.$fBitsCSigAtomic
      (GHC.Int.$fBitsInt32_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CSigAtomic -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CSigAtomic -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros
       `cast` (Sym (Foreign.C.Types.N:CSigAtomic[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CSigAtomic -> Int :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCWchar [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CWchar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CWchar
                       GHC.Int.$fShowInt32_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CWchar[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Int32 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CWchar -> [Char] -> [Char] :: *))
                       GHC.Int.$fShowInt32_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <[Char]>_R
                               :: (Int32 -> [Char] :: *) ~R# (CWchar -> [Char] :: *))
                       GHC.Int.$fShowInt32_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CWchar[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Int32] -> [Char] -> [Char] :: *)
                                  ~R# ([CWchar] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCWchar
  = GHC.Show.C:Show
      @ CWchar
      (GHC.Int.$fShowInt32_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Int32 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CWchar -> [Char] -> [Char] :: *)))
      (GHC.Int.$fShowInt32_$cshow
       `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <[Char]>_R
               :: (Int32 -> [Char] :: *) ~R# (CWchar -> [Char] :: *)))
      (GHC.Int.$fShowInt32_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CWchar[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Int32] -> [Char] -> [Char] :: *)
                  ~R# ([CWchar] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCWchar [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CWchar
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CWchar
                       GHC.Int.$fReadInt32_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CWchar[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Int32, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CWchar, [Char])] :: *))
                       GHC.Int.$fReadInt32_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CWchar[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Int32], [Char])] :: *)
                                  ~R# ([Char] -> [([CWchar], [Char])] :: *))
                       GHC.Int.$fReadInt6
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Int32>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     (Foreign.C.Types.N:CWchar[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Int32 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CWchar :: *))
                       GHC.Int.$fReadInt4
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Int32]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       ([Foreign.C.Types.N:CWchar[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Int32] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CWchar] :: *))]
Foreign.C.Types.$fReadCWchar
  = GHC.Read.C:Read
      @ CWchar
      (GHC.Int.$fReadInt32_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CWchar[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Int32, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CWchar, [Char])] :: *)))
      (GHC.Int.$fReadInt32_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CWchar[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Int32], [Char])] :: *)
                  ~R# ([Char] -> [([CWchar], [Char])] :: *)))
      (GHC.Int.$fReadInt6
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Int32>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                     (Foreign.C.Types.N:CWchar[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Int32 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CWchar :: *)))
      (GHC.Int.$fReadInt4
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Int32]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       ([Foreign.C.Types.N:CWchar[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Int32] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CWchar] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.C.Types.$fBoundedCWchar [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded CWchar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: CWchar
                          GHC.Int.$fBoundedInt32_$cminBound
                          `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                  :: (Int32 :: *) ~R# (CWchar :: *))
                          GHC.Int.$fBoundedInt32_$cmaxBound
                          `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                  :: (Int32 :: *) ~R# (CWchar :: *))]
Foreign.C.Types.$fBoundedCWchar
  = GHC.Enum.C:Bounded
      @ CWchar
      (GHC.Int.$fBoundedInt32_$cminBound
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 :: *) ~R# (CWchar :: *)))
      (GHC.Int.$fBoundedInt32_$cmaxBound
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 :: *) ~R# (CWchar :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCWchar [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CWchar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CWchar
                                   Foreign.Storable.$fStorableInt32_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Int>_R
                                           :: (Int32 -> Int :: *) ~R# (CWchar -> Int :: *))
                                   Foreign.Storable.$fStorableInt32_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Int>_R
                                           :: (Int32 -> Int :: *) ~R# (CWchar -> Int :: *))
                                   GHC.Storable.readInt32OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int32, CWchar))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CWchar[0]))
                                           :: (GHC.Ptr.Ptr Int32
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int32 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CWchar -> Int -> IO CWchar :: *))
                                   GHC.Storable.writeInt32OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int32, CWchar))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int32
                                               -> Int
                                               -> Int32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CWchar
                                                   -> Int -> CWchar -> IO () :: *))
                                   Foreign.Storable.$fStorableInt14
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CWchar[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int32 #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> IO CWchar :: *))
                                   Foreign.Storable.$fStorableInt13
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Int32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CWchar -> IO () :: *))
                                   Foreign.Storable.$fStorableInt12
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int32, CWchar))_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CWchar[0]))
                                           :: (GHC.Ptr.Ptr Int32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int32 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CWchar -> IO CWchar :: *))
                                   Foreign.Storable.$fStorableInt11
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int32, CWchar))_R
                                           ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int32
                                               -> Int32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CWchar -> CWchar -> IO () :: *))]
Foreign.C.Types.$fStorableCWchar
  = Foreign.Storable.C:Storable
      @ CWchar
      (Foreign.Storable.$fStorableInt32_$calignment
       `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CWchar -> Int :: *)))
      (Foreign.Storable.$fStorableInt32_$calignment
       `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CWchar -> Int :: *)))
      (GHC.Storable.readInt32OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int32, CWchar))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CWchar[0]))
               :: (GHC.Ptr.Ptr Int32
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int32 #) :: *)
                  ~R# (GHC.Ptr.Ptr CWchar -> Int -> IO CWchar :: *)))
      (GHC.Storable.writeInt32OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int32, CWchar))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int32
                   -> Int
                   -> Int32
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CWchar -> Int -> CWchar -> IO () :: *)))
      (Foreign.Storable.$fStorableInt14
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CWchar[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int32 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CWchar :: *)))
      (Foreign.Storable.$fStorableInt13
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Int32
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CWchar -> IO () :: *)))
      (Foreign.Storable.$fStorableInt12
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int32, CWchar))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CWchar[0]))
               :: (GHC.Ptr.Ptr Int32
                   -> State# RealWorld -> (# State# RealWorld, Int32 #) :: *)
                  ~R# (GHC.Ptr.Ptr CWchar -> IO CWchar :: *)))
      (Foreign.Storable.$fStorableInt11
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int32, CWchar))_R
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int32
                   -> Int32 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CWchar -> CWchar -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCWchar [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CWchar
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CWchar
                       GHC.Int.$fEnumInt32_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                               ->_R Sym (Foreign.C.Types.N:CWchar[0])
                               :: (Int32 -> Int32 :: *) ~R# (CWchar -> CWchar :: *))
                       GHC.Int.$fEnumInt32_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                               ->_R Sym (Foreign.C.Types.N:CWchar[0])
                               :: (Int32 -> Int32 :: *) ~R# (CWchar -> CWchar :: *))
                       GHC.Int.$fEnumInt32_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CWchar[0])
                               :: (Int -> Int32 :: *) ~R# (Int -> CWchar :: *))
                       GHC.Int.$fEnumInt32_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Int>_R
                               :: (Int32 -> Int :: *) ~R# (CWchar -> Int :: *))
                       GHC.Int.$fEnumInt32_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                               ->_R ([Sym (Foreign.C.Types.N:CWchar[0])])_R
                               :: (Int32 -> [Int32] :: *) ~R# (CWchar -> [CWchar] :: *))
                       GHC.Int.$fEnumInt32_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                               ->_R Sym (Foreign.C.Types.N:CWchar[0])
                               ->_R ([Sym (Foreign.C.Types.N:CWchar[0])])_R
                               :: (Int32 -> Int32 -> [Int32] :: *)
                                  ~R# (CWchar -> CWchar -> [CWchar] :: *))
                       GHC.Int.$fEnumInt32_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                               ->_R Sym (Foreign.C.Types.N:CWchar[0])
                               ->_R ([Sym (Foreign.C.Types.N:CWchar[0])])_R
                               :: (Int32 -> Int32 -> [Int32] :: *)
                                  ~R# (CWchar -> CWchar -> [CWchar] :: *))
                       GHC.Int.$fEnumInt32_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                               ->_R Sym (Foreign.C.Types.N:CWchar[0])
                               ->_R Sym (Foreign.C.Types.N:CWchar[0])
                               ->_R ([Sym (Foreign.C.Types.N:CWchar[0])])_R
                               :: (Int32 -> Int32 -> Int32 -> [Int32] :: *)
                                  ~R# (CWchar -> CWchar -> CWchar -> [CWchar] :: *))]
Foreign.C.Types.$fEnumCWchar
  = GHC.Enum.C:Enum
      @ CWchar
      (GHC.Int.$fEnumInt32_$csucc
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int32 :: *) ~R# (CWchar -> CWchar :: *)))
      (GHC.Int.$fEnumInt32_$cpred
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int32 :: *) ~R# (CWchar -> CWchar :: *)))
      (GHC.Int.$fEnumInt32_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int -> Int32 :: *) ~R# (Int -> CWchar :: *)))
      (GHC.Int.$fEnumInt32_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CWchar -> Int :: *)))
      (GHC.Int.$fEnumInt32_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R ([Sym (Foreign.C.Types.N:CWchar[0])])_R
               :: (Int32 -> [Int32] :: *) ~R# (CWchar -> [CWchar] :: *)))
      (GHC.Int.$fEnumInt32_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R ([Sym (Foreign.C.Types.N:CWchar[0])])_R
               :: (Int32 -> Int32 -> [Int32] :: *)
                  ~R# (CWchar -> CWchar -> [CWchar] :: *)))
      (GHC.Int.$fEnumInt32_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R ([Sym (Foreign.C.Types.N:CWchar[0])])_R
               :: (Int32 -> Int32 -> [Int32] :: *)
                  ~R# (CWchar -> CWchar -> [CWchar] :: *)))
      (GHC.Int.$fEnumInt32_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R ([Sym (Foreign.C.Types.N:CWchar[0])])_R
               :: (Int32 -> Int32 -> Int32 -> [Int32] :: *)
                  ~R# (CWchar -> CWchar -> CWchar -> [CWchar] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCWchar [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CWchar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CWchar
                     GHC.Int.$fNumInt32_$c+
                     `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                             ->_R Sym (Foreign.C.Types.N:CWchar[0])
                             ->_R Sym (Foreign.C.Types.N:CWchar[0])
                             :: (Int32 -> Int32 -> Int32 :: *)
                                ~R# (CWchar -> CWchar -> CWchar :: *))
                     GHC.Int.$fNumInt32_$c-
                     `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                             ->_R Sym (Foreign.C.Types.N:CWchar[0])
                             ->_R Sym (Foreign.C.Types.N:CWchar[0])
                             :: (Int32 -> Int32 -> Int32 :: *)
                                ~R# (CWchar -> CWchar -> CWchar :: *))
                     GHC.Int.$fNumInt32_$c*
                     `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                             ->_R Sym (Foreign.C.Types.N:CWchar[0])
                             ->_R Sym (Foreign.C.Types.N:CWchar[0])
                             :: (Int32 -> Int32 -> Int32 :: *)
                                ~R# (CWchar -> CWchar -> CWchar :: *))
                     GHC.Int.$fNumInt32_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                             ->_R Sym (Foreign.C.Types.N:CWchar[0])
                             :: (Int32 -> Int32 :: *) ~R# (CWchar -> CWchar :: *))
                     GHC.Int.$fNumInt32_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                             ->_R Sym (Foreign.C.Types.N:CWchar[0])
                             :: (Int32 -> Int32 :: *) ~R# (CWchar -> CWchar :: *))
                     GHC.Int.$fNumInt32_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                             ->_R Sym (Foreign.C.Types.N:CWchar[0])
                             :: (Int32 -> Int32 :: *) ~R# (CWchar -> CWchar :: *))
                     GHC.Int.$fNumInt32_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CWchar[0])
                             :: (Integer -> Int32 :: *) ~R# (Integer -> CWchar :: *))]
Foreign.C.Types.$fNumCWchar
  = GHC.Num.C:Num
      @ CWchar
      (GHC.Int.$fNumInt32_$c+
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CWchar -> CWchar -> CWchar :: *)))
      (GHC.Int.$fNumInt32_$c-
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CWchar -> CWchar -> CWchar :: *)))
      (GHC.Int.$fNumInt32_$c*
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CWchar -> CWchar -> CWchar :: *)))
      (GHC.Int.$fNumInt32_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int32 :: *) ~R# (CWchar -> CWchar :: *)))
      (GHC.Int.$fNumInt32_$cabs
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int32 :: *) ~R# (CWchar -> CWchar :: *)))
      (GHC.Int.$fNumInt32_$csignum
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int32 :: *) ~R# (CWchar -> CWchar :: *)))
      (GHC.Int.$fNumInt32_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Integer -> Int32 :: *) ~R# (Integer -> CWchar :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCWchar [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CWchar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CWchar
                        GHC.Int.eqInt32
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R <Bool>_R
                                :: (Int32 -> Int32 -> Bool :: *)
                                   ~R# (CWchar -> CWchar -> Bool :: *))
                        GHC.Int.neInt32
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R <Bool>_R
                                :: (Int32 -> Int32 -> Bool :: *)
                                   ~R# (CWchar -> CWchar -> Bool :: *))]
Foreign.C.Types.$fEqCWchar
  = GHC.Classes.C:Eq
      @ CWchar
      (GHC.Int.eqInt32
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R <Bool>_R
               :: (Int32 -> Int32 -> Bool :: *)
                  ~R# (CWchar -> CWchar -> Bool :: *)))
      (GHC.Int.neInt32
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R <Bool>_R
               :: (Int32 -> Int32 -> Bool :: *)
                  ~R# (CWchar -> CWchar -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCWchar [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CWchar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CWchar
                         Foreign.C.Types.$fEqCWchar
                         GHC.Int.$fOrdInt32_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                 ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                 ->_R <Ordering>_R
                                 :: (Int32 -> Int32 -> Ordering :: *)
                                    ~R# (CWchar -> CWchar -> Ordering :: *))
                         GHC.Int.ltInt32
                         `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                 ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                 ->_R <Bool>_R
                                 :: (Int32 -> Int32 -> Bool :: *)
                                    ~R# (CWchar -> CWchar -> Bool :: *))
                         GHC.Int.leInt32
                         `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                 ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                 ->_R <Bool>_R
                                 :: (Int32 -> Int32 -> Bool :: *)
                                    ~R# (CWchar -> CWchar -> Bool :: *))
                         GHC.Int.gtInt32
                         `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                 ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                 ->_R <Bool>_R
                                 :: (Int32 -> Int32 -> Bool :: *)
                                    ~R# (CWchar -> CWchar -> Bool :: *))
                         GHC.Int.geInt32
                         `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                 ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                 ->_R <Bool>_R
                                 :: (Int32 -> Int32 -> Bool :: *)
                                    ~R# (CWchar -> CWchar -> Bool :: *))
                         GHC.Int.$fOrdInt32_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                 ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                 ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                 :: (Int32 -> Int32 -> Int32 :: *)
                                    ~R# (CWchar -> CWchar -> CWchar :: *))
                         GHC.Int.$fOrdInt32_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                 ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                 ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                 :: (Int32 -> Int32 -> Int32 :: *)
                                    ~R# (CWchar -> CWchar -> CWchar :: *))]
Foreign.C.Types.$fOrdCWchar
  = GHC.Classes.C:Ord
      @ CWchar
      Foreign.C.Types.$fEqCWchar
      (GHC.Int.$fOrdInt32_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R <Ordering>_R
               :: (Int32 -> Int32 -> Ordering :: *)
                  ~R# (CWchar -> CWchar -> Ordering :: *)))
      (GHC.Int.ltInt32
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R <Bool>_R
               :: (Int32 -> Int32 -> Bool :: *)
                  ~R# (CWchar -> CWchar -> Bool :: *)))
      (GHC.Int.leInt32
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R <Bool>_R
               :: (Int32 -> Int32 -> Bool :: *)
                  ~R# (CWchar -> CWchar -> Bool :: *)))
      (GHC.Int.gtInt32
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R <Bool>_R
               :: (Int32 -> Int32 -> Bool :: *)
                  ~R# (CWchar -> CWchar -> Bool :: *)))
      (GHC.Int.geInt32
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R <Bool>_R
               :: (Int32 -> Int32 -> Bool :: *)
                  ~R# (CWchar -> CWchar -> Bool :: *)))
      (GHC.Int.$fOrdInt32_$cmax
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CWchar -> CWchar -> CWchar :: *)))
      (GHC.Int.$fOrdInt32_$cmin
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CWchar -> CWchar -> CWchar :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCWchar [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CWchar
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CWchar
                       Foreign.C.Types.$fNumCWchar
                       Foreign.C.Types.$fOrdCWchar
                       GHC.Int.$fRealInt32_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Ratio Integer>_R
                               :: (Int32 -> Ratio Integer :: *)
                                  ~R# (CWchar -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCWchar
  = GHC.Real.C:Real
      @ CWchar
      Foreign.C.Types.$fNumCWchar
      Foreign.C.Types.$fOrdCWchar
      (GHC.Int.$fRealInt32_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Ratio Integer>_R
               :: (Int32 -> Ratio Integer :: *)
                  ~R# (CWchar -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.C.Types.$fIntegralCWchar [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral CWchar
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: CWchar
                           Foreign.C.Types.$fRealCWchar
                           Foreign.C.Types.$fEnumCWchar
                           GHC.Int.$fIntegralInt32_$cquot
                           `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                   ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                   ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                   :: (Int32 -> Int32 -> Int32 :: *)
                                      ~R# (CWchar -> CWchar -> CWchar :: *))
                           GHC.Int.$fIntegralInt32_$crem
                           `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                   ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                   ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                   :: (Int32 -> Int32 -> Int32 :: *)
                                      ~R# (CWchar -> CWchar -> CWchar :: *))
                           GHC.Int.$fIntegralInt32_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                   ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                   ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                   :: (Int32 -> Int32 -> Int32 :: *)
                                      ~R# (CWchar -> CWchar -> CWchar :: *))
                           GHC.Int.$fIntegralInt32_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                   ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                   ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                   :: (Int32 -> Int32 -> Int32 :: *)
                                      ~R# (CWchar -> CWchar -> CWchar :: *))
                           GHC.Int.$fIntegralInt32_$cquotRem
                           `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                   ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CWchar[0]))
                                           (Sym (Foreign.C.Types.N:CWchar[0])))_R
                                   :: (Int32 -> Int32 -> (Int32, Int32) :: *)
                                      ~R# (CWchar -> CWchar -> (CWchar, CWchar) :: *))
                           GHC.Int.$fIntegralInt32_$cdivMod
                           `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                   ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CWchar[0]))
                                           (Sym (Foreign.C.Types.N:CWchar[0])))_R
                                   :: (Int32 -> Int32 -> (Int32, Int32) :: *)
                                      ~R# (CWchar -> CWchar -> (CWchar, CWchar) :: *))
                           GHC.Int.$fIntegralInt32_$ctoInteger
                           `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Integer>_R
                                   :: (Int32 -> Integer :: *) ~R# (CWchar -> Integer :: *))]
Foreign.C.Types.$fIntegralCWchar
  = GHC.Real.C:Integral
      @ CWchar
      Foreign.C.Types.$fRealCWchar
      Foreign.C.Types.$fEnumCWchar
      (GHC.Int.$fIntegralInt32_$cquot
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CWchar -> CWchar -> CWchar :: *)))
      (GHC.Int.$fIntegralInt32_$crem
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CWchar -> CWchar -> CWchar :: *)))
      (GHC.Int.$fIntegralInt32_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CWchar -> CWchar -> CWchar :: *)))
      (GHC.Int.$fIntegralInt32_$cmod
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CWchar -> CWchar -> CWchar :: *)))
      (GHC.Int.$fIntegralInt32_$cquotRem
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CWchar[0]))
                       (Sym (Foreign.C.Types.N:CWchar[0])))_R
               :: (Int32 -> Int32 -> (Int32, Int32) :: *)
                  ~R# (CWchar -> CWchar -> (CWchar, CWchar) :: *)))
      (GHC.Int.$fIntegralInt32_$cdivMod
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CWchar[0]))
                       (Sym (Foreign.C.Types.N:CWchar[0])))_R
               :: (Int32 -> Int32 -> (Int32, Int32) :: *)
                  ~R# (CWchar -> CWchar -> (CWchar, CWchar) :: *)))
      (GHC.Int.$fIntegralInt32_$ctoInteger
       `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Integer>_R
               :: (Int32 -> Integer :: *) ~R# (CWchar -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.C.Types.$fBitsCWchar [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits CWchar
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: CWchar
                        Foreign.C.Types.$fEqCWchar
                        GHC.Int.$fBitsInt32_$c.&.
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                :: (Int32 -> Int32 -> Int32 :: *)
                                   ~R# (CWchar -> CWchar -> CWchar :: *))
                        GHC.Int.$fBitsInt32_$c.|.
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                :: (Int32 -> Int32 -> Int32 :: *)
                                   ~R# (CWchar -> CWchar -> CWchar :: *))
                        GHC.Int.$fBitsInt32_$cxor
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                :: (Int32 -> Int32 -> Int32 :: *)
                                   ~R# (CWchar -> CWchar -> CWchar :: *))
                        GHC.Int.$fBitsInt32_$ccomplement
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                :: (Int32 -> Int32 :: *) ~R# (CWchar -> CWchar :: *))
                        GHC.Int.$fBitsInt32_$cshift
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CWchar -> Int -> CWchar :: *))
                        GHC.Int.$fBitsInt32_$crotate
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CWchar -> Int -> CWchar :: *))
                        GHC.Int.$fBitsInt6
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                :: (Int32 :: *) ~R# (CWchar :: *))
                        GHC.Int.$fBitsInt32_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                :: (Int -> Int32 :: *) ~R# (Int -> CWchar :: *))
                        GHC.Int.$fBitsInt32_$csetBit
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CWchar -> Int -> CWchar :: *))
                        GHC.Int.$fBitsInt32_$cclearBit
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CWchar -> Int -> CWchar :: *))
                        GHC.Int.$fBitsInt32_$ccomplementBit
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CWchar -> Int -> CWchar :: *))
                        GHC.Int.$fBitsInt32_$ctestBit
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Int -> Bool>_R
                                :: (Int32 -> Int -> Bool :: *) ~R# (CWchar -> Int -> Bool :: *))
                        GHC.Int.$fBitsInt32_$cbitSizeMaybe
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Maybe Int>_R
                                :: (Int32 -> Maybe Int :: *) ~R# (CWchar -> Maybe Int :: *))
                        GHC.Int.$fBitsInt32_$cfiniteBitSize
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Int>_R
                                :: (Int32 -> Int :: *) ~R# (CWchar -> Int :: *))
                        GHC.Int.$fBitsInt32_$cisSigned
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Bool>_R
                                :: (Int32 -> Bool :: *) ~R# (CWchar -> Bool :: *))
                        GHC.Int.$fBitsInt32_$cshiftL
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CWchar -> Int -> CWchar :: *))
                        GHC.Int.$fBitsInt32_$cunsafeShiftL
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CWchar -> Int -> CWchar :: *))
                        GHC.Int.$fBitsInt32_$cshiftR
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CWchar -> Int -> CWchar :: *))
                        GHC.Int.$fBitsInt32_$cunsafeShiftR
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CWchar -> Int -> CWchar :: *))
                        GHC.Int.$fBitsInt32_$crotateL
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CWchar -> Int -> CWchar :: *))
                        GHC.Int.$fBitsInt32_$crotateR
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CWchar[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CWchar -> Int -> CWchar :: *))
                        GHC.Int.$fBitsInt32_$cpopCount
                        `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Int>_R
                                :: (Int32 -> Int :: *) ~R# (CWchar -> Int :: *))]
Foreign.C.Types.$fBitsCWchar
  = Data.Bits.C:Bits
      @ CWchar
      Foreign.C.Types.$fEqCWchar
      (GHC.Int.$fBitsInt32_$c.&.
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CWchar -> CWchar -> CWchar :: *)))
      (GHC.Int.$fBitsInt32_$c.|.
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CWchar -> CWchar -> CWchar :: *)))
      (GHC.Int.$fBitsInt32_$cxor
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int32 -> Int32 :: *)
                  ~R# (CWchar -> CWchar -> CWchar :: *)))
      (GHC.Int.$fBitsInt32_$ccomplement
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int32 :: *) ~R# (CWchar -> CWchar :: *)))
      (GHC.Int.$fBitsInt32_$cshift
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CWchar -> Int -> CWchar :: *)))
      (GHC.Int.$fBitsInt32_$crotate
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CWchar -> Int -> CWchar :: *)))
      (GHC.Int.$fBitsInt6
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 :: *) ~R# (CWchar :: *)))
      (GHC.Int.$fBitsInt32_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int -> Int32 :: *) ~R# (Int -> CWchar :: *)))
      (GHC.Int.$fBitsInt32_$csetBit
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CWchar -> Int -> CWchar :: *)))
      (GHC.Int.$fBitsInt32_$cclearBit
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CWchar -> Int -> CWchar :: *)))
      (GHC.Int.$fBitsInt32_$ccomplementBit
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CWchar -> Int -> CWchar :: *)))
      (GHC.Int.$fBitsInt32_$ctestBit
       `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Int -> Bool>_R
               :: (Int32 -> Int -> Bool :: *) ~R# (CWchar -> Int -> Bool :: *)))
      (GHC.Int.$fBitsInt32_$cbitSizeMaybe
       `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Maybe Int>_R
               :: (Int32 -> Maybe Int :: *) ~R# (CWchar -> Maybe Int :: *)))
      (GHC.Int.$fBitsInt32_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CWchar -> Int :: *)))
      (GHC.Int.$fBitsInt32_$cisSigned
       `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Bool>_R
               :: (Int32 -> Bool :: *) ~R# (CWchar -> Bool :: *)))
      (GHC.Int.$fBitsInt32_$cshiftL
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CWchar -> Int -> CWchar :: *)))
      (GHC.Int.$fBitsInt32_$cunsafeShiftL
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CWchar -> Int -> CWchar :: *)))
      (GHC.Int.$fBitsInt32_$cshiftR
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CWchar -> Int -> CWchar :: *)))
      (GHC.Int.$fBitsInt32_$cunsafeShiftR
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CWchar -> Int -> CWchar :: *)))
      (GHC.Int.$fBitsInt32_$crotateL
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CWchar -> Int -> CWchar :: *)))
      (GHC.Int.$fBitsInt32_$crotateR
       `cast` (Sym (Foreign.C.Types.N:CWchar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CWchar[0])
               :: (Int32 -> Int -> Int32 :: *)
                  ~R# (CWchar -> Int -> CWchar :: *)))
      (GHC.Int.$fBitsInt32_$cpopCount
       `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CWchar -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.C.Types.$fFiniteBitsCWchar [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits CWchar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: CWchar
                              Foreign.C.Types.$fBitsCWchar
                              GHC.Int.$fBitsInt32_$cfiniteBitSize
                              `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Int>_R
                                      :: (Int32 -> Int :: *) ~R# (CWchar -> Int :: *))
                              GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros
                              `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Int>_R
                                      :: (Int32 -> Int :: *) ~R# (CWchar -> Int :: *))
                              GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros
                              `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Int>_R
                                      :: (Int32 -> Int :: *) ~R# (CWchar -> Int :: *))]
Foreign.C.Types.$fFiniteBitsCWchar
  = Data.Bits.C:FiniteBits
      @ CWchar
      Foreign.C.Types.$fBitsCWchar
      (GHC.Int.$fBitsInt32_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CWchar -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros
       `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CWchar -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros
       `cast` (Sym (Foreign.C.Types.N:CWchar[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CWchar -> Int :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCSize [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CSize
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CSize
                       GHC.Word.$fShowWord64_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CSize[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Word64 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CSize -> [Char] -> [Char] :: *))
                       GHC.Word.$fShowWord64_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <[Char]>_R
                               :: (Word64 -> [Char] :: *) ~R# (CSize -> [Char] :: *))
                       GHC.Word.$fShowWord64_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CSize[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Word64] -> [Char] -> [Char] :: *)
                                  ~R# ([CSize] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCSize
  = GHC.Show.C:Show
      @ CSize
      (GHC.Word.$fShowWord64_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Word64 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CSize -> [Char] -> [Char] :: *)))
      (GHC.Word.$fShowWord64_$cshow
       `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <[Char]>_R
               :: (Word64 -> [Char] :: *) ~R# (CSize -> [Char] :: *)))
      (GHC.Word.$fShowWord64_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CSize[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Word64] -> [Char] -> [Char] :: *)
                  ~R# ([CSize] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCSize [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CSize
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CSize
                       GHC.Read.$fReadWord64_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CSize[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Word64, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CSize, [Char])] :: *))
                       GHC.Read.$fReadWord64_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CSize[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Word64], [Char])] :: *)
                                  ~R# ([Char] -> [([CSize], [Char])] :: *))
                       GHC.Read.$fReadWord13
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Word64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      (Foreign.C.Types.N:CSize[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Word64 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CSize :: *))
                       GHC.Read.$fReadWord11
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Word64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                        ([Foreign.C.Types.N:CSize[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Word64] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CSize] :: *))]
Foreign.C.Types.$fReadCSize
  = GHC.Read.C:Read
      @ CSize
      (GHC.Read.$fReadWord64_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CSize[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Word64, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CSize, [Char])] :: *)))
      (GHC.Read.$fReadWord64_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CSize[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Word64], [Char])] :: *)
                  ~R# ([Char] -> [([CSize], [Char])] :: *)))
      (GHC.Read.$fReadWord13
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Word64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                      (Foreign.C.Types.N:CSize[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Word64 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CSize :: *)))
      (GHC.Read.$fReadWord11
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Word64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        ([Foreign.C.Types.N:CSize[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Word64] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CSize] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.C.Types.$fBoundedCSize [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded CSize
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: CSize
                          GHC.Word.$fBitsWord7
                          `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                  :: (Word64 :: *) ~R# (CSize :: *))
                          GHC.Word.$fBoundedWord64_$cmaxBound
                          `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                  :: (Word64 :: *) ~R# (CSize :: *))]
Foreign.C.Types.$fBoundedCSize
  = GHC.Enum.C:Bounded
      @ CSize
      (GHC.Word.$fBitsWord7
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 :: *) ~R# (CSize :: *)))
      (GHC.Word.$fBoundedWord64_$cmaxBound
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 :: *) ~R# (CSize :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCSize [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CSize
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CSize
                                   Foreign.Storable.$fStorableWord64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Int>_R
                                           :: (Word64 -> Int :: *) ~R# (CSize -> Int :: *))
                                   Foreign.Storable.$fStorableWord64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Int>_R
                                           :: (Word64 -> Int :: *) ~R# (CSize -> Int :: *))
                                   GHC.Storable.readWord64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word64, CSize))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CSize[0]))
                                           :: (GHC.Ptr.Ptr Word64
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CSize -> Int -> IO CSize :: *))
                                   GHC.Storable.writeWord64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word64, CSize))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CSize[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Word64
                                               -> Int
                                               -> Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CSize -> Int -> CSize -> IO () :: *))
                                   Foreign.Storable.$fStorableWord18
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CSize[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word64 #) :: *)
                                              ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CSize :: *))
                                   Foreign.Storable.$fStorableWord17
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CSize[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CSize -> IO () :: *))
                                   Foreign.Storable.$fStorableWord15
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word64, CSize))_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CSize[0]))
                                           :: (GHC.Ptr.Ptr Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CSize -> IO CSize :: *))
                                   Foreign.Storable.$fStorableWord14
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word64, CSize))_R
                                           ->_R Sym (Foreign.C.Types.N:CSize[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Word64
                                               -> Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CSize -> CSize -> IO () :: *))]
Foreign.C.Types.$fStorableCSize
  = Foreign.Storable.C:Storable
      @ CSize
      (Foreign.Storable.$fStorableWord64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CSize -> Int :: *)))
      (Foreign.Storable.$fStorableWord64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CSize -> Int :: *)))
      (GHC.Storable.readWord64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word64, CSize))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CSize[0]))
               :: (GHC.Ptr.Ptr Word64
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CSize -> Int -> IO CSize :: *)))
      (GHC.Storable.writeWord64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word64, CSize))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Word64
                   -> Int
                   -> Word64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CSize -> Int -> CSize -> IO () :: *)))
      (Foreign.Storable.$fStorableWord18
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CSize[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word64 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CSize :: *)))
      (Foreign.Storable.$fStorableWord17
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Word64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CSize -> IO () :: *)))
      (Foreign.Storable.$fStorableWord15
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word64, CSize))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CSize[0]))
               :: (GHC.Ptr.Ptr Word64
                   -> State# RealWorld -> (# State# RealWorld, Word64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CSize -> IO CSize :: *)))
      (Foreign.Storable.$fStorableWord14
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word64, CSize))_R
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Word64
                   -> Word64 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CSize -> CSize -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCSize [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CSize
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CSize
                       GHC.Word.$fEnumWord64_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CSize[0])
                               ->_R Sym (Foreign.C.Types.N:CSize[0])
                               :: (Word64 -> Word64 :: *) ~R# (CSize -> CSize :: *))
                       GHC.Word.$fEnumWord64_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CSize[0])
                               ->_R Sym (Foreign.C.Types.N:CSize[0])
                               :: (Word64 -> Word64 :: *) ~R# (CSize -> CSize :: *))
                       GHC.Word.$fEnumWord64_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CSize[0])
                               :: (Int -> Word64 :: *) ~R# (Int -> CSize :: *))
                       GHC.Word.$fEnumWord64_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Int>_R
                               :: (Word64 -> Int :: *) ~R# (CSize -> Int :: *))
                       GHC.Word.$fEnumWord64_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CSize[0])
                               ->_R ([Sym (Foreign.C.Types.N:CSize[0])])_R
                               :: (Word64 -> [Word64] :: *) ~R# (CSize -> [CSize] :: *))
                       GHC.Word.$fEnumWord64_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CSize[0])
                               ->_R Sym (Foreign.C.Types.N:CSize[0])
                               ->_R ([Sym (Foreign.C.Types.N:CSize[0])])_R
                               :: (Word64 -> Word64 -> [Word64] :: *)
                                  ~R# (CSize -> CSize -> [CSize] :: *))
                       GHC.Word.$fEnumWord64_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CSize[0])
                               ->_R Sym (Foreign.C.Types.N:CSize[0])
                               ->_R ([Sym (Foreign.C.Types.N:CSize[0])])_R
                               :: (Word64 -> Word64 -> [Word64] :: *)
                                  ~R# (CSize -> CSize -> [CSize] :: *))
                       GHC.Word.$fEnumWord64_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CSize[0])
                               ->_R Sym (Foreign.C.Types.N:CSize[0])
                               ->_R Sym (Foreign.C.Types.N:CSize[0])
                               ->_R ([Sym (Foreign.C.Types.N:CSize[0])])_R
                               :: (Word64 -> Word64 -> Word64 -> [Word64] :: *)
                                  ~R# (CSize -> CSize -> CSize -> [CSize] :: *))]
Foreign.C.Types.$fEnumCSize
  = GHC.Enum.C:Enum
      @ CSize
      (GHC.Word.$fEnumWord64_$csucc
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Word64 :: *) ~R# (CSize -> CSize :: *)))
      (GHC.Word.$fEnumWord64_$cpred
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Word64 :: *) ~R# (CSize -> CSize :: *)))
      (GHC.Word.$fEnumWord64_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Int -> Word64 :: *) ~R# (Int -> CSize :: *)))
      (GHC.Word.$fEnumWord64_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CSize -> Int :: *)))
      (GHC.Word.$fEnumWord64_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R ([Sym (Foreign.C.Types.N:CSize[0])])_R
               :: (Word64 -> [Word64] :: *) ~R# (CSize -> [CSize] :: *)))
      (GHC.Word.$fEnumWord64_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R ([Sym (Foreign.C.Types.N:CSize[0])])_R
               :: (Word64 -> Word64 -> [Word64] :: *)
                  ~R# (CSize -> CSize -> [CSize] :: *)))
      (GHC.Word.$fEnumWord64_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R ([Sym (Foreign.C.Types.N:CSize[0])])_R
               :: (Word64 -> Word64 -> [Word64] :: *)
                  ~R# (CSize -> CSize -> [CSize] :: *)))
      (GHC.Word.$fEnumWord64_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R ([Sym (Foreign.C.Types.N:CSize[0])])_R
               :: (Word64 -> Word64 -> Word64 -> [Word64] :: *)
                  ~R# (CSize -> CSize -> CSize -> [CSize] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCSize [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CSize
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CSize
                     GHC.Word.$fNumWord64_$c+
                     `cast` (Sym (Foreign.C.Types.N:CSize[0])
                             ->_R Sym (Foreign.C.Types.N:CSize[0])
                             ->_R Sym (Foreign.C.Types.N:CSize[0])
                             :: (Word64 -> Word64 -> Word64 :: *)
                                ~R# (CSize -> CSize -> CSize :: *))
                     GHC.Word.$fNumWord64_$c-
                     `cast` (Sym (Foreign.C.Types.N:CSize[0])
                             ->_R Sym (Foreign.C.Types.N:CSize[0])
                             ->_R Sym (Foreign.C.Types.N:CSize[0])
                             :: (Word64 -> Word64 -> Word64 :: *)
                                ~R# (CSize -> CSize -> CSize :: *))
                     GHC.Word.$fNumWord64_$c*
                     `cast` (Sym (Foreign.C.Types.N:CSize[0])
                             ->_R Sym (Foreign.C.Types.N:CSize[0])
                             ->_R Sym (Foreign.C.Types.N:CSize[0])
                             :: (Word64 -> Word64 -> Word64 :: *)
                                ~R# (CSize -> CSize -> CSize :: *))
                     GHC.Word.$fNumWord64_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CSize[0])
                             ->_R Sym (Foreign.C.Types.N:CSize[0])
                             :: (Word64 -> Word64 :: *) ~R# (CSize -> CSize :: *))
                     GHC.Word.$fNumWord64_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CSize[0])
                             ->_R Sym (Foreign.C.Types.N:CSize[0])
                             :: (Word64 -> Word64 :: *) ~R# (CSize -> CSize :: *))
                     GHC.Word.$fNumWord64_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CSize[0])
                             ->_R Sym (Foreign.C.Types.N:CSize[0])
                             :: (Word64 -> Word64 :: *) ~R# (CSize -> CSize :: *))
                     GHC.Word.$fNumWord64_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CSize[0])
                             :: (Integer -> Word64 :: *) ~R# (Integer -> CSize :: *))]
Foreign.C.Types.$fNumCSize
  = GHC.Num.C:Num
      @ CSize
      (GHC.Word.$fNumWord64_$c+
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CSize -> CSize -> CSize :: *)))
      (GHC.Word.$fNumWord64_$c-
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CSize -> CSize -> CSize :: *)))
      (GHC.Word.$fNumWord64_$c*
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CSize -> CSize -> CSize :: *)))
      (GHC.Word.$fNumWord64_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Word64 :: *) ~R# (CSize -> CSize :: *)))
      (GHC.Word.$fNumWord64_$cabs
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Word64 :: *) ~R# (CSize -> CSize :: *)))
      (GHC.Word.$fNumWord64_$csignum
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Word64 :: *) ~R# (CSize -> CSize :: *)))
      (GHC.Word.$fNumWord64_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Integer -> Word64 :: *) ~R# (Integer -> CSize :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCSize [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CSize
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CSize
                        GHC.Word.eqWord64
                        `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                ->_R Sym (Foreign.C.Types.N:CSize[0])
                                ->_R <Bool>_R
                                :: (Word64 -> Word64 -> Bool :: *)
                                   ~R# (CSize -> CSize -> Bool :: *))
                        GHC.Word.neWord64
                        `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                ->_R Sym (Foreign.C.Types.N:CSize[0])
                                ->_R <Bool>_R
                                :: (Word64 -> Word64 -> Bool :: *)
                                   ~R# (CSize -> CSize -> Bool :: *))]
Foreign.C.Types.$fEqCSize
  = GHC.Classes.C:Eq
      @ CSize
      (GHC.Word.eqWord64
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CSize -> CSize -> Bool :: *)))
      (GHC.Word.neWord64
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CSize -> CSize -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCSize [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CSize
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CSize
                         Foreign.C.Types.$fEqCSize
                         GHC.Word.$fOrdWord64_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                 ->_R Sym (Foreign.C.Types.N:CSize[0])
                                 ->_R <Ordering>_R
                                 :: (Word64 -> Word64 -> Ordering :: *)
                                    ~R# (CSize -> CSize -> Ordering :: *))
                         GHC.Word.ltWord64
                         `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                 ->_R Sym (Foreign.C.Types.N:CSize[0])
                                 ->_R <Bool>_R
                                 :: (Word64 -> Word64 -> Bool :: *)
                                    ~R# (CSize -> CSize -> Bool :: *))
                         GHC.Word.leWord64
                         `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                 ->_R Sym (Foreign.C.Types.N:CSize[0])
                                 ->_R <Bool>_R
                                 :: (Word64 -> Word64 -> Bool :: *)
                                    ~R# (CSize -> CSize -> Bool :: *))
                         GHC.Word.gtWord64
                         `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                 ->_R Sym (Foreign.C.Types.N:CSize[0])
                                 ->_R <Bool>_R
                                 :: (Word64 -> Word64 -> Bool :: *)
                                    ~R# (CSize -> CSize -> Bool :: *))
                         GHC.Word.geWord64
                         `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                 ->_R Sym (Foreign.C.Types.N:CSize[0])
                                 ->_R <Bool>_R
                                 :: (Word64 -> Word64 -> Bool :: *)
                                    ~R# (CSize -> CSize -> Bool :: *))
                         GHC.Word.$fOrdWord64_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                 ->_R Sym (Foreign.C.Types.N:CSize[0])
                                 ->_R Sym (Foreign.C.Types.N:CSize[0])
                                 :: (Word64 -> Word64 -> Word64 :: *)
                                    ~R# (CSize -> CSize -> CSize :: *))
                         GHC.Word.$fOrdWord64_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                 ->_R Sym (Foreign.C.Types.N:CSize[0])
                                 ->_R Sym (Foreign.C.Types.N:CSize[0])
                                 :: (Word64 -> Word64 -> Word64 :: *)
                                    ~R# (CSize -> CSize -> CSize :: *))]
Foreign.C.Types.$fOrdCSize
  = GHC.Classes.C:Ord
      @ CSize
      Foreign.C.Types.$fEqCSize
      (GHC.Word.$fOrdWord64_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R <Ordering>_R
               :: (Word64 -> Word64 -> Ordering :: *)
                  ~R# (CSize -> CSize -> Ordering :: *)))
      (GHC.Word.ltWord64
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CSize -> CSize -> Bool :: *)))
      (GHC.Word.leWord64
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CSize -> CSize -> Bool :: *)))
      (GHC.Word.gtWord64
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CSize -> CSize -> Bool :: *)))
      (GHC.Word.geWord64
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CSize -> CSize -> Bool :: *)))
      (GHC.Word.$fOrdWord64_$cmax
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CSize -> CSize -> CSize :: *)))
      (GHC.Word.$fOrdWord64_$cmin
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CSize -> CSize -> CSize :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCSize [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CSize
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CSize
                       Foreign.C.Types.$fNumCSize
                       Foreign.C.Types.$fOrdCSize
                       GHC.Word.$fRealWord64_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Ratio Integer>_R
                               :: (Word64 -> Ratio Integer :: *)
                                  ~R# (CSize -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCSize
  = GHC.Real.C:Real
      @ CSize
      Foreign.C.Types.$fNumCSize
      Foreign.C.Types.$fOrdCSize
      (GHC.Word.$fRealWord64_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Ratio Integer>_R
               :: (Word64 -> Ratio Integer :: *)
                  ~R# (CSize -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.C.Types.$fIntegralCSize [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral CSize
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: CSize
                           Foreign.C.Types.$fRealCSize
                           Foreign.C.Types.$fEnumCSize
                           GHC.Word.$fIntegralWord64_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                   ->_R Sym (Foreign.C.Types.N:CSize[0])
                                   ->_R Sym (Foreign.C.Types.N:CSize[0])
                                   :: (Word64 -> Word64 -> Word64 :: *)
                                      ~R# (CSize -> CSize -> CSize :: *))
                           GHC.Word.$fIntegralWord64_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                   ->_R Sym (Foreign.C.Types.N:CSize[0])
                                   ->_R Sym (Foreign.C.Types.N:CSize[0])
                                   :: (Word64 -> Word64 -> Word64 :: *)
                                      ~R# (CSize -> CSize -> CSize :: *))
                           GHC.Word.$fIntegralWord64_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                   ->_R Sym (Foreign.C.Types.N:CSize[0])
                                   ->_R Sym (Foreign.C.Types.N:CSize[0])
                                   :: (Word64 -> Word64 -> Word64 :: *)
                                      ~R# (CSize -> CSize -> CSize :: *))
                           GHC.Word.$fIntegralWord64_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                   ->_R Sym (Foreign.C.Types.N:CSize[0])
                                   ->_R Sym (Foreign.C.Types.N:CSize[0])
                                   :: (Word64 -> Word64 -> Word64 :: *)
                                      ~R# (CSize -> CSize -> CSize :: *))
                           GHC.Word.$fIntegralWord64_$cquotRem
                           `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                   ->_R Sym (Foreign.C.Types.N:CSize[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CSize[0]))
                                           (Sym (Foreign.C.Types.N:CSize[0])))_R
                                   :: (Word64 -> Word64 -> (Word64, Word64) :: *)
                                      ~R# (CSize -> CSize -> (CSize, CSize) :: *))
                           GHC.Word.$fIntegralWord64_$cdivMod
                           `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                   ->_R Sym (Foreign.C.Types.N:CSize[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CSize[0]))
                                           (Sym (Foreign.C.Types.N:CSize[0])))_R
                                   :: (Word64 -> Word64 -> (Word64, Word64) :: *)
                                      ~R# (CSize -> CSize -> (CSize, CSize) :: *))
                           GHC.Word.$fIntegralWord64_$ctoInteger
                           `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Integer>_R
                                   :: (Word64 -> Integer :: *) ~R# (CSize -> Integer :: *))]
Foreign.C.Types.$fIntegralCSize
  = GHC.Real.C:Integral
      @ CSize
      Foreign.C.Types.$fRealCSize
      Foreign.C.Types.$fEnumCSize
      (GHC.Word.$fIntegralWord64_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CSize -> CSize -> CSize :: *)))
      (GHC.Word.$fIntegralWord64_$cmod
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CSize -> CSize -> CSize :: *)))
      (GHC.Word.$fIntegralWord64_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CSize -> CSize -> CSize :: *)))
      (GHC.Word.$fIntegralWord64_$cmod
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CSize -> CSize -> CSize :: *)))
      (GHC.Word.$fIntegralWord64_$cquotRem
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CSize[0]))
                       (Sym (Foreign.C.Types.N:CSize[0])))_R
               :: (Word64 -> Word64 -> (Word64, Word64) :: *)
                  ~R# (CSize -> CSize -> (CSize, CSize) :: *)))
      (GHC.Word.$fIntegralWord64_$cdivMod
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CSize[0]))
                       (Sym (Foreign.C.Types.N:CSize[0])))_R
               :: (Word64 -> Word64 -> (Word64, Word64) :: *)
                  ~R# (CSize -> CSize -> (CSize, CSize) :: *)))
      (GHC.Word.$fIntegralWord64_$ctoInteger
       `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Integer>_R
               :: (Word64 -> Integer :: *) ~R# (CSize -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.C.Types.$fBitsCSize [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits CSize
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: CSize
                        Foreign.C.Types.$fEqCSize
                        GHC.Word.$fBitsWord64_$c.&.
                        `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                ->_R Sym (Foreign.C.Types.N:CSize[0])
                                ->_R Sym (Foreign.C.Types.N:CSize[0])
                                :: (Word64 -> Word64 -> Word64 :: *)
                                   ~R# (CSize -> CSize -> CSize :: *))
                        GHC.Word.$fBitsWord64_$c.|.
                        `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                ->_R Sym (Foreign.C.Types.N:CSize[0])
                                ->_R Sym (Foreign.C.Types.N:CSize[0])
                                :: (Word64 -> Word64 -> Word64 :: *)
                                   ~R# (CSize -> CSize -> CSize :: *))
                        GHC.Word.$fBitsWord64_$cxor
                        `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                ->_R Sym (Foreign.C.Types.N:CSize[0])
                                ->_R Sym (Foreign.C.Types.N:CSize[0])
                                :: (Word64 -> Word64 -> Word64 :: *)
                                   ~R# (CSize -> CSize -> CSize :: *))
                        GHC.Word.$fBitsWord64_$ccomplement
                        `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                ->_R Sym (Foreign.C.Types.N:CSize[0])
                                :: (Word64 -> Word64 :: *) ~R# (CSize -> CSize :: *))
                        GHC.Word.$fBitsWord64_$cshift
                        `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSize[0])
                                :: (Word64 -> Int -> Word64 :: *) ~R# (CSize -> Int -> CSize :: *))
                        GHC.Word.$fBitsWord64_$crotate
                        `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSize[0])
                                :: (Word64 -> Int -> Word64 :: *) ~R# (CSize -> Int -> CSize :: *))
                        GHC.Word.$fBitsWord7
                        `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                :: (Word64 :: *) ~R# (CSize :: *))
                        GHC.Word.$fBitsWord64_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CSize[0])
                                :: (Int -> Word64 :: *) ~R# (Int -> CSize :: *))
                        GHC.Word.$fBitsWord64_$csetBit
                        `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSize[0])
                                :: (Word64 -> Int -> Word64 :: *) ~R# (CSize -> Int -> CSize :: *))
                        GHC.Word.$fBitsWord64_$cclearBit
                        `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSize[0])
                                :: (Word64 -> Int -> Word64 :: *) ~R# (CSize -> Int -> CSize :: *))
                        GHC.Word.$fBitsWord64_$ccomplementBit
                        `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSize[0])
                                :: (Word64 -> Int -> Word64 :: *) ~R# (CSize -> Int -> CSize :: *))
                        GHC.Word.$fBitsWord64_$ctestBit
                        `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Int -> Bool>_R
                                :: (Word64 -> Int -> Bool :: *) ~R# (CSize -> Int -> Bool :: *))
                        GHC.Word.$fBitsWord64_$cbitSizeMaybe
                        `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Maybe Int>_R
                                :: (Word64 -> Maybe Int :: *) ~R# (CSize -> Maybe Int :: *))
                        GHC.Word.$fBitsWord64_$cfiniteBitSize
                        `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Int>_R
                                :: (Word64 -> Int :: *) ~R# (CSize -> Int :: *))
                        GHC.Word.$fBitsWord64_$cisSigned
                        `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Bool>_R
                                :: (Word64 -> Bool :: *) ~R# (CSize -> Bool :: *))
                        GHC.Word.$fBitsWord64_$cshiftL
                        `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSize[0])
                                :: (Word64 -> Int -> Word64 :: *) ~R# (CSize -> Int -> CSize :: *))
                        GHC.Word.$fBitsWord64_$cunsafeShiftL
                        `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSize[0])
                                :: (Word64 -> Int -> Word64 :: *) ~R# (CSize -> Int -> CSize :: *))
                        GHC.Word.$fBitsWord64_$cshiftR
                        `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSize[0])
                                :: (Word64 -> Int -> Word64 :: *) ~R# (CSize -> Int -> CSize :: *))
                        GHC.Word.$fBitsWord64_$cunsafeShiftR
                        `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSize[0])
                                :: (Word64 -> Int -> Word64 :: *) ~R# (CSize -> Int -> CSize :: *))
                        GHC.Word.$fBitsWord64_$crotateL
                        `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSize[0])
                                :: (Word64 -> Int -> Word64 :: *) ~R# (CSize -> Int -> CSize :: *))
                        GHC.Word.$fBitsWord64_$crotateR
                        `cast` (Sym (Foreign.C.Types.N:CSize[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSize[0])
                                :: (Word64 -> Int -> Word64 :: *) ~R# (CSize -> Int -> CSize :: *))
                        GHC.Word.$fBitsWord64_$cpopCount
                        `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Int>_R
                                :: (Word64 -> Int :: *) ~R# (CSize -> Int :: *))]
Foreign.C.Types.$fBitsCSize
  = Data.Bits.C:Bits
      @ CSize
      Foreign.C.Types.$fEqCSize
      (GHC.Word.$fBitsWord64_$c.&.
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CSize -> CSize -> CSize :: *)))
      (GHC.Word.$fBitsWord64_$c.|.
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CSize -> CSize -> CSize :: *)))
      (GHC.Word.$fBitsWord64_$cxor
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CSize -> CSize -> CSize :: *)))
      (GHC.Word.$fBitsWord64_$ccomplement
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Word64 :: *) ~R# (CSize -> CSize :: *)))
      (GHC.Word.$fBitsWord64_$cshift
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CSize -> Int -> CSize :: *)))
      (GHC.Word.$fBitsWord64_$crotate
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CSize -> Int -> CSize :: *)))
      (GHC.Word.$fBitsWord7
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 :: *) ~R# (CSize :: *)))
      (GHC.Word.$fBitsWord64_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Int -> Word64 :: *) ~R# (Int -> CSize :: *)))
      (GHC.Word.$fBitsWord64_$csetBit
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CSize -> Int -> CSize :: *)))
      (GHC.Word.$fBitsWord64_$cclearBit
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CSize -> Int -> CSize :: *)))
      (GHC.Word.$fBitsWord64_$ccomplementBit
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CSize -> Int -> CSize :: *)))
      (GHC.Word.$fBitsWord64_$ctestBit
       `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Int -> Bool>_R
               :: (Word64 -> Int -> Bool :: *) ~R# (CSize -> Int -> Bool :: *)))
      (GHC.Word.$fBitsWord64_$cbitSizeMaybe
       `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Maybe Int>_R
               :: (Word64 -> Maybe Int :: *) ~R# (CSize -> Maybe Int :: *)))
      (GHC.Word.$fBitsWord64_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CSize -> Int :: *)))
      (GHC.Word.$fBitsWord64_$cisSigned
       `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Bool>_R
               :: (Word64 -> Bool :: *) ~R# (CSize -> Bool :: *)))
      (GHC.Word.$fBitsWord64_$cshiftL
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CSize -> Int -> CSize :: *)))
      (GHC.Word.$fBitsWord64_$cunsafeShiftL
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CSize -> Int -> CSize :: *)))
      (GHC.Word.$fBitsWord64_$cshiftR
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CSize -> Int -> CSize :: *)))
      (GHC.Word.$fBitsWord64_$cunsafeShiftR
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CSize -> Int -> CSize :: *)))
      (GHC.Word.$fBitsWord64_$crotateL
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CSize -> Int -> CSize :: *)))
      (GHC.Word.$fBitsWord64_$crotateR
       `cast` (Sym (Foreign.C.Types.N:CSize[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSize[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CSize -> Int -> CSize :: *)))
      (GHC.Word.$fBitsWord64_$cpopCount
       `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CSize -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.C.Types.$fFiniteBitsCSize [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits CSize
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: CSize
                              Foreign.C.Types.$fBitsCSize
                              GHC.Word.$fBitsWord64_$cfiniteBitSize
                              `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Int>_R
                                      :: (Word64 -> Int :: *) ~R# (CSize -> Int :: *))
                              GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
                              `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Int>_R
                                      :: (Word64 -> Int :: *) ~R# (CSize -> Int :: *))
                              GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros
                              `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Int>_R
                                      :: (Word64 -> Int :: *) ~R# (CSize -> Int :: *))]
Foreign.C.Types.$fFiniteBitsCSize
  = Data.Bits.C:FiniteBits
      @ CSize
      Foreign.C.Types.$fBitsCSize
      (GHC.Word.$fBitsWord64_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CSize -> Int :: *)))
      (GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
       `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CSize -> Int :: *)))
      (GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros
       `cast` (Sym (Foreign.C.Types.N:CSize[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CSize -> Int :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCPtrdiff [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CPtrdiff
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CPtrdiff
                       GHC.Int.$fShowInt64_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Int64 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CPtrdiff -> [Char] -> [Char] :: *))
                       GHC.Int.$fShowInt64_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <[Char]>_R
                               :: (Int64 -> [Char] :: *) ~R# (CPtrdiff -> [Char] :: *))
                       GHC.Int.$fShowInt64_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CPtrdiff[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Int64] -> [Char] -> [Char] :: *)
                                  ~R# ([CPtrdiff] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCPtrdiff
  = GHC.Show.C:Show
      @ CPtrdiff
      (GHC.Int.$fShowInt64_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Int64 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CPtrdiff -> [Char] -> [Char] :: *)))
      (GHC.Int.$fShowInt64_$cshow
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <[Char]>_R
               :: (Int64 -> [Char] :: *) ~R# (CPtrdiff -> [Char] :: *)))
      (GHC.Int.$fShowInt64_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CPtrdiff[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Int64] -> [Char] -> [Char] :: *)
                  ~R# ([CPtrdiff] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCPtrdiff [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CPtrdiff
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CPtrdiff
                       GHC.Int.$fReadInt64_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CPtrdiff[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Int64, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CPtrdiff, [Char])] :: *))
                       GHC.Int.$fReadInt64_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CPtrdiff[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Int64], [Char])] :: *)
                                  ~R# ([Char] -> [([CPtrdiff], [Char])] :: *))
                       GHC.Int.$fReadInt10
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Int64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     (Foreign.C.Types.N:CPtrdiff[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Int64 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CPtrdiff :: *))
                       GHC.Int.$fReadInt7
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Int64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       ([Foreign.C.Types.N:CPtrdiff[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Int64] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CPtrdiff] :: *))]
Foreign.C.Types.$fReadCPtrdiff
  = GHC.Read.C:Read
      @ CPtrdiff
      (GHC.Int.$fReadInt64_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CPtrdiff[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Int64, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CPtrdiff, [Char])] :: *)))
      (GHC.Int.$fReadInt64_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CPtrdiff[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Int64], [Char])] :: *)
                  ~R# ([Char] -> [([CPtrdiff], [Char])] :: *)))
      (GHC.Int.$fReadInt10
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Int64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                     (Foreign.C.Types.N:CPtrdiff[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Int64 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CPtrdiff :: *)))
      (GHC.Int.$fReadInt7
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Int64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       ([Foreign.C.Types.N:CPtrdiff[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Int64] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CPtrdiff] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.C.Types.$fBoundedCPtrdiff [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded CPtrdiff
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: CPtrdiff
                          GHC.Int.$fBoundedInt64_$cminBound
                          `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                  :: (Int64 :: *) ~R# (CPtrdiff :: *))
                          GHC.Int.$fBoundedInt64_$cmaxBound
                          `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                  :: (Int64 :: *) ~R# (CPtrdiff :: *))]
Foreign.C.Types.$fBoundedCPtrdiff
  = GHC.Enum.C:Bounded
      @ CPtrdiff
      (GHC.Int.$fBoundedInt64_$cminBound
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 :: *) ~R# (CPtrdiff :: *)))
      (GHC.Int.$fBoundedInt64_$cmaxBound
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 :: *) ~R# (CPtrdiff :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCPtrdiff [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CPtrdiff
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CPtrdiff
                                   Foreign.Storable.$fStorableInt64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Int>_R
                                           :: (Int64 -> Int :: *) ~R# (CPtrdiff -> Int :: *))
                                   Foreign.Storable.$fStorableInt64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Int>_R
                                           :: (Int64 -> Int :: *) ~R# (CPtrdiff -> Int :: *))
                                   GHC.Storable.readInt64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CPtrdiff))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CPtrdiff[0]))
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CPtrdiff -> Int -> IO CPtrdiff :: *))
                                   GHC.Storable.writeInt64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CPtrdiff))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CPtrdiff
                                                   -> Int -> CPtrdiff -> IO () :: *))
                                   Foreign.Storable.$fStorableInt19
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CPtrdiff[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> IO CPtrdiff :: *))
                                   Foreign.Storable.$fStorableInt18
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CPtrdiff -> IO () :: *))
                                   Foreign.Storable.$fStorableInt17
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CPtrdiff))_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CPtrdiff[0]))
                                           :: (GHC.Ptr.Ptr Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CPtrdiff -> IO CPtrdiff :: *))
                                   Foreign.Storable.$fStorableInt15
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CPtrdiff))_R
                                           ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CPtrdiff -> CPtrdiff -> IO () :: *))]
Foreign.C.Types.$fStorableCPtrdiff
  = Foreign.Storable.C:Storable
      @ CPtrdiff
      (Foreign.Storable.$fStorableInt64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CPtrdiff -> Int :: *)))
      (Foreign.Storable.$fStorableInt64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CPtrdiff -> Int :: *)))
      (GHC.Storable.readInt64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CPtrdiff))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CPtrdiff[0]))
               :: (GHC.Ptr.Ptr Int64
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CPtrdiff -> Int -> IO CPtrdiff :: *)))
      (GHC.Storable.writeInt64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CPtrdiff))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int64
                   -> Int
                   -> Int64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CPtrdiff -> Int -> CPtrdiff -> IO () :: *)))
      (Foreign.Storable.$fStorableInt19
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CPtrdiff[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CPtrdiff :: *)))
      (Foreign.Storable.$fStorableInt18
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Int64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CPtrdiff -> IO () :: *)))
      (Foreign.Storable.$fStorableInt17
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CPtrdiff))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CPtrdiff[0]))
               :: (GHC.Ptr.Ptr Int64
                   -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CPtrdiff -> IO CPtrdiff :: *)))
      (Foreign.Storable.$fStorableInt15
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CPtrdiff))_R
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int64
                   -> Int64 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CPtrdiff -> CPtrdiff -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCPtrdiff [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CPtrdiff
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CPtrdiff
                       GHC.Int.$fEnumInt64_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                               :: (Int64 -> Int64 :: *) ~R# (CPtrdiff -> CPtrdiff :: *))
                       GHC.Int.$fEnumInt64_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                               :: (Int64 -> Int64 :: *) ~R# (CPtrdiff -> CPtrdiff :: *))
                       GHC.Int.$fEnumInt64_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                               :: (Int -> Int64 :: *) ~R# (Int -> CPtrdiff :: *))
                       GHC.Int.$fEnumInt64_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Int>_R
                               :: (Int64 -> Int :: *) ~R# (CPtrdiff -> Int :: *))
                       GHC.Int.$fEnumInt64_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                               ->_R ([Sym (Foreign.C.Types.N:CPtrdiff[0])])_R
                               :: (Int64 -> [Int64] :: *) ~R# (CPtrdiff -> [CPtrdiff] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                               ->_R ([Sym (Foreign.C.Types.N:CPtrdiff[0])])_R
                               :: (Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CPtrdiff -> CPtrdiff -> [CPtrdiff] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                               ->_R ([Sym (Foreign.C.Types.N:CPtrdiff[0])])_R
                               :: (Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CPtrdiff -> CPtrdiff -> [CPtrdiff] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                               ->_R ([Sym (Foreign.C.Types.N:CPtrdiff[0])])_R
                               :: (Int64 -> Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff -> [CPtrdiff] :: *))]
Foreign.C.Types.$fEnumCPtrdiff
  = GHC.Enum.C:Enum
      @ CPtrdiff
      (GHC.Int.$fEnumInt64_$csucc
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int64 :: *) ~R# (CPtrdiff -> CPtrdiff :: *)))
      (GHC.Int.$fEnumInt64_$cpred
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int64 :: *) ~R# (CPtrdiff -> CPtrdiff :: *)))
      (GHC.Int.$fEnumInt64_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int -> Int64 :: *) ~R# (Int -> CPtrdiff :: *)))
      (GHC.Int.$fEnumInt64_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CPtrdiff -> Int :: *)))
      (GHC.Int.$fEnumInt64_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R ([Sym (Foreign.C.Types.N:CPtrdiff[0])])_R
               :: (Int64 -> [Int64] :: *) ~R# (CPtrdiff -> [CPtrdiff] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R ([Sym (Foreign.C.Types.N:CPtrdiff[0])])_R
               :: (Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> [CPtrdiff] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R ([Sym (Foreign.C.Types.N:CPtrdiff[0])])_R
               :: (Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> [CPtrdiff] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R ([Sym (Foreign.C.Types.N:CPtrdiff[0])])_R
               :: (Int64 -> Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff -> [CPtrdiff] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCPtrdiff [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CPtrdiff
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CPtrdiff
                     GHC.Int.$fNumInt64_$c+
                     `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                             ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                             ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *))
                     GHC.Int.$fNumInt64_$c-
                     `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                             ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                             ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *))
                     GHC.Int.$fNumInt64_$c*
                     `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                             ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                             ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *))
                     GHC.Int.$fNumInt64_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                             ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                             :: (Int64 -> Int64 :: *) ~R# (CPtrdiff -> CPtrdiff :: *))
                     GHC.Int.$fNumInt64_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                             ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                             :: (Int64 -> Int64 :: *) ~R# (CPtrdiff -> CPtrdiff :: *))
                     GHC.Int.$fNumInt64_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                             ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                             :: (Int64 -> Int64 :: *) ~R# (CPtrdiff -> CPtrdiff :: *))
                     GHC.Int.$fNumInt64_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                             :: (Integer -> Int64 :: *) ~R# (Integer -> CPtrdiff :: *))]
Foreign.C.Types.$fNumCPtrdiff
  = GHC.Num.C:Num
      @ CPtrdiff
      (GHC.Int.$fNumInt64_$c+
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *)))
      (GHC.Int.$fNumInt64_$c-
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *)))
      (GHC.Int.$fNumInt64_$c*
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *)))
      (GHC.Int.$fNumInt64_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int64 :: *) ~R# (CPtrdiff -> CPtrdiff :: *)))
      (GHC.Int.$fNumInt64_$cabs
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int64 :: *) ~R# (CPtrdiff -> CPtrdiff :: *)))
      (GHC.Int.$fNumInt64_$csignum
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int64 :: *) ~R# (CPtrdiff -> CPtrdiff :: *)))
      (GHC.Int.$fNumInt64_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Integer -> Int64 :: *) ~R# (Integer -> CPtrdiff :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCPtrdiff [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CPtrdiff
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CPtrdiff
                        GHC.Int.eqInt64
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R <Bool>_R
                                :: (Int64 -> Int64 -> Bool :: *)
                                   ~R# (CPtrdiff -> CPtrdiff -> Bool :: *))
                        GHC.Int.neInt64
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R <Bool>_R
                                :: (Int64 -> Int64 -> Bool :: *)
                                   ~R# (CPtrdiff -> CPtrdiff -> Bool :: *))]
Foreign.C.Types.$fEqCPtrdiff
  = GHC.Classes.C:Eq
      @ CPtrdiff
      (GHC.Int.eqInt64
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> Bool :: *)))
      (GHC.Int.neInt64
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCPtrdiff [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CPtrdiff
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CPtrdiff
                         Foreign.C.Types.$fEqCPtrdiff
                         GHC.Int.$fOrdInt64_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                 ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                 ->_R <Ordering>_R
                                 :: (Int64 -> Int64 -> Ordering :: *)
                                    ~R# (CPtrdiff -> CPtrdiff -> Ordering :: *))
                         GHC.Int.ltInt64
                         `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                 ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CPtrdiff -> CPtrdiff -> Bool :: *))
                         GHC.Int.leInt64
                         `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                 ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CPtrdiff -> CPtrdiff -> Bool :: *))
                         GHC.Int.gtInt64
                         `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                 ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CPtrdiff -> CPtrdiff -> Bool :: *))
                         GHC.Int.geInt64
                         `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                 ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CPtrdiff -> CPtrdiff -> Bool :: *))
                         GHC.Int.$fOrdInt64_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                 ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                 ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                 :: (Int64 -> Int64 -> Int64 :: *)
                                    ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *))
                         GHC.Int.$fOrdInt64_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                 ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                 ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                 :: (Int64 -> Int64 -> Int64 :: *)
                                    ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *))]
Foreign.C.Types.$fOrdCPtrdiff
  = GHC.Classes.C:Ord
      @ CPtrdiff
      Foreign.C.Types.$fEqCPtrdiff
      (GHC.Int.$fOrdInt64_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R <Ordering>_R
               :: (Int64 -> Int64 -> Ordering :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> Ordering :: *)))
      (GHC.Int.ltInt64
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> Bool :: *)))
      (GHC.Int.leInt64
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> Bool :: *)))
      (GHC.Int.gtInt64
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> Bool :: *)))
      (GHC.Int.geInt64
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> Bool :: *)))
      (GHC.Int.$fOrdInt64_$cmax
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *)))
      (GHC.Int.$fOrdInt64_$cmin
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCPtrdiff [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CPtrdiff
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CPtrdiff
                       Foreign.C.Types.$fNumCPtrdiff
                       Foreign.C.Types.$fOrdCPtrdiff
                       GHC.Int.$fRealInt64_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Ratio Integer>_R
                               :: (Int64 -> Ratio Integer :: *)
                                  ~R# (CPtrdiff -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCPtrdiff
  = GHC.Real.C:Real
      @ CPtrdiff
      Foreign.C.Types.$fNumCPtrdiff
      Foreign.C.Types.$fOrdCPtrdiff
      (GHC.Int.$fRealInt64_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Ratio Integer>_R
               :: (Int64 -> Ratio Integer :: *)
                  ~R# (CPtrdiff -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.C.Types.$fIntegralCPtrdiff [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral CPtrdiff
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: CPtrdiff
                           Foreign.C.Types.$fRealCPtrdiff
                           Foreign.C.Types.$fEnumCPtrdiff
                           GHC.Int.$fIntegralInt64_$cquot
                           `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                   ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                   ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                   :: (Int64 -> Int64 -> Int64 :: *)
                                      ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *))
                           GHC.Int.$fIntegralInt64_$crem
                           `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                   ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                   ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                   :: (Int64 -> Int64 -> Int64 :: *)
                                      ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *))
                           GHC.Int.$fIntegralInt64_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                   ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                   ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                   :: (Int64 -> Int64 -> Int64 :: *)
                                      ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *))
                           GHC.Int.$fIntegralInt64_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                   ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                   ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                   :: (Int64 -> Int64 -> Int64 :: *)
                                      ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *))
                           GHC.Int.$fIntegralInt64_$cquotRem
                           `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                   ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CPtrdiff[0]))
                                           (Sym (Foreign.C.Types.N:CPtrdiff[0])))_R
                                   :: (Int64 -> Int64 -> (Int64, Int64) :: *)
                                      ~R# (CPtrdiff -> CPtrdiff -> (CPtrdiff, CPtrdiff) :: *))
                           GHC.Int.$fIntegralInt64_$cdivMod
                           `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                   ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CPtrdiff[0]))
                                           (Sym (Foreign.C.Types.N:CPtrdiff[0])))_R
                                   :: (Int64 -> Int64 -> (Int64, Int64) :: *)
                                      ~R# (CPtrdiff -> CPtrdiff -> (CPtrdiff, CPtrdiff) :: *))
                           GHC.Int.$fIntegralInt64_$ctoInteger
                           `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Integer>_R
                                   :: (Int64 -> Integer :: *) ~R# (CPtrdiff -> Integer :: *))]
Foreign.C.Types.$fIntegralCPtrdiff
  = GHC.Real.C:Integral
      @ CPtrdiff
      Foreign.C.Types.$fRealCPtrdiff
      Foreign.C.Types.$fEnumCPtrdiff
      (GHC.Int.$fIntegralInt64_$cquot
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *)))
      (GHC.Int.$fIntegralInt64_$crem
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *)))
      (GHC.Int.$fIntegralInt64_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *)))
      (GHC.Int.$fIntegralInt64_$cmod
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *)))
      (GHC.Int.$fIntegralInt64_$cquotRem
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CPtrdiff[0]))
                       (Sym (Foreign.C.Types.N:CPtrdiff[0])))_R
               :: (Int64 -> Int64 -> (Int64, Int64) :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> (CPtrdiff, CPtrdiff) :: *)))
      (GHC.Int.$fIntegralInt64_$cdivMod
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CPtrdiff[0]))
                       (Sym (Foreign.C.Types.N:CPtrdiff[0])))_R
               :: (Int64 -> Int64 -> (Int64, Int64) :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> (CPtrdiff, CPtrdiff) :: *)))
      (GHC.Int.$fIntegralInt64_$ctoInteger
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Integer>_R
               :: (Int64 -> Integer :: *) ~R# (CPtrdiff -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.C.Types.$fBitsCPtrdiff [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits CPtrdiff
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: CPtrdiff
                        Foreign.C.Types.$fEqCPtrdiff
                        GHC.Int.$fBitsInt64_$c.&.
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                :: (Int64 -> Int64 -> Int64 :: *)
                                   ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *))
                        GHC.Int.$fBitsInt64_$c.|.
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                :: (Int64 -> Int64 -> Int64 :: *)
                                   ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *))
                        GHC.Int.$fBitsInt64_$cxor
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                :: (Int64 -> Int64 -> Int64 :: *)
                                   ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *))
                        GHC.Int.$fBitsInt64_$ccomplement
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                :: (Int64 -> Int64 :: *) ~R# (CPtrdiff -> CPtrdiff :: *))
                        GHC.Int.$fBitsInt64_$cshift
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CPtrdiff -> Int -> CPtrdiff :: *))
                        GHC.Int.$fBitsInt64_$crotate
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CPtrdiff -> Int -> CPtrdiff :: *))
                        GHC.Int.$fBitsInt10
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                :: (Int64 :: *) ~R# (CPtrdiff :: *))
                        GHC.Int.$fBitsInt64_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                :: (Int -> Int64 :: *) ~R# (Int -> CPtrdiff :: *))
                        GHC.Int.$fBitsInt64_$csetBit
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CPtrdiff -> Int -> CPtrdiff :: *))
                        GHC.Int.$fBitsInt64_$cclearBit
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CPtrdiff -> Int -> CPtrdiff :: *))
                        GHC.Int.$fBitsInt64_$ccomplementBit
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CPtrdiff -> Int -> CPtrdiff :: *))
                        GHC.Int.$fBitsInt64_$ctestBit
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Int -> Bool>_R
                                :: (Int64 -> Int -> Bool :: *) ~R# (CPtrdiff -> Int -> Bool :: *))
                        GHC.Int.$fBitsInt64_$cbitSizeMaybe
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Maybe Int>_R
                                :: (Int64 -> Maybe Int :: *) ~R# (CPtrdiff -> Maybe Int :: *))
                        GHC.Int.$fBitsInt64_$cfiniteBitSize
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Int>_R
                                :: (Int64 -> Int :: *) ~R# (CPtrdiff -> Int :: *))
                        GHC.Int.$fBitsInt64_$cisSigned
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Bool>_R
                                :: (Int64 -> Bool :: *) ~R# (CPtrdiff -> Bool :: *))
                        GHC.Int.$fBitsInt64_$cshiftL
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CPtrdiff -> Int -> CPtrdiff :: *))
                        GHC.Int.$fBitsInt64_$cunsafeShiftL
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CPtrdiff -> Int -> CPtrdiff :: *))
                        GHC.Int.$fBitsInt64_$cshiftR
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CPtrdiff -> Int -> CPtrdiff :: *))
                        GHC.Int.$fBitsInt64_$cunsafeShiftR
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CPtrdiff -> Int -> CPtrdiff :: *))
                        GHC.Int.$fBitsInt64_$crotateL
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CPtrdiff -> Int -> CPtrdiff :: *))
                        GHC.Int.$fBitsInt64_$crotateR
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                                :: (Int64 -> Int -> Int64 :: *)
                                   ~R# (CPtrdiff -> Int -> CPtrdiff :: *))
                        GHC.Int.$fBitsInt64_$cpopCount
                        `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Int>_R
                                :: (Int64 -> Int :: *) ~R# (CPtrdiff -> Int :: *))]
Foreign.C.Types.$fBitsCPtrdiff
  = Data.Bits.C:Bits
      @ CPtrdiff
      Foreign.C.Types.$fEqCPtrdiff
      (GHC.Int.$fBitsInt64_$c.&.
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *)))
      (GHC.Int.$fBitsInt64_$c.|.
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *)))
      (GHC.Int.$fBitsInt64_$cxor
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CPtrdiff -> CPtrdiff -> CPtrdiff :: *)))
      (GHC.Int.$fBitsInt64_$ccomplement
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int64 :: *) ~R# (CPtrdiff -> CPtrdiff :: *)))
      (GHC.Int.$fBitsInt64_$cshift
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CPtrdiff -> Int -> CPtrdiff :: *)))
      (GHC.Int.$fBitsInt64_$crotate
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CPtrdiff -> Int -> CPtrdiff :: *)))
      (GHC.Int.$fBitsInt10
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 :: *) ~R# (CPtrdiff :: *)))
      (GHC.Int.$fBitsInt64_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int -> Int64 :: *) ~R# (Int -> CPtrdiff :: *)))
      (GHC.Int.$fBitsInt64_$csetBit
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CPtrdiff -> Int -> CPtrdiff :: *)))
      (GHC.Int.$fBitsInt64_$cclearBit
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CPtrdiff -> Int -> CPtrdiff :: *)))
      (GHC.Int.$fBitsInt64_$ccomplementBit
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CPtrdiff -> Int -> CPtrdiff :: *)))
      (GHC.Int.$fBitsInt64_$ctestBit
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Int -> Bool>_R
               :: (Int64 -> Int -> Bool :: *) ~R# (CPtrdiff -> Int -> Bool :: *)))
      (GHC.Int.$fBitsInt64_$cbitSizeMaybe
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Maybe Int>_R
               :: (Int64 -> Maybe Int :: *) ~R# (CPtrdiff -> Maybe Int :: *)))
      (GHC.Int.$fBitsInt64_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CPtrdiff -> Int :: *)))
      (GHC.Int.$fBitsInt64_$cisSigned
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Bool>_R
               :: (Int64 -> Bool :: *) ~R# (CPtrdiff -> Bool :: *)))
      (GHC.Int.$fBitsInt64_$cshiftL
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CPtrdiff -> Int -> CPtrdiff :: *)))
      (GHC.Int.$fBitsInt64_$cunsafeShiftL
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CPtrdiff -> Int -> CPtrdiff :: *)))
      (GHC.Int.$fBitsInt64_$cshiftR
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CPtrdiff -> Int -> CPtrdiff :: *)))
      (GHC.Int.$fBitsInt64_$cunsafeShiftR
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CPtrdiff -> Int -> CPtrdiff :: *)))
      (GHC.Int.$fBitsInt64_$crotateL
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CPtrdiff -> Int -> CPtrdiff :: *)))
      (GHC.Int.$fBitsInt64_$crotateR
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CPtrdiff -> Int -> CPtrdiff :: *)))
      (GHC.Int.$fBitsInt64_$cpopCount
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CPtrdiff -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.C.Types.$fFiniteBitsCPtrdiff [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits CPtrdiff
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: CPtrdiff
                              Foreign.C.Types.$fBitsCPtrdiff
                              GHC.Int.$fBitsInt64_$cfiniteBitSize
                              `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Int>_R
                                      :: (Int64 -> Int :: *) ~R# (CPtrdiff -> Int :: *))
                              GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros
                              `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Int>_R
                                      :: (Int64 -> Int :: *) ~R# (CPtrdiff -> Int :: *))
                              GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros
                              `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Int>_R
                                      :: (Int64 -> Int :: *) ~R# (CPtrdiff -> Int :: *))]
Foreign.C.Types.$fFiniteBitsCPtrdiff
  = Data.Bits.C:FiniteBits
      @ CPtrdiff
      Foreign.C.Types.$fBitsCPtrdiff
      (GHC.Int.$fBitsInt64_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CPtrdiff -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CPtrdiff -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros
       `cast` (Sym (Foreign.C.Types.N:CPtrdiff[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CPtrdiff -> Int :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CDouble
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CDouble
                       GHC.Float.$fShowDouble_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CDouble[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Double -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CDouble -> [Char] -> [Char] :: *))
                       GHC.Float.$fShowDouble_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <[Char]>_R
                               :: (Double -> [Char] :: *) ~R# (CDouble -> [Char] :: *))
                       GHC.Float.$fShowDouble_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CDouble[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Double] -> [Char] -> [Char] :: *)
                                  ~R# ([CDouble] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCDouble
  = GHC.Show.C:Show
      @ CDouble
      (GHC.Float.$fShowDouble_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Double -> [Char] -> [Char] :: *)
                  ~R# (Int -> CDouble -> [Char] -> [Char] :: *)))
      (GHC.Float.$fShowDouble_$cshow
       `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <[Char]>_R
               :: (Double -> [Char] :: *) ~R# (CDouble -> [Char] :: *)))
      (GHC.Float.$fShowDouble_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CDouble[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Double] -> [Char] -> [Char] :: *)
                  ~R# ([CDouble] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 34, joins: 0/0}
Foreign.C.Types.$fReadCDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CDouble
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CDouble
                       GHC.Read.$fReadDouble_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CDouble[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Double, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CDouble, [Char])] :: *))
                       GHC.Read.$fReadDouble_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CDouble[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Double], [Char])] :: *)
                                  ~R# ([Char] -> [([CDouble], [Char])] :: *))
                       GHC.Read.$fReadDouble1
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Double>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      (Foreign.C.Types.N:CDouble[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Double -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CDouble :: *))
                       GHC.Read.$fReadDouble_$creadListPrec
                       `cast` ((Text.ParserCombinators.ReadPrec.ReadPrec
                                  ([Sym (Foreign.C.Types.N:CDouble[0])])_R)_R
                               :: (Text.ParserCombinators.ReadPrec.ReadPrec [Double] :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CDouble] :: *))]
Foreign.C.Types.$fReadCDouble
  = GHC.Read.C:Read
      @ CDouble
      (GHC.Read.$fReadDouble_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CDouble[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Double, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CDouble, [Char])] :: *)))
      (GHC.Read.$fReadDouble_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CDouble[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Double], [Char])] :: *)
                  ~R# ([Char] -> [([CDouble], [Char])] :: *)))
      (GHC.Read.$fReadDouble1
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Double>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                      (Foreign.C.Types.N:CDouble[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Double -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CDouble :: *)))
      (GHC.Read.$fReadDouble_$creadListPrec
       `cast` ((Text.ParserCombinators.ReadPrec.ReadPrec
                  ([Sym (Foreign.C.Types.N:CDouble[0])])_R)_R
               :: (Text.ParserCombinators.ReadPrec.ReadPrec [Double] :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CDouble] :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CDouble
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CDouble
                                   Foreign.Storable.$fStorableDouble_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Int>_R
                                           :: (Double -> Int :: *) ~R# (CDouble -> Int :: *))
                                   Foreign.Storable.$fStorableDouble_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Int>_R
                                           :: (Double -> Int :: *) ~R# (CDouble -> Int :: *))
                                   GHC.Storable.readDoubleOffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Double, CDouble))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CDouble[0]))
                                           :: (GHC.Ptr.Ptr Double
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Double #) :: *)
                                              ~R# (GHC.Ptr.Ptr CDouble -> Int -> IO CDouble :: *))
                                   GHC.Storable.writeDoubleOffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Double, CDouble))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Double
                                               -> Int
                                               -> Double
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CDouble
                                                   -> Int -> CDouble -> IO () :: *))
                                   Foreign.Storable.$fStorableDouble4
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CDouble[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Double #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> IO CDouble :: *))
                                   Foreign.Storable.$fStorableDouble3
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Double
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CDouble -> IO () :: *))
                                   Foreign.Storable.$fStorableDouble2
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Double, CDouble))_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CDouble[0]))
                                           :: (GHC.Ptr.Ptr Double
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Double #) :: *)
                                              ~R# (GHC.Ptr.Ptr CDouble -> IO CDouble :: *))
                                   Foreign.Storable.$fStorableDouble1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Double, CDouble))_R
                                           ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Double
                                               -> Double
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CDouble -> CDouble -> IO () :: *))]
Foreign.C.Types.$fStorableCDouble
  = Foreign.Storable.C:Storable
      @ CDouble
      (Foreign.Storable.$fStorableDouble_$calignment
       `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Int>_R
               :: (Double -> Int :: *) ~R# (CDouble -> Int :: *)))
      (Foreign.Storable.$fStorableDouble_$calignment
       `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Int>_R
               :: (Double -> Int :: *) ~R# (CDouble -> Int :: *)))
      (GHC.Storable.readDoubleOffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Double, CDouble))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CDouble[0]))
               :: (GHC.Ptr.Ptr Double
                   -> Int -> State# RealWorld -> (# State# RealWorld, Double #) :: *)
                  ~R# (GHC.Ptr.Ptr CDouble -> Int -> IO CDouble :: *)))
      (GHC.Storable.writeDoubleOffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Double, CDouble))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Double
                   -> Int
                   -> Double
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CDouble -> Int -> CDouble -> IO () :: *)))
      (Foreign.Storable.$fStorableDouble4
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CDouble[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Double #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CDouble :: *)))
      (Foreign.Storable.$fStorableDouble3
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Double
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CDouble -> IO () :: *)))
      (Foreign.Storable.$fStorableDouble2
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Double, CDouble))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CDouble[0]))
               :: (GHC.Ptr.Ptr Double
                   -> State# RealWorld -> (# State# RealWorld, Double #) :: *)
                  ~R# (GHC.Ptr.Ptr CDouble -> IO CDouble :: *)))
      (Foreign.Storable.$fStorableDouble1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Double, CDouble))_R
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Double
                   -> Double -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CDouble -> CDouble -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CDouble
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CDouble
                       GHC.Float.$fEnumDouble_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                               ->_R Sym (Foreign.C.Types.N:CDouble[0])
                               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                       GHC.Float.$fEnumDouble_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                               ->_R Sym (Foreign.C.Types.N:CDouble[0])
                               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                       int2Double
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CDouble[0])
                               :: (Int -> Double :: *) ~R# (Int -> CDouble :: *))
                       GHC.Float.$fEnumDouble_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Int>_R
                               :: (Double -> Int :: *) ~R# (CDouble -> Int :: *))
                       GHC.Float.$fEnumDouble_$snumericEnumFrom
                       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                               ->_R ([Sym (Foreign.C.Types.N:CDouble[0])])_R
                               :: (Double -> [Double] :: *) ~R# (CDouble -> [CDouble] :: *))
                       GHC.Float.$fEnumDouble_$snumericEnumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                               ->_R Sym (Foreign.C.Types.N:CDouble[0])
                               ->_R ([Sym (Foreign.C.Types.N:CDouble[0])])_R
                               :: (Double -> Double -> [Double] :: *)
                                  ~R# (CDouble -> CDouble -> [CDouble] :: *))
                       GHC.Float.$fEnumDouble_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                               ->_R Sym (Foreign.C.Types.N:CDouble[0])
                               ->_R ([Sym (Foreign.C.Types.N:CDouble[0])])_R
                               :: (Double -> Double -> [Double] :: *)
                                  ~R# (CDouble -> CDouble -> [CDouble] :: *))
                       GHC.Float.$fEnumDouble_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                               ->_R Sym (Foreign.C.Types.N:CDouble[0])
                               ->_R Sym (Foreign.C.Types.N:CDouble[0])
                               ->_R ([Sym (Foreign.C.Types.N:CDouble[0])])_R
                               :: (Double -> Double -> Double -> [Double] :: *)
                                  ~R# (CDouble -> CDouble -> CDouble -> [CDouble] :: *))]
Foreign.C.Types.$fEnumCDouble
  = GHC.Enum.C:Enum
      @ CDouble
      (GHC.Float.$fEnumDouble_$csucc
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (GHC.Float.$fEnumDouble_$cpred
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (int2Double
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Int -> Double :: *) ~R# (Int -> CDouble :: *)))
      (GHC.Float.$fEnumDouble_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Int>_R
               :: (Double -> Int :: *) ~R# (CDouble -> Int :: *)))
      (GHC.Float.$fEnumDouble_$snumericEnumFrom
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R ([Sym (Foreign.C.Types.N:CDouble[0])])_R
               :: (Double -> [Double] :: *) ~R# (CDouble -> [CDouble] :: *)))
      (GHC.Float.$fEnumDouble_$snumericEnumFromThen
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R ([Sym (Foreign.C.Types.N:CDouble[0])])_R
               :: (Double -> Double -> [Double] :: *)
                  ~R# (CDouble -> CDouble -> [CDouble] :: *)))
      (GHC.Float.$fEnumDouble_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R ([Sym (Foreign.C.Types.N:CDouble[0])])_R
               :: (Double -> Double -> [Double] :: *)
                  ~R# (CDouble -> CDouble -> [CDouble] :: *)))
      (GHC.Float.$fEnumDouble_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R ([Sym (Foreign.C.Types.N:CDouble[0])])_R
               :: (Double -> Double -> Double -> [Double] :: *)
                  ~R# (CDouble -> CDouble -> CDouble -> [CDouble] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CDouble
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CDouble
                     plusDouble
                     `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                             ->_R Sym (Foreign.C.Types.N:CDouble[0])
                             ->_R Sym (Foreign.C.Types.N:CDouble[0])
                             :: (Double -> Double -> Double :: *)
                                ~R# (CDouble -> CDouble -> CDouble :: *))
                     minusDouble
                     `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                             ->_R Sym (Foreign.C.Types.N:CDouble[0])
                             ->_R Sym (Foreign.C.Types.N:CDouble[0])
                             :: (Double -> Double -> Double :: *)
                                ~R# (CDouble -> CDouble -> CDouble :: *))
                     timesDouble
                     `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                             ->_R Sym (Foreign.C.Types.N:CDouble[0])
                             ->_R Sym (Foreign.C.Types.N:CDouble[0])
                             :: (Double -> Double -> Double :: *)
                                ~R# (CDouble -> CDouble -> CDouble :: *))
                     negateDouble
                     `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                             ->_R Sym (Foreign.C.Types.N:CDouble[0])
                             :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                     fabsDouble
                     `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                             ->_R Sym (Foreign.C.Types.N:CDouble[0])
                             :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                     GHC.Float.$fNumDouble_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                             ->_R Sym (Foreign.C.Types.N:CDouble[0])
                             :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                     GHC.Float.$fNumDouble_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CDouble[0])
                             :: (Integer -> Double :: *) ~R# (Integer -> CDouble :: *))]
Foreign.C.Types.$fNumCDouble
  = GHC.Num.C:Num
      @ CDouble
      (plusDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double -> Double :: *)
                  ~R# (CDouble -> CDouble -> CDouble :: *)))
      (minusDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double -> Double :: *)
                  ~R# (CDouble -> CDouble -> CDouble :: *)))
      (timesDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double -> Double :: *)
                  ~R# (CDouble -> CDouble -> CDouble :: *)))
      (negateDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (fabsDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (GHC.Float.$fNumDouble_$csignum
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (GHC.Float.$fNumDouble_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Integer -> Double :: *) ~R# (Integer -> CDouble :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 18, joins: 0/0}
Foreign.C.Types.$fFractionalCDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Fractional CDouble
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Fractional TYPE: CDouble
                             Foreign.C.Types.$fNumCDouble
                             divideDouble
                             `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                     ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                     ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                     :: (Double -> Double -> Double :: *)
                                        ~R# (CDouble -> CDouble -> CDouble :: *))
                             GHC.Float.$fFractionalDouble_$crecip
                             `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                     ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                     :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                             GHC.Float.$fFractionalDouble_$cfromRational
                             `cast` (<Ratio Integer>_R ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                     :: (Ratio Integer -> Double :: *)
                                        ~R# (Ratio Integer -> CDouble :: *))]
Foreign.C.Types.$fFractionalCDouble
  = GHC.Real.C:Fractional
      @ CDouble
      Foreign.C.Types.$fNumCDouble
      (divideDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double -> Double :: *)
                  ~R# (CDouble -> CDouble -> CDouble :: *)))
      (GHC.Float.$fFractionalDouble_$crecip
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (GHC.Float.$fFractionalDouble_$cfromRational
       `cast` (<Ratio Integer>_R ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Ratio Integer -> Double :: *)
                  ~R# (Ratio Integer -> CDouble :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 113, joins: 0/0}
Foreign.C.Types.$fFloatingCDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Floating CDouble
[GblId[DFunId],
 Unf=DFun: \ ->
       GHC.Float.C:Floating TYPE: CDouble
                            Foreign.C.Types.$fFractionalCDouble
                            GHC.Float.$fFloatingDouble_$cpi
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double :: *) ~R# (CDouble :: *))
                            expDouble
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                            logDouble
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                            sqrtDouble
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                            powerDouble
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double -> Double :: *)
                                       ~R# (CDouble -> CDouble -> CDouble :: *))
                            GHC.Float.$fFloatingDouble_$clogBase
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double -> Double :: *)
                                       ~R# (CDouble -> CDouble -> CDouble :: *))
                            sinDouble
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                            cosDouble
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                            tanDouble
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                            asinDouble
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                            acosDouble
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                            atanDouble
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                            sinhDouble
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                            coshDouble
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                            tanhDouble
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                            GHC.Float.$fFloatingDouble_$casinh
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                            GHC.Float.$fFloatingDouble_$cacosh
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                            GHC.Float.$fFloatingDouble_$catanh
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                            log1pDouble
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                            expm1Double
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                            GHC.Float.$fFloatingDouble_$clog1pexp
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                            GHC.Float.$fFloatingDouble_$clog1mexp
                            `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                    ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                    :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))]
Foreign.C.Types.$fFloatingCDouble
  = GHC.Float.C:Floating
      @ CDouble
      Foreign.C.Types.$fFractionalCDouble
      (GHC.Float.$fFloatingDouble_$cpi
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double :: *) ~R# (CDouble :: *)))
      (expDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (logDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (sqrtDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (powerDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double -> Double :: *)
                  ~R# (CDouble -> CDouble -> CDouble :: *)))
      (GHC.Float.$fFloatingDouble_$clogBase
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double -> Double :: *)
                  ~R# (CDouble -> CDouble -> CDouble :: *)))
      (sinDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (cosDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (tanDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (asinDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (acosDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (atanDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (sinhDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (coshDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (tanhDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (GHC.Float.$fFloatingDouble_$casinh
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (GHC.Float.$fFloatingDouble_$cacosh
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (GHC.Float.$fFloatingDouble_$catanh
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (log1pDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (expm1Double
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (GHC.Float.$fFloatingDouble_$clog1pexp
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (GHC.Float.$fFloatingDouble_$clog1mexp
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CDouble
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CDouble
                        eqDouble
                        `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                ->_R <Bool>_R
                                :: (Double -> Double -> Bool :: *)
                                   ~R# (CDouble -> CDouble -> Bool :: *))
                        GHC.Classes.$fEqDouble_$c/=
                        `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                ->_R <Bool>_R
                                :: (Double -> Double -> Bool :: *)
                                   ~R# (CDouble -> CDouble -> Bool :: *))]
Foreign.C.Types.$fEqCDouble
  = GHC.Classes.C:Eq
      @ CDouble
      (eqDouble
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R <Bool>_R
               :: (Double -> Double -> Bool :: *)
                  ~R# (CDouble -> CDouble -> Bool :: *)))
      (GHC.Classes.$fEqDouble_$c/=
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R <Bool>_R
               :: (Double -> Double -> Bool :: *)
                  ~R# (CDouble -> CDouble -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CDouble
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CDouble
                         Foreign.C.Types.$fEqCDouble
                         GHC.Classes.$fOrdDouble_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                 ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                 ->_R <Ordering>_R
                                 :: (Double -> Double -> Ordering :: *)
                                    ~R# (CDouble -> CDouble -> Ordering :: *))
                         GHC.Classes.$fOrdDouble_$c<
                         `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                 ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                 ->_R <Bool>_R
                                 :: (Double -> Double -> Bool :: *)
                                    ~R# (CDouble -> CDouble -> Bool :: *))
                         GHC.Classes.$fOrdDouble_$c<=
                         `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                 ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                 ->_R <Bool>_R
                                 :: (Double -> Double -> Bool :: *)
                                    ~R# (CDouble -> CDouble -> Bool :: *))
                         GHC.Classes.$fOrdDouble_$c>
                         `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                 ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                 ->_R <Bool>_R
                                 :: (Double -> Double -> Bool :: *)
                                    ~R# (CDouble -> CDouble -> Bool :: *))
                         GHC.Classes.$fOrdDouble_$c>=
                         `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                 ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                 ->_R <Bool>_R
                                 :: (Double -> Double -> Bool :: *)
                                    ~R# (CDouble -> CDouble -> Bool :: *))
                         GHC.Classes.$fOrdDouble_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                 ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                 ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                 :: (Double -> Double -> Double :: *)
                                    ~R# (CDouble -> CDouble -> CDouble :: *))
                         GHC.Classes.$fOrdDouble_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                 ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                 ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                 :: (Double -> Double -> Double :: *)
                                    ~R# (CDouble -> CDouble -> CDouble :: *))]
Foreign.C.Types.$fOrdCDouble
  = GHC.Classes.C:Ord
      @ CDouble
      Foreign.C.Types.$fEqCDouble
      (GHC.Classes.$fOrdDouble_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R <Ordering>_R
               :: (Double -> Double -> Ordering :: *)
                  ~R# (CDouble -> CDouble -> Ordering :: *)))
      (GHC.Classes.$fOrdDouble_$c<
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R <Bool>_R
               :: (Double -> Double -> Bool :: *)
                  ~R# (CDouble -> CDouble -> Bool :: *)))
      (GHC.Classes.$fOrdDouble_$c<=
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R <Bool>_R
               :: (Double -> Double -> Bool :: *)
                  ~R# (CDouble -> CDouble -> Bool :: *)))
      (GHC.Classes.$fOrdDouble_$c>
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R <Bool>_R
               :: (Double -> Double -> Bool :: *)
                  ~R# (CDouble -> CDouble -> Bool :: *)))
      (GHC.Classes.$fOrdDouble_$c>=
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R <Bool>_R
               :: (Double -> Double -> Bool :: *)
                  ~R# (CDouble -> CDouble -> Bool :: *)))
      (GHC.Classes.$fOrdDouble_$cmax
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double -> Double :: *)
                  ~R# (CDouble -> CDouble -> CDouble :: *)))
      (GHC.Classes.$fOrdDouble_$cmin
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double -> Double :: *)
                  ~R# (CDouble -> CDouble -> CDouble :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CDouble
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CDouble
                       Foreign.C.Types.$fNumCDouble
                       Foreign.C.Types.$fOrdCDouble
                       GHC.Float.$fRealDouble_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Ratio Integer>_R
                               :: (Double -> Ratio Integer :: *)
                                  ~R# (CDouble -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCDouble
  = GHC.Real.C:Real
      @ CDouble
      Foreign.C.Types.$fNumCDouble
      Foreign.C.Types.$fOrdCDouble
      (GHC.Float.$fRealDouble_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Ratio Integer>_R
               :: (Double -> Ratio Integer :: *)
                  ~R# (CDouble -> Ratio Integer :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 53, joins: 0/0}
Foreign.C.Types.$fRealFracCDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: RealFrac CDouble
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:RealFrac TYPE: CDouble
                           Foreign.C.Types.$fRealCDouble
                           Foreign.C.Types.$fFractionalCDouble
                           GHC.Float.$fRealFracDouble_$cproperFraction
                           `cast` (forall (b :: <*>_N).
                                   <Integral b>_R
                                   ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                   ->_R ((,) <b>_R (Sym (Foreign.C.Types.N:CDouble[0])))_R
                                   :: (forall b. Integral b => Double -> (b, Double) :: *)
                                      ~R# (forall b. Integral b => CDouble -> (b, CDouble) :: *))
                           GHC.Float.$fRealFracDouble_$ctruncate
                           `cast` (forall (b :: <*>_N).
                                   <Integral b>_R ->_R Sym (Foreign.C.Types.N:CDouble[0]) ->_R <b>_R
                                   :: (forall b. Integral b => Double -> b :: *)
                                      ~R# (forall b. Integral b => CDouble -> b :: *))
                           GHC.Float.$fRealFracDouble_$cround
                           `cast` (forall (b :: <*>_N).
                                   <Integral b>_R ->_R Sym (Foreign.C.Types.N:CDouble[0]) ->_R <b>_R
                                   :: (forall b. Integral b => Double -> b :: *)
                                      ~R# (forall b. Integral b => CDouble -> b :: *))
                           GHC.Float.$fRealFracDouble_$cceiling
                           `cast` (forall (b :: <*>_N).
                                   <Integral b>_R ->_R Sym (Foreign.C.Types.N:CDouble[0]) ->_R <b>_R
                                   :: (forall b. Integral b => Double -> b :: *)
                                      ~R# (forall b. Integral b => CDouble -> b :: *))
                           GHC.Float.$fRealFracDouble_$cfloor
                           `cast` (forall (b :: <*>_N).
                                   <Integral b>_R ->_R Sym (Foreign.C.Types.N:CDouble[0]) ->_R <b>_R
                                   :: (forall b. Integral b => Double -> b :: *)
                                      ~R# (forall b. Integral b => CDouble -> b :: *))]
Foreign.C.Types.$fRealFracCDouble
  = GHC.Real.C:RealFrac
      @ CDouble
      Foreign.C.Types.$fRealCDouble
      Foreign.C.Types.$fFractionalCDouble
      (GHC.Float.$fRealFracDouble_$cproperFraction
       `cast` (forall (b :: <*>_N).
               <Integral b>_R
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R ((,) <b>_R (Sym (Foreign.C.Types.N:CDouble[0])))_R
               :: (forall b. Integral b => Double -> (b, Double) :: *)
                  ~R# (forall b. Integral b => CDouble -> (b, CDouble) :: *)))
      (GHC.Float.$fRealFracDouble_$ctruncate
       `cast` (forall (b :: <*>_N).
               <Integral b>_R ->_R Sym (Foreign.C.Types.N:CDouble[0]) ->_R <b>_R
               :: (forall b. Integral b => Double -> b :: *)
                  ~R# (forall b. Integral b => CDouble -> b :: *)))
      (GHC.Float.$fRealFracDouble_$cround
       `cast` (forall (b :: <*>_N).
               <Integral b>_R ->_R Sym (Foreign.C.Types.N:CDouble[0]) ->_R <b>_R
               :: (forall b. Integral b => Double -> b :: *)
                  ~R# (forall b. Integral b => CDouble -> b :: *)))
      (GHC.Float.$fRealFracDouble_$cceiling
       `cast` (forall (b :: <*>_N).
               <Integral b>_R ->_R Sym (Foreign.C.Types.N:CDouble[0]) ->_R <b>_R
               :: (forall b. Integral b => Double -> b :: *)
                  ~R# (forall b. Integral b => CDouble -> b :: *)))
      (GHC.Float.$fRealFracDouble_$cfloor
       `cast` (forall (b :: <*>_N).
               <Integral b>_R ->_R Sym (Foreign.C.Types.N:CDouble[0]) ->_R <b>_R
               :: (forall b. Integral b => Double -> b :: *)
                  ~R# (forall b. Integral b => CDouble -> b :: *)))

-- RHS size: {terms: 17, types: 1, coercions: 70, joins: 0/0}
Foreign.C.Types.$fRealFloatCDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: RealFloat CDouble
[GblId[DFunId],
 Unf=DFun: \ ->
       GHC.Float.C:RealFloat TYPE: CDouble
                             Foreign.C.Types.$fRealFracCDouble
                             Foreign.C.Types.$fFloatingCDouble
                             GHC.Float.$fRealFloatDouble_$cfloatRadix
                             `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Integer>_R
                                     :: (Double -> Integer :: *) ~R# (CDouble -> Integer :: *))
                             GHC.Float.$fRealFloatDouble_$cfloatDigits
                             `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Int>_R
                                     :: (Double -> Int :: *) ~R# (CDouble -> Int :: *))
                             GHC.Float.$fRealFloatDouble_$cfloatRange
                             `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <(Int, Int)>_R
                                     :: (Double -> (Int, Int) :: *)
                                        ~R# (CDouble -> (Int, Int) :: *))
                             GHC.Float.$fRealFloatDouble_$cdecodeFloat
                             `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <(Integer, Int)>_R
                                     :: (Double -> (Integer, Int) :: *)
                                        ~R# (CDouble -> (Integer, Int) :: *))
                             GHC.Float.$fRealFloatDouble_$cencodeFloat
                             `cast` (<Integer>_R
                                     ->_R <Int>_R
                                     ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                     :: (Integer -> Int -> Double :: *)
                                        ~R# (Integer -> Int -> CDouble :: *))
                             GHC.Float.$fRealFloatDouble_$cexponent
                             `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Int>_R
                                     :: (Double -> Int :: *) ~R# (CDouble -> Int :: *))
                             GHC.Float.$fRealFloatDouble_$csignificand
                             `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                     ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                     :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *))
                             GHC.Float.$fRealFloatDouble_$cscaleFloat
                             `cast` (<Int>_R
                                     ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                     ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                     :: (Int -> Double -> Double :: *)
                                        ~R# (Int -> CDouble -> CDouble :: *))
                             GHC.Float.$fRealFloatDouble_$cisNaN
                             `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Bool>_R
                                     :: (Double -> Bool :: *) ~R# (CDouble -> Bool :: *))
                             GHC.Float.$fRealFloatDouble_$cisInfinite
                             `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Bool>_R
                                     :: (Double -> Bool :: *) ~R# (CDouble -> Bool :: *))
                             GHC.Float.$fRealFloatDouble_$cisDenormalized
                             `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Bool>_R
                                     :: (Double -> Bool :: *) ~R# (CDouble -> Bool :: *))
                             GHC.Float.$fRealFloatDouble_$cisNegativeZero
                             `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Bool>_R
                                     :: (Double -> Bool :: *) ~R# (CDouble -> Bool :: *))
                             GHC.Float.$fRealFloatDouble_$cisIEEE
                             `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Bool>_R
                                     :: (Double -> Bool :: *) ~R# (CDouble -> Bool :: *))
                             GHC.Float.$fRealFloatDouble_$catan2
                             `cast` (Sym (Foreign.C.Types.N:CDouble[0])
                                     ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                     ->_R Sym (Foreign.C.Types.N:CDouble[0])
                                     :: (Double -> Double -> Double :: *)
                                        ~R# (CDouble -> CDouble -> CDouble :: *))]
Foreign.C.Types.$fRealFloatCDouble
  = GHC.Float.C:RealFloat
      @ CDouble
      Foreign.C.Types.$fRealFracCDouble
      Foreign.C.Types.$fFloatingCDouble
      (GHC.Float.$fRealFloatDouble_$cfloatRadix
       `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Integer>_R
               :: (Double -> Integer :: *) ~R# (CDouble -> Integer :: *)))
      (GHC.Float.$fRealFloatDouble_$cfloatDigits
       `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Int>_R
               :: (Double -> Int :: *) ~R# (CDouble -> Int :: *)))
      (GHC.Float.$fRealFloatDouble_$cfloatRange
       `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <(Int, Int)>_R
               :: (Double -> (Int, Int) :: *) ~R# (CDouble -> (Int, Int) :: *)))
      (GHC.Float.$fRealFloatDouble_$cdecodeFloat
       `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <(Integer, Int)>_R
               :: (Double -> (Integer, Int) :: *)
                  ~R# (CDouble -> (Integer, Int) :: *)))
      (GHC.Float.$fRealFloatDouble_$cencodeFloat
       `cast` (<Integer>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Integer -> Int -> Double :: *)
                  ~R# (Integer -> Int -> CDouble :: *)))
      (GHC.Float.$fRealFloatDouble_$cexponent
       `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Int>_R
               :: (Double -> Int :: *) ~R# (CDouble -> Int :: *)))
      (GHC.Float.$fRealFloatDouble_$csignificand
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double :: *) ~R# (CDouble -> CDouble :: *)))
      (GHC.Float.$fRealFloatDouble_$cscaleFloat
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Int -> Double -> Double :: *)
                  ~R# (Int -> CDouble -> CDouble :: *)))
      (GHC.Float.$fRealFloatDouble_$cisNaN
       `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Bool>_R
               :: (Double -> Bool :: *) ~R# (CDouble -> Bool :: *)))
      (GHC.Float.$fRealFloatDouble_$cisInfinite
       `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Bool>_R
               :: (Double -> Bool :: *) ~R# (CDouble -> Bool :: *)))
      (GHC.Float.$fRealFloatDouble_$cisDenormalized
       `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Bool>_R
               :: (Double -> Bool :: *) ~R# (CDouble -> Bool :: *)))
      (GHC.Float.$fRealFloatDouble_$cisNegativeZero
       `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Bool>_R
               :: (Double -> Bool :: *) ~R# (CDouble -> Bool :: *)))
      (GHC.Float.$fRealFloatDouble_$cisIEEE
       `cast` (Sym (Foreign.C.Types.N:CDouble[0]) ->_R <Bool>_R
               :: (Double -> Bool :: *) ~R# (CDouble -> Bool :: *)))
      (GHC.Float.$fRealFloatDouble_$catan2
       `cast` (Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               ->_R Sym (Foreign.C.Types.N:CDouble[0])
               :: (Double -> Double -> Double :: *)
                  ~R# (CDouble -> CDouble -> CDouble :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CFloat
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CFloat
                       GHC.Float.$fShowFloat_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CFloat[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Float -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CFloat -> [Char] -> [Char] :: *))
                       GHC.Float.$fShowFloat_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <[Char]>_R
                               :: (Float -> [Char] :: *) ~R# (CFloat -> [Char] :: *))
                       GHC.Float.$fShowFloat_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CFloat[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Float] -> [Char] -> [Char] :: *)
                                  ~R# ([CFloat] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCFloat
  = GHC.Show.C:Show
      @ CFloat
      (GHC.Float.$fShowFloat_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Float -> [Char] -> [Char] :: *)
                  ~R# (Int -> CFloat -> [Char] -> [Char] :: *)))
      (GHC.Float.$fShowFloat_$cshow
       `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <[Char]>_R
               :: (Float -> [Char] :: *) ~R# (CFloat -> [Char] :: *)))
      (GHC.Float.$fShowFloat_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CFloat[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Float] -> [Char] -> [Char] :: *)
                  ~R# ([CFloat] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 34, joins: 0/0}
Foreign.C.Types.$fReadCFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CFloat
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CFloat
                       GHC.Read.$fReadFloat_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CFloat[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Float, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CFloat, [Char])] :: *))
                       GHC.Read.$fReadFloat_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CFloat[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Float], [Char])] :: *)
                                  ~R# ([Char] -> [([CFloat], [Char])] :: *))
                       GHC.Read.$fReadFloat1
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Float>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     (Foreign.C.Types.N:CFloat[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Float -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CFloat :: *))
                       GHC.Read.$fReadFloat_$creadListPrec
                       `cast` ((Text.ParserCombinators.ReadPrec.ReadPrec
                                  ([Sym (Foreign.C.Types.N:CFloat[0])])_R)_R
                               :: (Text.ParserCombinators.ReadPrec.ReadPrec [Float] :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CFloat] :: *))]
Foreign.C.Types.$fReadCFloat
  = GHC.Read.C:Read
      @ CFloat
      (GHC.Read.$fReadFloat_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CFloat[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Float, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CFloat, [Char])] :: *)))
      (GHC.Read.$fReadFloat_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CFloat[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Float], [Char])] :: *)
                  ~R# ([Char] -> [([CFloat], [Char])] :: *)))
      (GHC.Read.$fReadFloat1
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Float>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                     (Foreign.C.Types.N:CFloat[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Float -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CFloat :: *)))
      (GHC.Read.$fReadFloat_$creadListPrec
       `cast` ((Text.ParserCombinators.ReadPrec.ReadPrec
                  ([Sym (Foreign.C.Types.N:CFloat[0])])_R)_R
               :: (Text.ParserCombinators.ReadPrec.ReadPrec [Float] :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CFloat] :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CFloat
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CFloat
                                   Foreign.Storable.$fStorableFloat_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Int>_R
                                           :: (Float -> Int :: *) ~R# (CFloat -> Int :: *))
                                   Foreign.Storable.$fStorableFloat_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Int>_R
                                           :: (Float -> Int :: *) ~R# (CFloat -> Int :: *))
                                   GHC.Storable.readFloatOffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Float, CFloat))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CFloat[0]))
                                           :: (GHC.Ptr.Ptr Float
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Float #) :: *)
                                              ~R# (GHC.Ptr.Ptr CFloat -> Int -> IO CFloat :: *))
                                   GHC.Storable.writeFloatOffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Float, CFloat))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Float
                                               -> Int
                                               -> Float
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CFloat
                                                   -> Int -> CFloat -> IO () :: *))
                                   Foreign.Storable.$fStorableFloat4
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CFloat[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Float #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> IO CFloat :: *))
                                   Foreign.Storable.$fStorableFloat3
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Float
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CFloat -> IO () :: *))
                                   Foreign.Storable.$fStorableFloat2
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Float, CFloat))_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CFloat[0]))
                                           :: (GHC.Ptr.Ptr Float
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Float #) :: *)
                                              ~R# (GHC.Ptr.Ptr CFloat -> IO CFloat :: *))
                                   Foreign.Storable.$fStorableFloat1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Float, CFloat))_R
                                           ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Float
                                               -> Float
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CFloat -> CFloat -> IO () :: *))]
Foreign.C.Types.$fStorableCFloat
  = Foreign.Storable.C:Storable
      @ CFloat
      (Foreign.Storable.$fStorableFloat_$calignment
       `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Int>_R
               :: (Float -> Int :: *) ~R# (CFloat -> Int :: *)))
      (Foreign.Storable.$fStorableFloat_$calignment
       `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Int>_R
               :: (Float -> Int :: *) ~R# (CFloat -> Int :: *)))
      (GHC.Storable.readFloatOffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Float, CFloat))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CFloat[0]))
               :: (GHC.Ptr.Ptr Float
                   -> Int -> State# RealWorld -> (# State# RealWorld, Float #) :: *)
                  ~R# (GHC.Ptr.Ptr CFloat -> Int -> IO CFloat :: *)))
      (GHC.Storable.writeFloatOffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Float, CFloat))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Float
                   -> Int
                   -> Float
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CFloat -> Int -> CFloat -> IO () :: *)))
      (Foreign.Storable.$fStorableFloat4
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CFloat[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Float #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CFloat :: *)))
      (Foreign.Storable.$fStorableFloat3
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Float
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CFloat -> IO () :: *)))
      (Foreign.Storable.$fStorableFloat2
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Float, CFloat))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CFloat[0]))
               :: (GHC.Ptr.Ptr Float
                   -> State# RealWorld -> (# State# RealWorld, Float #) :: *)
                  ~R# (GHC.Ptr.Ptr CFloat -> IO CFloat :: *)))
      (Foreign.Storable.$fStorableFloat1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Float, CFloat))_R
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Float
                   -> Float -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CFloat -> CFloat -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CFloat
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CFloat
                       GHC.Float.$fEnumFloat_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                               ->_R Sym (Foreign.C.Types.N:CFloat[0])
                               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                       GHC.Float.$fEnumFloat_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                               ->_R Sym (Foreign.C.Types.N:CFloat[0])
                               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                       int2Float
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CFloat[0])
                               :: (Int -> Float :: *) ~R# (Int -> CFloat :: *))
                       GHC.Float.$fEnumFloat_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Int>_R
                               :: (Float -> Int :: *) ~R# (CFloat -> Int :: *))
                       GHC.Float.$fEnumFloat_$snumericEnumFrom
                       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                               ->_R ([Sym (Foreign.C.Types.N:CFloat[0])])_R
                               :: (Float -> [Float] :: *) ~R# (CFloat -> [CFloat] :: *))
                       GHC.Float.$fEnumFloat_$snumericEnumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                               ->_R Sym (Foreign.C.Types.N:CFloat[0])
                               ->_R ([Sym (Foreign.C.Types.N:CFloat[0])])_R
                               :: (Float -> Float -> [Float] :: *)
                                  ~R# (CFloat -> CFloat -> [CFloat] :: *))
                       GHC.Float.$fEnumFloat_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                               ->_R Sym (Foreign.C.Types.N:CFloat[0])
                               ->_R ([Sym (Foreign.C.Types.N:CFloat[0])])_R
                               :: (Float -> Float -> [Float] :: *)
                                  ~R# (CFloat -> CFloat -> [CFloat] :: *))
                       GHC.Float.$fEnumFloat_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                               ->_R Sym (Foreign.C.Types.N:CFloat[0])
                               ->_R Sym (Foreign.C.Types.N:CFloat[0])
                               ->_R ([Sym (Foreign.C.Types.N:CFloat[0])])_R
                               :: (Float -> Float -> Float -> [Float] :: *)
                                  ~R# (CFloat -> CFloat -> CFloat -> [CFloat] :: *))]
Foreign.C.Types.$fEnumCFloat
  = GHC.Enum.C:Enum
      @ CFloat
      (GHC.Float.$fEnumFloat_$csucc
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (GHC.Float.$fEnumFloat_$cpred
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (int2Float
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Int -> Float :: *) ~R# (Int -> CFloat :: *)))
      (GHC.Float.$fEnumFloat_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Int>_R
               :: (Float -> Int :: *) ~R# (CFloat -> Int :: *)))
      (GHC.Float.$fEnumFloat_$snumericEnumFrom
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R ([Sym (Foreign.C.Types.N:CFloat[0])])_R
               :: (Float -> [Float] :: *) ~R# (CFloat -> [CFloat] :: *)))
      (GHC.Float.$fEnumFloat_$snumericEnumFromThen
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R ([Sym (Foreign.C.Types.N:CFloat[0])])_R
               :: (Float -> Float -> [Float] :: *)
                  ~R# (CFloat -> CFloat -> [CFloat] :: *)))
      (GHC.Float.$fEnumFloat_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R ([Sym (Foreign.C.Types.N:CFloat[0])])_R
               :: (Float -> Float -> [Float] :: *)
                  ~R# (CFloat -> CFloat -> [CFloat] :: *)))
      (GHC.Float.$fEnumFloat_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R ([Sym (Foreign.C.Types.N:CFloat[0])])_R
               :: (Float -> Float -> Float -> [Float] :: *)
                  ~R# (CFloat -> CFloat -> CFloat -> [CFloat] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CFloat
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CFloat
                     plusFloat
                     `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                             ->_R Sym (Foreign.C.Types.N:CFloat[0])
                             ->_R Sym (Foreign.C.Types.N:CFloat[0])
                             :: (Float -> Float -> Float :: *)
                                ~R# (CFloat -> CFloat -> CFloat :: *))
                     minusFloat
                     `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                             ->_R Sym (Foreign.C.Types.N:CFloat[0])
                             ->_R Sym (Foreign.C.Types.N:CFloat[0])
                             :: (Float -> Float -> Float :: *)
                                ~R# (CFloat -> CFloat -> CFloat :: *))
                     timesFloat
                     `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                             ->_R Sym (Foreign.C.Types.N:CFloat[0])
                             ->_R Sym (Foreign.C.Types.N:CFloat[0])
                             :: (Float -> Float -> Float :: *)
                                ~R# (CFloat -> CFloat -> CFloat :: *))
                     negateFloat
                     `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                             ->_R Sym (Foreign.C.Types.N:CFloat[0])
                             :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                     fabsFloat
                     `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                             ->_R Sym (Foreign.C.Types.N:CFloat[0])
                             :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                     GHC.Float.$fNumFloat_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                             ->_R Sym (Foreign.C.Types.N:CFloat[0])
                             :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                     GHC.Float.$fNumFloat_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CFloat[0])
                             :: (Integer -> Float :: *) ~R# (Integer -> CFloat :: *))]
Foreign.C.Types.$fNumCFloat
  = GHC.Num.C:Num
      @ CFloat
      (plusFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float -> Float :: *)
                  ~R# (CFloat -> CFloat -> CFloat :: *)))
      (minusFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float -> Float :: *)
                  ~R# (CFloat -> CFloat -> CFloat :: *)))
      (timesFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float -> Float :: *)
                  ~R# (CFloat -> CFloat -> CFloat :: *)))
      (negateFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (fabsFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (GHC.Float.$fNumFloat_$csignum
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (GHC.Float.$fNumFloat_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Integer -> Float :: *) ~R# (Integer -> CFloat :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 18, joins: 0/0}
Foreign.C.Types.$fFractionalCFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: Fractional CFloat
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Fractional TYPE: CFloat
                             Foreign.C.Types.$fNumCFloat
                             divideFloat
                             `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                     ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                     ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                     :: (Float -> Float -> Float :: *)
                                        ~R# (CFloat -> CFloat -> CFloat :: *))
                             GHC.Float.$fFractionalFloat_$crecip
                             `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                     ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                     :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                             GHC.Float.$fFractionalFloat_$cfromRational
                             `cast` (<Ratio Integer>_R ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                     :: (Ratio Integer -> Float :: *)
                                        ~R# (Ratio Integer -> CFloat :: *))]
Foreign.C.Types.$fFractionalCFloat
  = GHC.Real.C:Fractional
      @ CFloat
      Foreign.C.Types.$fNumCFloat
      (divideFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float -> Float :: *)
                  ~R# (CFloat -> CFloat -> CFloat :: *)))
      (GHC.Float.$fFractionalFloat_$crecip
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (GHC.Float.$fFractionalFloat_$cfromRational
       `cast` (<Ratio Integer>_R ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Ratio Integer -> Float :: *)
                  ~R# (Ratio Integer -> CFloat :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 113, joins: 0/0}
Foreign.C.Types.$fFloatingCFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: Floating CFloat
[GblId[DFunId],
 Unf=DFun: \ ->
       GHC.Float.C:Floating TYPE: CFloat
                            Foreign.C.Types.$fFractionalCFloat
                            GHC.Float.$fFloatingFloat_$cpi
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float :: *) ~R# (CFloat :: *))
                            expFloat
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                            logFloat
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                            sqrtFloat
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                            powerFloat
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float -> Float :: *)
                                       ~R# (CFloat -> CFloat -> CFloat :: *))
                            GHC.Float.$fFloatingFloat_$clogBase
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float -> Float :: *)
                                       ~R# (CFloat -> CFloat -> CFloat :: *))
                            sinFloat
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                            cosFloat
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                            tanFloat
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                            asinFloat
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                            acosFloat
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                            atanFloat
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                            sinhFloat
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                            coshFloat
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                            tanhFloat
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                            GHC.Float.$fFloatingFloat_$casinh
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                            GHC.Float.$fFloatingFloat_$cacosh
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                            GHC.Float.$fFloatingFloat_$catanh
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                            log1pFloat
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                            expm1Float
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                            GHC.Float.$fFloatingFloat_$clog1pexp
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                            GHC.Float.$fFloatingFloat_$clog1mexp
                            `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                    ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                    :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))]
Foreign.C.Types.$fFloatingCFloat
  = GHC.Float.C:Floating
      @ CFloat
      Foreign.C.Types.$fFractionalCFloat
      (GHC.Float.$fFloatingFloat_$cpi
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float :: *) ~R# (CFloat :: *)))
      (expFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (logFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (sqrtFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (powerFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float -> Float :: *)
                  ~R# (CFloat -> CFloat -> CFloat :: *)))
      (GHC.Float.$fFloatingFloat_$clogBase
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float -> Float :: *)
                  ~R# (CFloat -> CFloat -> CFloat :: *)))
      (sinFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (cosFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (tanFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (asinFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (acosFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (atanFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (sinhFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (coshFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (tanhFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (GHC.Float.$fFloatingFloat_$casinh
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (GHC.Float.$fFloatingFloat_$cacosh
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (GHC.Float.$fFloatingFloat_$catanh
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (log1pFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (expm1Float
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (GHC.Float.$fFloatingFloat_$clog1pexp
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (GHC.Float.$fFloatingFloat_$clog1mexp
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CFloat
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CFloat
                        eqFloat
                        `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                ->_R <Bool>_R
                                :: (Float -> Float -> Bool :: *)
                                   ~R# (CFloat -> CFloat -> Bool :: *))
                        GHC.Classes.$fEqFloat_$c/=
                        `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                ->_R <Bool>_R
                                :: (Float -> Float -> Bool :: *)
                                   ~R# (CFloat -> CFloat -> Bool :: *))]
Foreign.C.Types.$fEqCFloat
  = GHC.Classes.C:Eq
      @ CFloat
      (eqFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R <Bool>_R
               :: (Float -> Float -> Bool :: *)
                  ~R# (CFloat -> CFloat -> Bool :: *)))
      (GHC.Classes.$fEqFloat_$c/=
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R <Bool>_R
               :: (Float -> Float -> Bool :: *)
                  ~R# (CFloat -> CFloat -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CFloat
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CFloat
                         Foreign.C.Types.$fEqCFloat
                         GHC.Classes.$fOrdFloat_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                 ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                 ->_R <Ordering>_R
                                 :: (Float -> Float -> Ordering :: *)
                                    ~R# (CFloat -> CFloat -> Ordering :: *))
                         GHC.Classes.$fOrdFloat_$c<
                         `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                 ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                 ->_R <Bool>_R
                                 :: (Float -> Float -> Bool :: *)
                                    ~R# (CFloat -> CFloat -> Bool :: *))
                         GHC.Classes.$fOrdFloat_$c<=
                         `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                 ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                 ->_R <Bool>_R
                                 :: (Float -> Float -> Bool :: *)
                                    ~R# (CFloat -> CFloat -> Bool :: *))
                         GHC.Classes.$fOrdFloat_$c>
                         `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                 ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                 ->_R <Bool>_R
                                 :: (Float -> Float -> Bool :: *)
                                    ~R# (CFloat -> CFloat -> Bool :: *))
                         GHC.Classes.$fOrdFloat_$c>=
                         `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                 ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                 ->_R <Bool>_R
                                 :: (Float -> Float -> Bool :: *)
                                    ~R# (CFloat -> CFloat -> Bool :: *))
                         GHC.Classes.$fOrdFloat_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                 ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                 ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                 :: (Float -> Float -> Float :: *)
                                    ~R# (CFloat -> CFloat -> CFloat :: *))
                         GHC.Classes.$fOrdFloat_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                 ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                 ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                 :: (Float -> Float -> Float :: *)
                                    ~R# (CFloat -> CFloat -> CFloat :: *))]
Foreign.C.Types.$fOrdCFloat
  = GHC.Classes.C:Ord
      @ CFloat
      Foreign.C.Types.$fEqCFloat
      (GHC.Classes.$fOrdFloat_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R <Ordering>_R
               :: (Float -> Float -> Ordering :: *)
                  ~R# (CFloat -> CFloat -> Ordering :: *)))
      (GHC.Classes.$fOrdFloat_$c<
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R <Bool>_R
               :: (Float -> Float -> Bool :: *)
                  ~R# (CFloat -> CFloat -> Bool :: *)))
      (GHC.Classes.$fOrdFloat_$c<=
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R <Bool>_R
               :: (Float -> Float -> Bool :: *)
                  ~R# (CFloat -> CFloat -> Bool :: *)))
      (GHC.Classes.$fOrdFloat_$c>
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R <Bool>_R
               :: (Float -> Float -> Bool :: *)
                  ~R# (CFloat -> CFloat -> Bool :: *)))
      (GHC.Classes.$fOrdFloat_$c>=
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R <Bool>_R
               :: (Float -> Float -> Bool :: *)
                  ~R# (CFloat -> CFloat -> Bool :: *)))
      (GHC.Classes.$fOrdFloat_$cmax
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float -> Float :: *)
                  ~R# (CFloat -> CFloat -> CFloat :: *)))
      (GHC.Classes.$fOrdFloat_$cmin
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float -> Float :: *)
                  ~R# (CFloat -> CFloat -> CFloat :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CFloat
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CFloat
                       Foreign.C.Types.$fNumCFloat
                       Foreign.C.Types.$fOrdCFloat
                       GHC.Float.$fRealFloat_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Ratio Integer>_R
                               :: (Float -> Ratio Integer :: *)
                                  ~R# (CFloat -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCFloat
  = GHC.Real.C:Real
      @ CFloat
      Foreign.C.Types.$fNumCFloat
      Foreign.C.Types.$fOrdCFloat
      (GHC.Float.$fRealFloat_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Ratio Integer>_R
               :: (Float -> Ratio Integer :: *)
                  ~R# (CFloat -> Ratio Integer :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 53, joins: 0/0}
Foreign.C.Types.$fRealFracCFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: RealFrac CFloat
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:RealFrac TYPE: CFloat
                           Foreign.C.Types.$fRealCFloat
                           Foreign.C.Types.$fFractionalCFloat
                           GHC.Float.$fRealFracFloat_$cproperFraction
                           `cast` (forall (b :: <*>_N).
                                   <Integral b>_R
                                   ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                   ->_R ((,) <b>_R (Sym (Foreign.C.Types.N:CFloat[0])))_R
                                   :: (forall b. Integral b => Float -> (b, Float) :: *)
                                      ~R# (forall b. Integral b => CFloat -> (b, CFloat) :: *))
                           GHC.Float.$fRealFracFloat_$ctruncate
                           `cast` (forall (b :: <*>_N).
                                   <Integral b>_R ->_R Sym (Foreign.C.Types.N:CFloat[0]) ->_R <b>_R
                                   :: (forall b. Integral b => Float -> b :: *)
                                      ~R# (forall b. Integral b => CFloat -> b :: *))
                           GHC.Float.$fRealFracFloat_$cround
                           `cast` (forall (b :: <*>_N).
                                   <Integral b>_R ->_R Sym (Foreign.C.Types.N:CFloat[0]) ->_R <b>_R
                                   :: (forall b. Integral b => Float -> b :: *)
                                      ~R# (forall b. Integral b => CFloat -> b :: *))
                           GHC.Float.$fRealFracFloat_$cceiling
                           `cast` (forall (b :: <*>_N).
                                   <Integral b>_R ->_R Sym (Foreign.C.Types.N:CFloat[0]) ->_R <b>_R
                                   :: (forall b. Integral b => Float -> b :: *)
                                      ~R# (forall b. Integral b => CFloat -> b :: *))
                           GHC.Float.$fRealFracFloat_$cfloor
                           `cast` (forall (b :: <*>_N).
                                   <Integral b>_R ->_R Sym (Foreign.C.Types.N:CFloat[0]) ->_R <b>_R
                                   :: (forall b. Integral b => Float -> b :: *)
                                      ~R# (forall b. Integral b => CFloat -> b :: *))]
Foreign.C.Types.$fRealFracCFloat
  = GHC.Real.C:RealFrac
      @ CFloat
      Foreign.C.Types.$fRealCFloat
      Foreign.C.Types.$fFractionalCFloat
      (GHC.Float.$fRealFracFloat_$cproperFraction
       `cast` (forall (b :: <*>_N).
               <Integral b>_R
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R ((,) <b>_R (Sym (Foreign.C.Types.N:CFloat[0])))_R
               :: (forall b. Integral b => Float -> (b, Float) :: *)
                  ~R# (forall b. Integral b => CFloat -> (b, CFloat) :: *)))
      (GHC.Float.$fRealFracFloat_$ctruncate
       `cast` (forall (b :: <*>_N).
               <Integral b>_R ->_R Sym (Foreign.C.Types.N:CFloat[0]) ->_R <b>_R
               :: (forall b. Integral b => Float -> b :: *)
                  ~R# (forall b. Integral b => CFloat -> b :: *)))
      (GHC.Float.$fRealFracFloat_$cround
       `cast` (forall (b :: <*>_N).
               <Integral b>_R ->_R Sym (Foreign.C.Types.N:CFloat[0]) ->_R <b>_R
               :: (forall b. Integral b => Float -> b :: *)
                  ~R# (forall b. Integral b => CFloat -> b :: *)))
      (GHC.Float.$fRealFracFloat_$cceiling
       `cast` (forall (b :: <*>_N).
               <Integral b>_R ->_R Sym (Foreign.C.Types.N:CFloat[0]) ->_R <b>_R
               :: (forall b. Integral b => Float -> b :: *)
                  ~R# (forall b. Integral b => CFloat -> b :: *)))
      (GHC.Float.$fRealFracFloat_$cfloor
       `cast` (forall (b :: <*>_N).
               <Integral b>_R ->_R Sym (Foreign.C.Types.N:CFloat[0]) ->_R <b>_R
               :: (forall b. Integral b => Float -> b :: *)
                  ~R# (forall b. Integral b => CFloat -> b :: *)))

-- RHS size: {terms: 17, types: 1, coercions: 70, joins: 0/0}
Foreign.C.Types.$fRealFloatCFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: RealFloat CFloat
[GblId[DFunId],
 Unf=DFun: \ ->
       GHC.Float.C:RealFloat TYPE: CFloat
                             Foreign.C.Types.$fRealFracCFloat
                             Foreign.C.Types.$fFloatingCFloat
                             GHC.Float.$fRealFloatFloat_$cfloatRadix
                             `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Integer>_R
                                     :: (Float -> Integer :: *) ~R# (CFloat -> Integer :: *))
                             GHC.Float.$fRealFloatFloat_$cfloatDigits
                             `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Int>_R
                                     :: (Float -> Int :: *) ~R# (CFloat -> Int :: *))
                             GHC.Float.$fRealFloatFloat_$cfloatRange
                             `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <(Int, Int)>_R
                                     :: (Float -> (Int, Int) :: *) ~R# (CFloat -> (Int, Int) :: *))
                             GHC.Float.$fRealFloatFloat_$cdecodeFloat
                             `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <(Integer, Int)>_R
                                     :: (Float -> (Integer, Int) :: *)
                                        ~R# (CFloat -> (Integer, Int) :: *))
                             GHC.Float.$fRealFloatFloat_$cencodeFloat
                             `cast` (<Integer>_R
                                     ->_R <Int>_R
                                     ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                     :: (Integer -> Int -> Float :: *)
                                        ~R# (Integer -> Int -> CFloat :: *))
                             GHC.Float.$fRealFloatFloat_$cexponent
                             `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Int>_R
                                     :: (Float -> Int :: *) ~R# (CFloat -> Int :: *))
                             GHC.Float.$fRealFloatFloat_$csignificand
                             `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                     ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                     :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *))
                             GHC.Float.$fRealFloatFloat_$cscaleFloat
                             `cast` (<Int>_R
                                     ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                     ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                     :: (Int -> Float -> Float :: *)
                                        ~R# (Int -> CFloat -> CFloat :: *))
                             GHC.Float.$fRealFloatFloat_$cisNaN
                             `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Bool>_R
                                     :: (Float -> Bool :: *) ~R# (CFloat -> Bool :: *))
                             GHC.Float.$fRealFloatFloat_$cisInfinite
                             `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Bool>_R
                                     :: (Float -> Bool :: *) ~R# (CFloat -> Bool :: *))
                             GHC.Float.$fRealFloatFloat_$cisDenormalized
                             `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Bool>_R
                                     :: (Float -> Bool :: *) ~R# (CFloat -> Bool :: *))
                             GHC.Float.$fRealFloatFloat_$cisNegativeZero
                             `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Bool>_R
                                     :: (Float -> Bool :: *) ~R# (CFloat -> Bool :: *))
                             GHC.Float.$fRealFloatFloat_$cisIEEE
                             `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Bool>_R
                                     :: (Float -> Bool :: *) ~R# (CFloat -> Bool :: *))
                             GHC.Float.$fRealFloatFloat_$catan2
                             `cast` (Sym (Foreign.C.Types.N:CFloat[0])
                                     ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                     ->_R Sym (Foreign.C.Types.N:CFloat[0])
                                     :: (Float -> Float -> Float :: *)
                                        ~R# (CFloat -> CFloat -> CFloat :: *))]
Foreign.C.Types.$fRealFloatCFloat
  = GHC.Float.C:RealFloat
      @ CFloat
      Foreign.C.Types.$fRealFracCFloat
      Foreign.C.Types.$fFloatingCFloat
      (GHC.Float.$fRealFloatFloat_$cfloatRadix
       `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Integer>_R
               :: (Float -> Integer :: *) ~R# (CFloat -> Integer :: *)))
      (GHC.Float.$fRealFloatFloat_$cfloatDigits
       `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Int>_R
               :: (Float -> Int :: *) ~R# (CFloat -> Int :: *)))
      (GHC.Float.$fRealFloatFloat_$cfloatRange
       `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <(Int, Int)>_R
               :: (Float -> (Int, Int) :: *) ~R# (CFloat -> (Int, Int) :: *)))
      (GHC.Float.$fRealFloatFloat_$cdecodeFloat
       `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <(Integer, Int)>_R
               :: (Float -> (Integer, Int) :: *)
                  ~R# (CFloat -> (Integer, Int) :: *)))
      (GHC.Float.$fRealFloatFloat_$cencodeFloat
       `cast` (<Integer>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Integer -> Int -> Float :: *)
                  ~R# (Integer -> Int -> CFloat :: *)))
      (GHC.Float.$fRealFloatFloat_$cexponent
       `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Int>_R
               :: (Float -> Int :: *) ~R# (CFloat -> Int :: *)))
      (GHC.Float.$fRealFloatFloat_$csignificand
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float :: *) ~R# (CFloat -> CFloat :: *)))
      (GHC.Float.$fRealFloatFloat_$cscaleFloat
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Int -> Float -> Float :: *)
                  ~R# (Int -> CFloat -> CFloat :: *)))
      (GHC.Float.$fRealFloatFloat_$cisNaN
       `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Bool>_R
               :: (Float -> Bool :: *) ~R# (CFloat -> Bool :: *)))
      (GHC.Float.$fRealFloatFloat_$cisInfinite
       `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Bool>_R
               :: (Float -> Bool :: *) ~R# (CFloat -> Bool :: *)))
      (GHC.Float.$fRealFloatFloat_$cisDenormalized
       `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Bool>_R
               :: (Float -> Bool :: *) ~R# (CFloat -> Bool :: *)))
      (GHC.Float.$fRealFloatFloat_$cisNegativeZero
       `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Bool>_R
               :: (Float -> Bool :: *) ~R# (CFloat -> Bool :: *)))
      (GHC.Float.$fRealFloatFloat_$cisIEEE
       `cast` (Sym (Foreign.C.Types.N:CFloat[0]) ->_R <Bool>_R
               :: (Float -> Bool :: *) ~R# (CFloat -> Bool :: *)))
      (GHC.Float.$fRealFloatFloat_$catan2
       `cast` (Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               ->_R Sym (Foreign.C.Types.N:CFloat[0])
               :: (Float -> Float -> Float :: *)
                  ~R# (CFloat -> CFloat -> CFloat :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CBool
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CBool
                       GHC.Word.$fShowWord8_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CBool[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Word8 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CBool -> [Char] -> [Char] :: *))
                       GHC.Word.$fShowWord8_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <[Char]>_R
                               :: (Word8 -> [Char] :: *) ~R# (CBool -> [Char] :: *))
                       GHC.Word.$fShowWord8_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CBool[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Word8] -> [Char] -> [Char] :: *)
                                  ~R# ([CBool] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCBool
  = GHC.Show.C:Show
      @ CBool
      (GHC.Word.$fShowWord8_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Word8 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CBool -> [Char] -> [Char] :: *)))
      (GHC.Word.$fShowWord8_$cshow
       `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <[Char]>_R
               :: (Word8 -> [Char] :: *) ~R# (CBool -> [Char] :: *)))
      (GHC.Word.$fShowWord8_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CBool[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Word8] -> [Char] -> [Char] :: *)
                  ~R# ([CBool] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CBool
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CBool
                       GHC.Read.$fReadWord8_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CBool[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Word8, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CBool, [Char])] :: *))
                       GHC.Read.$fReadWord8_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CBool[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Word8], [Char])] :: *)
                                  ~R# ([Char] -> [([CBool], [Char])] :: *))
                       GHC.Read.$fReadWord17
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Word8>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     (Foreign.C.Types.N:CBool[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Word8 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CBool :: *))
                       GHC.Read.$fReadWord14
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Word8]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       ([Foreign.C.Types.N:CBool[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Word8] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CBool] :: *))]
Foreign.C.Types.$fReadCBool
  = GHC.Read.C:Read
      @ CBool
      (GHC.Read.$fReadWord8_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CBool[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Word8, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CBool, [Char])] :: *)))
      (GHC.Read.$fReadWord8_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CBool[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Word8], [Char])] :: *)
                  ~R# ([Char] -> [([CBool], [Char])] :: *)))
      (GHC.Read.$fReadWord17
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Word8>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                     (Foreign.C.Types.N:CBool[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Word8 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CBool :: *)))
      (GHC.Read.$fReadWord14
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Word8]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       ([Foreign.C.Types.N:CBool[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Word8] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CBool] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.C.Types.$fBoundedCBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded CBool
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: CBool
                          GHC.Word.$fBitsWord8_$cminBound
                          `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                  :: (Word8 :: *) ~R# (CBool :: *))
                          GHC.Word.$fBoundedWord8_$cmaxBound
                          `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                  :: (Word8 :: *) ~R# (CBool :: *))]
Foreign.C.Types.$fBoundedCBool
  = GHC.Enum.C:Bounded
      @ CBool
      (GHC.Word.$fBitsWord8_$cminBound
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 :: *) ~R# (CBool :: *)))
      (GHC.Word.$fBoundedWord8_$cmaxBound
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 :: *) ~R# (CBool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CBool
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CBool
                                   Foreign.Storable.$fStorableWord8_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Int>_R
                                           :: (Word8 -> Int :: *) ~R# (CBool -> Int :: *))
                                   Foreign.Storable.$fStorableWord8_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Int>_R
                                           :: (Word8 -> Int :: *) ~R# (CBool -> Int :: *))
                                   GHC.Storable.readWord8OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word8, CBool))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CBool[0]))
                                           :: (GHC.Ptr.Ptr Word8
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word8 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CBool -> Int -> IO CBool :: *))
                                   GHC.Storable.writeWord8OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word8, CBool))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CBool[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Word8
                                               -> Int
                                               -> Word8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CBool -> Int -> CBool -> IO () :: *))
                                   Foreign.Storable.$fStorableWord22
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CBool[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word8 #) :: *)
                                              ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CBool :: *))
                                   Foreign.Storable.$fStorableWord21
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CBool[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Word8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CBool -> IO () :: *))
                                   Foreign.Storable.$fStorableWord20
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word8, CBool))_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CBool[0]))
                                           :: (GHC.Ptr.Ptr Word8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word8 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CBool -> IO CBool :: *))
                                   Foreign.Storable.$fStorableWord19
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word8, CBool))_R
                                           ->_R Sym (Foreign.C.Types.N:CBool[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Word8
                                               -> Word8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CBool -> CBool -> IO () :: *))]
Foreign.C.Types.$fStorableCBool
  = Foreign.Storable.C:Storable
      @ CBool
      (Foreign.Storable.$fStorableWord8_$calignment
       `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Int>_R
               :: (Word8 -> Int :: *) ~R# (CBool -> Int :: *)))
      (Foreign.Storable.$fStorableWord8_$calignment
       `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Int>_R
               :: (Word8 -> Int :: *) ~R# (CBool -> Int :: *)))
      (GHC.Storable.readWord8OffPtr1
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Word8, CBool))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CBool[0]))
               :: (GHC.Ptr.Ptr Word8
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word8 #) :: *)
                  ~R# (GHC.Ptr.Ptr CBool -> Int -> IO CBool :: *)))
      (GHC.Storable.writeWord8OffPtr1
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Word8, CBool))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Word8
                   -> Int
                   -> Word8
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CBool -> Int -> CBool -> IO () :: *)))
      (Foreign.Storable.$fStorableWord22
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CBool[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word8 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CBool :: *)))
      (Foreign.Storable.$fStorableWord21
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Word8
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CBool -> IO () :: *)))
      (Foreign.Storable.$fStorableWord20
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Word8, CBool))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CBool[0]))
               :: (GHC.Ptr.Ptr Word8
                   -> State# RealWorld -> (# State# RealWorld, Word8 #) :: *)
                  ~R# (GHC.Ptr.Ptr CBool -> IO CBool :: *)))
      (Foreign.Storable.$fStorableWord19
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Word8, CBool))_R
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Word8
                   -> Word8 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CBool -> CBool -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CBool
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CBool
                       GHC.Word.$fEnumWord8_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CBool[0])
                               ->_R Sym (Foreign.C.Types.N:CBool[0])
                               :: (Word8 -> Word8 :: *) ~R# (CBool -> CBool :: *))
                       GHC.Word.$fEnumWord8_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CBool[0])
                               ->_R Sym (Foreign.C.Types.N:CBool[0])
                               :: (Word8 -> Word8 :: *) ~R# (CBool -> CBool :: *))
                       GHC.Word.$fEnumWord8_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CBool[0])
                               :: (Int -> Word8 :: *) ~R# (Int -> CBool :: *))
                       GHC.Word.$fEnumWord8_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Int>_R
                               :: (Word8 -> Int :: *) ~R# (CBool -> Int :: *))
                       GHC.Word.$fEnumWord8_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CBool[0])
                               ->_R ([Sym (Foreign.C.Types.N:CBool[0])])_R
                               :: (Word8 -> [Word8] :: *) ~R# (CBool -> [CBool] :: *))
                       GHC.Word.$fEnumWord8_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CBool[0])
                               ->_R Sym (Foreign.C.Types.N:CBool[0])
                               ->_R ([Sym (Foreign.C.Types.N:CBool[0])])_R
                               :: (Word8 -> Word8 -> [Word8] :: *)
                                  ~R# (CBool -> CBool -> [CBool] :: *))
                       GHC.Word.$fEnumWord8_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CBool[0])
                               ->_R Sym (Foreign.C.Types.N:CBool[0])
                               ->_R ([Sym (Foreign.C.Types.N:CBool[0])])_R
                               :: (Word8 -> Word8 -> [Word8] :: *)
                                  ~R# (CBool -> CBool -> [CBool] :: *))
                       GHC.Word.$fEnumWord8_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CBool[0])
                               ->_R Sym (Foreign.C.Types.N:CBool[0])
                               ->_R Sym (Foreign.C.Types.N:CBool[0])
                               ->_R ([Sym (Foreign.C.Types.N:CBool[0])])_R
                               :: (Word8 -> Word8 -> Word8 -> [Word8] :: *)
                                  ~R# (CBool -> CBool -> CBool -> [CBool] :: *))]
Foreign.C.Types.$fEnumCBool
  = GHC.Enum.C:Enum
      @ CBool
      (GHC.Word.$fEnumWord8_$csucc
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Word8 :: *) ~R# (CBool -> CBool :: *)))
      (GHC.Word.$fEnumWord8_$cpred
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Word8 :: *) ~R# (CBool -> CBool :: *)))
      (GHC.Word.$fEnumWord8_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Int -> Word8 :: *) ~R# (Int -> CBool :: *)))
      (GHC.Word.$fEnumWord8_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Int>_R
               :: (Word8 -> Int :: *) ~R# (CBool -> Int :: *)))
      (GHC.Word.$fEnumWord8_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R ([Sym (Foreign.C.Types.N:CBool[0])])_R
               :: (Word8 -> [Word8] :: *) ~R# (CBool -> [CBool] :: *)))
      (GHC.Word.$fEnumWord8_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R ([Sym (Foreign.C.Types.N:CBool[0])])_R
               :: (Word8 -> Word8 -> [Word8] :: *)
                  ~R# (CBool -> CBool -> [CBool] :: *)))
      (GHC.Word.$fEnumWord8_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R ([Sym (Foreign.C.Types.N:CBool[0])])_R
               :: (Word8 -> Word8 -> [Word8] :: *)
                  ~R# (CBool -> CBool -> [CBool] :: *)))
      (GHC.Word.$fEnumWord8_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R ([Sym (Foreign.C.Types.N:CBool[0])])_R
               :: (Word8 -> Word8 -> Word8 -> [Word8] :: *)
                  ~R# (CBool -> CBool -> CBool -> [CBool] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CBool
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CBool
                     GHC.Word.$fNumWord8_$c+
                     `cast` (Sym (Foreign.C.Types.N:CBool[0])
                             ->_R Sym (Foreign.C.Types.N:CBool[0])
                             ->_R Sym (Foreign.C.Types.N:CBool[0])
                             :: (Word8 -> Word8 -> Word8 :: *)
                                ~R# (CBool -> CBool -> CBool :: *))
                     GHC.Word.$fNumWord8_$c-
                     `cast` (Sym (Foreign.C.Types.N:CBool[0])
                             ->_R Sym (Foreign.C.Types.N:CBool[0])
                             ->_R Sym (Foreign.C.Types.N:CBool[0])
                             :: (Word8 -> Word8 -> Word8 :: *)
                                ~R# (CBool -> CBool -> CBool :: *))
                     GHC.Word.$fNumWord8_$c*
                     `cast` (Sym (Foreign.C.Types.N:CBool[0])
                             ->_R Sym (Foreign.C.Types.N:CBool[0])
                             ->_R Sym (Foreign.C.Types.N:CBool[0])
                             :: (Word8 -> Word8 -> Word8 :: *)
                                ~R# (CBool -> CBool -> CBool :: *))
                     GHC.Word.$fNumWord8_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CBool[0])
                             ->_R Sym (Foreign.C.Types.N:CBool[0])
                             :: (Word8 -> Word8 :: *) ~R# (CBool -> CBool :: *))
                     GHC.Word.$fNumWord8_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CBool[0])
                             ->_R Sym (Foreign.C.Types.N:CBool[0])
                             :: (Word8 -> Word8 :: *) ~R# (CBool -> CBool :: *))
                     GHC.Word.$fNumWord8_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CBool[0])
                             ->_R Sym (Foreign.C.Types.N:CBool[0])
                             :: (Word8 -> Word8 :: *) ~R# (CBool -> CBool :: *))
                     GHC.Word.$fNumWord8_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CBool[0])
                             :: (Integer -> Word8 :: *) ~R# (Integer -> CBool :: *))]
Foreign.C.Types.$fNumCBool
  = GHC.Num.C:Num
      @ CBool
      (GHC.Word.$fNumWord8_$c+
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CBool -> CBool -> CBool :: *)))
      (GHC.Word.$fNumWord8_$c-
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CBool -> CBool -> CBool :: *)))
      (GHC.Word.$fNumWord8_$c*
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CBool -> CBool -> CBool :: *)))
      (GHC.Word.$fNumWord8_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Word8 :: *) ~R# (CBool -> CBool :: *)))
      (GHC.Word.$fNumWord8_$cabs
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Word8 :: *) ~R# (CBool -> CBool :: *)))
      (GHC.Word.$fNumWord8_$csignum
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Word8 :: *) ~R# (CBool -> CBool :: *)))
      (GHC.Word.$fNumWord8_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Integer -> Word8 :: *) ~R# (Integer -> CBool :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CBool
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CBool
                        GHC.Word.eqWord8
                        `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                ->_R Sym (Foreign.C.Types.N:CBool[0])
                                ->_R <Bool>_R
                                :: (Word8 -> Word8 -> Bool :: *) ~R# (CBool -> CBool -> Bool :: *))
                        GHC.Word.neWord8
                        `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                ->_R Sym (Foreign.C.Types.N:CBool[0])
                                ->_R <Bool>_R
                                :: (Word8 -> Word8 -> Bool :: *)
                                   ~R# (CBool -> CBool -> Bool :: *))]
Foreign.C.Types.$fEqCBool
  = GHC.Classes.C:Eq
      @ CBool
      (GHC.Word.eqWord8
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R <Bool>_R
               :: (Word8 -> Word8 -> Bool :: *)
                  ~R# (CBool -> CBool -> Bool :: *)))
      (GHC.Word.neWord8
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R <Bool>_R
               :: (Word8 -> Word8 -> Bool :: *)
                  ~R# (CBool -> CBool -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CBool
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CBool
                         Foreign.C.Types.$fEqCBool
                         GHC.Word.$fOrdWord8_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                 ->_R Sym (Foreign.C.Types.N:CBool[0])
                                 ->_R <Ordering>_R
                                 :: (Word8 -> Word8 -> Ordering :: *)
                                    ~R# (CBool -> CBool -> Ordering :: *))
                         GHC.Word.ltWord8
                         `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                 ->_R Sym (Foreign.C.Types.N:CBool[0])
                                 ->_R <Bool>_R
                                 :: (Word8 -> Word8 -> Bool :: *) ~R# (CBool -> CBool -> Bool :: *))
                         GHC.Word.leWord8
                         `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                 ->_R Sym (Foreign.C.Types.N:CBool[0])
                                 ->_R <Bool>_R
                                 :: (Word8 -> Word8 -> Bool :: *) ~R# (CBool -> CBool -> Bool :: *))
                         GHC.Word.gtWord8
                         `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                 ->_R Sym (Foreign.C.Types.N:CBool[0])
                                 ->_R <Bool>_R
                                 :: (Word8 -> Word8 -> Bool :: *) ~R# (CBool -> CBool -> Bool :: *))
                         GHC.Word.geWord8
                         `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                 ->_R Sym (Foreign.C.Types.N:CBool[0])
                                 ->_R <Bool>_R
                                 :: (Word8 -> Word8 -> Bool :: *) ~R# (CBool -> CBool -> Bool :: *))
                         GHC.Word.$fOrdWord8_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                 ->_R Sym (Foreign.C.Types.N:CBool[0])
                                 ->_R Sym (Foreign.C.Types.N:CBool[0])
                                 :: (Word8 -> Word8 -> Word8 :: *)
                                    ~R# (CBool -> CBool -> CBool :: *))
                         GHC.Word.$fOrdWord8_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                 ->_R Sym (Foreign.C.Types.N:CBool[0])
                                 ->_R Sym (Foreign.C.Types.N:CBool[0])
                                 :: (Word8 -> Word8 -> Word8 :: *)
                                    ~R# (CBool -> CBool -> CBool :: *))]
Foreign.C.Types.$fOrdCBool
  = GHC.Classes.C:Ord
      @ CBool
      Foreign.C.Types.$fEqCBool
      (GHC.Word.$fOrdWord8_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R <Ordering>_R
               :: (Word8 -> Word8 -> Ordering :: *)
                  ~R# (CBool -> CBool -> Ordering :: *)))
      (GHC.Word.ltWord8
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R <Bool>_R
               :: (Word8 -> Word8 -> Bool :: *)
                  ~R# (CBool -> CBool -> Bool :: *)))
      (GHC.Word.leWord8
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R <Bool>_R
               :: (Word8 -> Word8 -> Bool :: *)
                  ~R# (CBool -> CBool -> Bool :: *)))
      (GHC.Word.gtWord8
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R <Bool>_R
               :: (Word8 -> Word8 -> Bool :: *)
                  ~R# (CBool -> CBool -> Bool :: *)))
      (GHC.Word.geWord8
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R <Bool>_R
               :: (Word8 -> Word8 -> Bool :: *)
                  ~R# (CBool -> CBool -> Bool :: *)))
      (GHC.Word.$fOrdWord8_$cmax
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CBool -> CBool -> CBool :: *)))
      (GHC.Word.$fOrdWord8_$cmin
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CBool -> CBool -> CBool :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CBool
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CBool
                       Foreign.C.Types.$fNumCBool
                       Foreign.C.Types.$fOrdCBool
                       GHC.Word.$fRealWord8_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Ratio Integer>_R
                               :: (Word8 -> Ratio Integer :: *)
                                  ~R# (CBool -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCBool
  = GHC.Real.C:Real
      @ CBool
      Foreign.C.Types.$fNumCBool
      Foreign.C.Types.$fOrdCBool
      (GHC.Word.$fRealWord8_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Ratio Integer>_R
               :: (Word8 -> Ratio Integer :: *)
                  ~R# (CBool -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.C.Types.$fIntegralCBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral CBool
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: CBool
                           Foreign.C.Types.$fRealCBool
                           Foreign.C.Types.$fEnumCBool
                           GHC.Word.$fIntegralWord8_$cquot
                           `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                   ->_R Sym (Foreign.C.Types.N:CBool[0])
                                   ->_R Sym (Foreign.C.Types.N:CBool[0])
                                   :: (Word8 -> Word8 -> Word8 :: *)
                                      ~R# (CBool -> CBool -> CBool :: *))
                           GHC.Word.$fIntegralWord8_$crem
                           `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                   ->_R Sym (Foreign.C.Types.N:CBool[0])
                                   ->_R Sym (Foreign.C.Types.N:CBool[0])
                                   :: (Word8 -> Word8 -> Word8 :: *)
                                      ~R# (CBool -> CBool -> CBool :: *))
                           GHC.Word.$fIntegralWord8_$cquot
                           `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                   ->_R Sym (Foreign.C.Types.N:CBool[0])
                                   ->_R Sym (Foreign.C.Types.N:CBool[0])
                                   :: (Word8 -> Word8 -> Word8 :: *)
                                      ~R# (CBool -> CBool -> CBool :: *))
                           GHC.Word.$fIntegralWord8_$crem
                           `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                   ->_R Sym (Foreign.C.Types.N:CBool[0])
                                   ->_R Sym (Foreign.C.Types.N:CBool[0])
                                   :: (Word8 -> Word8 -> Word8 :: *)
                                      ~R# (CBool -> CBool -> CBool :: *))
                           GHC.Word.$fIntegralWord8_$cquotRem
                           `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                   ->_R Sym (Foreign.C.Types.N:CBool[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CBool[0]))
                                           (Sym (Foreign.C.Types.N:CBool[0])))_R
                                   :: (Word8 -> Word8 -> (Word8, Word8) :: *)
                                      ~R# (CBool -> CBool -> (CBool, CBool) :: *))
                           GHC.Word.$fIntegralWord8_$cdivMod
                           `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                   ->_R Sym (Foreign.C.Types.N:CBool[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CBool[0]))
                                           (Sym (Foreign.C.Types.N:CBool[0])))_R
                                   :: (Word8 -> Word8 -> (Word8, Word8) :: *)
                                      ~R# (CBool -> CBool -> (CBool, CBool) :: *))
                           GHC.Word.$ctoInteger
                           `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Integer>_R
                                   :: (Word8 -> Integer :: *) ~R# (CBool -> Integer :: *))]
Foreign.C.Types.$fIntegralCBool
  = GHC.Real.C:Integral
      @ CBool
      Foreign.C.Types.$fRealCBool
      Foreign.C.Types.$fEnumCBool
      (GHC.Word.$fIntegralWord8_$cquot
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CBool -> CBool -> CBool :: *)))
      (GHC.Word.$fIntegralWord8_$crem
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CBool -> CBool -> CBool :: *)))
      (GHC.Word.$fIntegralWord8_$cquot
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CBool -> CBool -> CBool :: *)))
      (GHC.Word.$fIntegralWord8_$crem
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CBool -> CBool -> CBool :: *)))
      (GHC.Word.$fIntegralWord8_$cquotRem
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CBool[0]))
                       (Sym (Foreign.C.Types.N:CBool[0])))_R
               :: (Word8 -> Word8 -> (Word8, Word8) :: *)
                  ~R# (CBool -> CBool -> (CBool, CBool) :: *)))
      (GHC.Word.$fIntegralWord8_$cdivMod
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CBool[0]))
                       (Sym (Foreign.C.Types.N:CBool[0])))_R
               :: (Word8 -> Word8 -> (Word8, Word8) :: *)
                  ~R# (CBool -> CBool -> (CBool, CBool) :: *)))
      (GHC.Word.$ctoInteger
       `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Integer>_R
               :: (Word8 -> Integer :: *) ~R# (CBool -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.C.Types.$fBitsCBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits CBool
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: CBool
                        Foreign.C.Types.$fEqCBool
                        GHC.Word.$fBitsWord8_$c.&.
                        `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                ->_R Sym (Foreign.C.Types.N:CBool[0])
                                ->_R Sym (Foreign.C.Types.N:CBool[0])
                                :: (Word8 -> Word8 -> Word8 :: *)
                                   ~R# (CBool -> CBool -> CBool :: *))
                        GHC.Word.$fBitsWord8_$c.|.
                        `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                ->_R Sym (Foreign.C.Types.N:CBool[0])
                                ->_R Sym (Foreign.C.Types.N:CBool[0])
                                :: (Word8 -> Word8 -> Word8 :: *)
                                   ~R# (CBool -> CBool -> CBool :: *))
                        GHC.Word.$fBitsWord8_$cxor
                        `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                ->_R Sym (Foreign.C.Types.N:CBool[0])
                                ->_R Sym (Foreign.C.Types.N:CBool[0])
                                :: (Word8 -> Word8 -> Word8 :: *)
                                   ~R# (CBool -> CBool -> CBool :: *))
                        GHC.Word.$fBitsWord8_$ccomplement
                        `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                ->_R Sym (Foreign.C.Types.N:CBool[0])
                                :: (Word8 -> Word8 :: *) ~R# (CBool -> CBool :: *))
                        GHC.Word.$fBitsWord8_$cshift
                        `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CBool[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *))
                        GHC.Word.$fBitsWord8_$crotate
                        `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CBool[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *))
                        GHC.Word.$fBitsWord8_$cminBound
                        `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                :: (Word8 :: *) ~R# (CBool :: *))
                        GHC.Word.$fBitsWord8_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CBool[0])
                                :: (Int -> Word8 :: *) ~R# (Int -> CBool :: *))
                        GHC.Word.$fBitsWord8_$csetBit
                        `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CBool[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *))
                        GHC.Word.$fBitsWord8_$cclearBit
                        `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CBool[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *))
                        GHC.Word.$fBitsWord8_$ccomplementBit
                        `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CBool[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *))
                        GHC.Word.$fBitsWord8_$ctestBit
                        `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Int -> Bool>_R
                                :: (Word8 -> Int -> Bool :: *) ~R# (CBool -> Int -> Bool :: *))
                        GHC.Word.$fBitsWord8_$cbitSizeMaybe
                        `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Maybe Int>_R
                                :: (Word8 -> Maybe Int :: *) ~R# (CBool -> Maybe Int :: *))
                        GHC.Word.$fBitsWord8_$cfiniteBitSize
                        `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Int>_R
                                :: (Word8 -> Int :: *) ~R# (CBool -> Int :: *))
                        GHC.Word.$fBitsWord8_$cisSigned
                        `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Bool>_R
                                :: (Word8 -> Bool :: *) ~R# (CBool -> Bool :: *))
                        GHC.Word.$fBitsWord8_$cshiftL
                        `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CBool[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *))
                        GHC.Word.$fBitsWord8_$cunsafeShiftL
                        `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CBool[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *))
                        GHC.Word.$fBitsWord8_$cshiftR
                        `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CBool[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *))
                        GHC.Word.$fBitsWord8_$cunsafeShiftR
                        `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CBool[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *))
                        GHC.Word.$fBitsWord8_$crotateL
                        `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CBool[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *))
                        GHC.Word.$fBitsWord8_$crotateR
                        `cast` (Sym (Foreign.C.Types.N:CBool[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CBool[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *))
                        GHC.Word.$fBitsWord8_$cpopCount
                        `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Int>_R
                                :: (Word8 -> Int :: *) ~R# (CBool -> Int :: *))]
Foreign.C.Types.$fBitsCBool
  = Data.Bits.C:Bits
      @ CBool
      Foreign.C.Types.$fEqCBool
      (GHC.Word.$fBitsWord8_$c.&.
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CBool -> CBool -> CBool :: *)))
      (GHC.Word.$fBitsWord8_$c.|.
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CBool -> CBool -> CBool :: *)))
      (GHC.Word.$fBitsWord8_$cxor
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CBool -> CBool -> CBool :: *)))
      (GHC.Word.$fBitsWord8_$ccomplement
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Word8 :: *) ~R# (CBool -> CBool :: *)))
      (GHC.Word.$fBitsWord8_$cshift
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *)))
      (GHC.Word.$fBitsWord8_$crotate
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *)))
      (GHC.Word.$fBitsWord8_$cminBound
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 :: *) ~R# (CBool :: *)))
      (GHC.Word.$fBitsWord8_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Int -> Word8 :: *) ~R# (Int -> CBool :: *)))
      (GHC.Word.$fBitsWord8_$csetBit
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *)))
      (GHC.Word.$fBitsWord8_$cclearBit
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *)))
      (GHC.Word.$fBitsWord8_$ccomplementBit
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *)))
      (GHC.Word.$fBitsWord8_$ctestBit
       `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Int -> Bool>_R
               :: (Word8 -> Int -> Bool :: *) ~R# (CBool -> Int -> Bool :: *)))
      (GHC.Word.$fBitsWord8_$cbitSizeMaybe
       `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Maybe Int>_R
               :: (Word8 -> Maybe Int :: *) ~R# (CBool -> Maybe Int :: *)))
      (GHC.Word.$fBitsWord8_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Int>_R
               :: (Word8 -> Int :: *) ~R# (CBool -> Int :: *)))
      (GHC.Word.$fBitsWord8_$cisSigned
       `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Bool>_R
               :: (Word8 -> Bool :: *) ~R# (CBool -> Bool :: *)))
      (GHC.Word.$fBitsWord8_$cshiftL
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *)))
      (GHC.Word.$fBitsWord8_$cunsafeShiftL
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *)))
      (GHC.Word.$fBitsWord8_$cshiftR
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *)))
      (GHC.Word.$fBitsWord8_$cunsafeShiftR
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *)))
      (GHC.Word.$fBitsWord8_$crotateL
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *)))
      (GHC.Word.$fBitsWord8_$crotateR
       `cast` (Sym (Foreign.C.Types.N:CBool[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CBool[0])
               :: (Word8 -> Int -> Word8 :: *) ~R# (CBool -> Int -> CBool :: *)))
      (GHC.Word.$fBitsWord8_$cpopCount
       `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Int>_R
               :: (Word8 -> Int :: *) ~R# (CBool -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.C.Types.$fFiniteBitsCBool [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits CBool
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: CBool
                              Foreign.C.Types.$fBitsCBool
                              GHC.Word.$fBitsWord8_$cfiniteBitSize
                              `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Int>_R
                                      :: (Word8 -> Int :: *) ~R# (CBool -> Int :: *))
                              GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros
                              `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Int>_R
                                      :: (Word8 -> Int :: *) ~R# (CBool -> Int :: *))
                              GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros
                              `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Int>_R
                                      :: (Word8 -> Int :: *) ~R# (CBool -> Int :: *))]
Foreign.C.Types.$fFiniteBitsCBool
  = Data.Bits.C:FiniteBits
      @ CBool
      Foreign.C.Types.$fBitsCBool
      (GHC.Word.$fBitsWord8_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Int>_R
               :: (Word8 -> Int :: *) ~R# (CBool -> Int :: *)))
      (GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros
       `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Int>_R
               :: (Word8 -> Int :: *) ~R# (CBool -> Int :: *)))
      (GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros
       `cast` (Sym (Foreign.C.Types.N:CBool[0]) ->_R <Int>_R
               :: (Word8 -> Int :: *) ~R# (CBool -> Int :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCULLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CULLong
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CULLong
                       GHC.Word.$fShowWord64_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CULLong[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Word64 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CULLong -> [Char] -> [Char] :: *))
                       GHC.Word.$fShowWord64_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <[Char]>_R
                               :: (Word64 -> [Char] :: *) ~R# (CULLong -> [Char] :: *))
                       GHC.Word.$fShowWord64_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CULLong[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Word64] -> [Char] -> [Char] :: *)
                                  ~R# ([CULLong] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCULLong
  = GHC.Show.C:Show
      @ CULLong
      (GHC.Word.$fShowWord64_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Word64 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CULLong -> [Char] -> [Char] :: *)))
      (GHC.Word.$fShowWord64_$cshow
       `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <[Char]>_R
               :: (Word64 -> [Char] :: *) ~R# (CULLong -> [Char] :: *)))
      (GHC.Word.$fShowWord64_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CULLong[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Word64] -> [Char] -> [Char] :: *)
                  ~R# ([CULLong] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCULLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CULLong
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CULLong
                       GHC.Read.$fReadWord64_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CULLong[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Word64, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CULLong, [Char])] :: *))
                       GHC.Read.$fReadWord64_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CULLong[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Word64], [Char])] :: *)
                                  ~R# ([Char] -> [([CULLong], [Char])] :: *))
                       GHC.Read.$fReadWord13
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Word64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      (Foreign.C.Types.N:CULLong[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Word64 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CULLong :: *))
                       GHC.Read.$fReadWord11
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Word64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                        ([Foreign.C.Types.N:CULLong[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Word64] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CULLong] :: *))]
Foreign.C.Types.$fReadCULLong
  = GHC.Read.C:Read
      @ CULLong
      (GHC.Read.$fReadWord64_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CULLong[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Word64, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CULLong, [Char])] :: *)))
      (GHC.Read.$fReadWord64_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CULLong[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Word64], [Char])] :: *)
                  ~R# ([Char] -> [([CULLong], [Char])] :: *)))
      (GHC.Read.$fReadWord13
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Word64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                      (Foreign.C.Types.N:CULLong[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Word64 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CULLong :: *)))
      (GHC.Read.$fReadWord11
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Word64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        ([Foreign.C.Types.N:CULLong[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Word64] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CULLong] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.C.Types.$fBoundedCULLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded CULLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: CULLong
                          GHC.Word.$fBitsWord7
                          `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                  :: (Word64 :: *) ~R# (CULLong :: *))
                          GHC.Word.$fBoundedWord64_$cmaxBound
                          `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                  :: (Word64 :: *) ~R# (CULLong :: *))]
Foreign.C.Types.$fBoundedCULLong
  = GHC.Enum.C:Bounded
      @ CULLong
      (GHC.Word.$fBitsWord7
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 :: *) ~R# (CULLong :: *)))
      (GHC.Word.$fBoundedWord64_$cmaxBound
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 :: *) ~R# (CULLong :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCULLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CULLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CULLong
                                   Foreign.Storable.$fStorableWord64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Int>_R
                                           :: (Word64 -> Int :: *) ~R# (CULLong -> Int :: *))
                                   Foreign.Storable.$fStorableWord64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Int>_R
                                           :: (Word64 -> Int :: *) ~R# (CULLong -> Int :: *))
                                   GHC.Storable.readWord64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word64, CULLong))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CULLong[0]))
                                           :: (GHC.Ptr.Ptr Word64
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CULLong -> Int -> IO CULLong :: *))
                                   GHC.Storable.writeWord64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word64, CULLong))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Word64
                                               -> Int
                                               -> Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CULLong
                                                   -> Int -> CULLong -> IO () :: *))
                                   Foreign.Storable.$fStorableWord18
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CULLong[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word64 #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> IO CULLong :: *))
                                   Foreign.Storable.$fStorableWord17
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CULLong -> IO () :: *))
                                   Foreign.Storable.$fStorableWord15
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word64, CULLong))_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CULLong[0]))
                                           :: (GHC.Ptr.Ptr Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CULLong -> IO CULLong :: *))
                                   Foreign.Storable.$fStorableWord14
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word64, CULLong))_R
                                           ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Word64
                                               -> Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CULLong -> CULLong -> IO () :: *))]
Foreign.C.Types.$fStorableCULLong
  = Foreign.Storable.C:Storable
      @ CULLong
      (Foreign.Storable.$fStorableWord64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CULLong -> Int :: *)))
      (Foreign.Storable.$fStorableWord64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CULLong -> Int :: *)))
      (GHC.Storable.readWord64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word64, CULLong))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CULLong[0]))
               :: (GHC.Ptr.Ptr Word64
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CULLong -> Int -> IO CULLong :: *)))
      (GHC.Storable.writeWord64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word64, CULLong))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Word64
                   -> Int
                   -> Word64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CULLong -> Int -> CULLong -> IO () :: *)))
      (Foreign.Storable.$fStorableWord18
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CULLong[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word64 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CULLong :: *)))
      (Foreign.Storable.$fStorableWord17
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Word64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CULLong -> IO () :: *)))
      (Foreign.Storable.$fStorableWord15
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word64, CULLong))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CULLong[0]))
               :: (GHC.Ptr.Ptr Word64
                   -> State# RealWorld -> (# State# RealWorld, Word64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CULLong -> IO CULLong :: *)))
      (Foreign.Storable.$fStorableWord14
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word64, CULLong))_R
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Word64
                   -> Word64 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CULLong -> CULLong -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCULLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CULLong
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CULLong
                       GHC.Word.$fEnumWord64_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                               ->_R Sym (Foreign.C.Types.N:CULLong[0])
                               :: (Word64 -> Word64 :: *) ~R# (CULLong -> CULLong :: *))
                       GHC.Word.$fEnumWord64_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                               ->_R Sym (Foreign.C.Types.N:CULLong[0])
                               :: (Word64 -> Word64 :: *) ~R# (CULLong -> CULLong :: *))
                       GHC.Word.$fEnumWord64_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CULLong[0])
                               :: (Int -> Word64 :: *) ~R# (Int -> CULLong :: *))
                       GHC.Word.$fEnumWord64_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Int>_R
                               :: (Word64 -> Int :: *) ~R# (CULLong -> Int :: *))
                       GHC.Word.$fEnumWord64_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                               ->_R ([Sym (Foreign.C.Types.N:CULLong[0])])_R
                               :: (Word64 -> [Word64] :: *) ~R# (CULLong -> [CULLong] :: *))
                       GHC.Word.$fEnumWord64_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                               ->_R Sym (Foreign.C.Types.N:CULLong[0])
                               ->_R ([Sym (Foreign.C.Types.N:CULLong[0])])_R
                               :: (Word64 -> Word64 -> [Word64] :: *)
                                  ~R# (CULLong -> CULLong -> [CULLong] :: *))
                       GHC.Word.$fEnumWord64_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                               ->_R Sym (Foreign.C.Types.N:CULLong[0])
                               ->_R ([Sym (Foreign.C.Types.N:CULLong[0])])_R
                               :: (Word64 -> Word64 -> [Word64] :: *)
                                  ~R# (CULLong -> CULLong -> [CULLong] :: *))
                       GHC.Word.$fEnumWord64_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                               ->_R Sym (Foreign.C.Types.N:CULLong[0])
                               ->_R Sym (Foreign.C.Types.N:CULLong[0])
                               ->_R ([Sym (Foreign.C.Types.N:CULLong[0])])_R
                               :: (Word64 -> Word64 -> Word64 -> [Word64] :: *)
                                  ~R# (CULLong -> CULLong -> CULLong -> [CULLong] :: *))]
Foreign.C.Types.$fEnumCULLong
  = GHC.Enum.C:Enum
      @ CULLong
      (GHC.Word.$fEnumWord64_$csucc
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Word64 :: *) ~R# (CULLong -> CULLong :: *)))
      (GHC.Word.$fEnumWord64_$cpred
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Word64 :: *) ~R# (CULLong -> CULLong :: *)))
      (GHC.Word.$fEnumWord64_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Int -> Word64 :: *) ~R# (Int -> CULLong :: *)))
      (GHC.Word.$fEnumWord64_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CULLong -> Int :: *)))
      (GHC.Word.$fEnumWord64_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R ([Sym (Foreign.C.Types.N:CULLong[0])])_R
               :: (Word64 -> [Word64] :: *) ~R# (CULLong -> [CULLong] :: *)))
      (GHC.Word.$fEnumWord64_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R ([Sym (Foreign.C.Types.N:CULLong[0])])_R
               :: (Word64 -> Word64 -> [Word64] :: *)
                  ~R# (CULLong -> CULLong -> [CULLong] :: *)))
      (GHC.Word.$fEnumWord64_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R ([Sym (Foreign.C.Types.N:CULLong[0])])_R
               :: (Word64 -> Word64 -> [Word64] :: *)
                  ~R# (CULLong -> CULLong -> [CULLong] :: *)))
      (GHC.Word.$fEnumWord64_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R ([Sym (Foreign.C.Types.N:CULLong[0])])_R
               :: (Word64 -> Word64 -> Word64 -> [Word64] :: *)
                  ~R# (CULLong -> CULLong -> CULLong -> [CULLong] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCULLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CULLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CULLong
                     GHC.Word.$fNumWord64_$c+
                     `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                             ->_R Sym (Foreign.C.Types.N:CULLong[0])
                             ->_R Sym (Foreign.C.Types.N:CULLong[0])
                             :: (Word64 -> Word64 -> Word64 :: *)
                                ~R# (CULLong -> CULLong -> CULLong :: *))
                     GHC.Word.$fNumWord64_$c-
                     `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                             ->_R Sym (Foreign.C.Types.N:CULLong[0])
                             ->_R Sym (Foreign.C.Types.N:CULLong[0])
                             :: (Word64 -> Word64 -> Word64 :: *)
                                ~R# (CULLong -> CULLong -> CULLong :: *))
                     GHC.Word.$fNumWord64_$c*
                     `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                             ->_R Sym (Foreign.C.Types.N:CULLong[0])
                             ->_R Sym (Foreign.C.Types.N:CULLong[0])
                             :: (Word64 -> Word64 -> Word64 :: *)
                                ~R# (CULLong -> CULLong -> CULLong :: *))
                     GHC.Word.$fNumWord64_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                             ->_R Sym (Foreign.C.Types.N:CULLong[0])
                             :: (Word64 -> Word64 :: *) ~R# (CULLong -> CULLong :: *))
                     GHC.Word.$fNumWord64_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                             ->_R Sym (Foreign.C.Types.N:CULLong[0])
                             :: (Word64 -> Word64 :: *) ~R# (CULLong -> CULLong :: *))
                     GHC.Word.$fNumWord64_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                             ->_R Sym (Foreign.C.Types.N:CULLong[0])
                             :: (Word64 -> Word64 :: *) ~R# (CULLong -> CULLong :: *))
                     GHC.Word.$fNumWord64_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CULLong[0])
                             :: (Integer -> Word64 :: *) ~R# (Integer -> CULLong :: *))]
Foreign.C.Types.$fNumCULLong
  = GHC.Num.C:Num
      @ CULLong
      (GHC.Word.$fNumWord64_$c+
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULLong -> CULLong -> CULLong :: *)))
      (GHC.Word.$fNumWord64_$c-
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULLong -> CULLong -> CULLong :: *)))
      (GHC.Word.$fNumWord64_$c*
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULLong -> CULLong -> CULLong :: *)))
      (GHC.Word.$fNumWord64_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Word64 :: *) ~R# (CULLong -> CULLong :: *)))
      (GHC.Word.$fNumWord64_$cabs
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Word64 :: *) ~R# (CULLong -> CULLong :: *)))
      (GHC.Word.$fNumWord64_$csignum
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Word64 :: *) ~R# (CULLong -> CULLong :: *)))
      (GHC.Word.$fNumWord64_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Integer -> Word64 :: *) ~R# (Integer -> CULLong :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCULLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CULLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CULLong
                        GHC.Word.eqWord64
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R <Bool>_R
                                :: (Word64 -> Word64 -> Bool :: *)
                                   ~R# (CULLong -> CULLong -> Bool :: *))
                        GHC.Word.neWord64
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R <Bool>_R
                                :: (Word64 -> Word64 -> Bool :: *)
                                   ~R# (CULLong -> CULLong -> Bool :: *))]
Foreign.C.Types.$fEqCULLong
  = GHC.Classes.C:Eq
      @ CULLong
      (GHC.Word.eqWord64
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CULLong -> CULLong -> Bool :: *)))
      (GHC.Word.neWord64
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CULLong -> CULLong -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCULLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CULLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CULLong
                         Foreign.C.Types.$fEqCULLong
                         GHC.Word.$fOrdWord64_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                 ->_R <Ordering>_R
                                 :: (Word64 -> Word64 -> Ordering :: *)
                                    ~R# (CULLong -> CULLong -> Ordering :: *))
                         GHC.Word.ltWord64
                         `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                 ->_R <Bool>_R
                                 :: (Word64 -> Word64 -> Bool :: *)
                                    ~R# (CULLong -> CULLong -> Bool :: *))
                         GHC.Word.leWord64
                         `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                 ->_R <Bool>_R
                                 :: (Word64 -> Word64 -> Bool :: *)
                                    ~R# (CULLong -> CULLong -> Bool :: *))
                         GHC.Word.gtWord64
                         `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                 ->_R <Bool>_R
                                 :: (Word64 -> Word64 -> Bool :: *)
                                    ~R# (CULLong -> CULLong -> Bool :: *))
                         GHC.Word.geWord64
                         `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                 ->_R <Bool>_R
                                 :: (Word64 -> Word64 -> Bool :: *)
                                    ~R# (CULLong -> CULLong -> Bool :: *))
                         GHC.Word.$fOrdWord64_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                 :: (Word64 -> Word64 -> Word64 :: *)
                                    ~R# (CULLong -> CULLong -> CULLong :: *))
                         GHC.Word.$fOrdWord64_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                 :: (Word64 -> Word64 -> Word64 :: *)
                                    ~R# (CULLong -> CULLong -> CULLong :: *))]
Foreign.C.Types.$fOrdCULLong
  = GHC.Classes.C:Ord
      @ CULLong
      Foreign.C.Types.$fEqCULLong
      (GHC.Word.$fOrdWord64_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R <Ordering>_R
               :: (Word64 -> Word64 -> Ordering :: *)
                  ~R# (CULLong -> CULLong -> Ordering :: *)))
      (GHC.Word.ltWord64
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CULLong -> CULLong -> Bool :: *)))
      (GHC.Word.leWord64
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CULLong -> CULLong -> Bool :: *)))
      (GHC.Word.gtWord64
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CULLong -> CULLong -> Bool :: *)))
      (GHC.Word.geWord64
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CULLong -> CULLong -> Bool :: *)))
      (GHC.Word.$fOrdWord64_$cmax
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULLong -> CULLong -> CULLong :: *)))
      (GHC.Word.$fOrdWord64_$cmin
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULLong -> CULLong -> CULLong :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCULLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CULLong
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CULLong
                       Foreign.C.Types.$fNumCULLong
                       Foreign.C.Types.$fOrdCULLong
                       GHC.Word.$fRealWord64_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Ratio Integer>_R
                               :: (Word64 -> Ratio Integer :: *)
                                  ~R# (CULLong -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCULLong
  = GHC.Real.C:Real
      @ CULLong
      Foreign.C.Types.$fNumCULLong
      Foreign.C.Types.$fOrdCULLong
      (GHC.Word.$fRealWord64_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Ratio Integer>_R
               :: (Word64 -> Ratio Integer :: *)
                  ~R# (CULLong -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.C.Types.$fIntegralCULLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral CULLong
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: CULLong
                           Foreign.C.Types.$fRealCULLong
                           Foreign.C.Types.$fEnumCULLong
                           GHC.Word.$fIntegralWord64_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                   :: (Word64 -> Word64 -> Word64 :: *)
                                      ~R# (CULLong -> CULLong -> CULLong :: *))
                           GHC.Word.$fIntegralWord64_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                   :: (Word64 -> Word64 -> Word64 :: *)
                                      ~R# (CULLong -> CULLong -> CULLong :: *))
                           GHC.Word.$fIntegralWord64_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                   :: (Word64 -> Word64 -> Word64 :: *)
                                      ~R# (CULLong -> CULLong -> CULLong :: *))
                           GHC.Word.$fIntegralWord64_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                   :: (Word64 -> Word64 -> Word64 :: *)
                                      ~R# (CULLong -> CULLong -> CULLong :: *))
                           GHC.Word.$fIntegralWord64_$cquotRem
                           `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CULLong[0]))
                                           (Sym (Foreign.C.Types.N:CULLong[0])))_R
                                   :: (Word64 -> Word64 -> (Word64, Word64) :: *)
                                      ~R# (CULLong -> CULLong -> (CULLong, CULLong) :: *))
                           GHC.Word.$fIntegralWord64_$cdivMod
                           `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CULLong[0]))
                                           (Sym (Foreign.C.Types.N:CULLong[0])))_R
                                   :: (Word64 -> Word64 -> (Word64, Word64) :: *)
                                      ~R# (CULLong -> CULLong -> (CULLong, CULLong) :: *))
                           GHC.Word.$fIntegralWord64_$ctoInteger
                           `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Integer>_R
                                   :: (Word64 -> Integer :: *) ~R# (CULLong -> Integer :: *))]
Foreign.C.Types.$fIntegralCULLong
  = GHC.Real.C:Integral
      @ CULLong
      Foreign.C.Types.$fRealCULLong
      Foreign.C.Types.$fEnumCULLong
      (GHC.Word.$fIntegralWord64_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULLong -> CULLong -> CULLong :: *)))
      (GHC.Word.$fIntegralWord64_$cmod
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULLong -> CULLong -> CULLong :: *)))
      (GHC.Word.$fIntegralWord64_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULLong -> CULLong -> CULLong :: *)))
      (GHC.Word.$fIntegralWord64_$cmod
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULLong -> CULLong -> CULLong :: *)))
      (GHC.Word.$fIntegralWord64_$cquotRem
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CULLong[0]))
                       (Sym (Foreign.C.Types.N:CULLong[0])))_R
               :: (Word64 -> Word64 -> (Word64, Word64) :: *)
                  ~R# (CULLong -> CULLong -> (CULLong, CULLong) :: *)))
      (GHC.Word.$fIntegralWord64_$cdivMod
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CULLong[0]))
                       (Sym (Foreign.C.Types.N:CULLong[0])))_R
               :: (Word64 -> Word64 -> (Word64, Word64) :: *)
                  ~R# (CULLong -> CULLong -> (CULLong, CULLong) :: *)))
      (GHC.Word.$fIntegralWord64_$ctoInteger
       `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Integer>_R
               :: (Word64 -> Integer :: *) ~R# (CULLong -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.C.Types.$fBitsCULLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits CULLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: CULLong
                        Foreign.C.Types.$fEqCULLong
                        GHC.Word.$fBitsWord64_$c.&.
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                :: (Word64 -> Word64 -> Word64 :: *)
                                   ~R# (CULLong -> CULLong -> CULLong :: *))
                        GHC.Word.$fBitsWord64_$c.|.
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                :: (Word64 -> Word64 -> Word64 :: *)
                                   ~R# (CULLong -> CULLong -> CULLong :: *))
                        GHC.Word.$fBitsWord64_$cxor
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                :: (Word64 -> Word64 -> Word64 :: *)
                                   ~R# (CULLong -> CULLong -> CULLong :: *))
                        GHC.Word.$fBitsWord64_$ccomplement
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                :: (Word64 -> Word64 :: *) ~R# (CULLong -> CULLong :: *))
                        GHC.Word.$fBitsWord64_$cshift
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULLong -> Int -> CULLong :: *))
                        GHC.Word.$fBitsWord64_$crotate
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULLong -> Int -> CULLong :: *))
                        GHC.Word.$fBitsWord7
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                :: (Word64 :: *) ~R# (CULLong :: *))
                        GHC.Word.$fBitsWord64_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                :: (Int -> Word64 :: *) ~R# (Int -> CULLong :: *))
                        GHC.Word.$fBitsWord64_$csetBit
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULLong -> Int -> CULLong :: *))
                        GHC.Word.$fBitsWord64_$cclearBit
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULLong -> Int -> CULLong :: *))
                        GHC.Word.$fBitsWord64_$ccomplementBit
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULLong -> Int -> CULLong :: *))
                        GHC.Word.$fBitsWord64_$ctestBit
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Int -> Bool>_R
                                :: (Word64 -> Int -> Bool :: *) ~R# (CULLong -> Int -> Bool :: *))
                        GHC.Word.$fBitsWord64_$cbitSizeMaybe
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Maybe Int>_R
                                :: (Word64 -> Maybe Int :: *) ~R# (CULLong -> Maybe Int :: *))
                        GHC.Word.$fBitsWord64_$cfiniteBitSize
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Int>_R
                                :: (Word64 -> Int :: *) ~R# (CULLong -> Int :: *))
                        GHC.Word.$fBitsWord64_$cisSigned
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Bool>_R
                                :: (Word64 -> Bool :: *) ~R# (CULLong -> Bool :: *))
                        GHC.Word.$fBitsWord64_$cshiftL
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULLong -> Int -> CULLong :: *))
                        GHC.Word.$fBitsWord64_$cunsafeShiftL
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULLong -> Int -> CULLong :: *))
                        GHC.Word.$fBitsWord64_$cshiftR
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULLong -> Int -> CULLong :: *))
                        GHC.Word.$fBitsWord64_$cunsafeShiftR
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULLong -> Int -> CULLong :: *))
                        GHC.Word.$fBitsWord64_$crotateL
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULLong -> Int -> CULLong :: *))
                        GHC.Word.$fBitsWord64_$crotateR
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULLong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULLong -> Int -> CULLong :: *))
                        GHC.Word.$fBitsWord64_$cpopCount
                        `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Int>_R
                                :: (Word64 -> Int :: *) ~R# (CULLong -> Int :: *))]
Foreign.C.Types.$fBitsCULLong
  = Data.Bits.C:Bits
      @ CULLong
      Foreign.C.Types.$fEqCULLong
      (GHC.Word.$fBitsWord64_$c.&.
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULLong -> CULLong -> CULLong :: *)))
      (GHC.Word.$fBitsWord64_$c.|.
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULLong -> CULLong -> CULLong :: *)))
      (GHC.Word.$fBitsWord64_$cxor
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULLong -> CULLong -> CULLong :: *)))
      (GHC.Word.$fBitsWord64_$ccomplement
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Word64 :: *) ~R# (CULLong -> CULLong :: *)))
      (GHC.Word.$fBitsWord64_$cshift
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULLong -> Int -> CULLong :: *)))
      (GHC.Word.$fBitsWord64_$crotate
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULLong -> Int -> CULLong :: *)))
      (GHC.Word.$fBitsWord7
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 :: *) ~R# (CULLong :: *)))
      (GHC.Word.$fBitsWord64_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Int -> Word64 :: *) ~R# (Int -> CULLong :: *)))
      (GHC.Word.$fBitsWord64_$csetBit
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULLong -> Int -> CULLong :: *)))
      (GHC.Word.$fBitsWord64_$cclearBit
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULLong -> Int -> CULLong :: *)))
      (GHC.Word.$fBitsWord64_$ccomplementBit
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULLong -> Int -> CULLong :: *)))
      (GHC.Word.$fBitsWord64_$ctestBit
       `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Int -> Bool>_R
               :: (Word64 -> Int -> Bool :: *) ~R# (CULLong -> Int -> Bool :: *)))
      (GHC.Word.$fBitsWord64_$cbitSizeMaybe
       `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Maybe Int>_R
               :: (Word64 -> Maybe Int :: *) ~R# (CULLong -> Maybe Int :: *)))
      (GHC.Word.$fBitsWord64_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CULLong -> Int :: *)))
      (GHC.Word.$fBitsWord64_$cisSigned
       `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Bool>_R
               :: (Word64 -> Bool :: *) ~R# (CULLong -> Bool :: *)))
      (GHC.Word.$fBitsWord64_$cshiftL
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULLong -> Int -> CULLong :: *)))
      (GHC.Word.$fBitsWord64_$cunsafeShiftL
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULLong -> Int -> CULLong :: *)))
      (GHC.Word.$fBitsWord64_$cshiftR
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULLong -> Int -> CULLong :: *)))
      (GHC.Word.$fBitsWord64_$cunsafeShiftR
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULLong -> Int -> CULLong :: *)))
      (GHC.Word.$fBitsWord64_$crotateL
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULLong -> Int -> CULLong :: *)))
      (GHC.Word.$fBitsWord64_$crotateR
       `cast` (Sym (Foreign.C.Types.N:CULLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULLong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULLong -> Int -> CULLong :: *)))
      (GHC.Word.$fBitsWord64_$cpopCount
       `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CULLong -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.C.Types.$fFiniteBitsCULLong [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits CULLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: CULLong
                              Foreign.C.Types.$fBitsCULLong
                              GHC.Word.$fBitsWord64_$cfiniteBitSize
                              `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Int>_R
                                      :: (Word64 -> Int :: *) ~R# (CULLong -> Int :: *))
                              GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
                              `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Int>_R
                                      :: (Word64 -> Int :: *) ~R# (CULLong -> Int :: *))
                              GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros
                              `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Int>_R
                                      :: (Word64 -> Int :: *) ~R# (CULLong -> Int :: *))]
Foreign.C.Types.$fFiniteBitsCULLong
  = Data.Bits.C:FiniteBits
      @ CULLong
      Foreign.C.Types.$fBitsCULLong
      (GHC.Word.$fBitsWord64_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CULLong -> Int :: *)))
      (GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
       `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CULLong -> Int :: *)))
      (GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros
       `cast` (Sym (Foreign.C.Types.N:CULLong[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CULLong -> Int :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCLLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CLLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CLLong
                       GHC.Int.$fShowInt64_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CLLong[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Int64 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CLLong -> [Char] -> [Char] :: *))
                       GHC.Int.$fShowInt64_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <[Char]>_R
                               :: (Int64 -> [Char] :: *) ~R# (CLLong -> [Char] :: *))
                       GHC.Int.$fShowInt64_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CLLong[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Int64] -> [Char] -> [Char] :: *)
                                  ~R# ([CLLong] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCLLong
  = GHC.Show.C:Show
      @ CLLong
      (GHC.Int.$fShowInt64_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Int64 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CLLong -> [Char] -> [Char] :: *)))
      (GHC.Int.$fShowInt64_$cshow
       `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <[Char]>_R
               :: (Int64 -> [Char] :: *) ~R# (CLLong -> [Char] :: *)))
      (GHC.Int.$fShowInt64_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CLLong[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Int64] -> [Char] -> [Char] :: *)
                  ~R# ([CLLong] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCLLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CLLong
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CLLong
                       GHC.Int.$fReadInt64_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CLLong[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Int64, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CLLong, [Char])] :: *))
                       GHC.Int.$fReadInt64_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CLLong[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Int64], [Char])] :: *)
                                  ~R# ([Char] -> [([CLLong], [Char])] :: *))
                       GHC.Int.$fReadInt10
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Int64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     (Foreign.C.Types.N:CLLong[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Int64 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CLLong :: *))
                       GHC.Int.$fReadInt7
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Int64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       ([Foreign.C.Types.N:CLLong[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Int64] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CLLong] :: *))]
Foreign.C.Types.$fReadCLLong
  = GHC.Read.C:Read
      @ CLLong
      (GHC.Int.$fReadInt64_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CLLong[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Int64, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CLLong, [Char])] :: *)))
      (GHC.Int.$fReadInt64_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CLLong[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Int64], [Char])] :: *)
                  ~R# ([Char] -> [([CLLong], [Char])] :: *)))
      (GHC.Int.$fReadInt10
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Int64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                     (Foreign.C.Types.N:CLLong[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Int64 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CLLong :: *)))
      (GHC.Int.$fReadInt7
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Int64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       ([Foreign.C.Types.N:CLLong[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Int64] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CLLong] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.C.Types.$fBoundedCLLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded CLLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: CLLong
                          GHC.Int.$fBoundedInt64_$cminBound
                          `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                  :: (Int64 :: *) ~R# (CLLong :: *))
                          GHC.Int.$fBoundedInt64_$cmaxBound
                          `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                  :: (Int64 :: *) ~R# (CLLong :: *))]
Foreign.C.Types.$fBoundedCLLong
  = GHC.Enum.C:Bounded
      @ CLLong
      (GHC.Int.$fBoundedInt64_$cminBound
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 :: *) ~R# (CLLong :: *)))
      (GHC.Int.$fBoundedInt64_$cmaxBound
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 :: *) ~R# (CLLong :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCLLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CLLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CLLong
                                   Foreign.Storable.$fStorableInt64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Int>_R
                                           :: (Int64 -> Int :: *) ~R# (CLLong -> Int :: *))
                                   Foreign.Storable.$fStorableInt64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Int>_R
                                           :: (Int64 -> Int :: *) ~R# (CLLong -> Int :: *))
                                   GHC.Storable.readInt64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CLLong))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CLLong[0]))
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CLLong -> Int -> IO CLLong :: *))
                                   GHC.Storable.writeInt64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CLLong))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CLLong
                                                   -> Int -> CLLong -> IO () :: *))
                                   Foreign.Storable.$fStorableInt19
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CLLong[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> IO CLLong :: *))
                                   Foreign.Storable.$fStorableInt18
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CLLong -> IO () :: *))
                                   Foreign.Storable.$fStorableInt17
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CLLong))_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CLLong[0]))
                                           :: (GHC.Ptr.Ptr Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CLLong -> IO CLLong :: *))
                                   Foreign.Storable.$fStorableInt15
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CLLong))_R
                                           ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CLLong -> CLLong -> IO () :: *))]
Foreign.C.Types.$fStorableCLLong
  = Foreign.Storable.C:Storable
      @ CLLong
      (Foreign.Storable.$fStorableInt64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CLLong -> Int :: *)))
      (Foreign.Storable.$fStorableInt64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CLLong -> Int :: *)))
      (GHC.Storable.readInt64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CLLong))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CLLong[0]))
               :: (GHC.Ptr.Ptr Int64
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CLLong -> Int -> IO CLLong :: *)))
      (GHC.Storable.writeInt64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CLLong))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int64
                   -> Int
                   -> Int64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CLLong -> Int -> CLLong -> IO () :: *)))
      (Foreign.Storable.$fStorableInt19
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CLLong[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CLLong :: *)))
      (Foreign.Storable.$fStorableInt18
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Int64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CLLong -> IO () :: *)))
      (Foreign.Storable.$fStorableInt17
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CLLong))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CLLong[0]))
               :: (GHC.Ptr.Ptr Int64
                   -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CLLong -> IO CLLong :: *)))
      (Foreign.Storable.$fStorableInt15
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int64, CLLong))_R
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int64
                   -> Int64 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CLLong -> CLLong -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCLLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CLLong
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CLLong
                       GHC.Int.$fEnumInt64_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                               ->_R Sym (Foreign.C.Types.N:CLLong[0])
                               :: (Int64 -> Int64 :: *) ~R# (CLLong -> CLLong :: *))
                       GHC.Int.$fEnumInt64_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                               ->_R Sym (Foreign.C.Types.N:CLLong[0])
                               :: (Int64 -> Int64 :: *) ~R# (CLLong -> CLLong :: *))
                       GHC.Int.$fEnumInt64_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CLLong[0])
                               :: (Int -> Int64 :: *) ~R# (Int -> CLLong :: *))
                       GHC.Int.$fEnumInt64_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Int>_R
                               :: (Int64 -> Int :: *) ~R# (CLLong -> Int :: *))
                       GHC.Int.$fEnumInt64_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                               ->_R ([Sym (Foreign.C.Types.N:CLLong[0])])_R
                               :: (Int64 -> [Int64] :: *) ~R# (CLLong -> [CLLong] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                               ->_R Sym (Foreign.C.Types.N:CLLong[0])
                               ->_R ([Sym (Foreign.C.Types.N:CLLong[0])])_R
                               :: (Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CLLong -> CLLong -> [CLLong] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                               ->_R Sym (Foreign.C.Types.N:CLLong[0])
                               ->_R ([Sym (Foreign.C.Types.N:CLLong[0])])_R
                               :: (Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CLLong -> CLLong -> [CLLong] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                               ->_R Sym (Foreign.C.Types.N:CLLong[0])
                               ->_R Sym (Foreign.C.Types.N:CLLong[0])
                               ->_R ([Sym (Foreign.C.Types.N:CLLong[0])])_R
                               :: (Int64 -> Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CLLong -> CLLong -> CLLong -> [CLLong] :: *))]
Foreign.C.Types.$fEnumCLLong
  = GHC.Enum.C:Enum
      @ CLLong
      (GHC.Int.$fEnumInt64_$csucc
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int64 :: *) ~R# (CLLong -> CLLong :: *)))
      (GHC.Int.$fEnumInt64_$cpred
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int64 :: *) ~R# (CLLong -> CLLong :: *)))
      (GHC.Int.$fEnumInt64_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int -> Int64 :: *) ~R# (Int -> CLLong :: *)))
      (GHC.Int.$fEnumInt64_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CLLong -> Int :: *)))
      (GHC.Int.$fEnumInt64_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R ([Sym (Foreign.C.Types.N:CLLong[0])])_R
               :: (Int64 -> [Int64] :: *) ~R# (CLLong -> [CLLong] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R ([Sym (Foreign.C.Types.N:CLLong[0])])_R
               :: (Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CLLong -> CLLong -> [CLLong] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R ([Sym (Foreign.C.Types.N:CLLong[0])])_R
               :: (Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CLLong -> CLLong -> [CLLong] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R ([Sym (Foreign.C.Types.N:CLLong[0])])_R
               :: (Int64 -> Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CLLong -> CLLong -> CLLong -> [CLLong] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCLLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CLLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CLLong
                     GHC.Int.$fNumInt64_$c+
                     `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                             ->_R Sym (Foreign.C.Types.N:CLLong[0])
                             ->_R Sym (Foreign.C.Types.N:CLLong[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CLLong -> CLLong -> CLLong :: *))
                     GHC.Int.$fNumInt64_$c-
                     `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                             ->_R Sym (Foreign.C.Types.N:CLLong[0])
                             ->_R Sym (Foreign.C.Types.N:CLLong[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CLLong -> CLLong -> CLLong :: *))
                     GHC.Int.$fNumInt64_$c*
                     `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                             ->_R Sym (Foreign.C.Types.N:CLLong[0])
                             ->_R Sym (Foreign.C.Types.N:CLLong[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CLLong -> CLLong -> CLLong :: *))
                     GHC.Int.$fNumInt64_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                             ->_R Sym (Foreign.C.Types.N:CLLong[0])
                             :: (Int64 -> Int64 :: *) ~R# (CLLong -> CLLong :: *))
                     GHC.Int.$fNumInt64_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                             ->_R Sym (Foreign.C.Types.N:CLLong[0])
                             :: (Int64 -> Int64 :: *) ~R# (CLLong -> CLLong :: *))
                     GHC.Int.$fNumInt64_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                             ->_R Sym (Foreign.C.Types.N:CLLong[0])
                             :: (Int64 -> Int64 :: *) ~R# (CLLong -> CLLong :: *))
                     GHC.Int.$fNumInt64_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CLLong[0])
                             :: (Integer -> Int64 :: *) ~R# (Integer -> CLLong :: *))]
Foreign.C.Types.$fNumCLLong
  = GHC.Num.C:Num
      @ CLLong
      (GHC.Int.$fNumInt64_$c+
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLLong -> CLLong -> CLLong :: *)))
      (GHC.Int.$fNumInt64_$c-
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLLong -> CLLong -> CLLong :: *)))
      (GHC.Int.$fNumInt64_$c*
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLLong -> CLLong -> CLLong :: *)))
      (GHC.Int.$fNumInt64_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int64 :: *) ~R# (CLLong -> CLLong :: *)))
      (GHC.Int.$fNumInt64_$cabs
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int64 :: *) ~R# (CLLong -> CLLong :: *)))
      (GHC.Int.$fNumInt64_$csignum
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int64 :: *) ~R# (CLLong -> CLLong :: *)))
      (GHC.Int.$fNumInt64_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Integer -> Int64 :: *) ~R# (Integer -> CLLong :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCLLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CLLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CLLong
                        GHC.Int.eqInt64
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R <Bool>_R
                                :: (Int64 -> Int64 -> Bool :: *)
                                   ~R# (CLLong -> CLLong -> Bool :: *))
                        GHC.Int.neInt64
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R <Bool>_R
                                :: (Int64 -> Int64 -> Bool :: *)
                                   ~R# (CLLong -> CLLong -> Bool :: *))]
Foreign.C.Types.$fEqCLLong
  = GHC.Classes.C:Eq
      @ CLLong
      (GHC.Int.eqInt64
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CLLong -> CLLong -> Bool :: *)))
      (GHC.Int.neInt64
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CLLong -> CLLong -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCLLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CLLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CLLong
                         Foreign.C.Types.$fEqCLLong
                         GHC.Int.$fOrdInt64_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                 ->_R <Ordering>_R
                                 :: (Int64 -> Int64 -> Ordering :: *)
                                    ~R# (CLLong -> CLLong -> Ordering :: *))
                         GHC.Int.ltInt64
                         `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CLLong -> CLLong -> Bool :: *))
                         GHC.Int.leInt64
                         `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CLLong -> CLLong -> Bool :: *))
                         GHC.Int.gtInt64
                         `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CLLong -> CLLong -> Bool :: *))
                         GHC.Int.geInt64
                         `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *)
                                    ~R# (CLLong -> CLLong -> Bool :: *))
                         GHC.Int.$fOrdInt64_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                 :: (Int64 -> Int64 -> Int64 :: *)
                                    ~R# (CLLong -> CLLong -> CLLong :: *))
                         GHC.Int.$fOrdInt64_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                 :: (Int64 -> Int64 -> Int64 :: *)
                                    ~R# (CLLong -> CLLong -> CLLong :: *))]
Foreign.C.Types.$fOrdCLLong
  = GHC.Classes.C:Ord
      @ CLLong
      Foreign.C.Types.$fEqCLLong
      (GHC.Int.$fOrdInt64_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R <Ordering>_R
               :: (Int64 -> Int64 -> Ordering :: *)
                  ~R# (CLLong -> CLLong -> Ordering :: *)))
      (GHC.Int.ltInt64
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CLLong -> CLLong -> Bool :: *)))
      (GHC.Int.leInt64
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CLLong -> CLLong -> Bool :: *)))
      (GHC.Int.gtInt64
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CLLong -> CLLong -> Bool :: *)))
      (GHC.Int.geInt64
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CLLong -> CLLong -> Bool :: *)))
      (GHC.Int.$fOrdInt64_$cmax
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLLong -> CLLong -> CLLong :: *)))
      (GHC.Int.$fOrdInt64_$cmin
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLLong -> CLLong -> CLLong :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCLLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CLLong
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CLLong
                       Foreign.C.Types.$fNumCLLong
                       Foreign.C.Types.$fOrdCLLong
                       GHC.Int.$fRealInt64_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Ratio Integer>_R
                               :: (Int64 -> Ratio Integer :: *)
                                  ~R# (CLLong -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCLLong
  = GHC.Real.C:Real
      @ CLLong
      Foreign.C.Types.$fNumCLLong
      Foreign.C.Types.$fOrdCLLong
      (GHC.Int.$fRealInt64_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Ratio Integer>_R
               :: (Int64 -> Ratio Integer :: *)
                  ~R# (CLLong -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.C.Types.$fIntegralCLLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral CLLong
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: CLLong
                           Foreign.C.Types.$fRealCLLong
                           Foreign.C.Types.$fEnumCLLong
                           GHC.Int.$fIntegralInt64_$cquot
                           `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                   :: (Int64 -> Int64 -> Int64 :: *)
                                      ~R# (CLLong -> CLLong -> CLLong :: *))
                           GHC.Int.$fIntegralInt64_$crem
                           `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                   :: (Int64 -> Int64 -> Int64 :: *)
                                      ~R# (CLLong -> CLLong -> CLLong :: *))
                           GHC.Int.$fIntegralInt64_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                   :: (Int64 -> Int64 -> Int64 :: *)
                                      ~R# (CLLong -> CLLong -> CLLong :: *))
                           GHC.Int.$fIntegralInt64_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                   :: (Int64 -> Int64 -> Int64 :: *)
                                      ~R# (CLLong -> CLLong -> CLLong :: *))
                           GHC.Int.$fIntegralInt64_$cquotRem
                           `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CLLong[0]))
                                           (Sym (Foreign.C.Types.N:CLLong[0])))_R
                                   :: (Int64 -> Int64 -> (Int64, Int64) :: *)
                                      ~R# (CLLong -> CLLong -> (CLLong, CLLong) :: *))
                           GHC.Int.$fIntegralInt64_$cdivMod
                           `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CLLong[0]))
                                           (Sym (Foreign.C.Types.N:CLLong[0])))_R
                                   :: (Int64 -> Int64 -> (Int64, Int64) :: *)
                                      ~R# (CLLong -> CLLong -> (CLLong, CLLong) :: *))
                           GHC.Int.$fIntegralInt64_$ctoInteger
                           `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Integer>_R
                                   :: (Int64 -> Integer :: *) ~R# (CLLong -> Integer :: *))]
Foreign.C.Types.$fIntegralCLLong
  = GHC.Real.C:Integral
      @ CLLong
      Foreign.C.Types.$fRealCLLong
      Foreign.C.Types.$fEnumCLLong
      (GHC.Int.$fIntegralInt64_$cquot
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLLong -> CLLong -> CLLong :: *)))
      (GHC.Int.$fIntegralInt64_$crem
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLLong -> CLLong -> CLLong :: *)))
      (GHC.Int.$fIntegralInt64_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLLong -> CLLong -> CLLong :: *)))
      (GHC.Int.$fIntegralInt64_$cmod
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLLong -> CLLong -> CLLong :: *)))
      (GHC.Int.$fIntegralInt64_$cquotRem
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CLLong[0]))
                       (Sym (Foreign.C.Types.N:CLLong[0])))_R
               :: (Int64 -> Int64 -> (Int64, Int64) :: *)
                  ~R# (CLLong -> CLLong -> (CLLong, CLLong) :: *)))
      (GHC.Int.$fIntegralInt64_$cdivMod
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CLLong[0]))
                       (Sym (Foreign.C.Types.N:CLLong[0])))_R
               :: (Int64 -> Int64 -> (Int64, Int64) :: *)
                  ~R# (CLLong -> CLLong -> (CLLong, CLLong) :: *)))
      (GHC.Int.$fIntegralInt64_$ctoInteger
       `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Integer>_R
               :: (Int64 -> Integer :: *) ~R# (CLLong -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.C.Types.$fBitsCLLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits CLLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: CLLong
                        Foreign.C.Types.$fEqCLLong
                        GHC.Int.$fBitsInt64_$c.&.
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                :: (Int64 -> Int64 -> Int64 :: *)
                                   ~R# (CLLong -> CLLong -> CLLong :: *))
                        GHC.Int.$fBitsInt64_$c.|.
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                :: (Int64 -> Int64 -> Int64 :: *)
                                   ~R# (CLLong -> CLLong -> CLLong :: *))
                        GHC.Int.$fBitsInt64_$cxor
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                :: (Int64 -> Int64 -> Int64 :: *)
                                   ~R# (CLLong -> CLLong -> CLLong :: *))
                        GHC.Int.$fBitsInt64_$ccomplement
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                :: (Int64 -> Int64 :: *) ~R# (CLLong -> CLLong :: *))
                        GHC.Int.$fBitsInt64_$cshift
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLLong -> Int -> CLLong :: *))
                        GHC.Int.$fBitsInt64_$crotate
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLLong -> Int -> CLLong :: *))
                        GHC.Int.$fBitsInt10
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                :: (Int64 :: *) ~R# (CLLong :: *))
                        GHC.Int.$fBitsInt64_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                :: (Int -> Int64 :: *) ~R# (Int -> CLLong :: *))
                        GHC.Int.$fBitsInt64_$csetBit
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLLong -> Int -> CLLong :: *))
                        GHC.Int.$fBitsInt64_$cclearBit
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLLong -> Int -> CLLong :: *))
                        GHC.Int.$fBitsInt64_$ccomplementBit
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLLong -> Int -> CLLong :: *))
                        GHC.Int.$fBitsInt64_$ctestBit
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Int -> Bool>_R
                                :: (Int64 -> Int -> Bool :: *) ~R# (CLLong -> Int -> Bool :: *))
                        GHC.Int.$fBitsInt64_$cbitSizeMaybe
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Maybe Int>_R
                                :: (Int64 -> Maybe Int :: *) ~R# (CLLong -> Maybe Int :: *))
                        GHC.Int.$fBitsInt64_$cfiniteBitSize
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Int>_R
                                :: (Int64 -> Int :: *) ~R# (CLLong -> Int :: *))
                        GHC.Int.$fBitsInt64_$cisSigned
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Bool>_R
                                :: (Int64 -> Bool :: *) ~R# (CLLong -> Bool :: *))
                        GHC.Int.$fBitsInt64_$cshiftL
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLLong -> Int -> CLLong :: *))
                        GHC.Int.$fBitsInt64_$cunsafeShiftL
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLLong -> Int -> CLLong :: *))
                        GHC.Int.$fBitsInt64_$cshiftR
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLLong -> Int -> CLLong :: *))
                        GHC.Int.$fBitsInt64_$cunsafeShiftR
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLLong -> Int -> CLLong :: *))
                        GHC.Int.$fBitsInt64_$crotateL
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLLong -> Int -> CLLong :: *))
                        GHC.Int.$fBitsInt64_$crotateR
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLLong -> Int -> CLLong :: *))
                        GHC.Int.$fBitsInt64_$cpopCount
                        `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Int>_R
                                :: (Int64 -> Int :: *) ~R# (CLLong -> Int :: *))]
Foreign.C.Types.$fBitsCLLong
  = Data.Bits.C:Bits
      @ CLLong
      Foreign.C.Types.$fEqCLLong
      (GHC.Int.$fBitsInt64_$c.&.
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLLong -> CLLong -> CLLong :: *)))
      (GHC.Int.$fBitsInt64_$c.|.
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLLong -> CLLong -> CLLong :: *)))
      (GHC.Int.$fBitsInt64_$cxor
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLLong -> CLLong -> CLLong :: *)))
      (GHC.Int.$fBitsInt64_$ccomplement
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int64 :: *) ~R# (CLLong -> CLLong :: *)))
      (GHC.Int.$fBitsInt64_$cshift
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CLLong -> Int -> CLLong :: *)))
      (GHC.Int.$fBitsInt64_$crotate
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CLLong -> Int -> CLLong :: *)))
      (GHC.Int.$fBitsInt10
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 :: *) ~R# (CLLong :: *)))
      (GHC.Int.$fBitsInt64_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int -> Int64 :: *) ~R# (Int -> CLLong :: *)))
      (GHC.Int.$fBitsInt64_$csetBit
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CLLong -> Int -> CLLong :: *)))
      (GHC.Int.$fBitsInt64_$cclearBit
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CLLong -> Int -> CLLong :: *)))
      (GHC.Int.$fBitsInt64_$ccomplementBit
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CLLong -> Int -> CLLong :: *)))
      (GHC.Int.$fBitsInt64_$ctestBit
       `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Int -> Bool>_R
               :: (Int64 -> Int -> Bool :: *) ~R# (CLLong -> Int -> Bool :: *)))
      (GHC.Int.$fBitsInt64_$cbitSizeMaybe
       `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Maybe Int>_R
               :: (Int64 -> Maybe Int :: *) ~R# (CLLong -> Maybe Int :: *)))
      (GHC.Int.$fBitsInt64_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CLLong -> Int :: *)))
      (GHC.Int.$fBitsInt64_$cisSigned
       `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Bool>_R
               :: (Int64 -> Bool :: *) ~R# (CLLong -> Bool :: *)))
      (GHC.Int.$fBitsInt64_$cshiftL
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CLLong -> Int -> CLLong :: *)))
      (GHC.Int.$fBitsInt64_$cunsafeShiftL
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CLLong -> Int -> CLLong :: *)))
      (GHC.Int.$fBitsInt64_$cshiftR
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CLLong -> Int -> CLLong :: *)))
      (GHC.Int.$fBitsInt64_$cunsafeShiftR
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CLLong -> Int -> CLLong :: *)))
      (GHC.Int.$fBitsInt64_$crotateL
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CLLong -> Int -> CLLong :: *)))
      (GHC.Int.$fBitsInt64_$crotateR
       `cast` (Sym (Foreign.C.Types.N:CLLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLLong[0])
               :: (Int64 -> Int -> Int64 :: *)
                  ~R# (CLLong -> Int -> CLLong :: *)))
      (GHC.Int.$fBitsInt64_$cpopCount
       `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CLLong -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.C.Types.$fFiniteBitsCLLong [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits CLLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: CLLong
                              Foreign.C.Types.$fBitsCLLong
                              GHC.Int.$fBitsInt64_$cfiniteBitSize
                              `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Int>_R
                                      :: (Int64 -> Int :: *) ~R# (CLLong -> Int :: *))
                              GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros
                              `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Int>_R
                                      :: (Int64 -> Int :: *) ~R# (CLLong -> Int :: *))
                              GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros
                              `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Int>_R
                                      :: (Int64 -> Int :: *) ~R# (CLLong -> Int :: *))]
Foreign.C.Types.$fFiniteBitsCLLong
  = Data.Bits.C:FiniteBits
      @ CLLong
      Foreign.C.Types.$fBitsCLLong
      (GHC.Int.$fBitsInt64_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CLLong -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros
       `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CLLong -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros
       `cast` (Sym (Foreign.C.Types.N:CLLong[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CLLong -> Int :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCULong [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CULong
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CULong
                       GHC.Word.$fShowWord64_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CULong[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Word64 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CULong -> [Char] -> [Char] :: *))
                       GHC.Word.$fShowWord64_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <[Char]>_R
                               :: (Word64 -> [Char] :: *) ~R# (CULong -> [Char] :: *))
                       GHC.Word.$fShowWord64_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CULong[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Word64] -> [Char] -> [Char] :: *)
                                  ~R# ([CULong] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCULong
  = GHC.Show.C:Show
      @ CULong
      (GHC.Word.$fShowWord64_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Word64 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CULong -> [Char] -> [Char] :: *)))
      (GHC.Word.$fShowWord64_$cshow
       `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <[Char]>_R
               :: (Word64 -> [Char] :: *) ~R# (CULong -> [Char] :: *)))
      (GHC.Word.$fShowWord64_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CULong[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Word64] -> [Char] -> [Char] :: *)
                  ~R# ([CULong] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCULong [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CULong
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CULong
                       GHC.Read.$fReadWord64_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CULong[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Word64, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CULong, [Char])] :: *))
                       GHC.Read.$fReadWord64_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CULong[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Word64], [Char])] :: *)
                                  ~R# ([Char] -> [([CULong], [Char])] :: *))
                       GHC.Read.$fReadWord13
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Word64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      (Foreign.C.Types.N:CULong[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Word64 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CULong :: *))
                       GHC.Read.$fReadWord11
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Word64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                        ([Foreign.C.Types.N:CULong[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Word64] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CULong] :: *))]
Foreign.C.Types.$fReadCULong
  = GHC.Read.C:Read
      @ CULong
      (GHC.Read.$fReadWord64_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CULong[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Word64, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CULong, [Char])] :: *)))
      (GHC.Read.$fReadWord64_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CULong[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Word64], [Char])] :: *)
                  ~R# ([Char] -> [([CULong], [Char])] :: *)))
      (GHC.Read.$fReadWord13
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Word64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                      (Foreign.C.Types.N:CULong[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Word64 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CULong :: *)))
      (GHC.Read.$fReadWord11
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Word64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        ([Foreign.C.Types.N:CULong[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Word64] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CULong] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.C.Types.$fBoundedCULong [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded CULong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: CULong
                          GHC.Word.$fBitsWord7
                          `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                  :: (Word64 :: *) ~R# (CULong :: *))
                          GHC.Word.$fBoundedWord64_$cmaxBound
                          `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                  :: (Word64 :: *) ~R# (CULong :: *))]
Foreign.C.Types.$fBoundedCULong
  = GHC.Enum.C:Bounded
      @ CULong
      (GHC.Word.$fBitsWord7
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 :: *) ~R# (CULong :: *)))
      (GHC.Word.$fBoundedWord64_$cmaxBound
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 :: *) ~R# (CULong :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCULong [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CULong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CULong
                                   Foreign.Storable.$fStorableWord64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Int>_R
                                           :: (Word64 -> Int :: *) ~R# (CULong -> Int :: *))
                                   Foreign.Storable.$fStorableWord64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Int>_R
                                           :: (Word64 -> Int :: *) ~R# (CULong -> Int :: *))
                                   GHC.Storable.readWord64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word64, CULong))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CULong[0]))
                                           :: (GHC.Ptr.Ptr Word64
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CULong -> Int -> IO CULong :: *))
                                   GHC.Storable.writeWord64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word64, CULong))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CULong[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Word64
                                               -> Int
                                               -> Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CULong
                                                   -> Int -> CULong -> IO () :: *))
                                   Foreign.Storable.$fStorableWord18
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CULong[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word64 #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> IO CULong :: *))
                                   Foreign.Storable.$fStorableWord17
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CULong[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CULong -> IO () :: *))
                                   Foreign.Storable.$fStorableWord15
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word64, CULong))_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CULong[0]))
                                           :: (GHC.Ptr.Ptr Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CULong -> IO CULong :: *))
                                   Foreign.Storable.$fStorableWord14
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word64, CULong))_R
                                           ->_R Sym (Foreign.C.Types.N:CULong[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Word64
                                               -> Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CULong -> CULong -> IO () :: *))]
Foreign.C.Types.$fStorableCULong
  = Foreign.Storable.C:Storable
      @ CULong
      (Foreign.Storable.$fStorableWord64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CULong -> Int :: *)))
      (Foreign.Storable.$fStorableWord64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CULong -> Int :: *)))
      (GHC.Storable.readWord64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word64, CULong))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CULong[0]))
               :: (GHC.Ptr.Ptr Word64
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CULong -> Int -> IO CULong :: *)))
      (GHC.Storable.writeWord64OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word64, CULong))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Word64
                   -> Int
                   -> Word64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CULong -> Int -> CULong -> IO () :: *)))
      (Foreign.Storable.$fStorableWord18
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CULong[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word64 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CULong :: *)))
      (Foreign.Storable.$fStorableWord17
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Word64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CULong -> IO () :: *)))
      (Foreign.Storable.$fStorableWord15
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word64, CULong))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CULong[0]))
               :: (GHC.Ptr.Ptr Word64
                   -> State# RealWorld -> (# State# RealWorld, Word64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CULong -> IO CULong :: *)))
      (Foreign.Storable.$fStorableWord14
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word64, CULong))_R
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Word64
                   -> Word64 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CULong -> CULong -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCULong [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CULong
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CULong
                       GHC.Word.$fEnumWord64_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CULong[0])
                               ->_R Sym (Foreign.C.Types.N:CULong[0])
                               :: (Word64 -> Word64 :: *) ~R# (CULong -> CULong :: *))
                       GHC.Word.$fEnumWord64_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CULong[0])
                               ->_R Sym (Foreign.C.Types.N:CULong[0])
                               :: (Word64 -> Word64 :: *) ~R# (CULong -> CULong :: *))
                       GHC.Word.$fEnumWord64_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CULong[0])
                               :: (Int -> Word64 :: *) ~R# (Int -> CULong :: *))
                       GHC.Word.$fEnumWord64_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Int>_R
                               :: (Word64 -> Int :: *) ~R# (CULong -> Int :: *))
                       GHC.Word.$fEnumWord64_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CULong[0])
                               ->_R ([Sym (Foreign.C.Types.N:CULong[0])])_R
                               :: (Word64 -> [Word64] :: *) ~R# (CULong -> [CULong] :: *))
                       GHC.Word.$fEnumWord64_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CULong[0])
                               ->_R Sym (Foreign.C.Types.N:CULong[0])
                               ->_R ([Sym (Foreign.C.Types.N:CULong[0])])_R
                               :: (Word64 -> Word64 -> [Word64] :: *)
                                  ~R# (CULong -> CULong -> [CULong] :: *))
                       GHC.Word.$fEnumWord64_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CULong[0])
                               ->_R Sym (Foreign.C.Types.N:CULong[0])
                               ->_R ([Sym (Foreign.C.Types.N:CULong[0])])_R
                               :: (Word64 -> Word64 -> [Word64] :: *)
                                  ~R# (CULong -> CULong -> [CULong] :: *))
                       GHC.Word.$fEnumWord64_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CULong[0])
                               ->_R Sym (Foreign.C.Types.N:CULong[0])
                               ->_R Sym (Foreign.C.Types.N:CULong[0])
                               ->_R ([Sym (Foreign.C.Types.N:CULong[0])])_R
                               :: (Word64 -> Word64 -> Word64 -> [Word64] :: *)
                                  ~R# (CULong -> CULong -> CULong -> [CULong] :: *))]
Foreign.C.Types.$fEnumCULong
  = GHC.Enum.C:Enum
      @ CULong
      (GHC.Word.$fEnumWord64_$csucc
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Word64 :: *) ~R# (CULong -> CULong :: *)))
      (GHC.Word.$fEnumWord64_$cpred
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Word64 :: *) ~R# (CULong -> CULong :: *)))
      (GHC.Word.$fEnumWord64_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Int -> Word64 :: *) ~R# (Int -> CULong :: *)))
      (GHC.Word.$fEnumWord64_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CULong -> Int :: *)))
      (GHC.Word.$fEnumWord64_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R ([Sym (Foreign.C.Types.N:CULong[0])])_R
               :: (Word64 -> [Word64] :: *) ~R# (CULong -> [CULong] :: *)))
      (GHC.Word.$fEnumWord64_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R ([Sym (Foreign.C.Types.N:CULong[0])])_R
               :: (Word64 -> Word64 -> [Word64] :: *)
                  ~R# (CULong -> CULong -> [CULong] :: *)))
      (GHC.Word.$fEnumWord64_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R ([Sym (Foreign.C.Types.N:CULong[0])])_R
               :: (Word64 -> Word64 -> [Word64] :: *)
                  ~R# (CULong -> CULong -> [CULong] :: *)))
      (GHC.Word.$fEnumWord64_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R ([Sym (Foreign.C.Types.N:CULong[0])])_R
               :: (Word64 -> Word64 -> Word64 -> [Word64] :: *)
                  ~R# (CULong -> CULong -> CULong -> [CULong] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCULong [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CULong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CULong
                     GHC.Word.$fNumWord64_$c+
                     `cast` (Sym (Foreign.C.Types.N:CULong[0])
                             ->_R Sym (Foreign.C.Types.N:CULong[0])
                             ->_R Sym (Foreign.C.Types.N:CULong[0])
                             :: (Word64 -> Word64 -> Word64 :: *)
                                ~R# (CULong -> CULong -> CULong :: *))
                     GHC.Word.$fNumWord64_$c-
                     `cast` (Sym (Foreign.C.Types.N:CULong[0])
                             ->_R Sym (Foreign.C.Types.N:CULong[0])
                             ->_R Sym (Foreign.C.Types.N:CULong[0])
                             :: (Word64 -> Word64 -> Word64 :: *)
                                ~R# (CULong -> CULong -> CULong :: *))
                     GHC.Word.$fNumWord64_$c*
                     `cast` (Sym (Foreign.C.Types.N:CULong[0])
                             ->_R Sym (Foreign.C.Types.N:CULong[0])
                             ->_R Sym (Foreign.C.Types.N:CULong[0])
                             :: (Word64 -> Word64 -> Word64 :: *)
                                ~R# (CULong -> CULong -> CULong :: *))
                     GHC.Word.$fNumWord64_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CULong[0])
                             ->_R Sym (Foreign.C.Types.N:CULong[0])
                             :: (Word64 -> Word64 :: *) ~R# (CULong -> CULong :: *))
                     GHC.Word.$fNumWord64_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CULong[0])
                             ->_R Sym (Foreign.C.Types.N:CULong[0])
                             :: (Word64 -> Word64 :: *) ~R# (CULong -> CULong :: *))
                     GHC.Word.$fNumWord64_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CULong[0])
                             ->_R Sym (Foreign.C.Types.N:CULong[0])
                             :: (Word64 -> Word64 :: *) ~R# (CULong -> CULong :: *))
                     GHC.Word.$fNumWord64_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CULong[0])
                             :: (Integer -> Word64 :: *) ~R# (Integer -> CULong :: *))]
Foreign.C.Types.$fNumCULong
  = GHC.Num.C:Num
      @ CULong
      (GHC.Word.$fNumWord64_$c+
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULong -> CULong -> CULong :: *)))
      (GHC.Word.$fNumWord64_$c-
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULong -> CULong -> CULong :: *)))
      (GHC.Word.$fNumWord64_$c*
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULong -> CULong -> CULong :: *)))
      (GHC.Word.$fNumWord64_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Word64 :: *) ~R# (CULong -> CULong :: *)))
      (GHC.Word.$fNumWord64_$cabs
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Word64 :: *) ~R# (CULong -> CULong :: *)))
      (GHC.Word.$fNumWord64_$csignum
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Word64 :: *) ~R# (CULong -> CULong :: *)))
      (GHC.Word.$fNumWord64_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Integer -> Word64 :: *) ~R# (Integer -> CULong :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCULong [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CULong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CULong
                        GHC.Word.eqWord64
                        `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                ->_R Sym (Foreign.C.Types.N:CULong[0])
                                ->_R <Bool>_R
                                :: (Word64 -> Word64 -> Bool :: *)
                                   ~R# (CULong -> CULong -> Bool :: *))
                        GHC.Word.neWord64
                        `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                ->_R Sym (Foreign.C.Types.N:CULong[0])
                                ->_R <Bool>_R
                                :: (Word64 -> Word64 -> Bool :: *)
                                   ~R# (CULong -> CULong -> Bool :: *))]
Foreign.C.Types.$fEqCULong
  = GHC.Classes.C:Eq
      @ CULong
      (GHC.Word.eqWord64
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CULong -> CULong -> Bool :: *)))
      (GHC.Word.neWord64
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CULong -> CULong -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCULong [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CULong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CULong
                         Foreign.C.Types.$fEqCULong
                         GHC.Word.$fOrdWord64_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                 ->_R Sym (Foreign.C.Types.N:CULong[0])
                                 ->_R <Ordering>_R
                                 :: (Word64 -> Word64 -> Ordering :: *)
                                    ~R# (CULong -> CULong -> Ordering :: *))
                         GHC.Word.ltWord64
                         `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                 ->_R Sym (Foreign.C.Types.N:CULong[0])
                                 ->_R <Bool>_R
                                 :: (Word64 -> Word64 -> Bool :: *)
                                    ~R# (CULong -> CULong -> Bool :: *))
                         GHC.Word.leWord64
                         `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                 ->_R Sym (Foreign.C.Types.N:CULong[0])
                                 ->_R <Bool>_R
                                 :: (Word64 -> Word64 -> Bool :: *)
                                    ~R# (CULong -> CULong -> Bool :: *))
                         GHC.Word.gtWord64
                         `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                 ->_R Sym (Foreign.C.Types.N:CULong[0])
                                 ->_R <Bool>_R
                                 :: (Word64 -> Word64 -> Bool :: *)
                                    ~R# (CULong -> CULong -> Bool :: *))
                         GHC.Word.geWord64
                         `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                 ->_R Sym (Foreign.C.Types.N:CULong[0])
                                 ->_R <Bool>_R
                                 :: (Word64 -> Word64 -> Bool :: *)
                                    ~R# (CULong -> CULong -> Bool :: *))
                         GHC.Word.$fOrdWord64_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                 ->_R Sym (Foreign.C.Types.N:CULong[0])
                                 ->_R Sym (Foreign.C.Types.N:CULong[0])
                                 :: (Word64 -> Word64 -> Word64 :: *)
                                    ~R# (CULong -> CULong -> CULong :: *))
                         GHC.Word.$fOrdWord64_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                 ->_R Sym (Foreign.C.Types.N:CULong[0])
                                 ->_R Sym (Foreign.C.Types.N:CULong[0])
                                 :: (Word64 -> Word64 -> Word64 :: *)
                                    ~R# (CULong -> CULong -> CULong :: *))]
Foreign.C.Types.$fOrdCULong
  = GHC.Classes.C:Ord
      @ CULong
      Foreign.C.Types.$fEqCULong
      (GHC.Word.$fOrdWord64_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R <Ordering>_R
               :: (Word64 -> Word64 -> Ordering :: *)
                  ~R# (CULong -> CULong -> Ordering :: *)))
      (GHC.Word.ltWord64
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CULong -> CULong -> Bool :: *)))
      (GHC.Word.leWord64
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CULong -> CULong -> Bool :: *)))
      (GHC.Word.gtWord64
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CULong -> CULong -> Bool :: *)))
      (GHC.Word.geWord64
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R <Bool>_R
               :: (Word64 -> Word64 -> Bool :: *)
                  ~R# (CULong -> CULong -> Bool :: *)))
      (GHC.Word.$fOrdWord64_$cmax
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULong -> CULong -> CULong :: *)))
      (GHC.Word.$fOrdWord64_$cmin
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULong -> CULong -> CULong :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCULong [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CULong
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CULong
                       Foreign.C.Types.$fNumCULong
                       Foreign.C.Types.$fOrdCULong
                       GHC.Word.$fRealWord64_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Ratio Integer>_R
                               :: (Word64 -> Ratio Integer :: *)
                                  ~R# (CULong -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCULong
  = GHC.Real.C:Real
      @ CULong
      Foreign.C.Types.$fNumCULong
      Foreign.C.Types.$fOrdCULong
      (GHC.Word.$fRealWord64_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Ratio Integer>_R
               :: (Word64 -> Ratio Integer :: *)
                  ~R# (CULong -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.C.Types.$fIntegralCULong [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral CULong
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: CULong
                           Foreign.C.Types.$fRealCULong
                           Foreign.C.Types.$fEnumCULong
                           GHC.Word.$fIntegralWord64_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                   ->_R Sym (Foreign.C.Types.N:CULong[0])
                                   ->_R Sym (Foreign.C.Types.N:CULong[0])
                                   :: (Word64 -> Word64 -> Word64 :: *)
                                      ~R# (CULong -> CULong -> CULong :: *))
                           GHC.Word.$fIntegralWord64_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                   ->_R Sym (Foreign.C.Types.N:CULong[0])
                                   ->_R Sym (Foreign.C.Types.N:CULong[0])
                                   :: (Word64 -> Word64 -> Word64 :: *)
                                      ~R# (CULong -> CULong -> CULong :: *))
                           GHC.Word.$fIntegralWord64_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                   ->_R Sym (Foreign.C.Types.N:CULong[0])
                                   ->_R Sym (Foreign.C.Types.N:CULong[0])
                                   :: (Word64 -> Word64 -> Word64 :: *)
                                      ~R# (CULong -> CULong -> CULong :: *))
                           GHC.Word.$fIntegralWord64_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                   ->_R Sym (Foreign.C.Types.N:CULong[0])
                                   ->_R Sym (Foreign.C.Types.N:CULong[0])
                                   :: (Word64 -> Word64 -> Word64 :: *)
                                      ~R# (CULong -> CULong -> CULong :: *))
                           GHC.Word.$fIntegralWord64_$cquotRem
                           `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                   ->_R Sym (Foreign.C.Types.N:CULong[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CULong[0]))
                                           (Sym (Foreign.C.Types.N:CULong[0])))_R
                                   :: (Word64 -> Word64 -> (Word64, Word64) :: *)
                                      ~R# (CULong -> CULong -> (CULong, CULong) :: *))
                           GHC.Word.$fIntegralWord64_$cdivMod
                           `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                   ->_R Sym (Foreign.C.Types.N:CULong[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CULong[0]))
                                           (Sym (Foreign.C.Types.N:CULong[0])))_R
                                   :: (Word64 -> Word64 -> (Word64, Word64) :: *)
                                      ~R# (CULong -> CULong -> (CULong, CULong) :: *))
                           GHC.Word.$fIntegralWord64_$ctoInteger
                           `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Integer>_R
                                   :: (Word64 -> Integer :: *) ~R# (CULong -> Integer :: *))]
Foreign.C.Types.$fIntegralCULong
  = GHC.Real.C:Integral
      @ CULong
      Foreign.C.Types.$fRealCULong
      Foreign.C.Types.$fEnumCULong
      (GHC.Word.$fIntegralWord64_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULong -> CULong -> CULong :: *)))
      (GHC.Word.$fIntegralWord64_$cmod
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULong -> CULong -> CULong :: *)))
      (GHC.Word.$fIntegralWord64_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULong -> CULong -> CULong :: *)))
      (GHC.Word.$fIntegralWord64_$cmod
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULong -> CULong -> CULong :: *)))
      (GHC.Word.$fIntegralWord64_$cquotRem
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CULong[0]))
                       (Sym (Foreign.C.Types.N:CULong[0])))_R
               :: (Word64 -> Word64 -> (Word64, Word64) :: *)
                  ~R# (CULong -> CULong -> (CULong, CULong) :: *)))
      (GHC.Word.$fIntegralWord64_$cdivMod
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CULong[0]))
                       (Sym (Foreign.C.Types.N:CULong[0])))_R
               :: (Word64 -> Word64 -> (Word64, Word64) :: *)
                  ~R# (CULong -> CULong -> (CULong, CULong) :: *)))
      (GHC.Word.$fIntegralWord64_$ctoInteger
       `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Integer>_R
               :: (Word64 -> Integer :: *) ~R# (CULong -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.C.Types.$fBitsCULong [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits CULong
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: CULong
                        Foreign.C.Types.$fEqCULong
                        GHC.Word.$fBitsWord64_$c.&.
                        `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                ->_R Sym (Foreign.C.Types.N:CULong[0])
                                ->_R Sym (Foreign.C.Types.N:CULong[0])
                                :: (Word64 -> Word64 -> Word64 :: *)
                                   ~R# (CULong -> CULong -> CULong :: *))
                        GHC.Word.$fBitsWord64_$c.|.
                        `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                ->_R Sym (Foreign.C.Types.N:CULong[0])
                                ->_R Sym (Foreign.C.Types.N:CULong[0])
                                :: (Word64 -> Word64 -> Word64 :: *)
                                   ~R# (CULong -> CULong -> CULong :: *))
                        GHC.Word.$fBitsWord64_$cxor
                        `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                ->_R Sym (Foreign.C.Types.N:CULong[0])
                                ->_R Sym (Foreign.C.Types.N:CULong[0])
                                :: (Word64 -> Word64 -> Word64 :: *)
                                   ~R# (CULong -> CULong -> CULong :: *))
                        GHC.Word.$fBitsWord64_$ccomplement
                        `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                ->_R Sym (Foreign.C.Types.N:CULong[0])
                                :: (Word64 -> Word64 :: *) ~R# (CULong -> CULong :: *))
                        GHC.Word.$fBitsWord64_$cshift
                        `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULong -> Int -> CULong :: *))
                        GHC.Word.$fBitsWord64_$crotate
                        `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULong -> Int -> CULong :: *))
                        GHC.Word.$fBitsWord7
                        `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                :: (Word64 :: *) ~R# (CULong :: *))
                        GHC.Word.$fBitsWord64_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CULong[0])
                                :: (Int -> Word64 :: *) ~R# (Int -> CULong :: *))
                        GHC.Word.$fBitsWord64_$csetBit
                        `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULong -> Int -> CULong :: *))
                        GHC.Word.$fBitsWord64_$cclearBit
                        `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULong -> Int -> CULong :: *))
                        GHC.Word.$fBitsWord64_$ccomplementBit
                        `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULong -> Int -> CULong :: *))
                        GHC.Word.$fBitsWord64_$ctestBit
                        `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Int -> Bool>_R
                                :: (Word64 -> Int -> Bool :: *) ~R# (CULong -> Int -> Bool :: *))
                        GHC.Word.$fBitsWord64_$cbitSizeMaybe
                        `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Maybe Int>_R
                                :: (Word64 -> Maybe Int :: *) ~R# (CULong -> Maybe Int :: *))
                        GHC.Word.$fBitsWord64_$cfiniteBitSize
                        `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Int>_R
                                :: (Word64 -> Int :: *) ~R# (CULong -> Int :: *))
                        GHC.Word.$fBitsWord64_$cisSigned
                        `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Bool>_R
                                :: (Word64 -> Bool :: *) ~R# (CULong -> Bool :: *))
                        GHC.Word.$fBitsWord64_$cshiftL
                        `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULong -> Int -> CULong :: *))
                        GHC.Word.$fBitsWord64_$cunsafeShiftL
                        `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULong -> Int -> CULong :: *))
                        GHC.Word.$fBitsWord64_$cshiftR
                        `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULong -> Int -> CULong :: *))
                        GHC.Word.$fBitsWord64_$cunsafeShiftR
                        `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULong -> Int -> CULong :: *))
                        GHC.Word.$fBitsWord64_$crotateL
                        `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULong -> Int -> CULong :: *))
                        GHC.Word.$fBitsWord64_$crotateR
                        `cast` (Sym (Foreign.C.Types.N:CULong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CULong[0])
                                :: (Word64 -> Int -> Word64 :: *)
                                   ~R# (CULong -> Int -> CULong :: *))
                        GHC.Word.$fBitsWord64_$cpopCount
                        `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Int>_R
                                :: (Word64 -> Int :: *) ~R# (CULong -> Int :: *))]
Foreign.C.Types.$fBitsCULong
  = Data.Bits.C:Bits
      @ CULong
      Foreign.C.Types.$fEqCULong
      (GHC.Word.$fBitsWord64_$c.&.
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULong -> CULong -> CULong :: *)))
      (GHC.Word.$fBitsWord64_$c.|.
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULong -> CULong -> CULong :: *)))
      (GHC.Word.$fBitsWord64_$cxor
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Word64 -> Word64 :: *)
                  ~R# (CULong -> CULong -> CULong :: *)))
      (GHC.Word.$fBitsWord64_$ccomplement
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Word64 :: *) ~R# (CULong -> CULong :: *)))
      (GHC.Word.$fBitsWord64_$cshift
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULong -> Int -> CULong :: *)))
      (GHC.Word.$fBitsWord64_$crotate
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULong -> Int -> CULong :: *)))
      (GHC.Word.$fBitsWord7
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 :: *) ~R# (CULong :: *)))
      (GHC.Word.$fBitsWord64_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Int -> Word64 :: *) ~R# (Int -> CULong :: *)))
      (GHC.Word.$fBitsWord64_$csetBit
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULong -> Int -> CULong :: *)))
      (GHC.Word.$fBitsWord64_$cclearBit
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULong -> Int -> CULong :: *)))
      (GHC.Word.$fBitsWord64_$ccomplementBit
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULong -> Int -> CULong :: *)))
      (GHC.Word.$fBitsWord64_$ctestBit
       `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Int -> Bool>_R
               :: (Word64 -> Int -> Bool :: *) ~R# (CULong -> Int -> Bool :: *)))
      (GHC.Word.$fBitsWord64_$cbitSizeMaybe
       `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Maybe Int>_R
               :: (Word64 -> Maybe Int :: *) ~R# (CULong -> Maybe Int :: *)))
      (GHC.Word.$fBitsWord64_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CULong -> Int :: *)))
      (GHC.Word.$fBitsWord64_$cisSigned
       `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Bool>_R
               :: (Word64 -> Bool :: *) ~R# (CULong -> Bool :: *)))
      (GHC.Word.$fBitsWord64_$cshiftL
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULong -> Int -> CULong :: *)))
      (GHC.Word.$fBitsWord64_$cunsafeShiftL
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULong -> Int -> CULong :: *)))
      (GHC.Word.$fBitsWord64_$cshiftR
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULong -> Int -> CULong :: *)))
      (GHC.Word.$fBitsWord64_$cunsafeShiftR
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULong -> Int -> CULong :: *)))
      (GHC.Word.$fBitsWord64_$crotateL
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULong -> Int -> CULong :: *)))
      (GHC.Word.$fBitsWord64_$crotateR
       `cast` (Sym (Foreign.C.Types.N:CULong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CULong[0])
               :: (Word64 -> Int -> Word64 :: *)
                  ~R# (CULong -> Int -> CULong :: *)))
      (GHC.Word.$fBitsWord64_$cpopCount
       `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CULong -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.C.Types.$fFiniteBitsCULong [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits CULong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: CULong
                              Foreign.C.Types.$fBitsCULong
                              GHC.Word.$fBitsWord64_$cfiniteBitSize
                              `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Int>_R
                                      :: (Word64 -> Int :: *) ~R# (CULong -> Int :: *))
                              GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
                              `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Int>_R
                                      :: (Word64 -> Int :: *) ~R# (CULong -> Int :: *))
                              GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros
                              `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Int>_R
                                      :: (Word64 -> Int :: *) ~R# (CULong -> Int :: *))]
Foreign.C.Types.$fFiniteBitsCULong
  = Data.Bits.C:FiniteBits
      @ CULong
      Foreign.C.Types.$fBitsCULong
      (GHC.Word.$fBitsWord64_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CULong -> Int :: *)))
      (GHC.Word.$fFiniteBitsWord64_$ccountLeadingZeros
       `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CULong -> Int :: *)))
      (GHC.Word.$fFiniteBitsWord64_$ccountTrailingZeros
       `cast` (Sym (Foreign.C.Types.N:CULong[0]) ->_R <Int>_R
               :: (Word64 -> Int :: *) ~R# (CULong -> Int :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CLong
                       GHC.Int.$fShowInt64_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CLong[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Int64 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CLong -> [Char] -> [Char] :: *))
                       GHC.Int.$fShowInt64_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <[Char]>_R
                               :: (Int64 -> [Char] :: *) ~R# (CLong -> [Char] :: *))
                       GHC.Int.$fShowInt64_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CLong[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Int64] -> [Char] -> [Char] :: *)
                                  ~R# ([CLong] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCLong
  = GHC.Show.C:Show
      @ CLong
      (GHC.Int.$fShowInt64_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Int64 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CLong -> [Char] -> [Char] :: *)))
      (GHC.Int.$fShowInt64_$cshow
       `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <[Char]>_R
               :: (Int64 -> [Char] :: *) ~R# (CLong -> [Char] :: *)))
      (GHC.Int.$fShowInt64_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CLong[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Int64] -> [Char] -> [Char] :: *)
                  ~R# ([CLong] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CLong
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CLong
                       GHC.Int.$fReadInt64_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CLong[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Int64, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CLong, [Char])] :: *))
                       GHC.Int.$fReadInt64_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CLong[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Int64], [Char])] :: *)
                                  ~R# ([Char] -> [([CLong], [Char])] :: *))
                       GHC.Int.$fReadInt10
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Int64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     (Foreign.C.Types.N:CLong[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Int64 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CLong :: *))
                       GHC.Int.$fReadInt7
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Int64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       ([Foreign.C.Types.N:CLong[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Int64] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CLong] :: *))]
Foreign.C.Types.$fReadCLong
  = GHC.Read.C:Read
      @ CLong
      (GHC.Int.$fReadInt64_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CLong[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Int64, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CLong, [Char])] :: *)))
      (GHC.Int.$fReadInt64_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CLong[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Int64], [Char])] :: *)
                  ~R# ([Char] -> [([CLong], [Char])] :: *)))
      (GHC.Int.$fReadInt10
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Int64>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                     (Foreign.C.Types.N:CLong[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Int64 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CLong :: *)))
      (GHC.Int.$fReadInt7
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Int64]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       ([Foreign.C.Types.N:CLong[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Int64] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CLong] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.C.Types.$fBoundedCLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded CLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: CLong
                          GHC.Int.$fBoundedInt64_$cminBound
                          `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                  :: (Int64 :: *) ~R# (CLong :: *))
                          GHC.Int.$fBoundedInt64_$cmaxBound
                          `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                  :: (Int64 :: *) ~R# (CLong :: *))]
Foreign.C.Types.$fBoundedCLong
  = GHC.Enum.C:Bounded
      @ CLong
      (GHC.Int.$fBoundedInt64_$cminBound
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 :: *) ~R# (CLong :: *)))
      (GHC.Int.$fBoundedInt64_$cmaxBound
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 :: *) ~R# (CLong :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CLong
                                   Foreign.Storable.$fStorableInt64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Int>_R
                                           :: (Int64 -> Int :: *) ~R# (CLong -> Int :: *))
                                   Foreign.Storable.$fStorableInt64_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Int>_R
                                           :: (Int64 -> Int :: *) ~R# (CLong -> Int :: *))
                                   GHC.Storable.readInt64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CLong))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CLong[0]))
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CLong -> Int -> IO CLong :: *))
                                   GHC.Storable.writeInt64OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CLong))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CLong[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CLong -> Int -> CLong -> IO () :: *))
                                   Foreign.Storable.$fStorableInt19
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CLong[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CLong :: *))
                                   Foreign.Storable.$fStorableInt18
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CLong[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CLong -> IO () :: *))
                                   Foreign.Storable.$fStorableInt17
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CLong))_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CLong[0]))
                                           :: (GHC.Ptr.Ptr Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CLong -> IO CLong :: *))
                                   Foreign.Storable.$fStorableInt15
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int64, CLong))_R
                                           ->_R Sym (Foreign.C.Types.N:CLong[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int64
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CLong -> CLong -> IO () :: *))]
Foreign.C.Types.$fStorableCLong
  = Foreign.Storable.C:Storable
      @ CLong
      (Foreign.Storable.$fStorableInt64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CLong -> Int :: *)))
      (Foreign.Storable.$fStorableInt64_$calignment
       `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CLong -> Int :: *)))
      (GHC.Storable.readInt64OffPtr1
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Int64, CLong))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CLong[0]))
               :: (GHC.Ptr.Ptr Int64
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CLong -> Int -> IO CLong :: *)))
      (GHC.Storable.writeInt64OffPtr1
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Int64, CLong))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int64
                   -> Int
                   -> Int64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CLong -> Int -> CLong -> IO () :: *)))
      (Foreign.Storable.$fStorableInt19
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CLong[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CLong :: *)))
      (Foreign.Storable.$fStorableInt18
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Int64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CLong -> IO () :: *)))
      (Foreign.Storable.$fStorableInt17
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Int64, CLong))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CLong[0]))
               :: (GHC.Ptr.Ptr Int64
                   -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (GHC.Ptr.Ptr CLong -> IO CLong :: *)))
      (Foreign.Storable.$fStorableInt15
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Int64, CLong))_R
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int64
                   -> Int64 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CLong -> CLong -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CLong
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CLong
                       GHC.Int.$fEnumInt64_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CLong[0])
                               ->_R Sym (Foreign.C.Types.N:CLong[0])
                               :: (Int64 -> Int64 :: *) ~R# (CLong -> CLong :: *))
                       GHC.Int.$fEnumInt64_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CLong[0])
                               ->_R Sym (Foreign.C.Types.N:CLong[0])
                               :: (Int64 -> Int64 :: *) ~R# (CLong -> CLong :: *))
                       GHC.Int.$fEnumInt64_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CLong[0])
                               :: (Int -> Int64 :: *) ~R# (Int -> CLong :: *))
                       GHC.Int.$fEnumInt64_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Int>_R
                               :: (Int64 -> Int :: *) ~R# (CLong -> Int :: *))
                       GHC.Int.$fEnumInt64_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CLong[0])
                               ->_R ([Sym (Foreign.C.Types.N:CLong[0])])_R
                               :: (Int64 -> [Int64] :: *) ~R# (CLong -> [CLong] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CLong[0])
                               ->_R Sym (Foreign.C.Types.N:CLong[0])
                               ->_R ([Sym (Foreign.C.Types.N:CLong[0])])_R
                               :: (Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CLong -> CLong -> [CLong] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CLong[0])
                               ->_R Sym (Foreign.C.Types.N:CLong[0])
                               ->_R ([Sym (Foreign.C.Types.N:CLong[0])])_R
                               :: (Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CLong -> CLong -> [CLong] :: *))
                       GHC.Int.$fEnumInt64_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CLong[0])
                               ->_R Sym (Foreign.C.Types.N:CLong[0])
                               ->_R Sym (Foreign.C.Types.N:CLong[0])
                               ->_R ([Sym (Foreign.C.Types.N:CLong[0])])_R
                               :: (Int64 -> Int64 -> Int64 -> [Int64] :: *)
                                  ~R# (CLong -> CLong -> CLong -> [CLong] :: *))]
Foreign.C.Types.$fEnumCLong
  = GHC.Enum.C:Enum
      @ CLong
      (GHC.Int.$fEnumInt64_$csucc
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int64 :: *) ~R# (CLong -> CLong :: *)))
      (GHC.Int.$fEnumInt64_$cpred
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int64 :: *) ~R# (CLong -> CLong :: *)))
      (GHC.Int.$fEnumInt64_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int -> Int64 :: *) ~R# (Int -> CLong :: *)))
      (GHC.Int.$fEnumInt64_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CLong -> Int :: *)))
      (GHC.Int.$fEnumInt64_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R ([Sym (Foreign.C.Types.N:CLong[0])])_R
               :: (Int64 -> [Int64] :: *) ~R# (CLong -> [CLong] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R ([Sym (Foreign.C.Types.N:CLong[0])])_R
               :: (Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CLong -> CLong -> [CLong] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R ([Sym (Foreign.C.Types.N:CLong[0])])_R
               :: (Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CLong -> CLong -> [CLong] :: *)))
      (GHC.Int.$fEnumInt64_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R ([Sym (Foreign.C.Types.N:CLong[0])])_R
               :: (Int64 -> Int64 -> Int64 -> [Int64] :: *)
                  ~R# (CLong -> CLong -> CLong -> [CLong] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CLong
                     GHC.Int.$fNumInt64_$c+
                     `cast` (Sym (Foreign.C.Types.N:CLong[0])
                             ->_R Sym (Foreign.C.Types.N:CLong[0])
                             ->_R Sym (Foreign.C.Types.N:CLong[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CLong -> CLong -> CLong :: *))
                     GHC.Int.$fNumInt64_$c-
                     `cast` (Sym (Foreign.C.Types.N:CLong[0])
                             ->_R Sym (Foreign.C.Types.N:CLong[0])
                             ->_R Sym (Foreign.C.Types.N:CLong[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CLong -> CLong -> CLong :: *))
                     GHC.Int.$fNumInt64_$c*
                     `cast` (Sym (Foreign.C.Types.N:CLong[0])
                             ->_R Sym (Foreign.C.Types.N:CLong[0])
                             ->_R Sym (Foreign.C.Types.N:CLong[0])
                             :: (Int64 -> Int64 -> Int64 :: *)
                                ~R# (CLong -> CLong -> CLong :: *))
                     GHC.Int.$fNumInt64_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CLong[0])
                             ->_R Sym (Foreign.C.Types.N:CLong[0])
                             :: (Int64 -> Int64 :: *) ~R# (CLong -> CLong :: *))
                     GHC.Int.$fNumInt64_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CLong[0])
                             ->_R Sym (Foreign.C.Types.N:CLong[0])
                             :: (Int64 -> Int64 :: *) ~R# (CLong -> CLong :: *))
                     GHC.Int.$fNumInt64_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CLong[0])
                             ->_R Sym (Foreign.C.Types.N:CLong[0])
                             :: (Int64 -> Int64 :: *) ~R# (CLong -> CLong :: *))
                     GHC.Int.$fNumInt64_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CLong[0])
                             :: (Integer -> Int64 :: *) ~R# (Integer -> CLong :: *))]
Foreign.C.Types.$fNumCLong
  = GHC.Num.C:Num
      @ CLong
      (GHC.Int.$fNumInt64_$c+
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLong -> CLong -> CLong :: *)))
      (GHC.Int.$fNumInt64_$c-
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLong -> CLong -> CLong :: *)))
      (GHC.Int.$fNumInt64_$c*
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLong -> CLong -> CLong :: *)))
      (GHC.Int.$fNumInt64_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int64 :: *) ~R# (CLong -> CLong :: *)))
      (GHC.Int.$fNumInt64_$cabs
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int64 :: *) ~R# (CLong -> CLong :: *)))
      (GHC.Int.$fNumInt64_$csignum
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int64 :: *) ~R# (CLong -> CLong :: *)))
      (GHC.Int.$fNumInt64_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Integer -> Int64 :: *) ~R# (Integer -> CLong :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CLong
                        GHC.Int.eqInt64
                        `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                ->_R Sym (Foreign.C.Types.N:CLong[0])
                                ->_R <Bool>_R
                                :: (Int64 -> Int64 -> Bool :: *) ~R# (CLong -> CLong -> Bool :: *))
                        GHC.Int.neInt64
                        `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                ->_R Sym (Foreign.C.Types.N:CLong[0])
                                ->_R <Bool>_R
                                :: (Int64 -> Int64 -> Bool :: *)
                                   ~R# (CLong -> CLong -> Bool :: *))]
Foreign.C.Types.$fEqCLong
  = GHC.Classes.C:Eq
      @ CLong
      (GHC.Int.eqInt64
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CLong -> CLong -> Bool :: *)))
      (GHC.Int.neInt64
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CLong -> CLong -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CLong
                         Foreign.C.Types.$fEqCLong
                         GHC.Int.$fOrdInt64_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CLong[0])
                                 ->_R <Ordering>_R
                                 :: (Int64 -> Int64 -> Ordering :: *)
                                    ~R# (CLong -> CLong -> Ordering :: *))
                         GHC.Int.ltInt64
                         `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CLong[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *) ~R# (CLong -> CLong -> Bool :: *))
                         GHC.Int.leInt64
                         `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CLong[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *) ~R# (CLong -> CLong -> Bool :: *))
                         GHC.Int.gtInt64
                         `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CLong[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *) ~R# (CLong -> CLong -> Bool :: *))
                         GHC.Int.geInt64
                         `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CLong[0])
                                 ->_R <Bool>_R
                                 :: (Int64 -> Int64 -> Bool :: *) ~R# (CLong -> CLong -> Bool :: *))
                         GHC.Int.$fOrdInt64_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CLong[0])
                                 :: (Int64 -> Int64 -> Int64 :: *)
                                    ~R# (CLong -> CLong -> CLong :: *))
                         GHC.Int.$fOrdInt64_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CLong[0])
                                 ->_R Sym (Foreign.C.Types.N:CLong[0])
                                 :: (Int64 -> Int64 -> Int64 :: *)
                                    ~R# (CLong -> CLong -> CLong :: *))]
Foreign.C.Types.$fOrdCLong
  = GHC.Classes.C:Ord
      @ CLong
      Foreign.C.Types.$fEqCLong
      (GHC.Int.$fOrdInt64_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R <Ordering>_R
               :: (Int64 -> Int64 -> Ordering :: *)
                  ~R# (CLong -> CLong -> Ordering :: *)))
      (GHC.Int.ltInt64
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CLong -> CLong -> Bool :: *)))
      (GHC.Int.leInt64
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CLong -> CLong -> Bool :: *)))
      (GHC.Int.gtInt64
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CLong -> CLong -> Bool :: *)))
      (GHC.Int.geInt64
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R <Bool>_R
               :: (Int64 -> Int64 -> Bool :: *)
                  ~R# (CLong -> CLong -> Bool :: *)))
      (GHC.Int.$fOrdInt64_$cmax
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLong -> CLong -> CLong :: *)))
      (GHC.Int.$fOrdInt64_$cmin
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLong -> CLong -> CLong :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CLong
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CLong
                       Foreign.C.Types.$fNumCLong
                       Foreign.C.Types.$fOrdCLong
                       GHC.Int.$fRealInt64_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Ratio Integer>_R
                               :: (Int64 -> Ratio Integer :: *)
                                  ~R# (CLong -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCLong
  = GHC.Real.C:Real
      @ CLong
      Foreign.C.Types.$fNumCLong
      Foreign.C.Types.$fOrdCLong
      (GHC.Int.$fRealInt64_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Ratio Integer>_R
               :: (Int64 -> Ratio Integer :: *)
                  ~R# (CLong -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.C.Types.$fIntegralCLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral CLong
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: CLong
                           Foreign.C.Types.$fRealCLong
                           Foreign.C.Types.$fEnumCLong
                           GHC.Int.$fIntegralInt64_$cquot
                           `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CLong[0])
                                   :: (Int64 -> Int64 -> Int64 :: *)
                                      ~R# (CLong -> CLong -> CLong :: *))
                           GHC.Int.$fIntegralInt64_$crem
                           `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CLong[0])
                                   :: (Int64 -> Int64 -> Int64 :: *)
                                      ~R# (CLong -> CLong -> CLong :: *))
                           GHC.Int.$fIntegralInt64_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CLong[0])
                                   :: (Int64 -> Int64 -> Int64 :: *)
                                      ~R# (CLong -> CLong -> CLong :: *))
                           GHC.Int.$fIntegralInt64_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CLong[0])
                                   :: (Int64 -> Int64 -> Int64 :: *)
                                      ~R# (CLong -> CLong -> CLong :: *))
                           GHC.Int.$fIntegralInt64_$cquotRem
                           `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CLong[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CLong[0]))
                                           (Sym (Foreign.C.Types.N:CLong[0])))_R
                                   :: (Int64 -> Int64 -> (Int64, Int64) :: *)
                                      ~R# (CLong -> CLong -> (CLong, CLong) :: *))
                           GHC.Int.$fIntegralInt64_$cdivMod
                           `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                   ->_R Sym (Foreign.C.Types.N:CLong[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CLong[0]))
                                           (Sym (Foreign.C.Types.N:CLong[0])))_R
                                   :: (Int64 -> Int64 -> (Int64, Int64) :: *)
                                      ~R# (CLong -> CLong -> (CLong, CLong) :: *))
                           GHC.Int.$fIntegralInt64_$ctoInteger
                           `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Integer>_R
                                   :: (Int64 -> Integer :: *) ~R# (CLong -> Integer :: *))]
Foreign.C.Types.$fIntegralCLong
  = GHC.Real.C:Integral
      @ CLong
      Foreign.C.Types.$fRealCLong
      Foreign.C.Types.$fEnumCLong
      (GHC.Int.$fIntegralInt64_$cquot
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLong -> CLong -> CLong :: *)))
      (GHC.Int.$fIntegralInt64_$crem
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLong -> CLong -> CLong :: *)))
      (GHC.Int.$fIntegralInt64_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLong -> CLong -> CLong :: *)))
      (GHC.Int.$fIntegralInt64_$cmod
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLong -> CLong -> CLong :: *)))
      (GHC.Int.$fIntegralInt64_$cquotRem
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CLong[0]))
                       (Sym (Foreign.C.Types.N:CLong[0])))_R
               :: (Int64 -> Int64 -> (Int64, Int64) :: *)
                  ~R# (CLong -> CLong -> (CLong, CLong) :: *)))
      (GHC.Int.$fIntegralInt64_$cdivMod
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CLong[0]))
                       (Sym (Foreign.C.Types.N:CLong[0])))_R
               :: (Int64 -> Int64 -> (Int64, Int64) :: *)
                  ~R# (CLong -> CLong -> (CLong, CLong) :: *)))
      (GHC.Int.$fIntegralInt64_$ctoInteger
       `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Integer>_R
               :: (Int64 -> Integer :: *) ~R# (CLong -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.C.Types.$fBitsCLong [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits CLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: CLong
                        Foreign.C.Types.$fEqCLong
                        GHC.Int.$fBitsInt64_$c.&.
                        `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                ->_R Sym (Foreign.C.Types.N:CLong[0])
                                ->_R Sym (Foreign.C.Types.N:CLong[0])
                                :: (Int64 -> Int64 -> Int64 :: *)
                                   ~R# (CLong -> CLong -> CLong :: *))
                        GHC.Int.$fBitsInt64_$c.|.
                        `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                ->_R Sym (Foreign.C.Types.N:CLong[0])
                                ->_R Sym (Foreign.C.Types.N:CLong[0])
                                :: (Int64 -> Int64 -> Int64 :: *)
                                   ~R# (CLong -> CLong -> CLong :: *))
                        GHC.Int.$fBitsInt64_$cxor
                        `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                ->_R Sym (Foreign.C.Types.N:CLong[0])
                                ->_R Sym (Foreign.C.Types.N:CLong[0])
                                :: (Int64 -> Int64 -> Int64 :: *)
                                   ~R# (CLong -> CLong -> CLong :: *))
                        GHC.Int.$fBitsInt64_$ccomplement
                        `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                ->_R Sym (Foreign.C.Types.N:CLong[0])
                                :: (Int64 -> Int64 :: *) ~R# (CLong -> CLong :: *))
                        GHC.Int.$fBitsInt64_$cshift
                        `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *))
                        GHC.Int.$fBitsInt64_$crotate
                        `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *))
                        GHC.Int.$fBitsInt10
                        `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                :: (Int64 :: *) ~R# (CLong :: *))
                        GHC.Int.$fBitsInt64_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CLong[0])
                                :: (Int -> Int64 :: *) ~R# (Int -> CLong :: *))
                        GHC.Int.$fBitsInt64_$csetBit
                        `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *))
                        GHC.Int.$fBitsInt64_$cclearBit
                        `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *))
                        GHC.Int.$fBitsInt64_$ccomplementBit
                        `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *))
                        GHC.Int.$fBitsInt64_$ctestBit
                        `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Int -> Bool>_R
                                :: (Int64 -> Int -> Bool :: *) ~R# (CLong -> Int -> Bool :: *))
                        GHC.Int.$fBitsInt64_$cbitSizeMaybe
                        `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Maybe Int>_R
                                :: (Int64 -> Maybe Int :: *) ~R# (CLong -> Maybe Int :: *))
                        GHC.Int.$fBitsInt64_$cfiniteBitSize
                        `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Int>_R
                                :: (Int64 -> Int :: *) ~R# (CLong -> Int :: *))
                        GHC.Int.$fBitsInt64_$cisSigned
                        `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Bool>_R
                                :: (Int64 -> Bool :: *) ~R# (CLong -> Bool :: *))
                        GHC.Int.$fBitsInt64_$cshiftL
                        `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *))
                        GHC.Int.$fBitsInt64_$cunsafeShiftL
                        `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *))
                        GHC.Int.$fBitsInt64_$cshiftR
                        `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *))
                        GHC.Int.$fBitsInt64_$cunsafeShiftR
                        `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *))
                        GHC.Int.$fBitsInt64_$crotateL
                        `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *))
                        GHC.Int.$fBitsInt64_$crotateR
                        `cast` (Sym (Foreign.C.Types.N:CLong[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CLong[0])
                                :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *))
                        GHC.Int.$fBitsInt64_$cpopCount
                        `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Int>_R
                                :: (Int64 -> Int :: *) ~R# (CLong -> Int :: *))]
Foreign.C.Types.$fBitsCLong
  = Data.Bits.C:Bits
      @ CLong
      Foreign.C.Types.$fEqCLong
      (GHC.Int.$fBitsInt64_$c.&.
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLong -> CLong -> CLong :: *)))
      (GHC.Int.$fBitsInt64_$c.|.
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLong -> CLong -> CLong :: *)))
      (GHC.Int.$fBitsInt64_$cxor
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int64 -> Int64 :: *)
                  ~R# (CLong -> CLong -> CLong :: *)))
      (GHC.Int.$fBitsInt64_$ccomplement
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int64 :: *) ~R# (CLong -> CLong :: *)))
      (GHC.Int.$fBitsInt64_$cshift
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *)))
      (GHC.Int.$fBitsInt64_$crotate
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *)))
      (GHC.Int.$fBitsInt10
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 :: *) ~R# (CLong :: *)))
      (GHC.Int.$fBitsInt64_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int -> Int64 :: *) ~R# (Int -> CLong :: *)))
      (GHC.Int.$fBitsInt64_$csetBit
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *)))
      (GHC.Int.$fBitsInt64_$cclearBit
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *)))
      (GHC.Int.$fBitsInt64_$ccomplementBit
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *)))
      (GHC.Int.$fBitsInt64_$ctestBit
       `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Int -> Bool>_R
               :: (Int64 -> Int -> Bool :: *) ~R# (CLong -> Int -> Bool :: *)))
      (GHC.Int.$fBitsInt64_$cbitSizeMaybe
       `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Maybe Int>_R
               :: (Int64 -> Maybe Int :: *) ~R# (CLong -> Maybe Int :: *)))
      (GHC.Int.$fBitsInt64_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CLong -> Int :: *)))
      (GHC.Int.$fBitsInt64_$cisSigned
       `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Bool>_R
               :: (Int64 -> Bool :: *) ~R# (CLong -> Bool :: *)))
      (GHC.Int.$fBitsInt64_$cshiftL
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *)))
      (GHC.Int.$fBitsInt64_$cunsafeShiftL
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *)))
      (GHC.Int.$fBitsInt64_$cshiftR
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *)))
      (GHC.Int.$fBitsInt64_$cunsafeShiftR
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *)))
      (GHC.Int.$fBitsInt64_$crotateL
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *)))
      (GHC.Int.$fBitsInt64_$crotateR
       `cast` (Sym (Foreign.C.Types.N:CLong[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CLong[0])
               :: (Int64 -> Int -> Int64 :: *) ~R# (CLong -> Int -> CLong :: *)))
      (GHC.Int.$fBitsInt64_$cpopCount
       `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CLong -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.C.Types.$fFiniteBitsCLong [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits CLong
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: CLong
                              Foreign.C.Types.$fBitsCLong
                              GHC.Int.$fBitsInt64_$cfiniteBitSize
                              `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Int>_R
                                      :: (Int64 -> Int :: *) ~R# (CLong -> Int :: *))
                              GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros
                              `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Int>_R
                                      :: (Int64 -> Int :: *) ~R# (CLong -> Int :: *))
                              GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros
                              `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Int>_R
                                      :: (Int64 -> Int :: *) ~R# (CLong -> Int :: *))]
Foreign.C.Types.$fFiniteBitsCLong
  = Data.Bits.C:FiniteBits
      @ CLong
      Foreign.C.Types.$fBitsCLong
      (GHC.Int.$fBitsInt64_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CLong -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt64_$ccountLeadingZeros
       `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CLong -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt64_$ccountTrailingZeros
       `cast` (Sym (Foreign.C.Types.N:CLong[0]) ->_R <Int>_R
               :: (Int64 -> Int :: *) ~R# (CLong -> Int :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCUInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CUInt
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CUInt
                       GHC.Word.$fShowWord32_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CUInt[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Word32 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CUInt -> [Char] -> [Char] :: *))
                       GHC.Word.$fShowWord32_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <[Char]>_R
                               :: (Word32 -> [Char] :: *) ~R# (CUInt -> [Char] :: *))
                       GHC.Word.$fShowWord32_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CUInt[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Word32] -> [Char] -> [Char] :: *)
                                  ~R# ([CUInt] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCUInt
  = GHC.Show.C:Show
      @ CUInt
      (GHC.Word.$fShowWord32_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Word32 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CUInt -> [Char] -> [Char] :: *)))
      (GHC.Word.$fShowWord32_$cshow
       `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <[Char]>_R
               :: (Word32 -> [Char] :: *) ~R# (CUInt -> [Char] :: *)))
      (GHC.Word.$fShowWord32_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CUInt[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Word32] -> [Char] -> [Char] :: *)
                  ~R# ([CUInt] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCUInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CUInt
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CUInt
                       GHC.Read.$fReadWord32_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CUInt[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Word32, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CUInt, [Char])] :: *))
                       GHC.Read.$fReadWord32_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CUInt[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Word32], [Char])] :: *)
                                  ~R# ([Char] -> [([CUInt], [Char])] :: *))
                       GHC.Read.$fReadWord10
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Word32>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      (Foreign.C.Types.N:CUInt[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Word32 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CUInt :: *))
                       GHC.Read.$fReadWord7
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Word32]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                        ([Foreign.C.Types.N:CUInt[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Word32] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CUInt] :: *))]
Foreign.C.Types.$fReadCUInt
  = GHC.Read.C:Read
      @ CUInt
      (GHC.Read.$fReadWord32_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CUInt[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Word32, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CUInt, [Char])] :: *)))
      (GHC.Read.$fReadWord32_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CUInt[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Word32], [Char])] :: *)
                  ~R# ([Char] -> [([CUInt], [Char])] :: *)))
      (GHC.Read.$fReadWord10
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Word32>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                      (Foreign.C.Types.N:CUInt[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Word32 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CUInt :: *)))
      (GHC.Read.$fReadWord7
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Word32]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        ([Foreign.C.Types.N:CUInt[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Word32] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CUInt] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.C.Types.$fBoundedCUInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded CUInt
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: CUInt
                          GHC.Word.$fBitsWord32_$cminBound
                          `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                  :: (Word32 :: *) ~R# (CUInt :: *))
                          GHC.Word.$fBoundedWord32_$cmaxBound
                          `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                  :: (Word32 :: *) ~R# (CUInt :: *))]
Foreign.C.Types.$fBoundedCUInt
  = GHC.Enum.C:Bounded
      @ CUInt
      (GHC.Word.$fBitsWord32_$cminBound
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 :: *) ~R# (CUInt :: *)))
      (GHC.Word.$fBoundedWord32_$cmaxBound
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 :: *) ~R# (CUInt :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCUInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CUInt
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CUInt
                                   Foreign.Storable.$fStorableWord32_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Int>_R
                                           :: (Word32 -> Int :: *) ~R# (CUInt -> Int :: *))
                                   Foreign.Storable.$fStorableWord32_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Int>_R
                                           :: (Word32 -> Int :: *) ~R# (CUInt -> Int :: *))
                                   GHC.Storable.readWord32OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word32, CUInt))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUInt[0]))
                                           :: (GHC.Ptr.Ptr Word32
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word32 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUInt -> Int -> IO CUInt :: *))
                                   GHC.Storable.writeWord32OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word32, CUInt))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Word32
                                               -> Int
                                               -> Word32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUInt -> Int -> CUInt -> IO () :: *))
                                   Foreign.Storable.$fStorableWord13
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUInt[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word32 #) :: *)
                                              ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CUInt :: *))
                                   Foreign.Storable.$fStorableWord12
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Word32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CUInt -> IO () :: *))
                                   Foreign.Storable.$fStorableWord11
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word32, CUInt))_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUInt[0]))
                                           :: (GHC.Ptr.Ptr Word32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word32 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUInt -> IO CUInt :: *))
                                   Foreign.Storable.$fStorableWord10
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word32, CUInt))_R
                                           ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Word32
                                               -> Word32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUInt -> CUInt -> IO () :: *))]
Foreign.C.Types.$fStorableCUInt
  = Foreign.Storable.C:Storable
      @ CUInt
      (Foreign.Storable.$fStorableWord32_$calignment
       `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Int>_R
               :: (Word32 -> Int :: *) ~R# (CUInt -> Int :: *)))
      (Foreign.Storable.$fStorableWord32_$calignment
       `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Int>_R
               :: (Word32 -> Int :: *) ~R# (CUInt -> Int :: *)))
      (GHC.Storable.readWord32OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word32, CUInt))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUInt[0]))
               :: (GHC.Ptr.Ptr Word32
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word32 #) :: *)
                  ~R# (GHC.Ptr.Ptr CUInt -> Int -> IO CUInt :: *)))
      (GHC.Storable.writeWord32OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word32, CUInt))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Word32
                   -> Int
                   -> Word32
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CUInt -> Int -> CUInt -> IO () :: *)))
      (Foreign.Storable.$fStorableWord13
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUInt[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word32 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CUInt :: *)))
      (Foreign.Storable.$fStorableWord12
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Word32
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CUInt -> IO () :: *)))
      (Foreign.Storable.$fStorableWord11
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word32, CUInt))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUInt[0]))
               :: (GHC.Ptr.Ptr Word32
                   -> State# RealWorld -> (# State# RealWorld, Word32 #) :: *)
                  ~R# (GHC.Ptr.Ptr CUInt -> IO CUInt :: *)))
      (Foreign.Storable.$fStorableWord10
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word32, CUInt))_R
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Word32
                   -> Word32 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CUInt -> CUInt -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCUInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CUInt
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CUInt
                       GHC.Word.$fEnumWord32_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                               ->_R Sym (Foreign.C.Types.N:CUInt[0])
                               :: (Word32 -> Word32 :: *) ~R# (CUInt -> CUInt :: *))
                       GHC.Word.$fEnumWord32_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                               ->_R Sym (Foreign.C.Types.N:CUInt[0])
                               :: (Word32 -> Word32 :: *) ~R# (CUInt -> CUInt :: *))
                       GHC.Word.$fEnumWord32_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUInt[0])
                               :: (Int -> Word32 :: *) ~R# (Int -> CUInt :: *))
                       GHC.Word.$fEnumWord32_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Int>_R
                               :: (Word32 -> Int :: *) ~R# (CUInt -> Int :: *))
                       GHC.Word.$fEnumWord32_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUInt[0])])_R
                               :: (Word32 -> [Word32] :: *) ~R# (CUInt -> [CUInt] :: *))
                       GHC.Word.$fEnumWord32_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                               ->_R Sym (Foreign.C.Types.N:CUInt[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUInt[0])])_R
                               :: (Word32 -> Word32 -> [Word32] :: *)
                                  ~R# (CUInt -> CUInt -> [CUInt] :: *))
                       GHC.Word.$fEnumWord32_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                               ->_R Sym (Foreign.C.Types.N:CUInt[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUInt[0])])_R
                               :: (Word32 -> Word32 -> [Word32] :: *)
                                  ~R# (CUInt -> CUInt -> [CUInt] :: *))
                       GHC.Word.$fEnumWord32_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                               ->_R Sym (Foreign.C.Types.N:CUInt[0])
                               ->_R Sym (Foreign.C.Types.N:CUInt[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUInt[0])])_R
                               :: (Word32 -> Word32 -> Word32 -> [Word32] :: *)
                                  ~R# (CUInt -> CUInt -> CUInt -> [CUInt] :: *))]
Foreign.C.Types.$fEnumCUInt
  = GHC.Enum.C:Enum
      @ CUInt
      (GHC.Word.$fEnumWord32_$csucc
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Word32 :: *) ~R# (CUInt -> CUInt :: *)))
      (GHC.Word.$fEnumWord32_$cpred
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Word32 :: *) ~R# (CUInt -> CUInt :: *)))
      (GHC.Word.$fEnumWord32_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Int -> Word32 :: *) ~R# (Int -> CUInt :: *)))
      (GHC.Word.$fEnumWord32_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Int>_R
               :: (Word32 -> Int :: *) ~R# (CUInt -> Int :: *)))
      (GHC.Word.$fEnumWord32_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R ([Sym (Foreign.C.Types.N:CUInt[0])])_R
               :: (Word32 -> [Word32] :: *) ~R# (CUInt -> [CUInt] :: *)))
      (GHC.Word.$fEnumWord32_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R ([Sym (Foreign.C.Types.N:CUInt[0])])_R
               :: (Word32 -> Word32 -> [Word32] :: *)
                  ~R# (CUInt -> CUInt -> [CUInt] :: *)))
      (GHC.Word.$fEnumWord32_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R ([Sym (Foreign.C.Types.N:CUInt[0])])_R
               :: (Word32 -> Word32 -> [Word32] :: *)
                  ~R# (CUInt -> CUInt -> [CUInt] :: *)))
      (GHC.Word.$fEnumWord32_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R ([Sym (Foreign.C.Types.N:CUInt[0])])_R
               :: (Word32 -> Word32 -> Word32 -> [Word32] :: *)
                  ~R# (CUInt -> CUInt -> CUInt -> [CUInt] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCUInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CUInt
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CUInt
                     GHC.Word.$fNumWord32_$c+
                     `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                             ->_R Sym (Foreign.C.Types.N:CUInt[0])
                             ->_R Sym (Foreign.C.Types.N:CUInt[0])
                             :: (Word32 -> Word32 -> Word32 :: *)
                                ~R# (CUInt -> CUInt -> CUInt :: *))
                     GHC.Word.$fNumWord32_$c-
                     `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                             ->_R Sym (Foreign.C.Types.N:CUInt[0])
                             ->_R Sym (Foreign.C.Types.N:CUInt[0])
                             :: (Word32 -> Word32 -> Word32 :: *)
                                ~R# (CUInt -> CUInt -> CUInt :: *))
                     GHC.Word.$fNumWord32_$c*
                     `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                             ->_R Sym (Foreign.C.Types.N:CUInt[0])
                             ->_R Sym (Foreign.C.Types.N:CUInt[0])
                             :: (Word32 -> Word32 -> Word32 :: *)
                                ~R# (CUInt -> CUInt -> CUInt :: *))
                     GHC.Word.$fNumWord32_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                             ->_R Sym (Foreign.C.Types.N:CUInt[0])
                             :: (Word32 -> Word32 :: *) ~R# (CUInt -> CUInt :: *))
                     GHC.Word.$fNumWord32_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                             ->_R Sym (Foreign.C.Types.N:CUInt[0])
                             :: (Word32 -> Word32 :: *) ~R# (CUInt -> CUInt :: *))
                     GHC.Word.$fNumWord32_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                             ->_R Sym (Foreign.C.Types.N:CUInt[0])
                             :: (Word32 -> Word32 :: *) ~R# (CUInt -> CUInt :: *))
                     GHC.Word.$fNumWord32_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CUInt[0])
                             :: (Integer -> Word32 :: *) ~R# (Integer -> CUInt :: *))]
Foreign.C.Types.$fNumCUInt
  = GHC.Num.C:Num
      @ CUInt
      (GHC.Word.$fNumWord32_$c+
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Word32 -> Word32 :: *)
                  ~R# (CUInt -> CUInt -> CUInt :: *)))
      (GHC.Word.$fNumWord32_$c-
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Word32 -> Word32 :: *)
                  ~R# (CUInt -> CUInt -> CUInt :: *)))
      (GHC.Word.$fNumWord32_$c*
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Word32 -> Word32 :: *)
                  ~R# (CUInt -> CUInt -> CUInt :: *)))
      (GHC.Word.$fNumWord32_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Word32 :: *) ~R# (CUInt -> CUInt :: *)))
      (GHC.Word.$fNumWord32_$cabs
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Word32 :: *) ~R# (CUInt -> CUInt :: *)))
      (GHC.Word.$fNumWord32_$csignum
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Word32 :: *) ~R# (CUInt -> CUInt :: *)))
      (GHC.Word.$fNumWord32_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Integer -> Word32 :: *) ~R# (Integer -> CUInt :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCUInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CUInt
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CUInt
                        GHC.Word.eqWord32
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R <Bool>_R
                                :: (Word32 -> Word32 -> Bool :: *)
                                   ~R# (CUInt -> CUInt -> Bool :: *))
                        GHC.Word.neWord32
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R <Bool>_R
                                :: (Word32 -> Word32 -> Bool :: *)
                                   ~R# (CUInt -> CUInt -> Bool :: *))]
Foreign.C.Types.$fEqCUInt
  = GHC.Classes.C:Eq
      @ CUInt
      (GHC.Word.eqWord32
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R <Bool>_R
               :: (Word32 -> Word32 -> Bool :: *)
                  ~R# (CUInt -> CUInt -> Bool :: *)))
      (GHC.Word.neWord32
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R <Bool>_R
               :: (Word32 -> Word32 -> Bool :: *)
                  ~R# (CUInt -> CUInt -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCUInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CUInt
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CUInt
                         Foreign.C.Types.$fEqCUInt
                         GHC.Word.$fOrdWord32_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                 ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                 ->_R <Ordering>_R
                                 :: (Word32 -> Word32 -> Ordering :: *)
                                    ~R# (CUInt -> CUInt -> Ordering :: *))
                         GHC.Word.ltWord32
                         `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                 ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                 ->_R <Bool>_R
                                 :: (Word32 -> Word32 -> Bool :: *)
                                    ~R# (CUInt -> CUInt -> Bool :: *))
                         GHC.Word.leWord32
                         `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                 ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                 ->_R <Bool>_R
                                 :: (Word32 -> Word32 -> Bool :: *)
                                    ~R# (CUInt -> CUInt -> Bool :: *))
                         GHC.Word.gtWord32
                         `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                 ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                 ->_R <Bool>_R
                                 :: (Word32 -> Word32 -> Bool :: *)
                                    ~R# (CUInt -> CUInt -> Bool :: *))
                         GHC.Word.geWord32
                         `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                 ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                 ->_R <Bool>_R
                                 :: (Word32 -> Word32 -> Bool :: *)
                                    ~R# (CUInt -> CUInt -> Bool :: *))
                         GHC.Word.$fOrdWord32_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                 ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                 ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                 :: (Word32 -> Word32 -> Word32 :: *)
                                    ~R# (CUInt -> CUInt -> CUInt :: *))
                         GHC.Word.$fOrdWord32_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                 ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                 ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                 :: (Word32 -> Word32 -> Word32 :: *)
                                    ~R# (CUInt -> CUInt -> CUInt :: *))]
Foreign.C.Types.$fOrdCUInt
  = GHC.Classes.C:Ord
      @ CUInt
      Foreign.C.Types.$fEqCUInt
      (GHC.Word.$fOrdWord32_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R <Ordering>_R
               :: (Word32 -> Word32 -> Ordering :: *)
                  ~R# (CUInt -> CUInt -> Ordering :: *)))
      (GHC.Word.ltWord32
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R <Bool>_R
               :: (Word32 -> Word32 -> Bool :: *)
                  ~R# (CUInt -> CUInt -> Bool :: *)))
      (GHC.Word.leWord32
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R <Bool>_R
               :: (Word32 -> Word32 -> Bool :: *)
                  ~R# (CUInt -> CUInt -> Bool :: *)))
      (GHC.Word.gtWord32
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R <Bool>_R
               :: (Word32 -> Word32 -> Bool :: *)
                  ~R# (CUInt -> CUInt -> Bool :: *)))
      (GHC.Word.geWord32
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R <Bool>_R
               :: (Word32 -> Word32 -> Bool :: *)
                  ~R# (CUInt -> CUInt -> Bool :: *)))
      (GHC.Word.$fOrdWord32_$cmax
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Word32 -> Word32 :: *)
                  ~R# (CUInt -> CUInt -> CUInt :: *)))
      (GHC.Word.$fOrdWord32_$cmin
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Word32 -> Word32 :: *)
                  ~R# (CUInt -> CUInt -> CUInt :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCUInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CUInt
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CUInt
                       Foreign.C.Types.$fNumCUInt
                       Foreign.C.Types.$fOrdCUInt
                       GHC.Word.$fRealWord32_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Ratio Integer>_R
                               :: (Word32 -> Ratio Integer :: *)
                                  ~R# (CUInt -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCUInt
  = GHC.Real.C:Real
      @ CUInt
      Foreign.C.Types.$fNumCUInt
      Foreign.C.Types.$fOrdCUInt
      (GHC.Word.$fRealWord32_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Ratio Integer>_R
               :: (Word32 -> Ratio Integer :: *)
                  ~R# (CUInt -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.C.Types.$fIntegralCUInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral CUInt
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: CUInt
                           Foreign.C.Types.$fRealCUInt
                           Foreign.C.Types.$fEnumCUInt
                           GHC.Word.$fIntegralWord32_$cquot
                           `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                   ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                   ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                   :: (Word32 -> Word32 -> Word32 :: *)
                                      ~R# (CUInt -> CUInt -> CUInt :: *))
                           GHC.Word.$fIntegralWord32_$crem
                           `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                   ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                   ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                   :: (Word32 -> Word32 -> Word32 :: *)
                                      ~R# (CUInt -> CUInt -> CUInt :: *))
                           GHC.Word.$fIntegralWord32_$cquot
                           `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                   ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                   ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                   :: (Word32 -> Word32 -> Word32 :: *)
                                      ~R# (CUInt -> CUInt -> CUInt :: *))
                           GHC.Word.$fIntegralWord32_$crem
                           `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                   ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                   ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                   :: (Word32 -> Word32 -> Word32 :: *)
                                      ~R# (CUInt -> CUInt -> CUInt :: *))
                           GHC.Word.$fIntegralWord32_$cquotRem
                           `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                   ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CUInt[0]))
                                           (Sym (Foreign.C.Types.N:CUInt[0])))_R
                                   :: (Word32 -> Word32 -> (Word32, Word32) :: *)
                                      ~R# (CUInt -> CUInt -> (CUInt, CUInt) :: *))
                           GHC.Word.$fIntegralWord32_$cdivMod
                           `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                   ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CUInt[0]))
                                           (Sym (Foreign.C.Types.N:CUInt[0])))_R
                                   :: (Word32 -> Word32 -> (Word32, Word32) :: *)
                                      ~R# (CUInt -> CUInt -> (CUInt, CUInt) :: *))
                           GHC.Word.$ctoInteger2
                           `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Integer>_R
                                   :: (Word32 -> Integer :: *) ~R# (CUInt -> Integer :: *))]
Foreign.C.Types.$fIntegralCUInt
  = GHC.Real.C:Integral
      @ CUInt
      Foreign.C.Types.$fRealCUInt
      Foreign.C.Types.$fEnumCUInt
      (GHC.Word.$fIntegralWord32_$cquot
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Word32 -> Word32 :: *)
                  ~R# (CUInt -> CUInt -> CUInt :: *)))
      (GHC.Word.$fIntegralWord32_$crem
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Word32 -> Word32 :: *)
                  ~R# (CUInt -> CUInt -> CUInt :: *)))
      (GHC.Word.$fIntegralWord32_$cquot
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Word32 -> Word32 :: *)
                  ~R# (CUInt -> CUInt -> CUInt :: *)))
      (GHC.Word.$fIntegralWord32_$crem
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Word32 -> Word32 :: *)
                  ~R# (CUInt -> CUInt -> CUInt :: *)))
      (GHC.Word.$fIntegralWord32_$cquotRem
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CUInt[0]))
                       (Sym (Foreign.C.Types.N:CUInt[0])))_R
               :: (Word32 -> Word32 -> (Word32, Word32) :: *)
                  ~R# (CUInt -> CUInt -> (CUInt, CUInt) :: *)))
      (GHC.Word.$fIntegralWord32_$cdivMod
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CUInt[0]))
                       (Sym (Foreign.C.Types.N:CUInt[0])))_R
               :: (Word32 -> Word32 -> (Word32, Word32) :: *)
                  ~R# (CUInt -> CUInt -> (CUInt, CUInt) :: *)))
      (GHC.Word.$ctoInteger2
       `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Integer>_R
               :: (Word32 -> Integer :: *) ~R# (CUInt -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.C.Types.$fBitsCUInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits CUInt
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: CUInt
                        Foreign.C.Types.$fEqCUInt
                        GHC.Word.$fBitsWord32_$c.&.
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                :: (Word32 -> Word32 -> Word32 :: *)
                                   ~R# (CUInt -> CUInt -> CUInt :: *))
                        GHC.Word.$fBitsWord32_$c.|.
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                :: (Word32 -> Word32 -> Word32 :: *)
                                   ~R# (CUInt -> CUInt -> CUInt :: *))
                        GHC.Word.$fBitsWord32_$cxor
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                :: (Word32 -> Word32 -> Word32 :: *)
                                   ~R# (CUInt -> CUInt -> CUInt :: *))
                        GHC.Word.$fBitsWord32_$ccomplement
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                :: (Word32 -> Word32 :: *) ~R# (CUInt -> CUInt :: *))
                        GHC.Word.$fBitsWord32_$cshift
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                :: (Word32 -> Int -> Word32 :: *) ~R# (CUInt -> Int -> CUInt :: *))
                        GHC.Word.$fBitsWord32_$crotate
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                :: (Word32 -> Int -> Word32 :: *) ~R# (CUInt -> Int -> CUInt :: *))
                        GHC.Word.$fBitsWord32_$cminBound
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                :: (Word32 :: *) ~R# (CUInt :: *))
                        GHC.Word.$fBitsWord32_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                :: (Int -> Word32 :: *) ~R# (Int -> CUInt :: *))
                        GHC.Word.$fBitsWord32_$csetBit
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                :: (Word32 -> Int -> Word32 :: *) ~R# (CUInt -> Int -> CUInt :: *))
                        GHC.Word.$fBitsWord32_$cclearBit
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                :: (Word32 -> Int -> Word32 :: *) ~R# (CUInt -> Int -> CUInt :: *))
                        GHC.Word.$fBitsWord32_$ccomplementBit
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                :: (Word32 -> Int -> Word32 :: *) ~R# (CUInt -> Int -> CUInt :: *))
                        GHC.Word.$fBitsWord32_$ctestBit
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Int -> Bool>_R
                                :: (Word32 -> Int -> Bool :: *) ~R# (CUInt -> Int -> Bool :: *))
                        GHC.Word.$fBitsWord32_$cbitSizeMaybe
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Maybe Int>_R
                                :: (Word32 -> Maybe Int :: *) ~R# (CUInt -> Maybe Int :: *))
                        GHC.Word.$fBitsWord32_$cfiniteBitSize
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Int>_R
                                :: (Word32 -> Int :: *) ~R# (CUInt -> Int :: *))
                        GHC.Word.$fBitsWord32_$cisSigned
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Bool>_R
                                :: (Word32 -> Bool :: *) ~R# (CUInt -> Bool :: *))
                        GHC.Word.$fBitsWord32_$cshiftL
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                :: (Word32 -> Int -> Word32 :: *) ~R# (CUInt -> Int -> CUInt :: *))
                        GHC.Word.$fBitsWord32_$cunsafeShiftL
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                :: (Word32 -> Int -> Word32 :: *) ~R# (CUInt -> Int -> CUInt :: *))
                        GHC.Word.$fBitsWord32_$cshiftR
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                :: (Word32 -> Int -> Word32 :: *) ~R# (CUInt -> Int -> CUInt :: *))
                        GHC.Word.$fBitsWord32_$cunsafeShiftR
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                :: (Word32 -> Int -> Word32 :: *) ~R# (CUInt -> Int -> CUInt :: *))
                        GHC.Word.$fBitsWord32_$crotateL
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                :: (Word32 -> Int -> Word32 :: *) ~R# (CUInt -> Int -> CUInt :: *))
                        GHC.Word.$fBitsWord32_$crotateR
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUInt[0])
                                :: (Word32 -> Int -> Word32 :: *) ~R# (CUInt -> Int -> CUInt :: *))
                        GHC.Word.$fBitsWord32_$cpopCount
                        `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Int>_R
                                :: (Word32 -> Int :: *) ~R# (CUInt -> Int :: *))]
Foreign.C.Types.$fBitsCUInt
  = Data.Bits.C:Bits
      @ CUInt
      Foreign.C.Types.$fEqCUInt
      (GHC.Word.$fBitsWord32_$c.&.
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Word32 -> Word32 :: *)
                  ~R# (CUInt -> CUInt -> CUInt :: *)))
      (GHC.Word.$fBitsWord32_$c.|.
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Word32 -> Word32 :: *)
                  ~R# (CUInt -> CUInt -> CUInt :: *)))
      (GHC.Word.$fBitsWord32_$cxor
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Word32 -> Word32 :: *)
                  ~R# (CUInt -> CUInt -> CUInt :: *)))
      (GHC.Word.$fBitsWord32_$ccomplement
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Word32 :: *) ~R# (CUInt -> CUInt :: *)))
      (GHC.Word.$fBitsWord32_$cshift
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Int -> Word32 :: *)
                  ~R# (CUInt -> Int -> CUInt :: *)))
      (GHC.Word.$fBitsWord32_$crotate
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Int -> Word32 :: *)
                  ~R# (CUInt -> Int -> CUInt :: *)))
      (GHC.Word.$fBitsWord32_$cminBound
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 :: *) ~R# (CUInt :: *)))
      (GHC.Word.$fBitsWord32_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Int -> Word32 :: *) ~R# (Int -> CUInt :: *)))
      (GHC.Word.$fBitsWord32_$csetBit
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Int -> Word32 :: *)
                  ~R# (CUInt -> Int -> CUInt :: *)))
      (GHC.Word.$fBitsWord32_$cclearBit
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Int -> Word32 :: *)
                  ~R# (CUInt -> Int -> CUInt :: *)))
      (GHC.Word.$fBitsWord32_$ccomplementBit
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Int -> Word32 :: *)
                  ~R# (CUInt -> Int -> CUInt :: *)))
      (GHC.Word.$fBitsWord32_$ctestBit
       `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Int -> Bool>_R
               :: (Word32 -> Int -> Bool :: *) ~R# (CUInt -> Int -> Bool :: *)))
      (GHC.Word.$fBitsWord32_$cbitSizeMaybe
       `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Maybe Int>_R
               :: (Word32 -> Maybe Int :: *) ~R# (CUInt -> Maybe Int :: *)))
      (GHC.Word.$fBitsWord32_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Int>_R
               :: (Word32 -> Int :: *) ~R# (CUInt -> Int :: *)))
      (GHC.Word.$fBitsWord32_$cisSigned
       `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Bool>_R
               :: (Word32 -> Bool :: *) ~R# (CUInt -> Bool :: *)))
      (GHC.Word.$fBitsWord32_$cshiftL
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Int -> Word32 :: *)
                  ~R# (CUInt -> Int -> CUInt :: *)))
      (GHC.Word.$fBitsWord32_$cunsafeShiftL
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Int -> Word32 :: *)
                  ~R# (CUInt -> Int -> CUInt :: *)))
      (GHC.Word.$fBitsWord32_$cshiftR
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Int -> Word32 :: *)
                  ~R# (CUInt -> Int -> CUInt :: *)))
      (GHC.Word.$fBitsWord32_$cunsafeShiftR
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Int -> Word32 :: *)
                  ~R# (CUInt -> Int -> CUInt :: *)))
      (GHC.Word.$fBitsWord32_$crotateL
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Int -> Word32 :: *)
                  ~R# (CUInt -> Int -> CUInt :: *)))
      (GHC.Word.$fBitsWord32_$crotateR
       `cast` (Sym (Foreign.C.Types.N:CUInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUInt[0])
               :: (Word32 -> Int -> Word32 :: *)
                  ~R# (CUInt -> Int -> CUInt :: *)))
      (GHC.Word.$fBitsWord32_$cpopCount
       `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Int>_R
               :: (Word32 -> Int :: *) ~R# (CUInt -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.C.Types.$fFiniteBitsCUInt [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits CUInt
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: CUInt
                              Foreign.C.Types.$fBitsCUInt
                              GHC.Word.$fBitsWord32_$cfiniteBitSize
                              `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Int>_R
                                      :: (Word32 -> Int :: *) ~R# (CUInt -> Int :: *))
                              GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros
                              `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Int>_R
                                      :: (Word32 -> Int :: *) ~R# (CUInt -> Int :: *))
                              GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros
                              `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Int>_R
                                      :: (Word32 -> Int :: *) ~R# (CUInt -> Int :: *))]
Foreign.C.Types.$fFiniteBitsCUInt
  = Data.Bits.C:FiniteBits
      @ CUInt
      Foreign.C.Types.$fBitsCUInt
      (GHC.Word.$fBitsWord32_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Int>_R
               :: (Word32 -> Int :: *) ~R# (CUInt -> Int :: *)))
      (GHC.Word.$fFiniteBitsWord32_$ccountLeadingZeros
       `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Int>_R
               :: (Word32 -> Int :: *) ~R# (CUInt -> Int :: *)))
      (GHC.Word.$fFiniteBitsWord32_$ccountTrailingZeros
       `cast` (Sym (Foreign.C.Types.N:CUInt[0]) ->_R <Int>_R
               :: (Word32 -> Int :: *) ~R# (CUInt -> Int :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CInt
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CInt
                       GHC.Int.$fShowInt32_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CInt[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Int32 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CInt -> [Char] -> [Char] :: *))
                       GHC.Int.$fShowInt32_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <[Char]>_R
                               :: (Int32 -> [Char] :: *) ~R# (CInt -> [Char] :: *))
                       GHC.Int.$fShowInt32_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CInt[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Int32] -> [Char] -> [Char] :: *)
                                  ~R# ([CInt] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCInt
  = GHC.Show.C:Show
      @ CInt
      (GHC.Int.$fShowInt32_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Int32 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CInt -> [Char] -> [Char] :: *)))
      (GHC.Int.$fShowInt32_$cshow
       `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <[Char]>_R
               :: (Int32 -> [Char] :: *) ~R# (CInt -> [Char] :: *)))
      (GHC.Int.$fShowInt32_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CInt[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Int32] -> [Char] -> [Char] :: *)
                  ~R# ([CInt] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CInt
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CInt
                       GHC.Int.$fReadInt32_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CInt[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Int32, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CInt, [Char])] :: *))
                       GHC.Int.$fReadInt32_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,) ([Sym (Foreign.C.Types.N:CInt[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Int32], [Char])] :: *)
                                  ~R# ([Char] -> [([CInt], [Char])] :: *))
                       GHC.Int.$fReadInt6
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Int32>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     (Foreign.C.Types.N:CInt[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Int32 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CInt :: *))
                       GHC.Int.$fReadInt4
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Int32]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       ([Foreign.C.Types.N:CInt[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Int32] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CInt] :: *))]
Foreign.C.Types.$fReadCInt
  = GHC.Read.C:Read
      @ CInt
      (GHC.Int.$fReadInt32_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CInt[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Int32, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CInt, [Char])] :: *)))
      (GHC.Int.$fReadInt32_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,) ([Sym (Foreign.C.Types.N:CInt[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Int32], [Char])] :: *)
                  ~R# ([Char] -> [([CInt], [Char])] :: *)))
      (GHC.Int.$fReadInt6
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Int32>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                     (Foreign.C.Types.N:CInt[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Int32 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CInt :: *)))
      (GHC.Int.$fReadInt4
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Int32]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       ([Foreign.C.Types.N:CInt[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Int32] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CInt] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.C.Types.$fBoundedCInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded CInt
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: CInt
                          GHC.Int.$fBoundedInt32_$cminBound
                          `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                  :: (Int32 :: *) ~R# (CInt :: *))
                          GHC.Int.$fBoundedInt32_$cmaxBound
                          `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                  :: (Int32 :: *) ~R# (CInt :: *))]
Foreign.C.Types.$fBoundedCInt
  = GHC.Enum.C:Bounded
      @ CInt
      (GHC.Int.$fBoundedInt32_$cminBound
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 :: *) ~R# (CInt :: *)))
      (GHC.Int.$fBoundedInt32_$cmaxBound
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 :: *) ~R# (CInt :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CInt
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CInt
                                   Foreign.Storable.$fStorableInt32_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Int>_R
                                           :: (Int32 -> Int :: *) ~R# (CInt -> Int :: *))
                                   Foreign.Storable.$fStorableInt32_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Int>_R
                                           :: (Int32 -> Int :: *) ~R# (CInt -> Int :: *))
                                   GHC.Storable.readInt32OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int32, CInt))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CInt[0]))
                                           :: (GHC.Ptr.Ptr Int32
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int32 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CInt -> Int -> IO CInt :: *))
                                   GHC.Storable.writeInt32OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int32, CInt))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CInt[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int32
                                               -> Int
                                               -> Int32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CInt -> Int -> CInt -> IO () :: *))
                                   Foreign.Storable.$fStorableInt14
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CInt[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int32 #) :: *)
                                              ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CInt :: *))
                                   Foreign.Storable.$fStorableInt13
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CInt[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Int32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CInt -> IO () :: *))
                                   Foreign.Storable.$fStorableInt12
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int32, CInt))_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CInt[0]))
                                           :: (GHC.Ptr.Ptr Int32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int32 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CInt -> IO CInt :: *))
                                   Foreign.Storable.$fStorableInt11
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int32, CInt))_R
                                           ->_R Sym (Foreign.C.Types.N:CInt[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int32
                                               -> Int32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CInt -> CInt -> IO () :: *))]
Foreign.C.Types.$fStorableCInt
  = Foreign.Storable.C:Storable
      @ CInt
      (Foreign.Storable.$fStorableInt32_$calignment
       `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CInt -> Int :: *)))
      (Foreign.Storable.$fStorableInt32_$calignment
       `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CInt -> Int :: *)))
      (GHC.Storable.readInt32OffPtr1
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Int32, CInt))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CInt[0]))
               :: (GHC.Ptr.Ptr Int32
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int32 #) :: *)
                  ~R# (GHC.Ptr.Ptr CInt -> Int -> IO CInt :: *)))
      (GHC.Storable.writeInt32OffPtr1
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Int32, CInt))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int32
                   -> Int
                   -> Int32
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CInt -> Int -> CInt -> IO () :: *)))
      (Foreign.Storable.$fStorableInt14
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CInt[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int32 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CInt :: *)))
      (Foreign.Storable.$fStorableInt13
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Int32
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CInt -> IO () :: *)))
      (Foreign.Storable.$fStorableInt12
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Int32, CInt))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CInt[0]))
               :: (GHC.Ptr.Ptr Int32
                   -> State# RealWorld -> (# State# RealWorld, Int32 #) :: *)
                  ~R# (GHC.Ptr.Ptr CInt -> IO CInt :: *)))
      (Foreign.Storable.$fStorableInt11
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Int32, CInt))_R
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int32
                   -> Int32 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CInt -> CInt -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CInt
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CInt
                       GHC.Int.$fEnumInt32_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CInt[0])
                               ->_R Sym (Foreign.C.Types.N:CInt[0])
                               :: (Int32 -> Int32 :: *) ~R# (CInt -> CInt :: *))
                       GHC.Int.$fEnumInt32_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CInt[0])
                               ->_R Sym (Foreign.C.Types.N:CInt[0])
                               :: (Int32 -> Int32 :: *) ~R# (CInt -> CInt :: *))
                       GHC.Int.$fEnumInt32_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CInt[0])
                               :: (Int -> Int32 :: *) ~R# (Int -> CInt :: *))
                       GHC.Int.$fEnumInt32_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Int>_R
                               :: (Int32 -> Int :: *) ~R# (CInt -> Int :: *))
                       GHC.Int.$fEnumInt32_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CInt[0])
                               ->_R ([Sym (Foreign.C.Types.N:CInt[0])])_R
                               :: (Int32 -> [Int32] :: *) ~R# (CInt -> [CInt] :: *))
                       GHC.Int.$fEnumInt32_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CInt[0])
                               ->_R Sym (Foreign.C.Types.N:CInt[0])
                               ->_R ([Sym (Foreign.C.Types.N:CInt[0])])_R
                               :: (Int32 -> Int32 -> [Int32] :: *)
                                  ~R# (CInt -> CInt -> [CInt] :: *))
                       GHC.Int.$fEnumInt32_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CInt[0])
                               ->_R Sym (Foreign.C.Types.N:CInt[0])
                               ->_R ([Sym (Foreign.C.Types.N:CInt[0])])_R
                               :: (Int32 -> Int32 -> [Int32] :: *)
                                  ~R# (CInt -> CInt -> [CInt] :: *))
                       GHC.Int.$fEnumInt32_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CInt[0])
                               ->_R Sym (Foreign.C.Types.N:CInt[0])
                               ->_R Sym (Foreign.C.Types.N:CInt[0])
                               ->_R ([Sym (Foreign.C.Types.N:CInt[0])])_R
                               :: (Int32 -> Int32 -> Int32 -> [Int32] :: *)
                                  ~R# (CInt -> CInt -> CInt -> [CInt] :: *))]
Foreign.C.Types.$fEnumCInt
  = GHC.Enum.C:Enum
      @ CInt
      (GHC.Int.$fEnumInt32_$csucc
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int32 :: *) ~R# (CInt -> CInt :: *)))
      (GHC.Int.$fEnumInt32_$cpred
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int32 :: *) ~R# (CInt -> CInt :: *)))
      (GHC.Int.$fEnumInt32_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int -> Int32 :: *) ~R# (Int -> CInt :: *)))
      (GHC.Int.$fEnumInt32_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CInt -> Int :: *)))
      (GHC.Int.$fEnumInt32_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R ([Sym (Foreign.C.Types.N:CInt[0])])_R
               :: (Int32 -> [Int32] :: *) ~R# (CInt -> [CInt] :: *)))
      (GHC.Int.$fEnumInt32_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R ([Sym (Foreign.C.Types.N:CInt[0])])_R
               :: (Int32 -> Int32 -> [Int32] :: *)
                  ~R# (CInt -> CInt -> [CInt] :: *)))
      (GHC.Int.$fEnumInt32_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R ([Sym (Foreign.C.Types.N:CInt[0])])_R
               :: (Int32 -> Int32 -> [Int32] :: *)
                  ~R# (CInt -> CInt -> [CInt] :: *)))
      (GHC.Int.$fEnumInt32_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R ([Sym (Foreign.C.Types.N:CInt[0])])_R
               :: (Int32 -> Int32 -> Int32 -> [Int32] :: *)
                  ~R# (CInt -> CInt -> CInt -> [CInt] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CInt
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CInt
                     GHC.Int.$fNumInt32_$c+
                     `cast` (Sym (Foreign.C.Types.N:CInt[0])
                             ->_R Sym (Foreign.C.Types.N:CInt[0])
                             ->_R Sym (Foreign.C.Types.N:CInt[0])
                             :: (Int32 -> Int32 -> Int32 :: *) ~R# (CInt -> CInt -> CInt :: *))
                     GHC.Int.$fNumInt32_$c-
                     `cast` (Sym (Foreign.C.Types.N:CInt[0])
                             ->_R Sym (Foreign.C.Types.N:CInt[0])
                             ->_R Sym (Foreign.C.Types.N:CInt[0])
                             :: (Int32 -> Int32 -> Int32 :: *) ~R# (CInt -> CInt -> CInt :: *))
                     GHC.Int.$fNumInt32_$c*
                     `cast` (Sym (Foreign.C.Types.N:CInt[0])
                             ->_R Sym (Foreign.C.Types.N:CInt[0])
                             ->_R Sym (Foreign.C.Types.N:CInt[0])
                             :: (Int32 -> Int32 -> Int32 :: *) ~R# (CInt -> CInt -> CInt :: *))
                     GHC.Int.$fNumInt32_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CInt[0])
                             ->_R Sym (Foreign.C.Types.N:CInt[0])
                             :: (Int32 -> Int32 :: *) ~R# (CInt -> CInt :: *))
                     GHC.Int.$fNumInt32_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CInt[0])
                             ->_R Sym (Foreign.C.Types.N:CInt[0])
                             :: (Int32 -> Int32 :: *) ~R# (CInt -> CInt :: *))
                     GHC.Int.$fNumInt32_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CInt[0])
                             ->_R Sym (Foreign.C.Types.N:CInt[0])
                             :: (Int32 -> Int32 :: *) ~R# (CInt -> CInt :: *))
                     GHC.Int.$fNumInt32_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CInt[0])
                             :: (Integer -> Int32 :: *) ~R# (Integer -> CInt :: *))]
Foreign.C.Types.$fNumCInt
  = GHC.Num.C:Num
      @ CInt
      (GHC.Int.$fNumInt32_$c+
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int32 -> Int32 :: *) ~R# (CInt -> CInt -> CInt :: *)))
      (GHC.Int.$fNumInt32_$c-
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int32 -> Int32 :: *) ~R# (CInt -> CInt -> CInt :: *)))
      (GHC.Int.$fNumInt32_$c*
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int32 -> Int32 :: *) ~R# (CInt -> CInt -> CInt :: *)))
      (GHC.Int.$fNumInt32_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int32 :: *) ~R# (CInt -> CInt :: *)))
      (GHC.Int.$fNumInt32_$cabs
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int32 :: *) ~R# (CInt -> CInt :: *)))
      (GHC.Int.$fNumInt32_$csignum
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int32 :: *) ~R# (CInt -> CInt :: *)))
      (GHC.Int.$fNumInt32_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Integer -> Int32 :: *) ~R# (Integer -> CInt :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCInt [InlPrag=NOUSERINLINE CONLIKE] :: Eq CInt
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CInt
                        GHC.Int.eqInt32
                        `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                ->_R Sym (Foreign.C.Types.N:CInt[0])
                                ->_R <Bool>_R
                                :: (Int32 -> Int32 -> Bool :: *) ~R# (CInt -> CInt -> Bool :: *))
                        GHC.Int.neInt32
                        `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                ->_R Sym (Foreign.C.Types.N:CInt[0])
                                ->_R <Bool>_R
                                :: (Int32 -> Int32 -> Bool :: *) ~R# (CInt -> CInt -> Bool :: *))]
Foreign.C.Types.$fEqCInt
  = GHC.Classes.C:Eq
      @ CInt
      (GHC.Int.eqInt32
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R <Bool>_R
               :: (Int32 -> Int32 -> Bool :: *) ~R# (CInt -> CInt -> Bool :: *)))
      (GHC.Int.neInt32
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R <Bool>_R
               :: (Int32 -> Int32 -> Bool :: *) ~R# (CInt -> CInt -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CInt
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CInt
                         Foreign.C.Types.$fEqCInt
                         GHC.Int.$fOrdInt32_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                 ->_R Sym (Foreign.C.Types.N:CInt[0])
                                 ->_R <Ordering>_R
                                 :: (Int32 -> Int32 -> Ordering :: *)
                                    ~R# (CInt -> CInt -> Ordering :: *))
                         GHC.Int.ltInt32
                         `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                 ->_R Sym (Foreign.C.Types.N:CInt[0])
                                 ->_R <Bool>_R
                                 :: (Int32 -> Int32 -> Bool :: *) ~R# (CInt -> CInt -> Bool :: *))
                         GHC.Int.leInt32
                         `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                 ->_R Sym (Foreign.C.Types.N:CInt[0])
                                 ->_R <Bool>_R
                                 :: (Int32 -> Int32 -> Bool :: *) ~R# (CInt -> CInt -> Bool :: *))
                         GHC.Int.gtInt32
                         `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                 ->_R Sym (Foreign.C.Types.N:CInt[0])
                                 ->_R <Bool>_R
                                 :: (Int32 -> Int32 -> Bool :: *) ~R# (CInt -> CInt -> Bool :: *))
                         GHC.Int.geInt32
                         `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                 ->_R Sym (Foreign.C.Types.N:CInt[0])
                                 ->_R <Bool>_R
                                 :: (Int32 -> Int32 -> Bool :: *) ~R# (CInt -> CInt -> Bool :: *))
                         GHC.Int.$fOrdInt32_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                 ->_R Sym (Foreign.C.Types.N:CInt[0])
                                 ->_R Sym (Foreign.C.Types.N:CInt[0])
                                 :: (Int32 -> Int32 -> Int32 :: *) ~R# (CInt -> CInt -> CInt :: *))
                         GHC.Int.$fOrdInt32_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                 ->_R Sym (Foreign.C.Types.N:CInt[0])
                                 ->_R Sym (Foreign.C.Types.N:CInt[0])
                                 :: (Int32 -> Int32 -> Int32 :: *) ~R# (CInt -> CInt -> CInt :: *))]
Foreign.C.Types.$fOrdCInt
  = GHC.Classes.C:Ord
      @ CInt
      Foreign.C.Types.$fEqCInt
      (GHC.Int.$fOrdInt32_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R <Ordering>_R
               :: (Int32 -> Int32 -> Ordering :: *)
                  ~R# (CInt -> CInt -> Ordering :: *)))
      (GHC.Int.ltInt32
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R <Bool>_R
               :: (Int32 -> Int32 -> Bool :: *) ~R# (CInt -> CInt -> Bool :: *)))
      (GHC.Int.leInt32
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R <Bool>_R
               :: (Int32 -> Int32 -> Bool :: *) ~R# (CInt -> CInt -> Bool :: *)))
      (GHC.Int.gtInt32
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R <Bool>_R
               :: (Int32 -> Int32 -> Bool :: *) ~R# (CInt -> CInt -> Bool :: *)))
      (GHC.Int.geInt32
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R <Bool>_R
               :: (Int32 -> Int32 -> Bool :: *) ~R# (CInt -> CInt -> Bool :: *)))
      (GHC.Int.$fOrdInt32_$cmax
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int32 -> Int32 :: *) ~R# (CInt -> CInt -> CInt :: *)))
      (GHC.Int.$fOrdInt32_$cmin
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int32 -> Int32 :: *) ~R# (CInt -> CInt -> CInt :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CInt
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CInt
                       Foreign.C.Types.$fNumCInt
                       Foreign.C.Types.$fOrdCInt
                       GHC.Int.$fRealInt32_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Ratio Integer>_R
                               :: (Int32 -> Ratio Integer :: *) ~R# (CInt -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCInt
  = GHC.Real.C:Real
      @ CInt
      Foreign.C.Types.$fNumCInt
      Foreign.C.Types.$fOrdCInt
      (GHC.Int.$fRealInt32_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Ratio Integer>_R
               :: (Int32 -> Ratio Integer :: *) ~R# (CInt -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.C.Types.$fIntegralCInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral CInt
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: CInt
                           Foreign.C.Types.$fRealCInt
                           Foreign.C.Types.$fEnumCInt
                           GHC.Int.$fIntegralInt32_$cquot
                           `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                   ->_R Sym (Foreign.C.Types.N:CInt[0])
                                   ->_R Sym (Foreign.C.Types.N:CInt[0])
                                   :: (Int32 -> Int32 -> Int32 :: *)
                                      ~R# (CInt -> CInt -> CInt :: *))
                           GHC.Int.$fIntegralInt32_$crem
                           `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                   ->_R Sym (Foreign.C.Types.N:CInt[0])
                                   ->_R Sym (Foreign.C.Types.N:CInt[0])
                                   :: (Int32 -> Int32 -> Int32 :: *)
                                      ~R# (CInt -> CInt -> CInt :: *))
                           GHC.Int.$fIntegralInt32_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                   ->_R Sym (Foreign.C.Types.N:CInt[0])
                                   ->_R Sym (Foreign.C.Types.N:CInt[0])
                                   :: (Int32 -> Int32 -> Int32 :: *)
                                      ~R# (CInt -> CInt -> CInt :: *))
                           GHC.Int.$fIntegralInt32_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                   ->_R Sym (Foreign.C.Types.N:CInt[0])
                                   ->_R Sym (Foreign.C.Types.N:CInt[0])
                                   :: (Int32 -> Int32 -> Int32 :: *)
                                      ~R# (CInt -> CInt -> CInt :: *))
                           GHC.Int.$fIntegralInt32_$cquotRem
                           `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                   ->_R Sym (Foreign.C.Types.N:CInt[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CInt[0]))
                                           (Sym (Foreign.C.Types.N:CInt[0])))_R
                                   :: (Int32 -> Int32 -> (Int32, Int32) :: *)
                                      ~R# (CInt -> CInt -> (CInt, CInt) :: *))
                           GHC.Int.$fIntegralInt32_$cdivMod
                           `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                   ->_R Sym (Foreign.C.Types.N:CInt[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CInt[0]))
                                           (Sym (Foreign.C.Types.N:CInt[0])))_R
                                   :: (Int32 -> Int32 -> (Int32, Int32) :: *)
                                      ~R# (CInt -> CInt -> (CInt, CInt) :: *))
                           GHC.Int.$fIntegralInt32_$ctoInteger
                           `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Integer>_R
                                   :: (Int32 -> Integer :: *) ~R# (CInt -> Integer :: *))]
Foreign.C.Types.$fIntegralCInt
  = GHC.Real.C:Integral
      @ CInt
      Foreign.C.Types.$fRealCInt
      Foreign.C.Types.$fEnumCInt
      (GHC.Int.$fIntegralInt32_$cquot
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int32 -> Int32 :: *) ~R# (CInt -> CInt -> CInt :: *)))
      (GHC.Int.$fIntegralInt32_$crem
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int32 -> Int32 :: *) ~R# (CInt -> CInt -> CInt :: *)))
      (GHC.Int.$fIntegralInt32_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int32 -> Int32 :: *) ~R# (CInt -> CInt -> CInt :: *)))
      (GHC.Int.$fIntegralInt32_$cmod
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int32 -> Int32 :: *) ~R# (CInt -> CInt -> CInt :: *)))
      (GHC.Int.$fIntegralInt32_$cquotRem
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CInt[0]))
                       (Sym (Foreign.C.Types.N:CInt[0])))_R
               :: (Int32 -> Int32 -> (Int32, Int32) :: *)
                  ~R# (CInt -> CInt -> (CInt, CInt) :: *)))
      (GHC.Int.$fIntegralInt32_$cdivMod
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CInt[0]))
                       (Sym (Foreign.C.Types.N:CInt[0])))_R
               :: (Int32 -> Int32 -> (Int32, Int32) :: *)
                  ~R# (CInt -> CInt -> (CInt, CInt) :: *)))
      (GHC.Int.$fIntegralInt32_$ctoInteger
       `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Integer>_R
               :: (Int32 -> Integer :: *) ~R# (CInt -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.C.Types.$fBitsCInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits CInt
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: CInt
                        Foreign.C.Types.$fEqCInt
                        GHC.Int.$fBitsInt32_$c.&.
                        `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                ->_R Sym (Foreign.C.Types.N:CInt[0])
                                ->_R Sym (Foreign.C.Types.N:CInt[0])
                                :: (Int32 -> Int32 -> Int32 :: *) ~R# (CInt -> CInt -> CInt :: *))
                        GHC.Int.$fBitsInt32_$c.|.
                        `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                ->_R Sym (Foreign.C.Types.N:CInt[0])
                                ->_R Sym (Foreign.C.Types.N:CInt[0])
                                :: (Int32 -> Int32 -> Int32 :: *) ~R# (CInt -> CInt -> CInt :: *))
                        GHC.Int.$fBitsInt32_$cxor
                        `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                ->_R Sym (Foreign.C.Types.N:CInt[0])
                                ->_R Sym (Foreign.C.Types.N:CInt[0])
                                :: (Int32 -> Int32 -> Int32 :: *) ~R# (CInt -> CInt -> CInt :: *))
                        GHC.Int.$fBitsInt32_$ccomplement
                        `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                ->_R Sym (Foreign.C.Types.N:CInt[0])
                                :: (Int32 -> Int32 :: *) ~R# (CInt -> CInt :: *))
                        GHC.Int.$fBitsInt32_$cshift
                        `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CInt[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *))
                        GHC.Int.$fBitsInt32_$crotate
                        `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CInt[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *))
                        GHC.Int.$fBitsInt6
                        `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                :: (Int32 :: *) ~R# (CInt :: *))
                        GHC.Int.$fBitsInt32_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CInt[0])
                                :: (Int -> Int32 :: *) ~R# (Int -> CInt :: *))
                        GHC.Int.$fBitsInt32_$csetBit
                        `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CInt[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *))
                        GHC.Int.$fBitsInt32_$cclearBit
                        `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CInt[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *))
                        GHC.Int.$fBitsInt32_$ccomplementBit
                        `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CInt[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *))
                        GHC.Int.$fBitsInt32_$ctestBit
                        `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Int -> Bool>_R
                                :: (Int32 -> Int -> Bool :: *) ~R# (CInt -> Int -> Bool :: *))
                        GHC.Int.$fBitsInt32_$cbitSizeMaybe
                        `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Maybe Int>_R
                                :: (Int32 -> Maybe Int :: *) ~R# (CInt -> Maybe Int :: *))
                        GHC.Int.$fBitsInt32_$cfiniteBitSize
                        `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Int>_R
                                :: (Int32 -> Int :: *) ~R# (CInt -> Int :: *))
                        GHC.Int.$fBitsInt32_$cisSigned
                        `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Bool>_R
                                :: (Int32 -> Bool :: *) ~R# (CInt -> Bool :: *))
                        GHC.Int.$fBitsInt32_$cshiftL
                        `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CInt[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *))
                        GHC.Int.$fBitsInt32_$cunsafeShiftL
                        `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CInt[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *))
                        GHC.Int.$fBitsInt32_$cshiftR
                        `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CInt[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *))
                        GHC.Int.$fBitsInt32_$cunsafeShiftR
                        `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CInt[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *))
                        GHC.Int.$fBitsInt32_$crotateL
                        `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CInt[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *))
                        GHC.Int.$fBitsInt32_$crotateR
                        `cast` (Sym (Foreign.C.Types.N:CInt[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CInt[0])
                                :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *))
                        GHC.Int.$fBitsInt32_$cpopCount
                        `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Int>_R
                                :: (Int32 -> Int :: *) ~R# (CInt -> Int :: *))]
Foreign.C.Types.$fBitsCInt
  = Data.Bits.C:Bits
      @ CInt
      Foreign.C.Types.$fEqCInt
      (GHC.Int.$fBitsInt32_$c.&.
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int32 -> Int32 :: *) ~R# (CInt -> CInt -> CInt :: *)))
      (GHC.Int.$fBitsInt32_$c.|.
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int32 -> Int32 :: *) ~R# (CInt -> CInt -> CInt :: *)))
      (GHC.Int.$fBitsInt32_$cxor
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int32 -> Int32 :: *) ~R# (CInt -> CInt -> CInt :: *)))
      (GHC.Int.$fBitsInt32_$ccomplement
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int32 :: *) ~R# (CInt -> CInt :: *)))
      (GHC.Int.$fBitsInt32_$cshift
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *)))
      (GHC.Int.$fBitsInt32_$crotate
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *)))
      (GHC.Int.$fBitsInt6
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 :: *) ~R# (CInt :: *)))
      (GHC.Int.$fBitsInt32_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int -> Int32 :: *) ~R# (Int -> CInt :: *)))
      (GHC.Int.$fBitsInt32_$csetBit
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *)))
      (GHC.Int.$fBitsInt32_$cclearBit
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *)))
      (GHC.Int.$fBitsInt32_$ccomplementBit
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *)))
      (GHC.Int.$fBitsInt32_$ctestBit
       `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Int -> Bool>_R
               :: (Int32 -> Int -> Bool :: *) ~R# (CInt -> Int -> Bool :: *)))
      (GHC.Int.$fBitsInt32_$cbitSizeMaybe
       `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Maybe Int>_R
               :: (Int32 -> Maybe Int :: *) ~R# (CInt -> Maybe Int :: *)))
      (GHC.Int.$fBitsInt32_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CInt -> Int :: *)))
      (GHC.Int.$fBitsInt32_$cisSigned
       `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Bool>_R
               :: (Int32 -> Bool :: *) ~R# (CInt -> Bool :: *)))
      (GHC.Int.$fBitsInt32_$cshiftL
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *)))
      (GHC.Int.$fBitsInt32_$cunsafeShiftL
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *)))
      (GHC.Int.$fBitsInt32_$cshiftR
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *)))
      (GHC.Int.$fBitsInt32_$cunsafeShiftR
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *)))
      (GHC.Int.$fBitsInt32_$crotateL
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *)))
      (GHC.Int.$fBitsInt32_$crotateR
       `cast` (Sym (Foreign.C.Types.N:CInt[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CInt[0])
               :: (Int32 -> Int -> Int32 :: *) ~R# (CInt -> Int -> CInt :: *)))
      (GHC.Int.$fBitsInt32_$cpopCount
       `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CInt -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.C.Types.$fFiniteBitsCInt [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits CInt
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: CInt
                              Foreign.C.Types.$fBitsCInt
                              GHC.Int.$fBitsInt32_$cfiniteBitSize
                              `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Int>_R
                                      :: (Int32 -> Int :: *) ~R# (CInt -> Int :: *))
                              GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros
                              `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Int>_R
                                      :: (Int32 -> Int :: *) ~R# (CInt -> Int :: *))
                              GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros
                              `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Int>_R
                                      :: (Int32 -> Int :: *) ~R# (CInt -> Int :: *))]
Foreign.C.Types.$fFiniteBitsCInt
  = Data.Bits.C:FiniteBits
      @ CInt
      Foreign.C.Types.$fBitsCInt
      (GHC.Int.$fBitsInt32_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CInt -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt32_$ccountLeadingZeros
       `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CInt -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt32_$ccountTrailingZeros
       `cast` (Sym (Foreign.C.Types.N:CInt[0]) ->_R <Int>_R
               :: (Int32 -> Int :: *) ~R# (CInt -> Int :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCUShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CUShort
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CUShort
                       GHC.Word.$fShowWord16_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CUShort[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Word16 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CUShort -> [Char] -> [Char] :: *))
                       GHC.Word.$fShowWord16_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <[Char]>_R
                               :: (Word16 -> [Char] :: *) ~R# (CUShort -> [Char] :: *))
                       GHC.Word.$fShowWord16_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CUShort[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Word16] -> [Char] -> [Char] :: *)
                                  ~R# ([CUShort] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCUShort
  = GHC.Show.C:Show
      @ CUShort
      (GHC.Word.$fShowWord16_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Word16 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CUShort -> [Char] -> [Char] :: *)))
      (GHC.Word.$fShowWord16_$cshow
       `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <[Char]>_R
               :: (Word16 -> [Char] :: *) ~R# (CUShort -> [Char] :: *)))
      (GHC.Word.$fShowWord16_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CUShort[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Word16] -> [Char] -> [Char] :: *)
                  ~R# ([CUShort] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCUShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CUShort
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CUShort
                       GHC.Read.$fReadWord16_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CUShort[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Word16, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CUShort, [Char])] :: *))
                       GHC.Read.$fReadWord16_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CUShort[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Word16], [Char])] :: *)
                                  ~R# ([Char] -> [([CUShort], [Char])] :: *))
                       GHC.Read.$fReadWord6
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Word16>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      (Foreign.C.Types.N:CUShort[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Word16 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CUShort :: *))
                       GHC.Read.$fReadWord4
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Word16]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                        ([Foreign.C.Types.N:CUShort[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Word16] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CUShort] :: *))]
Foreign.C.Types.$fReadCUShort
  = GHC.Read.C:Read
      @ CUShort
      (GHC.Read.$fReadWord16_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CUShort[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Word16, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CUShort, [Char])] :: *)))
      (GHC.Read.$fReadWord16_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CUShort[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Word16], [Char])] :: *)
                  ~R# ([Char] -> [([CUShort], [Char])] :: *)))
      (GHC.Read.$fReadWord6
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Word16>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                      (Foreign.C.Types.N:CUShort[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Word16 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CUShort :: *)))
      (GHC.Read.$fReadWord4
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Word16]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                        ([Foreign.C.Types.N:CUShort[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Word16] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CUShort] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.C.Types.$fBoundedCUShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded CUShort
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: CUShort
                          GHC.Word.$fBitsWord16_$cminBound
                          `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                  :: (Word16 :: *) ~R# (CUShort :: *))
                          GHC.Word.$fBoundedWord16_$cmaxBound
                          `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                  :: (Word16 :: *) ~R# (CUShort :: *))]
Foreign.C.Types.$fBoundedCUShort
  = GHC.Enum.C:Bounded
      @ CUShort
      (GHC.Word.$fBitsWord16_$cminBound
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 :: *) ~R# (CUShort :: *)))
      (GHC.Word.$fBoundedWord16_$cmaxBound
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 :: *) ~R# (CUShort :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCUShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CUShort
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CUShort
                                   Foreign.Storable.$fStorableWord16_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Int>_R
                                           :: (Word16 -> Int :: *) ~R# (CUShort -> Int :: *))
                                   Foreign.Storable.$fStorableWord16_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Int>_R
                                           :: (Word16 -> Int :: *) ~R# (CUShort -> Int :: *))
                                   GHC.Storable.readWord16OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word16, CUShort))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CUShort[0]))
                                           :: (GHC.Ptr.Ptr Word16
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word16 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUShort -> Int -> IO CUShort :: *))
                                   GHC.Storable.writeWord16OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word16, CUShort))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Word16
                                               -> Int
                                               -> Word16
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUShort
                                                   -> Int -> CUShort -> IO () :: *))
                                   Foreign.Storable.$fStorableWord9
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CUShort[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word16 #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> IO CUShort :: *))
                                   Foreign.Storable.$fStorableWord7
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Word16
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CUShort -> IO () :: *))
                                   Foreign.Storable.$fStorableWord6
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word16, CUShort))_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CUShort[0]))
                                           :: (GHC.Ptr.Ptr Word16
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word16 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUShort -> IO CUShort :: *))
                                   Foreign.Storable.$fStorableWord5
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word16, CUShort))_R
                                           ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Word16
                                               -> Word16
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUShort -> CUShort -> IO () :: *))]
Foreign.C.Types.$fStorableCUShort
  = Foreign.Storable.C:Storable
      @ CUShort
      (Foreign.Storable.$fStorableWord16_$calignment
       `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Int>_R
               :: (Word16 -> Int :: *) ~R# (CUShort -> Int :: *)))
      (Foreign.Storable.$fStorableWord16_$calignment
       `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Int>_R
               :: (Word16 -> Int :: *) ~R# (CUShort -> Int :: *)))
      (GHC.Storable.readWord16OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word16, CUShort))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUShort[0]))
               :: (GHC.Ptr.Ptr Word16
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word16 #) :: *)
                  ~R# (GHC.Ptr.Ptr CUShort -> Int -> IO CUShort :: *)))
      (GHC.Storable.writeWord16OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word16, CUShort))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Word16
                   -> Int
                   -> Word16
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CUShort -> Int -> CUShort -> IO () :: *)))
      (Foreign.Storable.$fStorableWord9
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUShort[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word16 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CUShort :: *)))
      (Foreign.Storable.$fStorableWord7
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Word16
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CUShort -> IO () :: *)))
      (Foreign.Storable.$fStorableWord6
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word16, CUShort))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUShort[0]))
               :: (GHC.Ptr.Ptr Word16
                   -> State# RealWorld -> (# State# RealWorld, Word16 #) :: *)
                  ~R# (GHC.Ptr.Ptr CUShort -> IO CUShort :: *)))
      (Foreign.Storable.$fStorableWord5
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word16, CUShort))_R
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Word16
                   -> Word16 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CUShort -> CUShort -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCUShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CUShort
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CUShort
                       GHC.Word.$fEnumWord16_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                               ->_R Sym (Foreign.C.Types.N:CUShort[0])
                               :: (Word16 -> Word16 :: *) ~R# (CUShort -> CUShort :: *))
                       GHC.Word.$fEnumWord16_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                               ->_R Sym (Foreign.C.Types.N:CUShort[0])
                               :: (Word16 -> Word16 :: *) ~R# (CUShort -> CUShort :: *))
                       GHC.Word.$fEnumWord16_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUShort[0])
                               :: (Int -> Word16 :: *) ~R# (Int -> CUShort :: *))
                       GHC.Word.$fEnumWord16_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Int>_R
                               :: (Word16 -> Int :: *) ~R# (CUShort -> Int :: *))
                       GHC.Word.$fEnumWord16_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUShort[0])])_R
                               :: (Word16 -> [Word16] :: *) ~R# (CUShort -> [CUShort] :: *))
                       GHC.Word.$fEnumWord16_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                               ->_R Sym (Foreign.C.Types.N:CUShort[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUShort[0])])_R
                               :: (Word16 -> Word16 -> [Word16] :: *)
                                  ~R# (CUShort -> CUShort -> [CUShort] :: *))
                       GHC.Word.$fEnumWord16_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                               ->_R Sym (Foreign.C.Types.N:CUShort[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUShort[0])])_R
                               :: (Word16 -> Word16 -> [Word16] :: *)
                                  ~R# (CUShort -> CUShort -> [CUShort] :: *))
                       GHC.Word.$fEnumWord16_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                               ->_R Sym (Foreign.C.Types.N:CUShort[0])
                               ->_R Sym (Foreign.C.Types.N:CUShort[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUShort[0])])_R
                               :: (Word16 -> Word16 -> Word16 -> [Word16] :: *)
                                  ~R# (CUShort -> CUShort -> CUShort -> [CUShort] :: *))]
Foreign.C.Types.$fEnumCUShort
  = GHC.Enum.C:Enum
      @ CUShort
      (GHC.Word.$fEnumWord16_$csucc
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Word16 :: *) ~R# (CUShort -> CUShort :: *)))
      (GHC.Word.$fEnumWord16_$cpred
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Word16 :: *) ~R# (CUShort -> CUShort :: *)))
      (GHC.Word.$fEnumWord16_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Int -> Word16 :: *) ~R# (Int -> CUShort :: *)))
      (GHC.Word.$fEnumWord16_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Int>_R
               :: (Word16 -> Int :: *) ~R# (CUShort -> Int :: *)))
      (GHC.Word.$fEnumWord16_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R ([Sym (Foreign.C.Types.N:CUShort[0])])_R
               :: (Word16 -> [Word16] :: *) ~R# (CUShort -> [CUShort] :: *)))
      (GHC.Word.$fEnumWord16_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R ([Sym (Foreign.C.Types.N:CUShort[0])])_R
               :: (Word16 -> Word16 -> [Word16] :: *)
                  ~R# (CUShort -> CUShort -> [CUShort] :: *)))
      (GHC.Word.$fEnumWord16_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R ([Sym (Foreign.C.Types.N:CUShort[0])])_R
               :: (Word16 -> Word16 -> [Word16] :: *)
                  ~R# (CUShort -> CUShort -> [CUShort] :: *)))
      (GHC.Word.$fEnumWord16_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R ([Sym (Foreign.C.Types.N:CUShort[0])])_R
               :: (Word16 -> Word16 -> Word16 -> [Word16] :: *)
                  ~R# (CUShort -> CUShort -> CUShort -> [CUShort] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCUShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CUShort
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CUShort
                     GHC.Word.$fNumWord16_$c+
                     `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                             ->_R Sym (Foreign.C.Types.N:CUShort[0])
                             ->_R Sym (Foreign.C.Types.N:CUShort[0])
                             :: (Word16 -> Word16 -> Word16 :: *)
                                ~R# (CUShort -> CUShort -> CUShort :: *))
                     GHC.Word.$fNumWord16_$c-
                     `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                             ->_R Sym (Foreign.C.Types.N:CUShort[0])
                             ->_R Sym (Foreign.C.Types.N:CUShort[0])
                             :: (Word16 -> Word16 -> Word16 :: *)
                                ~R# (CUShort -> CUShort -> CUShort :: *))
                     GHC.Word.$fNumWord16_$c*
                     `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                             ->_R Sym (Foreign.C.Types.N:CUShort[0])
                             ->_R Sym (Foreign.C.Types.N:CUShort[0])
                             :: (Word16 -> Word16 -> Word16 :: *)
                                ~R# (CUShort -> CUShort -> CUShort :: *))
                     GHC.Word.$fNumWord16_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                             ->_R Sym (Foreign.C.Types.N:CUShort[0])
                             :: (Word16 -> Word16 :: *) ~R# (CUShort -> CUShort :: *))
                     GHC.Word.$fNumWord16_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                             ->_R Sym (Foreign.C.Types.N:CUShort[0])
                             :: (Word16 -> Word16 :: *) ~R# (CUShort -> CUShort :: *))
                     GHC.Word.$fNumWord16_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                             ->_R Sym (Foreign.C.Types.N:CUShort[0])
                             :: (Word16 -> Word16 :: *) ~R# (CUShort -> CUShort :: *))
                     GHC.Word.$fNumWord16_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CUShort[0])
                             :: (Integer -> Word16 :: *) ~R# (Integer -> CUShort :: *))]
Foreign.C.Types.$fNumCUShort
  = GHC.Num.C:Num
      @ CUShort
      (GHC.Word.$fNumWord16_$c+
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Word16 -> Word16 :: *)
                  ~R# (CUShort -> CUShort -> CUShort :: *)))
      (GHC.Word.$fNumWord16_$c-
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Word16 -> Word16 :: *)
                  ~R# (CUShort -> CUShort -> CUShort :: *)))
      (GHC.Word.$fNumWord16_$c*
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Word16 -> Word16 :: *)
                  ~R# (CUShort -> CUShort -> CUShort :: *)))
      (GHC.Word.$fNumWord16_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Word16 :: *) ~R# (CUShort -> CUShort :: *)))
      (GHC.Word.$fNumWord16_$cabs
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Word16 :: *) ~R# (CUShort -> CUShort :: *)))
      (GHC.Word.$fNumWord16_$csignum
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Word16 :: *) ~R# (CUShort -> CUShort :: *)))
      (GHC.Word.$fNumWord16_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Integer -> Word16 :: *) ~R# (Integer -> CUShort :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCUShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CUShort
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CUShort
                        GHC.Word.eqWord16
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R <Bool>_R
                                :: (Word16 -> Word16 -> Bool :: *)
                                   ~R# (CUShort -> CUShort -> Bool :: *))
                        GHC.Word.neWord16
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R <Bool>_R
                                :: (Word16 -> Word16 -> Bool :: *)
                                   ~R# (CUShort -> CUShort -> Bool :: *))]
Foreign.C.Types.$fEqCUShort
  = GHC.Classes.C:Eq
      @ CUShort
      (GHC.Word.eqWord16
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R <Bool>_R
               :: (Word16 -> Word16 -> Bool :: *)
                  ~R# (CUShort -> CUShort -> Bool :: *)))
      (GHC.Word.neWord16
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R <Bool>_R
               :: (Word16 -> Word16 -> Bool :: *)
                  ~R# (CUShort -> CUShort -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCUShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CUShort
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CUShort
                         Foreign.C.Types.$fEqCUShort
                         GHC.Word.$fOrdWord16_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                 ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                 ->_R <Ordering>_R
                                 :: (Word16 -> Word16 -> Ordering :: *)
                                    ~R# (CUShort -> CUShort -> Ordering :: *))
                         GHC.Word.ltWord16
                         `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                 ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                 ->_R <Bool>_R
                                 :: (Word16 -> Word16 -> Bool :: *)
                                    ~R# (CUShort -> CUShort -> Bool :: *))
                         GHC.Word.leWord16
                         `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                 ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                 ->_R <Bool>_R
                                 :: (Word16 -> Word16 -> Bool :: *)
                                    ~R# (CUShort -> CUShort -> Bool :: *))
                         GHC.Word.gtWord16
                         `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                 ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                 ->_R <Bool>_R
                                 :: (Word16 -> Word16 -> Bool :: *)
                                    ~R# (CUShort -> CUShort -> Bool :: *))
                         GHC.Word.geWord16
                         `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                 ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                 ->_R <Bool>_R
                                 :: (Word16 -> Word16 -> Bool :: *)
                                    ~R# (CUShort -> CUShort -> Bool :: *))
                         GHC.Word.$fOrdWord16_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                 ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                 ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                 :: (Word16 -> Word16 -> Word16 :: *)
                                    ~R# (CUShort -> CUShort -> CUShort :: *))
                         GHC.Word.$fOrdWord16_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                 ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                 ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                 :: (Word16 -> Word16 -> Word16 :: *)
                                    ~R# (CUShort -> CUShort -> CUShort :: *))]
Foreign.C.Types.$fOrdCUShort
  = GHC.Classes.C:Ord
      @ CUShort
      Foreign.C.Types.$fEqCUShort
      (GHC.Word.$fOrdWord16_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R <Ordering>_R
               :: (Word16 -> Word16 -> Ordering :: *)
                  ~R# (CUShort -> CUShort -> Ordering :: *)))
      (GHC.Word.ltWord16
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R <Bool>_R
               :: (Word16 -> Word16 -> Bool :: *)
                  ~R# (CUShort -> CUShort -> Bool :: *)))
      (GHC.Word.leWord16
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R <Bool>_R
               :: (Word16 -> Word16 -> Bool :: *)
                  ~R# (CUShort -> CUShort -> Bool :: *)))
      (GHC.Word.gtWord16
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R <Bool>_R
               :: (Word16 -> Word16 -> Bool :: *)
                  ~R# (CUShort -> CUShort -> Bool :: *)))
      (GHC.Word.geWord16
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R <Bool>_R
               :: (Word16 -> Word16 -> Bool :: *)
                  ~R# (CUShort -> CUShort -> Bool :: *)))
      (GHC.Word.$fOrdWord16_$cmax
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Word16 -> Word16 :: *)
                  ~R# (CUShort -> CUShort -> CUShort :: *)))
      (GHC.Word.$fOrdWord16_$cmin
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Word16 -> Word16 :: *)
                  ~R# (CUShort -> CUShort -> CUShort :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCUShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CUShort
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CUShort
                       Foreign.C.Types.$fNumCUShort
                       Foreign.C.Types.$fOrdCUShort
                       GHC.Word.$fRealWord16_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Ratio Integer>_R
                               :: (Word16 -> Ratio Integer :: *)
                                  ~R# (CUShort -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCUShort
  = GHC.Real.C:Real
      @ CUShort
      Foreign.C.Types.$fNumCUShort
      Foreign.C.Types.$fOrdCUShort
      (GHC.Word.$fRealWord16_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Ratio Integer>_R
               :: (Word16 -> Ratio Integer :: *)
                  ~R# (CUShort -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.C.Types.$fIntegralCUShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral CUShort
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: CUShort
                           Foreign.C.Types.$fRealCUShort
                           Foreign.C.Types.$fEnumCUShort
                           GHC.Word.$fIntegralWord16_$cquot
                           `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                   ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                   ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                   :: (Word16 -> Word16 -> Word16 :: *)
                                      ~R# (CUShort -> CUShort -> CUShort :: *))
                           GHC.Word.$fIntegralWord16_$crem
                           `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                   ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                   ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                   :: (Word16 -> Word16 -> Word16 :: *)
                                      ~R# (CUShort -> CUShort -> CUShort :: *))
                           GHC.Word.$fIntegralWord16_$cquot
                           `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                   ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                   ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                   :: (Word16 -> Word16 -> Word16 :: *)
                                      ~R# (CUShort -> CUShort -> CUShort :: *))
                           GHC.Word.$fIntegralWord16_$crem
                           `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                   ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                   ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                   :: (Word16 -> Word16 -> Word16 :: *)
                                      ~R# (CUShort -> CUShort -> CUShort :: *))
                           GHC.Word.$fIntegralWord16_$cquotRem
                           `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                   ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CUShort[0]))
                                           (Sym (Foreign.C.Types.N:CUShort[0])))_R
                                   :: (Word16 -> Word16 -> (Word16, Word16) :: *)
                                      ~R# (CUShort -> CUShort -> (CUShort, CUShort) :: *))
                           GHC.Word.$fIntegralWord16_$cdivMod
                           `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                   ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CUShort[0]))
                                           (Sym (Foreign.C.Types.N:CUShort[0])))_R
                                   :: (Word16 -> Word16 -> (Word16, Word16) :: *)
                                      ~R# (CUShort -> CUShort -> (CUShort, CUShort) :: *))
                           GHC.Word.$ctoInteger1
                           `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Integer>_R
                                   :: (Word16 -> Integer :: *) ~R# (CUShort -> Integer :: *))]
Foreign.C.Types.$fIntegralCUShort
  = GHC.Real.C:Integral
      @ CUShort
      Foreign.C.Types.$fRealCUShort
      Foreign.C.Types.$fEnumCUShort
      (GHC.Word.$fIntegralWord16_$cquot
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Word16 -> Word16 :: *)
                  ~R# (CUShort -> CUShort -> CUShort :: *)))
      (GHC.Word.$fIntegralWord16_$crem
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Word16 -> Word16 :: *)
                  ~R# (CUShort -> CUShort -> CUShort :: *)))
      (GHC.Word.$fIntegralWord16_$cquot
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Word16 -> Word16 :: *)
                  ~R# (CUShort -> CUShort -> CUShort :: *)))
      (GHC.Word.$fIntegralWord16_$crem
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Word16 -> Word16 :: *)
                  ~R# (CUShort -> CUShort -> CUShort :: *)))
      (GHC.Word.$fIntegralWord16_$cquotRem
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CUShort[0]))
                       (Sym (Foreign.C.Types.N:CUShort[0])))_R
               :: (Word16 -> Word16 -> (Word16, Word16) :: *)
                  ~R# (CUShort -> CUShort -> (CUShort, CUShort) :: *)))
      (GHC.Word.$fIntegralWord16_$cdivMod
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CUShort[0]))
                       (Sym (Foreign.C.Types.N:CUShort[0])))_R
               :: (Word16 -> Word16 -> (Word16, Word16) :: *)
                  ~R# (CUShort -> CUShort -> (CUShort, CUShort) :: *)))
      (GHC.Word.$ctoInteger1
       `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Integer>_R
               :: (Word16 -> Integer :: *) ~R# (CUShort -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.C.Types.$fBitsCUShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits CUShort
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: CUShort
                        Foreign.C.Types.$fEqCUShort
                        GHC.Word.$fBitsWord16_$c.&.
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                :: (Word16 -> Word16 -> Word16 :: *)
                                   ~R# (CUShort -> CUShort -> CUShort :: *))
                        GHC.Word.$fBitsWord16_$c.|.
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                :: (Word16 -> Word16 -> Word16 :: *)
                                   ~R# (CUShort -> CUShort -> CUShort :: *))
                        GHC.Word.$fBitsWord16_$cxor
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                :: (Word16 -> Word16 -> Word16 :: *)
                                   ~R# (CUShort -> CUShort -> CUShort :: *))
                        GHC.Word.$fBitsWord16_$ccomplement
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                :: (Word16 -> Word16 :: *) ~R# (CUShort -> CUShort :: *))
                        GHC.Word.$fBitsWord16_$cshift
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                :: (Word16 -> Int -> Word16 :: *)
                                   ~R# (CUShort -> Int -> CUShort :: *))
                        GHC.Word.$fBitsWord16_$crotate
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                :: (Word16 -> Int -> Word16 :: *)
                                   ~R# (CUShort -> Int -> CUShort :: *))
                        GHC.Word.$fBitsWord16_$cminBound
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                :: (Word16 :: *) ~R# (CUShort :: *))
                        GHC.Word.$fBitsWord16_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                :: (Int -> Word16 :: *) ~R# (Int -> CUShort :: *))
                        GHC.Word.$fBitsWord16_$csetBit
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                :: (Word16 -> Int -> Word16 :: *)
                                   ~R# (CUShort -> Int -> CUShort :: *))
                        GHC.Word.$fBitsWord16_$cclearBit
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                :: (Word16 -> Int -> Word16 :: *)
                                   ~R# (CUShort -> Int -> CUShort :: *))
                        GHC.Word.$fBitsWord16_$ccomplementBit
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                :: (Word16 -> Int -> Word16 :: *)
                                   ~R# (CUShort -> Int -> CUShort :: *))
                        GHC.Word.$fBitsWord16_$ctestBit
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Int -> Bool>_R
                                :: (Word16 -> Int -> Bool :: *) ~R# (CUShort -> Int -> Bool :: *))
                        GHC.Word.$fBitsWord16_$cbitSizeMaybe
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Maybe Int>_R
                                :: (Word16 -> Maybe Int :: *) ~R# (CUShort -> Maybe Int :: *))
                        GHC.Word.$fBitsWord16_$cfiniteBitSize
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Int>_R
                                :: (Word16 -> Int :: *) ~R# (CUShort -> Int :: *))
                        GHC.Word.$fBitsWord16_$cisSigned
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Bool>_R
                                :: (Word16 -> Bool :: *) ~R# (CUShort -> Bool :: *))
                        GHC.Word.$fBitsWord16_$cshiftL
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                :: (Word16 -> Int -> Word16 :: *)
                                   ~R# (CUShort -> Int -> CUShort :: *))
                        GHC.Word.$fBitsWord16_$cunsafeShiftL
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                :: (Word16 -> Int -> Word16 :: *)
                                   ~R# (CUShort -> Int -> CUShort :: *))
                        GHC.Word.$fBitsWord16_$cshiftR
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                :: (Word16 -> Int -> Word16 :: *)
                                   ~R# (CUShort -> Int -> CUShort :: *))
                        GHC.Word.$fBitsWord16_$cunsafeShiftR
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                :: (Word16 -> Int -> Word16 :: *)
                                   ~R# (CUShort -> Int -> CUShort :: *))
                        GHC.Word.$fBitsWord16_$crotateL
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                :: (Word16 -> Int -> Word16 :: *)
                                   ~R# (CUShort -> Int -> CUShort :: *))
                        GHC.Word.$fBitsWord16_$crotateR
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUShort[0])
                                :: (Word16 -> Int -> Word16 :: *)
                                   ~R# (CUShort -> Int -> CUShort :: *))
                        GHC.Word.$fBitsWord16_$cpopCount
                        `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Int>_R
                                :: (Word16 -> Int :: *) ~R# (CUShort -> Int :: *))]
Foreign.C.Types.$fBitsCUShort
  = Data.Bits.C:Bits
      @ CUShort
      Foreign.C.Types.$fEqCUShort
      (GHC.Word.$fBitsWord16_$c.&.
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Word16 -> Word16 :: *)
                  ~R# (CUShort -> CUShort -> CUShort :: *)))
      (GHC.Word.$fBitsWord16_$c.|.
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Word16 -> Word16 :: *)
                  ~R# (CUShort -> CUShort -> CUShort :: *)))
      (GHC.Word.$fBitsWord16_$cxor
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Word16 -> Word16 :: *)
                  ~R# (CUShort -> CUShort -> CUShort :: *)))
      (GHC.Word.$fBitsWord16_$ccomplement
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Word16 :: *) ~R# (CUShort -> CUShort :: *)))
      (GHC.Word.$fBitsWord16_$cshift
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Int -> Word16 :: *)
                  ~R# (CUShort -> Int -> CUShort :: *)))
      (GHC.Word.$fBitsWord16_$crotate
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Int -> Word16 :: *)
                  ~R# (CUShort -> Int -> CUShort :: *)))
      (GHC.Word.$fBitsWord16_$cminBound
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 :: *) ~R# (CUShort :: *)))
      (GHC.Word.$fBitsWord16_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Int -> Word16 :: *) ~R# (Int -> CUShort :: *)))
      (GHC.Word.$fBitsWord16_$csetBit
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Int -> Word16 :: *)
                  ~R# (CUShort -> Int -> CUShort :: *)))
      (GHC.Word.$fBitsWord16_$cclearBit
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Int -> Word16 :: *)
                  ~R# (CUShort -> Int -> CUShort :: *)))
      (GHC.Word.$fBitsWord16_$ccomplementBit
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Int -> Word16 :: *)
                  ~R# (CUShort -> Int -> CUShort :: *)))
      (GHC.Word.$fBitsWord16_$ctestBit
       `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Int -> Bool>_R
               :: (Word16 -> Int -> Bool :: *) ~R# (CUShort -> Int -> Bool :: *)))
      (GHC.Word.$fBitsWord16_$cbitSizeMaybe
       `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Maybe Int>_R
               :: (Word16 -> Maybe Int :: *) ~R# (CUShort -> Maybe Int :: *)))
      (GHC.Word.$fBitsWord16_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Int>_R
               :: (Word16 -> Int :: *) ~R# (CUShort -> Int :: *)))
      (GHC.Word.$fBitsWord16_$cisSigned
       `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Bool>_R
               :: (Word16 -> Bool :: *) ~R# (CUShort -> Bool :: *)))
      (GHC.Word.$fBitsWord16_$cshiftL
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Int -> Word16 :: *)
                  ~R# (CUShort -> Int -> CUShort :: *)))
      (GHC.Word.$fBitsWord16_$cunsafeShiftL
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Int -> Word16 :: *)
                  ~R# (CUShort -> Int -> CUShort :: *)))
      (GHC.Word.$fBitsWord16_$cshiftR
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Int -> Word16 :: *)
                  ~R# (CUShort -> Int -> CUShort :: *)))
      (GHC.Word.$fBitsWord16_$cunsafeShiftR
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Int -> Word16 :: *)
                  ~R# (CUShort -> Int -> CUShort :: *)))
      (GHC.Word.$fBitsWord16_$crotateL
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Int -> Word16 :: *)
                  ~R# (CUShort -> Int -> CUShort :: *)))
      (GHC.Word.$fBitsWord16_$crotateR
       `cast` (Sym (Foreign.C.Types.N:CUShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUShort[0])
               :: (Word16 -> Int -> Word16 :: *)
                  ~R# (CUShort -> Int -> CUShort :: *)))
      (GHC.Word.$fBitsWord16_$cpopCount
       `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Int>_R
               :: (Word16 -> Int :: *) ~R# (CUShort -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.C.Types.$fFiniteBitsCUShort [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits CUShort
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: CUShort
                              Foreign.C.Types.$fBitsCUShort
                              GHC.Word.$fBitsWord16_$cfiniteBitSize
                              `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Int>_R
                                      :: (Word16 -> Int :: *) ~R# (CUShort -> Int :: *))
                              GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros
                              `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Int>_R
                                      :: (Word16 -> Int :: *) ~R# (CUShort -> Int :: *))
                              GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros
                              `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Int>_R
                                      :: (Word16 -> Int :: *) ~R# (CUShort -> Int :: *))]
Foreign.C.Types.$fFiniteBitsCUShort
  = Data.Bits.C:FiniteBits
      @ CUShort
      Foreign.C.Types.$fBitsCUShort
      (GHC.Word.$fBitsWord16_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Int>_R
               :: (Word16 -> Int :: *) ~R# (CUShort -> Int :: *)))
      (GHC.Word.$fFiniteBitsWord16_$ccountLeadingZeros
       `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Int>_R
               :: (Word16 -> Int :: *) ~R# (CUShort -> Int :: *)))
      (GHC.Word.$fFiniteBitsWord16_$ccountTrailingZeros
       `cast` (Sym (Foreign.C.Types.N:CUShort[0]) ->_R <Int>_R
               :: (Word16 -> Int :: *) ~R# (CUShort -> Int :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CShort
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CShort
                       GHC.Int.$fShowInt16_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CShort[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Int16 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CShort -> [Char] -> [Char] :: *))
                       GHC.Int.$fShowInt16_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <[Char]>_R
                               :: (Int16 -> [Char] :: *) ~R# (CShort -> [Char] :: *))
                       GHC.Int.$fShowInt16_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CShort[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Int16] -> [Char] -> [Char] :: *)
                                  ~R# ([CShort] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCShort
  = GHC.Show.C:Show
      @ CShort
      (GHC.Int.$fShowInt16_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Int16 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CShort -> [Char] -> [Char] :: *)))
      (GHC.Int.$fShowInt16_$cshow
       `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <[Char]>_R
               :: (Int16 -> [Char] :: *) ~R# (CShort -> [Char] :: *)))
      (GHC.Int.$fShowInt16_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CShort[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Int16] -> [Char] -> [Char] :: *)
                  ~R# ([CShort] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CShort
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CShort
                       GHC.Int.$fReadInt16_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CShort[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Int16, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CShort, [Char])] :: *))
                       GHC.Int.$fReadInt16_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CShort[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Int16], [Char])] :: *)
                                  ~R# ([Char] -> [([CShort], [Char])] :: *))
                       GHC.Int.$fReadInt3
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Int16>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     (Foreign.C.Types.N:CShort[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Int16 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CShort :: *))
                       GHC.Int.$fReadInt1
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Int16]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       ([Foreign.C.Types.N:CShort[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Int16] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CShort] :: *))]
Foreign.C.Types.$fReadCShort
  = GHC.Read.C:Read
      @ CShort
      (GHC.Int.$fReadInt16_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CShort[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Int16, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CShort, [Char])] :: *)))
      (GHC.Int.$fReadInt16_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CShort[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Int16], [Char])] :: *)
                  ~R# ([Char] -> [([CShort], [Char])] :: *)))
      (GHC.Int.$fReadInt3
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Int16>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                     (Foreign.C.Types.N:CShort[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Int16 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CShort :: *)))
      (GHC.Int.$fReadInt1
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Int16]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       ([Foreign.C.Types.N:CShort[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Int16] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CShort] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.C.Types.$fBoundedCShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded CShort
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: CShort
                          GHC.Int.$fBoundedInt16_$cminBound
                          `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                  :: (Int16 :: *) ~R# (CShort :: *))
                          GHC.Int.$fBoundedInt16_$cmaxBound
                          `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                  :: (Int16 :: *) ~R# (CShort :: *))]
Foreign.C.Types.$fBoundedCShort
  = GHC.Enum.C:Bounded
      @ CShort
      (GHC.Int.$fBoundedInt16_$cminBound
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 :: *) ~R# (CShort :: *)))
      (GHC.Int.$fBoundedInt16_$cmaxBound
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 :: *) ~R# (CShort :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CShort
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CShort
                                   Foreign.Storable.$fStorableInt16_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Int>_R
                                           :: (Int16 -> Int :: *) ~R# (CShort -> Int :: *))
                                   Foreign.Storable.$fStorableInt16_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Int>_R
                                           :: (Int16 -> Int :: *) ~R# (CShort -> Int :: *))
                                   GHC.Storable.readInt16OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int16, CShort))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CShort[0]))
                                           :: (GHC.Ptr.Ptr Int16
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int16 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CShort -> Int -> IO CShort :: *))
                                   GHC.Storable.writeInt16OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int16, CShort))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CShort[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int16
                                               -> Int
                                               -> Int16
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CShort
                                                   -> Int -> CShort -> IO () :: *))
                                   Foreign.Storable.$fStorableInt9
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CShort[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int16 #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> IO CShort :: *))
                                   Foreign.Storable.$fStorableInt7
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CShort[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Int16
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CShort -> IO () :: *))
                                   Foreign.Storable.$fStorableInt6
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int16, CShort))_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CShort[0]))
                                           :: (GHC.Ptr.Ptr Int16
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int16 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CShort -> IO CShort :: *))
                                   Foreign.Storable.$fStorableInt5
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int16, CShort))_R
                                           ->_R Sym (Foreign.C.Types.N:CShort[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int16
                                               -> Int16
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CShort -> CShort -> IO () :: *))]
Foreign.C.Types.$fStorableCShort
  = Foreign.Storable.C:Storable
      @ CShort
      (Foreign.Storable.$fStorableInt16_$calignment
       `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Int>_R
               :: (Int16 -> Int :: *) ~R# (CShort -> Int :: *)))
      (Foreign.Storable.$fStorableInt16_$calignment
       `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Int>_R
               :: (Int16 -> Int :: *) ~R# (CShort -> Int :: *)))
      (GHC.Storable.readInt16OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int16, CShort))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CShort[0]))
               :: (GHC.Ptr.Ptr Int16
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int16 #) :: *)
                  ~R# (GHC.Ptr.Ptr CShort -> Int -> IO CShort :: *)))
      (GHC.Storable.writeInt16OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int16, CShort))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int16
                   -> Int
                   -> Int16
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CShort -> Int -> CShort -> IO () :: *)))
      (Foreign.Storable.$fStorableInt9
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CShort[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int16 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CShort :: *)))
      (Foreign.Storable.$fStorableInt7
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Int16
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CShort -> IO () :: *)))
      (Foreign.Storable.$fStorableInt6
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int16, CShort))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CShort[0]))
               :: (GHC.Ptr.Ptr Int16
                   -> State# RealWorld -> (# State# RealWorld, Int16 #) :: *)
                  ~R# (GHC.Ptr.Ptr CShort -> IO CShort :: *)))
      (Foreign.Storable.$fStorableInt5
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Int16, CShort))_R
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int16
                   -> Int16 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CShort -> CShort -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CShort
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CShort
                       GHC.Int.$fEnumInt16_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CShort[0])
                               ->_R Sym (Foreign.C.Types.N:CShort[0])
                               :: (Int16 -> Int16 :: *) ~R# (CShort -> CShort :: *))
                       GHC.Int.$fEnumInt16_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CShort[0])
                               ->_R Sym (Foreign.C.Types.N:CShort[0])
                               :: (Int16 -> Int16 :: *) ~R# (CShort -> CShort :: *))
                       GHC.Int.$fEnumInt16_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CShort[0])
                               :: (Int -> Int16 :: *) ~R# (Int -> CShort :: *))
                       GHC.Int.$fEnumInt16_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Int>_R
                               :: (Int16 -> Int :: *) ~R# (CShort -> Int :: *))
                       GHC.Int.$fEnumInt16_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CShort[0])
                               ->_R ([Sym (Foreign.C.Types.N:CShort[0])])_R
                               :: (Int16 -> [Int16] :: *) ~R# (CShort -> [CShort] :: *))
                       GHC.Int.$fEnumInt16_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CShort[0])
                               ->_R Sym (Foreign.C.Types.N:CShort[0])
                               ->_R ([Sym (Foreign.C.Types.N:CShort[0])])_R
                               :: (Int16 -> Int16 -> [Int16] :: *)
                                  ~R# (CShort -> CShort -> [CShort] :: *))
                       GHC.Int.$fEnumInt16_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CShort[0])
                               ->_R Sym (Foreign.C.Types.N:CShort[0])
                               ->_R ([Sym (Foreign.C.Types.N:CShort[0])])_R
                               :: (Int16 -> Int16 -> [Int16] :: *)
                                  ~R# (CShort -> CShort -> [CShort] :: *))
                       GHC.Int.$fEnumInt16_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CShort[0])
                               ->_R Sym (Foreign.C.Types.N:CShort[0])
                               ->_R Sym (Foreign.C.Types.N:CShort[0])
                               ->_R ([Sym (Foreign.C.Types.N:CShort[0])])_R
                               :: (Int16 -> Int16 -> Int16 -> [Int16] :: *)
                                  ~R# (CShort -> CShort -> CShort -> [CShort] :: *))]
Foreign.C.Types.$fEnumCShort
  = GHC.Enum.C:Enum
      @ CShort
      (GHC.Int.$fEnumInt16_$csucc
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int16 :: *) ~R# (CShort -> CShort :: *)))
      (GHC.Int.$fEnumInt16_$cpred
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int16 :: *) ~R# (CShort -> CShort :: *)))
      (GHC.Int.$fEnumInt16_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int -> Int16 :: *) ~R# (Int -> CShort :: *)))
      (GHC.Int.$fEnumInt16_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Int>_R
               :: (Int16 -> Int :: *) ~R# (CShort -> Int :: *)))
      (GHC.Int.$fEnumInt16_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R ([Sym (Foreign.C.Types.N:CShort[0])])_R
               :: (Int16 -> [Int16] :: *) ~R# (CShort -> [CShort] :: *)))
      (GHC.Int.$fEnumInt16_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R ([Sym (Foreign.C.Types.N:CShort[0])])_R
               :: (Int16 -> Int16 -> [Int16] :: *)
                  ~R# (CShort -> CShort -> [CShort] :: *)))
      (GHC.Int.$fEnumInt16_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R ([Sym (Foreign.C.Types.N:CShort[0])])_R
               :: (Int16 -> Int16 -> [Int16] :: *)
                  ~R# (CShort -> CShort -> [CShort] :: *)))
      (GHC.Int.$fEnumInt16_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R ([Sym (Foreign.C.Types.N:CShort[0])])_R
               :: (Int16 -> Int16 -> Int16 -> [Int16] :: *)
                  ~R# (CShort -> CShort -> CShort -> [CShort] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CShort
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CShort
                     GHC.Int.$fNumInt16_$c+
                     `cast` (Sym (Foreign.C.Types.N:CShort[0])
                             ->_R Sym (Foreign.C.Types.N:CShort[0])
                             ->_R Sym (Foreign.C.Types.N:CShort[0])
                             :: (Int16 -> Int16 -> Int16 :: *)
                                ~R# (CShort -> CShort -> CShort :: *))
                     GHC.Int.$fNumInt16_$c-
                     `cast` (Sym (Foreign.C.Types.N:CShort[0])
                             ->_R Sym (Foreign.C.Types.N:CShort[0])
                             ->_R Sym (Foreign.C.Types.N:CShort[0])
                             :: (Int16 -> Int16 -> Int16 :: *)
                                ~R# (CShort -> CShort -> CShort :: *))
                     GHC.Int.$fNumInt16_$c*
                     `cast` (Sym (Foreign.C.Types.N:CShort[0])
                             ->_R Sym (Foreign.C.Types.N:CShort[0])
                             ->_R Sym (Foreign.C.Types.N:CShort[0])
                             :: (Int16 -> Int16 -> Int16 :: *)
                                ~R# (CShort -> CShort -> CShort :: *))
                     GHC.Int.$fNumInt16_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CShort[0])
                             ->_R Sym (Foreign.C.Types.N:CShort[0])
                             :: (Int16 -> Int16 :: *) ~R# (CShort -> CShort :: *))
                     GHC.Int.$fNumInt16_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CShort[0])
                             ->_R Sym (Foreign.C.Types.N:CShort[0])
                             :: (Int16 -> Int16 :: *) ~R# (CShort -> CShort :: *))
                     GHC.Int.$fNumInt16_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CShort[0])
                             ->_R Sym (Foreign.C.Types.N:CShort[0])
                             :: (Int16 -> Int16 :: *) ~R# (CShort -> CShort :: *))
                     GHC.Int.$fNumInt16_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CShort[0])
                             :: (Integer -> Int16 :: *) ~R# (Integer -> CShort :: *))]
Foreign.C.Types.$fNumCShort
  = GHC.Num.C:Num
      @ CShort
      (GHC.Int.$fNumInt16_$c+
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int16 -> Int16 :: *)
                  ~R# (CShort -> CShort -> CShort :: *)))
      (GHC.Int.$fNumInt16_$c-
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int16 -> Int16 :: *)
                  ~R# (CShort -> CShort -> CShort :: *)))
      (GHC.Int.$fNumInt16_$c*
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int16 -> Int16 :: *)
                  ~R# (CShort -> CShort -> CShort :: *)))
      (GHC.Int.$fNumInt16_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int16 :: *) ~R# (CShort -> CShort :: *)))
      (GHC.Int.$fNumInt16_$cabs
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int16 :: *) ~R# (CShort -> CShort :: *)))
      (GHC.Int.$fNumInt16_$csignum
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int16 :: *) ~R# (CShort -> CShort :: *)))
      (GHC.Int.$fNumInt16_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Integer -> Int16 :: *) ~R# (Integer -> CShort :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CShort
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CShort
                        GHC.Int.eqInt16
                        `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                ->_R Sym (Foreign.C.Types.N:CShort[0])
                                ->_R <Bool>_R
                                :: (Int16 -> Int16 -> Bool :: *)
                                   ~R# (CShort -> CShort -> Bool :: *))
                        GHC.Int.neInt16
                        `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                ->_R Sym (Foreign.C.Types.N:CShort[0])
                                ->_R <Bool>_R
                                :: (Int16 -> Int16 -> Bool :: *)
                                   ~R# (CShort -> CShort -> Bool :: *))]
Foreign.C.Types.$fEqCShort
  = GHC.Classes.C:Eq
      @ CShort
      (GHC.Int.eqInt16
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R <Bool>_R
               :: (Int16 -> Int16 -> Bool :: *)
                  ~R# (CShort -> CShort -> Bool :: *)))
      (GHC.Int.neInt16
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R <Bool>_R
               :: (Int16 -> Int16 -> Bool :: *)
                  ~R# (CShort -> CShort -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CShort
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CShort
                         Foreign.C.Types.$fEqCShort
                         GHC.Int.$fOrdInt16_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                 ->_R Sym (Foreign.C.Types.N:CShort[0])
                                 ->_R <Ordering>_R
                                 :: (Int16 -> Int16 -> Ordering :: *)
                                    ~R# (CShort -> CShort -> Ordering :: *))
                         GHC.Int.ltInt16
                         `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                 ->_R Sym (Foreign.C.Types.N:CShort[0])
                                 ->_R <Bool>_R
                                 :: (Int16 -> Int16 -> Bool :: *)
                                    ~R# (CShort -> CShort -> Bool :: *))
                         GHC.Int.leInt16
                         `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                 ->_R Sym (Foreign.C.Types.N:CShort[0])
                                 ->_R <Bool>_R
                                 :: (Int16 -> Int16 -> Bool :: *)
                                    ~R# (CShort -> CShort -> Bool :: *))
                         GHC.Int.gtInt16
                         `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                 ->_R Sym (Foreign.C.Types.N:CShort[0])
                                 ->_R <Bool>_R
                                 :: (Int16 -> Int16 -> Bool :: *)
                                    ~R# (CShort -> CShort -> Bool :: *))
                         GHC.Int.geInt16
                         `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                 ->_R Sym (Foreign.C.Types.N:CShort[0])
                                 ->_R <Bool>_R
                                 :: (Int16 -> Int16 -> Bool :: *)
                                    ~R# (CShort -> CShort -> Bool :: *))
                         GHC.Int.$fOrdInt16_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                 ->_R Sym (Foreign.C.Types.N:CShort[0])
                                 ->_R Sym (Foreign.C.Types.N:CShort[0])
                                 :: (Int16 -> Int16 -> Int16 :: *)
                                    ~R# (CShort -> CShort -> CShort :: *))
                         GHC.Int.$fOrdInt16_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                 ->_R Sym (Foreign.C.Types.N:CShort[0])
                                 ->_R Sym (Foreign.C.Types.N:CShort[0])
                                 :: (Int16 -> Int16 -> Int16 :: *)
                                    ~R# (CShort -> CShort -> CShort :: *))]
Foreign.C.Types.$fOrdCShort
  = GHC.Classes.C:Ord
      @ CShort
      Foreign.C.Types.$fEqCShort
      (GHC.Int.$fOrdInt16_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R <Ordering>_R
               :: (Int16 -> Int16 -> Ordering :: *)
                  ~R# (CShort -> CShort -> Ordering :: *)))
      (GHC.Int.ltInt16
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R <Bool>_R
               :: (Int16 -> Int16 -> Bool :: *)
                  ~R# (CShort -> CShort -> Bool :: *)))
      (GHC.Int.leInt16
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R <Bool>_R
               :: (Int16 -> Int16 -> Bool :: *)
                  ~R# (CShort -> CShort -> Bool :: *)))
      (GHC.Int.gtInt16
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R <Bool>_R
               :: (Int16 -> Int16 -> Bool :: *)
                  ~R# (CShort -> CShort -> Bool :: *)))
      (GHC.Int.geInt16
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R <Bool>_R
               :: (Int16 -> Int16 -> Bool :: *)
                  ~R# (CShort -> CShort -> Bool :: *)))
      (GHC.Int.$fOrdInt16_$cmax
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int16 -> Int16 :: *)
                  ~R# (CShort -> CShort -> CShort :: *)))
      (GHC.Int.$fOrdInt16_$cmin
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int16 -> Int16 :: *)
                  ~R# (CShort -> CShort -> CShort :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CShort
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CShort
                       Foreign.C.Types.$fNumCShort
                       Foreign.C.Types.$fOrdCShort
                       GHC.Int.$fRealInt16_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Ratio Integer>_R
                               :: (Int16 -> Ratio Integer :: *)
                                  ~R# (CShort -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCShort
  = GHC.Real.C:Real
      @ CShort
      Foreign.C.Types.$fNumCShort
      Foreign.C.Types.$fOrdCShort
      (GHC.Int.$fRealInt16_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Ratio Integer>_R
               :: (Int16 -> Ratio Integer :: *)
                  ~R# (CShort -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.C.Types.$fIntegralCShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral CShort
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: CShort
                           Foreign.C.Types.$fRealCShort
                           Foreign.C.Types.$fEnumCShort
                           GHC.Int.$fIntegralInt16_$cquot
                           `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                   ->_R Sym (Foreign.C.Types.N:CShort[0])
                                   ->_R Sym (Foreign.C.Types.N:CShort[0])
                                   :: (Int16 -> Int16 -> Int16 :: *)
                                      ~R# (CShort -> CShort -> CShort :: *))
                           GHC.Int.$fIntegralInt16_$crem
                           `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                   ->_R Sym (Foreign.C.Types.N:CShort[0])
                                   ->_R Sym (Foreign.C.Types.N:CShort[0])
                                   :: (Int16 -> Int16 -> Int16 :: *)
                                      ~R# (CShort -> CShort -> CShort :: *))
                           GHC.Int.$fIntegralInt16_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                   ->_R Sym (Foreign.C.Types.N:CShort[0])
                                   ->_R Sym (Foreign.C.Types.N:CShort[0])
                                   :: (Int16 -> Int16 -> Int16 :: *)
                                      ~R# (CShort -> CShort -> CShort :: *))
                           GHC.Int.$fIntegralInt16_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                   ->_R Sym (Foreign.C.Types.N:CShort[0])
                                   ->_R Sym (Foreign.C.Types.N:CShort[0])
                                   :: (Int16 -> Int16 -> Int16 :: *)
                                      ~R# (CShort -> CShort -> CShort :: *))
                           GHC.Int.$fIntegralInt16_$cquotRem
                           `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                   ->_R Sym (Foreign.C.Types.N:CShort[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CShort[0]))
                                           (Sym (Foreign.C.Types.N:CShort[0])))_R
                                   :: (Int16 -> Int16 -> (Int16, Int16) :: *)
                                      ~R# (CShort -> CShort -> (CShort, CShort) :: *))
                           GHC.Int.$fIntegralInt16_$cdivMod
                           `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                   ->_R Sym (Foreign.C.Types.N:CShort[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CShort[0]))
                                           (Sym (Foreign.C.Types.N:CShort[0])))_R
                                   :: (Int16 -> Int16 -> (Int16, Int16) :: *)
                                      ~R# (CShort -> CShort -> (CShort, CShort) :: *))
                           GHC.Int.$fIntegralInt16_$ctoInteger
                           `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Integer>_R
                                   :: (Int16 -> Integer :: *) ~R# (CShort -> Integer :: *))]
Foreign.C.Types.$fIntegralCShort
  = GHC.Real.C:Integral
      @ CShort
      Foreign.C.Types.$fRealCShort
      Foreign.C.Types.$fEnumCShort
      (GHC.Int.$fIntegralInt16_$cquot
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int16 -> Int16 :: *)
                  ~R# (CShort -> CShort -> CShort :: *)))
      (GHC.Int.$fIntegralInt16_$crem
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int16 -> Int16 :: *)
                  ~R# (CShort -> CShort -> CShort :: *)))
      (GHC.Int.$fIntegralInt16_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int16 -> Int16 :: *)
                  ~R# (CShort -> CShort -> CShort :: *)))
      (GHC.Int.$fIntegralInt16_$cmod
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int16 -> Int16 :: *)
                  ~R# (CShort -> CShort -> CShort :: *)))
      (GHC.Int.$fIntegralInt16_$cquotRem
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CShort[0]))
                       (Sym (Foreign.C.Types.N:CShort[0])))_R
               :: (Int16 -> Int16 -> (Int16, Int16) :: *)
                  ~R# (CShort -> CShort -> (CShort, CShort) :: *)))
      (GHC.Int.$fIntegralInt16_$cdivMod
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CShort[0]))
                       (Sym (Foreign.C.Types.N:CShort[0])))_R
               :: (Int16 -> Int16 -> (Int16, Int16) :: *)
                  ~R# (CShort -> CShort -> (CShort, CShort) :: *)))
      (GHC.Int.$fIntegralInt16_$ctoInteger
       `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Integer>_R
               :: (Int16 -> Integer :: *) ~R# (CShort -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.C.Types.$fBitsCShort [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits CShort
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: CShort
                        Foreign.C.Types.$fEqCShort
                        GHC.Int.$fBitsInt16_$c.&.
                        `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                ->_R Sym (Foreign.C.Types.N:CShort[0])
                                ->_R Sym (Foreign.C.Types.N:CShort[0])
                                :: (Int16 -> Int16 -> Int16 :: *)
                                   ~R# (CShort -> CShort -> CShort :: *))
                        GHC.Int.$fBitsInt16_$c.|.
                        `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                ->_R Sym (Foreign.C.Types.N:CShort[0])
                                ->_R Sym (Foreign.C.Types.N:CShort[0])
                                :: (Int16 -> Int16 -> Int16 :: *)
                                   ~R# (CShort -> CShort -> CShort :: *))
                        GHC.Int.$fBitsInt16_$cxor
                        `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                ->_R Sym (Foreign.C.Types.N:CShort[0])
                                ->_R Sym (Foreign.C.Types.N:CShort[0])
                                :: (Int16 -> Int16 -> Int16 :: *)
                                   ~R# (CShort -> CShort -> CShort :: *))
                        GHC.Int.$fBitsInt16_$ccomplement
                        `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                ->_R Sym (Foreign.C.Types.N:CShort[0])
                                :: (Int16 -> Int16 :: *) ~R# (CShort -> CShort :: *))
                        GHC.Int.$fBitsInt16_$cshift
                        `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CShort[0])
                                :: (Int16 -> Int -> Int16 :: *) ~R# (CShort -> Int -> CShort :: *))
                        GHC.Int.$fBitsInt16_$crotate
                        `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CShort[0])
                                :: (Int16 -> Int -> Int16 :: *) ~R# (CShort -> Int -> CShort :: *))
                        GHC.Int.$fBitsInt3
                        `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                :: (Int16 :: *) ~R# (CShort :: *))
                        GHC.Int.$fBitsInt16_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CShort[0])
                                :: (Int -> Int16 :: *) ~R# (Int -> CShort :: *))
                        GHC.Int.$fBitsInt16_$csetBit
                        `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CShort[0])
                                :: (Int16 -> Int -> Int16 :: *) ~R# (CShort -> Int -> CShort :: *))
                        GHC.Int.$fBitsInt16_$cclearBit
                        `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CShort[0])
                                :: (Int16 -> Int -> Int16 :: *) ~R# (CShort -> Int -> CShort :: *))
                        GHC.Int.$fBitsInt16_$ccomplementBit
                        `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CShort[0])
                                :: (Int16 -> Int -> Int16 :: *) ~R# (CShort -> Int -> CShort :: *))
                        GHC.Int.$fBitsInt16_$ctestBit
                        `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Int -> Bool>_R
                                :: (Int16 -> Int -> Bool :: *) ~R# (CShort -> Int -> Bool :: *))
                        GHC.Int.$fBitsInt16_$cbitSizeMaybe
                        `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Maybe Int>_R
                                :: (Int16 -> Maybe Int :: *) ~R# (CShort -> Maybe Int :: *))
                        GHC.Int.$fBitsInt16_$cfiniteBitSize
                        `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Int>_R
                                :: (Int16 -> Int :: *) ~R# (CShort -> Int :: *))
                        GHC.Int.$fBitsInt16_$cisSigned
                        `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Bool>_R
                                :: (Int16 -> Bool :: *) ~R# (CShort -> Bool :: *))
                        GHC.Int.$fBitsInt16_$cshiftL
                        `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CShort[0])
                                :: (Int16 -> Int -> Int16 :: *) ~R# (CShort -> Int -> CShort :: *))
                        GHC.Int.$fBitsInt16_$cunsafeShiftL
                        `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CShort[0])
                                :: (Int16 -> Int -> Int16 :: *) ~R# (CShort -> Int -> CShort :: *))
                        GHC.Int.$fBitsInt16_$cshiftR
                        `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CShort[0])
                                :: (Int16 -> Int -> Int16 :: *) ~R# (CShort -> Int -> CShort :: *))
                        GHC.Int.$fBitsInt16_$cunsafeShiftR
                        `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CShort[0])
                                :: (Int16 -> Int -> Int16 :: *) ~R# (CShort -> Int -> CShort :: *))
                        GHC.Int.$fBitsInt16_$crotateL
                        `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CShort[0])
                                :: (Int16 -> Int -> Int16 :: *) ~R# (CShort -> Int -> CShort :: *))
                        GHC.Int.$fBitsInt16_$crotateR
                        `cast` (Sym (Foreign.C.Types.N:CShort[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CShort[0])
                                :: (Int16 -> Int -> Int16 :: *) ~R# (CShort -> Int -> CShort :: *))
                        GHC.Int.$fBitsInt16_$cpopCount
                        `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Int>_R
                                :: (Int16 -> Int :: *) ~R# (CShort -> Int :: *))]
Foreign.C.Types.$fBitsCShort
  = Data.Bits.C:Bits
      @ CShort
      Foreign.C.Types.$fEqCShort
      (GHC.Int.$fBitsInt16_$c.&.
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int16 -> Int16 :: *)
                  ~R# (CShort -> CShort -> CShort :: *)))
      (GHC.Int.$fBitsInt16_$c.|.
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int16 -> Int16 :: *)
                  ~R# (CShort -> CShort -> CShort :: *)))
      (GHC.Int.$fBitsInt16_$cxor
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int16 -> Int16 :: *)
                  ~R# (CShort -> CShort -> CShort :: *)))
      (GHC.Int.$fBitsInt16_$ccomplement
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int16 :: *) ~R# (CShort -> CShort :: *)))
      (GHC.Int.$fBitsInt16_$cshift
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int -> Int16 :: *)
                  ~R# (CShort -> Int -> CShort :: *)))
      (GHC.Int.$fBitsInt16_$crotate
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int -> Int16 :: *)
                  ~R# (CShort -> Int -> CShort :: *)))
      (GHC.Int.$fBitsInt3
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 :: *) ~R# (CShort :: *)))
      (GHC.Int.$fBitsInt16_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int -> Int16 :: *) ~R# (Int -> CShort :: *)))
      (GHC.Int.$fBitsInt16_$csetBit
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int -> Int16 :: *)
                  ~R# (CShort -> Int -> CShort :: *)))
      (GHC.Int.$fBitsInt16_$cclearBit
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int -> Int16 :: *)
                  ~R# (CShort -> Int -> CShort :: *)))
      (GHC.Int.$fBitsInt16_$ccomplementBit
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int -> Int16 :: *)
                  ~R# (CShort -> Int -> CShort :: *)))
      (GHC.Int.$fBitsInt16_$ctestBit
       `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Int -> Bool>_R
               :: (Int16 -> Int -> Bool :: *) ~R# (CShort -> Int -> Bool :: *)))
      (GHC.Int.$fBitsInt16_$cbitSizeMaybe
       `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Maybe Int>_R
               :: (Int16 -> Maybe Int :: *) ~R# (CShort -> Maybe Int :: *)))
      (GHC.Int.$fBitsInt16_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Int>_R
               :: (Int16 -> Int :: *) ~R# (CShort -> Int :: *)))
      (GHC.Int.$fBitsInt16_$cisSigned
       `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Bool>_R
               :: (Int16 -> Bool :: *) ~R# (CShort -> Bool :: *)))
      (GHC.Int.$fBitsInt16_$cshiftL
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int -> Int16 :: *)
                  ~R# (CShort -> Int -> CShort :: *)))
      (GHC.Int.$fBitsInt16_$cunsafeShiftL
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int -> Int16 :: *)
                  ~R# (CShort -> Int -> CShort :: *)))
      (GHC.Int.$fBitsInt16_$cshiftR
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int -> Int16 :: *)
                  ~R# (CShort -> Int -> CShort :: *)))
      (GHC.Int.$fBitsInt16_$cunsafeShiftR
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int -> Int16 :: *)
                  ~R# (CShort -> Int -> CShort :: *)))
      (GHC.Int.$fBitsInt16_$crotateL
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int -> Int16 :: *)
                  ~R# (CShort -> Int -> CShort :: *)))
      (GHC.Int.$fBitsInt16_$crotateR
       `cast` (Sym (Foreign.C.Types.N:CShort[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CShort[0])
               :: (Int16 -> Int -> Int16 :: *)
                  ~R# (CShort -> Int -> CShort :: *)))
      (GHC.Int.$fBitsInt16_$cpopCount
       `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Int>_R
               :: (Int16 -> Int :: *) ~R# (CShort -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.C.Types.$fFiniteBitsCShort [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits CShort
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: CShort
                              Foreign.C.Types.$fBitsCShort
                              GHC.Int.$fBitsInt16_$cfiniteBitSize
                              `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Int>_R
                                      :: (Int16 -> Int :: *) ~R# (CShort -> Int :: *))
                              GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros
                              `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Int>_R
                                      :: (Int16 -> Int :: *) ~R# (CShort -> Int :: *))
                              GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros
                              `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Int>_R
                                      :: (Int16 -> Int :: *) ~R# (CShort -> Int :: *))]
Foreign.C.Types.$fFiniteBitsCShort
  = Data.Bits.C:FiniteBits
      @ CShort
      Foreign.C.Types.$fBitsCShort
      (GHC.Int.$fBitsInt16_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Int>_R
               :: (Int16 -> Int :: *) ~R# (CShort -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt16_$ccountLeadingZeros
       `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Int>_R
               :: (Int16 -> Int :: *) ~R# (CShort -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt16_$ccountTrailingZeros
       `cast` (Sym (Foreign.C.Types.N:CShort[0]) ->_R <Int>_R
               :: (Int16 -> Int :: *) ~R# (CShort -> Int :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCUChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CUChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CUChar
                       GHC.Word.$fShowWord8_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CUChar[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Word8 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CUChar -> [Char] -> [Char] :: *))
                       GHC.Word.$fShowWord8_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <[Char]>_R
                               :: (Word8 -> [Char] :: *) ~R# (CUChar -> [Char] :: *))
                       GHC.Word.$fShowWord8_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CUChar[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Word8] -> [Char] -> [Char] :: *)
                                  ~R# ([CUChar] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCUChar
  = GHC.Show.C:Show
      @ CUChar
      (GHC.Word.$fShowWord8_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Word8 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CUChar -> [Char] -> [Char] :: *)))
      (GHC.Word.$fShowWord8_$cshow
       `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <[Char]>_R
               :: (Word8 -> [Char] :: *) ~R# (CUChar -> [Char] :: *)))
      (GHC.Word.$fShowWord8_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CUChar[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Word8] -> [Char] -> [Char] :: *)
                  ~R# ([CUChar] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCUChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CUChar
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CUChar
                       GHC.Read.$fReadWord8_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CUChar[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Word8, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CUChar, [Char])] :: *))
                       GHC.Read.$fReadWord8_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CUChar[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Word8], [Char])] :: *)
                                  ~R# ([Char] -> [([CUChar], [Char])] :: *))
                       GHC.Read.$fReadWord17
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Word8>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                     (Foreign.C.Types.N:CUChar[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Word8 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CUChar :: *))
                       GHC.Read.$fReadWord14
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Word8]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                       ([Foreign.C.Types.N:CUChar[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Word8] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CUChar] :: *))]
Foreign.C.Types.$fReadCUChar
  = GHC.Read.C:Read
      @ CUChar
      (GHC.Read.$fReadWord8_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CUChar[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Word8, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CUChar, [Char])] :: *)))
      (GHC.Read.$fReadWord8_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CUChar[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Word8], [Char])] :: *)
                  ~R# ([Char] -> [([CUChar], [Char])] :: *)))
      (GHC.Read.$fReadWord17
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Word8>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                     (Foreign.C.Types.N:CUChar[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Word8 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CUChar :: *)))
      (GHC.Read.$fReadWord14
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Word8]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                       ([Foreign.C.Types.N:CUChar[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Word8] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CUChar] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.C.Types.$fBoundedCUChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded CUChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: CUChar
                          GHC.Word.$fBitsWord8_$cminBound
                          `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                  :: (Word8 :: *) ~R# (CUChar :: *))
                          GHC.Word.$fBoundedWord8_$cmaxBound
                          `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                  :: (Word8 :: *) ~R# (CUChar :: *))]
Foreign.C.Types.$fBoundedCUChar
  = GHC.Enum.C:Bounded
      @ CUChar
      (GHC.Word.$fBitsWord8_$cminBound
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 :: *) ~R# (CUChar :: *)))
      (GHC.Word.$fBoundedWord8_$cmaxBound
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 :: *) ~R# (CUChar :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCUChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CUChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CUChar
                                   Foreign.Storable.$fStorableWord8_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Int>_R
                                           :: (Word8 -> Int :: *) ~R# (CUChar -> Int :: *))
                                   Foreign.Storable.$fStorableWord8_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Int>_R
                                           :: (Word8 -> Int :: *) ~R# (CUChar -> Int :: *))
                                   GHC.Storable.readWord8OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word8, CUChar))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CUChar[0]))
                                           :: (GHC.Ptr.Ptr Word8
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word8 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUChar -> Int -> IO CUChar :: *))
                                   GHC.Storable.writeWord8OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word8, CUChar))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Word8
                                               -> Int
                                               -> Word8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUChar
                                                   -> Int -> CUChar -> IO () :: *))
                                   Foreign.Storable.$fStorableWord22
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CUChar[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word8 #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> IO CUChar :: *))
                                   Foreign.Storable.$fStorableWord21
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Word8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CUChar -> IO () :: *))
                                   Foreign.Storable.$fStorableWord20
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word8, CUChar))_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CUChar[0]))
                                           :: (GHC.Ptr.Ptr Word8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word8 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUChar -> IO CUChar :: *))
                                   Foreign.Storable.$fStorableWord19
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Word8, CUChar))_R
                                           ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Word8
                                               -> Word8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CUChar -> CUChar -> IO () :: *))]
Foreign.C.Types.$fStorableCUChar
  = Foreign.Storable.C:Storable
      @ CUChar
      (Foreign.Storable.$fStorableWord8_$calignment
       `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Int>_R
               :: (Word8 -> Int :: *) ~R# (CUChar -> Int :: *)))
      (Foreign.Storable.$fStorableWord8_$calignment
       `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Int>_R
               :: (Word8 -> Int :: *) ~R# (CUChar -> Int :: *)))
      (GHC.Storable.readWord8OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word8, CUChar))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUChar[0]))
               :: (GHC.Ptr.Ptr Word8
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word8 #) :: *)
                  ~R# (GHC.Ptr.Ptr CUChar -> Int -> IO CUChar :: *)))
      (GHC.Storable.writeWord8OffPtr1
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word8, CUChar))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Word8
                   -> Int
                   -> Word8
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CUChar -> Int -> CUChar -> IO () :: *)))
      (Foreign.Storable.$fStorableWord22
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUChar[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word8 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CUChar :: *)))
      (Foreign.Storable.$fStorableWord21
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Word8
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CUChar -> IO () :: *)))
      (Foreign.Storable.$fStorableWord20
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word8, CUChar))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CUChar[0]))
               :: (GHC.Ptr.Ptr Word8
                   -> State# RealWorld -> (# State# RealWorld, Word8 #) :: *)
                  ~R# (GHC.Ptr.Ptr CUChar -> IO CUChar :: *)))
      (Foreign.Storable.$fStorableWord19
       `cast` ((GHC.Ptr.Ptr
                  Univ(phantom phantom <*>_N :: Word8, CUChar))_R
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Word8
                   -> Word8 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CUChar -> CUChar -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCUChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CUChar
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CUChar
                       GHC.Word.$fEnumWord8_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                               ->_R Sym (Foreign.C.Types.N:CUChar[0])
                               :: (Word8 -> Word8 :: *) ~R# (CUChar -> CUChar :: *))
                       GHC.Word.$fEnumWord8_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                               ->_R Sym (Foreign.C.Types.N:CUChar[0])
                               :: (Word8 -> Word8 :: *) ~R# (CUChar -> CUChar :: *))
                       GHC.Word.$fEnumWord8_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUChar[0])
                               :: (Int -> Word8 :: *) ~R# (Int -> CUChar :: *))
                       GHC.Word.$fEnumWord8_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Int>_R
                               :: (Word8 -> Int :: *) ~R# (CUChar -> Int :: *))
                       GHC.Word.$fEnumWord8_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUChar[0])])_R
                               :: (Word8 -> [Word8] :: *) ~R# (CUChar -> [CUChar] :: *))
                       GHC.Word.$fEnumWord8_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                               ->_R Sym (Foreign.C.Types.N:CUChar[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUChar[0])])_R
                               :: (Word8 -> Word8 -> [Word8] :: *)
                                  ~R# (CUChar -> CUChar -> [CUChar] :: *))
                       GHC.Word.$fEnumWord8_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                               ->_R Sym (Foreign.C.Types.N:CUChar[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUChar[0])])_R
                               :: (Word8 -> Word8 -> [Word8] :: *)
                                  ~R# (CUChar -> CUChar -> [CUChar] :: *))
                       GHC.Word.$fEnumWord8_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                               ->_R Sym (Foreign.C.Types.N:CUChar[0])
                               ->_R Sym (Foreign.C.Types.N:CUChar[0])
                               ->_R ([Sym (Foreign.C.Types.N:CUChar[0])])_R
                               :: (Word8 -> Word8 -> Word8 -> [Word8] :: *)
                                  ~R# (CUChar -> CUChar -> CUChar -> [CUChar] :: *))]
Foreign.C.Types.$fEnumCUChar
  = GHC.Enum.C:Enum
      @ CUChar
      (GHC.Word.$fEnumWord8_$csucc
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Word8 :: *) ~R# (CUChar -> CUChar :: *)))
      (GHC.Word.$fEnumWord8_$cpred
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Word8 :: *) ~R# (CUChar -> CUChar :: *)))
      (GHC.Word.$fEnumWord8_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Int -> Word8 :: *) ~R# (Int -> CUChar :: *)))
      (GHC.Word.$fEnumWord8_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Int>_R
               :: (Word8 -> Int :: *) ~R# (CUChar -> Int :: *)))
      (GHC.Word.$fEnumWord8_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R ([Sym (Foreign.C.Types.N:CUChar[0])])_R
               :: (Word8 -> [Word8] :: *) ~R# (CUChar -> [CUChar] :: *)))
      (GHC.Word.$fEnumWord8_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R ([Sym (Foreign.C.Types.N:CUChar[0])])_R
               :: (Word8 -> Word8 -> [Word8] :: *)
                  ~R# (CUChar -> CUChar -> [CUChar] :: *)))
      (GHC.Word.$fEnumWord8_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R ([Sym (Foreign.C.Types.N:CUChar[0])])_R
               :: (Word8 -> Word8 -> [Word8] :: *)
                  ~R# (CUChar -> CUChar -> [CUChar] :: *)))
      (GHC.Word.$fEnumWord8_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R ([Sym (Foreign.C.Types.N:CUChar[0])])_R
               :: (Word8 -> Word8 -> Word8 -> [Word8] :: *)
                  ~R# (CUChar -> CUChar -> CUChar -> [CUChar] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCUChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CUChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CUChar
                     GHC.Word.$fNumWord8_$c+
                     `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                             ->_R Sym (Foreign.C.Types.N:CUChar[0])
                             ->_R Sym (Foreign.C.Types.N:CUChar[0])
                             :: (Word8 -> Word8 -> Word8 :: *)
                                ~R# (CUChar -> CUChar -> CUChar :: *))
                     GHC.Word.$fNumWord8_$c-
                     `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                             ->_R Sym (Foreign.C.Types.N:CUChar[0])
                             ->_R Sym (Foreign.C.Types.N:CUChar[0])
                             :: (Word8 -> Word8 -> Word8 :: *)
                                ~R# (CUChar -> CUChar -> CUChar :: *))
                     GHC.Word.$fNumWord8_$c*
                     `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                             ->_R Sym (Foreign.C.Types.N:CUChar[0])
                             ->_R Sym (Foreign.C.Types.N:CUChar[0])
                             :: (Word8 -> Word8 -> Word8 :: *)
                                ~R# (CUChar -> CUChar -> CUChar :: *))
                     GHC.Word.$fNumWord8_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                             ->_R Sym (Foreign.C.Types.N:CUChar[0])
                             :: (Word8 -> Word8 :: *) ~R# (CUChar -> CUChar :: *))
                     GHC.Word.$fNumWord8_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                             ->_R Sym (Foreign.C.Types.N:CUChar[0])
                             :: (Word8 -> Word8 :: *) ~R# (CUChar -> CUChar :: *))
                     GHC.Word.$fNumWord8_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                             ->_R Sym (Foreign.C.Types.N:CUChar[0])
                             :: (Word8 -> Word8 :: *) ~R# (CUChar -> CUChar :: *))
                     GHC.Word.$fNumWord8_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CUChar[0])
                             :: (Integer -> Word8 :: *) ~R# (Integer -> CUChar :: *))]
Foreign.C.Types.$fNumCUChar
  = GHC.Num.C:Num
      @ CUChar
      (GHC.Word.$fNumWord8_$c+
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CUChar -> CUChar -> CUChar :: *)))
      (GHC.Word.$fNumWord8_$c-
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CUChar -> CUChar -> CUChar :: *)))
      (GHC.Word.$fNumWord8_$c*
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CUChar -> CUChar -> CUChar :: *)))
      (GHC.Word.$fNumWord8_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Word8 :: *) ~R# (CUChar -> CUChar :: *)))
      (GHC.Word.$fNumWord8_$cabs
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Word8 :: *) ~R# (CUChar -> CUChar :: *)))
      (GHC.Word.$fNumWord8_$csignum
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Word8 :: *) ~R# (CUChar -> CUChar :: *)))
      (GHC.Word.$fNumWord8_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Integer -> Word8 :: *) ~R# (Integer -> CUChar :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCUChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CUChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CUChar
                        GHC.Word.eqWord8
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R <Bool>_R
                                :: (Word8 -> Word8 -> Bool :: *)
                                   ~R# (CUChar -> CUChar -> Bool :: *))
                        GHC.Word.neWord8
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R <Bool>_R
                                :: (Word8 -> Word8 -> Bool :: *)
                                   ~R# (CUChar -> CUChar -> Bool :: *))]
Foreign.C.Types.$fEqCUChar
  = GHC.Classes.C:Eq
      @ CUChar
      (GHC.Word.eqWord8
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R <Bool>_R
               :: (Word8 -> Word8 -> Bool :: *)
                  ~R# (CUChar -> CUChar -> Bool :: *)))
      (GHC.Word.neWord8
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R <Bool>_R
               :: (Word8 -> Word8 -> Bool :: *)
                  ~R# (CUChar -> CUChar -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCUChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CUChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CUChar
                         Foreign.C.Types.$fEqCUChar
                         GHC.Word.$fOrdWord8_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                 ->_R <Ordering>_R
                                 :: (Word8 -> Word8 -> Ordering :: *)
                                    ~R# (CUChar -> CUChar -> Ordering :: *))
                         GHC.Word.ltWord8
                         `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                 ->_R <Bool>_R
                                 :: (Word8 -> Word8 -> Bool :: *)
                                    ~R# (CUChar -> CUChar -> Bool :: *))
                         GHC.Word.leWord8
                         `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                 ->_R <Bool>_R
                                 :: (Word8 -> Word8 -> Bool :: *)
                                    ~R# (CUChar -> CUChar -> Bool :: *))
                         GHC.Word.gtWord8
                         `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                 ->_R <Bool>_R
                                 :: (Word8 -> Word8 -> Bool :: *)
                                    ~R# (CUChar -> CUChar -> Bool :: *))
                         GHC.Word.geWord8
                         `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                 ->_R <Bool>_R
                                 :: (Word8 -> Word8 -> Bool :: *)
                                    ~R# (CUChar -> CUChar -> Bool :: *))
                         GHC.Word.$fOrdWord8_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                 :: (Word8 -> Word8 -> Word8 :: *)
                                    ~R# (CUChar -> CUChar -> CUChar :: *))
                         GHC.Word.$fOrdWord8_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                 :: (Word8 -> Word8 -> Word8 :: *)
                                    ~R# (CUChar -> CUChar -> CUChar :: *))]
Foreign.C.Types.$fOrdCUChar
  = GHC.Classes.C:Ord
      @ CUChar
      Foreign.C.Types.$fEqCUChar
      (GHC.Word.$fOrdWord8_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R <Ordering>_R
               :: (Word8 -> Word8 -> Ordering :: *)
                  ~R# (CUChar -> CUChar -> Ordering :: *)))
      (GHC.Word.ltWord8
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R <Bool>_R
               :: (Word8 -> Word8 -> Bool :: *)
                  ~R# (CUChar -> CUChar -> Bool :: *)))
      (GHC.Word.leWord8
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R <Bool>_R
               :: (Word8 -> Word8 -> Bool :: *)
                  ~R# (CUChar -> CUChar -> Bool :: *)))
      (GHC.Word.gtWord8
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R <Bool>_R
               :: (Word8 -> Word8 -> Bool :: *)
                  ~R# (CUChar -> CUChar -> Bool :: *)))
      (GHC.Word.geWord8
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R <Bool>_R
               :: (Word8 -> Word8 -> Bool :: *)
                  ~R# (CUChar -> CUChar -> Bool :: *)))
      (GHC.Word.$fOrdWord8_$cmax
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CUChar -> CUChar -> CUChar :: *)))
      (GHC.Word.$fOrdWord8_$cmin
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CUChar -> CUChar -> CUChar :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCUChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CUChar
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CUChar
                       Foreign.C.Types.$fNumCUChar
                       Foreign.C.Types.$fOrdCUChar
                       GHC.Word.$fRealWord8_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Ratio Integer>_R
                               :: (Word8 -> Ratio Integer :: *)
                                  ~R# (CUChar -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCUChar
  = GHC.Real.C:Real
      @ CUChar
      Foreign.C.Types.$fNumCUChar
      Foreign.C.Types.$fOrdCUChar
      (GHC.Word.$fRealWord8_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Ratio Integer>_R
               :: (Word8 -> Ratio Integer :: *)
                  ~R# (CUChar -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.C.Types.$fIntegralCUChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral CUChar
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: CUChar
                           Foreign.C.Types.$fRealCUChar
                           Foreign.C.Types.$fEnumCUChar
                           GHC.Word.$fIntegralWord8_$cquot
                           `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                   :: (Word8 -> Word8 -> Word8 :: *)
                                      ~R# (CUChar -> CUChar -> CUChar :: *))
                           GHC.Word.$fIntegralWord8_$crem
                           `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                   :: (Word8 -> Word8 -> Word8 :: *)
                                      ~R# (CUChar -> CUChar -> CUChar :: *))
                           GHC.Word.$fIntegralWord8_$cquot
                           `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                   :: (Word8 -> Word8 -> Word8 :: *)
                                      ~R# (CUChar -> CUChar -> CUChar :: *))
                           GHC.Word.$fIntegralWord8_$crem
                           `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                   :: (Word8 -> Word8 -> Word8 :: *)
                                      ~R# (CUChar -> CUChar -> CUChar :: *))
                           GHC.Word.$fIntegralWord8_$cquotRem
                           `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CUChar[0]))
                                           (Sym (Foreign.C.Types.N:CUChar[0])))_R
                                   :: (Word8 -> Word8 -> (Word8, Word8) :: *)
                                      ~R# (CUChar -> CUChar -> (CUChar, CUChar) :: *))
                           GHC.Word.$fIntegralWord8_$cdivMod
                           `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CUChar[0]))
                                           (Sym (Foreign.C.Types.N:CUChar[0])))_R
                                   :: (Word8 -> Word8 -> (Word8, Word8) :: *)
                                      ~R# (CUChar -> CUChar -> (CUChar, CUChar) :: *))
                           GHC.Word.$ctoInteger
                           `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Integer>_R
                                   :: (Word8 -> Integer :: *) ~R# (CUChar -> Integer :: *))]
Foreign.C.Types.$fIntegralCUChar
  = GHC.Real.C:Integral
      @ CUChar
      Foreign.C.Types.$fRealCUChar
      Foreign.C.Types.$fEnumCUChar
      (GHC.Word.$fIntegralWord8_$cquot
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CUChar -> CUChar -> CUChar :: *)))
      (GHC.Word.$fIntegralWord8_$crem
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CUChar -> CUChar -> CUChar :: *)))
      (GHC.Word.$fIntegralWord8_$cquot
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CUChar -> CUChar -> CUChar :: *)))
      (GHC.Word.$fIntegralWord8_$crem
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CUChar -> CUChar -> CUChar :: *)))
      (GHC.Word.$fIntegralWord8_$cquotRem
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CUChar[0]))
                       (Sym (Foreign.C.Types.N:CUChar[0])))_R
               :: (Word8 -> Word8 -> (Word8, Word8) :: *)
                  ~R# (CUChar -> CUChar -> (CUChar, CUChar) :: *)))
      (GHC.Word.$fIntegralWord8_$cdivMod
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CUChar[0]))
                       (Sym (Foreign.C.Types.N:CUChar[0])))_R
               :: (Word8 -> Word8 -> (Word8, Word8) :: *)
                  ~R# (CUChar -> CUChar -> (CUChar, CUChar) :: *)))
      (GHC.Word.$ctoInteger
       `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Integer>_R
               :: (Word8 -> Integer :: *) ~R# (CUChar -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.C.Types.$fBitsCUChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits CUChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: CUChar
                        Foreign.C.Types.$fEqCUChar
                        GHC.Word.$fBitsWord8_$c.&.
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                :: (Word8 -> Word8 -> Word8 :: *)
                                   ~R# (CUChar -> CUChar -> CUChar :: *))
                        GHC.Word.$fBitsWord8_$c.|.
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                :: (Word8 -> Word8 -> Word8 :: *)
                                   ~R# (CUChar -> CUChar -> CUChar :: *))
                        GHC.Word.$fBitsWord8_$cxor
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                :: (Word8 -> Word8 -> Word8 :: *)
                                   ~R# (CUChar -> CUChar -> CUChar :: *))
                        GHC.Word.$fBitsWord8_$ccomplement
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                :: (Word8 -> Word8 :: *) ~R# (CUChar -> CUChar :: *))
                        GHC.Word.$fBitsWord8_$cshift
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CUChar -> Int -> CUChar :: *))
                        GHC.Word.$fBitsWord8_$crotate
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CUChar -> Int -> CUChar :: *))
                        GHC.Word.$fBitsWord8_$cminBound
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                :: (Word8 :: *) ~R# (CUChar :: *))
                        GHC.Word.$fBitsWord8_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                :: (Int -> Word8 :: *) ~R# (Int -> CUChar :: *))
                        GHC.Word.$fBitsWord8_$csetBit
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CUChar -> Int -> CUChar :: *))
                        GHC.Word.$fBitsWord8_$cclearBit
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CUChar -> Int -> CUChar :: *))
                        GHC.Word.$fBitsWord8_$ccomplementBit
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CUChar -> Int -> CUChar :: *))
                        GHC.Word.$fBitsWord8_$ctestBit
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Int -> Bool>_R
                                :: (Word8 -> Int -> Bool :: *) ~R# (CUChar -> Int -> Bool :: *))
                        GHC.Word.$fBitsWord8_$cbitSizeMaybe
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Maybe Int>_R
                                :: (Word8 -> Maybe Int :: *) ~R# (CUChar -> Maybe Int :: *))
                        GHC.Word.$fBitsWord8_$cfiniteBitSize
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Int>_R
                                :: (Word8 -> Int :: *) ~R# (CUChar -> Int :: *))
                        GHC.Word.$fBitsWord8_$cisSigned
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Bool>_R
                                :: (Word8 -> Bool :: *) ~R# (CUChar -> Bool :: *))
                        GHC.Word.$fBitsWord8_$cshiftL
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CUChar -> Int -> CUChar :: *))
                        GHC.Word.$fBitsWord8_$cunsafeShiftL
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CUChar -> Int -> CUChar :: *))
                        GHC.Word.$fBitsWord8_$cshiftR
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CUChar -> Int -> CUChar :: *))
                        GHC.Word.$fBitsWord8_$cunsafeShiftR
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CUChar -> Int -> CUChar :: *))
                        GHC.Word.$fBitsWord8_$crotateL
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CUChar -> Int -> CUChar :: *))
                        GHC.Word.$fBitsWord8_$crotateR
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CUChar[0])
                                :: (Word8 -> Int -> Word8 :: *) ~R# (CUChar -> Int -> CUChar :: *))
                        GHC.Word.$fBitsWord8_$cpopCount
                        `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Int>_R
                                :: (Word8 -> Int :: *) ~R# (CUChar -> Int :: *))]
Foreign.C.Types.$fBitsCUChar
  = Data.Bits.C:Bits
      @ CUChar
      Foreign.C.Types.$fEqCUChar
      (GHC.Word.$fBitsWord8_$c.&.
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CUChar -> CUChar -> CUChar :: *)))
      (GHC.Word.$fBitsWord8_$c.|.
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CUChar -> CUChar -> CUChar :: *)))
      (GHC.Word.$fBitsWord8_$cxor
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Word8 -> Word8 :: *)
                  ~R# (CUChar -> CUChar -> CUChar :: *)))
      (GHC.Word.$fBitsWord8_$ccomplement
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Word8 :: *) ~R# (CUChar -> CUChar :: *)))
      (GHC.Word.$fBitsWord8_$cshift
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Int -> Word8 :: *)
                  ~R# (CUChar -> Int -> CUChar :: *)))
      (GHC.Word.$fBitsWord8_$crotate
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Int -> Word8 :: *)
                  ~R# (CUChar -> Int -> CUChar :: *)))
      (GHC.Word.$fBitsWord8_$cminBound
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 :: *) ~R# (CUChar :: *)))
      (GHC.Word.$fBitsWord8_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Int -> Word8 :: *) ~R# (Int -> CUChar :: *)))
      (GHC.Word.$fBitsWord8_$csetBit
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Int -> Word8 :: *)
                  ~R# (CUChar -> Int -> CUChar :: *)))
      (GHC.Word.$fBitsWord8_$cclearBit
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Int -> Word8 :: *)
                  ~R# (CUChar -> Int -> CUChar :: *)))
      (GHC.Word.$fBitsWord8_$ccomplementBit
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Int -> Word8 :: *)
                  ~R# (CUChar -> Int -> CUChar :: *)))
      (GHC.Word.$fBitsWord8_$ctestBit
       `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Int -> Bool>_R
               :: (Word8 -> Int -> Bool :: *) ~R# (CUChar -> Int -> Bool :: *)))
      (GHC.Word.$fBitsWord8_$cbitSizeMaybe
       `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Maybe Int>_R
               :: (Word8 -> Maybe Int :: *) ~R# (CUChar -> Maybe Int :: *)))
      (GHC.Word.$fBitsWord8_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Int>_R
               :: (Word8 -> Int :: *) ~R# (CUChar -> Int :: *)))
      (GHC.Word.$fBitsWord8_$cisSigned
       `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Bool>_R
               :: (Word8 -> Bool :: *) ~R# (CUChar -> Bool :: *)))
      (GHC.Word.$fBitsWord8_$cshiftL
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Int -> Word8 :: *)
                  ~R# (CUChar -> Int -> CUChar :: *)))
      (GHC.Word.$fBitsWord8_$cunsafeShiftL
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Int -> Word8 :: *)
                  ~R# (CUChar -> Int -> CUChar :: *)))
      (GHC.Word.$fBitsWord8_$cshiftR
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Int -> Word8 :: *)
                  ~R# (CUChar -> Int -> CUChar :: *)))
      (GHC.Word.$fBitsWord8_$cunsafeShiftR
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Int -> Word8 :: *)
                  ~R# (CUChar -> Int -> CUChar :: *)))
      (GHC.Word.$fBitsWord8_$crotateL
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Int -> Word8 :: *)
                  ~R# (CUChar -> Int -> CUChar :: *)))
      (GHC.Word.$fBitsWord8_$crotateR
       `cast` (Sym (Foreign.C.Types.N:CUChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CUChar[0])
               :: (Word8 -> Int -> Word8 :: *)
                  ~R# (CUChar -> Int -> CUChar :: *)))
      (GHC.Word.$fBitsWord8_$cpopCount
       `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Int>_R
               :: (Word8 -> Int :: *) ~R# (CUChar -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.C.Types.$fFiniteBitsCUChar [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits CUChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: CUChar
                              Foreign.C.Types.$fBitsCUChar
                              GHC.Word.$fBitsWord8_$cfiniteBitSize
                              `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Int>_R
                                      :: (Word8 -> Int :: *) ~R# (CUChar -> Int :: *))
                              GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros
                              `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Int>_R
                                      :: (Word8 -> Int :: *) ~R# (CUChar -> Int :: *))
                              GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros
                              `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Int>_R
                                      :: (Word8 -> Int :: *) ~R# (CUChar -> Int :: *))]
Foreign.C.Types.$fFiniteBitsCUChar
  = Data.Bits.C:FiniteBits
      @ CUChar
      Foreign.C.Types.$fBitsCUChar
      (GHC.Word.$fBitsWord8_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Int>_R
               :: (Word8 -> Int :: *) ~R# (CUChar -> Int :: *)))
      (GHC.Word.$fFiniteBitsWord8_$ccountLeadingZeros
       `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Int>_R
               :: (Word8 -> Int :: *) ~R# (CUChar -> Int :: *)))
      (GHC.Word.$fFiniteBitsWord8_$ccountTrailingZeros
       `cast` (Sym (Foreign.C.Types.N:CUChar[0]) ->_R <Int>_R
               :: (Word8 -> Int :: *) ~R# (CUChar -> Int :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCSChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CSChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CSChar
                       GHC.Int.$fShowInt8_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CSChar[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Int8 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CSChar -> [Char] -> [Char] :: *))
                       GHC.Int.$fShowInt8_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <[Char]>_R
                               :: (Int8 -> [Char] :: *) ~R# (CSChar -> [Char] :: *))
                       GHC.Int.$fShowInt8_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CSChar[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Int8] -> [Char] -> [Char] :: *)
                                  ~R# ([CSChar] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCSChar
  = GHC.Show.C:Show
      @ CSChar
      (GHC.Int.$fShowInt8_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Int8 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CSChar -> [Char] -> [Char] :: *)))
      (GHC.Int.$fShowInt8_$cshow
       `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <[Char]>_R
               :: (Int8 -> [Char] :: *) ~R# (CSChar -> [Char] :: *)))
      (GHC.Int.$fShowInt8_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CSChar[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Int8] -> [Char] -> [Char] :: *)
                  ~R# ([CSChar] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCSChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CSChar
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CSChar
                       GHC.Int.$fReadInt8_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CSChar[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Int8, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CSChar, [Char])] :: *))
                       GHC.Int.$fReadInt8_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CSChar[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Int8], [Char])] :: *)
                                  ~R# ([Char] -> [([CSChar], [Char])] :: *))
                       GHC.Int.$fReadInt13
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Int8>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                    (Foreign.C.Types.N:CSChar[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Int8 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CSChar :: *))
                       GHC.Int.$fReadInt11
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Int8]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      ([Foreign.C.Types.N:CSChar[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Int8] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CSChar] :: *))]
Foreign.C.Types.$fReadCSChar
  = GHC.Read.C:Read
      @ CSChar
      (GHC.Int.$fReadInt8_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CSChar[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Int8, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CSChar, [Char])] :: *)))
      (GHC.Int.$fReadInt8_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CSChar[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Int8], [Char])] :: *)
                  ~R# ([Char] -> [([CSChar], [Char])] :: *)))
      (GHC.Int.$fReadInt13
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Int8>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                    (Foreign.C.Types.N:CSChar[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Int8 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CSChar :: *)))
      (GHC.Int.$fReadInt11
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Int8]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                      ([Foreign.C.Types.N:CSChar[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Int8] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CSChar] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.C.Types.$fBoundedCSChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded CSChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: CSChar
                          GHC.Int.$fBoundedInt8_$cminBound
                          `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                  :: (Int8 :: *) ~R# (CSChar :: *))
                          GHC.Int.$fBoundedInt8_$cmaxBound
                          `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                  :: (Int8 :: *) ~R# (CSChar :: *))]
Foreign.C.Types.$fBoundedCSChar
  = GHC.Enum.C:Bounded
      @ CSChar
      (GHC.Int.$fBoundedInt8_$cminBound
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 :: *) ~R# (CSChar :: *)))
      (GHC.Int.$fBoundedInt8_$cmaxBound
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 :: *) ~R# (CSChar :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCSChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CSChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CSChar
                                   Foreign.Storable.$fStorableInt8_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Int>_R
                                           :: (Int8 -> Int :: *) ~R# (CSChar -> Int :: *))
                                   Foreign.Storable.$fStorableInt8_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Int>_R
                                           :: (Int8 -> Int :: *) ~R# (CSChar -> Int :: *))
                                   GHC.Storable.readInt8OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int8, CSChar))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CSChar[0]))
                                           :: (GHC.Ptr.Ptr Int8
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int8 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CSChar -> Int -> IO CSChar :: *))
                                   GHC.Storable.writeInt8OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int8, CSChar))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int8
                                               -> Int
                                               -> Int8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CSChar
                                                   -> Int -> CSChar -> IO () :: *))
                                   Foreign.Storable.$fStorableInt23
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CSChar[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int8 #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> IO CSChar :: *))
                                   Foreign.Storable.$fStorableInt22
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Int8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CSChar -> IO () :: *))
                                   Foreign.Storable.$fStorableInt21
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int8, CSChar))_R
                                           ->_R Sym (GHC.Types.N:IO[0]
                                                         (Foreign.C.Types.N:CSChar[0]))
                                           :: (GHC.Ptr.Ptr Int8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int8 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CSChar -> IO CSChar :: *))
                                   Foreign.Storable.$fStorableInt20
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int8, CSChar))_R
                                           ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int8
                                               -> Int8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CSChar -> CSChar -> IO () :: *))]
Foreign.C.Types.$fStorableCSChar
  = Foreign.Storable.C:Storable
      @ CSChar
      (Foreign.Storable.$fStorableInt8_$calignment
       `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Int>_R
               :: (Int8 -> Int :: *) ~R# (CSChar -> Int :: *)))
      (Foreign.Storable.$fStorableInt8_$calignment
       `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Int>_R
               :: (Int8 -> Int :: *) ~R# (CSChar -> Int :: *)))
      (GHC.Storable.readInt8OffPtr1
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Int8, CSChar))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CSChar[0]))
               :: (GHC.Ptr.Ptr Int8
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int8 #) :: *)
                  ~R# (GHC.Ptr.Ptr CSChar -> Int -> IO CSChar :: *)))
      (GHC.Storable.writeInt8OffPtr1
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Int8, CSChar))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int8
                   -> Int
                   -> Int8
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CSChar -> Int -> CSChar -> IO () :: *)))
      (Foreign.Storable.$fStorableInt23
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CSChar[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int8 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CSChar :: *)))
      (Foreign.Storable.$fStorableInt22
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Int8
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CSChar -> IO () :: *)))
      (Foreign.Storable.$fStorableInt21
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Int8, CSChar))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CSChar[0]))
               :: (GHC.Ptr.Ptr Int8
                   -> State# RealWorld -> (# State# RealWorld, Int8 #) :: *)
                  ~R# (GHC.Ptr.Ptr CSChar -> IO CSChar :: *)))
      (Foreign.Storable.$fStorableInt20
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Int8, CSChar))_R
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int8
                   -> Int8 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CSChar -> CSChar -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCSChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CSChar
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CSChar
                       GHC.Int.$fEnumInt8_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                               ->_R Sym (Foreign.C.Types.N:CSChar[0])
                               :: (Int8 -> Int8 :: *) ~R# (CSChar -> CSChar :: *))
                       GHC.Int.$fEnumInt8_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                               ->_R Sym (Foreign.C.Types.N:CSChar[0])
                               :: (Int8 -> Int8 :: *) ~R# (CSChar -> CSChar :: *))
                       GHC.Int.$fEnumInt8_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CSChar[0])
                               :: (Int -> Int8 :: *) ~R# (Int -> CSChar :: *))
                       GHC.Int.$fEnumInt8_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Int>_R
                               :: (Int8 -> Int :: *) ~R# (CSChar -> Int :: *))
                       GHC.Int.$fEnumInt8_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                               ->_R ([Sym (Foreign.C.Types.N:CSChar[0])])_R
                               :: (Int8 -> [Int8] :: *) ~R# (CSChar -> [CSChar] :: *))
                       GHC.Int.$fEnumInt8_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                               ->_R Sym (Foreign.C.Types.N:CSChar[0])
                               ->_R ([Sym (Foreign.C.Types.N:CSChar[0])])_R
                               :: (Int8 -> Int8 -> [Int8] :: *)
                                  ~R# (CSChar -> CSChar -> [CSChar] :: *))
                       GHC.Int.$fEnumInt8_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                               ->_R Sym (Foreign.C.Types.N:CSChar[0])
                               ->_R ([Sym (Foreign.C.Types.N:CSChar[0])])_R
                               :: (Int8 -> Int8 -> [Int8] :: *)
                                  ~R# (CSChar -> CSChar -> [CSChar] :: *))
                       GHC.Int.$fEnumInt8_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                               ->_R Sym (Foreign.C.Types.N:CSChar[0])
                               ->_R Sym (Foreign.C.Types.N:CSChar[0])
                               ->_R ([Sym (Foreign.C.Types.N:CSChar[0])])_R
                               :: (Int8 -> Int8 -> Int8 -> [Int8] :: *)
                                  ~R# (CSChar -> CSChar -> CSChar -> [CSChar] :: *))]
Foreign.C.Types.$fEnumCSChar
  = GHC.Enum.C:Enum
      @ CSChar
      (GHC.Int.$fEnumInt8_$csucc
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int8 :: *) ~R# (CSChar -> CSChar :: *)))
      (GHC.Int.$fEnumInt8_$cpred
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int8 :: *) ~R# (CSChar -> CSChar :: *)))
      (GHC.Int.$fEnumInt8_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int -> Int8 :: *) ~R# (Int -> CSChar :: *)))
      (GHC.Int.$fEnumInt8_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Int>_R
               :: (Int8 -> Int :: *) ~R# (CSChar -> Int :: *)))
      (GHC.Int.$fEnumInt8_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R ([Sym (Foreign.C.Types.N:CSChar[0])])_R
               :: (Int8 -> [Int8] :: *) ~R# (CSChar -> [CSChar] :: *)))
      (GHC.Int.$fEnumInt8_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R ([Sym (Foreign.C.Types.N:CSChar[0])])_R
               :: (Int8 -> Int8 -> [Int8] :: *)
                  ~R# (CSChar -> CSChar -> [CSChar] :: *)))
      (GHC.Int.$fEnumInt8_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R ([Sym (Foreign.C.Types.N:CSChar[0])])_R
               :: (Int8 -> Int8 -> [Int8] :: *)
                  ~R# (CSChar -> CSChar -> [CSChar] :: *)))
      (GHC.Int.$fEnumInt8_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R ([Sym (Foreign.C.Types.N:CSChar[0])])_R
               :: (Int8 -> Int8 -> Int8 -> [Int8] :: *)
                  ~R# (CSChar -> CSChar -> CSChar -> [CSChar] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCSChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CSChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CSChar
                     GHC.Int.$fNumInt8_$c+
                     `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                             ->_R Sym (Foreign.C.Types.N:CSChar[0])
                             ->_R Sym (Foreign.C.Types.N:CSChar[0])
                             :: (Int8 -> Int8 -> Int8 :: *)
                                ~R# (CSChar -> CSChar -> CSChar :: *))
                     GHC.Int.$fNumInt8_$c-
                     `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                             ->_R Sym (Foreign.C.Types.N:CSChar[0])
                             ->_R Sym (Foreign.C.Types.N:CSChar[0])
                             :: (Int8 -> Int8 -> Int8 :: *)
                                ~R# (CSChar -> CSChar -> CSChar :: *))
                     GHC.Int.$fNumInt8_$c*
                     `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                             ->_R Sym (Foreign.C.Types.N:CSChar[0])
                             ->_R Sym (Foreign.C.Types.N:CSChar[0])
                             :: (Int8 -> Int8 -> Int8 :: *)
                                ~R# (CSChar -> CSChar -> CSChar :: *))
                     GHC.Int.$fNumInt8_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                             ->_R Sym (Foreign.C.Types.N:CSChar[0])
                             :: (Int8 -> Int8 :: *) ~R# (CSChar -> CSChar :: *))
                     GHC.Int.$fNumInt8_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                             ->_R Sym (Foreign.C.Types.N:CSChar[0])
                             :: (Int8 -> Int8 :: *) ~R# (CSChar -> CSChar :: *))
                     GHC.Int.$fNumInt8_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                             ->_R Sym (Foreign.C.Types.N:CSChar[0])
                             :: (Int8 -> Int8 :: *) ~R# (CSChar -> CSChar :: *))
                     GHC.Int.$fNumInt8_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CSChar[0])
                             :: (Integer -> Int8 :: *) ~R# (Integer -> CSChar :: *))]
Foreign.C.Types.$fNumCSChar
  = GHC.Num.C:Num
      @ CSChar
      (GHC.Int.$fNumInt8_$c+
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int8 -> Int8 :: *)
                  ~R# (CSChar -> CSChar -> CSChar :: *)))
      (GHC.Int.$fNumInt8_$c-
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int8 -> Int8 :: *)
                  ~R# (CSChar -> CSChar -> CSChar :: *)))
      (GHC.Int.$fNumInt8_$c*
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int8 -> Int8 :: *)
                  ~R# (CSChar -> CSChar -> CSChar :: *)))
      (GHC.Int.$fNumInt8_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int8 :: *) ~R# (CSChar -> CSChar :: *)))
      (GHC.Int.$fNumInt8_$cabs
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int8 :: *) ~R# (CSChar -> CSChar :: *)))
      (GHC.Int.$fNumInt8_$csignum
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int8 :: *) ~R# (CSChar -> CSChar :: *)))
      (GHC.Int.$fNumInt8_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Integer -> Int8 :: *) ~R# (Integer -> CSChar :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCSChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CSChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CSChar
                        GHC.Int.eqInt8
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R <Bool>_R
                                :: (Int8 -> Int8 -> Bool :: *) ~R# (CSChar -> CSChar -> Bool :: *))
                        GHC.Int.neInt8
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R <Bool>_R
                                :: (Int8 -> Int8 -> Bool :: *)
                                   ~R# (CSChar -> CSChar -> Bool :: *))]
Foreign.C.Types.$fEqCSChar
  = GHC.Classes.C:Eq
      @ CSChar
      (GHC.Int.eqInt8
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R <Bool>_R
               :: (Int8 -> Int8 -> Bool :: *)
                  ~R# (CSChar -> CSChar -> Bool :: *)))
      (GHC.Int.neInt8
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R <Bool>_R
               :: (Int8 -> Int8 -> Bool :: *)
                  ~R# (CSChar -> CSChar -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCSChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CSChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CSChar
                         Foreign.C.Types.$fEqCSChar
                         GHC.Int.$fOrdInt8_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                 ->_R <Ordering>_R
                                 :: (Int8 -> Int8 -> Ordering :: *)
                                    ~R# (CSChar -> CSChar -> Ordering :: *))
                         GHC.Int.ltInt8
                         `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                 ->_R <Bool>_R
                                 :: (Int8 -> Int8 -> Bool :: *) ~R# (CSChar -> CSChar -> Bool :: *))
                         GHC.Int.leInt8
                         `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                 ->_R <Bool>_R
                                 :: (Int8 -> Int8 -> Bool :: *) ~R# (CSChar -> CSChar -> Bool :: *))
                         GHC.Int.gtInt8
                         `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                 ->_R <Bool>_R
                                 :: (Int8 -> Int8 -> Bool :: *) ~R# (CSChar -> CSChar -> Bool :: *))
                         GHC.Int.geInt8
                         `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                 ->_R <Bool>_R
                                 :: (Int8 -> Int8 -> Bool :: *) ~R# (CSChar -> CSChar -> Bool :: *))
                         GHC.Int.$fOrdInt8_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                 :: (Int8 -> Int8 -> Int8 :: *)
                                    ~R# (CSChar -> CSChar -> CSChar :: *))
                         GHC.Int.$fOrdInt8_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                 :: (Int8 -> Int8 -> Int8 :: *)
                                    ~R# (CSChar -> CSChar -> CSChar :: *))]
Foreign.C.Types.$fOrdCSChar
  = GHC.Classes.C:Ord
      @ CSChar
      Foreign.C.Types.$fEqCSChar
      (GHC.Int.$fOrdInt8_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R <Ordering>_R
               :: (Int8 -> Int8 -> Ordering :: *)
                  ~R# (CSChar -> CSChar -> Ordering :: *)))
      (GHC.Int.ltInt8
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R <Bool>_R
               :: (Int8 -> Int8 -> Bool :: *)
                  ~R# (CSChar -> CSChar -> Bool :: *)))
      (GHC.Int.leInt8
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R <Bool>_R
               :: (Int8 -> Int8 -> Bool :: *)
                  ~R# (CSChar -> CSChar -> Bool :: *)))
      (GHC.Int.gtInt8
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R <Bool>_R
               :: (Int8 -> Int8 -> Bool :: *)
                  ~R# (CSChar -> CSChar -> Bool :: *)))
      (GHC.Int.geInt8
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R <Bool>_R
               :: (Int8 -> Int8 -> Bool :: *)
                  ~R# (CSChar -> CSChar -> Bool :: *)))
      (GHC.Int.$fOrdInt8_$cmax
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int8 -> Int8 :: *)
                  ~R# (CSChar -> CSChar -> CSChar :: *)))
      (GHC.Int.$fOrdInt8_$cmin
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int8 -> Int8 :: *)
                  ~R# (CSChar -> CSChar -> CSChar :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCSChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CSChar
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CSChar
                       Foreign.C.Types.$fNumCSChar
                       Foreign.C.Types.$fOrdCSChar
                       GHC.Int.$fRealInt8_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Ratio Integer>_R
                               :: (Int8 -> Ratio Integer :: *)
                                  ~R# (CSChar -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCSChar
  = GHC.Real.C:Real
      @ CSChar
      Foreign.C.Types.$fNumCSChar
      Foreign.C.Types.$fOrdCSChar
      (GHC.Int.$fRealInt8_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Ratio Integer>_R
               :: (Int8 -> Ratio Integer :: *)
                  ~R# (CSChar -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.C.Types.$fIntegralCSChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral CSChar
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: CSChar
                           Foreign.C.Types.$fRealCSChar
                           Foreign.C.Types.$fEnumCSChar
                           GHC.Int.$fIntegralInt8_$cquot
                           `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                   :: (Int8 -> Int8 -> Int8 :: *)
                                      ~R# (CSChar -> CSChar -> CSChar :: *))
                           GHC.Int.$fIntegralInt8_$crem
                           `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                   :: (Int8 -> Int8 -> Int8 :: *)
                                      ~R# (CSChar -> CSChar -> CSChar :: *))
                           GHC.Int.$fIntegralInt8_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                   :: (Int8 -> Int8 -> Int8 :: *)
                                      ~R# (CSChar -> CSChar -> CSChar :: *))
                           GHC.Int.$fIntegralInt8_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                   :: (Int8 -> Int8 -> Int8 :: *)
                                      ~R# (CSChar -> CSChar -> CSChar :: *))
                           GHC.Int.$fIntegralInt8_$cquotRem
                           `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CSChar[0]))
                                           (Sym (Foreign.C.Types.N:CSChar[0])))_R
                                   :: (Int8 -> Int8 -> (Int8, Int8) :: *)
                                      ~R# (CSChar -> CSChar -> (CSChar, CSChar) :: *))
                           GHC.Int.$fIntegralInt8_$cdivMod
                           `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CSChar[0]))
                                           (Sym (Foreign.C.Types.N:CSChar[0])))_R
                                   :: (Int8 -> Int8 -> (Int8, Int8) :: *)
                                      ~R# (CSChar -> CSChar -> (CSChar, CSChar) :: *))
                           GHC.Int.$fIntegralInt8_$ctoInteger
                           `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Integer>_R
                                   :: (Int8 -> Integer :: *) ~R# (CSChar -> Integer :: *))]
Foreign.C.Types.$fIntegralCSChar
  = GHC.Real.C:Integral
      @ CSChar
      Foreign.C.Types.$fRealCSChar
      Foreign.C.Types.$fEnumCSChar
      (GHC.Int.$fIntegralInt8_$cquot
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int8 -> Int8 :: *)
                  ~R# (CSChar -> CSChar -> CSChar :: *)))
      (GHC.Int.$fIntegralInt8_$crem
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int8 -> Int8 :: *)
                  ~R# (CSChar -> CSChar -> CSChar :: *)))
      (GHC.Int.$fIntegralInt8_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int8 -> Int8 :: *)
                  ~R# (CSChar -> CSChar -> CSChar :: *)))
      (GHC.Int.$fIntegralInt8_$cmod
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int8 -> Int8 :: *)
                  ~R# (CSChar -> CSChar -> CSChar :: *)))
      (GHC.Int.$fIntegralInt8_$cquotRem
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CSChar[0]))
                       (Sym (Foreign.C.Types.N:CSChar[0])))_R
               :: (Int8 -> Int8 -> (Int8, Int8) :: *)
                  ~R# (CSChar -> CSChar -> (CSChar, CSChar) :: *)))
      (GHC.Int.$fIntegralInt8_$cdivMod
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CSChar[0]))
                       (Sym (Foreign.C.Types.N:CSChar[0])))_R
               :: (Int8 -> Int8 -> (Int8, Int8) :: *)
                  ~R# (CSChar -> CSChar -> (CSChar, CSChar) :: *)))
      (GHC.Int.$fIntegralInt8_$ctoInteger
       `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Integer>_R
               :: (Int8 -> Integer :: *) ~R# (CSChar -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.C.Types.$fBitsCSChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits CSChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: CSChar
                        Foreign.C.Types.$fEqCSChar
                        GHC.Int.$fBitsInt8_$c.&.
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                :: (Int8 -> Int8 -> Int8 :: *)
                                   ~R# (CSChar -> CSChar -> CSChar :: *))
                        GHC.Int.$fBitsInt8_$c.|.
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                :: (Int8 -> Int8 -> Int8 :: *)
                                   ~R# (CSChar -> CSChar -> CSChar :: *))
                        GHC.Int.$fBitsInt8_$cxor
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                :: (Int8 -> Int8 -> Int8 :: *)
                                   ~R# (CSChar -> CSChar -> CSChar :: *))
                        GHC.Int.$fBitsInt8_$ccomplement
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                :: (Int8 -> Int8 :: *) ~R# (CSChar -> CSChar :: *))
                        GHC.Int.$fBitsInt8_$cshift
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *))
                        GHC.Int.$fBitsInt8_$crotate
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *))
                        GHC.Int.$fBitsInt13
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                :: (Int8 :: *) ~R# (CSChar :: *))
                        GHC.Int.$fBitsInt8_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                :: (Int -> Int8 :: *) ~R# (Int -> CSChar :: *))
                        GHC.Int.$fBitsInt8_$csetBit
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *))
                        GHC.Int.$fBitsInt8_$cclearBit
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *))
                        GHC.Int.$fBitsInt8_$ccomplementBit
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *))
                        GHC.Int.$fBitsInt8_$ctestBit
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Int -> Bool>_R
                                :: (Int8 -> Int -> Bool :: *) ~R# (CSChar -> Int -> Bool :: *))
                        GHC.Int.$fBitsInt8_$cbitSizeMaybe
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Maybe Int>_R
                                :: (Int8 -> Maybe Int :: *) ~R# (CSChar -> Maybe Int :: *))
                        GHC.Int.$fBitsInt8_$cfiniteBitSize
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Int>_R
                                :: (Int8 -> Int :: *) ~R# (CSChar -> Int :: *))
                        GHC.Int.$fBitsInt8_$cisSigned
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Bool>_R
                                :: (Int8 -> Bool :: *) ~R# (CSChar -> Bool :: *))
                        GHC.Int.$fBitsInt8_$cshiftL
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *))
                        GHC.Int.$fBitsInt8_$cunsafeShiftL
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *))
                        GHC.Int.$fBitsInt8_$cshiftR
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *))
                        GHC.Int.$fBitsInt8_$cunsafeShiftR
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *))
                        GHC.Int.$fBitsInt8_$crotateL
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *))
                        GHC.Int.$fBitsInt8_$crotateR
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CSChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *))
                        GHC.Int.$fBitsInt8_$cpopCount
                        `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Int>_R
                                :: (Int8 -> Int :: *) ~R# (CSChar -> Int :: *))]
Foreign.C.Types.$fBitsCSChar
  = Data.Bits.C:Bits
      @ CSChar
      Foreign.C.Types.$fEqCSChar
      (GHC.Int.$fBitsInt8_$c.&.
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int8 -> Int8 :: *)
                  ~R# (CSChar -> CSChar -> CSChar :: *)))
      (GHC.Int.$fBitsInt8_$c.|.
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int8 -> Int8 :: *)
                  ~R# (CSChar -> CSChar -> CSChar :: *)))
      (GHC.Int.$fBitsInt8_$cxor
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int8 -> Int8 :: *)
                  ~R# (CSChar -> CSChar -> CSChar :: *)))
      (GHC.Int.$fBitsInt8_$ccomplement
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int8 :: *) ~R# (CSChar -> CSChar :: *)))
      (GHC.Int.$fBitsInt8_$cshift
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *)))
      (GHC.Int.$fBitsInt8_$crotate
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *)))
      (GHC.Int.$fBitsInt13
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 :: *) ~R# (CSChar :: *)))
      (GHC.Int.$fBitsInt8_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int -> Int8 :: *) ~R# (Int -> CSChar :: *)))
      (GHC.Int.$fBitsInt8_$csetBit
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *)))
      (GHC.Int.$fBitsInt8_$cclearBit
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *)))
      (GHC.Int.$fBitsInt8_$ccomplementBit
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *)))
      (GHC.Int.$fBitsInt8_$ctestBit
       `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Int -> Bool>_R
               :: (Int8 -> Int -> Bool :: *) ~R# (CSChar -> Int -> Bool :: *)))
      (GHC.Int.$fBitsInt8_$cbitSizeMaybe
       `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Maybe Int>_R
               :: (Int8 -> Maybe Int :: *) ~R# (CSChar -> Maybe Int :: *)))
      (GHC.Int.$fBitsInt8_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Int>_R
               :: (Int8 -> Int :: *) ~R# (CSChar -> Int :: *)))
      (GHC.Int.$fBitsInt8_$cisSigned
       `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Bool>_R
               :: (Int8 -> Bool :: *) ~R# (CSChar -> Bool :: *)))
      (GHC.Int.$fBitsInt8_$cshiftL
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *)))
      (GHC.Int.$fBitsInt8_$cunsafeShiftL
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *)))
      (GHC.Int.$fBitsInt8_$cshiftR
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *)))
      (GHC.Int.$fBitsInt8_$cunsafeShiftR
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *)))
      (GHC.Int.$fBitsInt8_$crotateL
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *)))
      (GHC.Int.$fBitsInt8_$crotateR
       `cast` (Sym (Foreign.C.Types.N:CSChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CSChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CSChar -> Int -> CSChar :: *)))
      (GHC.Int.$fBitsInt8_$cpopCount
       `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Int>_R
               :: (Int8 -> Int :: *) ~R# (CSChar -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.C.Types.$fFiniteBitsCSChar [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits CSChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: CSChar
                              Foreign.C.Types.$fBitsCSChar
                              GHC.Int.$fBitsInt8_$cfiniteBitSize
                              `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Int>_R
                                      :: (Int8 -> Int :: *) ~R# (CSChar -> Int :: *))
                              GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros
                              `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Int>_R
                                      :: (Int8 -> Int :: *) ~R# (CSChar -> Int :: *))
                              GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros
                              `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Int>_R
                                      :: (Int8 -> Int :: *) ~R# (CSChar -> Int :: *))]
Foreign.C.Types.$fFiniteBitsCSChar
  = Data.Bits.C:FiniteBits
      @ CSChar
      Foreign.C.Types.$fBitsCSChar
      (GHC.Int.$fBitsInt8_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Int>_R
               :: (Int8 -> Int :: *) ~R# (CSChar -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros
       `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Int>_R
               :: (Int8 -> Int :: *) ~R# (CSChar -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros
       `cast` (Sym (Foreign.C.Types.N:CSChar[0]) ->_R <Int>_R
               :: (Int8 -> Int :: *) ~R# (CSChar -> Int :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 22, joins: 0/0}
Foreign.C.Types.$fShowCChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Show CChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Show.C:Show TYPE: CChar
                       GHC.Int.$fShowInt8_$cshowsPrec
                       `cast` (<Int>_R
                               ->_R Sym (Foreign.C.Types.N:CChar[0])
                               ->_R <[Char] -> [Char]>_R
                               :: (Int -> Int8 -> [Char] -> [Char] :: *)
                                  ~R# (Int -> CChar -> [Char] -> [Char] :: *))
                       GHC.Int.$fShowInt8_$cshow
                       `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <[Char]>_R
                               :: (Int8 -> [Char] :: *) ~R# (CChar -> [Char] :: *))
                       GHC.Int.$fShowInt8_$cshowList
                       `cast` (([Sym (Foreign.C.Types.N:CChar[0])])_R
                               ->_R <[Char] -> [Char]>_R
                               :: ([Int8] -> [Char] -> [Char] :: *)
                                  ~R# ([CChar] -> [Char] -> [Char] :: *))]
Foreign.C.Types.$fShowCChar
  = GHC.Show.C:Show
      @ CChar
      (GHC.Int.$fShowInt8_$cshowsPrec
       `cast` (<Int>_R
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R <[Char] -> [Char]>_R
               :: (Int -> Int8 -> [Char] -> [Char] :: *)
                  ~R# (Int -> CChar -> [Char] -> [Char] :: *)))
      (GHC.Int.$fShowInt8_$cshow
       `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <[Char]>_R
               :: (Int8 -> [Char] :: *) ~R# (CChar -> [Char] :: *)))
      (GHC.Int.$fShowInt8_$cshowList
       `cast` (([Sym (Foreign.C.Types.N:CChar[0])])_R
               ->_R <[Char] -> [Char]>_R
               :: ([Int8] -> [Char] -> [Char] :: *)
                  ~R# ([CChar] -> [Char] -> [Char] :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 41, joins: 0/0}
Foreign.C.Types.$fReadCChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Read CChar
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Read.C:Read TYPE: CChar
                       GHC.Int.$fReadInt8_$creadsPrec
                       `cast` (<Int>_R
                               ->_R <[Char]>_R
                               ->_R ([((,) (Sym (Foreign.C.Types.N:CChar[0])) <[Char]>_R)_R])_R
                               :: (Int -> [Char] -> [(Int8, [Char])] :: *)
                                  ~R# (Int -> [Char] -> [(CChar, [Char])] :: *))
                       GHC.Int.$fReadInt8_$creadList
                       `cast` (<[Char]>_R
                               ->_R ([((,)
                                         ([Sym (Foreign.C.Types.N:CChar[0])])_R <[Char]>_R)_R])_R
                               :: ([Char] -> [([Int8], [Char])] :: *)
                                  ~R# ([Char] -> [([CChar], [Char])] :: *))
                       GHC.Int.$fReadInt13
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <Int8>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                    (Foreign.C.Types.N:CChar[0]))
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      (Int8 -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CChar :: *))
                       GHC.Int.$fReadInt11
                       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                              <[Int8]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                                      ([Foreign.C.Types.N:CChar[0]])_R)
                               :: (Text.ParserCombinators.ReadPrec.Prec
                                   -> forall b.
                                      ([Int8] -> Text.ParserCombinators.ReadP.P b)
                                      -> Text.ParserCombinators.ReadP.P b :: *)
                                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CChar] :: *))]
Foreign.C.Types.$fReadCChar
  = GHC.Read.C:Read
      @ CChar
      (GHC.Int.$fReadInt8_$creadsPrec
       `cast` (<Int>_R
               ->_R <[Char]>_R
               ->_R ([((,) (Sym (Foreign.C.Types.N:CChar[0])) <[Char]>_R)_R])_R
               :: (Int -> [Char] -> [(Int8, [Char])] :: *)
                  ~R# (Int -> [Char] -> [(CChar, [Char])] :: *)))
      (GHC.Int.$fReadInt8_$creadList
       `cast` (<[Char]>_R
               ->_R ([((,)
                         ([Sym (Foreign.C.Types.N:CChar[0])])_R <[Char]>_R)_R])_R
               :: ([Char] -> [([Int8], [Char])] :: *)
                  ~R# ([Char] -> [([CChar], [Char])] :: *)))
      (GHC.Int.$fReadInt13
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <Int8>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                    (Foreign.C.Types.N:CChar[0]))
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      (Int8 -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec CChar :: *)))
      (GHC.Int.$fReadInt11
       `cast` ((<Text.ParserCombinators.ReadPrec.Prec>_R
                ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                              <[Int8]>_R)) ; Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                                      ([Foreign.C.Types.N:CChar[0]])_R)
               :: (Text.ParserCombinators.ReadPrec.Prec
                   -> forall b.
                      ([Int8] -> Text.ParserCombinators.ReadP.P b)
                      -> Text.ParserCombinators.ReadP.P b :: *)
                  ~R# (Text.ParserCombinators.ReadPrec.ReadPrec [CChar] :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 4, joins: 0/0}
Foreign.C.Types.$fBoundedCChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Bounded CChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Bounded TYPE: CChar
                          GHC.Int.$fBoundedInt8_$cminBound
                          `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                  :: (Int8 :: *) ~R# (CChar :: *))
                          GHC.Int.$fBoundedInt8_$cmaxBound
                          `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                  :: (Int8 :: *) ~R# (CChar :: *))]
Foreign.C.Types.$fBoundedCChar
  = GHC.Enum.C:Bounded
      @ CChar
      (GHC.Int.$fBoundedInt8_$cminBound
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 :: *) ~R# (CChar :: *)))
      (GHC.Int.$fBoundedInt8_$cmaxBound
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 :: *) ~R# (CChar :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 87, joins: 0/0}
Foreign.C.Types.$fStorableCChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable CChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: CChar
                                   Foreign.Storable.$fStorableInt8_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Int>_R
                                           :: (Int8 -> Int :: *) ~R# (CChar -> Int :: *))
                                   Foreign.Storable.$fStorableInt8_$calignment
                                   `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Int>_R
                                           :: (Int8 -> Int :: *) ~R# (CChar -> Int :: *))
                                   GHC.Storable.readInt8OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int8, CChar))_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CChar[0]))
                                           :: (GHC.Ptr.Ptr Int8
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int8 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CChar -> Int -> IO CChar :: *))
                                   GHC.Storable.writeInt8OffPtr1
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int8, CChar))_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CChar[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int8
                                               -> Int
                                               -> Int8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CChar -> Int -> CChar -> IO () :: *))
                                   Foreign.Storable.$fStorableInt23
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CChar[0]))
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int8 #) :: *)
                                              ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CChar :: *))
                                   Foreign.Storable.$fStorableInt22
                                   `cast` (forall (b :: <*>_N).
                                           <GHC.Ptr.Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (Foreign.C.Types.N:CChar[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               GHC.Ptr.Ptr b
                                               -> Int
                                               -> Int8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   GHC.Ptr.Ptr b -> Int -> CChar -> IO () :: *))
                                   Foreign.Storable.$fStorableInt21
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int8, CChar))_R
                                           ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CChar[0]))
                                           :: (GHC.Ptr.Ptr Int8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int8 #) :: *)
                                              ~R# (GHC.Ptr.Ptr CChar -> IO CChar :: *))
                                   Foreign.Storable.$fStorableInt20
                                   `cast` ((GHC.Ptr.Ptr
                                              Univ(phantom phantom <*>_N :: Int8, CChar))_R
                                           ->_R Sym (Foreign.C.Types.N:CChar[0])
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (GHC.Ptr.Ptr Int8
                                               -> Int8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (GHC.Ptr.Ptr CChar -> CChar -> IO () :: *))]
Foreign.C.Types.$fStorableCChar
  = Foreign.Storable.C:Storable
      @ CChar
      (Foreign.Storable.$fStorableInt8_$calignment
       `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Int>_R
               :: (Int8 -> Int :: *) ~R# (CChar -> Int :: *)))
      (Foreign.Storable.$fStorableInt8_$calignment
       `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Int>_R
               :: (Int8 -> Int :: *) ~R# (CChar -> Int :: *)))
      (GHC.Storable.readInt8OffPtr1
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Int8, CChar))_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CChar[0]))
               :: (GHC.Ptr.Ptr Int8
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int8 #) :: *)
                  ~R# (GHC.Ptr.Ptr CChar -> Int -> IO CChar :: *)))
      (GHC.Storable.writeInt8OffPtr1
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Int8, CChar))_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int8
                   -> Int
                   -> Int8
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CChar -> Int -> CChar -> IO () :: *)))
      (Foreign.Storable.$fStorableInt23
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CChar[0]))
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int8 #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> IO CChar :: *)))
      (Foreign.Storable.$fStorableInt22
       `cast` (forall (b :: <*>_N).
               <GHC.Ptr.Ptr b>_R
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   GHC.Ptr.Ptr b
                   -> Int
                   -> Int8
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. GHC.Ptr.Ptr b -> Int -> CChar -> IO () :: *)))
      (Foreign.Storable.$fStorableInt21
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Int8, CChar))_R
               ->_R Sym (GHC.Types.N:IO[0] (Foreign.C.Types.N:CChar[0]))
               :: (GHC.Ptr.Ptr Int8
                   -> State# RealWorld -> (# State# RealWorld, Int8 #) :: *)
                  ~R# (GHC.Ptr.Ptr CChar -> IO CChar :: *)))
      (Foreign.Storable.$fStorableInt20
       `cast` ((GHC.Ptr.Ptr Univ(phantom phantom <*>_N :: Int8, CChar))_R
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (GHC.Ptr.Ptr Int8
                   -> Int8 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (GHC.Ptr.Ptr CChar -> CChar -> IO () :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 54, joins: 0/0}
Foreign.C.Types.$fEnumCChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Enum CChar
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Enum.C:Enum TYPE: CChar
                       GHC.Int.$fEnumInt8_$csucc
                       `cast` (Sym (Foreign.C.Types.N:CChar[0])
                               ->_R Sym (Foreign.C.Types.N:CChar[0])
                               :: (Int8 -> Int8 :: *) ~R# (CChar -> CChar :: *))
                       GHC.Int.$fEnumInt8_$cpred
                       `cast` (Sym (Foreign.C.Types.N:CChar[0])
                               ->_R Sym (Foreign.C.Types.N:CChar[0])
                               :: (Int8 -> Int8 :: *) ~R# (CChar -> CChar :: *))
                       GHC.Int.$fEnumInt8_$ctoEnum
                       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CChar[0])
                               :: (Int -> Int8 :: *) ~R# (Int -> CChar :: *))
                       GHC.Int.$fEnumInt8_$cfromEnum
                       `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Int>_R
                               :: (Int8 -> Int :: *) ~R# (CChar -> Int :: *))
                       GHC.Int.$fEnumInt8_$cenumFrom
                       `cast` (Sym (Foreign.C.Types.N:CChar[0])
                               ->_R ([Sym (Foreign.C.Types.N:CChar[0])])_R
                               :: (Int8 -> [Int8] :: *) ~R# (CChar -> [CChar] :: *))
                       GHC.Int.$fEnumInt8_$cenumFromThen
                       `cast` (Sym (Foreign.C.Types.N:CChar[0])
                               ->_R Sym (Foreign.C.Types.N:CChar[0])
                               ->_R ([Sym (Foreign.C.Types.N:CChar[0])])_R
                               :: (Int8 -> Int8 -> [Int8] :: *)
                                  ~R# (CChar -> CChar -> [CChar] :: *))
                       GHC.Int.$fEnumInt8_$cenumFromTo
                       `cast` (Sym (Foreign.C.Types.N:CChar[0])
                               ->_R Sym (Foreign.C.Types.N:CChar[0])
                               ->_R ([Sym (Foreign.C.Types.N:CChar[0])])_R
                               :: (Int8 -> Int8 -> [Int8] :: *)
                                  ~R# (CChar -> CChar -> [CChar] :: *))
                       GHC.Int.$fEnumInt8_$cenumFromThenTo
                       `cast` (Sym (Foreign.C.Types.N:CChar[0])
                               ->_R Sym (Foreign.C.Types.N:CChar[0])
                               ->_R Sym (Foreign.C.Types.N:CChar[0])
                               ->_R ([Sym (Foreign.C.Types.N:CChar[0])])_R
                               :: (Int8 -> Int8 -> Int8 -> [Int8] :: *)
                                  ~R# (CChar -> CChar -> CChar -> [CChar] :: *))]
Foreign.C.Types.$fEnumCChar
  = GHC.Enum.C:Enum
      @ CChar
      (GHC.Int.$fEnumInt8_$csucc
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int8 :: *) ~R# (CChar -> CChar :: *)))
      (GHC.Int.$fEnumInt8_$cpred
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int8 :: *) ~R# (CChar -> CChar :: *)))
      (GHC.Int.$fEnumInt8_$ctoEnum
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int -> Int8 :: *) ~R# (Int -> CChar :: *)))
      (GHC.Int.$fEnumInt8_$cfromEnum
       `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Int>_R
               :: (Int8 -> Int :: *) ~R# (CChar -> Int :: *)))
      (GHC.Int.$fEnumInt8_$cenumFrom
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R ([Sym (Foreign.C.Types.N:CChar[0])])_R
               :: (Int8 -> [Int8] :: *) ~R# (CChar -> [CChar] :: *)))
      (GHC.Int.$fEnumInt8_$cenumFromThen
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R ([Sym (Foreign.C.Types.N:CChar[0])])_R
               :: (Int8 -> Int8 -> [Int8] :: *)
                  ~R# (CChar -> CChar -> [CChar] :: *)))
      (GHC.Int.$fEnumInt8_$cenumFromTo
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R ([Sym (Foreign.C.Types.N:CChar[0])])_R
               :: (Int8 -> Int8 -> [Int8] :: *)
                  ~R# (CChar -> CChar -> [CChar] :: *)))
      (GHC.Int.$fEnumInt8_$cenumFromThenTo
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R ([Sym (Foreign.C.Types.N:CChar[0])])_R
               :: (Int8 -> Int8 -> Int8 -> [Int8] :: *)
                  ~R# (CChar -> CChar -> CChar -> [CChar] :: *)))

-- RHS size: {terms: 8, types: 1, coercions: 43, joins: 0/0}
Foreign.C.Types.$fNumCChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Num CChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Num.C:Num TYPE: CChar
                     GHC.Int.$fNumInt8_$c+
                     `cast` (Sym (Foreign.C.Types.N:CChar[0])
                             ->_R Sym (Foreign.C.Types.N:CChar[0])
                             ->_R Sym (Foreign.C.Types.N:CChar[0])
                             :: (Int8 -> Int8 -> Int8 :: *) ~R# (CChar -> CChar -> CChar :: *))
                     GHC.Int.$fNumInt8_$c-
                     `cast` (Sym (Foreign.C.Types.N:CChar[0])
                             ->_R Sym (Foreign.C.Types.N:CChar[0])
                             ->_R Sym (Foreign.C.Types.N:CChar[0])
                             :: (Int8 -> Int8 -> Int8 :: *) ~R# (CChar -> CChar -> CChar :: *))
                     GHC.Int.$fNumInt8_$c*
                     `cast` (Sym (Foreign.C.Types.N:CChar[0])
                             ->_R Sym (Foreign.C.Types.N:CChar[0])
                             ->_R Sym (Foreign.C.Types.N:CChar[0])
                             :: (Int8 -> Int8 -> Int8 :: *) ~R# (CChar -> CChar -> CChar :: *))
                     GHC.Int.$fNumInt8_$cnegate
                     `cast` (Sym (Foreign.C.Types.N:CChar[0])
                             ->_R Sym (Foreign.C.Types.N:CChar[0])
                             :: (Int8 -> Int8 :: *) ~R# (CChar -> CChar :: *))
                     GHC.Int.$fNumInt8_$cabs
                     `cast` (Sym (Foreign.C.Types.N:CChar[0])
                             ->_R Sym (Foreign.C.Types.N:CChar[0])
                             :: (Int8 -> Int8 :: *) ~R# (CChar -> CChar :: *))
                     GHC.Int.$fNumInt8_$csignum
                     `cast` (Sym (Foreign.C.Types.N:CChar[0])
                             ->_R Sym (Foreign.C.Types.N:CChar[0])
                             :: (Int8 -> Int8 :: *) ~R# (CChar -> CChar :: *))
                     GHC.Int.$fNumInt8_$cfromInteger
                     `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CChar[0])
                             :: (Integer -> Int8 :: *) ~R# (Integer -> CChar :: *))]
Foreign.C.Types.$fNumCChar
  = GHC.Num.C:Num
      @ CChar
      (GHC.Int.$fNumInt8_$c+
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int8 -> Int8 :: *) ~R# (CChar -> CChar -> CChar :: *)))
      (GHC.Int.$fNumInt8_$c-
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int8 -> Int8 :: *) ~R# (CChar -> CChar -> CChar :: *)))
      (GHC.Int.$fNumInt8_$c*
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int8 -> Int8 :: *) ~R# (CChar -> CChar -> CChar :: *)))
      (GHC.Int.$fNumInt8_$cnegate
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int8 :: *) ~R# (CChar -> CChar :: *)))
      (GHC.Int.$fNumInt8_$cabs
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int8 :: *) ~R# (CChar -> CChar :: *)))
      (GHC.Int.$fNumInt8_$csignum
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int8 :: *) ~R# (CChar -> CChar :: *)))
      (GHC.Int.$fNumInt8_$cfromInteger
       `cast` (<Integer>_R ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Integer -> Int8 :: *) ~R# (Integer -> CChar :: *)))

-- RHS size: {terms: 3, types: 1, coercions: 14, joins: 0/0}
Foreign.C.Types.$fEqCChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Eq CChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Eq TYPE: CChar
                        GHC.Int.eqInt8
                        `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                ->_R Sym (Foreign.C.Types.N:CChar[0])
                                ->_R <Bool>_R
                                :: (Int8 -> Int8 -> Bool :: *) ~R# (CChar -> CChar -> Bool :: *))
                        GHC.Int.neInt8
                        `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                ->_R Sym (Foreign.C.Types.N:CChar[0])
                                ->_R <Bool>_R
                                :: (Int8 -> Int8 -> Bool :: *) ~R# (CChar -> CChar -> Bool :: *))]
Foreign.C.Types.$fEqCChar
  = GHC.Classes.C:Eq
      @ CChar
      (GHC.Int.eqInt8
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R <Bool>_R
               :: (Int8 -> Int8 -> Bool :: *) ~R# (CChar -> CChar -> Bool :: *)))
      (GHC.Int.neInt8
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R <Bool>_R
               :: (Int8 -> Int8 -> Bool :: *) ~R# (CChar -> CChar -> Bool :: *)))

-- RHS size: {terms: 9, types: 1, coercions: 51, joins: 0/0}
Foreign.C.Types.$fOrdCChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Ord CChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       GHC.Classes.C:Ord TYPE: CChar
                         Foreign.C.Types.$fEqCChar
                         GHC.Int.$fOrdInt8_$ccompare
                         `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CChar[0])
                                 ->_R <Ordering>_R
                                 :: (Int8 -> Int8 -> Ordering :: *)
                                    ~R# (CChar -> CChar -> Ordering :: *))
                         GHC.Int.ltInt8
                         `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CChar[0])
                                 ->_R <Bool>_R
                                 :: (Int8 -> Int8 -> Bool :: *) ~R# (CChar -> CChar -> Bool :: *))
                         GHC.Int.leInt8
                         `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CChar[0])
                                 ->_R <Bool>_R
                                 :: (Int8 -> Int8 -> Bool :: *) ~R# (CChar -> CChar -> Bool :: *))
                         GHC.Int.gtInt8
                         `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CChar[0])
                                 ->_R <Bool>_R
                                 :: (Int8 -> Int8 -> Bool :: *) ~R# (CChar -> CChar -> Bool :: *))
                         GHC.Int.geInt8
                         `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CChar[0])
                                 ->_R <Bool>_R
                                 :: (Int8 -> Int8 -> Bool :: *) ~R# (CChar -> CChar -> Bool :: *))
                         GHC.Int.$fOrdInt8_$cmax
                         `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CChar[0])
                                 :: (Int8 -> Int8 -> Int8 :: *) ~R# (CChar -> CChar -> CChar :: *))
                         GHC.Int.$fOrdInt8_$cmin
                         `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CChar[0])
                                 ->_R Sym (Foreign.C.Types.N:CChar[0])
                                 :: (Int8 -> Int8 -> Int8 :: *) ~R# (CChar -> CChar -> CChar :: *))]
Foreign.C.Types.$fOrdCChar
  = GHC.Classes.C:Ord
      @ CChar
      Foreign.C.Types.$fEqCChar
      (GHC.Int.$fOrdInt8_$ccompare
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R <Ordering>_R
               :: (Int8 -> Int8 -> Ordering :: *)
                  ~R# (CChar -> CChar -> Ordering :: *)))
      (GHC.Int.ltInt8
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R <Bool>_R
               :: (Int8 -> Int8 -> Bool :: *) ~R# (CChar -> CChar -> Bool :: *)))
      (GHC.Int.leInt8
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R <Bool>_R
               :: (Int8 -> Int8 -> Bool :: *) ~R# (CChar -> CChar -> Bool :: *)))
      (GHC.Int.gtInt8
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R <Bool>_R
               :: (Int8 -> Int8 -> Bool :: *) ~R# (CChar -> CChar -> Bool :: *)))
      (GHC.Int.geInt8
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R <Bool>_R
               :: (Int8 -> Int8 -> Bool :: *) ~R# (CChar -> CChar -> Bool :: *)))
      (GHC.Int.$fOrdInt8_$cmax
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int8 -> Int8 :: *) ~R# (CChar -> CChar -> CChar :: *)))
      (GHC.Int.$fOrdInt8_$cmin
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int8 -> Int8 :: *) ~R# (CChar -> CChar -> CChar :: *)))

-- RHS size: {terms: 4, types: 1, coercions: 5, joins: 0/0}
Foreign.C.Types.$fRealCChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Real CChar
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Real TYPE: CChar
                       Foreign.C.Types.$fNumCChar
                       Foreign.C.Types.$fOrdCChar
                       GHC.Int.$fRealInt8_$ctoRational
                       `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Ratio Integer>_R
                               :: (Int8 -> Ratio Integer :: *) ~R# (CChar -> Ratio Integer :: *))]
Foreign.C.Types.$fRealCChar
  = GHC.Real.C:Real
      @ CChar
      Foreign.C.Types.$fNumCChar
      Foreign.C.Types.$fOrdCChar
      (GHC.Int.$fRealInt8_$ctoRational
       `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Ratio Integer>_R
               :: (Int8 -> Ratio Integer :: *) ~R# (CChar -> Ratio Integer :: *)))

-- RHS size: {terms: 10, types: 1, coercions: 58, joins: 0/0}
Foreign.C.Types.$fIntegralCChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Integral CChar
[GblId[DFunId],
 Str=m,
 Unf=DFun: \ ->
       GHC.Real.C:Integral TYPE: CChar
                           Foreign.C.Types.$fRealCChar
                           Foreign.C.Types.$fEnumCChar
                           GHC.Int.$fIntegralInt8_$cquot
                           `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CChar[0])
                                   :: (Int8 -> Int8 -> Int8 :: *)
                                      ~R# (CChar -> CChar -> CChar :: *))
                           GHC.Int.$fIntegralInt8_$crem
                           `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CChar[0])
                                   :: (Int8 -> Int8 -> Int8 :: *)
                                      ~R# (CChar -> CChar -> CChar :: *))
                           GHC.Int.$fIntegralInt8_$cdiv
                           `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CChar[0])
                                   :: (Int8 -> Int8 -> Int8 :: *)
                                      ~R# (CChar -> CChar -> CChar :: *))
                           GHC.Int.$fIntegralInt8_$cmod
                           `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CChar[0])
                                   :: (Int8 -> Int8 -> Int8 :: *)
                                      ~R# (CChar -> CChar -> CChar :: *))
                           GHC.Int.$fIntegralInt8_$cquotRem
                           `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CChar[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CChar[0]))
                                           (Sym (Foreign.C.Types.N:CChar[0])))_R
                                   :: (Int8 -> Int8 -> (Int8, Int8) :: *)
                                      ~R# (CChar -> CChar -> (CChar, CChar) :: *))
                           GHC.Int.$fIntegralInt8_$cdivMod
                           `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                   ->_R Sym (Foreign.C.Types.N:CChar[0])
                                   ->_R ((,)
                                           (Sym (Foreign.C.Types.N:CChar[0]))
                                           (Sym (Foreign.C.Types.N:CChar[0])))_R
                                   :: (Int8 -> Int8 -> (Int8, Int8) :: *)
                                      ~R# (CChar -> CChar -> (CChar, CChar) :: *))
                           GHC.Int.$fIntegralInt8_$ctoInteger
                           `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Integer>_R
                                   :: (Int8 -> Integer :: *) ~R# (CChar -> Integer :: *))]
Foreign.C.Types.$fIntegralCChar
  = GHC.Real.C:Integral
      @ CChar
      Foreign.C.Types.$fRealCChar
      Foreign.C.Types.$fEnumCChar
      (GHC.Int.$fIntegralInt8_$cquot
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int8 -> Int8 :: *) ~R# (CChar -> CChar -> CChar :: *)))
      (GHC.Int.$fIntegralInt8_$crem
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int8 -> Int8 :: *) ~R# (CChar -> CChar -> CChar :: *)))
      (GHC.Int.$fIntegralInt8_$cdiv
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int8 -> Int8 :: *) ~R# (CChar -> CChar -> CChar :: *)))
      (GHC.Int.$fIntegralInt8_$cmod
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int8 -> Int8 :: *) ~R# (CChar -> CChar -> CChar :: *)))
      (GHC.Int.$fIntegralInt8_$cquotRem
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CChar[0]))
                       (Sym (Foreign.C.Types.N:CChar[0])))_R
               :: (Int8 -> Int8 -> (Int8, Int8) :: *)
                  ~R# (CChar -> CChar -> (CChar, CChar) :: *)))
      (GHC.Int.$fIntegralInt8_$cdivMod
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R ((,)
                       (Sym (Foreign.C.Types.N:CChar[0]))
                       (Sym (Foreign.C.Types.N:CChar[0])))_R
               :: (Int8 -> Int8 -> (Int8, Int8) :: *)
                  ~R# (CChar -> CChar -> (CChar, CChar) :: *)))
      (GHC.Int.$fIntegralInt8_$ctoInteger
       `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Integer>_R
               :: (Int8 -> Integer :: *) ~R# (CChar -> Integer :: *)))

-- RHS size: {terms: 24, types: 1, coercions: 134, joins: 0/0}
Foreign.C.Types.$fBitsCChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Bits CChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Unf=DFun: \ ->
       Data.Bits.C:Bits TYPE: CChar
                        Foreign.C.Types.$fEqCChar
                        GHC.Int.$fBitsInt8_$c.&.
                        `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                ->_R Sym (Foreign.C.Types.N:CChar[0])
                                ->_R Sym (Foreign.C.Types.N:CChar[0])
                                :: (Int8 -> Int8 -> Int8 :: *) ~R# (CChar -> CChar -> CChar :: *))
                        GHC.Int.$fBitsInt8_$c.|.
                        `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                ->_R Sym (Foreign.C.Types.N:CChar[0])
                                ->_R Sym (Foreign.C.Types.N:CChar[0])
                                :: (Int8 -> Int8 -> Int8 :: *) ~R# (CChar -> CChar -> CChar :: *))
                        GHC.Int.$fBitsInt8_$cxor
                        `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                ->_R Sym (Foreign.C.Types.N:CChar[0])
                                ->_R Sym (Foreign.C.Types.N:CChar[0])
                                :: (Int8 -> Int8 -> Int8 :: *) ~R# (CChar -> CChar -> CChar :: *))
                        GHC.Int.$fBitsInt8_$ccomplement
                        `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                ->_R Sym (Foreign.C.Types.N:CChar[0])
                                :: (Int8 -> Int8 :: *) ~R# (CChar -> CChar :: *))
                        GHC.Int.$fBitsInt8_$cshift
                        `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *))
                        GHC.Int.$fBitsInt8_$crotate
                        `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *))
                        GHC.Int.$fBitsInt13
                        `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                :: (Int8 :: *) ~R# (CChar :: *))
                        GHC.Int.$fBitsInt8_$cbit
                        `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CChar[0])
                                :: (Int -> Int8 :: *) ~R# (Int -> CChar :: *))
                        GHC.Int.$fBitsInt8_$csetBit
                        `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *))
                        GHC.Int.$fBitsInt8_$cclearBit
                        `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *))
                        GHC.Int.$fBitsInt8_$ccomplementBit
                        `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *))
                        GHC.Int.$fBitsInt8_$ctestBit
                        `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Int -> Bool>_R
                                :: (Int8 -> Int -> Bool :: *) ~R# (CChar -> Int -> Bool :: *))
                        GHC.Int.$fBitsInt8_$cbitSizeMaybe
                        `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Maybe Int>_R
                                :: (Int8 -> Maybe Int :: *) ~R# (CChar -> Maybe Int :: *))
                        GHC.Int.$fBitsInt8_$cfiniteBitSize
                        `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Int>_R
                                :: (Int8 -> Int :: *) ~R# (CChar -> Int :: *))
                        GHC.Int.$fBitsInt8_$cisSigned
                        `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Bool>_R
                                :: (Int8 -> Bool :: *) ~R# (CChar -> Bool :: *))
                        GHC.Int.$fBitsInt8_$cshiftL
                        `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *))
                        GHC.Int.$fBitsInt8_$cunsafeShiftL
                        `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *))
                        GHC.Int.$fBitsInt8_$cshiftR
                        `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *))
                        GHC.Int.$fBitsInt8_$cunsafeShiftR
                        `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *))
                        GHC.Int.$fBitsInt8_$crotateL
                        `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *))
                        GHC.Int.$fBitsInt8_$crotateR
                        `cast` (Sym (Foreign.C.Types.N:CChar[0])
                                ->_R <Int>_R
                                ->_R Sym (Foreign.C.Types.N:CChar[0])
                                :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *))
                        GHC.Int.$fBitsInt8_$cpopCount
                        `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Int>_R
                                :: (Int8 -> Int :: *) ~R# (CChar -> Int :: *))]
Foreign.C.Types.$fBitsCChar
  = Data.Bits.C:Bits
      @ CChar
      Foreign.C.Types.$fEqCChar
      (GHC.Int.$fBitsInt8_$c.&.
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int8 -> Int8 :: *) ~R# (CChar -> CChar -> CChar :: *)))
      (GHC.Int.$fBitsInt8_$c.|.
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int8 -> Int8 :: *) ~R# (CChar -> CChar -> CChar :: *)))
      (GHC.Int.$fBitsInt8_$cxor
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int8 -> Int8 :: *) ~R# (CChar -> CChar -> CChar :: *)))
      (GHC.Int.$fBitsInt8_$ccomplement
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int8 :: *) ~R# (CChar -> CChar :: *)))
      (GHC.Int.$fBitsInt8_$cshift
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *)))
      (GHC.Int.$fBitsInt8_$crotate
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *)))
      (GHC.Int.$fBitsInt13
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 :: *) ~R# (CChar :: *)))
      (GHC.Int.$fBitsInt8_$cbit
       `cast` (<Int>_R ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int -> Int8 :: *) ~R# (Int -> CChar :: *)))
      (GHC.Int.$fBitsInt8_$csetBit
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *)))
      (GHC.Int.$fBitsInt8_$cclearBit
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *)))
      (GHC.Int.$fBitsInt8_$ccomplementBit
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *)))
      (GHC.Int.$fBitsInt8_$ctestBit
       `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Int -> Bool>_R
               :: (Int8 -> Int -> Bool :: *) ~R# (CChar -> Int -> Bool :: *)))
      (GHC.Int.$fBitsInt8_$cbitSizeMaybe
       `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Maybe Int>_R
               :: (Int8 -> Maybe Int :: *) ~R# (CChar -> Maybe Int :: *)))
      (GHC.Int.$fBitsInt8_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Int>_R
               :: (Int8 -> Int :: *) ~R# (CChar -> Int :: *)))
      (GHC.Int.$fBitsInt8_$cisSigned
       `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Bool>_R
               :: (Int8 -> Bool :: *) ~R# (CChar -> Bool :: *)))
      (GHC.Int.$fBitsInt8_$cshiftL
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *)))
      (GHC.Int.$fBitsInt8_$cunsafeShiftL
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *)))
      (GHC.Int.$fBitsInt8_$cshiftR
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *)))
      (GHC.Int.$fBitsInt8_$cunsafeShiftR
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *)))
      (GHC.Int.$fBitsInt8_$crotateL
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *)))
      (GHC.Int.$fBitsInt8_$crotateR
       `cast` (Sym (Foreign.C.Types.N:CChar[0])
               ->_R <Int>_R
               ->_R Sym (Foreign.C.Types.N:CChar[0])
               :: (Int8 -> Int -> Int8 :: *) ~R# (CChar -> Int -> CChar :: *)))
      (GHC.Int.$fBitsInt8_$cpopCount
       `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Int>_R
               :: (Int8 -> Int :: *) ~R# (CChar -> Int :: *)))

-- RHS size: {terms: 5, types: 1, coercions: 12, joins: 0/0}
Foreign.C.Types.$fFiniteBitsCChar [InlPrag=NOUSERINLINE CONLIKE]
  :: FiniteBits CChar
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Data.Bits.C:FiniteBits TYPE: CChar
                              Foreign.C.Types.$fBitsCChar
                              GHC.Int.$fBitsInt8_$cfiniteBitSize
                              `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Int>_R
                                      :: (Int8 -> Int :: *) ~R# (CChar -> Int :: *))
                              GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros
                              `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Int>_R
                                      :: (Int8 -> Int :: *) ~R# (CChar -> Int :: *))
                              GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros
                              `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Int>_R
                                      :: (Int8 -> Int :: *) ~R# (CChar -> Int :: *))]
Foreign.C.Types.$fFiniteBitsCChar
  = Data.Bits.C:FiniteBits
      @ CChar
      Foreign.C.Types.$fBitsCChar
      (GHC.Int.$fBitsInt8_$cfiniteBitSize
       `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Int>_R
               :: (Int8 -> Int :: *) ~R# (CChar -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt8_$ccountLeadingZeros
       `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Int>_R
               :: (Int8 -> Int :: *) ~R# (CChar -> Int :: *)))
      (GHC.Int.$fFiniteBitsInt8_$ccountTrailingZeros
       `cast` (Sym (Foreign.C.Types.N:CChar[0]) ->_R <Int>_R
               :: (Int8 -> Int :: *) ~R# (CChar -> Int :: *)))

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Foreign.C.Types.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$trModule3
  = GHC.Types.TrNameS Foreign.C.Types.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Foreign.C.Types.$trModule2 = "Foreign.C.Types"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$trModule1
  = GHC.Types.TrNameS Foreign.C.Types.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Foreign.C.Types.$trModule
  = GHC.Types.Module
      Foreign.C.Types.$trModule3 Foreign.C.Types.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_r54rc :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_r54rc
  = GHC.Types.KindRepTyConApp
      GHC.Int.$tcInt8 (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1_r54rd :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep1_r54rd
  = GHC.Types.KindRepTyConApp
      GHC.Int.$tcInt16 (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep2_r54re :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep2_r54re
  = GHC.Types.KindRepTyConApp
      GHC.Word.$tcWord16 (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep3_r54rf :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep3_r54rf
  = GHC.Types.KindRepTyConApp
      GHC.Word.$tcWord8 (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep4_r54rg :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep4_r54rg
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcFloat (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep5_r54rh :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep5_r54rh
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcDouble (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep6_r54ri :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep6_r54ri
  = GHC.Types.KindRepTyConApp
      GHC.Int.$tcInt32 (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep7_r54rj :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep7_r54rj
  = GHC.Types.KindRepTyConApp
      GHC.Word.$tcWord32 (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep8_r54rk :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep8_r54rk
  = GHC.Types.KindRepTyConApp
      GHC.Int.$tcInt64 (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep9_r54rl :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep9_r54rl
  = GHC.Types.KindRepTyConApp
      GHC.Word.$tcWord64 (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCChar2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCChar2 = "CChar"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCChar1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCChar1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCChar2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCChar :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCChar
  = GHC.Types.TyCon
      2396474507734313709##
      6682082218532013927##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCChar1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep10_r54rm :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep10_r54rm
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCChar (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CChar1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CChar1
  = GHC.Types.KindRepFun $krep_r54rc $krep10_r54rm

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CChar3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CChar3 = "'CChar"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CChar2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CChar2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CChar3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CChar :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CChar
  = GHC.Types.TyCon
      16530466139966006137##
      10909368544422599906##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CChar2
      0#
      Foreign.C.Types.$tc'CChar1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCSChar2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCSChar2 = "CSChar"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCSChar1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCSChar1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCSChar2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCSChar :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCSChar
  = GHC.Types.TyCon
      670014241423056801##
      13143642922997006659##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCSChar1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep11_r54rn :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep11_r54rn
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCSChar (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CSChar1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CSChar1
  = GHC.Types.KindRepFun $krep_r54rc $krep11_r54rn

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CSChar3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CSChar3 = "'CSChar"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CSChar2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CSChar2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CSChar3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CSChar :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CSChar
  = GHC.Types.TyCon
      12967293744565543744##
      16172465149069937779##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CSChar2
      0#
      Foreign.C.Types.$tc'CSChar1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCUChar2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCUChar2 = "CUChar"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCUChar1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCUChar1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCUChar2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCUChar :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCUChar
  = GHC.Types.TyCon
      8453544638672177657##
      4088140939900538118##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCUChar1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep12_r54ro :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep12_r54ro
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCUChar (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUChar1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CUChar1
  = GHC.Types.KindRepFun $krep3_r54rf $krep12_r54ro

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUChar3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CUChar3 = "'CUChar"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUChar2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CUChar2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CUChar3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUChar :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CUChar
  = GHC.Types.TyCon
      10663029171348202549##
      3183188510825835811##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CUChar2
      0#
      Foreign.C.Types.$tc'CUChar1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCShort2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCShort2 = "CShort"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCShort1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCShort1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCShort2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCShort :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCShort
  = GHC.Types.TyCon
      14914560985572859509##
      5456450767128082830##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCShort1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep13_r54rp :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep13_r54rp
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCShort (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CShort1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CShort1
  = GHC.Types.KindRepFun $krep1_r54rd $krep13_r54rp

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CShort3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CShort3 = "'CShort"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CShort2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CShort2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CShort3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CShort :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CShort
  = GHC.Types.TyCon
      8012790609237483390##
      5585194063474609654##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CShort2
      0#
      Foreign.C.Types.$tc'CShort1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCUShort2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCUShort2 = "CUShort"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCUShort1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCUShort1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCUShort2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCUShort :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCUShort
  = GHC.Types.TyCon
      8017488325625726968##
      17560577666502845853##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCUShort1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep14_r54rq :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep14_r54rq
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCUShort (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUShort1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CUShort1
  = GHC.Types.KindRepFun $krep2_r54re $krep14_r54rq

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUShort3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CUShort3 = "'CUShort"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUShort2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CUShort2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CUShort3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUShort :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CUShort
  = GHC.Types.TyCon
      230481143628903571##
      69801006601599105##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CUShort2
      0#
      Foreign.C.Types.$tc'CUShort1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCInt2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Foreign.C.Types.$tcCInt2 = "CInt"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCInt1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCInt1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCInt2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCInt :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCInt
  = GHC.Types.TyCon
      12436196710956858214##
      2085191951279969833##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCInt1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep15_r54rr :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep15_r54rr
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCInt (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CInt1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CInt1
  = GHC.Types.KindRepFun $krep6_r54ri $krep15_r54rr

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CInt3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CInt3 = "'CInt"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CInt2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CInt2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CInt3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CInt :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CInt
  = GHC.Types.TyCon
      1120313203669928333##
      2109434438009157121##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CInt2
      0#
      Foreign.C.Types.$tc'CInt1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCUInt2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCUInt2 = "CUInt"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCUInt1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCUInt1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCUInt2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCUInt :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCUInt
  = GHC.Types.TyCon
      14846027554880959849##
      1568033666229718172##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCUInt1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep16_r54rs :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep16_r54rs
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCUInt (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUInt1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CUInt1
  = GHC.Types.KindRepFun $krep7_r54rj $krep16_r54rs

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUInt3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CUInt3 = "'CUInt"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUInt2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CUInt2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CUInt3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUInt :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CUInt
  = GHC.Types.TyCon
      5056806206685987871##
      16269849959994571619##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CUInt2
      0#
      Foreign.C.Types.$tc'CUInt1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCLong2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCLong2 = "CLong"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCLong1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCLong1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCLong2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCLong :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCLong
  = GHC.Types.TyCon
      10646618100418836143##
      9243001812621971743##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCLong1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep17_r54rt :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep17_r54rt
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCLong (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CLong1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CLong1
  = GHC.Types.KindRepFun $krep8_r54rk $krep17_r54rt

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CLong3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CLong3 = "'CLong"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CLong2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CLong2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CLong3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CLong :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CLong
  = GHC.Types.TyCon
      3628484187667118205##
      18251486164209701606##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CLong2
      0#
      Foreign.C.Types.$tc'CLong1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCULong2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCULong2 = "CULong"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCULong1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCULong1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCULong2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCULong :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCULong
  = GHC.Types.TyCon
      13895283310731510483##
      3072096496662073086##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCULong1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep18_r54ru :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep18_r54ru
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCULong (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CULong1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CULong1
  = GHC.Types.KindRepFun $krep9_r54rl $krep18_r54ru

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CULong3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CULong3 = "'CULong"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CULong2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CULong2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CULong3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CULong :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CULong
  = GHC.Types.TyCon
      15519685101152487835##
      12004583885240283077##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CULong2
      0#
      Foreign.C.Types.$tc'CULong1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCLLong2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCLLong2 = "CLLong"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCLLong1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCLLong1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCLLong2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCLLong :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCLLong
  = GHC.Types.TyCon
      14244409577131416195##
      5952802457093262910##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCLLong1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep19_r54rv :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep19_r54rv
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCLLong (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CLLong1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CLLong1
  = GHC.Types.KindRepFun $krep8_r54rk $krep19_r54rv

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CLLong3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CLLong3 = "'CLLong"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CLLong2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CLLong2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CLLong3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CLLong :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CLLong
  = GHC.Types.TyCon
      5567960549599469613##
      3143535471112770491##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CLLong2
      0#
      Foreign.C.Types.$tc'CLLong1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCULLong2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCULLong2 = "CULLong"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCULLong1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCULLong1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCULLong2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCULLong :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCULLong
  = GHC.Types.TyCon
      12322165229137886614##
      18269851590527847329##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCULLong1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep20_r54rw :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep20_r54rw
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCULLong (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CULLong1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CULLong1
  = GHC.Types.KindRepFun $krep9_r54rl $krep20_r54rw

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CULLong3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CULLong3 = "'CULLong"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CULLong2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CULLong2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CULLong3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CULLong :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CULLong
  = GHC.Types.TyCon
      3146513334079263607##
      15997303439394869846##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CULLong2
      0#
      Foreign.C.Types.$tc'CULLong1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCBool2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCBool2 = "CBool"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCBool1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCBool1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCBool2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCBool :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCBool
  = GHC.Types.TyCon
      2279337507396481328##
      13354832971938562972##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCBool1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep21_r54rx :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep21_r54rx
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCBool (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CBool1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CBool1
  = GHC.Types.KindRepFun $krep3_r54rf $krep21_r54rx

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CBool3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CBool3 = "'CBool"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CBool2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CBool2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CBool3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CBool :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CBool
  = GHC.Types.TyCon
      7877573716786595125##
      10108068606237611138##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CBool2
      0#
      Foreign.C.Types.$tc'CBool1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCFloat2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCFloat2 = "CFloat"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCFloat1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCFloat1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCFloat2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCFloat :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCFloat
  = GHC.Types.TyCon
      7535293774037760901##
      15755754912293552836##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCFloat1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep22_r54ry :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep22_r54ry
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCFloat (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CFloat1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CFloat1
  = GHC.Types.KindRepFun $krep4_r54rg $krep22_r54ry

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CFloat3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CFloat3 = "'CFloat"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CFloat2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CFloat2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CFloat3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CFloat :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CFloat
  = GHC.Types.TyCon
      14616473864857291281##
      17808868477168782076##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CFloat2
      0#
      Foreign.C.Types.$tc'CFloat1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCDouble2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCDouble2 = "CDouble"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCDouble1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCDouble1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCDouble2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCDouble :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCDouble
  = GHC.Types.TyCon
      6818159078703101232##
      2532424603516558210##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCDouble1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep23_r54rz :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep23_r54rz
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCDouble (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CDouble1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CDouble1
  = GHC.Types.KindRepFun $krep5_r54rh $krep23_r54rz

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CDouble3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CDouble3 = "'CDouble"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CDouble2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CDouble2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CDouble3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CDouble :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CDouble
  = GHC.Types.TyCon
      17825589113792566821##
      2117840440117442278##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CDouble2
      0#
      Foreign.C.Types.$tc'CDouble1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCPtrdiff2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCPtrdiff2 = "CPtrdiff"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCPtrdiff1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCPtrdiff1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCPtrdiff2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCPtrdiff :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCPtrdiff
  = GHC.Types.TyCon
      17214415904810395203##
      17157228803030510849##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCPtrdiff1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep24_r54rA :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep24_r54rA
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCPtrdiff (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CPtrdiff1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CPtrdiff1
  = GHC.Types.KindRepFun $krep8_r54rk $krep24_r54rA

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CPtrdiff3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Foreign.C.Types.$tc'CPtrdiff3 = "'CPtrdiff"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CPtrdiff2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CPtrdiff2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CPtrdiff3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CPtrdiff :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CPtrdiff
  = GHC.Types.TyCon
      11471205784925482390##
      4232446785647106570##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CPtrdiff2
      0#
      Foreign.C.Types.$tc'CPtrdiff1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCSize2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCSize2 = "CSize"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCSize1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCSize1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCSize2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCSize :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCSize
  = GHC.Types.TyCon
      13349225497583392568##
      2637756187933719306##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCSize1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep25_r54rB :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep25_r54rB
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCSize (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CSize1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CSize1
  = GHC.Types.KindRepFun $krep9_r54rl $krep25_r54rB

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CSize3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CSize3 = "'CSize"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CSize2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CSize2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CSize3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CSize :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CSize
  = GHC.Types.TyCon
      10732574519801736620##
      9582148817759369933##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CSize2
      0#
      Foreign.C.Types.$tc'CSize1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCWchar2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCWchar2 = "CWchar"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCWchar1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCWchar1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCWchar2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCWchar :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCWchar
  = GHC.Types.TyCon
      17109569786881617348##
      12848424059160789567##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCWchar1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep26_r54rC :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep26_r54rC
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCWchar (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CWchar1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CWchar1
  = GHC.Types.KindRepFun $krep6_r54ri $krep26_r54rC

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CWchar3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CWchar3 = "'CWchar"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CWchar2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CWchar2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CWchar3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CWchar :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CWchar
  = GHC.Types.TyCon
      12847418893300185693##
      10342021236626115560##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CWchar2
      0#
      Foreign.C.Types.$tc'CWchar1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCSigAtomic2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Foreign.C.Types.$tcCSigAtomic2 = "CSigAtomic"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCSigAtomic1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCSigAtomic1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCSigAtomic2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCSigAtomic :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCSigAtomic
  = GHC.Types.TyCon
      10964102087567040849##
      4732914489126451968##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCSigAtomic1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep27_r54rD :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep27_r54rD
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCSigAtomic (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CSigAtomic1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CSigAtomic1
  = GHC.Types.KindRepFun $krep6_r54ri $krep27_r54rD

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CSigAtomic3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Foreign.C.Types.$tc'CSigAtomic3 = "'CSigAtomic"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CSigAtomic2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CSigAtomic2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CSigAtomic3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CSigAtomic :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CSigAtomic
  = GHC.Types.TyCon
      13396342001631048434##
      10235017041220212375##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CSigAtomic2
      0#
      Foreign.C.Types.$tc'CSigAtomic1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCClock2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCClock2 = "CClock"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCClock1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCClock1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCClock2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCClock :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCClock
  = GHC.Types.TyCon
      4014099957796664594##
      16004588873343805550##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCClock1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep28_r54rE :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep28_r54rE
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCClock (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CClock1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CClock1
  = GHC.Types.KindRepFun $krep8_r54rk $krep28_r54rE

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CClock3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CClock3 = "'CClock"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CClock2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CClock2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CClock3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CClock :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CClock
  = GHC.Types.TyCon
      7016713985082915031##
      17346134655367323413##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CClock2
      0#
      Foreign.C.Types.$tc'CClock1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCTime2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCTime2 = "CTime"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCTime1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCTime1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCTime2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCTime :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCTime
  = GHC.Types.TyCon
      6217075761792864271##
      2605806391289821578##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCTime1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep29_r54rF :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep29_r54rF
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCTime (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CTime1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CTime1
  = GHC.Types.KindRepFun $krep8_r54rk $krep29_r54rF

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CTime3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CTime3 = "'CTime"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CTime2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CTime2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CTime3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CTime :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CTime
  = GHC.Types.TyCon
      17509316711753497463##
      1311689641528100086##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CTime2
      0#
      Foreign.C.Types.$tc'CTime1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCUSeconds2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Foreign.C.Types.$tcCUSeconds2 = "CUSeconds"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCUSeconds1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCUSeconds1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCUSeconds2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCUSeconds :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCUSeconds
  = GHC.Types.TyCon
      17405471525584189701##
      2346565657742720464##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCUSeconds1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep30_r54rG :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep30_r54rG
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCUSeconds (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUSeconds1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CUSeconds1
  = GHC.Types.KindRepFun $krep7_r54rj $krep30_r54rG

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUSeconds3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Foreign.C.Types.$tc'CUSeconds3 = "'CUSeconds"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUSeconds2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CUSeconds2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CUSeconds3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUSeconds :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CUSeconds
  = GHC.Types.TyCon
      1636377087964720166##
      9077913612209140483##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CUSeconds2
      0#
      Foreign.C.Types.$tc'CUSeconds1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCSUSeconds2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Foreign.C.Types.$tcCSUSeconds2 = "CSUSeconds"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCSUSeconds1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCSUSeconds1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCSUSeconds2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCSUSeconds :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCSUSeconds
  = GHC.Types.TyCon
      17742176050705091078##
      4953235515970284689##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCSUSeconds1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep31_r54rH :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep31_r54rH
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCSUSeconds (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CSUSeconds1 [InlPrag=NOUSERINLINE[~]]
  :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CSUSeconds1
  = GHC.Types.KindRepFun $krep8_r54rk $krep31_r54rH

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CSUSeconds3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Foreign.C.Types.$tc'CSUSeconds3 = "'CSUSeconds"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CSUSeconds2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CSUSeconds2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CSUSeconds3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CSUSeconds :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CSUSeconds
  = GHC.Types.TyCon
      1705325731812814046##
      1387105441940513020##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CSUSeconds2
      0#
      Foreign.C.Types.$tc'CSUSeconds1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCFile2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCFile2 = "CFile"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCFile1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCFile1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCFile2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCFile :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCFile
  = GHC.Types.TyCon
      14154907999347903425##
      1814172269682152286##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCFile1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CFile1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
Foreign.C.Types.$tc'CFile1
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCFile (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CFile3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CFile3 = "'CFile"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CFile2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CFile2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CFile3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CFile :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CFile
  = GHC.Types.TyCon
      12302197724313820129##
      4785193272387875481##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CFile2
      0#
      Foreign.C.Types.$tc'CFile1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCFpos2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCFpos2 = "CFpos"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCFpos1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCFpos1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCFpos2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCFpos :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCFpos
  = GHC.Types.TyCon
      16874339295908012189##
      2656467663994338805##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCFpos1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CFpos1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
Foreign.C.Types.$tc'CFpos1
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCFpos (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CFpos3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CFpos3 = "'CFpos"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CFpos2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CFpos2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CFpos3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CFpos :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CFpos
  = GHC.Types.TyCon
      18279263347003670163##
      11699892855938511932##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CFpos2
      0#
      Foreign.C.Types.$tc'CFpos1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCJmpBuf2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCJmpBuf2 = "CJmpBuf"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCJmpBuf1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCJmpBuf1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCJmpBuf2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCJmpBuf :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCJmpBuf
  = GHC.Types.TyCon
      5219762936910773001##
      5563521999894797471##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCJmpBuf1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CJmpBuf1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
Foreign.C.Types.$tc'CJmpBuf1
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCJmpBuf (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CJmpBuf3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CJmpBuf3 = "'CJmpBuf"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CJmpBuf2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CJmpBuf2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CJmpBuf3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CJmpBuf :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CJmpBuf
  = GHC.Types.TyCon
      8278531976244408132##
      11989261641992411619##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CJmpBuf2
      0#
      Foreign.C.Types.$tc'CJmpBuf1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCIntPtr2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCIntPtr2 = "CIntPtr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCIntPtr1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCIntPtr1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCIntPtr2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCIntPtr :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCIntPtr
  = GHC.Types.TyCon
      4666846936648130190##
      1074292558155745783##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCIntPtr1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep32_r54rI :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep32_r54rI
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCIntPtr (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CIntPtr1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CIntPtr1
  = GHC.Types.KindRepFun $krep8_r54rk $krep32_r54rI

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CIntPtr3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CIntPtr3 = "'CIntPtr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CIntPtr2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CIntPtr2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CIntPtr3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CIntPtr :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CIntPtr
  = GHC.Types.TyCon
      14193281566492847253##
      11429158215235451511##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CIntPtr2
      0#
      Foreign.C.Types.$tc'CIntPtr1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCUIntPtr2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCUIntPtr2 = "CUIntPtr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCUIntPtr1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCUIntPtr1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCUIntPtr2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCUIntPtr :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCUIntPtr
  = GHC.Types.TyCon
      3784320557383063626##
      5356790357315597843##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCUIntPtr1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep33_r54rJ :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep33_r54rJ
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCUIntPtr (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUIntPtr1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CUIntPtr1
  = GHC.Types.KindRepFun $krep9_r54rl $krep33_r54rJ

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUIntPtr3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Foreign.C.Types.$tc'CUIntPtr3 = "'CUIntPtr"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUIntPtr2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CUIntPtr2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CUIntPtr3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUIntPtr :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CUIntPtr
  = GHC.Types.TyCon
      13898690391388793946##
      494854583711937458##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CUIntPtr2
      0#
      Foreign.C.Types.$tc'CUIntPtr1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCIntMax2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCIntMax2 = "CIntMax"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCIntMax1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCIntMax1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCIntMax2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCIntMax :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCIntMax
  = GHC.Types.TyCon
      12739001320308858558##
      4975233500487868495##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCIntMax1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep34_r54rK :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep34_r54rK
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCIntMax (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CIntMax1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CIntMax1
  = GHC.Types.KindRepFun $krep8_r54rk $krep34_r54rK

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CIntMax3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tc'CIntMax3 = "'CIntMax"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CIntMax2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CIntMax2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CIntMax3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CIntMax :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CIntMax
  = GHC.Types.TyCon
      2671575007670815434##
      14572633195159182874##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CIntMax2
      0#
      Foreign.C.Types.$tc'CIntMax1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCUIntMax2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.C.Types.$tcCUIntMax2 = "CUIntMax"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCUIntMax1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tcCUIntMax1
  = GHC.Types.TrNameS Foreign.C.Types.$tcCUIntMax2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tcCUIntMax :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tcCUIntMax
  = GHC.Types.TyCon
      10275136122733258480##
      14814319483566909713##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tcCUIntMax1
      0#
      GHC.Types.krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep35_r54rL :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep35_r54rL
  = GHC.Types.KindRepTyConApp
      Foreign.C.Types.$tcCUIntMax (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUIntMax1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.C.Types.$tc'CUIntMax1
  = GHC.Types.KindRepFun $krep9_r54rl $krep35_r54rL

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUIntMax3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 40 0}]
Foreign.C.Types.$tc'CUIntMax3 = "'CUIntMax"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUIntMax2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.C.Types.$tc'CUIntMax2
  = GHC.Types.TrNameS Foreign.C.Types.$tc'CUIntMax3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.C.Types.$tc'CUIntMax :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.C.Types.$tc'CUIntMax
  = GHC.Types.TyCon
      4605074089694102640##
      11721661597354817794##
      Foreign.C.Types.$trModule
      Foreign.C.Types.$tc'CUIntMax2
      0#
      Foreign.C.Types.$tc'CUIntMax1


------ Local rules for imported ids --------
"fromIntegral/a->CIntPtr"
    forall (@ a_a51Jy)
           ($dIntegral_a51Jw :: Integral a_a51Jy)
           ($dNum_a51Jx :: Num CIntPtr).
      fromIntegral @ a_a51Jy @ CIntPtr $dIntegral_a51Jw $dNum_a51Jx
      = (\ (x_a4S4h :: a_a51Jy) ->
           fromIntegral
             @ a_a51Jy @ Int64 $dIntegral_a51Jw GHC.Int.$fNumInt64 x_a4S4h)
        `cast` (<a_a51Jy>_R ->_R Sym (Foreign.C.Types.N:CIntPtr[0])
                :: (a_a51Jy -> Int64 :: *) ~R# (a_a51Jy -> CIntPtr :: *))
"fromIntegral/a->CUIntPtr"
    forall (@ a_a51JP)
           ($dIntegral_a51JN :: Integral a_a51JP)
           ($dNum_a51JO :: Num CUIntPtr).
      fromIntegral @ a_a51JP @ CUIntPtr $dIntegral_a51JN $dNum_a51JO
      = (\ (x_a4S4i :: a_a51JP) ->
           fromIntegral
             @ a_a51JP @ Word64 $dIntegral_a51JN GHC.Word.$fNumWord64 x_a4S4i)
        `cast` (<a_a51JP>_R ->_R Sym (Foreign.C.Types.N:CUIntPtr[0])
                :: (a_a51JP -> Word64 :: *) ~R# (a_a51JP -> CUIntPtr :: *))
"fromIntegral/a->CIntMax"
    forall (@ a_a51K6)
           ($dIntegral_a51K4 :: Integral a_a51K6)
           ($dNum_a51K5 :: Num CIntMax).
      fromIntegral @ a_a51K6 @ CIntMax $dIntegral_a51K4 $dNum_a51K5
      = (\ (x_a4S4j :: a_a51K6) ->
           fromIntegral
             @ a_a51K6 @ Int64 $dIntegral_a51K4 GHC.Int.$fNumInt64 x_a4S4j)
        `cast` (<a_a51K6>_R ->_R Sym (Foreign.C.Types.N:CIntMax[0])
                :: (a_a51K6 -> Int64 :: *) ~R# (a_a51K6 -> CIntMax :: *))
"fromIntegral/a->CUIntMax"
    forall (@ a_a51Kn)
           ($dIntegral_a51Kl :: Integral a_a51Kn)
           ($dNum_a51Km :: Num CUIntMax).
      fromIntegral @ a_a51Kn @ CUIntMax $dIntegral_a51Kl $dNum_a51Km
      = (\ (x_a4S4k :: a_a51Kn) ->
           fromIntegral
             @ a_a51Kn @ Word64 $dIntegral_a51Kl GHC.Word.$fNumWord64 x_a4S4k)
        `cast` (<a_a51Kn>_R ->_R Sym (Foreign.C.Types.N:CUIntMax[0])
                :: (a_a51Kn -> Word64 :: *) ~R# (a_a51Kn -> CUIntMax :: *))
"fromIntegral/a->CPtrdiff"
    forall (@ a_a51KE)
           ($dIntegral_a51KC :: Integral a_a51KE)
           ($dNum_a51KD :: Num CPtrdiff).
      fromIntegral @ a_a51KE @ CPtrdiff $dIntegral_a51KC $dNum_a51KD
      = (\ (x_a4S4l :: a_a51KE) ->
           fromIntegral
             @ a_a51KE @ Int64 $dIntegral_a51KC GHC.Int.$fNumInt64 x_a4S4l)
        `cast` (<a_a51KE>_R ->_R Sym (Foreign.C.Types.N:CPtrdiff[0])
                :: (a_a51KE -> Int64 :: *) ~R# (a_a51KE -> CPtrdiff :: *))
"fromIntegral/a->CSize"
    forall (@ a_a51KV)
           ($dIntegral_a51KT :: Integral a_a51KV)
           ($dNum_a51KU :: Num CSize).
      fromIntegral @ a_a51KV @ CSize $dIntegral_a51KT $dNum_a51KU
      = (\ (x_a4S4m :: a_a51KV) ->
           fromIntegral
             @ a_a51KV @ Word64 $dIntegral_a51KT GHC.Word.$fNumWord64 x_a4S4m)
        `cast` (<a_a51KV>_R ->_R Sym (Foreign.C.Types.N:CSize[0])
                :: (a_a51KV -> Word64 :: *) ~R# (a_a51KV -> CSize :: *))
"fromIntegral/a->CWchar"
    forall (@ a_a51Lc)
           ($dIntegral_a51La :: Integral a_a51Lc)
           ($dNum_a51Lb :: Num CWchar).
      fromIntegral @ a_a51Lc @ CWchar $dIntegral_a51La $dNum_a51Lb
      = (\ (x_a4S4n :: a_a51Lc) ->
           fromIntegral
             @ a_a51Lc @ Int32 $dIntegral_a51La GHC.Int.$fNumInt32 x_a4S4n)
        `cast` (<a_a51Lc>_R ->_R Sym (Foreign.C.Types.N:CWchar[0])
                :: (a_a51Lc -> Int32 :: *) ~R# (a_a51Lc -> CWchar :: *))
"fromIntegral/a->CSigAtomic"
    forall (@ a_a51Lt)
           ($dIntegral_a51Lr :: Integral a_a51Lt)
           ($dNum_a51Ls :: Num CSigAtomic).
      fromIntegral @ a_a51Lt @ CSigAtomic $dIntegral_a51Lr $dNum_a51Ls
      = (\ (x_a4S4o :: a_a51Lt) ->
           fromIntegral
             @ a_a51Lt @ Int32 $dIntegral_a51Lr GHC.Int.$fNumInt32 x_a4S4o)
        `cast` (<a_a51Lt>_R ->_R Sym (Foreign.C.Types.N:CSigAtomic[0])
                :: (a_a51Lt -> Int32 :: *) ~R# (a_a51Lt -> CSigAtomic :: *))
"fromIntegral/CPtrdiff->a"
    forall (@ b_a51LH)
           ($dIntegral_a51LI :: Integral CPtrdiff)
           ($dNum_a51LJ :: Num b_a51LH).
      fromIntegral @ CPtrdiff @ b_a51LH $dIntegral_a51LI $dNum_a51LJ
      = \ (ds_d54kh :: CPtrdiff) ->
          fromIntegral
            @ Int64
            @ b_a51LH
            GHC.Int.$fIntegralInt64
            $dNum_a51LJ
            (ds_d54kh
             `cast` (Foreign.C.Types.N:CPtrdiff[0]
                     :: (CPtrdiff :: *) ~R# (Int64 :: *)))
"fromIntegral/CSize->a"
    forall (@ b_a51LY)
           ($dIntegral_a51LZ :: Integral CSize)
           ($dNum_a51M0 :: Num b_a51LY).
      fromIntegral @ CSize @ b_a51LY $dIntegral_a51LZ $dNum_a51M0
      = \ (ds_d54kl :: CSize) ->
          fromIntegral
            @ Word64
            @ b_a51LY
            GHC.Word.$fIntegralWord64
            $dNum_a51M0
            (ds_d54kl
             `cast` (Foreign.C.Types.N:CSize[0]
                     :: (CSize :: *) ~R# (Word64 :: *)))
"fromIntegral/CWchar->a"
    forall (@ b_a51Mf)
           ($dIntegral_a51Mg :: Integral CWchar)
           ($dNum_a51Mh :: Num b_a51Mf).
      fromIntegral @ CWchar @ b_a51Mf $dIntegral_a51Mg $dNum_a51Mh
      = \ (ds_d54kp :: CWchar) ->
          fromIntegral
            @ Int32
            @ b_a51Mf
            GHC.Int.$fIntegralInt32
            $dNum_a51Mh
            (ds_d54kp
             `cast` (Foreign.C.Types.N:CWchar[0]
                     :: (CWchar :: *) ~R# (Int32 :: *)))
"fromIntegral/CSigAtomic->a"
    forall (@ b_a51Mw)
           ($dIntegral_a51Mx :: Integral CSigAtomic)
           ($dNum_a51My :: Num b_a51Mw).
      fromIntegral @ CSigAtomic @ b_a51Mw $dIntegral_a51Mx $dNum_a51My
      = \ (ds_d54kt :: CSigAtomic) ->
          fromIntegral
            @ Int32
            @ b_a51Mw
            GHC.Int.$fIntegralInt32
            $dNum_a51My
            (ds_d54kt
             `cast` (Foreign.C.Types.N:CSigAtomic[0]
                     :: (CSigAtomic :: *) ~R# (Int32 :: *)))
"realToFrac/a->CFloat"
    forall (@ a_a51MQ)
           ($dReal_a51MO :: Real a_a51MQ)
           ($dFractional_a51MP :: Fractional CFloat).
      realToFrac @ a_a51MQ @ CFloat $dReal_a51MO $dFractional_a51MP
      = (\ (x_a4S4t :: a_a51MQ) ->
           realToFrac
             @ a_a51MQ @ Float $dReal_a51MO GHC.Float.$fFractionalFloat x_a4S4t)
        `cast` (<a_a51MQ>_R ->_R Sym (Foreign.C.Types.N:CFloat[0])
                :: (a_a51MQ -> Float :: *) ~R# (a_a51MQ -> CFloat :: *))
"realToFrac/a->CDouble"
    forall (@ a_a51N7)
           ($dReal_a51N5 :: Real a_a51N7)
           ($dFractional_a51N6 :: Fractional CDouble).
      realToFrac @ a_a51N7 @ CDouble $dReal_a51N5 $dFractional_a51N6
      = (\ (x_a4S4u :: a_a51N7) ->
           realToFrac
             @ a_a51N7
             @ Double
             $dReal_a51N5
             GHC.Float.$fFractionalDouble
             x_a4S4u)
        `cast` (<a_a51N7>_R ->_R Sym (Foreign.C.Types.N:CDouble[0])
                :: (a_a51N7 -> Double :: *) ~R# (a_a51N7 -> CDouble :: *))
"realToFrac/CFloat->a"
    forall (@ b_a51Nl)
           ($dReal_a51Nm :: Real CFloat)
           ($dFractional_a51Nn :: Fractional b_a51Nl).
      realToFrac @ CFloat @ b_a51Nl $dReal_a51Nm $dFractional_a51Nn
      = \ (ds_d54kz :: CFloat) ->
          realToFrac
            @ Float
            @ b_a51Nl
            GHC.Float.$fRealFloat
            $dFractional_a51Nn
            (ds_d54kz
             `cast` (Foreign.C.Types.N:CFloat[0]
                     :: (CFloat :: *) ~R# (Float :: *)))
"realToFrac/CDouble->a"
    forall (@ b_a51NC)
           ($dReal_a51ND :: Real CDouble)
           ($dFractional_a51NE :: Fractional b_a51NC).
      realToFrac @ CDouble @ b_a51NC $dReal_a51ND $dFractional_a51NE
      = \ (ds_d54kD :: CDouble) ->
          realToFrac
            @ Double
            @ b_a51NC
            GHC.Float.$fRealDouble
            $dFractional_a51NE
            (ds_d54kD
             `cast` (Foreign.C.Types.N:CDouble[0]
                     :: (CDouble :: *) ~R# (Double :: *)))
"fromIntegral/a->CChar"
    forall (@ a_a51NW)
           ($dIntegral_a51NU :: Integral a_a51NW)
           ($dNum_a51NV :: Num CChar).
      fromIntegral @ a_a51NW @ CChar $dIntegral_a51NU $dNum_a51NV
      = (\ (x_a4S4x :: a_a51NW) ->
           fromIntegral
             @ a_a51NW @ Int8 $dIntegral_a51NU GHC.Int.$fNumInt8 x_a4S4x)
        `cast` (<a_a51NW>_R ->_R Sym (Foreign.C.Types.N:CChar[0])
                :: (a_a51NW -> Int8 :: *) ~R# (a_a51NW -> CChar :: *))
"fromIntegral/a->CSChar"
    forall (@ a_a51Od)
           ($dIntegral_a51Ob :: Integral a_a51Od)
           ($dNum_a51Oc :: Num CSChar).
      fromIntegral @ a_a51Od @ CSChar $dIntegral_a51Ob $dNum_a51Oc
      = (\ (x_a4S4y :: a_a51Od) ->
           fromIntegral
             @ a_a51Od @ Int8 $dIntegral_a51Ob GHC.Int.$fNumInt8 x_a4S4y)
        `cast` (<a_a51Od>_R ->_R Sym (Foreign.C.Types.N:CSChar[0])
                :: (a_a51Od -> Int8 :: *) ~R# (a_a51Od -> CSChar :: *))
"fromIntegral/a->CUChar"
    forall (@ a_a51Ou)
           ($dIntegral_a51Os :: Integral a_a51Ou)
           ($dNum_a51Ot :: Num CUChar).
      fromIntegral @ a_a51Ou @ CUChar $dIntegral_a51Os $dNum_a51Ot
      = (\ (x_a4S4z :: a_a51Ou) ->
           fromIntegral
             @ a_a51Ou @ Word8 $dIntegral_a51Os GHC.Word.$fNumWord8 x_a4S4z)
        `cast` (<a_a51Ou>_R ->_R Sym (Foreign.C.Types.N:CUChar[0])
                :: (a_a51Ou -> Word8 :: *) ~R# (a_a51Ou -> CUChar :: *))
"fromIntegral/a->CShort"
    forall (@ a_a51OL)
           ($dIntegral_a51OJ :: Integral a_a51OL)
           ($dNum_a51OK :: Num CShort).
      fromIntegral @ a_a51OL @ CShort $dIntegral_a51OJ $dNum_a51OK
      = (\ (x_a4S4A :: a_a51OL) ->
           fromIntegral
             @ a_a51OL @ Int16 $dIntegral_a51OJ GHC.Int.$fNumInt16 x_a4S4A)
        `cast` (<a_a51OL>_R ->_R Sym (Foreign.C.Types.N:CShort[0])
                :: (a_a51OL -> Int16 :: *) ~R# (a_a51OL -> CShort :: *))
"fromIntegral/a->CUShort"
    forall (@ a_a51P2)
           ($dIntegral_a51P0 :: Integral a_a51P2)
           ($dNum_a51P1 :: Num CUShort).
      fromIntegral @ a_a51P2 @ CUShort $dIntegral_a51P0 $dNum_a51P1
      = (\ (x_a4S4B :: a_a51P2) ->
           fromIntegral
             @ a_a51P2 @ Word16 $dIntegral_a51P0 GHC.Word.$fNumWord16 x_a4S4B)
        `cast` (<a_a51P2>_R ->_R Sym (Foreign.C.Types.N:CUShort[0])
                :: (a_a51P2 -> Word16 :: *) ~R# (a_a51P2 -> CUShort :: *))
"fromIntegral/a->CInt"
    forall (@ a_a51Pj)
           ($dIntegral_a51Ph :: Integral a_a51Pj)
           ($dNum_a51Pi :: Num CInt).
      fromIntegral @ a_a51Pj @ CInt $dIntegral_a51Ph $dNum_a51Pi
      = (\ (x_a4S4C :: a_a51Pj) ->
           fromIntegral
             @ a_a51Pj @ Int32 $dIntegral_a51Ph GHC.Int.$fNumInt32 x_a4S4C)
        `cast` (<a_a51Pj>_R ->_R Sym (Foreign.C.Types.N:CInt[0])
                :: (a_a51Pj -> Int32 :: *) ~R# (a_a51Pj -> CInt :: *))
"fromIntegral/a->CUInt"
    forall (@ a_a51PA)
           ($dIntegral_a51Py :: Integral a_a51PA)
           ($dNum_a51Pz :: Num CUInt).
      fromIntegral @ a_a51PA @ CUInt $dIntegral_a51Py $dNum_a51Pz
      = (\ (x_a4S4D :: a_a51PA) ->
           fromIntegral
             @ a_a51PA @ Word32 $dIntegral_a51Py GHC.Word.$fNumWord32 x_a4S4D)
        `cast` (<a_a51PA>_R ->_R Sym (Foreign.C.Types.N:CUInt[0])
                :: (a_a51PA -> Word32 :: *) ~R# (a_a51PA -> CUInt :: *))
"fromIntegral/a->CLong"
    forall (@ a_a51PR)
           ($dIntegral_a51PP :: Integral a_a51PR)
           ($dNum_a51PQ :: Num CLong).
      fromIntegral @ a_a51PR @ CLong $dIntegral_a51PP $dNum_a51PQ
      = (\ (x_a4S4E :: a_a51PR) ->
           fromIntegral
             @ a_a51PR @ Int64 $dIntegral_a51PP GHC.Int.$fNumInt64 x_a4S4E)
        `cast` (<a_a51PR>_R ->_R Sym (Foreign.C.Types.N:CLong[0])
                :: (a_a51PR -> Int64 :: *) ~R# (a_a51PR -> CLong :: *))
"fromIntegral/a->CULong"
    forall (@ a_a51Q8)
           ($dIntegral_a51Q6 :: Integral a_a51Q8)
           ($dNum_a51Q7 :: Num CULong).
      fromIntegral @ a_a51Q8 @ CULong $dIntegral_a51Q6 $dNum_a51Q7
      = (\ (x_a4S4F :: a_a51Q8) ->
           fromIntegral
             @ a_a51Q8 @ Word64 $dIntegral_a51Q6 GHC.Word.$fNumWord64 x_a4S4F)
        `cast` (<a_a51Q8>_R ->_R Sym (Foreign.C.Types.N:CULong[0])
                :: (a_a51Q8 -> Word64 :: *) ~R# (a_a51Q8 -> CULong :: *))
"fromIntegral/a->CLLong"
    forall (@ a_a51Qp)
           ($dIntegral_a51Qn :: Integral a_a51Qp)
           ($dNum_a51Qo :: Num CLLong).
      fromIntegral @ a_a51Qp @ CLLong $dIntegral_a51Qn $dNum_a51Qo
      = (\ (x_a4S4G :: a_a51Qp) ->
           fromIntegral
             @ a_a51Qp @ Int64 $dIntegral_a51Qn GHC.Int.$fNumInt64 x_a4S4G)
        `cast` (<a_a51Qp>_R ->_R Sym (Foreign.C.Types.N:CLLong[0])
                :: (a_a51Qp -> Int64 :: *) ~R# (a_a51Qp -> CLLong :: *))
"fromIntegral/a->CULLong"
    forall (@ a_a51QG)
           ($dIntegral_a51QE :: Integral a_a51QG)
           ($dNum_a51QF :: Num CULLong).
      fromIntegral @ a_a51QG @ CULLong $dIntegral_a51QE $dNum_a51QF
      = (\ (x_a4S4H :: a_a51QG) ->
           fromIntegral
             @ a_a51QG @ Word64 $dIntegral_a51QE GHC.Word.$fNumWord64 x_a4S4H)
        `cast` (<a_a51QG>_R ->_R Sym (Foreign.C.Types.N:CULLong[0])
                :: (a_a51QG -> Word64 :: *) ~R# (a_a51QG -> CULLong :: *))
"fromIntegral/CChar->a"
    forall (@ b_a51QU)
           ($dIntegral_a51QV :: Integral CChar)
           ($dNum_a51QW :: Num b_a51QU).
      fromIntegral @ CChar @ b_a51QU $dIntegral_a51QV $dNum_a51QW
      = \ (ds_d54kS :: CChar) ->
          fromIntegral
            @ Int8
            @ b_a51QU
            GHC.Int.$fIntegralInt8
            $dNum_a51QW
            (ds_d54kS
             `cast` (Foreign.C.Types.N:CChar[0]
                     :: (CChar :: *) ~R# (Int8 :: *)))
"fromIntegral/CSChar->a"
    forall (@ b_a51Rb)
           ($dIntegral_a51Rc :: Integral CSChar)
           ($dNum_a51Rd :: Num b_a51Rb).
      fromIntegral @ CSChar @ b_a51Rb $dIntegral_a51Rc $dNum_a51Rd
      = \ (ds_d54kW :: CSChar) ->
          fromIntegral
            @ Int8
            @ b_a51Rb
            GHC.Int.$fIntegralInt8
            $dNum_a51Rd
            (ds_d54kW
             `cast` (Foreign.C.Types.N:CSChar[0]
                     :: (CSChar :: *) ~R# (Int8 :: *)))
"fromIntegral/CUChar->a"
    forall (@ b_a51Rs)
           ($dIntegral_a51Rt :: Integral CUChar)
           ($dNum_a51Ru :: Num b_a51Rs).
      fromIntegral @ CUChar @ b_a51Rs $dIntegral_a51Rt $dNum_a51Ru
      = \ (ds_d54l0 :: CUChar) ->
          fromIntegral
            @ Word8
            @ b_a51Rs
            GHC.Word.$fIntegralWord8
            $dNum_a51Ru
            (ds_d54l0
             `cast` (Foreign.C.Types.N:CUChar[0]
                     :: (CUChar :: *) ~R# (Word8 :: *)))
"fromIntegral/CShort->a"
    forall (@ b_a51RJ)
           ($dIntegral_a51RK :: Integral CShort)
           ($dNum_a51RL :: Num b_a51RJ).
      fromIntegral @ CShort @ b_a51RJ $dIntegral_a51RK $dNum_a51RL
      = \ (ds_d54l4 :: CShort) ->
          fromIntegral
            @ Int16
            @ b_a51RJ
            GHC.Int.$fIntegralInt16
            $dNum_a51RL
            (ds_d54l4
             `cast` (Foreign.C.Types.N:CShort[0]
                     :: (CShort :: *) ~R# (Int16 :: *)))
"fromIntegral/CUShort->a"
    forall (@ b_a51S0)
           ($dIntegral_a51S1 :: Integral CUShort)
           ($dNum_a51S2 :: Num b_a51S0).
      fromIntegral @ CUShort @ b_a51S0 $dIntegral_a51S1 $dNum_a51S2
      = \ (ds_d54l8 :: CUShort) ->
          fromIntegral
            @ Word16
            @ b_a51S0
            GHC.Word.$fIntegralWord16
            $dNum_a51S2
            (ds_d54l8
             `cast` (Foreign.C.Types.N:CUShort[0]
                     :: (CUShort :: *) ~R# (Word16 :: *)))
"fromIntegral/CInt->a"
    forall (@ b_a51Sh)
           ($dIntegral_a51Si :: Integral CInt)
           ($dNum_a51Sj :: Num b_a51Sh).
      fromIntegral @ CInt @ b_a51Sh $dIntegral_a51Si $dNum_a51Sj
      = \ (ds_d54lc :: CInt) ->
          fromIntegral
            @ Int32
            @ b_a51Sh
            GHC.Int.$fIntegralInt32
            $dNum_a51Sj
            (ds_d54lc
             `cast` (Foreign.C.Types.N:CInt[0] :: (CInt :: *) ~R# (Int32 :: *)))
"fromIntegral/CUInt->a"
    forall (@ b_a51Sy)
           ($dIntegral_a51Sz :: Integral CUInt)
           ($dNum_a51SA :: Num b_a51Sy).
      fromIntegral @ CUInt @ b_a51Sy $dIntegral_a51Sz $dNum_a51SA
      = \ (ds_d54lg :: CUInt) ->
          fromIntegral
            @ Word32
            @ b_a51Sy
            GHC.Word.$fIntegralWord32
            $dNum_a51SA
            (ds_d54lg
             `cast` (Foreign.C.Types.N:CUInt[0]
                     :: (CUInt :: *) ~R# (Word32 :: *)))
"fromIntegral/CLong->a"
    forall (@ b_a51SP)
           ($dIntegral_a51SQ :: Integral CLong)
           ($dNum_a51SR :: Num b_a51SP).
      fromIntegral @ CLong @ b_a51SP $dIntegral_a51SQ $dNum_a51SR
      = \ (ds_d54lk :: CLong) ->
          fromIntegral
            @ Int64
            @ b_a51SP
            GHC.Int.$fIntegralInt64
            $dNum_a51SR
            (ds_d54lk
             `cast` (Foreign.C.Types.N:CLong[0]
                     :: (CLong :: *) ~R# (Int64 :: *)))
"fromIntegral/CULong->a"
    forall (@ b_a51T6)
           ($dIntegral_a51T7 :: Integral CULong)
           ($dNum_a51T8 :: Num b_a51T6).
      fromIntegral @ CULong @ b_a51T6 $dIntegral_a51T7 $dNum_a51T8
      = \ (ds_d54lo :: CULong) ->
          fromIntegral
            @ Word64
            @ b_a51T6
            GHC.Word.$fIntegralWord64
            $dNum_a51T8
            (ds_d54lo
             `cast` (Foreign.C.Types.N:CULong[0]
                     :: (CULong :: *) ~R# (Word64 :: *)))
"fromIntegral/CLLong->a"
    forall (@ b_a51Tn)
           ($dIntegral_a51To :: Integral CLLong)
           ($dNum_a51Tp :: Num b_a51Tn).
      fromIntegral @ CLLong @ b_a51Tn $dIntegral_a51To $dNum_a51Tp
      = \ (ds_d54ls :: CLLong) ->
          fromIntegral
            @ Int64
            @ b_a51Tn
            GHC.Int.$fIntegralInt64
            $dNum_a51Tp
            (ds_d54ls
             `cast` (Foreign.C.Types.N:CLLong[0]
                     :: (CLLong :: *) ~R# (Int64 :: *)))
"fromIntegral/CULLong->a"
    forall (@ b_a51TE)
           ($dIntegral_a51TF :: Integral CULLong)
           ($dNum_a51TG :: Num b_a51TE).
      fromIntegral @ CULLong @ b_a51TE $dIntegral_a51TF $dNum_a51TG
      = \ (ds_d54lw :: CULLong) ->
          fromIntegral
            @ Word64
            @ b_a51TE
            GHC.Word.$fIntegralWord64
            $dNum_a51TG
            (ds_d54lw
             `cast` (Foreign.C.Types.N:CULLong[0]
                     :: (CULLong :: *) ~R# (Word64 :: *)))
"fromIntegral/CBool->a"
    forall (@ b_a51TV)
           ($dIntegral_a51TW :: Integral CBool)
           ($dNum_a51TX :: Num b_a51TV).
      fromIntegral @ CBool @ b_a51TV $dIntegral_a51TW $dNum_a51TX
      = \ (ds_d54lA :: CBool) ->
          fromIntegral
            @ Word8
            @ b_a51TV
            GHC.Word.$fIntegralWord8
            $dNum_a51TX
            (ds_d54lA
             `cast` (Foreign.C.Types.N:CBool[0]
                     :: (CBool :: *) ~R# (Word8 :: *)))

