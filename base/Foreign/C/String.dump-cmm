
==================== Output Cmm ====================
2018-03-16 16:04:07.451744391 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:04:07.452423526 UTC

[section ""cstring" . Foreign.C.String.$trModule4_bytes" {
     Foreign.C.String.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.453037043 UTC

[section ""data" . Foreign.C.String.$trModule3_closure" {
     Foreign.C.String.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.C.String.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.453643957 UTC

[section ""cstring" . Foreign.C.String.$trModule2_bytes" {
     Foreign.C.String.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,67,46,83,116,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.454185088 UTC

[section ""data" . Foreign.C.String.$trModule1_closure" {
     Foreign.C.String.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.C.String.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.454723426 UTC

[section ""data" . Foreign.C.String.$trModule_closure" {
     Foreign.C.String.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.C.String.$trModule3_closure+1;
         const Foreign.C.String.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.457586883 UTC

[section ""data" . Foreign.C.String.withCStringLen1_closure" {
     Foreign.C.String.withCStringLen1_closure:
         const Foreign.C.String.withCStringLen1_info;
         const 0;
 },
 $wgo_s8YpD_entry() //  [R1, R2]
         { info_tbl: [(c8YBY,
                       label: $wgo_s8YpD_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YBY: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8YBZ; else goto c8YC0;
       c8YBZ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YC0: // global
           I64[Sp - 48] = block_c8YBT_info;
           _s8YpD::P64 = R1;
           _s8Ypc::P64 = P64[R1 + 6];
           _s8Ypl::P64 = P64[R1 + 14];
           _s8YpC::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 40] = _s8Ypc::P64;
           P64[Sp - 32] = _s8Ypl::P64;
           P64[Sp - 24] = _s8YpC::P64;
           P64[Sp - 16] = _s8YpD::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 48;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YBT() //  [R1]
         { info_tbl: [(c8YBT,
                       label: block_c8YBT_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YBT: // global
           I64[Sp] = block_c8YBV_info;
           _s8YpL::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8YpL::P64;
           if (R1 & 7 != 0) goto u8YCz; else goto c8YBW;
       u8YCz: // global
           call _c8YBV(R1) args: 0, res: 0, upd: 0;
       c8YBW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YBV() //  [R1]
         { info_tbl: [(c8YBV,
                       label: block_c8YBV_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YBV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8YC6; else goto c8YC5;
       c8YC6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YC5: // global
           _s8YpN::P64 = P64[R1 + 7];
           _s8YpO::P64 = P64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 40];
           _s8Ypc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8YCb_info;
           R6 = P64[Sp + 16] + 16;
           R5 = P64[Sp + 24];
           R4 = GHC.Types.False_closure+1;
           R3 = _s8YpO::P64;
           R2 = _s8YpN::P64;
           P64[Sp - 8] = Hp - 7;
           P64[Sp] = _s8Ypc::P64;
           Sp = Sp - 8;
           call GHC.Foreign.$wtryFillBufferAndCall_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8YCb() //  [R1]
         { info_tbl: [(c8YCb,
                       label: block_c8YCb_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YCb: // global
           I64[Sp] = block_c8YCd_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8YCA; else goto c8YCf;
       u8YCA: // global
           call _c8YCd(R1) args: 0, res: 0, upd: 0;
       c8YCf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YCd() //  [R1]
         { info_tbl: [(c8YCd,
                       label: block_c8YCd_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YCd: // global
           if (R1 & 7 == 1) goto c8YCp; else goto c8YCv;
       c8YCp: // global
           I64[Sp] = block_c8YCn_info;
           R2 = I64[Sp + 32] << 1;
           R1 = P64[Sp + 24];
           call $wgo_s8YpD_entry(R2, R1) args: 8, res: 8, upd: 8;
       c8YCv: // global
           _s8Yq3::P64 = P64[R1 + 6];
           call MO_Touch(P64[Sp + 8]);
           R1 = _s8Yq3::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8YCn() //  [R1]
         { info_tbl: [(c8YCn,
                       label: block_c8YCn_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YCn: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Yql_entry() //  [R1, R2]
         { info_tbl: [(c8YCB,
                       label: sat_s8Yql_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YCB: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8YCC; else goto c8YCD;
       c8YCC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YCD: // global
           I64[Sp - 32] = block_c8YBt_info;
           R3 = 0;
           _s8Ypl::P64 = R2;
           _s8Ypb::P64 = P64[R1 + 6];
           R2 = _s8Ypb::P64;
           P64[Sp - 24] = _s8Ypb::P64;
           P64[Sp - 16] = P64[R1 + 14];
           P64[Sp - 8] = _s8Ypl::P64;
           Sp = Sp - 32;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8YBt() //  [R1]
         { info_tbl: [(c8YBt,
                       label: block_c8YBt_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YBt: // global
           I64[Sp - 8] = block_c8YBA_info;
           R2 = 4;
           _s8Ypn::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8Ypn::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YBA() //  [R1]
         { info_tbl: [(c8YBA,
                       label: block_c8YBA_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YBA: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c8YCS() args: 0, res: 0, upd: 0;
     }
 },
 _c8YCS() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YCS: // global
           _s8Yqb::P64 = P64[Sp];
           I64[Sp] = block_c8YCV_info;
           R1 = _s8Yqb::P64;
           if (R1 & 7 != 0) goto u8YDk; else goto c8YCX;
       u8YDk: // global
           call _c8YCV(R1) args: 0, res: 0, upd: 0;
       c8YCX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YCV() //  [R1]
         { info_tbl: [(c8YCV,
                       label: block_c8YCV_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YCV: // global
           if (R1 & 7 == 1) goto c8YD3; else goto c8YD8;
       c8YD3: // global
           I64[Sp + 8] = block_c8YBK_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8YD8: // global
           I64[Sp - 8] = block_c8YD6_info;
           _s8Yqg::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8Yqg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8YDl; else goto c8YD9;
       u8YDl: // global
           call _c8YD6(R1) args: 0, res: 0, upd: 0;
       c8YD9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YBK() //  [R1]
         { info_tbl: [(c8YBK,
                       label: block_c8YBK_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YBK: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c8YCJ; else goto c8YCI;
       c8YCJ: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YCI: // global
           I64[Hp - 96] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 88] = R1;
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = Hp - 95;
           P64[Hp - 64] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 56] = I64[Sp + 8];
           _s8Ypn::I64 = I64[Sp + 16];
           I64[Hp - 48] = _s8Ypn::I64;
           I64[Hp - 40] = 0;
           I64[Hp - 32] = _s8Ypn::I64;
           I64[Hp - 24] = $wgo_s8YpD_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = Hp - 79;
           I64[Sp + 16] = block_c8YCN_info;
           R2 = _s8Ypn::I64 + 1;
           R1 = Hp - 22;
           Sp = Sp + 16;
           call $wgo_s8YpD_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YCN() //  [R1]
         { info_tbl: [(c8YCN,
                       label: block_c8YCN_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YCN: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8YD6() //  [R1]
         { info_tbl: [(c8YD6,
                       label: block_c8YD6_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YD6: // global
           _s8Yqc::I64 = I64[Sp + 16];
           _s8Yqg::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8Yqc::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8Yqg::P64;
           I64[Sp + 16] = _s8Yqc::I64 + 1;
           Sp = Sp + 8;
           call _c8YCS() args: 0, res: 0, upd: 0;
     }
 },
 Foreign.C.String.withCStringLen1_entry() //  [R2, R3]
         { info_tbl: [(c8YDn,
                       label: Foreign.C.String.withCStringLen1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YDn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8YDo; else goto c8YDp;
       c8YDo: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.withCStringLen1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8YDp: // global
           I64[Sp - 24] = block_c8YBh_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YBh() //  [R1]
         { info_tbl: [(c8YBh,
                       label: block_c8YBh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YBh: // global
           I64[Sp] = block_c8YBj_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8YDu; else goto c8YBk;
       u8YDu: // global
           call _c8YBj(R1) args: 0, res: 0, upd: 0;
       c8YBk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YBj() //  [R1]
         { info_tbl: [(c8YBj,
                       label: block_c8YBj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YBj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8YDt; else goto c8YDs;
       c8YDt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YDs: // global
           _s8Ypk::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_s8Yql_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8Ypk::P64;
           Sp = Sp + 24;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.463805799 UTC

[section ""data" . Foreign.C.String.withCStringLen_closure" {
     Foreign.C.String.withCStringLen_closure:
         const Foreign.C.String.withCStringLen_info;
         const 0;
 },
 Foreign.C.String.withCStringLen_entry() //  [R2, R3]
         { info_tbl: [(c8YDA,
                       label: Foreign.C.String.withCStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YDA: // global
           R3 = R3;
           R2 = R2;
           call Foreign.C.String.withCStringLen1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.464717672 UTC

[section ""data" . Foreign.C.String.withCString1_closure" {
     Foreign.C.String.withCString1_closure:
         const Foreign.C.String.withCString1_info;
         const 0;
 },
 Foreign.C.String.withCString1_entry() //  [R2, R3]
         { info_tbl: [(c8YDJ,
                       label: Foreign.C.String.withCString1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YDJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8YDK; else goto c8YDL;
       c8YDK: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.withCString1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8YDL: // global
           I64[Sp - 24] = block_c8YDH_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YDH() //  [R1]
         { info_tbl: [(c8YDH,
                       label: block_c8YDH_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YDH: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.465841748 UTC

[section ""data" . Foreign.C.String.withCString_closure" {
     Foreign.C.String.withCString_closure:
         const Foreign.C.String.withCString_info;
         const 0;
 },
 Foreign.C.String.withCString_entry() //  [R2, R3]
         { info_tbl: [(c8YDR,
                       label: Foreign.C.String.withCString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YDR: // global
           R3 = R3;
           R2 = R2;
           call Foreign.C.String.withCString1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.466726073 UTC

[section ""data" . Foreign.C.String.charIsRepresentable1_closure" {
     Foreign.C.String.charIsRepresentable1_closure:
         const Foreign.C.String.charIsRepresentable1_info;
         const 0;
 },
 Foreign.C.String.charIsRepresentable1_entry() //  [R2]
         { info_tbl: [(c8YE0,
                       label: Foreign.C.String.charIsRepresentable1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YE0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8YE1; else goto c8YE2;
       c8YE1: // global
           R2 = R2;
           R1 = Foreign.C.String.charIsRepresentable1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YE2: // global
           I64[Sp - 16] = block_c8YDY_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YDY() //  [R1]
         { info_tbl: [(c8YDY,
                       label: block_c8YDY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YDY: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.467732812 UTC

[section ""data" . Foreign.C.String.charIsRepresentable_closure" {
     Foreign.C.String.charIsRepresentable_closure:
         const Foreign.C.String.charIsRepresentable_info;
         const 0;
 },
 Foreign.C.String.charIsRepresentable_entry() //  [R2]
         { info_tbl: [(c8YE8,
                       label: Foreign.C.String.charIsRepresentable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YE8: // global
           R2 = R2;
           call Foreign.C.String.charIsRepresentable1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.468397763 UTC

[section ""data" . Foreign.C.String.newCStringLen2_closure" {
     Foreign.C.String.newCStringLen2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.472683378 UTC

[section ""data" . Foreign.C.String.newCStringLen1_closure" {
     Foreign.C.String.newCStringLen1_closure:
         const Foreign.C.String.newCStringLen1_info;
         const 0;
 },
 sat_s8Ysq_entry() //  [R1]
         { info_tbl: [(c8YFO,
                       label: sat_s8Ysq_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YFO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8YFT; else goto c8YFU;
       c8YFT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8YFU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c8YFL_info;
           _s8Yrl::P64 = P64[R1 + 24];
           _s8Yra::I64 = I64[R1 + 32];
           R1 = P64[R1 + 16];
           I64[Sp - 32] = _s8Yra::I64;
           P64[Sp - 24] = _s8Yrl::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8YFY; else goto c8YFM;
       u8YFY: // global
           call _c8YFL(R1) args: 0, res: 0, upd: 0;
       c8YFM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8YFL() //  [R1]
         { info_tbl: [(c8YFL,
                       label: block_c8YFL_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YFL: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8YFX; else goto c8YFW;
       c8YFX: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8YFW: // global
           _s8Yso::I64 = I64[R1 + 7];
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 16];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s8Yso::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8YsE_entry() //  [R1, R2]
         { info_tbl: [(c8YFZ,
                       label: sat_s8YsE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YFZ: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8YG0; else goto c8YG1;
       c8YG0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YG1: // global
           I64[Sp - 24] = block_c8YEr_info;
           R3 = 0;
           _s8YqG::P64 = R2;
           _s8Yqx::P64 = P64[R1 + 6];
           R2 = _s8Yqx::P64;
           P64[Sp - 16] = _s8Yqx::P64;
           P64[Sp - 8] = _s8YqG::P64;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8YEr() //  [R1]
         { info_tbl: [(c8YEr,
                       label: block_c8YEr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YEr: // global
           I64[Sp - 8] = block_c8YEy_info;
           R2 = 4;
           _s8YqI::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8YqI::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YEy() //  [R1]
         { info_tbl: [(c8YEy,
                       label: block_c8YEy_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YEy: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c8YHP() args: 0, res: 0, upd: 0;
     }
 },
 _c8YHP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YHP: // global
           _s8Ysu::P64 = P64[Sp];
           I64[Sp] = block_c8YHS_info;
           R1 = _s8Ysu::P64;
           if (R1 & 7 != 0) goto u8YIS; else goto c8YHU;
       u8YIS: // global
           call _c8YHS(R1) args: 0, res: 0, upd: 0;
       c8YHU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YHS() //  [R1]
         { info_tbl: [(c8YHS,
                       label: block_c8YHS_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YHS: // global
           if (R1 & 7 == 1) goto c8YI0; else goto c8YI5;
       c8YI0: // global
           I64[Sp + 8] = block_c8YEI_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8YI5: // global
           I64[Sp - 8] = block_c8YI3_info;
           _s8Ysz::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8Ysz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8YIT; else goto c8YI6;
       u8YIT: // global
           call _c8YI3(R1) args: 0, res: 0, upd: 0;
       c8YI6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YEI() //  [R1]
         { info_tbl: [(c8YEI,
                       label: block_c8YEI_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YEI: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8YG7; else goto c8YG6;
       c8YG7: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YG6: // global
           _s8YqI::I64 = I64[Sp + 16];
           _s8YqQ::I64 = I64[Sp + 8];
           _s8YqW::I64 = _s8YqI::I64 + 1;
           (_s8Yr1::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(_s8YqW::I64);
           if (_s8Yr1::I64 == 0) goto c8YHM; else goto c8YHL;
       c8YHM: // global
           Hp = Hp - 88;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8YHL: // global
           I64[Hp - 80] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 72] = R1;
           I64[Hp - 64] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 40] = _s8YqQ::I64;
           I64[Hp - 32] = _s8YqI::I64;
           I64[Hp - 24] = 0;
           I64[Hp - 16] = _s8YqI::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8YqW::I64;
           P64[Sp] = Hp - 7;
           I64[Sp + 8] = _s8Yr1::I64;
           P64[Sp + 16] = Hp - 63;
           call _c8YF2() args: 0, res: 0, upd: 0;
     }
 },
 _c8YF2() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YF2: // global
           I64[Sp - 8] = block_c8YF5_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8YID; else goto c8YF6;
       u8YID: // global
           call _c8YF5(R1) args: 0, res: 0, upd: 0;
       c8YF6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YF5() //  [R1]
         { info_tbl: [(c8YF5,
                       label: block_c8YF5_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YF5: // global
           I64[Sp - 16] = block_c8YFa_info;
           _s8Yre::P64 = P64[R1 + 7];
           _s8Yrf::P64 = P64[R1 + 15];
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 8] = _s8Yrf::P64;
           P64[Sp] = _s8Yre::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YFa() //  [R1]
         { info_tbl: [(c8YFa,
                       label: block_c8YFa_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YFa: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8YGg; else goto c8YGf;
       c8YGg: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YGf: // global
           I64[Hp - 32] = sat_s8Ysq_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 32];
           P64[Sp - 8] = Hp - 32;
           P64[Sp] = P64[Sp + 40];
           Sp = Sp - 8;
           call _c8YH1() args: 0, res: 0, upd: 0;
     }
 },
 _c8YH1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YH1: // global
           _s8YrY::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8YH3_info;
           R3 = P64[Sp];
           R2 = _s8YrY::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YH3() //  [R1]
         { info_tbl: [(c8YH3,
                       label: block_c8YH3_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YH3: // global
           I64[Sp] = block_c8YH5_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8YIL; else goto c8YH6;
       u8YIL: // global
           call _c8YH5(R1) args: 0, res: 0, upd: 0;
       c8YH6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YH5() //  [R1]
         { info_tbl: [(c8YH5,
                       label: block_c8YH5_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YH5: // global
           I64[Sp - 16] = block_c8YHa_info;
           _s8Ys5::P64 = P64[R1 + 7];
           _s8Ys7::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8Ys7::P64;
           P64[Sp] = _s8Ys5::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8YIM; else goto c8YHe;
       u8YIM: // global
           call _c8YHa(R1) args: 0, res: 0, upd: 0;
       c8YHe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YHa() //  [R1]
         { info_tbl: [(c8YHa,
                       label: block_c8YHa_info
                       rep:StackRep [False, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YHa: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8YHJ; else goto c8YHo;
       c8YHJ: // global
           I64[Sp + 32] = block_c8YGP_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8YIO; else goto c8YGR;
       u8YIO: // global
           call _c8YGP(R1) args: 0, res: 0, upd: 0;
       c8YGR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8YHo: // global
           I64[Sp] = block_c8YHm_info;
           _s8Ys8::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8Ys8::P64;
           if (R1 & 7 != 0) goto u8YIN; else goto c8YHp;
       u8YIN: // global
           call _c8YHm(R1) args: 0, res: 0, upd: 0;
       c8YHp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YGP() //  [R1]
         { info_tbl: [(c8YGP,
                       label: block_c8YGP_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YGP: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8YGX; else goto c8YGW;
       c8YGX: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YGW: // global
           _s8YrL::I64 = I64[R1 + 23];
           _s8YrP::I64 = I64[R1 + 39];
           _s8YrQ::I64 = I64[R1 + 47];
           call MO_Touch(P64[R1 + 7]);
           I64[Hp - 64] = GHC.Types.I#_con_info;
           I64[Hp - 56] = _s8YrQ::I64 - _s8YrP::I64;
           I64[Hp - 48] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 40] = _s8YrL::I64;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 63;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           P64[Sp] = Hp - 6;
           call _s8Yrm() args: 0, res: 0, upd: 0;
     }
 },
 _c8YHm() //  [R1]
         { info_tbl: [(c8YHm,
                       label: block_c8YHm_info
                       rep:StackRep [False, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YHm: // global
           if (R1 & 7 == 2) goto c8YHI; else goto c8YHy;
       c8YHI: // global
           P64[Sp + 32] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call _s8Yrm() args: 0, res: 0, upd: 0;
       c8YHy: // global
           _s8Ys8::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8YHt_info;
           R3 = P64[Sp + 8];
           R2 = _s8Ys8::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _s8Yrm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8Yrm: // global
           _s8Yro::P64 = P64[Sp];
           I64[Sp] = block_c8YFj_info;
           R1 = _s8Yro::P64;
           if (R1 & 7 != 0) goto u8YIV; else goto c8YFk;
       u8YIV: // global
           call _c8YFj(R1) args: 0, res: 0, upd: 0;
       c8YFk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YFj() //  [R1]
         { info_tbl: [(c8YFj,
                       label: block_c8YFj_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YFj: // global
           if (R1 & 7 == 1) goto c8YGk; else goto c8YGD;
       c8YGk: // global
           _s8Yrb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8YFo_info;
           R1 = _s8Yrb::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8YIF; else goto c8YFp;
       u8YIF: // global
           call _c8YFo(R1) args: 0, res: 0, upd: 0;
       c8YFp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8YGD: // global
           _s8Yr7::P64 = P64[R1 + 6];
           call MO_Touch(P64[Sp + 32]);
           R1 = _s8Yr7::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8YFo() //  [R1]
         { info_tbl: [(c8YFo,
                       label: block_c8YFo_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YFo: // global
           _s8Yrs::I64 = I64[R1 + 7] << 1;
           if (_s8Yrs::I64 != 0) goto u8YIx; else goto c8YGw;
       u8YIx: // global
           I64[Sp] = _s8Yrs::I64;
           call _c8YFx() args: 0, res: 0, upd: 0;
       c8YGw: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[Sp + 8]);
           I64[Sp + 8] = 0;
           P64[Sp] = Foreign.C.String.newCStringLen2_closure+1;
           call _c8YF2() args: 0, res: 0, upd: 0;
     }
 },
 _c8YFx() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YFx: // global
           Hp = Hp + 16;
           _s8Yrs::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c8YGq; else goto c8YGp;
       c8YGq: // global
           HpAlloc = 16;
           I64[Sp] = block_c8YFw_info;
           R1 = _s8Yrs::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8YGp: // global
           (_s8Yrx::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp + 8], _s8Yrs::I64);
           if (_s8Yrx::I64 == 0) goto c8YGt; else goto c8YGs;
       c8YGt: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8YGs: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8Yrs::I64;
           I64[Sp + 8] = _s8Yrx::I64;
           P64[Sp] = Hp - 7;
           call _c8YF2() args: 0, res: 0, upd: 0;
     }
 },
 _c8YFw() //  [R1]
         { info_tbl: [(c8YFw,
                       label: block_c8YFw_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YFw: // global
           I64[Sp] = R1;
           call _c8YFx() args: 0, res: 0, upd: 0;
     }
 },
 _c8YHt() //  [R1]
         { info_tbl: [(c8YHt,
                       label: block_c8YHt_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YHt: // global
           I64[Sp] = block_c8YHv_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8YIQ; else goto c8YHA;
       u8YIQ: // global
           call _c8YHv(R1) args: 0, res: 0, upd: 0;
       c8YHA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YHv() //  [R1]
         { info_tbl: [(c8YHv,
                       label: block_c8YHv_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YHv: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 8;
           call _c8YH1() args: 0, res: 0, upd: 0;
     }
 },
 _c8YI3() //  [R1]
         { info_tbl: [(c8YI3,
                       label: block_c8YI3_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YI3: // global
           _s8Ysv::I64 = I64[Sp + 16];
           _s8Ysz::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8Ysv::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8Ysz::P64;
           I64[Sp + 16] = _s8Ysv::I64 + 1;
           Sp = Sp + 8;
           call _c8YHP() args: 0, res: 0, upd: 0;
     }
 },
 Foreign.C.String.newCStringLen1_entry() //  [R2]
         { info_tbl: [(c8YIW,
                       label: Foreign.C.String.newCStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YIW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8YIX; else goto c8YIY;
       c8YIX: // global
           R2 = R2;
           R1 = Foreign.C.String.newCStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YIY: // global
           I64[Sp - 16] = block_c8YEf_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YEf() //  [R1]
         { info_tbl: [(c8YEf,
                       label: block_c8YEf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YEf: // global
           I64[Sp] = block_c8YEh_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8YJ3; else goto c8YEi;
       u8YJ3: // global
           call _c8YEh(R1) args: 0, res: 0, upd: 0;
       c8YEi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YEh() //  [R1]
         { info_tbl: [(c8YEh,
                       label: block_c8YEh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YEh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8YJ2; else goto c8YJ1;
       c8YJ2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YJ1: // global
           _s8YqF::P64 = P64[R1 + 23];
           I64[Hp - 8] = sat_s8YsE_info;
           P64[Hp] = P64[Sp + 8];
           R4 = Hp - 6;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8YqF::P64;
           Sp = Sp + 16;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.479905182 UTC

[section ""data" . Foreign.C.String.newCStringLen_closure" {
     Foreign.C.String.newCStringLen_closure:
         const Foreign.C.String.newCStringLen_info;
         const 0;
 },
 Foreign.C.String.newCStringLen_entry() //  [R2]
         { info_tbl: [(c8YJ8,
                       label: Foreign.C.String.newCStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YJ8: // global
           R2 = R2;
           call Foreign.C.String.newCStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.480826869 UTC

[section ""data" . Foreign.C.String.newCString1_closure" {
     Foreign.C.String.newCString1_closure:
         const Foreign.C.String.newCString1_info;
         const 0;
 },
 Foreign.C.String.newCString1_entry() //  [R2]
         { info_tbl: [(c8YJh,
                       label: Foreign.C.String.newCString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YJh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8YJi; else goto c8YJj;
       c8YJi: // global
           R2 = R2;
           R1 = Foreign.C.String.newCString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YJj: // global
           I64[Sp - 16] = block_c8YJf_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YJf() //  [R1]
         { info_tbl: [(c8YJf,
                       label: block_c8YJf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YJf: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.newCString1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.481900787 UTC

[section ""data" . Foreign.C.String.newCString_closure" {
     Foreign.C.String.newCString_closure:
         const Foreign.C.String.newCString_info;
         const 0;
 },
 Foreign.C.String.newCString_entry() //  [R2]
         { info_tbl: [(c8YJp,
                       label: Foreign.C.String.newCString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YJp: // global
           R2 = R2;
           call Foreign.C.String.newCString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.486813696 UTC

[section ""data" . Foreign.C.String.peekCStringLen1_closure" {
     Foreign.C.String.peekCStringLen1_closure:
         const Foreign.C.String.peekCStringLen1_info;
         const 0;
 },
 sat_s8Yu1_entry() //  [R1]
         { info_tbl: [(c8YLJ,
                       label: sat_s8Yu1_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YLJ: // global
           _s8Yu1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8YLK; else goto c8YLL;
       c8YLL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8YLN; else goto c8YLM;
       c8YLN: // global
           HpAlloc = 40;
           goto c8YLK;
       c8YLK: // global
           R1 = _s8Yu1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8YLM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Yu1::P64;
           _s8YtQ::P64 = P64[_s8Yu1::P64 + 16];
           _s8YtY::P64 = P64[_s8Yu1::P64 + 24];
           _s8YtU::I64 = I64[_s8Yu1::P64 + 32];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8YtU::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YtQ::P64;
           R3 = _s8YtY::P64;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Yui_entry() //  [R1]
         { info_tbl: [(c8YLW,
                       label: sat_s8Yui_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YLW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8YLX; else goto c8YLY;
       c8YLX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8YLY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 $wgo_s8Yti_entry() //  [R1, R2]
         { info_tbl: [(c8YLZ,
                       label: $wgo_s8Yti_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YLZ: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8YM0; else goto c8YM1;
       c8YM0: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YM1: // global
           I64[Sp - 32] = block_c8YKo_info;
           _s8Yti::P64 = R1;
           _s8Yth::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 24] = _s8Yth::P64;
           P64[Sp - 16] = _s8Yti::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8YNB; else goto c8YKp;
       u8YNB: // global
           call _c8YKo(R1) args: 0, res: 0, upd: 0;
       c8YKp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YKo() //  [R1]
         { info_tbl: [(c8YKo,
                       label: block_c8YKo_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YKo: // global
           _s8Yth::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8YKt_info;
           R3 = _s8Yth::P64;
           R2 = P64[Sp + 24];
           _s8Ytn::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 24] = _s8Ytn::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YKt() //  [R1]
         { info_tbl: [(c8YKt,
                       label: block_c8YKt_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YKt: // global
           I64[Sp] = block_c8YKv_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8YNt; else goto c8YKw;
       u8YNt: // global
           call _c8YKv(R1) args: 0, res: 0, upd: 0;
       c8YKw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YKv() //  [R1]
         { info_tbl: [(c8YKv,
                       label: block_c8YKv_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YKv: // global
           I64[Sp - 16] = block_c8YKA_info;
           _s8Ytv::P64 = P64[R1 + 7];
           _s8Ytx::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8Ytx::P64;
           P64[Sp] = _s8Ytv::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8YNu; else goto c8YKB;
       u8YNu: // global
           call _c8YKA(R1) args: 0, res: 0, upd: 0;
       c8YKB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YKA() //  [R1]
         { info_tbl: [(c8YKA,
                       label: block_c8YKA_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YKA: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8YMW; else goto c8YMp;
       c8YMW: // global
           I64[Sp + 32] = block_c8YL8_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8YNw; else goto c8YL9;
       u8YNw: // global
           call _c8YL8(R1) args: 0, res: 0, upd: 0;
       c8YL9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8YMp: // global
           I64[Sp] = block_c8YM6_info;
           _s8Yty::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8Yty::P64;
           if (R1 & 7 != 0) goto u8YNv; else goto c8YMq;
       u8YNv: // global
           call _c8YM6(R1) args: 0, res: 0, upd: 0;
       c8YMq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YL8() //  [R1]
         { info_tbl: [(c8YL8,
                       label: block_c8YL8_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YL8: // global
           _s8YuG::P64 = P64[R1 + 7];
           _s8YuL::I64 = I64[R1 + 47] - I64[R1 + 39];
           if (%MO_S_Gt_W64(_s8YuL::I64, 0)) goto c8YNe; else goto c8YNf;
       c8YNe: // global
           P64[Sp - 24] = _s8YuG::P64;
           I64[Sp - 16] = _s8YuL::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 32;
           call _c8YLq() args: 0, res: 0, upd: 0;
       c8YNf: // global
           call MO_Touch(_s8YuG::P64);
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8YLq() //  []
         { info_tbl: [(c8YLq,
                       label: block_c8YLq_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YLq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8YN9; else goto c8YN8;
       c8YN9: // global
           HpAlloc = 40;
           I64[Sp] = block_c8YLq_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8YN8: // global
           _s8YuY::P64 = P64[Sp + 24];
           _s8Yv0::I64 = I64[Sp + 16];
           if (_s8Yv0::I64 != 0) goto c8YNb; else goto c8YNc;
       c8YNb: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 32] + (_s8Yv0::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YuY::P64;
           I64[Sp + 16] = _s8Yv0::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           call _c8YLq() args: 0, res: 0, upd: 0;
       c8YNc: // global
           Hp = Hp - 40;
           P64[Sp + 24] = _s8YuY::P64;
           Sp = Sp + 8;
           call _c8YMZ() args: 0, res: 0, upd: 0;
     }
 },
 _c8YMZ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YMZ: // global
           Hp = Hp + 40;
           _s8YuO::P64 = P64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c8YN6; else goto c8YN5;
       c8YN6: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_c8YMY_info;
           R1 = _s8YuO::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YN5: // global
           _s8YuS::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 24]]);
           call MO_Touch(P64[Sp]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8YuS::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YuO::P64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8YMY() //  [R1]
         { info_tbl: [(c8YMY,
                       label: block_c8YMY_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YMY: // global
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c8YMZ() args: 0, res: 0, upd: 0;
     }
 },
 _c8YM6() //  [R1]
         { info_tbl: [(c8YM6,
                       label: block_c8YM6_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YM6: // global
           _s8Ytx::P64 = P64[Sp + 8];
           if (R1 & 7 == 2) goto c8YMQ; else goto c8YME;
       c8YMQ: // global
           I64[Sp + 8] = block_c8YMO_info;
           R1 = _s8Ytx::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8YNC; else goto c8YMR;
       u8YNC: // global
           call _c8YMO(R1) args: 0, res: 0, upd: 0;
       c8YMR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8YME: // global
           _s8Yty::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8YMu_info;
           R3 = _s8Ytx::P64;
           R2 = _s8Yty::P64;
           R1 = P64[Sp + 32];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YMO() //  [R1]
         { info_tbl: [(c8YMO,
                       label: block_c8YMO_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YMO: // global
           P64[Sp + 24] = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 23];
           P64[Sp - 16] = P64[R1 + 7];
           I64[Sp - 8] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           Sp = Sp - 16;
           call _s8YtG() args: 0, res: 0, upd: 0;
     }
 },
 _c8YMu() //  [R1]
         { info_tbl: [(c8YMu,
                       label: block_c8YMu_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YMu: // global
           I64[Sp] = block_c8YMw_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8YND; else goto c8YMx;
       u8YND: // global
           call _c8YMw(R1) args: 0, res: 0, upd: 0;
       c8YMx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YMw() //  [R1]
         { info_tbl: [(c8YMw,
                       label: block_c8YMw_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YMw: // global
           I64[Sp] = block_c8YMB_info;
           _s8Yuo::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 16] = _s8Yuo::P64;
           if (R1 & 7 != 0) goto u8YNE; else goto c8YMH;
       u8YNE: // global
           call _c8YMB(R1) args: 0, res: 0, upd: 0;
       c8YMH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YMB() //  [R1]
         { info_tbl: [(c8YMB,
                       label: block_c8YMB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YMB: // global
           P64[Sp - 24] = P64[R1 + 7];
           I64[Sp - 16] = I64[R1 + 39];
           I64[Sp - 8] = I64[R1 + 47];
           I64[Sp] = I64[R1 + 23];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp - 24;
           call _s8YtG() args: 0, res: 0, upd: 0;
     }
 },
 _s8YtG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8YtG: // global
           _s8YtN::I64 = I64[Sp + 16] - I64[Sp + 8];
           if (%MO_S_Gt_W64(_s8YtN::I64, 0)) goto c8YMj; else goto c8YMk;
       c8YMj: // global
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           I64[Sp + 16] = _s8YtN::I64 - 1;
           Sp = Sp - 8;
           call _c8YL0() args: 0, res: 0, upd: 0;
       c8YMk: // global
           _s8Yti::P64 = P64[Sp + 32];
           _s8YtI::P64 = P64[Sp + 40];
           call MO_Touch(P64[Sp]);
           I64[Sp + 40] = block_c8YLQ_info;
           R2 = _s8YtI::P64;
           R1 = _s8Yti::P64;
           Sp = Sp + 40;
           call $wgo_s8Yti_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YL0() //  []
         { info_tbl: [(c8YL0,
                       label: block_c8YL0_info
                       rep:StackRep [False, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YL0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8YMe; else goto c8YMd;
       c8YMe: // global
           HpAlloc = 40;
           I64[Sp] = block_c8YL0_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8YMd: // global
           _s8YtJ::I64 = I64[Sp + 32];
           _s8Yu4::P64 = P64[Sp + 16];
           _s8Yu6::I64 = I64[Sp + 24];
           if (_s8Yu6::I64 != 0) goto c8YMg; else goto c8YMh;
       c8YMg: // global
           _s8Yu9::I64 = %MO_UU_Conv_W32_W64(I32[_s8YtJ::I64 + (_s8Yu6::I64 << 2)]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8Yu9::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8Yu4::P64;
           I64[Sp + 24] = _s8Yu6::I64 - 1;
           P64[Sp + 16] = Hp - 14;
           call _c8YL0() args: 0, res: 0, upd: 0;
       c8YMh: // global
           Hp = Hp - 40;
           _s8Yti::P64 = P64[Sp + 40];
           _s8YtI::P64 = P64[Sp + 48];
           _s8YtU::I64 = %MO_UU_Conv_W32_W64(I32[_s8YtJ::I64]);
           call MO_Touch(P64[Sp + 8]);
           I64[Sp + 32] = block_c8YLB_info;
           R2 = _s8YtI::P64;
           R1 = _s8Yti::P64;
           I64[Sp + 40] = _s8YtU::I64;
           P64[Sp + 48] = _s8Yu4::P64;
           Sp = Sp + 32;
           call $wgo_s8Yti_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YLB() //  [R1]
         { info_tbl: [(c8YLB,
                       label: block_c8YLB_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YLB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8YMb; else goto c8YMa;
       c8YMb: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YMa: // global
           I64[Hp - 32] = sat_s8Yu1_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8YLQ() //  [R1]
         { info_tbl: [(c8YLQ,
                       label: block_c8YLQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YLQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8YMn; else goto c8YMm;
       c8YMn: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YMm: // global
           I64[Hp - 16] = sat_s8Yui_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Yvd_entry() //  [R1, R2]
         { info_tbl: [(c8YNJ,
                       label: sat_s8Yvd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YNJ: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8YNK; else goto c8YNL;
       c8YNK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YNL: // global
           I64[Sp - 24] = block_c8YJN_info;
           _s8YsV::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 16] = _s8YsV::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8YO5; else goto c8YJO;
       u8YO5: // global
           call _c8YJN(R1) args: 0, res: 0, upd: 0;
       c8YJO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YJN() //  [R1]
         { info_tbl: [(c8YJN,
                       label: block_c8YJN_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YJN: // global
           I64[Sp - 8] = block_c8YJS_info;
           _s8YsZ::I64 = I64[R1 + 7];
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp] = _s8YsZ::I64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YJS() //  [R1]
         { info_tbl: [(c8YJS,
                       label: block_c8YJS_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YJS: // global
           I64[Sp] = block_c8YJU_info;
           _s8Yt2::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8Yt2::P64;
           if (R1 & 7 != 0) goto u8YO4; else goto c8YJV;
       u8YO4: // global
           call _c8YJU(R1) args: 0, res: 0, upd: 0;
       c8YJV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YJU() //  [R1]
         { info_tbl: [(c8YJU,
                       label: block_c8YJU_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YJU: // global
           _s8Yt4::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s8Yt4::I64, 1)) goto c8YO2; else goto c8YO3;
       c8YO2: // global
           _s8Yt6::I64 = _s8Yt4::I64;
           goto s8Yt5;
       c8YO3: // global
           _s8Yt6::I64 = 1;
           goto s8Yt5;
       s8Yt5: // global
           _s8Yt7::I64 = _s8Yt6::I64 << 2;
           if (%MO_S_Ge_W64(_s8Yt7::I64, 0)) goto c8YNT; else goto c8YNY;
       c8YNT: // global
           I64[Sp - 24] = block_c8YKa_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = _s8Yt6::I64;
           I64[Sp - 8] = _s8Yt7::I64;
           I64[Sp] = _s8Yt4::I64;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8YNY: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8YKa() //  [R1]
         { info_tbl: [(c8YKa,
                       label: block_c8YKa_info
                       rep:StackRep [True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YKa: // global
           I64[Sp] = block_c8YKc_info;
           _s8Ytb::P64 = R1;
           R1 = I64[Sp + 16];
           P64[Sp + 16] = _s8Ytb::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YKc() //  [R1]
         { info_tbl: [(c8YKc,
                       label: block_c8YKc_info
                       rep:StackRep [True, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YKc: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto c8YNX; else goto c8YNW;
       c8YNX: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YNW: // global
           I64[Hp - 168] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 160] = R1;
           P64[Hp - 152] = P64[Sp + 16];
           I64[Hp - 144] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 136] = Hp - 166;
           P64[Hp - 128] = GHC.IO.Buffer.WriteBuffer_closure+2;
           P64[Hp - 120] = R1 + 16;
           I64[Hp - 112] = I64[Sp + 8];
           I64[Hp - 104] = 0;
           I64[Hp - 96] = 0;
           I64[Hp - 88] = $wgo_s8Yti_info;
           P64[Hp - 80] = P64[Sp + 48];
           P64[Hp - 72] = Hp - 143;
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 40];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = I64[Sp + 32];
           _s8Yt4::I64 = I64[Sp + 24];
           I64[Hp - 16] = _s8Yt4::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _s8Yt4::I64;
           R2 = Hp - 47;
           R1 = Hp - 86;
           Sp = Sp + 56;
           call $wgo_s8Yti_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.C.String.peekCStringLen1_entry() //  [R2]
         { info_tbl: [(c8YO6,
                       label: Foreign.C.String.peekCStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YO6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8YO7; else goto c8YO8;
       c8YO7: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YO8: // global
           I64[Sp - 16] = block_c8YJw_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YJw() //  [R1]
         { info_tbl: [(c8YJw,
                       label: block_c8YJw_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YJw: // global
           I64[Sp] = block_c8YJy_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8YOe; else goto c8YJz;
       u8YOe: // global
           call _c8YJy(R1) args: 0, res: 0, upd: 0;
       c8YJz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YJy() //  [R1]
         { info_tbl: [(c8YJy,
                       label: block_c8YJy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YJy: // global
           I64[Sp] = block_c8YJD_info;
           _s8YsR::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8YsR::P64;
           if (R1 & 7 != 0) goto u8YOf; else goto c8YJE;
       u8YOf: // global
           call _c8YJD(R1) args: 0, res: 0, upd: 0;
       c8YJE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YJD() //  [R1]
         { info_tbl: [(c8YJD,
                       label: block_c8YJD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YJD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8YOd; else goto c8YOc;
       c8YOd: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YOc: // global
           _s8YsU::P64 = P64[R1 + 7];
           _s8YsV::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_s8Yvd_info;
           P64[Hp - 8] = _s8YsU::P64;
           P64[Hp] = _s8YsV::P64;
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.495094028 UTC

[section ""data" . Foreign.C.String.peekCStringLen_closure" {
     Foreign.C.String.peekCStringLen_closure:
         const Foreign.C.String.peekCStringLen_info;
         const 0;
 },
 Foreign.C.String.peekCStringLen_entry() //  [R2]
         { info_tbl: [(c8YOk,
                       label: Foreign.C.String.peekCStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YOk: // global
           R2 = R2;
           call Foreign.C.String.peekCStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.495954342 UTC

[section ""data" . Foreign.C.String.peekCString1_closure" {
     Foreign.C.String.peekCString1_closure:
         const Foreign.C.String.peekCString1_info;
         const 0;
 },
 Foreign.C.String.peekCString1_entry() //  [R2]
         { info_tbl: [(c8YOt,
                       label: Foreign.C.String.peekCString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YOt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8YOu; else goto c8YOv;
       c8YOu: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YOv: // global
           I64[Sp - 16] = block_c8YOr_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YOr() //  [R1]
         { info_tbl: [(c8YOr,
                       label: block_c8YOr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YOr: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.peekCString1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.496988003 UTC

[section ""data" . Foreign.C.String.peekCString_closure" {
     Foreign.C.String.peekCString_closure:
         const Foreign.C.String.peekCString_info;
         const 0;
 },
 Foreign.C.String.peekCString_entry() //  [R2]
         { info_tbl: [(c8YOB,
                       label: Foreign.C.String.peekCString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YOB: // global
           R2 = R2;
           call Foreign.C.String.peekCString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.498105273 UTC

[section ""data" . Foreign.C.String.castCSCharToChar_closure" {
     Foreign.C.String.castCSCharToChar_closure:
         const Foreign.C.String.castCSCharToChar_info;
 },
 Foreign.C.String.castCSCharToChar_entry() //  [R2]
         { info_tbl: [(c8YOL,
                       label: Foreign.C.String.castCSCharToChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YOL: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8YP1; else goto c8YP2;
       c8YP1: // global
           R2 = R2;
           R1 = Foreign.C.String.castCSCharToChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YP2: // global
           I64[Sp - 8] = block_c8YOI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8YP6; else goto c8YOJ;
       u8YP6: // global
           call _c8YOI(R1) args: 0, res: 0, upd: 0;
       c8YOJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YOI() //  [R1]
         { info_tbl: [(c8YOI,
                       label: block_c8YOI_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YOI: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8YP5; else goto c8YP4;
       c8YP5: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YP4: // global
           _s8Yvp::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s8Yvp::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.499421311 UTC

[section ""data" . Foreign.C.String.castCUCharToChar_closure" {
     Foreign.C.String.castCUCharToChar_closure:
         const Foreign.C.String.castCUCharToChar_info;
 },
 Foreign.C.String.castCUCharToChar_entry() //  [R2]
         { info_tbl: [(c8YPe,
                       label: Foreign.C.String.castCUCharToChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YPe: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8YPo; else goto c8YPp;
       c8YPo: // global
           R2 = R2;
           R1 = Foreign.C.String.castCUCharToChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YPp: // global
           I64[Sp - 8] = block_c8YPb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8YPt; else goto c8YPc;
       u8YPt: // global
           call _c8YPb(R1) args: 0, res: 0, upd: 0;
       c8YPc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YPb() //  [R1]
         { info_tbl: [(c8YPb,
                       label: block_c8YPb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YPb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8YPs; else goto c8YPr;
       c8YPs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YPr: // global
           _s8Yvu::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s8Yvu::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.500716551 UTC

[section ""data" . Foreign.C.String.castCCharToChar_closure" {
     Foreign.C.String.castCCharToChar_closure:
         const Foreign.C.String.castCCharToChar_info;
 },
 Foreign.C.String.castCCharToChar_entry() //  [R2]
         { info_tbl: [(c8YPB,
                       label: Foreign.C.String.castCCharToChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YPB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8YPR; else goto c8YPS;
       c8YPR: // global
           R2 = R2;
           R1 = Foreign.C.String.castCCharToChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YPS: // global
           I64[Sp - 8] = block_c8YPy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8YPW; else goto c8YPz;
       u8YPW: // global
           call _c8YPy(R1) args: 0, res: 0, upd: 0;
       c8YPz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YPy() //  [R1]
         { info_tbl: [(c8YPy,
                       label: block_c8YPy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YPy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8YPV; else goto c8YPU;
       c8YPV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YPU: // global
           _s8YvB::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s8YvB::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.502549933 UTC

[section ""data" . Foreign.C.String.$wpeekCAString_closure" {
     Foreign.C.String.$wpeekCAString_closure:
         const Foreign.C.String.$wpeekCAString_info;
 },
 Foreign.C.String.$wpeekCAString_entry() //  [R2]
         { info_tbl: [(c8YQD,
                       label: Foreign.C.String.$wpeekCAString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YQD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8YQE; else goto c8YQF;
       c8YQE: // global
           R2 = R2;
           R1 = Foreign.C.String.$wpeekCAString_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YQF: // global
           _s8YvC::I64 = R2;
           _s8Yw5::I64 = 0;
           goto c8YR6;
       c8YR6: // global
           if (I8[_s8YvC::I64 + _s8Yw5::I64] == 0 :: W8) goto c8YRc; else goto c8YRb;
       c8YRc: // global
           if (%MO_S_Gt_W64(_s8Yw5::I64, 0)) goto c8YR3; else goto c8YR4;
       c8YR3: // global
           I64[Sp - 24] = _s8YvC::I64;
           P64[Sp - 16] = GHC.Types.[]_closure+1;
           I64[Sp - 8] = _s8Yw5::I64 - 1;
           Sp = Sp - 32;
           call _c8YQe() args: 0, res: 0, upd: 0;
       c8YR4: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8YRb: // global
           _s8Yw5::I64 = _s8Yw5::I64 + 1;
           goto c8YR6;
     }
 },
 _c8YQe() //  []
         { info_tbl: [(c8YQe,
                       label: block_c8YQe_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YQe: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8YQJ; else goto c8YQI;
       c8YQJ: // global
           HpAlloc = 40;
           I64[Sp] = block_c8YQe_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8YQI: // global
           _s8YvJ::P64 = P64[Sp + 16];
           _s8YvK::I64 = I64[Sp + 24];
           _s8YvO::I64 = %MO_SS_Conv_W8_W64(I8[I64[Sp + 8] + _s8YvK::I64]);
           if (%MO_S_Gt_W64(_s8YvK::I64, 0)) goto c8YQL; else goto c8YR1;
       c8YQL: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s8YvO::I64));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YvJ::P64;
           P64[Sp + 16] = Hp - 14;
           I64[Sp + 24] = _s8YvK::I64 - 1;
           call _c8YQe() args: 0, res: 0, upd: 0;
       c8YR1: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s8YvO::I64));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YvJ::P64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.504232494 UTC

[section ""data" . Foreign.C.String.peekCAString1_closure" {
     Foreign.C.String.peekCAString1_closure:
         const Foreign.C.String.peekCAString1_info;
 },
 Foreign.C.String.peekCAString1_entry() //  [R2]
         { info_tbl: [(c8YRq,
                       label: Foreign.C.String.peekCAString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YRq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8YRr; else goto c8YRs;
       c8YRr: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCAString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YRs: // global
           I64[Sp - 8] = block_c8YRn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8YRw; else goto c8YRo;
       u8YRw: // global
           call _c8YRn(R1) args: 0, res: 0, upd: 0;
       c8YRo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YRn() //  [R1]
         { info_tbl: [(c8YRn,
                       label: block_c8YRn_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YRn: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call Foreign.C.String.$wpeekCAString_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.505349224 UTC

[section ""data" . Foreign.C.String.peekCAString_closure" {
     Foreign.C.String.peekCAString_closure:
         const Foreign.C.String.peekCAString_info;
 },
 Foreign.C.String.peekCAString_entry() //  [R2]
         { info_tbl: [(c8YRB,
                       label: Foreign.C.String.peekCAString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YRB: // global
           R2 = R2;
           call Foreign.C.String.peekCAString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.506694283 UTC

[section ""data" . Foreign.C.String.$wpeekCAStringLen_closure" {
     Foreign.C.String.$wpeekCAStringLen_closure:
         const Foreign.C.String.$wpeekCAStringLen_info;
 },
 Foreign.C.String.$wpeekCAStringLen_entry() //  [R2, R3]
         { info_tbl: [(c8YSk,
                       label: Foreign.C.String.$wpeekCAStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YSk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8YSl; else goto c8YSm;
       c8YSl: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.$wpeekCAStringLen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8YSm: // global
           if (%MO_S_Gt_W64(R3, 0)) goto c8YSi; else goto c8YSj;
       c8YSi: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = GHC.Types.[]_closure+1;
           I64[Sp - 8] = R3 - 1;
           Sp = Sp - 24;
           call _c8YRQ() args: 0, res: 0, upd: 0;
       c8YSj: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8YRQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YRQ: // global
           I64[Sp - 8] = block_c8YRT_info;
           R1 = P64[Sp];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8YSL; else goto c8YRU;
       u8YSL: // global
           call _c8YRT(R1) args: 0, res: 0, upd: 0;
       c8YRU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YRT() //  [R1]
         { info_tbl: [(c8YRT,
                       label: block_c8YRT_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YRT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8YSq; else goto c8YSp;
       c8YSq: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YSp: // global
           _s8Ywl::P64 = P64[Sp + 16];
           _s8Ywm::I64 = I64[Sp + 24];
           _s8Yws::I64 = %MO_SS_Conv_W8_W64(I8[I64[R1 + 7] + _s8Ywm::I64]);
           if (_s8Ywm::I64 == 0) goto c8YSI; else goto c8YSs;
       c8YSI: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s8Yws::I64));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8Ywl::P64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8YSs: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s8Yws::I64));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8Ywl::P64;
           P64[Sp + 16] = Hp - 14;
           I64[Sp + 24] = _s8Ywm::I64 - 1;
           Sp = Sp + 8;
           call _c8YRQ() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.508499991 UTC

[section ""data" . Foreign.C.String.peekCAStringLen1_closure" {
     Foreign.C.String.peekCAStringLen1_closure:
         const Foreign.C.String.peekCAStringLen1_info;
 },
 Foreign.C.String.peekCAStringLen1_entry() //  [R2]
         { info_tbl: [(c8YSV,
                       label: Foreign.C.String.peekCAStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YSV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8YSZ; else goto c8YT0;
       c8YSZ: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCAStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YT0: // global
           I64[Sp - 8] = block_c8YSS_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8YT8; else goto c8YST;
       u8YT8: // global
           call _c8YSS(R1) args: 0, res: 0, upd: 0;
       c8YST: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YSS() //  [R1]
         { info_tbl: [(c8YSS,
                       label: block_c8YSS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YSS: // global
           I64[Sp - 8] = block_c8YSY_info;
           _s8YwL::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s8YwL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8YT7; else goto c8YT2;
       u8YT7: // global
           call _c8YSY(R1) args: 0, res: 0, upd: 0;
       c8YT2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YSY() //  [R1]
         { info_tbl: [(c8YSY,
                       label: block_c8YSY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YSY: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.C.String.$wpeekCAStringLen_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.509885548 UTC

[section ""data" . Foreign.C.String.peekCAStringLen_closure" {
     Foreign.C.String.peekCAStringLen_closure:
         const Foreign.C.String.peekCAStringLen_info;
 },
 Foreign.C.String.peekCAStringLen_entry() //  [R2]
         { info_tbl: [(c8YTd,
                       label: Foreign.C.String.peekCAStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YTd: // global
           R2 = R2;
           call Foreign.C.String.peekCAStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.510897665 UTC

[section ""data" . Foreign.C.String.castCWcharToChar_closure" {
     Foreign.C.String.castCWcharToChar_closure:
         const Foreign.C.String.castCWcharToChar_info;
         const 0;
 },
 Foreign.C.String.castCWcharToChar_entry() //  [R2]
         { info_tbl: [(c8YTn,
                       label: Foreign.C.String.castCWcharToChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YTn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8YTo; else goto c8YTp;
       c8YTo: // global
           R2 = R2;
           R1 = Foreign.C.String.castCWcharToChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YTp: // global
           I64[Sp - 8] = block_c8YTk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8YTJ; else goto c8YTl;
       u8YTJ: // global
           call _c8YTk(R1) args: 0, res: 0, upd: 0;
       c8YTl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YTk() //  [R1]
         { info_tbl: [(c8YTk,
                       label: block_c8YTk_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YTk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8YTu; else goto c8YTt;
       c8YTu: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YTt: // global
           _s8YwR::I64 = I64[R1 + 7];
           if (_s8YwR::I64 > 1114111) goto c8YTB; else goto c8YTI;
       c8YTB: // global
           Hp = Hp - 16;
           R2 = _s8YwR::I64;
           Sp = Sp + 8;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c8YTI: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s8YwR::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.512236346 UTC

[section ""data" . Foreign.C.String.peekCWString2_closure" {
     Foreign.C.String.peekCWString2_closure:
         const Foreign.C.String.peekCWString2_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.C.String.peekCWString2_entry() //  [R1]
         { info_tbl: [(c8YTQ,
                       label: Foreign.C.String.peekCWString2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YTQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8YTR; else goto c8YTS;
       c8YTR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8YTS: // global
           (_c8YTN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8YTN::I64 == 0) goto c8YTP; else goto c8YTO;
       c8YTP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8YTO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8YTN::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = Foreign.C.String.castCWcharToChar_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.514091385 UTC

[section ""data" . Foreign.C.String.$wpeekCWStringLen_closure" {
     Foreign.C.String.$wpeekCWStringLen_closure:
         const Foreign.C.String.$wpeekCWStringLen_info;
         const 0;
 },
 sat_s8Yx9_entry() //  [R1]
         { info_tbl: [(c8YUx,
                       label: sat_s8Yx9_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YUx: // global
           _s8Yx9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8YUy; else goto c8YUz;
       c8YUz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8YUB; else goto c8YUA;
       c8YUB: // global
           HpAlloc = 40;
           goto c8YUy;
       c8YUy: // global
           R1 = _s8Yx9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8YUA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Yx9::P64;
           _s8Yx0::P64 = P64[_s8Yx9::P64 + 16];
           _s8Yx6::I64 = I64[_s8Yx9::P64 + 24];
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = _s8Yx6::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8Yx0::P64;
           R3 = Hp - 14;
           R2 = Foreign.C.String.castCWcharToChar_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.C.String.$wpeekCWStringLen_entry() //  [R2, R3]
         { info_tbl: [(c8YUF,
                       label: Foreign.C.String.$wpeekCWStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YUF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8YUG; else goto c8YUH;
       c8YUG: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.$wpeekCWStringLen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8YUH: // global
           if (%MO_S_Gt_W64(R3, 0)) goto c8YUD; else goto c8YUE;
       c8YUD: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call _c8YU7() args: 0, res: 0, upd: 0;
       c8YUE: // global
           R1 = Foreign.C.String.peekCWString2_closure;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8YU7() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YU7: // global
           _s8YwV::P64 = P64[Sp];
           _s8Yxe::I64 = I64[Sp + 8];
           if (_s8Yxe::I64 != 0) goto c8YUO; else goto c8YUS;
       c8YUO: // global
           I64[Sp - 8] = block_c8YUc_info;
           R1 = _s8YwV::P64;
           I64[Sp + 8] = _s8Yxe::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8YUW; else goto c8YUd;
       u8YUW: // global
           call _c8YUc(R1) args: 0, res: 0, upd: 0;
       c8YUd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8YUS: // global
           I64[Sp + 8] = block_c8YUm_info;
           R1 = _s8YwV::P64;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8YUX; else goto c8YUn;
       u8YUX: // global
           call _c8YUm(R1) args: 0, res: 0, upd: 0;
       c8YUn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YUc() //  [R1]
         { info_tbl: [(c8YUc,
                       label: block_c8YUc_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YUc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8YUR; else goto c8YUQ;
       c8YUR: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YUQ: // global
           _s8Yxe::I64 = I64[Sp + 16];
           _s8Yxj::I64 = %MO_SS_Conv_W32_W64(I32[I64[R1 + 7] + (_s8Yxe::I64 << 2)]);
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = _s8Yxj::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 16] = _s8Yxe::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           Sp = Sp + 8;
           call _c8YU7() args: 0, res: 0, upd: 0;
     }
 },
 _c8YUm() //  [R1]
         { info_tbl: [(c8YUm,
                       label: block_c8YUm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YUm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8YUL; else goto c8YUK;
       c8YUL: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YUK: // global
           _s8Yx6::I64 = %MO_SS_Conv_W32_W64(I32[I64[R1 + 7]]);
           I64[Hp - 24] = sat_s8Yx9_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = _s8Yx6::I64;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.516627711 UTC

[section ""data" . Foreign.C.String.peekCWStringLen1_closure" {
     Foreign.C.String.peekCWStringLen1_closure:
         const Foreign.C.String.peekCWStringLen1_info;
         const 0;
 },
 Foreign.C.String.peekCWStringLen1_entry() //  [R2]
         { info_tbl: [(c8YV7,
                       label: Foreign.C.String.peekCWStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YV7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8YVb; else goto c8YVc;
       c8YVb: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCWStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YVc: // global
           I64[Sp - 8] = block_c8YV4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8YVk; else goto c8YV5;
       u8YVk: // global
           call _c8YV4(R1) args: 0, res: 0, upd: 0;
       c8YV5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YV4() //  [R1]
         { info_tbl: [(c8YV4,
                       label: block_c8YV4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YV4: // global
           I64[Sp - 8] = block_c8YVa_info;
           _s8Yxr::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s8Yxr::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8YVj; else goto c8YVe;
       u8YVj: // global
           call _c8YVa(R1) args: 0, res: 0, upd: 0;
       c8YVe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YVa() //  [R1]
         { info_tbl: [(c8YVa,
                       label: block_c8YVa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YVa: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.C.String.$wpeekCWStringLen_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.51805386 UTC

[section ""data" . Foreign.C.String.peekCWStringLen_closure" {
     Foreign.C.String.peekCWStringLen_closure:
         const Foreign.C.String.peekCWStringLen_info;
         const 0;
 },
 Foreign.C.String.peekCWStringLen_entry() //  [R2]
         { info_tbl: [(c8YVp,
                       label: Foreign.C.String.peekCWStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YVp: // global
           R2 = R2;
           call Foreign.C.String.peekCWStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.51876055 UTC

[section ""data" . Foreign.C.String.newCWString3_closure" {
     Foreign.C.String.newCWString3_closure:
         const GHC.Int.I32#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.520296259 UTC

[section ""data" . Foreign.C.String.$wpeekCWString_closure" {
     Foreign.C.String.$wpeekCWString_closure:
         const Foreign.C.String.$wpeekCWString_info;
         const 0;
 },
 sat_s8YxJ_entry() //  [R1]
         { info_tbl: [(c8YW1,
                       label: sat_s8YxJ_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YW1: // global
           _s8YxJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8YW2; else goto c8YW3;
       c8YW3: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8YW5; else goto c8YW4;
       c8YW5: // global
           HpAlloc = 40;
           goto c8YW2;
       c8YW2: // global
           R1 = _s8YxJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8YW4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8YxJ::P64;
           _s8YxC::P64 = P64[_s8YxJ::P64 + 16];
           _s8YxG::I64 = I64[_s8YxJ::P64 + 24];
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = _s8YxG::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YxC::P64;
           R3 = Hp - 14;
           R2 = Foreign.C.String.castCWcharToChar_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.C.String.$wpeekCWString_entry() //  [R2]
         { info_tbl: [(c8YW8,
                       label: Foreign.C.String.$wpeekCWString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YW8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8YW9; else goto c8YWa;
       c8YW9: // global
           R2 = R2;
           R1 = Foreign.C.String.$wpeekCWString_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YWa: // global
           _s8Yxv::I64 = R2;
           _s8YxX::I64 = 0;
           goto c8YWp;
       c8YWp: // global
           if (I32[_s8Yxv::I64 + (_s8YxX::I64 << 2)] == 0 :: W32) goto c8YWv; else goto c8YWu;
       c8YWv: // global
           if (%MO_S_Gt_W64(_s8YxX::I64, 0)) goto c8YWm; else goto c8YWn;
       c8YWm: // global
           I64[Sp - 24] = _s8Yxv::I64;
           I64[Sp - 16] = _s8YxX::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call _c8YVL() args: 0, res: 0, upd: 0;
       c8YWn: // global
           R1 = Foreign.C.String.peekCWString2_closure;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8YWu: // global
           _s8YxX::I64 = _s8YxX::I64 + 1;
           goto c8YWp;
     }
 },
 _c8YVL() //  []
         { info_tbl: [(c8YVL,
                       label: block_c8YVL_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YVL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8YWh; else goto c8YWg;
       c8YWh: // global
           HpAlloc = 40;
           I64[Sp] = block_c8YVL_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8YWg: // global
           _s8YxM::P64 = P64[Sp + 24];
           _s8YxO::I64 = I64[Sp + 16];
           if (_s8YxO::I64 != 0) goto c8YWj; else goto c8YWk;
       c8YWj: // global
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W32_W64(I32[I64[Sp + 8] + (_s8YxO::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YxM::P64;
           I64[Sp + 16] = _s8YxO::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           call _c8YVL() args: 0, res: 0, upd: 0;
       c8YWk: // global
           Hp = Hp - 40;
           P64[Sp + 24] = _s8YxM::P64;
           Sp = Sp + 8;
           call _c8YVT() args: 0, res: 0, upd: 0;
     }
 },
 _c8YVT() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YVT: // global
           Hp = Hp + 32;
           _s8YxC::P64 = P64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c8YWe; else goto c8YWd;
       c8YWe: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_c8YVS_info;
           R1 = _s8YxC::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YWd: // global
           I64[Hp - 24] = sat_s8YxJ_info;
           P64[Hp - 8] = _s8YxC::P64;
           I64[Hp] = %MO_SS_Conv_W32_W64(I32[I64[Sp]]);
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8YVS() //  [R1]
         { info_tbl: [(c8YVS,
                       label: block_c8YVS_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YVS: // global
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c8YVT() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.524361727 UTC

[section ""data" . Foreign.C.String.peekCWString1_closure" {
     Foreign.C.String.peekCWString1_closure:
         const Foreign.C.String.peekCWString1_info;
         const 0;
 },
 Foreign.C.String.peekCWString1_entry() //  [R2]
         { info_tbl: [(c8YWO,
                       label: Foreign.C.String.peekCWString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YWO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8YWP; else goto c8YWQ;
       c8YWP: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCWString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YWQ: // global
           I64[Sp - 8] = block_c8YWL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8YWU; else goto c8YWM;
       u8YWU: // global
           call _c8YWL(R1) args: 0, res: 0, upd: 0;
       c8YWM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YWL() //  [R1]
         { info_tbl: [(c8YWL,
                       label: block_c8YWL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YWL: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call Foreign.C.String.$wpeekCWString_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.525748973 UTC

[section ""data" . Foreign.C.String.peekCWString_closure" {
     Foreign.C.String.peekCWString_closure:
         const Foreign.C.String.peekCWString_info;
         const 0;
 },
 Foreign.C.String.peekCWString_entry() //  [R2]
         { info_tbl: [(c8YWZ,
                       label: Foreign.C.String.peekCWString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YWZ: // global
           R2 = R2;
           call Foreign.C.String.peekCWString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.526735381 UTC

[section ""data" . Foreign.C.String.newCWString2_closure" {
     Foreign.C.String.newCWString2_closure:
         const Foreign.C.String.newCWString2_info;
 },
 Foreign.C.String.newCWString2_entry() //  [R2]
         { info_tbl: [(c8YX9,
                       label: Foreign.C.String.newCWString2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YX9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8YXj; else goto c8YXk;
       c8YXj: // global
           R2 = R2;
           R1 = Foreign.C.String.newCWString2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YXk: // global
           I64[Sp - 8] = block_c8YX6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8YXo; else goto c8YX7;
       u8YXo: // global
           call _c8YX6(R1) args: 0, res: 0, upd: 0;
       c8YX7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YX6() //  [R1]
         { info_tbl: [(c8YX6,
                       label: block_c8YX6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YX6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8YXn; else goto c8YXm;
       c8YXn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8YXm: // global
           _s8Yyc::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s8Yyc::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.528687904 UTC

[section ""data" . Foreign.C.String.withCWStringLen1_closure" {
     Foreign.C.String.withCWStringLen1_closure:
         const Foreign.C.String.withCWStringLen1_info;
 },
 Foreign.C.String.withCWStringLen1_entry() //  [R2, R3]
         { info_tbl: [(c8YXv,
                       label: Foreign.C.String.withCWStringLen1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YXv: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8YXz; else goto c8YXA;
       c8YXz: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.withCWStringLen1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8YXA: // global
           I64[Sp - 16] = block_c8YXt_info;
           _s8Yye::P64 = R3;
           R3 = R2;
           R2 = Foreign.C.String.newCWString2_closure+1;
           P64[Sp - 8] = _s8Yye::P64;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8YXt() //  [R1]
         { info_tbl: [(c8YXt,
                       label: block_c8YXt_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YXt: // global
           I64[Sp - 8] = block_c8YXy_info;
           R3 = 0;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8YXy() //  [R1]
         { info_tbl: [(c8YXy,
                       label: block_c8YXy_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YXy: // global
           I64[Sp - 8] = block_c8YXJ_info;
           R2 = 4;
           _s8Yyh::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8Yyh::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YXJ() //  [R1]
         { info_tbl: [(c8YXJ,
                       label: block_c8YXJ_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YXJ: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c8YY5() args: 0, res: 0, upd: 0;
     }
 },
 _c8YY5() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YY5: // global
           _s8YyA::P64 = P64[Sp];
           I64[Sp] = block_c8YY8_info;
           R1 = _s8YyA::P64;
           if (R1 & 7 != 0) goto u8YYy; else goto c8YYa;
       u8YYy: // global
           call _c8YY8(R1) args: 0, res: 0, upd: 0;
       c8YYa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YY8() //  [R1]
         { info_tbl: [(c8YY8,
                       label: block_c8YY8_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YY8: // global
           if (R1 & 7 == 1) goto u8YYv; else goto c8YYl;
       u8YYv: // global
           Sp = Sp + 8;
           call _c8YXS() args: 0, res: 0, upd: 0;
       c8YYl: // global
           I64[Sp - 8] = block_c8YYj_info;
           _s8YyF::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8YyF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8YYz; else goto c8YYm;
       u8YYz: // global
           call _c8YYj(R1) args: 0, res: 0, upd: 0;
       c8YYm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YXS() //  []
         { info_tbl: [(c8YXS,
                       label: block_c8YXS_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YXS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8YY0; else goto c8YXZ;
       c8YY0: // global
           HpAlloc = 56;
           I64[Sp] = block_c8YXS_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8YXZ: // global
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = I64[Sp + 16];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           I64[Sp + 16] = block_c8YXX_info;
           R2 = Hp - 15;
           R1 = P64[Sp + 32];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8YXX() //  [R1]
         { info_tbl: [(c8YXX,
                       label: block_c8YXX_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YXX: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8YYj() //  [R1]
         { info_tbl: [(c8YYj,
                       label: block_c8YYj_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YYj: // global
           _s8YyB::I64 = I64[Sp + 16];
           _s8YyF::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8YyB::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8YyF::P64;
           I64[Sp + 16] = _s8YyB::I64 + 1;
           Sp = Sp + 8;
           call _c8YY5() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.53105123 UTC

[section ""data" . Foreign.C.String.withCWStringLen_closure" {
     Foreign.C.String.withCWStringLen_closure:
         const Foreign.C.String.withCWStringLen_info;
 },
 Foreign.C.String.withCWStringLen_entry() //  [R2, R3]
         { info_tbl: [(c8YYG,
                       label: Foreign.C.String.withCWStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YYG: // global
           R3 = R3;
           R2 = R2;
           call Foreign.C.String.withCWStringLen1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.532289231 UTC

[section ""data" . Foreign.C.String.withCWString_closure" {
     Foreign.C.String.withCWString_closure:
         const Foreign.C.String.withCWString_info;
         const 0;
 },
 vals_s8YyL_entry() //  [R1]
         { info_tbl: [(c8YYR,
                       label: vals_s8YyL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YYR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8YYS; else goto c8YYT;
       c8YYS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8YYT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Foreign.C.String.newCWString2_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8YyO_entry() //  [R1]
         { info_tbl: [(c8YZ4,
                       label: sat_s8YyO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YZ4: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8YyP_entry() //  [R1, R2]
         { info_tbl: [(c8YZ7,
                       label: sat_s8YyP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YZ7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8YZb; else goto c8YZa;
       c8YZb: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YZa: // global
           _s8YyL::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s8YyO_info;
           P64[Hp] = R2;
           R5 = Hp - 7;
           R4 = _s8YyL::P64;
           R3 = Foreign.C.String.newCWString3_closure+1;
           R2 = Foreign.C.Types.$fStorableCWchar_closure;
           call Foreign.Marshal.Array.withArrayLen0_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.C.String.withCWString_entry() //  [R2]
         { info_tbl: [(c8YZc,
                       label: Foreign.C.String.withCWString_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YZc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8YZg; else goto c8YZf;
       c8YZg: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.C.String.withCWString_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YZf: // global
           I64[Hp - 32] = vals_s8YyL_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8YyP_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.533958374 UTC

[section ""data" . Foreign.C.String.newCWString1_closure" {
     Foreign.C.String.newCWString1_closure:
         const Foreign.C.String.newCWString1_info;
         const 0;
 },
 Foreign.C.String.newCWString1_entry() //  [R2]
         { info_tbl: [(c8YZn,
                       label: Foreign.C.String.newCWString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YZn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8YZo; else goto c8YZp;
       c8YZo: // global
           R2 = R2;
           R1 = Foreign.C.String.newCWString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8YZp: // global
           I64[Sp - 8] = block_c8YZl_info;
           R3 = R2;
           R2 = Foreign.C.String.newCWString2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8YZl() //  [R1]
         { info_tbl: [(c8YZl,
                       label: block_c8YZl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YZl: // global
           R4 = R1;
           R3 = Foreign.C.String.newCWString3_closure+1;
           R2 = Foreign.C.Types.$fStorableCWchar_closure;
           Sp = Sp + 8;
           call Foreign.Marshal.Array.newArray3_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.535006187 UTC

[section ""data" . Foreign.C.String.newCWString_closure" {
     Foreign.C.String.newCWString_closure:
         const Foreign.C.String.newCWString_info;
         const 0;
 },
 Foreign.C.String.newCWString_entry() //  [R2]
         { info_tbl: [(c8YZx,
                       label: Foreign.C.String.newCWString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YZx: // global
           R2 = R2;
           call Foreign.C.String.newCWString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.536196236 UTC

[section ""data" . Foreign.C.String.newCWStringLen1_closure" {
     Foreign.C.String.newCWStringLen1_closure:
         const Foreign.C.String.newCWStringLen1_info;
         const 0;
 },
 sat_s8Yz0_entry() //  [R1]
         { info_tbl: [(c8YZQ,
                       label: sat_s8Yz0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YZQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8YZU; else goto c8YZV;
       c8YZU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8YZV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8YZO_info;
           R3 = 0;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8YZO() //  [R1]
         { info_tbl: [(c8YZO,
                       label: block_c8YZO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YZO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8YZY; else goto c8YZX;
       c8YZY: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c8YZX: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.C.String.newCWStringLen1_entry() //  [R2]
         { info_tbl: [(c8YZZ,
                       label: Foreign.C.String.newCWStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YZZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Z01; else goto c8Z02;
       c8Z01: // global
           R2 = R2;
           R1 = Foreign.C.String.newCWStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Z02: // global
           I64[Sp - 8] = block_c8YZE_info;
           R3 = R2;
           R2 = Foreign.C.String.newCWString2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8YZE() //  [R1]
         { info_tbl: [(c8YZE,
                       label: block_c8YZE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YZE: // global
           I64[Sp - 8] = block_c8YZI_info;
           R3 = R1;
           R2 = Foreign.C.Types.$fStorableCWchar_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call Foreign.Marshal.Array.newArray1_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8YZI() //  [R1]
         { info_tbl: [(c8YZI,
                       label: block_c8YZI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8YZI: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8Z06; else goto c8Z05;
       c8Z06: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Z05: // global
           I64[Hp - 40] = sat_s8Yz0_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.538015402 UTC

[section ""data" . Foreign.C.String.newCWStringLen_closure" {
     Foreign.C.String.newCWStringLen_closure:
         const Foreign.C.String.newCWStringLen_info;
         const 0;
 },
 Foreign.C.String.newCWStringLen_entry() //  [R2]
         { info_tbl: [(c8Z0b,
                       label: Foreign.C.String.newCWStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z0b: // global
           R2 = R2;
           call Foreign.C.String.newCWStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.538977456 UTC

[section ""data" . Foreign.C.String.castCharToCChar1_closure" {
     Foreign.C.String.castCharToCChar1_closure:
         const Foreign.C.String.castCharToCChar1_info;
 },
 Foreign.C.String.castCharToCChar1_entry() //  [R2]
         { info_tbl: [(c8Z0l,
                       label: Foreign.C.String.castCharToCChar1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z0l: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8Z0v; else goto c8Z0w;
       c8Z0v: // global
           R2 = R2;
           R1 = Foreign.C.String.castCharToCChar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Z0w: // global
           I64[Sp - 8] = block_c8Z0i_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Z0A; else goto c8Z0j;
       u8Z0A: // global
           call _c8Z0i(R1) args: 0, res: 0, upd: 0;
       c8Z0j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z0i() //  [R1]
         { info_tbl: [(c8Z0i,
                       label: block_c8Z0i_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z0i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Z0z; else goto c8Z0y;
       c8Z0z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Z0y: // global
           _s8Yz6::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s8Yz6::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.540155625 UTC

[section ""data" . Foreign.C.String.castCharToCSChar_closure" {
     Foreign.C.String.castCharToCSChar_closure:
         const Foreign.C.String.castCharToCSChar_info;
 },
 Foreign.C.String.castCharToCSChar_entry() //  [R2]
         { info_tbl: [(c8Z0F,
                       label: Foreign.C.String.castCharToCSChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z0F: // global
           R2 = R2;
           call Foreign.C.String.castCharToCChar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.541080669 UTC

[section ""data" . Foreign.C.String.castCharToCUChar1_closure" {
     Foreign.C.String.castCharToCUChar1_closure:
         const Foreign.C.String.castCharToCUChar1_info;
 },
 Foreign.C.String.castCharToCUChar1_entry() //  [R2]
         { info_tbl: [(c8Z0P,
                       label: Foreign.C.String.castCharToCUChar1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z0P: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8Z12; else goto c8Z13;
       c8Z12: // global
           R2 = R2;
           R1 = Foreign.C.String.castCharToCUChar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Z13: // global
           I64[Sp - 8] = block_c8Z0M_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Z17; else goto c8Z0N;
       u8Z17: // global
           call _c8Z0M(R1) args: 0, res: 0, upd: 0;
       c8Z0N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z0M() //  [R1]
         { info_tbl: [(c8Z0M,
                       label: block_c8Z0M_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z0M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Z16; else goto c8Z15;
       c8Z16: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Z15: // global
           _s8Yzc::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s8Yzc::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.542283663 UTC

[section ""data" . Foreign.C.String.castCharToCUChar_closure" {
     Foreign.C.String.castCharToCUChar_closure:
         const Foreign.C.String.castCharToCUChar_info;
 },
 Foreign.C.String.castCharToCUChar_entry() //  [R2]
         { info_tbl: [(c8Z1c,
                       label: Foreign.C.String.castCharToCUChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z1c: // global
           R2 = R2;
           call Foreign.C.String.castCharToCUChar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.543100302 UTC

[section ""data" . Foreign.C.String.castCharToCChar_closure" {
     Foreign.C.String.castCharToCChar_closure:
         const Foreign.C.String.castCharToCChar_info;
 },
 Foreign.C.String.castCharToCChar_entry() //  [R2]
         { info_tbl: [(c8Z1j,
                       label: Foreign.C.String.castCharToCChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z1j: // global
           R2 = R2;
           call Foreign.C.String.castCharToCChar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.544621388 UTC

[section ""data" . Foreign.C.String.newCAString1_closure" {
     Foreign.C.String.newCAString1_closure:
         const Foreign.C.String.newCAString1_info;
         const 0;
 },
 Foreign.C.String.newCAString1_entry() //  [R2]
         { info_tbl: [(c8Z1s,
                       label: Foreign.C.String.newCAString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z1s: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Z1t; else goto c8Z1u;
       c8Z1t: // global
           R2 = R2;
           R1 = Foreign.C.String.newCAString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Z1u: // global
           I64[Sp - 16] = block_c8Z1q_info;
           R3 = 0;
           _s8Yzd::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s8Yzd::P64;
           Sp = Sp - 16;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z1q() //  [R1]
         { info_tbl: [(c8Z1q,
                       label: block_c8Z1q_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z1q: // global
           _s8Yzd::P64 = P64[Sp + 8];
           (_s8Yzl::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(R1 + 1);
           if (_s8Yzl::I64 == 0) goto c8Z2i; else goto c8Z2h;
       c8Z2i: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Z2h: // global
           I64[Sp - 8] = 0;
           P64[Sp] = _s8Yzd::P64;
           I64[Sp + 8] = _s8Yzl::I64;
           Sp = Sp - 8;
           call _c8Z1U() args: 0, res: 0, upd: 0;
     }
 },
 _c8Z1U() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z1U: // global
           I64[Sp - 8] = block_c8Z1X_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Z2x; else goto c8Z1Z;
       u8Z2x: // global
           call _c8Z1X(R1) args: 0, res: 0, upd: 0;
       c8Z1Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z1X() //  [R1]
         { info_tbl: [(c8Z1X,
                       label: block_c8Z1X_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z1X: // global
           if (R1 & 7 == 1) goto c8Z25; else goto c8Z2a;
       c8Z25: // global
           I64[Sp + 16] = I64[Sp + 8];
           Sp = Sp + 16;
           call _c8Z1M() args: 0, res: 0, upd: 0;
       c8Z2a: // global
           I64[Sp] = block_c8Z28_info;
           _s8Yzy::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _s8Yzy::P64;
           if (R1 & 7 != 0) goto u8Z2y; else goto c8Z2b;
       u8Z2y: // global
           call _c8Z28(R1) args: 0, res: 0, upd: 0;
       c8Z2b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z1M() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z1M: // global
           Hp = Hp + 16;
           _s8Yzo::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c8Z1R; else goto c8Z1Q;
       c8Z1R: // global
           HpAlloc = 16;
           I64[Sp] = block_c8Z1L_info;
           R1 = _s8Yzo::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8Z1Q: // global
           _s8Yzl::I64 = I64[Sp + 8];
           I8[_s8Yzl::I64 + _s8Yzo::I64] = 0 :: W8;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8Yzl::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Z1L() //  [R1]
         { info_tbl: [(c8Z1L,
                       label: block_c8Z1L_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z1L: // global
           I64[Sp] = R1;
           call _c8Z1M() args: 0, res: 0, upd: 0;
     }
 },
 _c8Z28() //  [R1]
         { info_tbl: [(c8Z28,
                       label: block_c8Z28_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z28: // global
           _s8Yzu::I64 = I64[Sp + 8];
           _s8Yzy::P64 = P64[Sp + 16];
           I8[I64[Sp + 24] + _s8Yzu::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 16] = _s8Yzy::P64;
           I64[Sp + 8] = _s8Yzu::I64 + 1;
           Sp = Sp + 8;
           call _c8Z1U() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.546728065 UTC

[section ""data" . Foreign.C.String.newCAString_closure" {
     Foreign.C.String.newCAString_closure:
         const Foreign.C.String.newCAString_info;
         const 0;
 },
 Foreign.C.String.newCAString_entry() //  [R2]
         { info_tbl: [(c8Z2F,
                       label: Foreign.C.String.newCAString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z2F: // global
           R2 = R2;
           call Foreign.C.String.newCAString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.548251091 UTC

[section ""data" . Foreign.C.String.newCAStringLen1_closure" {
     Foreign.C.String.newCAStringLen1_closure:
         const Foreign.C.String.newCAStringLen1_info;
         const 0;
 },
 Foreign.C.String.newCAStringLen1_entry() //  [R2]
         { info_tbl: [(c8Z2O,
                       label: Foreign.C.String.newCAStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z2O: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8Z2P; else goto c8Z2Q;
       c8Z2P: // global
           R2 = R2;
           R1 = Foreign.C.String.newCAStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Z2Q: // global
           I64[Sp - 16] = block_c8Z2M_info;
           R3 = 0;
           _s8YzF::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s8YzF::P64;
           Sp = Sp - 16;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z2M() //  [R1]
         { info_tbl: [(c8Z2M,
                       label: block_c8Z2M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z2M: // global
           _s8YzF::P64 = P64[Sp + 8];
           (_s8YzN::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(R1 + 1);
           if (_s8YzN::I64 == 0) goto c8Z3G; else goto c8Z3F;
       c8Z3G: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Z3F: // global
           P64[Sp - 16] = _s8YzF::P64;
           I64[Sp - 8] = 0;
           I64[Sp] = _s8YzN::I64;
           I64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _c8Z3i() args: 0, res: 0, upd: 0;
     }
 },
 _c8Z3i() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z3i: // global
           _s8YzV::P64 = P64[Sp];
           I64[Sp] = block_c8Z3l_info;
           R1 = _s8YzV::P64;
           if (R1 & 7 != 0) goto u8Z3T; else goto c8Z3n;
       u8Z3T: // global
           call _c8Z3l(R1) args: 0, res: 0, upd: 0;
       c8Z3n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z3l() //  [R1]
         { info_tbl: [(c8Z3l,
                       label: block_c8Z3l_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z3l: // global
           if (R1 & 7 == 1) goto u8Z3Q; else goto c8Z3y;
       u8Z3Q: // global
           Sp = Sp + 8;
           call _c8Z38() args: 0, res: 0, upd: 0;
       c8Z3y: // global
           I64[Sp - 8] = block_c8Z3w_info;
           _s8YA0::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8YA0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Z3U; else goto c8Z3z;
       u8Z3U: // global
           call _c8Z3w(R1) args: 0, res: 0, upd: 0;
       c8Z3z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z38() //  []
         { info_tbl: [(c8Z38,
                       label: block_c8Z38_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z38: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Z3f; else goto c8Z3e;
       c8Z3f: // global
           HpAlloc = 56;
           I64[Sp] = block_c8Z38_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Z3e: // global
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = I64[Sp + 16];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Z3w() //  [R1]
         { info_tbl: [(c8Z3w,
                       label: block_c8Z3w_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z3w: // global
           _s8YzW::I64 = I64[Sp + 16];
           _s8YA0::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s8YzW::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s8YA0::P64;
           I64[Sp + 16] = _s8YzW::I64 + 1;
           Sp = Sp + 8;
           call _c8Z3i() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.550548154 UTC

[section ""data" . Foreign.C.String.newCAStringLen_closure" {
     Foreign.C.String.newCAStringLen_closure:
         const Foreign.C.String.newCAStringLen_info;
         const 0;
 },
 Foreign.C.String.newCAStringLen_entry() //  [R2]
         { info_tbl: [(c8Z41,
                       label: Foreign.C.String.newCAStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z41: // global
           R2 = R2;
           call Foreign.C.String.newCAStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.552198163 UTC

[section ""data" . Foreign.C.String.withCAString1_closure" {
     Foreign.C.String.withCAString1_closure:
         const Foreign.C.String.withCAString1_info;
 },
 Foreign.C.String.withCAString1_entry() //  [R2, R3]
         { info_tbl: [(c8Z4a,
                       label: Foreign.C.String.withCAString1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z4a: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8Z4b; else goto c8Z4c;
       c8Z4b: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.withCAString1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Z4c: // global
           I64[Sp - 24] = block_c8Z48_info;
           _s8YA9::P64 = R3;
           R3 = 0;
           _s8YA8::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s8YA8::P64;
           P64[Sp - 8] = _s8YA9::P64;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z48() //  [R1]
         { info_tbl: [(c8Z48,
                       label: block_c8Z48_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z48: // global
           I64[Sp] = block_c8Z4j_info;
           R2 = 1;
           R1 = R1 + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z4j() //  [R1]
         { info_tbl: [(c8Z4j,
                       label: block_c8Z4j_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z4j: // global
           P64[Sp - 16] = P64[Sp + 8];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _c8Z4D() args: 0, res: 0, upd: 0;
     }
 },
 _c8Z4D() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z4D: // global
           _s8YAu::P64 = P64[Sp];
           I64[Sp] = block_c8Z4G_info;
           R1 = _s8YAu::P64;
           if (R1 & 7 != 0) goto u8Z5e; else goto c8Z4I;
       u8Z5e: // global
           call _c8Z4G(R1) args: 0, res: 0, upd: 0;
       c8Z4I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z4G() //  [R1]
         { info_tbl: [(c8Z4G,
                       label: block_c8Z4G_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z4G: // global
           if (R1 & 7 == 1) goto c8Z4O; else goto c8Z4T;
       c8Z4O: // global
           I64[Sp + 8] = I64[Sp + 8];
           Sp = Sp + 8;
           call _c8Z4s() args: 0, res: 0, upd: 0;
       c8Z4T: // global
           I64[Sp - 8] = block_c8Z4R_info;
           _s8YAz::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8YAz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Z5f; else goto c8Z4U;
       u8Z5f: // global
           call _c8Z4R(R1) args: 0, res: 0, upd: 0;
       c8Z4U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z4s() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z4s: // global
           Hp = Hp + 16;
           _s8YAl::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c8Z4y; else goto c8Z4x;
       c8Z4y: // global
           HpAlloc = 16;
           I64[Sp] = block_c8Z4r_info;
           R1 = _s8YAl::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8Z4x: // global
           _s8YA9::P64 = P64[Sp + 24];
           _s8YAj::I64 = I64[Sp + 8];
           I8[_s8YAj::I64 + _s8YAl::I64] = 0 :: W8;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8YAj::I64;
           I64[Sp + 8] = block_c8Z4v_info;
           R2 = Hp - 7;
           R1 = _s8YA9::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z4r() //  [R1]
         { info_tbl: [(c8Z4r,
                       label: block_c8Z4r_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z4r: // global
           I64[Sp] = R1;
           call _c8Z4s() args: 0, res: 0, upd: 0;
     }
 },
 _c8Z4v() //  [R1]
         { info_tbl: [(c8Z4v,
                       label: block_c8Z4v_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z4v: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Z4R() //  [R1]
         { info_tbl: [(c8Z4R,
                       label: block_c8Z4R_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z4R: // global
           _s8YAv::I64 = I64[Sp + 16];
           _s8YAz::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s8YAv::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s8YAz::P64;
           I64[Sp + 16] = _s8YAv::I64 + 1;
           Sp = Sp + 8;
           call _c8Z4D() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.554587106 UTC

[section ""data" . Foreign.C.String.withCAString_closure" {
     Foreign.C.String.withCAString_closure:
         const Foreign.C.String.withCAString_info;
 },
 Foreign.C.String.withCAString_entry() //  [R2, R3]
         { info_tbl: [(c8Z5m,
                       label: Foreign.C.String.withCAString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z5m: // global
           R3 = R3;
           R2 = R2;
           call Foreign.C.String.withCAString1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.556123854 UTC

[section ""data" . Foreign.C.String.withCAStringLen1_closure" {
     Foreign.C.String.withCAStringLen1_closure:
         const Foreign.C.String.withCAStringLen1_info;
 },
 Foreign.C.String.withCAStringLen1_entry() //  [R2, R3]
         { info_tbl: [(c8Z5v,
                       label: Foreign.C.String.withCAStringLen1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z5v: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8Z5w; else goto c8Z5x;
       c8Z5w: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.withCAStringLen1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Z5x: // global
           I64[Sp - 24] = block_c8Z5t_info;
           _s8YAH::P64 = R3;
           R3 = 0;
           _s8YAG::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s8YAG::P64;
           P64[Sp - 8] = _s8YAH::P64;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z5t() //  [R1]
         { info_tbl: [(c8Z5t,
                       label: block_c8Z5t_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z5t: // global
           I64[Sp - 8] = block_c8Z5A_info;
           R2 = 1;
           _s8YAJ::I64 = R1;
           R1 = R1;
           I64[Sp] = _s8YAJ::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z5A() //  [R1]
         { info_tbl: [(c8Z5A,
                       label: block_c8Z5A_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z5A: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c8Z5X() args: 0, res: 0, upd: 0;
     }
 },
 _c8Z5X() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z5X: // global
           _s8YB1::P64 = P64[Sp];
           I64[Sp] = block_c8Z60_info;
           R1 = _s8YB1::P64;
           if (R1 & 7 != 0) goto u8Z6w; else goto c8Z62;
       u8Z6w: // global
           call _c8Z60(R1) args: 0, res: 0, upd: 0;
       c8Z62: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z60() //  [R1]
         { info_tbl: [(c8Z60,
                       label: block_c8Z60_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z60: // global
           if (R1 & 7 == 1) goto u8Z6t; else goto c8Z6d;
       u8Z6t: // global
           Sp = Sp + 8;
           call _c8Z5K() args: 0, res: 0, upd: 0;
       c8Z6d: // global
           I64[Sp - 8] = block_c8Z6b_info;
           _s8YB6::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8YB6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Z6x; else goto c8Z6e;
       u8Z6x: // global
           call _c8Z6b(R1) args: 0, res: 0, upd: 0;
       c8Z6e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z5K() //  []
         { info_tbl: [(c8Z5K,
                       label: block_c8Z5K_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z5K: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Z5S; else goto c8Z5R;
       c8Z5S: // global
           HpAlloc = 56;
           I64[Sp] = block_c8Z5K_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Z5R: // global
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = I64[Sp + 16];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           I64[Sp + 16] = block_c8Z5P_info;
           R2 = Hp - 15;
           R1 = P64[Sp + 32];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z5P() //  [R1]
         { info_tbl: [(c8Z5P,
                       label: block_c8Z5P_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z5P: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Z6b() //  [R1]
         { info_tbl: [(c8Z6b,
                       label: block_c8Z6b_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z6b: // global
           _s8YB2::I64 = I64[Sp + 16];
           _s8YB6::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s8YB2::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s8YB6::P64;
           I64[Sp + 16] = _s8YB2::I64 + 1;
           Sp = Sp + 8;
           call _c8Z5X() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.558414747 UTC

[section ""data" . Foreign.C.String.withCAStringLen_closure" {
     Foreign.C.String.withCAStringLen_closure:
         const Foreign.C.String.withCAStringLen_info;
 },
 Foreign.C.String.withCAStringLen_entry() //  [R2, R3]
         { info_tbl: [(c8Z6E,
                       label: Foreign.C.String.withCAStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z6E: // global
           R3 = R3;
           R2 = R2;
           call Foreign.C.String.withCAStringLen1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.559138138 UTC

[section ""relreadonly" . S8YDv_srt" {
     S8YDv_srt:
         const GHC.IO.Encoding.getForeignEncoding_closure;
         const Foreign.C.String.withCStringLen1_closure;
         const Foreign.C.String.withCString1_closure;
         const GHC.Foreign.charIsRepresentable1_closure;
         const Foreign.C.String.charIsRepresentable1_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Alloc.realloc2_closure;
         const Foreign.C.String.newCStringLen1_closure;
         const GHC.Foreign.newCString1_closure;
         const Foreign.C.String.newCString1_closure;
         const GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
         const Foreign.C.String.peekCStringLen1_closure;
         const GHC.Foreign.peekCString1_closure;
         const Foreign.C.String.peekCString1_closure;
         const GHC.Char.$wlvl_closure;
         const Foreign.C.String.castCWcharToChar_closure;
         const Foreign.C.String.peekCWString2_closure;
         const Foreign.C.String.$wpeekCWStringLen_closure;
         const Foreign.C.String.peekCWStringLen1_closure;
         const Foreign.C.String.$wpeekCWString_closure;
         const Foreign.C.String.peekCWString1_closure;
         const Foreign.Marshal.Array.withArrayLen0_closure;
         const Foreign.C.String.withCWString_closure;
         const Foreign.Marshal.Array.newArray3_closure;
         const Foreign.C.String.newCWString1_closure;
         const Foreign.Marshal.Array.newArray1_closure;
         const Foreign.C.String.newCWStringLen1_closure;
         const Foreign.C.String.newCAString1_closure;
         const Foreign.C.String.newCAStringLen1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.559847578 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:04:07.560368242 UTC

[section ""cstring" . Foreign.C.String.$trModule4_bytes" {
     Foreign.C.String.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.56095146 UTC

[section ""data" . Foreign.C.String.$trModule3_closure" {
     Foreign.C.String.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.C.String.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.561702025 UTC

[section ""cstring" . Foreign.C.String.$trModule2_bytes" {
     Foreign.C.String.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,67,46,83,116,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.562226365 UTC

[section ""data" . Foreign.C.String.$trModule1_closure" {
     Foreign.C.String.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.C.String.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.562767594 UTC

[section ""data" . Foreign.C.String.$trModule_closure" {
     Foreign.C.String.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.C.String.$trModule3_closure+1;
         const Foreign.C.String.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.566734856 UTC

[section ""data" . Foreign.C.String.withCStringLen1_closure" {
     Foreign.C.String.withCStringLen1_closure:
         const Foreign.C.String.withCStringLen1_info;
         const 0;
 },
 $wgo_s8YpD_entry() //  [R1, R2]
         { info_tbl: [(c8Z7s,
                       label: $wgo_s8YpD_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z7s: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8Z7t; else goto c8Z7u;
       c8Z7t: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Z7u: // global
           I64[Sp - 48] = block_c8Z7n_info;
           _s8YpD::P64 = R1;
           _s8Ypc::P64 = P64[R1 + 6];
           _s8Ypl::P64 = P64[R1 + 14];
           _s8YpC::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 40] = _s8Ypc::P64;
           P64[Sp - 32] = _s8Ypl::P64;
           P64[Sp - 24] = _s8YpC::P64;
           P64[Sp - 16] = _s8YpD::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 48;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z7n() //  [R1]
         { info_tbl: [(c8Z7n,
                       label: block_c8Z7n_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z7n: // global
           I64[Sp] = block_c8Z7p_info;
           _s8YpL::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8YpL::P64;
           if (R1 & 7 != 0) goto u8Z83; else goto c8Z7q;
       u8Z83: // global
           call _c8Z7p(R1) args: 0, res: 0, upd: 0;
       c8Z7q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z7p() //  [R1]
         { info_tbl: [(c8Z7p,
                       label: block_c8Z7p_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z7p: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Z7A; else goto c8Z7z;
       c8Z7A: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Z7z: // global
           _s8YpN::P64 = P64[R1 + 7];
           _s8YpO::P64 = P64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 40];
           _s8Ypc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Z7F_info;
           R6 = P64[Sp + 16] + 16;
           R5 = P64[Sp + 24];
           R4 = GHC.Types.False_closure+1;
           R3 = _s8YpO::P64;
           R2 = _s8YpN::P64;
           P64[Sp - 8] = Hp - 7;
           P64[Sp] = _s8Ypc::P64;
           Sp = Sp - 8;
           call GHC.Foreign.$wtryFillBufferAndCall_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8Z7F() //  [R1]
         { info_tbl: [(c8Z7F,
                       label: block_c8Z7F_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z7F: // global
           I64[Sp] = block_c8Z7H_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8Z84; else goto c8Z7J;
       u8Z84: // global
           call _c8Z7H(R1) args: 0, res: 0, upd: 0;
       c8Z7J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z7H() //  [R1]
         { info_tbl: [(c8Z7H,
                       label: block_c8Z7H_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z7H: // global
           if (R1 & 7 == 1) goto c8Z7T; else goto c8Z7Z;
       c8Z7T: // global
           I64[Sp] = block_c8Z7R_info;
           R2 = I64[Sp + 32] << 1;
           R1 = P64[Sp + 24];
           call $wgo_s8YpD_entry(R2, R1) args: 8, res: 8, upd: 8;
       c8Z7Z: // global
           _s8Yq3::P64 = P64[R1 + 6];
           call MO_Touch(P64[Sp + 8]);
           R1 = _s8Yq3::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Z7R() //  [R1]
         { info_tbl: [(c8Z7R,
                       label: block_c8Z7R_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z7R: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Yql_entry() //  [R1, R2]
         { info_tbl: [(c8Z85,
                       label: sat_s8Yql_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z85: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8Z86; else goto c8Z87;
       c8Z86: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Z87: // global
           I64[Sp - 32] = block_c8Z6X_info;
           R3 = 0;
           _s8Ypl::P64 = R2;
           _s8Ypb::P64 = P64[R1 + 6];
           R2 = _s8Ypb::P64;
           P64[Sp - 24] = _s8Ypb::P64;
           P64[Sp - 16] = P64[R1 + 14];
           P64[Sp - 8] = _s8Ypl::P64;
           Sp = Sp - 32;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z6X() //  [R1]
         { info_tbl: [(c8Z6X,
                       label: block_c8Z6X_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z6X: // global
           I64[Sp - 8] = block_c8Z74_info;
           R2 = 4;
           _s8Ypn::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8Ypn::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z74() //  [R1]
         { info_tbl: [(c8Z74,
                       label: block_c8Z74_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z74: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c8Z8m() args: 0, res: 0, upd: 0;
     }
 },
 _c8Z8m() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z8m: // global
           _s8Yqb::P64 = P64[Sp];
           I64[Sp] = block_c8Z8p_info;
           R1 = _s8Yqb::P64;
           if (R1 & 7 != 0) goto u8Z8O; else goto c8Z8r;
       u8Z8O: // global
           call _c8Z8p(R1) args: 0, res: 0, upd: 0;
       c8Z8r: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z8p() //  [R1]
         { info_tbl: [(c8Z8p,
                       label: block_c8Z8p_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z8p: // global
           if (R1 & 7 == 1) goto c8Z8x; else goto c8Z8C;
       c8Z8x: // global
           I64[Sp + 8] = block_c8Z7e_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8Z8C: // global
           I64[Sp - 8] = block_c8Z8A_info;
           _s8Yqg::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8Yqg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Z8P; else goto c8Z8D;
       u8Z8P: // global
           call _c8Z8A(R1) args: 0, res: 0, upd: 0;
       c8Z8D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z7e() //  [R1]
         { info_tbl: [(c8Z7e,
                       label: block_c8Z7e_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z7e: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c8Z8d; else goto c8Z8c;
       c8Z8d: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Z8c: // global
           I64[Hp - 96] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 88] = R1;
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = Hp - 95;
           P64[Hp - 64] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 56] = I64[Sp + 8];
           _s8Ypn::I64 = I64[Sp + 16];
           I64[Hp - 48] = _s8Ypn::I64;
           I64[Hp - 40] = 0;
           I64[Hp - 32] = _s8Ypn::I64;
           I64[Hp - 24] = $wgo_s8YpD_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = Hp - 79;
           I64[Sp + 16] = block_c8Z8h_info;
           R2 = _s8Ypn::I64 + 1;
           R1 = Hp - 22;
           Sp = Sp + 16;
           call $wgo_s8YpD_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z8h() //  [R1]
         { info_tbl: [(c8Z8h,
                       label: block_c8Z8h_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z8h: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Z8A() //  [R1]
         { info_tbl: [(c8Z8A,
                       label: block_c8Z8A_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z8A: // global
           _s8Yqc::I64 = I64[Sp + 16];
           _s8Yqg::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8Yqc::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8Yqg::P64;
           I64[Sp + 16] = _s8Yqc::I64 + 1;
           Sp = Sp + 8;
           call _c8Z8m() args: 0, res: 0, upd: 0;
     }
 },
 Foreign.C.String.withCStringLen1_entry() //  [R2, R3]
         { info_tbl: [(c8Z8R,
                       label: Foreign.C.String.withCStringLen1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z8R: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Z8S; else goto c8Z8T;
       c8Z8S: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.withCStringLen1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Z8T: // global
           I64[Sp - 24] = block_c8Z6L_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z6L() //  [R1]
         { info_tbl: [(c8Z6L,
                       label: block_c8Z6L_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z6L: // global
           I64[Sp] = block_c8Z6N_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8Z8Y; else goto c8Z6O;
       u8Z8Y: // global
           call _c8Z6N(R1) args: 0, res: 0, upd: 0;
       c8Z6O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z6N() //  [R1]
         { info_tbl: [(c8Z6N,
                       label: block_c8Z6N_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z6N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8Z8X; else goto c8Z8W;
       c8Z8X: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Z8W: // global
           _s8Ypk::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_s8Yql_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8Ypk::P64;
           Sp = Sp + 24;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.571408418 UTC

[section ""data" . Foreign.C.String.withCStringLen_closure" {
     Foreign.C.String.withCStringLen_closure:
         const Foreign.C.String.withCStringLen_info;
         const 0;
 },
 Foreign.C.String.withCStringLen_entry() //  [R2, R3]
         { info_tbl: [(c8Z93,
                       label: Foreign.C.String.withCStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z93: // global
           R3 = R3;
           R2 = R2;
           call Foreign.C.String.withCStringLen1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.572333331 UTC

[section ""data" . Foreign.C.String.withCString1_closure" {
     Foreign.C.String.withCString1_closure:
         const Foreign.C.String.withCString1_info;
         const 0;
 },
 Foreign.C.String.withCString1_entry() //  [R2, R3]
         { info_tbl: [(c8Z9c,
                       label: Foreign.C.String.withCString1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z9c: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Z9d; else goto c8Z9e;
       c8Z9d: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.withCString1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Z9e: // global
           I64[Sp - 24] = block_c8Z9a_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z9a() //  [R1]
         { info_tbl: [(c8Z9a,
                       label: block_c8Z9a_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z9a: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.573669457 UTC

[section ""data" . Foreign.C.String.withCString_closure" {
     Foreign.C.String.withCString_closure:
         const Foreign.C.String.withCString_info;
         const 0;
 },
 Foreign.C.String.withCString_entry() //  [R2, R3]
         { info_tbl: [(c8Z9k,
                       label: Foreign.C.String.withCString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z9k: // global
           R3 = R3;
           R2 = R2;
           call Foreign.C.String.withCString1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.574608774 UTC

[section ""data" . Foreign.C.String.charIsRepresentable1_closure" {
     Foreign.C.String.charIsRepresentable1_closure:
         const Foreign.C.String.charIsRepresentable1_info;
         const 0;
 },
 Foreign.C.String.charIsRepresentable1_entry() //  [R2]
         { info_tbl: [(c8Z9t,
                       label: Foreign.C.String.charIsRepresentable1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z9t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Z9u; else goto c8Z9v;
       c8Z9u: // global
           R2 = R2;
           R1 = Foreign.C.String.charIsRepresentable1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Z9v: // global
           I64[Sp - 16] = block_c8Z9r_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z9r() //  [R1]
         { info_tbl: [(c8Z9r,
                       label: block_c8Z9r_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z9r: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.575697168 UTC

[section ""data" . Foreign.C.String.charIsRepresentable_closure" {
     Foreign.C.String.charIsRepresentable_closure:
         const Foreign.C.String.charIsRepresentable_info;
         const 0;
 },
 Foreign.C.String.charIsRepresentable_entry() //  [R2]
         { info_tbl: [(c8Z9B,
                       label: Foreign.C.String.charIsRepresentable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z9B: // global
           R2 = R2;
           call Foreign.C.String.charIsRepresentable1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.576425251 UTC

[section ""data" . Foreign.C.String.newCStringLen2_closure" {
     Foreign.C.String.newCStringLen2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.580923051 UTC

[section ""data" . Foreign.C.String.newCStringLen1_closure" {
     Foreign.C.String.newCStringLen1_closure:
         const Foreign.C.String.newCStringLen1_info;
         const 0;
 },
 sat_s8Ysq_entry() //  [R1]
         { info_tbl: [(c8Zbh,
                       label: sat_s8Ysq_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zbh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8Zbm; else goto c8Zbn;
       c8Zbm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Zbn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c8Zbe_info;
           _s8Yrl::P64 = P64[R1 + 24];
           _s8Yra::I64 = I64[R1 + 32];
           R1 = P64[R1 + 16];
           I64[Sp - 32] = _s8Yra::I64;
           P64[Sp - 24] = _s8Yrl::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8Zbr; else goto c8Zbf;
       u8Zbr: // global
           call _c8Zbe(R1) args: 0, res: 0, upd: 0;
       c8Zbf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8Zbe() //  [R1]
         { info_tbl: [(c8Zbe,
                       label: block_c8Zbe_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zbe: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8Zbq; else goto c8Zbp;
       c8Zbq: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8Zbp: // global
           _s8Yso::I64 = I64[R1 + 7];
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 16];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s8Yso::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8YsE_entry() //  [R1, R2]
         { info_tbl: [(c8Zbs,
                       label: sat_s8YsE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zbs: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8Zbt; else goto c8Zbu;
       c8Zbt: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Zbu: // global
           I64[Sp - 24] = block_c8Z9U_info;
           R3 = 0;
           _s8YqG::P64 = R2;
           _s8Yqx::P64 = P64[R1 + 6];
           R2 = _s8Yqx::P64;
           P64[Sp - 16] = _s8Yqx::P64;
           P64[Sp - 8] = _s8YqG::P64;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z9U() //  [R1]
         { info_tbl: [(c8Z9U,
                       label: block_c8Z9U_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z9U: // global
           I64[Sp - 8] = block_c8Za1_info;
           R2 = 4;
           _s8YqI::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8YqI::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Za1() //  [R1]
         { info_tbl: [(c8Za1,
                       label: block_c8Za1_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Za1: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c8Zdi() args: 0, res: 0, upd: 0;
     }
 },
 _c8Zdi() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zdi: // global
           _s8Ysu::P64 = P64[Sp];
           I64[Sp] = block_c8Zdl_info;
           R1 = _s8Ysu::P64;
           if (R1 & 7 != 0) goto u8Zel; else goto c8Zdn;
       u8Zel: // global
           call _c8Zdl(R1) args: 0, res: 0, upd: 0;
       c8Zdn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zdl() //  [R1]
         { info_tbl: [(c8Zdl,
                       label: block_c8Zdl_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zdl: // global
           if (R1 & 7 == 1) goto c8Zdt; else goto c8Zdy;
       c8Zdt: // global
           I64[Sp + 8] = block_c8Zab_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8Zdy: // global
           I64[Sp - 8] = block_c8Zdw_info;
           _s8Ysz::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8Ysz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Zem; else goto c8Zdz;
       u8Zem: // global
           call _c8Zdw(R1) args: 0, res: 0, upd: 0;
       c8Zdz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zab() //  [R1]
         { info_tbl: [(c8Zab,
                       label: block_c8Zab_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zab: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8ZbA; else goto c8Zbz;
       c8ZbA: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Zbz: // global
           _s8YqI::I64 = I64[Sp + 16];
           _s8YqQ::I64 = I64[Sp + 8];
           _s8YqW::I64 = _s8YqI::I64 + 1;
           (_s8Yr1::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(_s8YqW::I64);
           if (_s8Yr1::I64 == 0) goto c8Zdf; else goto c8Zde;
       c8Zdf: // global
           Hp = Hp - 88;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Zde: // global
           I64[Hp - 80] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 72] = R1;
           I64[Hp - 64] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 40] = _s8YqQ::I64;
           I64[Hp - 32] = _s8YqI::I64;
           I64[Hp - 24] = 0;
           I64[Hp - 16] = _s8YqI::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8YqW::I64;
           P64[Sp] = Hp - 7;
           I64[Sp + 8] = _s8Yr1::I64;
           P64[Sp + 16] = Hp - 63;
           call _c8Zav() args: 0, res: 0, upd: 0;
     }
 },
 _c8Zav() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zav: // global
           I64[Sp - 8] = block_c8Zay_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Ze6; else goto c8Zaz;
       u8Ze6: // global
           call _c8Zay(R1) args: 0, res: 0, upd: 0;
       c8Zaz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zay() //  [R1]
         { info_tbl: [(c8Zay,
                       label: block_c8Zay_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zay: // global
           I64[Sp - 16] = block_c8ZaD_info;
           _s8Yre::P64 = P64[R1 + 7];
           _s8Yrf::P64 = P64[R1 + 15];
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 8] = _s8Yrf::P64;
           P64[Sp] = _s8Yre::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZaD() //  [R1]
         { info_tbl: [(c8ZaD,
                       label: block_c8ZaD_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZaD: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8ZbJ; else goto c8ZbI;
       c8ZbJ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZbI: // global
           I64[Hp - 32] = sat_s8Ysq_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 32];
           P64[Sp - 8] = Hp - 32;
           P64[Sp] = P64[Sp + 40];
           Sp = Sp - 8;
           call _c8Zcu() args: 0, res: 0, upd: 0;
     }
 },
 _c8Zcu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zcu: // global
           _s8YrY::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8Zcw_info;
           R3 = P64[Sp];
           R2 = _s8YrY::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zcw() //  [R1]
         { info_tbl: [(c8Zcw,
                       label: block_c8Zcw_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zcw: // global
           I64[Sp] = block_c8Zcy_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8Zee; else goto c8Zcz;
       u8Zee: // global
           call _c8Zcy(R1) args: 0, res: 0, upd: 0;
       c8Zcz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zcy() //  [R1]
         { info_tbl: [(c8Zcy,
                       label: block_c8Zcy_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zcy: // global
           I64[Sp - 16] = block_c8ZcD_info;
           _s8Ys5::P64 = P64[R1 + 7];
           _s8Ys7::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8Ys7::P64;
           P64[Sp] = _s8Ys5::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8Zef; else goto c8ZcH;
       u8Zef: // global
           call _c8ZcD(R1) args: 0, res: 0, upd: 0;
       c8ZcH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZcD() //  [R1]
         { info_tbl: [(c8ZcD,
                       label: block_c8ZcD_info
                       rep:StackRep [False, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZcD: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8Zdc; else goto c8ZcR;
       c8Zdc: // global
           I64[Sp + 32] = block_c8Zci_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8Zeh; else goto c8Zck;
       u8Zeh: // global
           call _c8Zci(R1) args: 0, res: 0, upd: 0;
       c8Zck: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ZcR: // global
           I64[Sp] = block_c8ZcP_info;
           _s8Ys8::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8Ys8::P64;
           if (R1 & 7 != 0) goto u8Zeg; else goto c8ZcS;
       u8Zeg: // global
           call _c8ZcP(R1) args: 0, res: 0, upd: 0;
       c8ZcS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zci() //  [R1]
         { info_tbl: [(c8Zci,
                       label: block_c8Zci_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zci: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8Zcq; else goto c8Zcp;
       c8Zcq: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Zcp: // global
           _s8YrL::I64 = I64[R1 + 23];
           _s8YrP::I64 = I64[R1 + 39];
           _s8YrQ::I64 = I64[R1 + 47];
           call MO_Touch(P64[R1 + 7]);
           I64[Hp - 64] = GHC.Types.I#_con_info;
           I64[Hp - 56] = _s8YrQ::I64 - _s8YrP::I64;
           I64[Hp - 48] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 40] = _s8YrL::I64;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 63;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           P64[Sp] = Hp - 6;
           call _s8Yrm() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZcP() //  [R1]
         { info_tbl: [(c8ZcP,
                       label: block_c8ZcP_info
                       rep:StackRep [False, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZcP: // global
           if (R1 & 7 == 2) goto c8Zdb; else goto c8Zd1;
       c8Zdb: // global
           P64[Sp + 32] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call _s8Yrm() args: 0, res: 0, upd: 0;
       c8Zd1: // global
           _s8Ys8::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8ZcW_info;
           R3 = P64[Sp + 8];
           R2 = _s8Ys8::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _s8Yrm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8Yrm: // global
           _s8Yro::P64 = P64[Sp];
           I64[Sp] = block_c8ZaM_info;
           R1 = _s8Yro::P64;
           if (R1 & 7 != 0) goto u8Zeo; else goto c8ZaN;
       u8Zeo: // global
           call _c8ZaM(R1) args: 0, res: 0, upd: 0;
       c8ZaN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZaM() //  [R1]
         { info_tbl: [(c8ZaM,
                       label: block_c8ZaM_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZaM: // global
           if (R1 & 7 == 1) goto c8ZbN; else goto c8Zc6;
       c8ZbN: // global
           _s8Yrb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8ZaR_info;
           R1 = _s8Yrb::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8Ze8; else goto c8ZaS;
       u8Ze8: // global
           call _c8ZaR(R1) args: 0, res: 0, upd: 0;
       c8ZaS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8Zc6: // global
           _s8Yr7::P64 = P64[R1 + 6];
           call MO_Touch(P64[Sp + 32]);
           R1 = _s8Yr7::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ZaR() //  [R1]
         { info_tbl: [(c8ZaR,
                       label: block_c8ZaR_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZaR: // global
           _s8Yrs::I64 = I64[R1 + 7] << 1;
           if (_s8Yrs::I64 != 0) goto u8Ze0; else goto c8ZbZ;
       u8Ze0: // global
           I64[Sp] = _s8Yrs::I64;
           call _c8Zb0() args: 0, res: 0, upd: 0;
       c8ZbZ: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[Sp + 8]);
           I64[Sp + 8] = 0;
           P64[Sp] = Foreign.C.String.newCStringLen2_closure+1;
           call _c8Zav() args: 0, res: 0, upd: 0;
     }
 },
 _c8Zb0() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zb0: // global
           Hp = Hp + 16;
           _s8Yrs::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c8ZbT; else goto c8ZbS;
       c8ZbT: // global
           HpAlloc = 16;
           I64[Sp] = block_c8ZaZ_info;
           R1 = _s8Yrs::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8ZbS: // global
           (_s8Yrx::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp + 8], _s8Yrs::I64);
           if (_s8Yrx::I64 == 0) goto c8ZbW; else goto c8ZbV;
       c8ZbW: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8ZbV: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8Yrs::I64;
           I64[Sp + 8] = _s8Yrx::I64;
           P64[Sp] = Hp - 7;
           call _c8Zav() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZaZ() //  [R1]
         { info_tbl: [(c8ZaZ,
                       label: block_c8ZaZ_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZaZ: // global
           I64[Sp] = R1;
           call _c8Zb0() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZcW() //  [R1]
         { info_tbl: [(c8ZcW,
                       label: block_c8ZcW_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZcW: // global
           I64[Sp] = block_c8ZcY_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8Zej; else goto c8Zd3;
       u8Zej: // global
           call _c8ZcY(R1) args: 0, res: 0, upd: 0;
       c8Zd3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZcY() //  [R1]
         { info_tbl: [(c8ZcY,
                       label: block_c8ZcY_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZcY: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 8;
           call _c8Zcu() args: 0, res: 0, upd: 0;
     }
 },
 _c8Zdw() //  [R1]
         { info_tbl: [(c8Zdw,
                       label: block_c8Zdw_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zdw: // global
           _s8Ysv::I64 = I64[Sp + 16];
           _s8Ysz::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8Ysv::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8Ysz::P64;
           I64[Sp + 16] = _s8Ysv::I64 + 1;
           Sp = Sp + 8;
           call _c8Zdi() args: 0, res: 0, upd: 0;
     }
 },
 Foreign.C.String.newCStringLen1_entry() //  [R2]
         { info_tbl: [(c8Zep,
                       label: Foreign.C.String.newCStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zep: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Zeq; else goto c8Zer;
       c8Zeq: // global
           R2 = R2;
           R1 = Foreign.C.String.newCStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Zer: // global
           I64[Sp - 16] = block_c8Z9I_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z9I() //  [R1]
         { info_tbl: [(c8Z9I,
                       label: block_c8Z9I_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z9I: // global
           I64[Sp] = block_c8Z9K_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8Zew; else goto c8Z9L;
       u8Zew: // global
           call _c8Z9K(R1) args: 0, res: 0, upd: 0;
       c8Z9L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Z9K() //  [R1]
         { info_tbl: [(c8Z9K,
                       label: block_c8Z9K_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Z9K: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Zev; else goto c8Zeu;
       c8Zev: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Zeu: // global
           _s8YqF::P64 = P64[R1 + 23];
           I64[Hp - 8] = sat_s8YsE_info;
           P64[Hp] = P64[Sp + 8];
           R4 = Hp - 6;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8YqF::P64;
           Sp = Sp + 16;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.590602067 UTC

[section ""data" . Foreign.C.String.newCStringLen_closure" {
     Foreign.C.String.newCStringLen_closure:
         const Foreign.C.String.newCStringLen_info;
         const 0;
 },
 Foreign.C.String.newCStringLen_entry() //  [R2]
         { info_tbl: [(c8ZeB,
                       label: Foreign.C.String.newCStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZeB: // global
           R2 = R2;
           call Foreign.C.String.newCStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.591527669 UTC

[section ""data" . Foreign.C.String.newCString1_closure" {
     Foreign.C.String.newCString1_closure:
         const Foreign.C.String.newCString1_info;
         const 0;
 },
 Foreign.C.String.newCString1_entry() //  [R2]
         { info_tbl: [(c8ZeK,
                       label: Foreign.C.String.newCString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZeK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ZeL; else goto c8ZeM;
       c8ZeL: // global
           R2 = R2;
           R1 = Foreign.C.String.newCString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZeM: // global
           I64[Sp - 16] = block_c8ZeI_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZeI() //  [R1]
         { info_tbl: [(c8ZeI,
                       label: block_c8ZeI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZeI: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.newCString1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.592600903 UTC

[section ""data" . Foreign.C.String.newCString_closure" {
     Foreign.C.String.newCString_closure:
         const Foreign.C.String.newCString_info;
         const 0;
 },
 Foreign.C.String.newCString_entry() //  [R2]
         { info_tbl: [(c8ZeS,
                       label: Foreign.C.String.newCString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZeS: // global
           R2 = R2;
           call Foreign.C.String.newCString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.597196531 UTC

[section ""data" . Foreign.C.String.peekCStringLen1_closure" {
     Foreign.C.String.peekCStringLen1_closure:
         const Foreign.C.String.peekCStringLen1_info;
         const 0;
 },
 sat_s8Yu1_entry() //  [R1]
         { info_tbl: [(c8Zhc,
                       label: sat_s8Yu1_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zhc: // global
           _s8Yu1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Zhd; else goto c8Zhe;
       c8Zhe: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Zhg; else goto c8Zhf;
       c8Zhg: // global
           HpAlloc = 40;
           goto c8Zhd;
       c8Zhd: // global
           R1 = _s8Yu1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Zhf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Yu1::P64;
           _s8YtQ::P64 = P64[_s8Yu1::P64 + 16];
           _s8YtY::P64 = P64[_s8Yu1::P64 + 24];
           _s8YtU::I64 = I64[_s8Yu1::P64 + 32];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8YtU::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YtQ::P64;
           R3 = _s8YtY::P64;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Yui_entry() //  [R1]
         { info_tbl: [(c8Zhp,
                       label: sat_s8Yui_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zhp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Zhq; else goto c8Zhr;
       c8Zhq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Zhr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 $wgo_s8Yti_entry() //  [R1, R2]
         { info_tbl: [(c8Zhs,
                       label: $wgo_s8Yti_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zhs: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8Zht; else goto c8Zhu;
       c8Zht: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Zhu: // global
           I64[Sp - 32] = block_c8ZfR_info;
           _s8Yti::P64 = R1;
           _s8Yth::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 24] = _s8Yth::P64;
           P64[Sp - 16] = _s8Yti::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8Zj4; else goto c8ZfS;
       u8Zj4: // global
           call _c8ZfR(R1) args: 0, res: 0, upd: 0;
       c8ZfS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZfR() //  [R1]
         { info_tbl: [(c8ZfR,
                       label: block_c8ZfR_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZfR: // global
           _s8Yth::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8ZfW_info;
           R3 = _s8Yth::P64;
           R2 = P64[Sp + 24];
           _s8Ytn::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 24] = _s8Ytn::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZfW() //  [R1]
         { info_tbl: [(c8ZfW,
                       label: block_c8ZfW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZfW: // global
           I64[Sp] = block_c8ZfY_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8ZiW; else goto c8ZfZ;
       u8ZiW: // global
           call _c8ZfY(R1) args: 0, res: 0, upd: 0;
       c8ZfZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZfY() //  [R1]
         { info_tbl: [(c8ZfY,
                       label: block_c8ZfY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZfY: // global
           I64[Sp - 16] = block_c8Zg3_info;
           _s8Ytv::P64 = P64[R1 + 7];
           _s8Ytx::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8Ytx::P64;
           P64[Sp] = _s8Ytv::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ZiX; else goto c8Zg4;
       u8ZiX: // global
           call _c8Zg3(R1) args: 0, res: 0, upd: 0;
       c8Zg4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zg3() //  [R1]
         { info_tbl: [(c8Zg3,
                       label: block_c8Zg3_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zg3: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8Zip; else goto c8ZhS;
       c8Zip: // global
           I64[Sp + 32] = block_c8ZgB_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8ZiZ; else goto c8ZgC;
       u8ZiZ: // global
           call _c8ZgB(R1) args: 0, res: 0, upd: 0;
       c8ZgC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ZhS: // global
           I64[Sp] = block_c8Zhz_info;
           _s8Yty::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8Yty::P64;
           if (R1 & 7 != 0) goto u8ZiY; else goto c8ZhT;
       u8ZiY: // global
           call _c8Zhz(R1) args: 0, res: 0, upd: 0;
       c8ZhT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZgB() //  [R1]
         { info_tbl: [(c8ZgB,
                       label: block_c8ZgB_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZgB: // global
           _s8YuG::P64 = P64[R1 + 7];
           _s8YuL::I64 = I64[R1 + 47] - I64[R1 + 39];
           if (%MO_S_Gt_W64(_s8YuL::I64, 0)) goto c8ZiH; else goto c8ZiI;
       c8ZiH: // global
           P64[Sp - 24] = _s8YuG::P64;
           I64[Sp - 16] = _s8YuL::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 32;
           call _c8ZgT() args: 0, res: 0, upd: 0;
       c8ZiI: // global
           call MO_Touch(_s8YuG::P64);
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ZgT() //  []
         { info_tbl: [(c8ZgT,
                       label: block_c8ZgT_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZgT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8ZiC; else goto c8ZiB;
       c8ZiC: // global
           HpAlloc = 40;
           I64[Sp] = block_c8ZgT_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8ZiB: // global
           _s8YuY::P64 = P64[Sp + 24];
           _s8Yv0::I64 = I64[Sp + 16];
           if (_s8Yv0::I64 != 0) goto c8ZiE; else goto c8ZiF;
       c8ZiE: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 32] + (_s8Yv0::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YuY::P64;
           I64[Sp + 16] = _s8Yv0::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           call _c8ZgT() args: 0, res: 0, upd: 0;
       c8ZiF: // global
           Hp = Hp - 40;
           P64[Sp + 24] = _s8YuY::P64;
           Sp = Sp + 8;
           call _c8Zis() args: 0, res: 0, upd: 0;
     }
 },
 _c8Zis() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zis: // global
           Hp = Hp + 40;
           _s8YuO::P64 = P64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c8Ziz; else goto c8Ziy;
       c8Ziz: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_c8Zir_info;
           R1 = _s8YuO::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Ziy: // global
           _s8YuS::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 24]]);
           call MO_Touch(P64[Sp]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8YuS::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YuO::P64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Zir() //  [R1]
         { info_tbl: [(c8Zir,
                       label: block_c8Zir_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zir: // global
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c8Zis() args: 0, res: 0, upd: 0;
     }
 },
 _c8Zhz() //  [R1]
         { info_tbl: [(c8Zhz,
                       label: block_c8Zhz_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zhz: // global
           _s8Ytx::P64 = P64[Sp + 8];
           if (R1 & 7 == 2) goto c8Zij; else goto c8Zi7;
       c8Zij: // global
           I64[Sp + 8] = block_c8Zih_info;
           R1 = _s8Ytx::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8Zj5; else goto c8Zik;
       u8Zj5: // global
           call _c8Zih(R1) args: 0, res: 0, upd: 0;
       c8Zik: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8Zi7: // global
           _s8Yty::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8ZhX_info;
           R3 = _s8Ytx::P64;
           R2 = _s8Yty::P64;
           R1 = P64[Sp + 32];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zih() //  [R1]
         { info_tbl: [(c8Zih,
                       label: block_c8Zih_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zih: // global
           P64[Sp + 24] = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 23];
           P64[Sp - 16] = P64[R1 + 7];
           I64[Sp - 8] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           Sp = Sp - 16;
           call _s8YtG() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZhX() //  [R1]
         { info_tbl: [(c8ZhX,
                       label: block_c8ZhX_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZhX: // global
           I64[Sp] = block_c8ZhZ_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8Zj6; else goto c8Zi0;
       u8Zj6: // global
           call _c8ZhZ(R1) args: 0, res: 0, upd: 0;
       c8Zi0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZhZ() //  [R1]
         { info_tbl: [(c8ZhZ,
                       label: block_c8ZhZ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZhZ: // global
           I64[Sp] = block_c8Zi4_info;
           _s8Yuo::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 16] = _s8Yuo::P64;
           if (R1 & 7 != 0) goto u8Zj7; else goto c8Zia;
       u8Zj7: // global
           call _c8Zi4(R1) args: 0, res: 0, upd: 0;
       c8Zia: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zi4() //  [R1]
         { info_tbl: [(c8Zi4,
                       label: block_c8Zi4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zi4: // global
           P64[Sp - 24] = P64[R1 + 7];
           I64[Sp - 16] = I64[R1 + 39];
           I64[Sp - 8] = I64[R1 + 47];
           I64[Sp] = I64[R1 + 23];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp - 24;
           call _s8YtG() args: 0, res: 0, upd: 0;
     }
 },
 _s8YtG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8YtG: // global
           _s8YtN::I64 = I64[Sp + 16] - I64[Sp + 8];
           if (%MO_S_Gt_W64(_s8YtN::I64, 0)) goto c8ZhM; else goto c8ZhN;
       c8ZhM: // global
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           I64[Sp + 16] = _s8YtN::I64 - 1;
           Sp = Sp - 8;
           call _c8Zgt() args: 0, res: 0, upd: 0;
       c8ZhN: // global
           _s8Yti::P64 = P64[Sp + 32];
           _s8YtI::P64 = P64[Sp + 40];
           call MO_Touch(P64[Sp]);
           I64[Sp + 40] = block_c8Zhj_info;
           R2 = _s8YtI::P64;
           R1 = _s8Yti::P64;
           Sp = Sp + 40;
           call $wgo_s8Yti_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zgt() //  []
         { info_tbl: [(c8Zgt,
                       label: block_c8Zgt_info
                       rep:StackRep [False, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zgt: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8ZhH; else goto c8ZhG;
       c8ZhH: // global
           HpAlloc = 40;
           I64[Sp] = block_c8Zgt_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8ZhG: // global
           _s8YtJ::I64 = I64[Sp + 32];
           _s8Yu4::P64 = P64[Sp + 16];
           _s8Yu6::I64 = I64[Sp + 24];
           if (_s8Yu6::I64 != 0) goto c8ZhJ; else goto c8ZhK;
       c8ZhJ: // global
           _s8Yu9::I64 = %MO_UU_Conv_W32_W64(I32[_s8YtJ::I64 + (_s8Yu6::I64 << 2)]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8Yu9::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8Yu4::P64;
           I64[Sp + 24] = _s8Yu6::I64 - 1;
           P64[Sp + 16] = Hp - 14;
           call _c8Zgt() args: 0, res: 0, upd: 0;
       c8ZhK: // global
           Hp = Hp - 40;
           _s8Yti::P64 = P64[Sp + 40];
           _s8YtI::P64 = P64[Sp + 48];
           _s8YtU::I64 = %MO_UU_Conv_W32_W64(I32[_s8YtJ::I64]);
           call MO_Touch(P64[Sp + 8]);
           I64[Sp + 32] = block_c8Zh4_info;
           R2 = _s8YtI::P64;
           R1 = _s8Yti::P64;
           I64[Sp + 40] = _s8YtU::I64;
           P64[Sp + 48] = _s8Yu4::P64;
           Sp = Sp + 32;
           call $wgo_s8Yti_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zh4() //  [R1]
         { info_tbl: [(c8Zh4,
                       label: block_c8Zh4_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zh4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8ZhE; else goto c8ZhD;
       c8ZhE: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZhD: // global
           I64[Hp - 32] = sat_s8Yu1_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Zhj() //  [R1]
         { info_tbl: [(c8Zhj,
                       label: block_c8Zhj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zhj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8ZhQ; else goto c8ZhP;
       c8ZhQ: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZhP: // global
           I64[Hp - 16] = sat_s8Yui_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Yvd_entry() //  [R1, R2]
         { info_tbl: [(c8Zjc,
                       label: sat_s8Yvd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zjc: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8Zjd; else goto c8Zje;
       c8Zjd: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Zje: // global
           I64[Sp - 24] = block_c8Zfg_info;
           _s8YsV::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 16] = _s8YsV::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8Zjy; else goto c8Zfh;
       u8Zjy: // global
           call _c8Zfg(R1) args: 0, res: 0, upd: 0;
       c8Zfh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zfg() //  [R1]
         { info_tbl: [(c8Zfg,
                       label: block_c8Zfg_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zfg: // global
           I64[Sp - 8] = block_c8Zfl_info;
           _s8YsZ::I64 = I64[R1 + 7];
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp] = _s8YsZ::I64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zfl() //  [R1]
         { info_tbl: [(c8Zfl,
                       label: block_c8Zfl_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zfl: // global
           I64[Sp] = block_c8Zfn_info;
           _s8Yt2::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8Yt2::P64;
           if (R1 & 7 != 0) goto u8Zjx; else goto c8Zfo;
       u8Zjx: // global
           call _c8Zfn(R1) args: 0, res: 0, upd: 0;
       c8Zfo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zfn() //  [R1]
         { info_tbl: [(c8Zfn,
                       label: block_c8Zfn_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zfn: // global
           _s8Yt4::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s8Yt4::I64, 1)) goto c8Zjv; else goto c8Zjw;
       c8Zjv: // global
           _s8Yt6::I64 = _s8Yt4::I64;
           goto s8Yt5;
       c8Zjw: // global
           _s8Yt6::I64 = 1;
           goto s8Yt5;
       s8Yt5: // global
           _s8Yt7::I64 = _s8Yt6::I64 << 2;
           if (%MO_S_Ge_W64(_s8Yt7::I64, 0)) goto c8Zjm; else goto c8Zjr;
       c8Zjm: // global
           I64[Sp - 24] = block_c8ZfD_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = _s8Yt6::I64;
           I64[Sp - 8] = _s8Yt7::I64;
           I64[Sp] = _s8Yt4::I64;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8Zjr: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ZfD() //  [R1]
         { info_tbl: [(c8ZfD,
                       label: block_c8ZfD_info
                       rep:StackRep [True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZfD: // global
           I64[Sp] = block_c8ZfF_info;
           _s8Ytb::P64 = R1;
           R1 = I64[Sp + 16];
           P64[Sp + 16] = _s8Ytb::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZfF() //  [R1]
         { info_tbl: [(c8ZfF,
                       label: block_c8ZfF_info
                       rep:StackRep [True, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZfF: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto c8Zjq; else goto c8Zjp;
       c8Zjq: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Zjp: // global
           I64[Hp - 168] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 160] = R1;
           P64[Hp - 152] = P64[Sp + 16];
           I64[Hp - 144] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 136] = Hp - 166;
           P64[Hp - 128] = GHC.IO.Buffer.WriteBuffer_closure+2;
           P64[Hp - 120] = R1 + 16;
           I64[Hp - 112] = I64[Sp + 8];
           I64[Hp - 104] = 0;
           I64[Hp - 96] = 0;
           I64[Hp - 88] = $wgo_s8Yti_info;
           P64[Hp - 80] = P64[Sp + 48];
           P64[Hp - 72] = Hp - 143;
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 40];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = I64[Sp + 32];
           _s8Yt4::I64 = I64[Sp + 24];
           I64[Hp - 16] = _s8Yt4::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _s8Yt4::I64;
           R2 = Hp - 47;
           R1 = Hp - 86;
           Sp = Sp + 56;
           call $wgo_s8Yti_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.C.String.peekCStringLen1_entry() //  [R2]
         { info_tbl: [(c8Zjz,
                       label: Foreign.C.String.peekCStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zjz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ZjA; else goto c8ZjB;
       c8ZjA: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZjB: // global
           I64[Sp - 16] = block_c8ZeZ_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZeZ() //  [R1]
         { info_tbl: [(c8ZeZ,
                       label: block_c8ZeZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZeZ: // global
           I64[Sp] = block_c8Zf1_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8ZjH; else goto c8Zf2;
       u8ZjH: // global
           call _c8Zf1(R1) args: 0, res: 0, upd: 0;
       c8Zf2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zf1() //  [R1]
         { info_tbl: [(c8Zf1,
                       label: block_c8Zf1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zf1: // global
           I64[Sp] = block_c8Zf6_info;
           _s8YsR::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8YsR::P64;
           if (R1 & 7 != 0) goto u8ZjI; else goto c8Zf7;
       u8ZjI: // global
           call _c8Zf6(R1) args: 0, res: 0, upd: 0;
       c8Zf7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zf6() //  [R1]
         { info_tbl: [(c8Zf6,
                       label: block_c8Zf6_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zf6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8ZjG; else goto c8ZjF;
       c8ZjG: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZjF: // global
           _s8YsU::P64 = P64[R1 + 7];
           _s8YsV::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_s8Yvd_info;
           P64[Hp - 8] = _s8YsU::P64;
           P64[Hp] = _s8YsV::P64;
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.605671782 UTC

[section ""data" . Foreign.C.String.peekCStringLen_closure" {
     Foreign.C.String.peekCStringLen_closure:
         const Foreign.C.String.peekCStringLen_info;
         const 0;
 },
 Foreign.C.String.peekCStringLen_entry() //  [R2]
         { info_tbl: [(c8ZjN,
                       label: Foreign.C.String.peekCStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZjN: // global
           R2 = R2;
           call Foreign.C.String.peekCStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.60657956 UTC

[section ""data" . Foreign.C.String.peekCString1_closure" {
     Foreign.C.String.peekCString1_closure:
         const Foreign.C.String.peekCString1_info;
         const 0;
 },
 Foreign.C.String.peekCString1_entry() //  [R2]
         { info_tbl: [(c8ZjW,
                       label: Foreign.C.String.peekCString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZjW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ZjX; else goto c8ZjY;
       c8ZjX: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZjY: // global
           I64[Sp - 16] = block_c8ZjU_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZjU() //  [R1]
         { info_tbl: [(c8ZjU,
                       label: block_c8ZjU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZjU: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.peekCString1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.607609493 UTC

[section ""data" . Foreign.C.String.peekCString_closure" {
     Foreign.C.String.peekCString_closure:
         const Foreign.C.String.peekCString_info;
         const 0;
 },
 Foreign.C.String.peekCString_entry() //  [R2]
         { info_tbl: [(c8Zk4,
                       label: Foreign.C.String.peekCString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zk4: // global
           R2 = R2;
           call Foreign.C.String.peekCString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.608663563 UTC

[section ""data" . Foreign.C.String.castCSCharToChar_closure" {
     Foreign.C.String.castCSCharToChar_closure:
         const Foreign.C.String.castCSCharToChar_info;
 },
 Foreign.C.String.castCSCharToChar_entry() //  [R2]
         { info_tbl: [(c8Zke,
                       label: Foreign.C.String.castCSCharToChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zke: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8Zku; else goto c8Zkv;
       c8Zku: // global
           R2 = R2;
           R1 = Foreign.C.String.castCSCharToChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Zkv: // global
           I64[Sp - 8] = block_c8Zkb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Zkz; else goto c8Zkc;
       u8Zkz: // global
           call _c8Zkb(R1) args: 0, res: 0, upd: 0;
       c8Zkc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zkb() //  [R1]
         { info_tbl: [(c8Zkb,
                       label: block_c8Zkb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zkb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Zky; else goto c8Zkx;
       c8Zky: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Zkx: // global
           _s8Yvp::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s8Yvp::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.610022635 UTC

[section ""data" . Foreign.C.String.castCUCharToChar_closure" {
     Foreign.C.String.castCUCharToChar_closure:
         const Foreign.C.String.castCUCharToChar_info;
 },
 Foreign.C.String.castCUCharToChar_entry() //  [R2]
         { info_tbl: [(c8ZkH,
                       label: Foreign.C.String.castCUCharToChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZkH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8ZkR; else goto c8ZkS;
       c8ZkR: // global
           R2 = R2;
           R1 = Foreign.C.String.castCUCharToChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZkS: // global
           I64[Sp - 8] = block_c8ZkE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ZkW; else goto c8ZkF;
       u8ZkW: // global
           call _c8ZkE(R1) args: 0, res: 0, upd: 0;
       c8ZkF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZkE() //  [R1]
         { info_tbl: [(c8ZkE,
                       label: block_c8ZkE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZkE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8ZkV; else goto c8ZkU;
       c8ZkV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZkU: // global
           _s8Yvu::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s8Yvu::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.611414582 UTC

[section ""data" . Foreign.C.String.castCCharToChar_closure" {
     Foreign.C.String.castCCharToChar_closure:
         const Foreign.C.String.castCCharToChar_info;
 },
 Foreign.C.String.castCCharToChar_entry() //  [R2]
         { info_tbl: [(c8Zl4,
                       label: Foreign.C.String.castCCharToChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zl4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8Zlk; else goto c8Zll;
       c8Zlk: // global
           R2 = R2;
           R1 = Foreign.C.String.castCCharToChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Zll: // global
           I64[Sp - 8] = block_c8Zl1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Zlp; else goto c8Zl2;
       u8Zlp: // global
           call _c8Zl1(R1) args: 0, res: 0, upd: 0;
       c8Zl2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zl1() //  [R1]
         { info_tbl: [(c8Zl1,
                       label: block_c8Zl1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zl1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Zlo; else goto c8Zln;
       c8Zlo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Zln: // global
           _s8YvB::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s8YvB::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.613393236 UTC

[section ""data" . Foreign.C.String.$wpeekCAString_closure" {
     Foreign.C.String.$wpeekCAString_closure:
         const Foreign.C.String.$wpeekCAString_info;
 },
 Foreign.C.String.$wpeekCAString_entry() //  [R2]
         { info_tbl: [(c8Zm6,
                       label: Foreign.C.String.$wpeekCAString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zm6: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Zm7; else goto c8Zm8;
       c8Zm7: // global
           R2 = R2;
           R1 = Foreign.C.String.$wpeekCAString_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Zm8: // global
           _s8YvC::I64 = R2;
           _s8Yw5::I64 = 0;
           goto c8Zmz;
       c8Zmz: // global
           if (I8[_s8YvC::I64 + _s8Yw5::I64] == 0 :: W8) goto c8ZmF; else goto c8ZmE;
       c8ZmF: // global
           if (%MO_S_Gt_W64(_s8Yw5::I64, 0)) goto c8Zmw; else goto c8Zmx;
       c8Zmw: // global
           I64[Sp - 24] = _s8YvC::I64;
           P64[Sp - 16] = GHC.Types.[]_closure+1;
           I64[Sp - 8] = _s8Yw5::I64 - 1;
           Sp = Sp - 32;
           call _c8ZlH() args: 0, res: 0, upd: 0;
       c8Zmx: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8ZmE: // global
           _s8Yw5::I64 = _s8Yw5::I64 + 1;
           goto c8Zmz;
     }
 },
 _c8ZlH() //  []
         { info_tbl: [(c8ZlH,
                       label: block_c8ZlH_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZlH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Zmc; else goto c8Zmb;
       c8Zmc: // global
           HpAlloc = 40;
           I64[Sp] = block_c8ZlH_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Zmb: // global
           _s8YvJ::P64 = P64[Sp + 16];
           _s8YvK::I64 = I64[Sp + 24];
           _s8YvO::I64 = %MO_SS_Conv_W8_W64(I8[I64[Sp + 8] + _s8YvK::I64]);
           if (%MO_S_Gt_W64(_s8YvK::I64, 0)) goto c8Zme; else goto c8Zmu;
       c8Zme: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s8YvO::I64));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YvJ::P64;
           P64[Sp + 16] = Hp - 14;
           I64[Sp + 24] = _s8YvK::I64 - 1;
           call _c8ZlH() args: 0, res: 0, upd: 0;
       c8Zmu: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s8YvO::I64));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YvJ::P64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.615115066 UTC

[section ""data" . Foreign.C.String.peekCAString1_closure" {
     Foreign.C.String.peekCAString1_closure:
         const Foreign.C.String.peekCAString1_info;
 },
 Foreign.C.String.peekCAString1_entry() //  [R2]
         { info_tbl: [(c8ZmT,
                       label: Foreign.C.String.peekCAString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZmT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8ZmU; else goto c8ZmV;
       c8ZmU: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCAString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZmV: // global
           I64[Sp - 8] = block_c8ZmQ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ZmZ; else goto c8ZmR;
       u8ZmZ: // global
           call _c8ZmQ(R1) args: 0, res: 0, upd: 0;
       c8ZmR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZmQ() //  [R1]
         { info_tbl: [(c8ZmQ,
                       label: block_c8ZmQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZmQ: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call Foreign.C.String.$wpeekCAString_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.61622032 UTC

[section ""data" . Foreign.C.String.peekCAString_closure" {
     Foreign.C.String.peekCAString_closure:
         const Foreign.C.String.peekCAString_info;
 },
 Foreign.C.String.peekCAString_entry() //  [R2]
         { info_tbl: [(c8Zn4,
                       label: Foreign.C.String.peekCAString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zn4: // global
           R2 = R2;
           call Foreign.C.String.peekCAString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.617615773 UTC

[section ""data" . Foreign.C.String.$wpeekCAStringLen_closure" {
     Foreign.C.String.$wpeekCAStringLen_closure:
         const Foreign.C.String.$wpeekCAStringLen_info;
 },
 Foreign.C.String.$wpeekCAStringLen_entry() //  [R2, R3]
         { info_tbl: [(c8ZnN,
                       label: Foreign.C.String.$wpeekCAStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZnN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8ZnO; else goto c8ZnP;
       c8ZnO: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.$wpeekCAStringLen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ZnP: // global
           if (%MO_S_Gt_W64(R3, 0)) goto c8ZnL; else goto c8ZnM;
       c8ZnL: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = GHC.Types.[]_closure+1;
           I64[Sp - 8] = R3 - 1;
           Sp = Sp - 24;
           call _c8Znj() args: 0, res: 0, upd: 0;
       c8ZnM: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Znj() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Znj: // global
           I64[Sp - 8] = block_c8Znm_info;
           R1 = P64[Sp];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Zoe; else goto c8Znn;
       u8Zoe: // global
           call _c8Znm(R1) args: 0, res: 0, upd: 0;
       c8Znn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Znm() //  [R1]
         { info_tbl: [(c8Znm,
                       label: block_c8Znm_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Znm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8ZnT; else goto c8ZnS;
       c8ZnT: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZnS: // global
           _s8Ywl::P64 = P64[Sp + 16];
           _s8Ywm::I64 = I64[Sp + 24];
           _s8Yws::I64 = %MO_SS_Conv_W8_W64(I8[I64[R1 + 7] + _s8Ywm::I64]);
           if (_s8Ywm::I64 == 0) goto c8Zob; else goto c8ZnV;
       c8Zob: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s8Yws::I64));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8Ywl::P64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8ZnV: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s8Yws::I64));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8Ywl::P64;
           P64[Sp + 16] = Hp - 14;
           I64[Sp + 24] = _s8Ywm::I64 - 1;
           Sp = Sp + 8;
           call _c8Znj() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.619397766 UTC

[section ""data" . Foreign.C.String.peekCAStringLen1_closure" {
     Foreign.C.String.peekCAStringLen1_closure:
         const Foreign.C.String.peekCAStringLen1_info;
 },
 Foreign.C.String.peekCAStringLen1_entry() //  [R2]
         { info_tbl: [(c8Zoo,
                       label: Foreign.C.String.peekCAStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zoo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Zos; else goto c8Zot;
       c8Zos: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCAStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Zot: // global
           I64[Sp - 8] = block_c8Zol_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ZoB; else goto c8Zom;
       u8ZoB: // global
           call _c8Zol(R1) args: 0, res: 0, upd: 0;
       c8Zom: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zol() //  [R1]
         { info_tbl: [(c8Zol,
                       label: block_c8Zol_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zol: // global
           I64[Sp - 8] = block_c8Zor_info;
           _s8YwL::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s8YwL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ZoA; else goto c8Zov;
       u8ZoA: // global
           call _c8Zor(R1) args: 0, res: 0, upd: 0;
       c8Zov: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zor() //  [R1]
         { info_tbl: [(c8Zor,
                       label: block_c8Zor_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zor: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.C.String.$wpeekCAStringLen_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.620680636 UTC

[section ""data" . Foreign.C.String.peekCAStringLen_closure" {
     Foreign.C.String.peekCAStringLen_closure:
         const Foreign.C.String.peekCAStringLen_info;
 },
 Foreign.C.String.peekCAStringLen_entry() //  [R2]
         { info_tbl: [(c8ZoG,
                       label: Foreign.C.String.peekCAStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZoG: // global
           R2 = R2;
           call Foreign.C.String.peekCAStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.621715474 UTC

[section ""data" . Foreign.C.String.castCWcharToChar_closure" {
     Foreign.C.String.castCWcharToChar_closure:
         const Foreign.C.String.castCWcharToChar_info;
         const 0;
 },
 Foreign.C.String.castCWcharToChar_entry() //  [R2]
         { info_tbl: [(c8ZoQ,
                       label: Foreign.C.String.castCWcharToChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZoQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8ZoR; else goto c8ZoS;
       c8ZoR: // global
           R2 = R2;
           R1 = Foreign.C.String.castCWcharToChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZoS: // global
           I64[Sp - 8] = block_c8ZoN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Zpc; else goto c8ZoO;
       u8Zpc: // global
           call _c8ZoN(R1) args: 0, res: 0, upd: 0;
       c8ZoO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZoN() //  [R1]
         { info_tbl: [(c8ZoN,
                       label: block_c8ZoN_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZoN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8ZoX; else goto c8ZoW;
       c8ZoX: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZoW: // global
           _s8YwR::I64 = I64[R1 + 7];
           if (_s8YwR::I64 > 1114111) goto c8Zp4; else goto c8Zpb;
       c8Zp4: // global
           Hp = Hp - 16;
           R2 = _s8YwR::I64;
           Sp = Sp + 8;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c8Zpb: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s8YwR::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.623061748 UTC

[section ""data" . Foreign.C.String.peekCWString2_closure" {
     Foreign.C.String.peekCWString2_closure:
         const Foreign.C.String.peekCWString2_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.C.String.peekCWString2_entry() //  [R1]
         { info_tbl: [(c8Zpj,
                       label: Foreign.C.String.peekCWString2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zpj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Zpk; else goto c8Zpl;
       c8Zpk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Zpl: // global
           (_c8Zpg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c8Zpg::I64 == 0) goto c8Zpi; else goto c8Zph;
       c8Zpi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c8Zph: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c8Zpg::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = Foreign.C.String.castCWcharToChar_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.624887506 UTC

[section ""data" . Foreign.C.String.$wpeekCWStringLen_closure" {
     Foreign.C.String.$wpeekCWStringLen_closure:
         const Foreign.C.String.$wpeekCWStringLen_info;
         const 0;
 },
 sat_s8Yx9_entry() //  [R1]
         { info_tbl: [(c8Zq0,
                       label: sat_s8Yx9_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zq0: // global
           _s8Yx9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Zq1; else goto c8Zq2;
       c8Zq2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Zq4; else goto c8Zq3;
       c8Zq4: // global
           HpAlloc = 40;
           goto c8Zq1;
       c8Zq1: // global
           R1 = _s8Yx9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Zq3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Yx9::P64;
           _s8Yx0::P64 = P64[_s8Yx9::P64 + 16];
           _s8Yx6::I64 = I64[_s8Yx9::P64 + 24];
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = _s8Yx6::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8Yx0::P64;
           R3 = Hp - 14;
           R2 = Foreign.C.String.castCWcharToChar_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.C.String.$wpeekCWStringLen_entry() //  [R2, R3]
         { info_tbl: [(c8Zq8,
                       label: Foreign.C.String.$wpeekCWStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zq8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8Zq9; else goto c8Zqa;
       c8Zq9: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.$wpeekCWStringLen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Zqa: // global
           if (%MO_S_Gt_W64(R3, 0)) goto c8Zq6; else goto c8Zq7;
       c8Zq6: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call _c8ZpA() args: 0, res: 0, upd: 0;
       c8Zq7: // global
           R1 = Foreign.C.String.peekCWString2_closure;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ZpA() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZpA: // global
           _s8YwV::P64 = P64[Sp];
           _s8Yxe::I64 = I64[Sp + 8];
           if (_s8Yxe::I64 != 0) goto c8Zqh; else goto c8Zql;
       c8Zqh: // global
           I64[Sp - 8] = block_c8ZpF_info;
           R1 = _s8YwV::P64;
           I64[Sp + 8] = _s8Yxe::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Zqp; else goto c8ZpG;
       u8Zqp: // global
           call _c8ZpF(R1) args: 0, res: 0, upd: 0;
       c8ZpG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8Zql: // global
           I64[Sp + 8] = block_c8ZpP_info;
           R1 = _s8YwV::P64;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8Zqq; else goto c8ZpQ;
       u8Zqq: // global
           call _c8ZpP(R1) args: 0, res: 0, upd: 0;
       c8ZpQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZpF() //  [R1]
         { info_tbl: [(c8ZpF,
                       label: block_c8ZpF_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZpF: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Zqk; else goto c8Zqj;
       c8Zqk: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Zqj: // global
           _s8Yxe::I64 = I64[Sp + 16];
           _s8Yxj::I64 = %MO_SS_Conv_W32_W64(I32[I64[R1 + 7] + (_s8Yxe::I64 << 2)]);
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = _s8Yxj::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 16] = _s8Yxe::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           Sp = Sp + 8;
           call _c8ZpA() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZpP() //  [R1]
         { info_tbl: [(c8ZpP,
                       label: block_c8ZpP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZpP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c8Zqe; else goto c8Zqd;
       c8Zqe: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Zqd: // global
           _s8Yx6::I64 = %MO_SS_Conv_W32_W64(I32[I64[R1 + 7]]);
           I64[Hp - 24] = sat_s8Yx9_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = _s8Yx6::I64;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.627439689 UTC

[section ""data" . Foreign.C.String.peekCWStringLen1_closure" {
     Foreign.C.String.peekCWStringLen1_closure:
         const Foreign.C.String.peekCWStringLen1_info;
         const 0;
 },
 Foreign.C.String.peekCWStringLen1_entry() //  [R2]
         { info_tbl: [(c8ZqA,
                       label: Foreign.C.String.peekCWStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZqA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ZqE; else goto c8ZqF;
       c8ZqE: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCWStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZqF: // global
           I64[Sp - 8] = block_c8Zqx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ZqN; else goto c8Zqy;
       u8ZqN: // global
           call _c8Zqx(R1) args: 0, res: 0, upd: 0;
       c8Zqy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zqx() //  [R1]
         { info_tbl: [(c8Zqx,
                       label: block_c8Zqx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zqx: // global
           I64[Sp - 8] = block_c8ZqD_info;
           _s8Yxr::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s8Yxr::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ZqM; else goto c8ZqH;
       u8ZqM: // global
           call _c8ZqD(R1) args: 0, res: 0, upd: 0;
       c8ZqH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZqD() //  [R1]
         { info_tbl: [(c8ZqD,
                       label: block_c8ZqD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZqD: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.C.String.$wpeekCWStringLen_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.628759577 UTC

[section ""data" . Foreign.C.String.peekCWStringLen_closure" {
     Foreign.C.String.peekCWStringLen_closure:
         const Foreign.C.String.peekCWStringLen_info;
         const 0;
 },
 Foreign.C.String.peekCWStringLen_entry() //  [R2]
         { info_tbl: [(c8ZqS,
                       label: Foreign.C.String.peekCWStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZqS: // global
           R2 = R2;
           call Foreign.C.String.peekCWStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.629668854 UTC

[section ""data" . Foreign.C.String.newCWString3_closure" {
     Foreign.C.String.newCWString3_closure:
         const GHC.Int.I32#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.631198011 UTC

[section ""data" . Foreign.C.String.$wpeekCWString_closure" {
     Foreign.C.String.$wpeekCWString_closure:
         const Foreign.C.String.$wpeekCWString_info;
         const 0;
 },
 sat_s8YxJ_entry() //  [R1]
         { info_tbl: [(c8Zru,
                       label: sat_s8YxJ_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zru: // global
           _s8YxJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8Zrv; else goto c8Zrw;
       c8Zrw: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8Zry; else goto c8Zrx;
       c8Zry: // global
           HpAlloc = 40;
           goto c8Zrv;
       c8Zrv: // global
           R1 = _s8YxJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Zrx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8YxJ::P64;
           _s8YxC::P64 = P64[_s8YxJ::P64 + 16];
           _s8YxG::I64 = I64[_s8YxJ::P64 + 24];
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = _s8YxG::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YxC::P64;
           R3 = Hp - 14;
           R2 = Foreign.C.String.castCWcharToChar_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.C.String.$wpeekCWString_entry() //  [R2]
         { info_tbl: [(c8ZrB,
                       label: Foreign.C.String.$wpeekCWString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZrB: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8ZrC; else goto c8ZrD;
       c8ZrC: // global
           R2 = R2;
           R1 = Foreign.C.String.$wpeekCWString_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZrD: // global
           _s8Yxv::I64 = R2;
           _s8YxX::I64 = 0;
           goto c8ZrS;
       c8ZrS: // global
           if (I32[_s8Yxv::I64 + (_s8YxX::I64 << 2)] == 0 :: W32) goto c8ZrY; else goto c8ZrX;
       c8ZrY: // global
           if (%MO_S_Gt_W64(_s8YxX::I64, 0)) goto c8ZrP; else goto c8ZrQ;
       c8ZrP: // global
           I64[Sp - 24] = _s8Yxv::I64;
           I64[Sp - 16] = _s8YxX::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call _c8Zre() args: 0, res: 0, upd: 0;
       c8ZrQ: // global
           R1 = Foreign.C.String.peekCWString2_closure;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8ZrX: // global
           _s8YxX::I64 = _s8YxX::I64 + 1;
           goto c8ZrS;
     }
 },
 _c8Zre() //  []
         { info_tbl: [(c8Zre,
                       label: block_c8Zre_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zre: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8ZrK; else goto c8ZrJ;
       c8ZrK: // global
           HpAlloc = 40;
           I64[Sp] = block_c8Zre_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8ZrJ: // global
           _s8YxM::P64 = P64[Sp + 24];
           _s8YxO::I64 = I64[Sp + 16];
           if (_s8YxO::I64 != 0) goto c8ZrM; else goto c8ZrN;
       c8ZrM: // global
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W32_W64(I32[I64[Sp + 8] + (_s8YxO::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YxM::P64;
           I64[Sp + 16] = _s8YxO::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           call _c8Zre() args: 0, res: 0, upd: 0;
       c8ZrN: // global
           Hp = Hp - 40;
           P64[Sp + 24] = _s8YxM::P64;
           Sp = Sp + 8;
           call _c8Zrm() args: 0, res: 0, upd: 0;
     }
 },
 _c8Zrm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zrm: // global
           Hp = Hp + 32;
           _s8YxC::P64 = P64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c8ZrH; else goto c8ZrG;
       c8ZrH: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_c8Zrl_info;
           R1 = _s8YxC::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZrG: // global
           I64[Hp - 24] = sat_s8YxJ_info;
           P64[Hp - 8] = _s8YxC::P64;
           I64[Hp] = %MO_SS_Conv_W32_W64(I32[I64[Sp]]);
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Zrl() //  [R1]
         { info_tbl: [(c8Zrl,
                       label: block_c8Zrl_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zrl: // global
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c8Zrm() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.633602919 UTC

[section ""data" . Foreign.C.String.peekCWString1_closure" {
     Foreign.C.String.peekCWString1_closure:
         const Foreign.C.String.peekCWString1_info;
         const 0;
 },
 Foreign.C.String.peekCWString1_entry() //  [R2]
         { info_tbl: [(c8Zsh,
                       label: Foreign.C.String.peekCWString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zsh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8Zsi; else goto c8Zsj;
       c8Zsi: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCWString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Zsj: // global
           I64[Sp - 8] = block_c8Zse_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Zsn; else goto c8Zsf;
       u8Zsn: // global
           call _c8Zse(R1) args: 0, res: 0, upd: 0;
       c8Zsf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zse() //  [R1]
         { info_tbl: [(c8Zse,
                       label: block_c8Zse_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zse: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call Foreign.C.String.$wpeekCWString_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.634733564 UTC

[section ""data" . Foreign.C.String.peekCWString_closure" {
     Foreign.C.String.peekCWString_closure:
         const Foreign.C.String.peekCWString_info;
         const 0;
 },
 Foreign.C.String.peekCWString_entry() //  [R2]
         { info_tbl: [(c8Zss,
                       label: Foreign.C.String.peekCWString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zss: // global
           R2 = R2;
           call Foreign.C.String.peekCWString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.635732981 UTC

[section ""data" . Foreign.C.String.newCWString2_closure" {
     Foreign.C.String.newCWString2_closure:
         const Foreign.C.String.newCWString2_info;
 },
 Foreign.C.String.newCWString2_entry() //  [R2]
         { info_tbl: [(c8ZsC,
                       label: Foreign.C.String.newCWString2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZsC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8ZsM; else goto c8ZsN;
       c8ZsM: // global
           R2 = R2;
           R1 = Foreign.C.String.newCWString2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZsN: // global
           I64[Sp - 8] = block_c8Zsz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ZsR; else goto c8ZsA;
       u8ZsR: // global
           call _c8Zsz(R1) args: 0, res: 0, upd: 0;
       c8ZsA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zsz() //  [R1]
         { info_tbl: [(c8Zsz,
                       label: block_c8Zsz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zsz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8ZsQ; else goto c8ZsP;
       c8ZsQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZsP: // global
           _s8Yyc::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s8Yyc::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.637829624 UTC

[section ""data" . Foreign.C.String.withCWStringLen1_closure" {
     Foreign.C.String.withCWStringLen1_closure:
         const Foreign.C.String.withCWStringLen1_info;
 },
 Foreign.C.String.withCWStringLen1_entry() //  [R2, R3]
         { info_tbl: [(c8ZsY,
                       label: Foreign.C.String.withCWStringLen1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZsY: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8Zt2; else goto c8Zt3;
       c8Zt2: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.withCWStringLen1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8Zt3: // global
           I64[Sp - 16] = block_c8ZsW_info;
           _s8Yye::P64 = R3;
           R3 = R2;
           R2 = Foreign.C.String.newCWString2_closure+1;
           P64[Sp - 8] = _s8Yye::P64;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZsW() //  [R1]
         { info_tbl: [(c8ZsW,
                       label: block_c8ZsW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZsW: // global
           I64[Sp - 8] = block_c8Zt1_info;
           R3 = 0;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zt1() //  [R1]
         { info_tbl: [(c8Zt1,
                       label: block_c8Zt1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zt1: // global
           I64[Sp - 8] = block_c8Ztc_info;
           R2 = 4;
           _s8Yyh::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8Yyh::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ztc() //  [R1]
         { info_tbl: [(c8Ztc,
                       label: block_c8Ztc_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ztc: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c8Zty() args: 0, res: 0, upd: 0;
     }
 },
 _c8Zty() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zty: // global
           _s8YyA::P64 = P64[Sp];
           I64[Sp] = block_c8ZtB_info;
           R1 = _s8YyA::P64;
           if (R1 & 7 != 0) goto u8Zu1; else goto c8ZtD;
       u8Zu1: // global
           call _c8ZtB(R1) args: 0, res: 0, upd: 0;
       c8ZtD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZtB() //  [R1]
         { info_tbl: [(c8ZtB,
                       label: block_c8ZtB_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZtB: // global
           if (R1 & 7 == 1) goto u8ZtY; else goto c8ZtO;
       u8ZtY: // global
           Sp = Sp + 8;
           call _c8Ztl() args: 0, res: 0, upd: 0;
       c8ZtO: // global
           I64[Sp - 8] = block_c8ZtM_info;
           _s8YyF::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8YyF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Zu2; else goto c8ZtP;
       u8Zu2: // global
           call _c8ZtM(R1) args: 0, res: 0, upd: 0;
       c8ZtP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ztl() //  []
         { info_tbl: [(c8Ztl,
                       label: block_c8Ztl_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ztl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8Ztt; else goto c8Zts;
       c8Ztt: // global
           HpAlloc = 56;
           I64[Sp] = block_c8Ztl_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8Zts: // global
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = I64[Sp + 16];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           I64[Sp + 16] = block_c8Ztq_info;
           R2 = Hp - 15;
           R1 = P64[Sp + 32];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Ztq() //  [R1]
         { info_tbl: [(c8Ztq,
                       label: block_c8Ztq_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Ztq: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ZtM() //  [R1]
         { info_tbl: [(c8ZtM,
                       label: block_c8ZtM_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZtM: // global
           _s8YyB::I64 = I64[Sp + 16];
           _s8YyF::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8YyB::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8YyF::P64;
           I64[Sp + 16] = _s8YyB::I64 + 1;
           Sp = Sp + 8;
           call _c8Zty() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.640445683 UTC

[section ""data" . Foreign.C.String.withCWStringLen_closure" {
     Foreign.C.String.withCWStringLen_closure:
         const Foreign.C.String.withCWStringLen_info;
 },
 Foreign.C.String.withCWStringLen_entry() //  [R2, R3]
         { info_tbl: [(c8Zu9,
                       label: Foreign.C.String.withCWStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zu9: // global
           R3 = R3;
           R2 = R2;
           call Foreign.C.String.withCWStringLen1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.643668301 UTC

[section ""data" . Foreign.C.String.withCWString_closure" {
     Foreign.C.String.withCWString_closure:
         const Foreign.C.String.withCWString_info;
         const 0;
 },
 vals_s8YyL_entry() //  [R1]
         { info_tbl: [(c8Zuk,
                       label: vals_s8YyL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zuk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Zul; else goto c8Zum;
       c8Zul: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Zum: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Foreign.C.String.newCWString2_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8YyO_entry() //  [R1]
         { info_tbl: [(c8Zux,
                       label: sat_s8YyO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zux: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8YyP_entry() //  [R1, R2]
         { info_tbl: [(c8ZuA,
                       label: sat_s8YyP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZuA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8ZuE; else goto c8ZuD;
       c8ZuE: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZuD: // global
           _s8YyL::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s8YyO_info;
           P64[Hp] = R2;
           R5 = Hp - 7;
           R4 = _s8YyL::P64;
           R3 = Foreign.C.String.newCWString3_closure+1;
           R2 = Foreign.C.Types.$fStorableCWchar_closure;
           call Foreign.Marshal.Array.withArrayLen0_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.C.String.withCWString_entry() //  [R2]
         { info_tbl: [(c8ZuF,
                       label: Foreign.C.String.withCWString_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZuF: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8ZuJ; else goto c8ZuI;
       c8ZuJ: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.C.String.withCWString_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZuI: // global
           I64[Hp - 32] = vals_s8YyL_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8YyP_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.645369934 UTC

[section ""data" . Foreign.C.String.newCWString1_closure" {
     Foreign.C.String.newCWString1_closure:
         const Foreign.C.String.newCWString1_info;
         const 0;
 },
 Foreign.C.String.newCWString1_entry() //  [R2]
         { info_tbl: [(c8ZuQ,
                       label: Foreign.C.String.newCWString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZuQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8ZuR; else goto c8ZuS;
       c8ZuR: // global
           R2 = R2;
           R1 = Foreign.C.String.newCWString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZuS: // global
           I64[Sp - 8] = block_c8ZuO_info;
           R3 = R2;
           R2 = Foreign.C.String.newCWString2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZuO() //  [R1]
         { info_tbl: [(c8ZuO,
                       label: block_c8ZuO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZuO: // global
           R4 = R1;
           R3 = Foreign.C.String.newCWString3_closure+1;
           R2 = Foreign.C.Types.$fStorableCWchar_closure;
           Sp = Sp + 8;
           call Foreign.Marshal.Array.newArray3_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.646449906 UTC

[section ""data" . Foreign.C.String.newCWString_closure" {
     Foreign.C.String.newCWString_closure:
         const Foreign.C.String.newCWString_info;
         const 0;
 },
 Foreign.C.String.newCWString_entry() //  [R2]
         { info_tbl: [(c8Zv0,
                       label: Foreign.C.String.newCWString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zv0: // global
           R2 = R2;
           call Foreign.C.String.newCWString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.647694988 UTC

[section ""data" . Foreign.C.String.newCWStringLen1_closure" {
     Foreign.C.String.newCWStringLen1_closure:
         const Foreign.C.String.newCWStringLen1_info;
         const 0;
 },
 sat_s8Yz0_entry() //  [R1]
         { info_tbl: [(c8Zvj,
                       label: sat_s8Yz0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zvj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8Zvn; else goto c8Zvo;
       c8Zvn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8Zvo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c8Zvh_info;
           R3 = 0;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c8Zvh() //  [R1]
         { info_tbl: [(c8Zvh,
                       label: block_c8Zvh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zvh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Zvr; else goto c8Zvq;
       c8Zvr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c8Zvq: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.C.String.newCWStringLen1_entry() //  [R2]
         { info_tbl: [(c8Zvs,
                       label: Foreign.C.String.newCWStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zvs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8Zvu; else goto c8Zvv;
       c8Zvu: // global
           R2 = R2;
           R1 = Foreign.C.String.newCWStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Zvv: // global
           I64[Sp - 8] = block_c8Zv7_info;
           R3 = R2;
           R2 = Foreign.C.String.newCWString2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zv7() //  [R1]
         { info_tbl: [(c8Zv7,
                       label: block_c8Zv7_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zv7: // global
           I64[Sp - 8] = block_c8Zvb_info;
           R3 = R1;
           R2 = Foreign.C.Types.$fStorableCWchar_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call Foreign.Marshal.Array.newArray1_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zvb() //  [R1]
         { info_tbl: [(c8Zvb,
                       label: block_c8Zvb_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zvb: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c8Zvz; else goto c8Zvy;
       c8Zvz: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Zvy: // global
           I64[Hp - 40] = sat_s8Yz0_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.649444702 UTC

[section ""data" . Foreign.C.String.newCWStringLen_closure" {
     Foreign.C.String.newCWStringLen_closure:
         const Foreign.C.String.newCWStringLen_info;
         const 0;
 },
 Foreign.C.String.newCWStringLen_entry() //  [R2]
         { info_tbl: [(c8ZvE,
                       label: Foreign.C.String.newCWStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZvE: // global
           R2 = R2;
           call Foreign.C.String.newCWStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.650455877 UTC

[section ""data" . Foreign.C.String.castCharToCChar1_closure" {
     Foreign.C.String.castCharToCChar1_closure:
         const Foreign.C.String.castCharToCChar1_info;
 },
 Foreign.C.String.castCharToCChar1_entry() //  [R2]
         { info_tbl: [(c8ZvO,
                       label: Foreign.C.String.castCharToCChar1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZvO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8ZvY; else goto c8ZvZ;
       c8ZvY: // global
           R2 = R2;
           R1 = Foreign.C.String.castCharToCChar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZvZ: // global
           I64[Sp - 8] = block_c8ZvL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Zw3; else goto c8ZvM;
       u8Zw3: // global
           call _c8ZvL(R1) args: 0, res: 0, upd: 0;
       c8ZvM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZvL() //  [R1]
         { info_tbl: [(c8ZvL,
                       label: block_c8ZvL_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZvL: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Zw2; else goto c8Zw1;
       c8Zw2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Zw1: // global
           _s8Yz6::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s8Yz6::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.651615063 UTC

[section ""data" . Foreign.C.String.castCharToCSChar_closure" {
     Foreign.C.String.castCharToCSChar_closure:
         const Foreign.C.String.castCharToCSChar_info;
 },
 Foreign.C.String.castCharToCSChar_entry() //  [R2]
         { info_tbl: [(c8Zw8,
                       label: Foreign.C.String.castCharToCSChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zw8: // global
           R2 = R2;
           call Foreign.C.String.castCharToCChar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.652593379 UTC

[section ""data" . Foreign.C.String.castCharToCUChar1_closure" {
     Foreign.C.String.castCharToCUChar1_closure:
         const Foreign.C.String.castCharToCUChar1_info;
 },
 Foreign.C.String.castCharToCUChar1_entry() //  [R2]
         { info_tbl: [(c8Zwi,
                       label: Foreign.C.String.castCharToCUChar1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zwi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8Zwv; else goto c8Zww;
       c8Zwv: // global
           R2 = R2;
           R1 = Foreign.C.String.castCharToCUChar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Zww: // global
           I64[Sp - 8] = block_c8Zwf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ZwA; else goto c8Zwg;
       u8ZwA: // global
           call _c8Zwf(R1) args: 0, res: 0, upd: 0;
       c8Zwg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zwf() //  [R1]
         { info_tbl: [(c8Zwf,
                       label: block_c8Zwf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zwf: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8Zwz; else goto c8Zwy;
       c8Zwz: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8Zwy: // global
           _s8Yzc::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s8Yzc::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.653827445 UTC

[section ""data" . Foreign.C.String.castCharToCUChar_closure" {
     Foreign.C.String.castCharToCUChar_closure:
         const Foreign.C.String.castCharToCUChar_info;
 },
 Foreign.C.String.castCharToCUChar_entry() //  [R2]
         { info_tbl: [(c8ZwF,
                       label: Foreign.C.String.castCharToCUChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZwF: // global
           R2 = R2;
           call Foreign.C.String.castCharToCUChar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.65460005 UTC

[section ""data" . Foreign.C.String.castCharToCChar_closure" {
     Foreign.C.String.castCharToCChar_closure:
         const Foreign.C.String.castCharToCChar_info;
 },
 Foreign.C.String.castCharToCChar_entry() //  [R2]
         { info_tbl: [(c8ZwM,
                       label: Foreign.C.String.castCharToCChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZwM: // global
           R2 = R2;
           call Foreign.C.String.castCharToCChar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.656118154 UTC

[section ""data" . Foreign.C.String.newCAString1_closure" {
     Foreign.C.String.newCAString1_closure:
         const Foreign.C.String.newCAString1_info;
         const 0;
 },
 Foreign.C.String.newCAString1_entry() //  [R2]
         { info_tbl: [(c8ZwV,
                       label: Foreign.C.String.newCAString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZwV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8ZwW; else goto c8ZwX;
       c8ZwW: // global
           R2 = R2;
           R1 = Foreign.C.String.newCAString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZwX: // global
           I64[Sp - 16] = block_c8ZwT_info;
           R3 = 0;
           _s8Yzd::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s8Yzd::P64;
           Sp = Sp - 16;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZwT() //  [R1]
         { info_tbl: [(c8ZwT,
                       label: block_c8ZwT_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZwT: // global
           _s8Yzd::P64 = P64[Sp + 8];
           (_s8Yzl::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(R1 + 1);
           if (_s8Yzl::I64 == 0) goto c8ZxL; else goto c8ZxK;
       c8ZxL: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8ZxK: // global
           I64[Sp - 8] = 0;
           P64[Sp] = _s8Yzd::P64;
           I64[Sp + 8] = _s8Yzl::I64;
           Sp = Sp - 8;
           call _c8Zxn() args: 0, res: 0, upd: 0;
     }
 },
 _c8Zxn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zxn: // global
           I64[Sp - 8] = block_c8Zxq_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Zy0; else goto c8Zxs;
       u8Zy0: // global
           call _c8Zxq(R1) args: 0, res: 0, upd: 0;
       c8Zxs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zxq() //  [R1]
         { info_tbl: [(c8Zxq,
                       label: block_c8Zxq_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zxq: // global
           if (R1 & 7 == 1) goto c8Zxy; else goto c8ZxD;
       c8Zxy: // global
           I64[Sp + 16] = I64[Sp + 8];
           Sp = Sp + 16;
           call _c8Zxf() args: 0, res: 0, upd: 0;
       c8ZxD: // global
           I64[Sp] = block_c8ZxB_info;
           _s8Yzy::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _s8Yzy::P64;
           if (R1 & 7 != 0) goto u8Zy1; else goto c8ZxE;
       u8Zy1: // global
           call _c8ZxB(R1) args: 0, res: 0, upd: 0;
       c8ZxE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zxf() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zxf: // global
           Hp = Hp + 16;
           _s8Yzo::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c8Zxk; else goto c8Zxj;
       c8Zxk: // global
           HpAlloc = 16;
           I64[Sp] = block_c8Zxe_info;
           R1 = _s8Yzo::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8Zxj: // global
           _s8Yzl::I64 = I64[Sp + 8];
           I8[_s8Yzl::I64 + _s8Yzo::I64] = 0 :: W8;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8Yzl::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8Zxe() //  [R1]
         { info_tbl: [(c8Zxe,
                       label: block_c8Zxe_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zxe: // global
           I64[Sp] = R1;
           call _c8Zxf() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZxB() //  [R1]
         { info_tbl: [(c8ZxB,
                       label: block_c8ZxB_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZxB: // global
           _s8Yzu::I64 = I64[Sp + 8];
           _s8Yzy::P64 = P64[Sp + 16];
           I8[I64[Sp + 24] + _s8Yzu::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 16] = _s8Yzy::P64;
           I64[Sp + 8] = _s8Yzu::I64 + 1;
           Sp = Sp + 8;
           call _c8Zxn() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.658256175 UTC

[section ""data" . Foreign.C.String.newCAString_closure" {
     Foreign.C.String.newCAString_closure:
         const Foreign.C.String.newCAString_info;
         const 0;
 },
 Foreign.C.String.newCAString_entry() //  [R2]
         { info_tbl: [(c8Zy8,
                       label: Foreign.C.String.newCAString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zy8: // global
           R2 = R2;
           call Foreign.C.String.newCAString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.659728899 UTC

[section ""data" . Foreign.C.String.newCAStringLen1_closure" {
     Foreign.C.String.newCAStringLen1_closure:
         const Foreign.C.String.newCAStringLen1_info;
         const 0;
 },
 Foreign.C.String.newCAStringLen1_entry() //  [R2]
         { info_tbl: [(c8Zyh,
                       label: Foreign.C.String.newCAStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zyh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8Zyi; else goto c8Zyj;
       c8Zyi: // global
           R2 = R2;
           R1 = Foreign.C.String.newCAStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8Zyj: // global
           I64[Sp - 16] = block_c8Zyf_info;
           R3 = 0;
           _s8YzF::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s8YzF::P64;
           Sp = Sp - 16;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8Zyf() //  [R1]
         { info_tbl: [(c8Zyf,
                       label: block_c8Zyf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zyf: // global
           _s8YzF::P64 = P64[Sp + 8];
           (_s8YzN::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(R1 + 1);
           if (_s8YzN::I64 == 0) goto c8Zz9; else goto c8Zz8;
       c8Zz9: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8Zz8: // global
           P64[Sp - 16] = _s8YzF::P64;
           I64[Sp - 8] = 0;
           I64[Sp] = _s8YzN::I64;
           I64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _c8ZyL() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZyL() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZyL: // global
           _s8YzV::P64 = P64[Sp];
           I64[Sp] = block_c8ZyO_info;
           R1 = _s8YzV::P64;
           if (R1 & 7 != 0) goto u8Zzm; else goto c8ZyQ;
       u8Zzm: // global
           call _c8ZyO(R1) args: 0, res: 0, upd: 0;
       c8ZyQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZyO() //  [R1]
         { info_tbl: [(c8ZyO,
                       label: block_c8ZyO_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZyO: // global
           if (R1 & 7 == 1) goto u8Zzj; else goto c8Zz1;
       u8Zzj: // global
           Sp = Sp + 8;
           call _c8ZyB() args: 0, res: 0, upd: 0;
       c8Zz1: // global
           I64[Sp - 8] = block_c8ZyZ_info;
           _s8YA0::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8YA0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8Zzn; else goto c8Zz2;
       u8Zzn: // global
           call _c8ZyZ(R1) args: 0, res: 0, upd: 0;
       c8Zz2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZyB() //  []
         { info_tbl: [(c8ZyB,
                       label: block_c8ZyB_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZyB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8ZyI; else goto c8ZyH;
       c8ZyI: // global
           HpAlloc = 56;
           I64[Sp] = block_c8ZyB_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8ZyH: // global
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = I64[Sp + 16];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ZyZ() //  [R1]
         { info_tbl: [(c8ZyZ,
                       label: block_c8ZyZ_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZyZ: // global
           _s8YzW::I64 = I64[Sp + 16];
           _s8YA0::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s8YzW::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s8YA0::P64;
           I64[Sp + 16] = _s8YzW::I64 + 1;
           Sp = Sp + 8;
           call _c8ZyL() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.66181991 UTC

[section ""data" . Foreign.C.String.newCAStringLen_closure" {
     Foreign.C.String.newCAStringLen_closure:
         const Foreign.C.String.newCAStringLen_info;
         const 0;
 },
 Foreign.C.String.newCAStringLen_entry() //  [R2]
         { info_tbl: [(c8Zzu,
                       label: Foreign.C.String.newCAStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8Zzu: // global
           R2 = R2;
           call Foreign.C.String.newCAStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.663380154 UTC

[section ""data" . Foreign.C.String.withCAString1_closure" {
     Foreign.C.String.withCAString1_closure:
         const Foreign.C.String.withCAString1_info;
 },
 Foreign.C.String.withCAString1_entry() //  [R2, R3]
         { info_tbl: [(c8ZzD,
                       label: Foreign.C.String.withCAString1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZzD: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c8ZzE; else goto c8ZzF;
       c8ZzE: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.withCAString1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ZzF: // global
           I64[Sp - 24] = block_c8ZzB_info;
           _s8YA9::P64 = R3;
           R3 = 0;
           _s8YA8::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s8YA8::P64;
           P64[Sp - 8] = _s8YA9::P64;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZzB() //  [R1]
         { info_tbl: [(c8ZzB,
                       label: block_c8ZzB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZzB: // global
           I64[Sp] = block_c8ZzM_info;
           R2 = 1;
           R1 = R1 + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZzM() //  [R1]
         { info_tbl: [(c8ZzM,
                       label: block_c8ZzM_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZzM: // global
           P64[Sp - 16] = P64[Sp + 8];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _c8ZA6() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZA6() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZA6: // global
           _s8YAu::P64 = P64[Sp];
           I64[Sp] = block_c8ZA9_info;
           R1 = _s8YAu::P64;
           if (R1 & 7 != 0) goto u8ZAH; else goto c8ZAb;
       u8ZAH: // global
           call _c8ZA9(R1) args: 0, res: 0, upd: 0;
       c8ZAb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZA9() //  [R1]
         { info_tbl: [(c8ZA9,
                       label: block_c8ZA9_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZA9: // global
           if (R1 & 7 == 1) goto c8ZAh; else goto c8ZAm;
       c8ZAh: // global
           I64[Sp + 8] = I64[Sp + 8];
           Sp = Sp + 8;
           call _c8ZzV() args: 0, res: 0, upd: 0;
       c8ZAm: // global
           I64[Sp - 8] = block_c8ZAk_info;
           _s8YAz::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8YAz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ZAI; else goto c8ZAn;
       u8ZAI: // global
           call _c8ZAk(R1) args: 0, res: 0, upd: 0;
       c8ZAn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZzV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZzV: // global
           Hp = Hp + 16;
           _s8YAl::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c8ZA1; else goto c8ZA0;
       c8ZA1: // global
           HpAlloc = 16;
           I64[Sp] = block_c8ZzU_info;
           R1 = _s8YAl::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8ZA0: // global
           _s8YA9::P64 = P64[Sp + 24];
           _s8YAj::I64 = I64[Sp + 8];
           I8[_s8YAj::I64 + _s8YAl::I64] = 0 :: W8;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8YAj::I64;
           I64[Sp + 8] = block_c8ZzY_info;
           R2 = Hp - 7;
           R1 = _s8YA9::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZzU() //  [R1]
         { info_tbl: [(c8ZzU,
                       label: block_c8ZzU_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZzU: // global
           I64[Sp] = R1;
           call _c8ZzV() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZzY() //  [R1]
         { info_tbl: [(c8ZzY,
                       label: block_c8ZzY_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZzY: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ZAk() //  [R1]
         { info_tbl: [(c8ZAk,
                       label: block_c8ZAk_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZAk: // global
           _s8YAv::I64 = I64[Sp + 16];
           _s8YAz::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s8YAv::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s8YAz::P64;
           I64[Sp + 16] = _s8YAv::I64 + 1;
           Sp = Sp + 8;
           call _c8ZA6() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.666264389 UTC

[section ""data" . Foreign.C.String.withCAString_closure" {
     Foreign.C.String.withCAString_closure:
         const Foreign.C.String.withCAString_info;
 },
 Foreign.C.String.withCAString_entry() //  [R2, R3]
         { info_tbl: [(c8ZAP,
                       label: Foreign.C.String.withCAString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZAP: // global
           R3 = R3;
           R2 = R2;
           call Foreign.C.String.withCAString1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.667815178 UTC

[section ""data" . Foreign.C.String.withCAStringLen1_closure" {
     Foreign.C.String.withCAStringLen1_closure:
         const Foreign.C.String.withCAStringLen1_info;
 },
 Foreign.C.String.withCAStringLen1_entry() //  [R2, R3]
         { info_tbl: [(c8ZAY,
                       label: Foreign.C.String.withCAStringLen1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZAY: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8ZAZ; else goto c8ZB0;
       c8ZAZ: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.withCAStringLen1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ZB0: // global
           I64[Sp - 24] = block_c8ZAW_info;
           _s8YAH::P64 = R3;
           R3 = 0;
           _s8YAG::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s8YAG::P64;
           P64[Sp - 8] = _s8YAH::P64;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZAW() //  [R1]
         { info_tbl: [(c8ZAW,
                       label: block_c8ZAW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZAW: // global
           I64[Sp - 8] = block_c8ZB3_info;
           R2 = 1;
           _s8YAJ::I64 = R1;
           R1 = R1;
           I64[Sp] = _s8YAJ::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZB3() //  [R1]
         { info_tbl: [(c8ZB3,
                       label: block_c8ZB3_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZB3: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c8ZBq() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZBq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZBq: // global
           _s8YB1::P64 = P64[Sp];
           I64[Sp] = block_c8ZBt_info;
           R1 = _s8YB1::P64;
           if (R1 & 7 != 0) goto u8ZBZ; else goto c8ZBv;
       u8ZBZ: // global
           call _c8ZBt(R1) args: 0, res: 0, upd: 0;
       c8ZBv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZBt() //  [R1]
         { info_tbl: [(c8ZBt,
                       label: block_c8ZBt_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZBt: // global
           if (R1 & 7 == 1) goto u8ZBW; else goto c8ZBG;
       u8ZBW: // global
           Sp = Sp + 8;
           call _c8ZBd() args: 0, res: 0, upd: 0;
       c8ZBG: // global
           I64[Sp - 8] = block_c8ZBE_info;
           _s8YB6::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8YB6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ZC0; else goto c8ZBH;
       u8ZC0: // global
           call _c8ZBE(R1) args: 0, res: 0, upd: 0;
       c8ZBH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZBd() //  []
         { info_tbl: [(c8ZBd,
                       label: block_c8ZBd_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZBd: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c8ZBl; else goto c8ZBk;
       c8ZBl: // global
           HpAlloc = 56;
           I64[Sp] = block_c8ZBd_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8ZBk: // global
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = I64[Sp + 16];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           I64[Sp + 16] = block_c8ZBi_info;
           R2 = Hp - 15;
           R1 = P64[Sp + 32];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZBi() //  [R1]
         { info_tbl: [(c8ZBi,
                       label: block_c8ZBi_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZBi: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ZBE() //  [R1]
         { info_tbl: [(c8ZBE,
                       label: block_c8ZBE_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZBE: // global
           _s8YB2::I64 = I64[Sp + 16];
           _s8YB6::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s8YB2::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s8YB6::P64;
           I64[Sp + 16] = _s8YB2::I64 + 1;
           Sp = Sp + 8;
           call _c8ZBq() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.670111784 UTC

[section ""data" . Foreign.C.String.withCAStringLen_closure" {
     Foreign.C.String.withCAStringLen_closure:
         const Foreign.C.String.withCAStringLen_info;
 },
 Foreign.C.String.withCAStringLen_entry() //  [R2, R3]
         { info_tbl: [(c8ZC7,
                       label: Foreign.C.String.withCAStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZC7: // global
           R3 = R3;
           R2 = R2;
           call Foreign.C.String.withCAStringLen1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.670830818 UTC

[section ""relreadonly" . S8YDv_srt" {
     S8YDv_srt:
         const GHC.IO.Encoding.getForeignEncoding_closure;
         const Foreign.C.String.withCStringLen1_closure;
         const Foreign.C.String.withCString1_closure;
         const GHC.Foreign.charIsRepresentable1_closure;
         const Foreign.C.String.charIsRepresentable1_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Alloc.realloc2_closure;
         const Foreign.C.String.newCStringLen1_closure;
         const GHC.Foreign.newCString1_closure;
         const Foreign.C.String.newCString1_closure;
         const GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
         const Foreign.C.String.peekCStringLen1_closure;
         const GHC.Foreign.peekCString1_closure;
         const Foreign.C.String.peekCString1_closure;
         const GHC.Char.$wlvl_closure;
         const Foreign.C.String.castCWcharToChar_closure;
         const Foreign.C.String.peekCWString2_closure;
         const Foreign.C.String.$wpeekCWStringLen_closure;
         const Foreign.C.String.peekCWStringLen1_closure;
         const Foreign.C.String.$wpeekCWString_closure;
         const Foreign.C.String.peekCWString1_closure;
         const Foreign.Marshal.Array.withArrayLen0_closure;
         const Foreign.C.String.withCWString_closure;
         const Foreign.Marshal.Array.newArray3_closure;
         const Foreign.C.String.newCWString1_closure;
         const Foreign.Marshal.Array.newArray1_closure;
         const Foreign.C.String.newCWStringLen1_closure;
         const Foreign.C.String.newCAString1_closure;
         const Foreign.C.String.newCAStringLen1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.671790812 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:04:07.672902735 UTC

[section ""cstring" . Foreign.C.String.$trModule4_bytes" {
     Foreign.C.String.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.674654906 UTC

[section ""data" . Foreign.C.String.$trModule3_closure" {
     Foreign.C.String.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.C.String.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.676341391 UTC

[section ""cstring" . Foreign.C.String.$trModule2_bytes" {
     Foreign.C.String.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,67,46,83,116,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.678269128 UTC

[section ""data" . Foreign.C.String.$trModule1_closure" {
     Foreign.C.String.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.C.String.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.679961844 UTC

[section ""data" . Foreign.C.String.$trModule_closure" {
     Foreign.C.String.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.C.String.$trModule3_closure+1;
         const Foreign.C.String.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.683798082 UTC

[section ""data" . Foreign.C.String.withCStringLen1_closure" {
     Foreign.C.String.withCStringLen1_closure:
         const Foreign.C.String.withCStringLen1_info;
         const 0;
 },
 $wgo_s8YpD_entry() //  [R1, R2]
         { info_tbl: [(c8ZD0,
                       label: $wgo_s8YpD_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZD0: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8ZD1; else goto c8ZD2;
       c8ZD1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZD2: // global
           I64[Sp - 48] = block_c8ZCV_info;
           _s8YpD::P64 = R1;
           _s8Ypc::P64 = P64[R1 + 6];
           _s8Ypl::P64 = P64[R1 + 14];
           _s8YpC::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 40] = _s8Ypc::P64;
           P64[Sp - 32] = _s8Ypl::P64;
           P64[Sp - 24] = _s8YpC::P64;
           P64[Sp - 16] = _s8YpD::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 48;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZCV() //  [R1]
         { info_tbl: [(c8ZCV,
                       label: block_c8ZCV_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZCV: // global
           I64[Sp] = block_c8ZCX_info;
           _s8YpL::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8YpL::P64;
           if (R1 & 7 != 0) goto u8ZDB; else goto c8ZCY;
       u8ZDB: // global
           call _c8ZCX(R1) args: 0, res: 0, upd: 0;
       c8ZCY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZCX() //  [R1]
         { info_tbl: [(c8ZCX,
                       label: block_c8ZCX_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZCX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8ZD8; else goto c8ZD7;
       c8ZD8: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZD7: // global
           _s8YpN::P64 = P64[R1 + 7];
           _s8YpO::P64 = P64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 40];
           _s8Ypc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8ZDd_info;
           R6 = P64[Sp + 16] + 16;
           R5 = P64[Sp + 24];
           R4 = GHC.Types.False_closure+1;
           R3 = _s8YpO::P64;
           R2 = _s8YpN::P64;
           P64[Sp - 8] = Hp - 7;
           P64[Sp] = _s8Ypc::P64;
           Sp = Sp - 8;
           call GHC.Foreign.$wtryFillBufferAndCall_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 8, upd: 8;
     }
 },
 _c8ZDd() //  [R1]
         { info_tbl: [(c8ZDd,
                       label: block_c8ZDd_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZDd: // global
           I64[Sp] = block_c8ZDf_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8ZDC; else goto c8ZDh;
       u8ZDC: // global
           call _c8ZDf(R1) args: 0, res: 0, upd: 0;
       c8ZDh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZDf() //  [R1]
         { info_tbl: [(c8ZDf,
                       label: block_c8ZDf_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZDf: // global
           if (R1 & 7 == 1) goto c8ZDr; else goto c8ZDx;
       c8ZDr: // global
           I64[Sp] = block_c8ZDp_info;
           R2 = I64[Sp + 32] << 1;
           R1 = P64[Sp + 24];
           call $wgo_s8YpD_entry(R2, R1) args: 8, res: 8, upd: 8;
       c8ZDx: // global
           _s8Yq3::P64 = P64[R1 + 6];
           call MO_Touch(P64[Sp + 8]);
           R1 = _s8Yq3::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ZDp() //  [R1]
         { info_tbl: [(c8ZDp,
                       label: block_c8ZDp_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZDp: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Yql_entry() //  [R1, R2]
         { info_tbl: [(c8ZDD,
                       label: sat_s8Yql_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZDD: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c8ZDE; else goto c8ZDF;
       c8ZDE: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZDF: // global
           I64[Sp - 32] = block_c8ZCv_info;
           R3 = 0;
           _s8Ypl::P64 = R2;
           _s8Ypb::P64 = P64[R1 + 6];
           R2 = _s8Ypb::P64;
           P64[Sp - 24] = _s8Ypb::P64;
           P64[Sp - 16] = P64[R1 + 14];
           P64[Sp - 8] = _s8Ypl::P64;
           Sp = Sp - 32;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZCv() //  [R1]
         { info_tbl: [(c8ZCv,
                       label: block_c8ZCv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZCv: // global
           I64[Sp - 8] = block_c8ZCC_info;
           R2 = 4;
           _s8Ypn::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8Ypn::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZCC() //  [R1]
         { info_tbl: [(c8ZCC,
                       label: block_c8ZCC_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZCC: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c8ZDU() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZDU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZDU: // global
           _s8Yqb::P64 = P64[Sp];
           I64[Sp] = block_c8ZDX_info;
           R1 = _s8Yqb::P64;
           if (R1 & 7 != 0) goto u8ZEm; else goto c8ZDZ;
       u8ZEm: // global
           call _c8ZDX(R1) args: 0, res: 0, upd: 0;
       c8ZDZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZDX() //  [R1]
         { info_tbl: [(c8ZDX,
                       label: block_c8ZDX_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZDX: // global
           if (R1 & 7 == 1) goto c8ZE5; else goto c8ZEa;
       c8ZE5: // global
           I64[Sp + 8] = block_c8ZCM_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8ZEa: // global
           I64[Sp - 8] = block_c8ZE8_info;
           _s8Yqg::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8Yqg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ZEn; else goto c8ZEb;
       u8ZEn: // global
           call _c8ZE8(R1) args: 0, res: 0, upd: 0;
       c8ZEb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZCM() //  [R1]
         { info_tbl: [(c8ZCM,
                       label: block_c8ZCM_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZCM: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c8ZDL; else goto c8ZDK;
       c8ZDL: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZDK: // global
           I64[Hp - 96] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 88] = R1;
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = Hp - 95;
           P64[Hp - 64] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 56] = I64[Sp + 8];
           _s8Ypn::I64 = I64[Sp + 16];
           I64[Hp - 48] = _s8Ypn::I64;
           I64[Hp - 40] = 0;
           I64[Hp - 32] = _s8Ypn::I64;
           I64[Hp - 24] = $wgo_s8YpD_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = Hp - 79;
           I64[Sp + 16] = block_c8ZDP_info;
           R2 = _s8Ypn::I64 + 1;
           R1 = Hp - 22;
           Sp = Sp + 16;
           call $wgo_s8YpD_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZDP() //  [R1]
         { info_tbl: [(c8ZDP,
                       label: block_c8ZDP_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZDP: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ZE8() //  [R1]
         { info_tbl: [(c8ZE8,
                       label: block_c8ZE8_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZE8: // global
           _s8Yqc::I64 = I64[Sp + 16];
           _s8Yqg::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8Yqc::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8Yqg::P64;
           I64[Sp + 16] = _s8Yqc::I64 + 1;
           Sp = Sp + 8;
           call _c8ZDU() args: 0, res: 0, upd: 0;
     }
 },
 Foreign.C.String.withCStringLen1_entry() //  [R2, R3]
         { info_tbl: [(c8ZEp,
                       label: Foreign.C.String.withCStringLen1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZEp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8ZEq; else goto c8ZEr;
       c8ZEq: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.withCStringLen1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ZEr: // global
           I64[Sp - 24] = block_c8ZCj_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZCj() //  [R1]
         { info_tbl: [(c8ZCj,
                       label: block_c8ZCj_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZCj: // global
           I64[Sp] = block_c8ZCl_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8ZEw; else goto c8ZCm;
       u8ZEw: // global
           call _c8ZCl(R1) args: 0, res: 0, upd: 0;
       c8ZCm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZCl() //  [R1]
         { info_tbl: [(c8ZCl,
                       label: block_c8ZCl_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZCl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8ZEv; else goto c8ZEu;
       c8ZEv: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZEu: // global
           _s8Ypk::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_s8Yql_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8Ypk::P64;
           Sp = Sp + 24;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.717847649 UTC

[section ""data" . Foreign.C.String.withCStringLen_closure" {
     Foreign.C.String.withCStringLen_closure:
         const Foreign.C.String.withCStringLen_info;
         const 0;
 },
 Foreign.C.String.withCStringLen_entry() //  [R2, R3]
         { info_tbl: [(c8ZFV,
                       label: Foreign.C.String.withCStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZFV: // global
           R3 = R3;
           R2 = R2;
           call Foreign.C.String.withCStringLen1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.721400464 UTC

[section ""data" . Foreign.C.String.withCString1_closure" {
     Foreign.C.String.withCString1_closure:
         const Foreign.C.String.withCString1_info;
         const 0;
 },
 Foreign.C.String.withCString1_entry() //  [R2, R3]
         { info_tbl: [(c8ZG8,
                       label: Foreign.C.String.withCString1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZG8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c8ZG9; else goto c8ZGa;
       c8ZG9: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.withCString1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c8ZGa: // global
           I64[Sp - 24] = block_c8ZG6_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZG6() //  [R1]
         { info_tbl: [(c8ZG6,
                       label: block_c8ZG6_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZG6: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.727431594 UTC

[section ""data" . Foreign.C.String.withCString_closure" {
     Foreign.C.String.withCString_closure:
         const Foreign.C.String.withCString_info;
         const 0;
 },
 Foreign.C.String.withCString_entry() //  [R2, R3]
         { info_tbl: [(c8ZGo,
                       label: Foreign.C.String.withCString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZGo: // global
           R3 = R3;
           R2 = R2;
           call Foreign.C.String.withCString1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.730889281 UTC

[section ""data" . Foreign.C.String.charIsRepresentable1_closure" {
     Foreign.C.String.charIsRepresentable1_closure:
         const Foreign.C.String.charIsRepresentable1_info;
         const 0;
 },
 Foreign.C.String.charIsRepresentable1_entry() //  [R2]
         { info_tbl: [(c8ZGB,
                       label: Foreign.C.String.charIsRepresentable1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZGB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ZGC; else goto c8ZGD;
       c8ZGC: // global
           R2 = R2;
           R1 = Foreign.C.String.charIsRepresentable1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZGD: // global
           I64[Sp - 16] = block_c8ZGz_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZGz() //  [R1]
         { info_tbl: [(c8ZGz,
                       label: block_c8ZGz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZGz: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.736080151 UTC

[section ""data" . Foreign.C.String.charIsRepresentable_closure" {
     Foreign.C.String.charIsRepresentable_closure:
         const Foreign.C.String.charIsRepresentable_info;
         const 0;
 },
 Foreign.C.String.charIsRepresentable_entry() //  [R2]
         { info_tbl: [(c8ZGR,
                       label: Foreign.C.String.charIsRepresentable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZGR: // global
           R2 = R2;
           call Foreign.C.String.charIsRepresentable1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.739892919 UTC

[section ""data" . Foreign.C.String.newCStringLen2_closure" {
     Foreign.C.String.newCStringLen2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.745453631 UTC

[section ""data" . Foreign.C.String.newCStringLen1_closure" {
     Foreign.C.String.newCStringLen1_closure:
         const Foreign.C.String.newCStringLen1_info;
         const 0;
 },
 sat_s8Ysq_entry() //  [R1]
         { info_tbl: [(c8ZIC,
                       label: sat_s8Ysq_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZIC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c8ZIH; else goto c8ZII;
       c8ZIH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ZII: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c8ZIz_info;
           _s8Yrl::P64 = P64[R1 + 24];
           _s8Yra::I64 = I64[R1 + 32];
           R1 = P64[R1 + 16];
           I64[Sp - 32] = _s8Yra::I64;
           P64[Sp - 24] = _s8Yrl::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u8ZIM; else goto c8ZIA;
       u8ZIM: // global
           call _c8ZIz(R1) args: 0, res: 0, upd: 0;
       c8ZIA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c8ZIz() //  [R1]
         { info_tbl: [(c8ZIz,
                       label: block_c8ZIz_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZIz: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8ZIL; else goto c8ZIK;
       c8ZIL: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c8ZIK: // global
           _s8Yso::I64 = I64[R1 + 7];
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 16];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s8Yso::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8YsE_entry() //  [R1, R2]
         { info_tbl: [(c8ZIN,
                       label: sat_s8YsE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZIN: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c8ZIO; else goto c8ZIP;
       c8ZIO: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZIP: // global
           I64[Sp - 24] = block_c8ZHf_info;
           R3 = 0;
           _s8YqG::P64 = R2;
           _s8Yqx::P64 = P64[R1 + 6];
           R2 = _s8Yqx::P64;
           P64[Sp - 16] = _s8Yqx::P64;
           P64[Sp - 8] = _s8YqG::P64;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZHf() //  [R1]
         { info_tbl: [(c8ZHf,
                       label: block_c8ZHf_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZHf: // global
           I64[Sp - 8] = block_c8ZHm_info;
           R2 = 4;
           _s8YqI::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8YqI::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZHm() //  [R1]
         { info_tbl: [(c8ZHm,
                       label: block_c8ZHm_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZHm: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c8ZKD() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZKD() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZKD: // global
           _s8Ysu::P64 = P64[Sp];
           I64[Sp] = block_c8ZKG_info;
           R1 = _s8Ysu::P64;
           if (R1 & 7 != 0) goto u8ZLG; else goto c8ZKI;
       u8ZLG: // global
           call _c8ZKG(R1) args: 0, res: 0, upd: 0;
       c8ZKI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZKG() //  [R1]
         { info_tbl: [(c8ZKG,
                       label: block_c8ZKG_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZKG: // global
           if (R1 & 7 == 1) goto c8ZKO; else goto c8ZKT;
       c8ZKO: // global
           I64[Sp + 8] = block_c8ZHw_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8ZKT: // global
           I64[Sp - 8] = block_c8ZKR_info;
           _s8Ysz::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8Ysz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ZLH; else goto c8ZKU;
       u8ZLH: // global
           call _c8ZKR(R1) args: 0, res: 0, upd: 0;
       c8ZKU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZHw() //  [R1]
         { info_tbl: [(c8ZHw,
                       label: block_c8ZHw_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZHw: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c8ZIV; else goto c8ZIU;
       c8ZIV: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZIU: // global
           _s8YqI::I64 = I64[Sp + 16];
           _s8YqQ::I64 = I64[Sp + 8];
           _s8YqW::I64 = _s8YqI::I64 + 1;
           (_s8Yr1::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(_s8YqW::I64);
           if (_s8Yr1::I64 == 0) goto c8ZKA; else goto c8ZKz;
       c8ZKA: // global
           Hp = Hp - 88;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8ZKz: // global
           I64[Hp - 80] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 72] = R1;
           I64[Hp - 64] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 40] = _s8YqQ::I64;
           I64[Hp - 32] = _s8YqI::I64;
           I64[Hp - 24] = 0;
           I64[Hp - 16] = _s8YqI::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8YqW::I64;
           P64[Sp] = Hp - 7;
           I64[Sp + 8] = _s8Yr1::I64;
           P64[Sp + 16] = Hp - 63;
           call _c8ZHQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZHQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZHQ: // global
           I64[Sp - 8] = block_c8ZHT_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ZLr; else goto c8ZHU;
       u8ZLr: // global
           call _c8ZHT(R1) args: 0, res: 0, upd: 0;
       c8ZHU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZHT() //  [R1]
         { info_tbl: [(c8ZHT,
                       label: block_c8ZHT_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZHT: // global
           I64[Sp - 16] = block_c8ZHY_info;
           _s8Yre::P64 = P64[R1 + 7];
           _s8Yrf::P64 = P64[R1 + 15];
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 8] = _s8Yrf::P64;
           P64[Sp] = _s8Yre::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZHY() //  [R1]
         { info_tbl: [(c8ZHY,
                       label: block_c8ZHY_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZHY: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8ZJ4; else goto c8ZJ3;
       c8ZJ4: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZJ3: // global
           I64[Hp - 32] = sat_s8Ysq_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 32];
           P64[Sp - 8] = Hp - 32;
           P64[Sp] = P64[Sp + 40];
           Sp = Sp - 8;
           call _c8ZJP() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZJP() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZJP: // global
           _s8YrY::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8ZJR_info;
           R3 = P64[Sp];
           R2 = _s8YrY::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZJR() //  [R1]
         { info_tbl: [(c8ZJR,
                       label: block_c8ZJR_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZJR: // global
           I64[Sp] = block_c8ZJT_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8ZLz; else goto c8ZJU;
       u8ZLz: // global
           call _c8ZJT(R1) args: 0, res: 0, upd: 0;
       c8ZJU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZJT() //  [R1]
         { info_tbl: [(c8ZJT,
                       label: block_c8ZJT_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZJT: // global
           I64[Sp - 16] = block_c8ZJY_info;
           _s8Ys5::P64 = P64[R1 + 7];
           _s8Ys7::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8Ys7::P64;
           P64[Sp] = _s8Ys5::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ZLA; else goto c8ZK2;
       u8ZLA: // global
           call _c8ZJY(R1) args: 0, res: 0, upd: 0;
       c8ZK2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZJY() //  [R1]
         { info_tbl: [(c8ZJY,
                       label: block_c8ZJY_info
                       rep:StackRep [False, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZJY: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8ZKx; else goto c8ZKc;
       c8ZKx: // global
           I64[Sp + 32] = block_c8ZJD_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8ZLC; else goto c8ZJF;
       u8ZLC: // global
           call _c8ZJD(R1) args: 0, res: 0, upd: 0;
       c8ZJF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ZKc: // global
           I64[Sp] = block_c8ZKa_info;
           _s8Ys8::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8Ys8::P64;
           if (R1 & 7 != 0) goto u8ZLB; else goto c8ZKd;
       u8ZLB: // global
           call _c8ZKa(R1) args: 0, res: 0, upd: 0;
       c8ZKd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZJD() //  [R1]
         { info_tbl: [(c8ZJD,
                       label: block_c8ZJD_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZJD: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c8ZJL; else goto c8ZJK;
       c8ZJL: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZJK: // global
           _s8YrL::I64 = I64[R1 + 23];
           _s8YrP::I64 = I64[R1 + 39];
           _s8YrQ::I64 = I64[R1 + 47];
           call MO_Touch(P64[R1 + 7]);
           I64[Hp - 64] = GHC.Types.I#_con_info;
           I64[Hp - 56] = _s8YrQ::I64 - _s8YrP::I64;
           I64[Hp - 48] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 40] = _s8YrL::I64;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 63;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           P64[Sp] = Hp - 6;
           call _s8Yrm() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZKa() //  [R1]
         { info_tbl: [(c8ZKa,
                       label: block_c8ZKa_info
                       rep:StackRep [False, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZKa: // global
           if (R1 & 7 == 2) goto c8ZKw; else goto c8ZKm;
       c8ZKw: // global
           P64[Sp + 32] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call _s8Yrm() args: 0, res: 0, upd: 0;
       c8ZKm: // global
           _s8Ys8::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8ZKh_info;
           R3 = P64[Sp + 8];
           R2 = _s8Ys8::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _s8Yrm() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8Yrm: // global
           _s8Yro::P64 = P64[Sp];
           I64[Sp] = block_c8ZI7_info;
           R1 = _s8Yro::P64;
           if (R1 & 7 != 0) goto u8ZLJ; else goto c8ZI8;
       u8ZLJ: // global
           call _c8ZI7(R1) args: 0, res: 0, upd: 0;
       c8ZI8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZI7() //  [R1]
         { info_tbl: [(c8ZI7,
                       label: block_c8ZI7_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZI7: // global
           if (R1 & 7 == 1) goto c8ZJ8; else goto c8ZJr;
       c8ZJ8: // global
           _s8Yrb::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8ZIc_info;
           R1 = _s8Yrb::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8ZLt; else goto c8ZId;
       u8ZLt: // global
           call _c8ZIc(R1) args: 0, res: 0, upd: 0;
       c8ZId: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ZJr: // global
           _s8Yr7::P64 = P64[R1 + 6];
           call MO_Touch(P64[Sp + 32]);
           R1 = _s8Yr7::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ZIc() //  [R1]
         { info_tbl: [(c8ZIc,
                       label: block_c8ZIc_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZIc: // global
           _s8Yrs::I64 = I64[R1 + 7] << 1;
           if (_s8Yrs::I64 != 0) goto u8ZLl; else goto c8ZJk;
       u8ZLl: // global
           I64[Sp] = _s8Yrs::I64;
           call _c8ZIl() args: 0, res: 0, upd: 0;
       c8ZJk: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[Sp + 8]);
           I64[Sp + 8] = 0;
           P64[Sp] = Foreign.C.String.newCStringLen2_closure+1;
           call _c8ZHQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZIl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZIl: // global
           Hp = Hp + 16;
           _s8Yrs::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c8ZJe; else goto c8ZJd;
       c8ZJe: // global
           HpAlloc = 16;
           I64[Sp] = block_c8ZIk_info;
           R1 = _s8Yrs::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c8ZJd: // global
           (_s8Yrx::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp + 8], _s8Yrs::I64);
           if (_s8Yrx::I64 == 0) goto c8ZJh; else goto c8ZJg;
       c8ZJh: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c8ZJg: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s8Yrs::I64;
           I64[Sp + 8] = _s8Yrx::I64;
           P64[Sp] = Hp - 7;
           call _c8ZHQ() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZIk() //  [R1]
         { info_tbl: [(c8ZIk,
                       label: block_c8ZIk_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZIk: // global
           I64[Sp] = R1;
           call _c8ZIl() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZKh() //  [R1]
         { info_tbl: [(c8ZKh,
                       label: block_c8ZKh_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZKh: // global
           I64[Sp] = block_c8ZKj_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8ZLE; else goto c8ZKo;
       u8ZLE: // global
           call _c8ZKj(R1) args: 0, res: 0, upd: 0;
       c8ZKo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZKj() //  [R1]
         { info_tbl: [(c8ZKj,
                       label: block_c8ZKj_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZKj: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 8;
           call _c8ZJP() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZKR() //  [R1]
         { info_tbl: [(c8ZKR,
                       label: block_c8ZKR_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZKR: // global
           _s8Ysv::I64 = I64[Sp + 16];
           _s8Ysz::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8Ysv::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8Ysz::P64;
           I64[Sp + 16] = _s8Ysv::I64 + 1;
           Sp = Sp + 8;
           call _c8ZKD() args: 0, res: 0, upd: 0;
     }
 },
 Foreign.C.String.newCStringLen1_entry() //  [R2]
         { info_tbl: [(c8ZLK,
                       label: Foreign.C.String.newCStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZLK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ZLL; else goto c8ZLM;
       c8ZLL: // global
           R2 = R2;
           R1 = Foreign.C.String.newCStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZLM: // global
           I64[Sp - 16] = block_c8ZH3_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZH3() //  [R1]
         { info_tbl: [(c8ZH3,
                       label: block_c8ZH3_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZH3: // global
           I64[Sp] = block_c8ZH5_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8ZLR; else goto c8ZH6;
       u8ZLR: // global
           call _c8ZH5(R1) args: 0, res: 0, upd: 0;
       c8ZH6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZH5() //  [R1]
         { info_tbl: [(c8ZH5,
                       label: block_c8ZH5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZH5: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8ZLQ; else goto c8ZLP;
       c8ZLQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZLP: // global
           _s8YqF::P64 = P64[R1 + 23];
           I64[Hp - 8] = sat_s8YsE_info;
           P64[Hp] = P64[Sp + 8];
           R4 = Hp - 6;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s8YqF::P64;
           Sp = Sp + 16;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.796824047 UTC

[section ""data" . Foreign.C.String.newCStringLen_closure" {
     Foreign.C.String.newCStringLen_closure:
         const Foreign.C.String.newCStringLen_info;
         const 0;
 },
 Foreign.C.String.newCStringLen_entry() //  [R2]
         { info_tbl: [(c8ZO1,
                       label: Foreign.C.String.newCStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZO1: // global
           R2 = R2;
           call Foreign.C.String.newCStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.800304503 UTC

[section ""data" . Foreign.C.String.newCString1_closure" {
     Foreign.C.String.newCString1_closure:
         const Foreign.C.String.newCString1_info;
         const 0;
 },
 Foreign.C.String.newCString1_entry() //  [R2]
         { info_tbl: [(c8ZOe,
                       label: Foreign.C.String.newCString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZOe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ZOf; else goto c8ZOg;
       c8ZOf: // global
           R2 = R2;
           R1 = Foreign.C.String.newCString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZOg: // global
           I64[Sp - 16] = block_c8ZOc_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZOc() //  [R1]
         { info_tbl: [(c8ZOc,
                       label: block_c8ZOc_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZOc: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.newCString1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.805910164 UTC

[section ""data" . Foreign.C.String.newCString_closure" {
     Foreign.C.String.newCString_closure:
         const Foreign.C.String.newCString_info;
         const 0;
 },
 Foreign.C.String.newCString_entry() //  [R2]
         { info_tbl: [(c8ZOu,
                       label: Foreign.C.String.newCString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZOu: // global
           R2 = R2;
           call Foreign.C.String.newCString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.812959588 UTC

[section ""data" . Foreign.C.String.peekCStringLen1_closure" {
     Foreign.C.String.peekCStringLen1_closure:
         const Foreign.C.String.peekCStringLen1_info;
         const 0;
 },
 sat_s8Yu1_entry() //  [R1]
         { info_tbl: [(c8ZQS,
                       label: sat_s8Yu1_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZQS: // global
           _s8Yu1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c8ZQT; else goto c8ZQU;
       c8ZQU: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8ZQW; else goto c8ZQV;
       c8ZQW: // global
           HpAlloc = 40;
           goto c8ZQT;
       c8ZQT: // global
           R1 = _s8Yu1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ZQV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Yu1::P64;
           _s8YtQ::P64 = P64[_s8Yu1::P64 + 16];
           _s8YtY::P64 = P64[_s8Yu1::P64 + 24];
           _s8YtU::I64 = I64[_s8Yu1::P64 + 32];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8YtU::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YtQ::P64;
           R3 = _s8YtY::P64;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8Yui_entry() //  [R1]
         { info_tbl: [(c8ZR5,
                       label: sat_s8Yui_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZR5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ZR6; else goto c8ZR7;
       c8ZR6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c8ZR7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 $wgo_s8Yti_entry() //  [R1, R2]
         { info_tbl: [(c8ZR8,
                       label: $wgo_s8Yti_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZR8: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8ZR9; else goto c8ZRa;
       c8ZR9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZRa: // global
           I64[Sp - 32] = block_c8ZPx_info;
           _s8Yti::P64 = R1;
           _s8Yth::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 24] = _s8Yth::P64;
           P64[Sp - 16] = _s8Yti::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u8ZSK; else goto c8ZPy;
       u8ZSK: // global
           call _c8ZPx(R1) args: 0, res: 0, upd: 0;
       c8ZPy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZPx() //  [R1]
         { info_tbl: [(c8ZPx,
                       label: block_c8ZPx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZPx: // global
           _s8Yth::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c8ZPC_info;
           R3 = _s8Yth::P64;
           R2 = P64[Sp + 24];
           _s8Ytn::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 24] = _s8Ytn::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZPC() //  [R1]
         { info_tbl: [(c8ZPC,
                       label: block_c8ZPC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZPC: // global
           I64[Sp] = block_c8ZPE_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8ZSC; else goto c8ZPF;
       u8ZSC: // global
           call _c8ZPE(R1) args: 0, res: 0, upd: 0;
       c8ZPF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZPE() //  [R1]
         { info_tbl: [(c8ZPE,
                       label: block_c8ZPE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZPE: // global
           I64[Sp - 16] = block_c8ZPJ_info;
           _s8Ytv::P64 = P64[R1 + 7];
           _s8Ytx::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s8Ytx::P64;
           P64[Sp] = _s8Ytv::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u8ZSD; else goto c8ZPK;
       u8ZSD: // global
           call _c8ZPJ(R1) args: 0, res: 0, upd: 0;
       c8ZPK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZPJ() //  [R1]
         { info_tbl: [(c8ZPJ,
                       label: block_c8ZPJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZPJ: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c8ZS5; else goto c8ZRy;
       c8ZS5: // global
           I64[Sp + 32] = block_c8ZQh_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u8ZSF; else goto c8ZQi;
       u8ZSF: // global
           call _c8ZQh(R1) args: 0, res: 0, upd: 0;
       c8ZQi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ZRy: // global
           I64[Sp] = block_c8ZRf_info;
           _s8Yty::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8Yty::P64;
           if (R1 & 7 != 0) goto u8ZSE; else goto c8ZRz;
       u8ZSE: // global
           call _c8ZRf(R1) args: 0, res: 0, upd: 0;
       c8ZRz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZQh() //  [R1]
         { info_tbl: [(c8ZQh,
                       label: block_c8ZQh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZQh: // global
           _s8YuG::P64 = P64[R1 + 7];
           _s8YuL::I64 = I64[R1 + 47] - I64[R1 + 39];
           if (%MO_S_Gt_W64(_s8YuL::I64, 0)) goto c8ZSn; else goto c8ZSo;
       c8ZSn: // global
           P64[Sp - 24] = _s8YuG::P64;
           I64[Sp - 16] = _s8YuL::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 32;
           call _c8ZQz() args: 0, res: 0, upd: 0;
       c8ZSo: // global
           call MO_Touch(_s8YuG::P64);
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ZQz() //  []
         { info_tbl: [(c8ZQz,
                       label: block_c8ZQz_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZQz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8ZSi; else goto c8ZSh;
       c8ZSi: // global
           HpAlloc = 40;
           I64[Sp] = block_c8ZQz_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8ZSh: // global
           _s8YuY::P64 = P64[Sp + 24];
           _s8Yv0::I64 = I64[Sp + 16];
           if (_s8Yv0::I64 != 0) goto c8ZSk; else goto c8ZSl;
       c8ZSk: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 32] + (_s8Yv0::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YuY::P64;
           I64[Sp + 16] = _s8Yv0::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           call _c8ZQz() args: 0, res: 0, upd: 0;
       c8ZSl: // global
           Hp = Hp - 40;
           P64[Sp + 24] = _s8YuY::P64;
           Sp = Sp + 8;
           call _c8ZS8() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZS8() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZS8: // global
           Hp = Hp + 40;
           _s8YuO::P64 = P64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c8ZSf; else goto c8ZSe;
       c8ZSf: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_c8ZS7_info;
           R1 = _s8YuO::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZSe: // global
           _s8YuS::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 24]]);
           call MO_Touch(P64[Sp]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8YuS::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YuO::P64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ZS7() //  [R1]
         { info_tbl: [(c8ZS7,
                       label: block_c8ZS7_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZS7: // global
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c8ZS8() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZRf() //  [R1]
         { info_tbl: [(c8ZRf,
                       label: block_c8ZRf_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZRf: // global
           _s8Ytx::P64 = P64[Sp + 8];
           if (R1 & 7 == 2) goto c8ZRZ; else goto c8ZRN;
       c8ZRZ: // global
           I64[Sp + 8] = block_c8ZRX_info;
           R1 = _s8Ytx::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u8ZSL; else goto c8ZS0;
       u8ZSL: // global
           call _c8ZRX(R1) args: 0, res: 0, upd: 0;
       c8ZS0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c8ZRN: // global
           _s8Yty::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c8ZRD_info;
           R3 = _s8Ytx::P64;
           R2 = _s8Yty::P64;
           R1 = P64[Sp + 32];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZRX() //  [R1]
         { info_tbl: [(c8ZRX,
                       label: block_c8ZRX_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZRX: // global
           P64[Sp + 24] = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 23];
           P64[Sp - 16] = P64[R1 + 7];
           I64[Sp - 8] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           Sp = Sp - 16;
           call _s8YtG() args: 0, res: 0, upd: 0;
     }
 },
 _c8ZRD() //  [R1]
         { info_tbl: [(c8ZRD,
                       label: block_c8ZRD_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZRD: // global
           I64[Sp] = block_c8ZRF_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8ZSM; else goto c8ZRG;
       u8ZSM: // global
           call _c8ZRF(R1) args: 0, res: 0, upd: 0;
       c8ZRG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZRF() //  [R1]
         { info_tbl: [(c8ZRF,
                       label: block_c8ZRF_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZRF: // global
           I64[Sp] = block_c8ZRK_info;
           _s8Yuo::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 16] = _s8Yuo::P64;
           if (R1 & 7 != 0) goto u8ZSN; else goto c8ZRQ;
       u8ZSN: // global
           call _c8ZRK(R1) args: 0, res: 0, upd: 0;
       c8ZRQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZRK() //  [R1]
         { info_tbl: [(c8ZRK,
                       label: block_c8ZRK_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZRK: // global
           P64[Sp - 24] = P64[R1 + 7];
           I64[Sp - 16] = I64[R1 + 39];
           I64[Sp - 8] = I64[R1 + 47];
           I64[Sp] = I64[R1 + 23];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp - 24;
           call _s8YtG() args: 0, res: 0, upd: 0;
     }
 },
 _s8YtG() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s8YtG: // global
           _s8YtN::I64 = I64[Sp + 16] - I64[Sp + 8];
           if (%MO_S_Gt_W64(_s8YtN::I64, 0)) goto c8ZRs; else goto c8ZRt;
       c8ZRs: // global
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           I64[Sp + 16] = _s8YtN::I64 - 1;
           Sp = Sp - 8;
           call _c8ZQ9() args: 0, res: 0, upd: 0;
       c8ZRt: // global
           _s8Yti::P64 = P64[Sp + 32];
           _s8YtI::P64 = P64[Sp + 40];
           call MO_Touch(P64[Sp]);
           I64[Sp + 40] = block_c8ZQZ_info;
           R2 = _s8YtI::P64;
           R1 = _s8Yti::P64;
           Sp = Sp + 40;
           call $wgo_s8Yti_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZQ9() //  []
         { info_tbl: [(c8ZQ9,
                       label: block_c8ZQ9_info
                       rep:StackRep [False, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZQ9: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8ZRn; else goto c8ZRm;
       c8ZRn: // global
           HpAlloc = 40;
           I64[Sp] = block_c8ZQ9_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8ZRm: // global
           _s8YtJ::I64 = I64[Sp + 32];
           _s8Yu4::P64 = P64[Sp + 16];
           _s8Yu6::I64 = I64[Sp + 24];
           if (_s8Yu6::I64 != 0) goto c8ZRp; else goto c8ZRq;
       c8ZRp: // global
           _s8Yu9::I64 = %MO_UU_Conv_W32_W64(I32[_s8YtJ::I64 + (_s8Yu6::I64 << 2)]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s8Yu9::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8Yu4::P64;
           I64[Sp + 24] = _s8Yu6::I64 - 1;
           P64[Sp + 16] = Hp - 14;
           call _c8ZQ9() args: 0, res: 0, upd: 0;
       c8ZRq: // global
           Hp = Hp - 40;
           _s8Yti::P64 = P64[Sp + 40];
           _s8YtI::P64 = P64[Sp + 48];
           _s8YtU::I64 = %MO_UU_Conv_W32_W64(I32[_s8YtJ::I64]);
           call MO_Touch(P64[Sp + 8]);
           I64[Sp + 32] = block_c8ZQK_info;
           R2 = _s8YtI::P64;
           R1 = _s8Yti::P64;
           I64[Sp + 40] = _s8YtU::I64;
           P64[Sp + 48] = _s8Yu4::P64;
           Sp = Sp + 32;
           call $wgo_s8Yti_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZQK() //  [R1]
         { info_tbl: [(c8ZQK,
                       label: block_c8ZQK_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZQK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8ZRk; else goto c8ZRj;
       c8ZRk: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZRj: // global
           I64[Hp - 32] = sat_s8Yu1_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ZQZ() //  [R1]
         { info_tbl: [(c8ZQZ,
                       label: block_c8ZQZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZQZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8ZRw; else goto c8ZRv;
       c8ZRw: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZRv: // global
           I64[Hp - 16] = sat_s8Yui_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8Yvd_entry() //  [R1, R2]
         { info_tbl: [(c8ZSS,
                       label: sat_s8Yvd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZSS: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c8ZST; else goto c8ZSU;
       c8ZST: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZSU: // global
           I64[Sp - 24] = block_c8ZOW_info;
           _s8YsV::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 16] = _s8YsV::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u8ZTe; else goto c8ZOX;
       u8ZTe: // global
           call _c8ZOW(R1) args: 0, res: 0, upd: 0;
       c8ZOX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZOW() //  [R1]
         { info_tbl: [(c8ZOW,
                       label: block_c8ZOW_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZOW: // global
           I64[Sp - 8] = block_c8ZP1_info;
           _s8YsZ::I64 = I64[R1 + 7];
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp] = _s8YsZ::I64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZP1() //  [R1]
         { info_tbl: [(c8ZP1,
                       label: block_c8ZP1_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZP1: // global
           I64[Sp] = block_c8ZP3_info;
           _s8Yt2::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8Yt2::P64;
           if (R1 & 7 != 0) goto u8ZTd; else goto c8ZP4;
       u8ZTd: // global
           call _c8ZP3(R1) args: 0, res: 0, upd: 0;
       c8ZP4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZP3() //  [R1]
         { info_tbl: [(c8ZP3,
                       label: block_c8ZP3_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZP3: // global
           _s8Yt4::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s8Yt4::I64, 1)) goto c8ZTb; else goto c8ZTc;
       c8ZTb: // global
           _s8Yt6::I64 = _s8Yt4::I64;
           goto s8Yt5;
       c8ZTc: // global
           _s8Yt6::I64 = 1;
           goto s8Yt5;
       s8Yt5: // global
           _s8Yt7::I64 = _s8Yt6::I64 << 2;
           if (%MO_S_Ge_W64(_s8Yt7::I64, 0)) goto c8ZT2; else goto c8ZT7;
       c8ZT2: // global
           I64[Sp - 24] = block_c8ZPj_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = _s8Yt6::I64;
           I64[Sp - 8] = _s8Yt7::I64;
           I64[Sp] = _s8Yt4::I64;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c8ZT7: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c8ZPj() //  [R1]
         { info_tbl: [(c8ZPj,
                       label: block_c8ZPj_info
                       rep:StackRep [True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZPj: // global
           I64[Sp] = block_c8ZPl_info;
           _s8Ytb::P64 = R1;
           R1 = I64[Sp + 16];
           P64[Sp + 16] = _s8Ytb::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZPl() //  [R1]
         { info_tbl: [(c8ZPl,
                       label: block_c8ZPl_info
                       rep:StackRep [True, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZPl: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto c8ZT6; else goto c8ZT5;
       c8ZT6: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZT5: // global
           I64[Hp - 168] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 160] = R1;
           P64[Hp - 152] = P64[Sp + 16];
           I64[Hp - 144] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 136] = Hp - 166;
           P64[Hp - 128] = GHC.IO.Buffer.WriteBuffer_closure+2;
           P64[Hp - 120] = R1 + 16;
           I64[Hp - 112] = I64[Sp + 8];
           I64[Hp - 104] = 0;
           I64[Hp - 96] = 0;
           I64[Hp - 88] = $wgo_s8Yti_info;
           P64[Hp - 80] = P64[Sp + 48];
           P64[Hp - 72] = Hp - 143;
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 40];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = I64[Sp + 32];
           _s8Yt4::I64 = I64[Sp + 24];
           I64[Hp - 16] = _s8Yt4::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _s8Yt4::I64;
           R2 = Hp - 47;
           R1 = Hp - 86;
           Sp = Sp + 56;
           call $wgo_s8Yti_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.C.String.peekCStringLen1_entry() //  [R2]
         { info_tbl: [(c8ZTf,
                       label: Foreign.C.String.peekCStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZTf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ZTg; else goto c8ZTh;
       c8ZTg: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZTh: // global
           I64[Sp - 16] = block_c8ZOF_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZOF() //  [R1]
         { info_tbl: [(c8ZOF,
                       label: block_c8ZOF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZOF: // global
           I64[Sp] = block_c8ZOH_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u8ZTn; else goto c8ZOI;
       u8ZTn: // global
           call _c8ZOH(R1) args: 0, res: 0, upd: 0;
       c8ZOI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZOH() //  [R1]
         { info_tbl: [(c8ZOH,
                       label: block_c8ZOH_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZOH: // global
           I64[Sp] = block_c8ZOM_info;
           _s8YsR::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8YsR::P64;
           if (R1 & 7 != 0) goto u8ZTo; else goto c8ZON;
       u8ZTo: // global
           call _c8ZOM(R1) args: 0, res: 0, upd: 0;
       c8ZON: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZOM() //  [R1]
         { info_tbl: [(c8ZOM,
                       label: block_c8ZOM_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZOM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c8ZTm; else goto c8ZTl;
       c8ZTm: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZTl: // global
           _s8YsU::P64 = P64[R1 + 7];
           _s8YsV::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_s8Yvd_info;
           P64[Hp - 8] = _s8YsU::P64;
           P64[Hp] = _s8YsV::P64;
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.871434374 UTC

[section ""data" . Foreign.C.String.peekCStringLen_closure" {
     Foreign.C.String.peekCStringLen_closure:
         const Foreign.C.String.peekCStringLen_info;
         const 0;
 },
 Foreign.C.String.peekCStringLen_entry() //  [R2]
         { info_tbl: [(c8ZVU,
                       label: Foreign.C.String.peekCStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZVU: // global
           R2 = R2;
           call Foreign.C.String.peekCStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.874890422 UTC

[section ""data" . Foreign.C.String.peekCString1_closure" {
     Foreign.C.String.peekCString1_closure:
         const Foreign.C.String.peekCString1_info;
         const 0;
 },
 Foreign.C.String.peekCString1_entry() //  [R2]
         { info_tbl: [(c8ZW7,
                       label: Foreign.C.String.peekCString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZW7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c8ZW8; else goto c8ZW9;
       c8ZW8: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZW9: // global
           I64[Sp - 16] = block_c8ZW5_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZW5() //  [R1]
         { info_tbl: [(c8ZW5,
                       label: block_c8ZW5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZW5: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.peekCString1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.880052503 UTC

[section ""data" . Foreign.C.String.peekCString_closure" {
     Foreign.C.String.peekCString_closure:
         const Foreign.C.String.peekCString_info;
         const 0;
 },
 Foreign.C.String.peekCString_entry() //  [R2]
         { info_tbl: [(c8ZWn,
                       label: Foreign.C.String.peekCString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZWn: // global
           R2 = R2;
           call Foreign.C.String.peekCString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.883652454 UTC

[section ""data" . Foreign.C.String.castCSCharToChar_closure" {
     Foreign.C.String.castCSCharToChar_closure:
         const Foreign.C.String.castCSCharToChar_info;
 },
 Foreign.C.String.castCSCharToChar_entry() //  [R2]
         { info_tbl: [(c8ZWB,
                       label: Foreign.C.String.castCSCharToChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZWB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8ZWR; else goto c8ZWS;
       c8ZWR: // global
           R2 = R2;
           R1 = Foreign.C.String.castCSCharToChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZWS: // global
           I64[Sp - 8] = block_c8ZWy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ZWW; else goto c8ZWz;
       u8ZWW: // global
           call _c8ZWy(R1) args: 0, res: 0, upd: 0;
       c8ZWz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZWy() //  [R1]
         { info_tbl: [(c8ZWy,
                       label: block_c8ZWy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZWy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8ZWV; else goto c8ZWU;
       c8ZWV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZWU: // global
           _s8Yvp::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s8Yvp::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.890408679 UTC

[section ""data" . Foreign.C.String.castCUCharToChar_closure" {
     Foreign.C.String.castCUCharToChar_closure:
         const Foreign.C.String.castCUCharToChar_info;
 },
 Foreign.C.String.castCUCharToChar_entry() //  [R2]
         { info_tbl: [(c8ZXf,
                       label: Foreign.C.String.castCUCharToChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZXf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8ZXp; else goto c8ZXq;
       c8ZXp: // global
           R2 = R2;
           R1 = Foreign.C.String.castCUCharToChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZXq: // global
           I64[Sp - 8] = block_c8ZXc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ZXu; else goto c8ZXd;
       u8ZXu: // global
           call _c8ZXc(R1) args: 0, res: 0, upd: 0;
       c8ZXd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZXc() //  [R1]
         { info_tbl: [(c8ZXc,
                       label: block_c8ZXc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZXc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8ZXt; else goto c8ZXs;
       c8ZXt: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZXs: // global
           _s8Yvu::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s8Yvu::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.895939352 UTC

[section ""data" . Foreign.C.String.castCCharToChar_closure" {
     Foreign.C.String.castCCharToChar_closure:
         const Foreign.C.String.castCCharToChar_info;
 },
 Foreign.C.String.castCCharToChar_entry() //  [R2]
         { info_tbl: [(c8ZXM,
                       label: Foreign.C.String.castCCharToChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZXM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c8ZY2; else goto c8ZY3;
       c8ZY2: // global
           R2 = R2;
           R1 = Foreign.C.String.castCCharToChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZY3: // global
           I64[Sp - 8] = block_c8ZXJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u8ZY7; else goto c8ZXK;
       u8ZY7: // global
           call _c8ZXJ(R1) args: 0, res: 0, upd: 0;
       c8ZXK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c8ZXJ() //  [R1]
         { info_tbl: [(c8ZXJ,
                       label: block_c8ZXJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZXJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c8ZY6; else goto c8ZY5;
       c8ZY6: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c8ZY5: // global
           _s8YvB::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s8YvB::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.902738783 UTC

[section ""data" . Foreign.C.String.$wpeekCAString_closure" {
     Foreign.C.String.$wpeekCAString_closure:
         const Foreign.C.String.$wpeekCAString_info;
 },
 Foreign.C.String.$wpeekCAString_entry() //  [R2]
         { info_tbl: [(c8ZYZ,
                       label: Foreign.C.String.$wpeekCAString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZYZ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c8ZZ0; else goto c8ZZ1;
       c8ZZ0: // global
           R2 = R2;
           R1 = Foreign.C.String.$wpeekCAString_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c8ZZ1: // global
           _s8YvC::I64 = R2;
           _s8Yw5::I64 = 0;
           goto c8ZZs;
       c8ZZs: // global
           if (I8[_s8YvC::I64 + _s8Yw5::I64] == 0 :: W8) goto c8ZZy; else goto c8ZZx;
       c8ZZy: // global
           if (%MO_S_Gt_W64(_s8Yw5::I64, 0)) goto c8ZZp; else goto c8ZZq;
       c8ZZp: // global
           I64[Sp - 24] = _s8YvC::I64;
           P64[Sp - 16] = GHC.Types.[]_closure+1;
           I64[Sp - 8] = _s8Yw5::I64 - 1;
           Sp = Sp - 32;
           call _c8ZYA() args: 0, res: 0, upd: 0;
       c8ZZq: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c8ZZx: // global
           _s8Yw5::I64 = _s8Yw5::I64 + 1;
           goto c8ZZs;
     }
 },
 _c8ZYA() //  []
         { info_tbl: [(c8ZYA,
                       label: block_c8ZYA_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c8ZYA: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c8ZZ5; else goto c8ZZ4;
       c8ZZ5: // global
           HpAlloc = 40;
           I64[Sp] = block_c8ZYA_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c8ZZ4: // global
           _s8YvJ::P64 = P64[Sp + 16];
           _s8YvK::I64 = I64[Sp + 24];
           _s8YvO::I64 = %MO_SS_Conv_W8_W64(I8[I64[Sp + 8] + _s8YvK::I64]);
           if (%MO_S_Gt_W64(_s8YvK::I64, 0)) goto c8ZZ7; else goto c8ZZn;
       c8ZZ7: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s8YvO::I64));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YvJ::P64;
           P64[Sp + 16] = Hp - 14;
           I64[Sp + 24] = _s8YvK::I64 - 1;
           call _c8ZYA() args: 0, res: 0, upd: 0;
       c8ZZn: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s8YvO::I64));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YvJ::P64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.909549818 UTC

[section ""data" . Foreign.C.String.peekCAString1_closure" {
     Foreign.C.String.peekCAString1_closure:
         const Foreign.C.String.peekCAString1_info;
 },
 Foreign.C.String.peekCAString1_entry() //  [R2]
         { info_tbl: [(c9006,
                       label: Foreign.C.String.peekCAString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9006: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9007; else goto c9008;
       c9007: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCAString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9008: // global
           I64[Sp - 8] = block_c9003_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u900c; else goto c9004;
       u900c: // global
           call _c9003(R1) args: 0, res: 0, upd: 0;
       c9004: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9003() //  [R1]
         { info_tbl: [(c9003,
                       label: block_c9003_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9003: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call Foreign.C.String.$wpeekCAString_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.914676086 UTC

[section ""data" . Foreign.C.String.peekCAString_closure" {
     Foreign.C.String.peekCAString_closure:
         const Foreign.C.String.peekCAString_info;
 },
 Foreign.C.String.peekCAString_entry() //  [R2]
         { info_tbl: [(c900q,
                       label: Foreign.C.String.peekCAString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c900q: // global
           R2 = R2;
           call Foreign.C.String.peekCAString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.918989792 UTC

[section ""data" . Foreign.C.String.$wpeekCAStringLen_closure" {
     Foreign.C.String.$wpeekCAStringLen_closure:
         const Foreign.C.String.$wpeekCAStringLen_info;
 },
 Foreign.C.String.$wpeekCAStringLen_entry() //  [R2, R3]
         { info_tbl: [(c901d,
                       label: Foreign.C.String.$wpeekCAStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c901d: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c901e; else goto c901f;
       c901e: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.$wpeekCAStringLen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c901f: // global
           if (%MO_S_Gt_W64(R3, 0)) goto c901b; else goto c901c;
       c901b: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = GHC.Types.[]_closure+1;
           I64[Sp - 8] = R3 - 1;
           Sp = Sp - 24;
           call _c900J() args: 0, res: 0, upd: 0;
       c901c: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c900J() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c900J: // global
           I64[Sp - 8] = block_c900M_info;
           R1 = P64[Sp];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u901E; else goto c900N;
       u901E: // global
           call _c900M(R1) args: 0, res: 0, upd: 0;
       c900N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c900M() //  [R1]
         { info_tbl: [(c900M,
                       label: block_c900M_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c900M: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c901j; else goto c901i;
       c901j: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c901i: // global
           _s8Ywl::P64 = P64[Sp + 16];
           _s8Ywm::I64 = I64[Sp + 24];
           _s8Yws::I64 = %MO_SS_Conv_W8_W64(I8[I64[R1 + 7] + _s8Ywm::I64]);
           if (_s8Ywm::I64 == 0) goto c901B; else goto c901l;
       c901B: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s8Yws::I64));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8Ywl::P64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c901l: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s8Yws::I64));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8Ywl::P64;
           P64[Sp + 16] = Hp - 14;
           I64[Sp + 24] = _s8Ywm::I64 - 1;
           Sp = Sp + 8;
           call _c900J() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.927147751 UTC

[section ""data" . Foreign.C.String.peekCAStringLen1_closure" {
     Foreign.C.String.peekCAStringLen1_closure:
         const Foreign.C.String.peekCAStringLen1_info;
 },
 Foreign.C.String.peekCAStringLen1_entry() //  [R2]
         { info_tbl: [(c902b,
                       label: Foreign.C.String.peekCAStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c902b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c902f; else goto c902g;
       c902f: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCAStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c902g: // global
           I64[Sp - 8] = block_c9028_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u902o; else goto c9029;
       u902o: // global
           call _c9028(R1) args: 0, res: 0, upd: 0;
       c9029: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9028() //  [R1]
         { info_tbl: [(c9028,
                       label: block_c9028_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9028: // global
           I64[Sp - 8] = block_c902e_info;
           _s8YwL::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s8YwL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u902n; else goto c902i;
       u902n: // global
           call _c902e(R1) args: 0, res: 0, upd: 0;
       c902i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c902e() //  [R1]
         { info_tbl: [(c902e,
                       label: block_c902e_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c902e: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.C.String.$wpeekCAStringLen_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.935089952 UTC

[section ""data" . Foreign.C.String.peekCAStringLen_closure" {
     Foreign.C.String.peekCAStringLen_closure:
         const Foreign.C.String.peekCAStringLen_info;
 },
 Foreign.C.String.peekCAStringLen_entry() //  [R2]
         { info_tbl: [(c902G,
                       label: Foreign.C.String.peekCAStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c902G: // global
           R2 = R2;
           call Foreign.C.String.peekCAStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.938592418 UTC

[section ""data" . Foreign.C.String.castCWcharToChar_closure" {
     Foreign.C.String.castCWcharToChar_closure:
         const Foreign.C.String.castCWcharToChar_info;
         const 0;
 },
 Foreign.C.String.castCWcharToChar_entry() //  [R2]
         { info_tbl: [(c902U,
                       label: Foreign.C.String.castCWcharToChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c902U: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c902V; else goto c902W;
       c902V: // global
           R2 = R2;
           R1 = Foreign.C.String.castCWcharToChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c902W: // global
           I64[Sp - 8] = block_c902R_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u903g; else goto c902S;
       u903g: // global
           call _c902R(R1) args: 0, res: 0, upd: 0;
       c902S: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c902R() //  [R1]
         { info_tbl: [(c902R,
                       label: block_c902R_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c902R: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9031; else goto c9030;
       c9031: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9030: // global
           _s8YwR::I64 = I64[R1 + 7];
           if (_s8YwR::I64 > 1114111) goto c9038; else goto c903f;
       c9038: // global
           Hp = Hp - 16;
           R2 = _s8YwR::I64;
           Sp = Sp + 8;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c903f: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s8YwR::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.944708706 UTC

[section ""data" . Foreign.C.String.peekCWString2_closure" {
     Foreign.C.String.peekCWString2_closure:
         const Foreign.C.String.peekCWString2_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.C.String.peekCWString2_entry() //  [R1]
         { info_tbl: [(c903x,
                       label: Foreign.C.String.peekCWString2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c903x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c903y; else goto c903z;
       c903y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c903z: // global
           (_c903u::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c903u::I64 == 0) goto c903w; else goto c903v;
       c903w: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c903v: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c903u::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = Foreign.C.String.castCWcharToChar_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.949691854 UTC

[section ""data" . Foreign.C.String.$wpeekCWStringLen_closure" {
     Foreign.C.String.$wpeekCWStringLen_closure:
         const Foreign.C.String.$wpeekCWStringLen_info;
         const 0;
 },
 sat_s8Yx9_entry() //  [R1]
         { info_tbl: [(c904l,
                       label: sat_s8Yx9_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c904l: // global
           _s8Yx9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c904m; else goto c904n;
       c904n: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c904p; else goto c904o;
       c904p: // global
           HpAlloc = 40;
           goto c904m;
       c904m: // global
           R1 = _s8Yx9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c904o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8Yx9::P64;
           _s8Yx0::P64 = P64[_s8Yx9::P64 + 16];
           _s8Yx6::I64 = I64[_s8Yx9::P64 + 24];
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = _s8Yx6::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8Yx0::P64;
           R3 = Hp - 14;
           R2 = Foreign.C.String.castCWcharToChar_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.C.String.$wpeekCWStringLen_entry() //  [R2, R3]
         { info_tbl: [(c904t,
                       label: Foreign.C.String.$wpeekCWStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c904t: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c904u; else goto c904v;
       c904u: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.$wpeekCWStringLen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c904v: // global
           if (%MO_S_Gt_W64(R3, 0)) goto c904r; else goto c904s;
       c904r: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call _c903V() args: 0, res: 0, upd: 0;
       c904s: // global
           R1 = Foreign.C.String.peekCWString2_closure;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c903V() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c903V: // global
           _s8YwV::P64 = P64[Sp];
           _s8Yxe::I64 = I64[Sp + 8];
           if (_s8Yxe::I64 != 0) goto c904C; else goto c904G;
       c904C: // global
           I64[Sp - 8] = block_c9040_info;
           R1 = _s8YwV::P64;
           I64[Sp + 8] = _s8Yxe::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u904K; else goto c9041;
       u904K: // global
           call _c9040(R1) args: 0, res: 0, upd: 0;
       c9041: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c904G: // global
           I64[Sp + 8] = block_c904a_info;
           R1 = _s8YwV::P64;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u904L; else goto c904b;
       u904L: // global
           call _c904a(R1) args: 0, res: 0, upd: 0;
       c904b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9040() //  [R1]
         { info_tbl: [(c9040,
                       label: block_c9040_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9040: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c904F; else goto c904E;
       c904F: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c904E: // global
           _s8Yxe::I64 = I64[Sp + 16];
           _s8Yxj::I64 = %MO_SS_Conv_W32_W64(I32[I64[R1 + 7] + (_s8Yxe::I64 << 2)]);
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = _s8Yxj::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 16] = _s8Yxe::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           Sp = Sp + 8;
           call _c903V() args: 0, res: 0, upd: 0;
     }
 },
 _c904a() //  [R1]
         { info_tbl: [(c904a,
                       label: block_c904a_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c904a: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c904z; else goto c904y;
       c904z: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c904y: // global
           _s8Yx6::I64 = %MO_SS_Conv_W32_W64(I32[I64[R1 + 7]]);
           I64[Hp - 24] = sat_s8Yx9_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = _s8Yx6::I64;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.961772776 UTC

[section ""data" . Foreign.C.String.peekCWStringLen1_closure" {
     Foreign.C.String.peekCWStringLen1_closure:
         const Foreign.C.String.peekCWStringLen1_info;
         const 0;
 },
 Foreign.C.String.peekCWStringLen1_entry() //  [R2]
         { info_tbl: [(c905q,
                       label: Foreign.C.String.peekCWStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c905q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c905u; else goto c905v;
       c905u: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCWStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c905v: // global
           I64[Sp - 8] = block_c905n_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u905D; else goto c905o;
       u905D: // global
           call _c905n(R1) args: 0, res: 0, upd: 0;
       c905o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c905n() //  [R1]
         { info_tbl: [(c905n,
                       label: block_c905n_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c905n: // global
           I64[Sp - 8] = block_c905t_info;
           _s8Yxr::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s8Yxr::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u905C; else goto c905x;
       u905C: // global
           call _c905t(R1) args: 0, res: 0, upd: 0;
       c905x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c905t() //  [R1]
         { info_tbl: [(c905t,
                       label: block_c905t_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c905t: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.C.String.$wpeekCWStringLen_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.96907178 UTC

[section ""data" . Foreign.C.String.peekCWStringLen_closure" {
     Foreign.C.String.peekCWStringLen_closure:
         const Foreign.C.String.peekCWStringLen_info;
         const 0;
 },
 Foreign.C.String.peekCWStringLen_entry() //  [R2]
         { info_tbl: [(c905V,
                       label: Foreign.C.String.peekCWStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c905V: // global
           R2 = R2;
           call Foreign.C.String.peekCWStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.972121862 UTC

[section ""data" . Foreign.C.String.newCWString3_closure" {
     Foreign.C.String.newCWString3_closure:
         const GHC.Int.I32#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.975220124 UTC

[section ""data" . Foreign.C.String.$wpeekCWString_closure" {
     Foreign.C.String.$wpeekCWString_closure:
         const Foreign.C.String.$wpeekCWString_info;
         const 0;
 },
 sat_s8YxJ_entry() //  [R1]
         { info_tbl: [(c906C,
                       label: sat_s8YxJ_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c906C: // global
           _s8YxJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c906D; else goto c906E;
       c906E: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c906G; else goto c906F;
       c906G: // global
           HpAlloc = 40;
           goto c906D;
       c906D: // global
           R1 = _s8YxJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c906F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s8YxJ::P64;
           _s8YxC::P64 = P64[_s8YxJ::P64 + 16];
           _s8YxG::I64 = I64[_s8YxJ::P64 + 24];
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = _s8YxG::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YxC::P64;
           R3 = Hp - 14;
           R2 = Foreign.C.String.castCWcharToChar_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.C.String.$wpeekCWString_entry() //  [R2]
         { info_tbl: [(c906J,
                       label: Foreign.C.String.$wpeekCWString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c906J: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c906K; else goto c906L;
       c906K: // global
           R2 = R2;
           R1 = Foreign.C.String.$wpeekCWString_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c906L: // global
           _s8Yxv::I64 = R2;
           _s8YxX::I64 = 0;
           goto c9070;
       c9070: // global
           if (I32[_s8Yxv::I64 + (_s8YxX::I64 << 2)] == 0 :: W32) goto c9076; else goto c9075;
       c9076: // global
           if (%MO_S_Gt_W64(_s8YxX::I64, 0)) goto c906X; else goto c906Y;
       c906X: // global
           I64[Sp - 24] = _s8Yxv::I64;
           I64[Sp - 16] = _s8YxX::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call _c906m() args: 0, res: 0, upd: 0;
       c906Y: // global
           R1 = Foreign.C.String.peekCWString2_closure;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c9075: // global
           _s8YxX::I64 = _s8YxX::I64 + 1;
           goto c9070;
     }
 },
 _c906m() //  []
         { info_tbl: [(c906m,
                       label: block_c906m_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c906m: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c906S; else goto c906R;
       c906S: // global
           HpAlloc = 40;
           I64[Sp] = block_c906m_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c906R: // global
           _s8YxM::P64 = P64[Sp + 24];
           _s8YxO::I64 = I64[Sp + 16];
           if (_s8YxO::I64 != 0) goto c906U; else goto c906V;
       c906U: // global
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W32_W64(I32[I64[Sp + 8] + (_s8YxO::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s8YxM::P64;
           I64[Sp + 16] = _s8YxO::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           call _c906m() args: 0, res: 0, upd: 0;
       c906V: // global
           Hp = Hp - 40;
           P64[Sp + 24] = _s8YxM::P64;
           Sp = Sp + 8;
           call _c906u() args: 0, res: 0, upd: 0;
     }
 },
 _c906u() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c906u: // global
           Hp = Hp + 32;
           _s8YxC::P64 = P64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c906P; else goto c906O;
       c906P: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_c906t_info;
           R1 = _s8YxC::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c906O: // global
           I64[Hp - 24] = sat_s8YxJ_info;
           P64[Hp - 8] = _s8YxC::P64;
           I64[Hp] = %MO_SS_Conv_W32_W64(I32[I64[Sp]]);
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c906t() //  [R1]
         { info_tbl: [(c906t,
                       label: block_c906t_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c906t: // global
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c906u() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.986494663 UTC

[section ""data" . Foreign.C.String.peekCWString1_closure" {
     Foreign.C.String.peekCWString1_closure:
         const Foreign.C.String.peekCWString1_info;
         const 0;
 },
 Foreign.C.String.peekCWString1_entry() //  [R2]
         { info_tbl: [(c907R,
                       label: Foreign.C.String.peekCWString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c907R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c907S; else goto c907T;
       c907S: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCWString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c907T: // global
           I64[Sp - 8] = block_c907O_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u907X; else goto c907P;
       u907X: // global
           call _c907O(R1) args: 0, res: 0, upd: 0;
       c907P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c907O() //  [R1]
         { info_tbl: [(c907O,
                       label: block_c907O_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c907O: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call Foreign.C.String.$wpeekCWString_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.991900953 UTC

[section ""data" . Foreign.C.String.peekCWString_closure" {
     Foreign.C.String.peekCWString_closure:
         const Foreign.C.String.peekCWString_info;
         const 0;
 },
 Foreign.C.String.peekCWString_entry() //  [R2]
         { info_tbl: [(c908b,
                       label: Foreign.C.String.peekCWString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c908b: // global
           R2 = R2;
           call Foreign.C.String.peekCWString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:07.995342574 UTC

[section ""data" . Foreign.C.String.newCWString2_closure" {
     Foreign.C.String.newCWString2_closure:
         const Foreign.C.String.newCWString2_info;
 },
 Foreign.C.String.newCWString2_entry() //  [R2]
         { info_tbl: [(c908p,
                       label: Foreign.C.String.newCWString2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c908p: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c908z; else goto c908A;
       c908z: // global
           R2 = R2;
           R1 = Foreign.C.String.newCWString2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c908A: // global
           I64[Sp - 8] = block_c908m_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u908E; else goto c908n;
       u908E: // global
           call _c908m(R1) args: 0, res: 0, upd: 0;
       c908n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c908m() //  [R1]
         { info_tbl: [(c908m,
                       label: block_c908m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c908m: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c908D; else goto c908C;
       c908D: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c908C: // global
           _s8Yyc::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s8Yyc::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.002065221 UTC

[section ""data" . Foreign.C.String.withCWStringLen1_closure" {
     Foreign.C.String.withCWStringLen1_closure:
         const Foreign.C.String.withCWStringLen1_info;
 },
 Foreign.C.String.withCWStringLen1_entry() //  [R2, R3]
         { info_tbl: [(c908W,
                       label: Foreign.C.String.withCWStringLen1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c908W: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c9090; else goto c9091;
       c9090: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.withCWStringLen1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c9091: // global
           I64[Sp - 16] = block_c908U_info;
           _s8Yye::P64 = R3;
           R3 = R2;
           R2 = Foreign.C.String.newCWString2_closure+1;
           P64[Sp - 8] = _s8Yye::P64;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c908U() //  [R1]
         { info_tbl: [(c908U,
                       label: block_c908U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c908U: // global
           I64[Sp - 8] = block_c908Z_info;
           R3 = 0;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c908Z() //  [R1]
         { info_tbl: [(c908Z,
                       label: block_c908Z_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c908Z: // global
           I64[Sp - 8] = block_c909a_info;
           R2 = 4;
           _s8Yyh::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s8Yyh::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c909a() //  [R1]
         { info_tbl: [(c909a,
                       label: block_c909a_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c909a: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c909w() args: 0, res: 0, upd: 0;
     }
 },
 _c909w() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c909w: // global
           _s8YyA::P64 = P64[Sp];
           I64[Sp] = block_c909z_info;
           R1 = _s8YyA::P64;
           if (R1 & 7 != 0) goto u909Z; else goto c909B;
       u909Z: // global
           call _c909z(R1) args: 0, res: 0, upd: 0;
       c909B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c909z() //  [R1]
         { info_tbl: [(c909z,
                       label: block_c909z_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c909z: // global
           if (R1 & 7 == 1) goto u909W; else goto c909M;
       u909W: // global
           Sp = Sp + 8;
           call _c909j() args: 0, res: 0, upd: 0;
       c909M: // global
           I64[Sp - 8] = block_c909K_info;
           _s8YyF::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8YyF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u90a0; else goto c909N;
       u90a0: // global
           call _c909K(R1) args: 0, res: 0, upd: 0;
       c909N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c909j() //  []
         { info_tbl: [(c909j,
                       label: block_c909j_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c909j: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c909r; else goto c909q;
       c909r: // global
           HpAlloc = 56;
           I64[Sp] = block_c909j_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c909q: // global
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = I64[Sp + 16];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           I64[Sp + 16] = block_c909o_info;
           R2 = Hp - 15;
           R1 = P64[Sp + 32];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c909o() //  [R1]
         { info_tbl: [(c909o,
                       label: block_c909o_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c909o: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c909K() //  [R1]
         { info_tbl: [(c909K,
                       label: block_c909K_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c909K: // global
           _s8YyB::I64 = I64[Sp + 16];
           _s8YyF::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s8YyB::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s8YyF::P64;
           I64[Sp + 16] = _s8YyB::I64 + 1;
           Sp = Sp + 8;
           call _c909w() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.018184848 UTC

[section ""data" . Foreign.C.String.withCWStringLen_closure" {
     Foreign.C.String.withCWStringLen_closure:
         const Foreign.C.String.withCWStringLen_info;
 },
 Foreign.C.String.withCWStringLen_entry() //  [R2, R3]
         { info_tbl: [(c90aN,
                       label: Foreign.C.String.withCWStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90aN: // global
           R3 = R3;
           R2 = R2;
           call Foreign.C.String.withCWStringLen1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.022186701 UTC

[section ""data" . Foreign.C.String.withCWString_closure" {
     Foreign.C.String.withCWString_closure:
         const Foreign.C.String.withCWString_info;
         const 0;
 },
 vals_s8YyL_entry() //  [R1]
         { info_tbl: [(c90b2,
                       label: vals_s8YyL_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90b2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c90b3; else goto c90b4;
       c90b3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c90b4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Foreign.C.String.newCWString2_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s8YyO_entry() //  [R1]
         { info_tbl: [(c90bf,
                       label: sat_s8YyO_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90bf: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s8YyP_entry() //  [R1, R2]
         { info_tbl: [(c90bi,
                       label: sat_s8YyP_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90bi: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c90bm; else goto c90bl;
       c90bm: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90bl: // global
           _s8YyL::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s8YyO_info;
           P64[Hp] = R2;
           R5 = Hp - 7;
           R4 = _s8YyL::P64;
           R3 = Foreign.C.String.newCWString3_closure+1;
           R2 = Foreign.C.Types.$fStorableCWchar_closure;
           call Foreign.Marshal.Array.withArrayLen0_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.C.String.withCWString_entry() //  [R2]
         { info_tbl: [(c90bn,
                       label: Foreign.C.String.withCWString_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90bn: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c90br; else goto c90bq;
       c90br: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.C.String.withCWString_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90bq: // global
           I64[Hp - 32] = vals_s8YyL_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s8YyP_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.031109452 UTC

[section ""data" . Foreign.C.String.newCWString1_closure" {
     Foreign.C.String.newCWString1_closure:
         const Foreign.C.String.newCWString1_info;
         const 0;
 },
 Foreign.C.String.newCWString1_entry() //  [R2]
         { info_tbl: [(c90bO,
                       label: Foreign.C.String.newCWString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90bO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c90bP; else goto c90bQ;
       c90bP: // global
           R2 = R2;
           R1 = Foreign.C.String.newCWString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90bQ: // global
           I64[Sp - 8] = block_c90bM_info;
           R3 = R2;
           R2 = Foreign.C.String.newCWString2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c90bM() //  [R1]
         { info_tbl: [(c90bM,
                       label: block_c90bM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90bM: // global
           R4 = R1;
           R3 = Foreign.C.String.newCWString3_closure+1;
           R2 = Foreign.C.Types.$fStorableCWchar_closure;
           Sp = Sp + 8;
           call Foreign.Marshal.Array.newArray3_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.0367068 UTC

[section ""data" . Foreign.C.String.newCWString_closure" {
     Foreign.C.String.newCWString_closure:
         const Foreign.C.String.newCWString_info;
         const 0;
 },
 Foreign.C.String.newCWString_entry() //  [R2]
         { info_tbl: [(c90c6,
                       label: Foreign.C.String.newCWString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90c6: // global
           R2 = R2;
           call Foreign.C.String.newCWString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.040807401 UTC

[section ""data" . Foreign.C.String.newCWStringLen1_closure" {
     Foreign.C.String.newCWStringLen1_closure:
         const Foreign.C.String.newCWStringLen1_info;
         const 0;
 },
 sat_s8Yz0_entry() //  [R1]
         { info_tbl: [(c90ct,
                       label: sat_s8Yz0_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90ct: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c90cx; else goto c90cy;
       c90cx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c90cy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c90cr_info;
           R3 = 0;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c90cr() //  [R1]
         { info_tbl: [(c90cr,
                       label: block_c90cr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90cr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c90cB; else goto c90cA;
       c90cB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c90cA: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.C.String.newCWStringLen1_entry() //  [R2]
         { info_tbl: [(c90cC,
                       label: Foreign.C.String.newCWStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90cC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c90cE; else goto c90cF;
       c90cE: // global
           R2 = R2;
           R1 = Foreign.C.String.newCWStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90cF: // global
           I64[Sp - 8] = block_c90ch_info;
           R3 = R2;
           R2 = Foreign.C.String.newCWString2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c90ch() //  [R1]
         { info_tbl: [(c90ch,
                       label: block_c90ch_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90ch: // global
           I64[Sp - 8] = block_c90cl_info;
           R3 = R1;
           R2 = Foreign.C.Types.$fStorableCWchar_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call Foreign.Marshal.Array.newArray1_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c90cl() //  [R1]
         { info_tbl: [(c90cl,
                       label: block_c90cl_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90cl: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c90cJ; else goto c90cI;
       c90cJ: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c90cI: // global
           I64[Hp - 40] = sat_s8Yz0_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.05112646 UTC

[section ""data" . Foreign.C.String.newCWStringLen_closure" {
     Foreign.C.String.newCWStringLen_closure:
         const Foreign.C.String.newCWStringLen_info;
         const 0;
 },
 Foreign.C.String.newCWStringLen_entry() //  [R2]
         { info_tbl: [(c90da,
                       label: Foreign.C.String.newCWStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90da: // global
           R2 = R2;
           call Foreign.C.String.newCWStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.054986532 UTC

[section ""data" . Foreign.C.String.castCharToCChar1_closure" {
     Foreign.C.String.castCharToCChar1_closure:
         const Foreign.C.String.castCharToCChar1_info;
 },
 Foreign.C.String.castCharToCChar1_entry() //  [R2]
         { info_tbl: [(c90do,
                       label: Foreign.C.String.castCharToCChar1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90do: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c90dy; else goto c90dz;
       c90dy: // global
           R2 = R2;
           R1 = Foreign.C.String.castCharToCChar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90dz: // global
           I64[Sp - 8] = block_c90dl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u90dD; else goto c90dm;
       u90dD: // global
           call _c90dl(R1) args: 0, res: 0, upd: 0;
       c90dm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90dl() //  [R1]
         { info_tbl: [(c90dl,
                       label: block_c90dl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90dl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c90dC; else goto c90dB;
       c90dC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c90dB: // global
           _s8Yz6::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s8Yz6::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.060455851 UTC

[section ""data" . Foreign.C.String.castCharToCSChar_closure" {
     Foreign.C.String.castCharToCSChar_closure:
         const Foreign.C.String.castCharToCSChar_info;
 },
 Foreign.C.String.castCharToCSChar_entry() //  [R2]
         { info_tbl: [(c90dT,
                       label: Foreign.C.String.castCharToCSChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90dT: // global
           R2 = R2;
           call Foreign.C.String.castCharToCChar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.063753466 UTC

[section ""data" . Foreign.C.String.castCharToCUChar1_closure" {
     Foreign.C.String.castCharToCUChar1_closure:
         const Foreign.C.String.castCharToCUChar1_info;
 },
 Foreign.C.String.castCharToCUChar1_entry() //  [R2]
         { info_tbl: [(c90e7,
                       label: Foreign.C.String.castCharToCUChar1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90e7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c90ek; else goto c90el;
       c90ek: // global
           R2 = R2;
           R1 = Foreign.C.String.castCharToCUChar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90el: // global
           I64[Sp - 8] = block_c90e4_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u90ep; else goto c90e5;
       u90ep: // global
           call _c90e4(R1) args: 0, res: 0, upd: 0;
       c90e5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90e4() //  [R1]
         { info_tbl: [(c90e4,
                       label: block_c90e4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90e4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c90eo; else goto c90en;
       c90eo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c90en: // global
           _s8Yzc::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s8Yzc::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.07013929 UTC

[section ""data" . Foreign.C.String.castCharToCUChar_closure" {
     Foreign.C.String.castCharToCUChar_closure:
         const Foreign.C.String.castCharToCUChar_info;
 },
 Foreign.C.String.castCharToCUChar_entry() //  [R2]
         { info_tbl: [(c90eF,
                       label: Foreign.C.String.castCharToCUChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90eF: // global
           R2 = R2;
           call Foreign.C.String.castCharToCUChar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.073345459 UTC

[section ""data" . Foreign.C.String.castCharToCChar_closure" {
     Foreign.C.String.castCharToCChar_closure:
         const Foreign.C.String.castCharToCChar_info;
 },
 Foreign.C.String.castCharToCChar_entry() //  [R2]
         { info_tbl: [(c90eQ,
                       label: Foreign.C.String.castCharToCChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90eQ: // global
           R2 = R2;
           call Foreign.C.String.castCharToCChar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.077377878 UTC

[section ""data" . Foreign.C.String.newCAString1_closure" {
     Foreign.C.String.newCAString1_closure:
         const Foreign.C.String.newCAString1_info;
         const 0;
 },
 Foreign.C.String.newCAString1_entry() //  [R2]
         { info_tbl: [(c90f3,
                       label: Foreign.C.String.newCAString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90f3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c90f4; else goto c90f5;
       c90f4: // global
           R2 = R2;
           R1 = Foreign.C.String.newCAString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90f5: // global
           I64[Sp - 16] = block_c90f1_info;
           R3 = 0;
           _s8Yzd::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s8Yzd::P64;
           Sp = Sp - 16;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c90f1() //  [R1]
         { info_tbl: [(c90f1,
                       label: block_c90f1_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90f1: // global
           _s8Yzd::P64 = P64[Sp + 8];
           (_s8Yzl::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(R1 + 1);
           if (_s8Yzl::I64 == 0) goto c90fT; else goto c90fS;
       c90fT: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c90fS: // global
           I64[Sp - 8] = 0;
           P64[Sp] = _s8Yzd::P64;
           I64[Sp + 8] = _s8Yzl::I64;
           Sp = Sp - 8;
           call _c90fv() args: 0, res: 0, upd: 0;
     }
 },
 _c90fv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90fv: // global
           I64[Sp - 8] = block_c90fy_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u90g8; else goto c90fA;
       u90g8: // global
           call _c90fy(R1) args: 0, res: 0, upd: 0;
       c90fA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90fy() //  [R1]
         { info_tbl: [(c90fy,
                       label: block_c90fy_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90fy: // global
           if (R1 & 7 == 1) goto c90fG; else goto c90fL;
       c90fG: // global
           I64[Sp + 16] = I64[Sp + 8];
           Sp = Sp + 16;
           call _c90fn() args: 0, res: 0, upd: 0;
       c90fL: // global
           I64[Sp] = block_c90fJ_info;
           _s8Yzy::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _s8Yzy::P64;
           if (R1 & 7 != 0) goto u90g9; else goto c90fM;
       u90g9: // global
           call _c90fJ(R1) args: 0, res: 0, upd: 0;
       c90fM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90fn() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90fn: // global
           Hp = Hp + 16;
           _s8Yzo::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c90fs; else goto c90fr;
       c90fs: // global
           HpAlloc = 16;
           I64[Sp] = block_c90fm_info;
           R1 = _s8Yzo::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c90fr: // global
           _s8Yzl::I64 = I64[Sp + 8];
           I8[_s8Yzl::I64 + _s8Yzo::I64] = 0 :: W8;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8Yzl::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c90fm() //  [R1]
         { info_tbl: [(c90fm,
                       label: block_c90fm_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90fm: // global
           I64[Sp] = R1;
           call _c90fn() args: 0, res: 0, upd: 0;
     }
 },
 _c90fJ() //  [R1]
         { info_tbl: [(c90fJ,
                       label: block_c90fJ_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90fJ: // global
           _s8Yzu::I64 = I64[Sp + 8];
           _s8Yzy::P64 = P64[Sp + 16];
           I8[I64[Sp + 24] + _s8Yzu::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 16] = _s8Yzy::P64;
           I64[Sp + 8] = _s8Yzu::I64 + 1;
           Sp = Sp + 8;
           call _c90fv() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.090389991 UTC

[section ""data" . Foreign.C.String.newCAString_closure" {
     Foreign.C.String.newCAString_closure:
         const Foreign.C.String.newCAString_info;
         const 0;
 },
 Foreign.C.String.newCAString_entry() //  [R2]
         { info_tbl: [(c90gK,
                       label: Foreign.C.String.newCAString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90gK: // global
           R2 = R2;
           call Foreign.C.String.newCAString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.094448818 UTC

[section ""data" . Foreign.C.String.newCAStringLen1_closure" {
     Foreign.C.String.newCAStringLen1_closure:
         const Foreign.C.String.newCAStringLen1_info;
         const 0;
 },
 Foreign.C.String.newCAStringLen1_entry() //  [R2]
         { info_tbl: [(c90gX,
                       label: Foreign.C.String.newCAStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90gX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c90gY; else goto c90gZ;
       c90gY: // global
           R2 = R2;
           R1 = Foreign.C.String.newCAStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90gZ: // global
           I64[Sp - 16] = block_c90gV_info;
           R3 = 0;
           _s8YzF::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s8YzF::P64;
           Sp = Sp - 16;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c90gV() //  [R1]
         { info_tbl: [(c90gV,
                       label: block_c90gV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90gV: // global
           _s8YzF::P64 = P64[Sp + 8];
           (_s8YzN::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(R1 + 1);
           if (_s8YzN::I64 == 0) goto c90hP; else goto c90hO;
       c90hP: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c90hO: // global
           P64[Sp - 16] = _s8YzF::P64;
           I64[Sp - 8] = 0;
           I64[Sp] = _s8YzN::I64;
           I64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _c90hr() args: 0, res: 0, upd: 0;
     }
 },
 _c90hr() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90hr: // global
           _s8YzV::P64 = P64[Sp];
           I64[Sp] = block_c90hu_info;
           R1 = _s8YzV::P64;
           if (R1 & 7 != 0) goto u90i2; else goto c90hw;
       u90i2: // global
           call _c90hu(R1) args: 0, res: 0, upd: 0;
       c90hw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90hu() //  [R1]
         { info_tbl: [(c90hu,
                       label: block_c90hu_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90hu: // global
           if (R1 & 7 == 1) goto u90hZ; else goto c90hH;
       u90hZ: // global
           Sp = Sp + 8;
           call _c90hh() args: 0, res: 0, upd: 0;
       c90hH: // global
           I64[Sp - 8] = block_c90hF_info;
           _s8YA0::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8YA0::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u90i3; else goto c90hI;
       u90i3: // global
           call _c90hF(R1) args: 0, res: 0, upd: 0;
       c90hI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90hh() //  []
         { info_tbl: [(c90hh,
                       label: block_c90hh_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90hh: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c90ho; else goto c90hn;
       c90ho: // global
           HpAlloc = 56;
           I64[Sp] = block_c90hh_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c90hn: // global
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = I64[Sp + 16];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c90hF() //  [R1]
         { info_tbl: [(c90hF,
                       label: block_c90hF_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90hF: // global
           _s8YzW::I64 = I64[Sp + 16];
           _s8YA0::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s8YzW::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s8YA0::P64;
           I64[Sp + 16] = _s8YzW::I64 + 1;
           Sp = Sp + 8;
           call _c90hr() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.107477383 UTC

[section ""data" . Foreign.C.String.newCAStringLen_closure" {
     Foreign.C.String.newCAStringLen_closure:
         const Foreign.C.String.newCAStringLen_info;
         const 0;
 },
 Foreign.C.String.newCAStringLen_entry() //  [R2]
         { info_tbl: [(c90iF,
                       label: Foreign.C.String.newCAStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90iF: // global
           R2 = R2;
           call Foreign.C.String.newCAStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.111500031 UTC

[section ""data" . Foreign.C.String.withCAString1_closure" {
     Foreign.C.String.withCAString1_closure:
         const Foreign.C.String.withCAString1_info;
 },
 Foreign.C.String.withCAString1_entry() //  [R2, R3]
         { info_tbl: [(c90iS,
                       label: Foreign.C.String.withCAString1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90iS: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c90iT; else goto c90iU;
       c90iT: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.withCAString1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c90iU: // global
           I64[Sp - 24] = block_c90iQ_info;
           _s8YA9::P64 = R3;
           R3 = 0;
           _s8YA8::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s8YA8::P64;
           P64[Sp - 8] = _s8YA9::P64;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c90iQ() //  [R1]
         { info_tbl: [(c90iQ,
                       label: block_c90iQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90iQ: // global
           I64[Sp] = block_c90j1_info;
           R2 = 1;
           R1 = R1 + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90j1() //  [R1]
         { info_tbl: [(c90j1,
                       label: block_c90j1_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90j1: // global
           P64[Sp - 16] = P64[Sp + 8];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _c90jl() args: 0, res: 0, upd: 0;
     }
 },
 _c90jl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90jl: // global
           _s8YAu::P64 = P64[Sp];
           I64[Sp] = block_c90jo_info;
           R1 = _s8YAu::P64;
           if (R1 & 7 != 0) goto u90jW; else goto c90jq;
       u90jW: // global
           call _c90jo(R1) args: 0, res: 0, upd: 0;
       c90jq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90jo() //  [R1]
         { info_tbl: [(c90jo,
                       label: block_c90jo_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90jo: // global
           if (R1 & 7 == 1) goto c90jw; else goto c90jB;
       c90jw: // global
           I64[Sp + 8] = I64[Sp + 8];
           Sp = Sp + 8;
           call _c90ja() args: 0, res: 0, upd: 0;
       c90jB: // global
           I64[Sp - 8] = block_c90jz_info;
           _s8YAz::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8YAz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u90jX; else goto c90jC;
       u90jX: // global
           call _c90jz(R1) args: 0, res: 0, upd: 0;
       c90jC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90ja() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90ja: // global
           Hp = Hp + 16;
           _s8YAl::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c90jg; else goto c90jf;
       c90jg: // global
           HpAlloc = 16;
           I64[Sp] = block_c90j9_info;
           R1 = _s8YAl::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c90jf: // global
           _s8YA9::P64 = P64[Sp + 24];
           _s8YAj::I64 = I64[Sp + 8];
           I8[_s8YAj::I64 + _s8YAl::I64] = 0 :: W8;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s8YAj::I64;
           I64[Sp + 8] = block_c90jd_info;
           R2 = Hp - 7;
           R1 = _s8YA9::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90j9() //  [R1]
         { info_tbl: [(c90j9,
                       label: block_c90j9_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90j9: // global
           I64[Sp] = R1;
           call _c90ja() args: 0, res: 0, upd: 0;
     }
 },
 _c90jd() //  [R1]
         { info_tbl: [(c90jd,
                       label: block_c90jd_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90jd: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c90jz() //  [R1]
         { info_tbl: [(c90jz,
                       label: block_c90jz_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90jz: // global
           _s8YAv::I64 = I64[Sp + 16];
           _s8YAz::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s8YAv::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s8YAz::P64;
           I64[Sp + 16] = _s8YAv::I64 + 1;
           Sp = Sp + 8;
           call _c90jl() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.127444216 UTC

[section ""data" . Foreign.C.String.withCAString_closure" {
     Foreign.C.String.withCAString_closure:
         const Foreign.C.String.withCAString_info;
 },
 Foreign.C.String.withCAString_entry() //  [R2, R3]
         { info_tbl: [(c90kG,
                       label: Foreign.C.String.withCAString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90kG: // global
           R3 = R3;
           R2 = R2;
           call Foreign.C.String.withCAString1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.131700987 UTC

[section ""data" . Foreign.C.String.withCAStringLen1_closure" {
     Foreign.C.String.withCAStringLen1_closure:
         const Foreign.C.String.withCAStringLen1_info;
 },
 Foreign.C.String.withCAStringLen1_entry() //  [R2, R3]
         { info_tbl: [(c90kT,
                       label: Foreign.C.String.withCAStringLen1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90kT: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c90kU; else goto c90kV;
       c90kU: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.withCAStringLen1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c90kV: // global
           I64[Sp - 24] = block_c90kR_info;
           _s8YAH::P64 = R3;
           R3 = 0;
           _s8YAG::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s8YAG::P64;
           P64[Sp - 8] = _s8YAH::P64;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c90kR() //  [R1]
         { info_tbl: [(c90kR,
                       label: block_c90kR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90kR: // global
           I64[Sp - 8] = block_c90kY_info;
           R2 = 1;
           _s8YAJ::I64 = R1;
           R1 = R1;
           I64[Sp] = _s8YAJ::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90kY() //  [R1]
         { info_tbl: [(c90kY,
                       label: block_c90kY_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90kY: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c90ll() args: 0, res: 0, upd: 0;
     }
 },
 _c90ll() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90ll: // global
           _s8YB1::P64 = P64[Sp];
           I64[Sp] = block_c90lo_info;
           R1 = _s8YB1::P64;
           if (R1 & 7 != 0) goto u90lU; else goto c90lq;
       u90lU: // global
           call _c90lo(R1) args: 0, res: 0, upd: 0;
       c90lq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90lo() //  [R1]
         { info_tbl: [(c90lo,
                       label: block_c90lo_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90lo: // global
           if (R1 & 7 == 1) goto u90lR; else goto c90lB;
       u90lR: // global
           Sp = Sp + 8;
           call _c90l8() args: 0, res: 0, upd: 0;
       c90lB: // global
           I64[Sp - 8] = block_c90lz_info;
           _s8YB6::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8YB6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u90lV; else goto c90lC;
       u90lV: // global
           call _c90lz(R1) args: 0, res: 0, upd: 0;
       c90lC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90l8() //  []
         { info_tbl: [(c90l8,
                       label: block_c90l8_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90l8: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c90lg; else goto c90lf;
       c90lg: // global
           HpAlloc = 56;
           I64[Sp] = block_c90l8_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c90lf: // global
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = I64[Sp + 16];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           I64[Sp + 16] = block_c90ld_info;
           R2 = Hp - 15;
           R1 = P64[Sp + 32];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90ld() //  [R1]
         { info_tbl: [(c90ld,
                       label: block_c90ld_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90ld: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c90lz() //  [R1]
         { info_tbl: [(c90lz,
                       label: block_c90lz_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90lz: // global
           _s8YB2::I64 = I64[Sp + 16];
           _s8YB6::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s8YB2::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s8YB6::P64;
           I64[Sp + 16] = _s8YB2::I64 + 1;
           Sp = Sp + 8;
           call _c90ll() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.147422144 UTC

[section ""data" . Foreign.C.String.withCAStringLen_closure" {
     Foreign.C.String.withCAStringLen_closure:
         const Foreign.C.String.withCAStringLen_info;
 },
 Foreign.C.String.withCAStringLen_entry() //  [R2, R3]
         { info_tbl: [(c90mF,
                       label: Foreign.C.String.withCAStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90mF: // global
           R3 = R3;
           R2 = R2;
           call Foreign.C.String.withCAStringLen1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:08.151075832 UTC

[section ""relreadonly" . S8YDv_srt" {
     S8YDv_srt:
         const GHC.IO.Encoding.getForeignEncoding_closure;
         const Foreign.C.String.withCStringLen1_closure;
         const Foreign.C.String.withCString1_closure;
         const GHC.Foreign.charIsRepresentable1_closure;
         const Foreign.C.String.charIsRepresentable1_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Alloc.realloc2_closure;
         const Foreign.C.String.newCStringLen1_closure;
         const GHC.Foreign.newCString1_closure;
         const Foreign.C.String.newCString1_closure;
         const GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
         const Foreign.C.String.peekCStringLen1_closure;
         const GHC.Foreign.peekCString1_closure;
         const Foreign.C.String.peekCString1_closure;
         const GHC.Char.$wlvl_closure;
         const Foreign.C.String.castCWcharToChar_closure;
         const Foreign.C.String.peekCWString2_closure;
         const Foreign.C.String.$wpeekCWStringLen_closure;
         const Foreign.C.String.peekCWStringLen1_closure;
         const Foreign.C.String.$wpeekCWString_closure;
         const Foreign.C.String.peekCWString1_closure;
         const Foreign.Marshal.Array.withArrayLen0_closure;
         const Foreign.C.String.withCWString_closure;
         const Foreign.Marshal.Array.newArray3_closure;
         const Foreign.C.String.newCWString1_closure;
         const Foreign.Marshal.Array.newArray1_closure;
         const Foreign.C.String.newCWStringLen1_closure;
         const Foreign.C.String.newCAString1_closure;
         const Foreign.C.String.newCAStringLen1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.200410134 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:04:10.201442619 UTC

[section ""cstring" . Foreign.C.String.$trModule4_bytes" {
     Foreign.C.String.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.204341579 UTC

[section ""data" . Foreign.C.String.$trModule3_closure" {
     Foreign.C.String.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.C.String.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.205940149 UTC

[section ""cstring" . Foreign.C.String.$trModule2_bytes" {
     Foreign.C.String.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,67,46,83,116,114,105,110,103]
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.207665748 UTC

[section ""data" . Foreign.C.String.$trModule1_closure" {
     Foreign.C.String.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.C.String.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.209207875 UTC

[section ""data" . Foreign.C.String.$trModule_closure" {
     Foreign.C.String.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.C.String.$trModule3_closure+1;
         const Foreign.C.String.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.212916766 UTC

[section ""data" . Foreign.C.String.withCStringLen1_closure" {
     Foreign.C.String.withCStringLen1_closure:
         const Foreign.C.String.withCStringLen1_info;
         const 0;
 },
 $wgo_s90nf_entry() //  [R1, R2]
         { info_tbl: [(c90zF,
                       label: $wgo_s90nf_info
                       rep:HeapRep 3 ptrs { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90zF: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c90zG; else goto c90zH;
       c90zG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90zH: // global
           I64[Sp - 48] = block_c90zA_info;
           _s90nf::P64 = R1;
           _s90mO::P64 = P64[R1 + 6];
           _s90mX::P64 = P64[R1 + 14];
           _s90ne::P64 = P64[R1 + 22];
           R1 = R2;
           P64[Sp - 40] = _s90mO::P64;
           P64[Sp - 32] = _s90mX::P64;
           P64[Sp - 24] = _s90ne::P64;
           P64[Sp - 16] = _s90nf::P64;
           I64[Sp - 8] = R2;
           Sp = Sp - 48;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90zA() //  [R1]
         { info_tbl: [(c90zA,
                       label: block_c90zA_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90zA: // global
           I64[Sp] = block_c90zC_info;
           _s90nn::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s90nn::P64;
           if (R1 & 7 != 0) goto u90Ag; else goto c90zD;
       u90Ag: // global
           call _c90zC(R1) args: 0, res: 0, upd: 0;
       c90zD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90zC() //  [R1]
         { info_tbl: [(c90zC,
                       label: block_c90zC_info
                       rep:StackRep [False, False, False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90zC: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c90zN; else goto c90zM;
       c90zN: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c90zM: // global
           _s90np::P64 = P64[R1 + 7];
           _s90nq::P64 = P64[R1 + 15];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = I64[Sp + 40];
           _s90mO::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c90zS_info;
           R6 = P64[Sp + 16] + 16;
           R5 = P64[Sp + 24];
           R4 = GHC.Types.False_closure+1;
           R3 = _s90nq::P64;
           R2 = _s90np::P64;
           P64[Sp - 8] = Hp - 7;
           P64[Sp] = _s90mO::P64;
           Sp = Sp - 8;
           call GHC.Foreign.$wtryFillBufferAndCall_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 8, upd: 8;
     }
 },
 _c90zS() //  [R1]
         { info_tbl: [(c90zS,
                       label: block_c90zS_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90zS: // global
           I64[Sp] = block_c90zU_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u90Ah; else goto c90zW;
       u90Ah: // global
           call _c90zU(R1) args: 0, res: 0, upd: 0;
       c90zW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90zU() //  [R1]
         { info_tbl: [(c90zU,
                       label: block_c90zU_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90zU: // global
           if (R1 & 7 == 1) goto c90A6; else goto c90Ac;
       c90A6: // global
           I64[Sp] = block_c90A4_info;
           R2 = I64[Sp + 32] << 1;
           R1 = P64[Sp + 24];
           call $wgo_s90nf_entry(R2, R1) args: 8, res: 8, upd: 8;
       c90Ac: // global
           _s90nF::P64 = P64[R1 + 6];
           call MO_Touch(P64[Sp + 8]);
           R1 = _s90nF::P64;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c90A4() //  [R1]
         { info_tbl: [(c90A4,
                       label: block_c90A4_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90A4: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s90nX_entry() //  [R1, R2]
         { info_tbl: [(c90Ai,
                       label: sat_s90nX_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Ai: // global
           if ((Sp + -64) < SpLim) (likely: False) goto c90Aj; else goto c90Ak;
       c90Aj: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90Ak: // global
           I64[Sp - 32] = block_c90za_info;
           R3 = 0;
           _s90mX::P64 = R2;
           _s90mN::P64 = P64[R1 + 6];
           R2 = _s90mN::P64;
           P64[Sp - 24] = _s90mN::P64;
           P64[Sp - 16] = P64[R1 + 14];
           P64[Sp - 8] = _s90mX::P64;
           Sp = Sp - 32;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c90za() //  [R1]
         { info_tbl: [(c90za,
                       label: block_c90za_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90za: // global
           I64[Sp - 8] = block_c90zh_info;
           R2 = 4;
           _s90mZ::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s90mZ::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90zh() //  [R1]
         { info_tbl: [(c90zh,
                       label: block_c90zh_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90zh: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c90Az() args: 0, res: 0, upd: 0;
     }
 },
 _c90Az() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Az: // global
           _s90nN::P64 = P64[Sp];
           I64[Sp] = block_c90AC_info;
           R1 = _s90nN::P64;
           if (R1 & 7 != 0) goto u90B1; else goto c90AE;
       u90B1: // global
           call _c90AC(R1) args: 0, res: 0, upd: 0;
       c90AE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90AC() //  [R1]
         { info_tbl: [(c90AC,
                       label: block_c90AC_info
                       rep:StackRep [True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90AC: // global
           if (R1 & 7 == 1) goto c90AK; else goto c90AP;
       c90AK: // global
           I64[Sp + 8] = block_c90zr_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c90AP: // global
           I64[Sp - 8] = block_c90AN_info;
           _s90nS::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s90nS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u90B2; else goto c90AQ;
       u90B2: // global
           call _c90AN(R1) args: 0, res: 0, upd: 0;
       c90AQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90zr() //  [R1]
         { info_tbl: [(c90zr,
                       label: block_c90zr_info
                       rep:StackRep [True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90zr: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c90Aq; else goto c90Ap;
       c90Aq: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c90Ap: // global
           I64[Hp - 96] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 88] = R1;
           I64[Hp - 80] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 72] = Hp - 95;
           P64[Hp - 64] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 56] = I64[Sp + 8];
           _s90mZ::I64 = I64[Sp + 16];
           I64[Hp - 48] = _s90mZ::I64;
           I64[Hp - 40] = 0;
           I64[Hp - 32] = _s90mZ::I64;
           I64[Hp - 24] = $wgo_s90nf_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = Hp - 79;
           I64[Sp + 16] = block_c90Au_info;
           R2 = _s90mZ::I64 + 1;
           R1 = Hp - 22;
           Sp = Sp + 16;
           call $wgo_s90nf_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90Au() //  [R1]
         { info_tbl: [(c90Au,
                       label: block_c90Au_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Au: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c90AN() //  [R1]
         { info_tbl: [(c90AN,
                       label: block_c90AN_info
                       rep:StackRep [False, True, True, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90AN: // global
           _s90nO::I64 = I64[Sp + 16];
           _s90nS::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s90nO::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s90nS::P64;
           I64[Sp + 16] = _s90nO::I64 + 1;
           Sp = Sp + 8;
           call _c90Az() args: 0, res: 0, upd: 0;
     }
 },
 Foreign.C.String.withCStringLen1_entry() //  [R2, R3]
         { info_tbl: [(c90B4,
                       label: Foreign.C.String.withCStringLen1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90B4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c90B5; else goto c90B6;
       c90B5: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.withCStringLen1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c90B6: // global
           I64[Sp - 24] = block_c90yY_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90yY() //  [R1]
         { info_tbl: [(c90yY,
                       label: block_c90yY_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90yY: // global
           I64[Sp] = block_c90z0_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u90Bb; else goto c90z1;
       u90Bb: // global
           call _c90z0(R1) args: 0, res: 0, upd: 0;
       c90z1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90z0() //  [R1]
         { info_tbl: [(c90z0,
                       label: block_c90z0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90z0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c90Ba; else goto c90B9;
       c90Ba: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c90B9: // global
           _s90mW::P64 = P64[R1 + 23];
           I64[Hp - 16] = sat_s90nX_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s90mW::P64;
           Sp = Sp + 24;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.243634792 UTC

[section ""data" . Foreign.C.String.withCStringLen_closure" {
     Foreign.C.String.withCStringLen_closure:
         const Foreign.C.String.withCStringLen_info;
         const 0;
 },
 Foreign.C.String.withCStringLen_entry() //  [R2, R3]
         { info_tbl: [(c90CY,
                       label: Foreign.C.String.withCStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90CY: // global
           R3 = R3;
           R2 = R2;
           call Foreign.C.String.withCStringLen1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.247217366 UTC

[section ""data" . Foreign.C.String.withCString1_closure" {
     Foreign.C.String.withCString1_closure:
         const Foreign.C.String.withCString1_info;
         const 0;
 },
 Foreign.C.String.withCString1_entry() //  [R2, R3]
         { info_tbl: [(c90Db,
                       label: Foreign.C.String.withCString1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Db: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c90Dc; else goto c90Dd;
       c90Dc: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.withCString1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c90Dd: // global
           I64[Sp - 24] = block_c90D9_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90D9() //  [R1]
         { info_tbl: [(c90D9,
                       label: block_c90D9_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90D9: // global
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 24;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.252160024 UTC

[section ""data" . Foreign.C.String.withCString_closure" {
     Foreign.C.String.withCString_closure:
         const Foreign.C.String.withCString_info;
         const 0;
 },
 Foreign.C.String.withCString_entry() //  [R2, R3]
         { info_tbl: [(c90Ds,
                       label: Foreign.C.String.withCString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Ds: // global
           R3 = R3;
           R2 = R2;
           call Foreign.C.String.withCString1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.255454832 UTC

[section ""data" . Foreign.C.String.charIsRepresentable1_closure" {
     Foreign.C.String.charIsRepresentable1_closure:
         const Foreign.C.String.charIsRepresentable1_info;
         const 0;
 },
 Foreign.C.String.charIsRepresentable1_entry() //  [R2]
         { info_tbl: [(c90DF,
                       label: Foreign.C.String.charIsRepresentable1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90DF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c90DG; else goto c90DH;
       c90DG: // global
           R2 = R2;
           R1 = Foreign.C.String.charIsRepresentable1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90DH: // global
           I64[Sp - 16] = block_c90DD_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90DD() //  [R1]
         { info_tbl: [(c90DD,
                       label: block_c90DD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90DD: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable1_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.260358772 UTC

[section ""data" . Foreign.C.String.charIsRepresentable_closure" {
     Foreign.C.String.charIsRepresentable_closure:
         const Foreign.C.String.charIsRepresentable_info;
         const 0;
 },
 Foreign.C.String.charIsRepresentable_entry() //  [R2]
         { info_tbl: [(c90DW,
                       label: Foreign.C.String.charIsRepresentable_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90DW: // global
           R2 = R2;
           call Foreign.C.String.charIsRepresentable1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.263704963 UTC

[section ""data" . Foreign.C.String.newCStringLen2_closure" {
     Foreign.C.String.newCStringLen2_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.269107483 UTC

[section ""data" . Foreign.C.String.newCStringLen1_closure" {
     Foreign.C.String.newCStringLen1_closure:
         const Foreign.C.String.newCStringLen1_info;
         const 0;
 },
 sat_s90q2_entry() //  [R1]
         { info_tbl: [(c90FH,
                       label: sat_s90q2_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90FH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c90FM; else goto c90FN;
       c90FM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c90FN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c90FE_info;
           _s90oX::P64 = P64[R1 + 24];
           _s90oM::I64 = I64[R1 + 32];
           R1 = P64[R1 + 16];
           I64[Sp - 32] = _s90oM::I64;
           P64[Sp - 24] = _s90oX::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto u90FR; else goto c90FF;
       u90FR: // global
           call _c90FE(R1) args: 0, res: 0, upd: 0;
       c90FF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 _c90FE() //  [R1]
         { info_tbl: [(c90FE,
                       label: block_c90FE_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90FE: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c90FQ; else goto c90FP;
       c90FQ: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       c90FP: // global
           _s90q0::I64 = I64[R1 + 7];
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 16];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.WriteBuffer_closure+2;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = _s90q0::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = 0;
           R1 = Hp - 47;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_s90qg_entry() //  [R1, R2]
         { info_tbl: [(c90FS,
                       label: sat_s90qg_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90FS: // global
           if ((Sp + -80) < SpLim) (likely: False) goto c90FT; else goto c90FU;
       c90FT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90FU: // global
           I64[Sp - 24] = block_c90Ek_info;
           R3 = 0;
           _s90oi::P64 = R2;
           _s90o9::P64 = P64[R1 + 6];
           R2 = _s90o9::P64;
           P64[Sp - 16] = _s90o9::P64;
           P64[Sp - 8] = _s90oi::P64;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c90Ek() //  [R1]
         { info_tbl: [(c90Ek,
                       label: block_c90Ek_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Ek: // global
           I64[Sp - 8] = block_c90Er_info;
           R2 = 4;
           _s90ok::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s90ok::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90Er() //  [R1]
         { info_tbl: [(c90Er,
                       label: block_c90Er_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Er: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c90HI() args: 0, res: 0, upd: 0;
     }
 },
 _c90HI() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90HI: // global
           _s90q6::P64 = P64[Sp];
           I64[Sp] = block_c90HL_info;
           R1 = _s90q6::P64;
           if (R1 & 7 != 0) goto u90IL; else goto c90HN;
       u90IL: // global
           call _c90HL(R1) args: 0, res: 0, upd: 0;
       c90HN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90HL() //  [R1]
         { info_tbl: [(c90HL,
                       label: block_c90HL_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90HL: // global
           if (R1 & 7 == 1) goto c90HT; else goto c90HY;
       c90HT: // global
           I64[Sp + 8] = block_c90EB_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           Sp = Sp + 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c90HY: // global
           I64[Sp - 8] = block_c90HW_info;
           _s90qb::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s90qb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u90IM; else goto c90HZ;
       u90IM: // global
           call _c90HW(R1) args: 0, res: 0, upd: 0;
       c90HZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90EB() //  [R1]
         { info_tbl: [(c90EB,
                       label: block_c90EB_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90EB: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto c90G0; else goto c90FZ;
       c90G0: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c90FZ: // global
           _s90ok::I64 = I64[Sp + 16];
           _s90os::I64 = I64[Sp + 8];
           _s90oy::I64 = _s90ok::I64 + 1;
           (_s90oD::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(_s90oy::I64);
           if (_s90oD::I64 == 0) goto c90HF; else goto c90HE;
       c90HF: // global
           Hp = Hp - 88;
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c90HE: // global
           I64[Hp - 80] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 72] = R1;
           I64[Hp - 64] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 56] = Hp - 79;
           P64[Hp - 48] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 40] = _s90os::I64;
           I64[Hp - 32] = _s90ok::I64;
           I64[Hp - 24] = 0;
           I64[Hp - 16] = _s90ok::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s90oy::I64;
           P64[Sp] = Hp - 7;
           I64[Sp + 8] = _s90oD::I64;
           P64[Sp + 16] = Hp - 63;
           call _c90EV() args: 0, res: 0, upd: 0;
     }
 },
 _c90EV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90EV: // global
           I64[Sp - 8] = block_c90EY_info;
           R1 = P64[Sp + 32];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u90Iw; else goto c90EZ;
       u90Iw: // global
           call _c90EY(R1) args: 0, res: 0, upd: 0;
       c90EZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90EY() //  [R1]
         { info_tbl: [(c90EY,
                       label: block_c90EY_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90EY: // global
           I64[Sp - 16] = block_c90F3_info;
           _s90oQ::P64 = P64[R1 + 7];
           _s90oR::P64 = P64[R1 + 15];
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           P64[Sp - 8] = _s90oR::P64;
           P64[Sp] = _s90oQ::P64;
           Sp = Sp - 16;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90F3() //  [R1]
         { info_tbl: [(c90F3,
                       label: block_c90F3_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90F3: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c90G9; else goto c90G8;
       c90G9: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c90G8: // global
           I64[Hp - 32] = sat_s90q2_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 32];
           P64[Sp - 8] = Hp - 32;
           P64[Sp] = P64[Sp + 40];
           Sp = Sp - 8;
           call _c90GU() args: 0, res: 0, upd: 0;
     }
 },
 _c90GU() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90GU: // global
           _s90pA::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c90GW_info;
           R3 = P64[Sp];
           R2 = _s90pA::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90GW() //  [R1]
         { info_tbl: [(c90GW,
                       label: block_c90GW_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90GW: // global
           I64[Sp] = block_c90GY_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u90IE; else goto c90GZ;
       u90IE: // global
           call _c90GY(R1) args: 0, res: 0, upd: 0;
       c90GZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90GY() //  [R1]
         { info_tbl: [(c90GY,
                       label: block_c90GY_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90GY: // global
           I64[Sp - 16] = block_c90H3_info;
           _s90pH::P64 = P64[R1 + 7];
           _s90pJ::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s90pJ::P64;
           P64[Sp] = _s90pH::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u90IF; else goto c90H7;
       u90IF: // global
           call _c90H3(R1) args: 0, res: 0, upd: 0;
       c90H7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90H3() //  [R1]
         { info_tbl: [(c90H3,
                       label: block_c90H3_info
                       rep:StackRep [False, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90H3: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c90HC; else goto c90Hh;
       c90HC: // global
           I64[Sp + 32] = block_c90GI_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u90IH; else goto c90GK;
       u90IH: // global
           call _c90GI(R1) args: 0, res: 0, upd: 0;
       c90GK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c90Hh: // global
           I64[Sp] = block_c90Hf_info;
           _s90pK::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s90pK::P64;
           if (R1 & 7 != 0) goto u90IG; else goto c90Hi;
       u90IG: // global
           call _c90Hf(R1) args: 0, res: 0, upd: 0;
       c90Hi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90GI() //  [R1]
         { info_tbl: [(c90GI,
                       label: block_c90GI_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90GI: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto c90GQ; else goto c90GP;
       c90GQ: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c90GP: // global
           _s90pn::I64 = I64[R1 + 23];
           _s90pr::I64 = I64[R1 + 39];
           _s90ps::I64 = I64[R1 + 47];
           call MO_Touch(P64[R1 + 7]);
           I64[Hp - 64] = GHC.Types.I#_con_info;
           I64[Hp - 56] = _s90ps::I64 - _s90pr::I64;
           I64[Hp - 48] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 40] = _s90pn::I64;
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = Hp - 47;
           P64[Hp - 16] = Hp - 63;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           P64[Sp] = Hp - 6;
           call _s90oY() args: 0, res: 0, upd: 0;
     }
 },
 _c90Hf() //  [R1]
         { info_tbl: [(c90Hf,
                       label: block_c90Hf_info
                       rep:StackRep [False, False, False, False, False, True, False,
                                     False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Hf: // global
           if (R1 & 7 == 2) goto c90HB; else goto c90Hr;
       c90HB: // global
           P64[Sp + 32] = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call _s90oY() args: 0, res: 0, upd: 0;
       c90Hr: // global
           _s90pK::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c90Hm_info;
           R3 = P64[Sp + 8];
           R2 = _s90pK::P64;
           R1 = P64[Sp + 24];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _s90oY() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s90oY: // global
           _s90p0::P64 = P64[Sp];
           I64[Sp] = block_c90Fc_info;
           R1 = _s90p0::P64;
           if (R1 & 7 != 0) goto u90IO; else goto c90Fd;
       u90IO: // global
           call _c90Fc(R1) args: 0, res: 0, upd: 0;
       c90Fd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90Fc() //  [R1]
         { info_tbl: [(c90Fc,
                       label: block_c90Fc_info
                       rep:StackRep [False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Fc: // global
           if (R1 & 7 == 1) goto c90Gd; else goto c90Gw;
       c90Gd: // global
           _s90oN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c90Fh_info;
           R1 = _s90oN::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u90Iy; else goto c90Fi;
       u90Iy: // global
           call _c90Fh(R1) args: 0, res: 0, upd: 0;
       c90Fi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c90Gw: // global
           _s90oJ::P64 = P64[R1 + 6];
           call MO_Touch(P64[Sp + 32]);
           R1 = _s90oJ::P64;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c90Fh() //  [R1]
         { info_tbl: [(c90Fh,
                       label: block_c90Fh_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Fh: // global
           _s90p4::I64 = I64[R1 + 7] << 1;
           if (_s90p4::I64 != 0) goto u90Iq; else goto c90Gp;
       u90Iq: // global
           I64[Sp] = _s90p4::I64;
           call _c90Fq() args: 0, res: 0, upd: 0;
       c90Gp: // global
           call "ccall" arg hints:  [PtrHint]  result hints:  [] free(I64[Sp + 8]);
           I64[Sp + 8] = 0;
           P64[Sp] = Foreign.C.String.newCStringLen2_closure+1;
           call _c90EV() args: 0, res: 0, upd: 0;
     }
 },
 _c90Fq() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Fq: // global
           Hp = Hp + 16;
           _s90p4::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c90Gj; else goto c90Gi;
       c90Gj: // global
           HpAlloc = 16;
           I64[Sp] = block_c90Fp_info;
           R1 = _s90p4::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c90Gi: // global
           (_s90p9::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] realloc(I64[Sp + 8], _s90p4::I64);
           if (_s90p9::I64 == 0) goto c90Gm; else goto c90Gl;
       c90Gm: // global
           Hp = Hp - 16;
           R1 = Foreign.Marshal.Alloc.realloc2_closure;
           Sp = Sp + 40;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c90Gl: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s90p4::I64;
           I64[Sp + 8] = _s90p9::I64;
           P64[Sp] = Hp - 7;
           call _c90EV() args: 0, res: 0, upd: 0;
     }
 },
 _c90Fp() //  [R1]
         { info_tbl: [(c90Fp,
                       label: block_c90Fp_info
                       rep:StackRep [True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Fp: // global
           I64[Sp] = R1;
           call _c90Fq() args: 0, res: 0, upd: 0;
     }
 },
 _c90Hm() //  [R1]
         { info_tbl: [(c90Hm,
                       label: block_c90Hm_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Hm: // global
           I64[Sp] = block_c90Ho_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u90IJ; else goto c90Ht;
       u90IJ: // global
           call _c90Ho(R1) args: 0, res: 0, upd: 0;
       c90Ht: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90Ho() //  [R1]
         { info_tbl: [(c90Ho,
                       label: block_c90Ho_info
                       rep:StackRep [False, False, False, True, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Ho: // global
           P64[Sp] = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 15];
           Sp = Sp - 8;
           call _c90GU() args: 0, res: 0, upd: 0;
     }
 },
 _c90HW() //  [R1]
         { info_tbl: [(c90HW,
                       label: block_c90HW_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90HW: // global
           _s90q7::I64 = I64[Sp + 16];
           _s90qb::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s90q7::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s90qb::P64;
           I64[Sp + 16] = _s90q7::I64 + 1;
           Sp = Sp + 8;
           call _c90HI() args: 0, res: 0, upd: 0;
     }
 },
 Foreign.C.String.newCStringLen1_entry() //  [R2]
         { info_tbl: [(c90IP,
                       label: Foreign.C.String.newCStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90IP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c90IQ; else goto c90IR;
       c90IQ: // global
           R2 = R2;
           R1 = Foreign.C.String.newCStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90IR: // global
           I64[Sp - 16] = block_c90E8_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90E8() //  [R1]
         { info_tbl: [(c90E8,
                       label: block_c90E8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90E8: // global
           I64[Sp] = block_c90Ea_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u90IW; else goto c90Eb;
       u90IW: // global
           call _c90Ea(R1) args: 0, res: 0, upd: 0;
       c90Eb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90Ea() //  [R1]
         { info_tbl: [(c90Ea,
                       label: block_c90Ea_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Ea: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c90IV; else goto c90IU;
       c90IV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c90IU: // global
           _s90oh::P64 = P64[R1 + 23];
           I64[Hp - 8] = sat_s90qg_info;
           P64[Hp] = P64[Sp + 8];
           R4 = Hp - 6;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = _s90oh::P64;
           Sp = Sp + 16;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.318440262 UTC

[section ""data" . Foreign.C.String.newCStringLen_closure" {
     Foreign.C.String.newCStringLen_closure:
         const Foreign.C.String.newCStringLen_info;
         const 0;
 },
 Foreign.C.String.newCStringLen_entry() //  [R2]
         { info_tbl: [(c90LN,
                       label: Foreign.C.String.newCStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90LN: // global
           R2 = R2;
           call Foreign.C.String.newCStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.321681665 UTC

[section ""data" . Foreign.C.String.newCString1_closure" {
     Foreign.C.String.newCString1_closure:
         const Foreign.C.String.newCString1_info;
         const 0;
 },
 Foreign.C.String.newCString1_entry() //  [R2]
         { info_tbl: [(c90M0,
                       label: Foreign.C.String.newCString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90M0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c90M1; else goto c90M2;
       c90M1: // global
           R2 = R2;
           R1 = Foreign.C.String.newCString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90M2: // global
           I64[Sp - 16] = block_c90LY_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90LY() //  [R1]
         { info_tbl: [(c90LY,
                       label: block_c90LY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90LY: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.newCString1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.326778258 UTC

[section ""data" . Foreign.C.String.newCString_closure" {
     Foreign.C.String.newCString_closure:
         const Foreign.C.String.newCString_info;
         const 0;
 },
 Foreign.C.String.newCString_entry() //  [R2]
         { info_tbl: [(c90Mh,
                       label: Foreign.C.String.newCString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Mh: // global
           R2 = R2;
           call Foreign.C.String.newCString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.334230546 UTC

[section ""data" . Foreign.C.String.peekCStringLen1_closure" {
     Foreign.C.String.peekCStringLen1_closure:
         const Foreign.C.String.peekCStringLen1_info;
         const 0;
 },
 sat_s90rD_entry() //  [R1]
         { info_tbl: [(c90OF,
                       label: sat_s90rD_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90OF: // global
           _s90rD::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c90OG; else goto c90OH;
       c90OH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c90OJ; else goto c90OI;
       c90OJ: // global
           HpAlloc = 40;
           goto c90OG;
       c90OG: // global
           R1 = _s90rD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c90OI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s90rD::P64;
           _s90rs::P64 = P64[_s90rD::P64 + 16];
           _s90rA::P64 = P64[_s90rD::P64 + 24];
           _s90rw::I64 = I64[_s90rD::P64 + 32];
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s90rw::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s90rs::P64;
           R3 = _s90rA::P64;
           R2 = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s90rU_entry() //  [R1]
         { info_tbl: [(c90OS,
                       label: sat_s90rU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90OS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c90OT; else goto c90OU;
       c90OT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c90OU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = GHC.Types.[]_closure+1;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 $wgo_s90qU_entry() //  [R1, R2]
         { info_tbl: [(c90OV,
                       label: $wgo_s90qU_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90OV: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c90OW; else goto c90OX;
       c90OW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90OX: // global
           I64[Sp - 32] = block_c90Nk_info;
           _s90qU::P64 = R1;
           _s90qT::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 24] = _s90qT::P64;
           P64[Sp - 16] = _s90qU::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto u90Qx; else goto c90Nl;
       u90Qx: // global
           call _c90Nk(R1) args: 0, res: 0, upd: 0;
       c90Nl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90Nk() //  [R1]
         { info_tbl: [(c90Nk,
                       label: block_c90Nk_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Nk: // global
           _s90qT::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c90Np_info;
           R3 = _s90qT::P64;
           R2 = P64[Sp + 24];
           _s90qZ::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp + 24] = _s90qZ::P64;
           Sp = Sp + 8;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90Np() //  [R1]
         { info_tbl: [(c90Np,
                       label: block_c90Np_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Np: // global
           I64[Sp] = block_c90Nr_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u90Qp; else goto c90Ns;
       u90Qp: // global
           call _c90Nr(R1) args: 0, res: 0, upd: 0;
       c90Ns: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90Nr() //  [R1]
         { info_tbl: [(c90Nr,
                       label: block_c90Nr_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Nr: // global
           I64[Sp - 16] = block_c90Nw_info;
           _s90r7::P64 = P64[R1 + 7];
           _s90r9::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _s90r9::P64;
           P64[Sp] = _s90r7::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u90Qq; else goto c90Nx;
       u90Qq: // global
           call _c90Nw(R1) args: 0, res: 0, upd: 0;
       c90Nx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90Nw() //  [R1]
         { info_tbl: [(c90Nw,
                       label: block_c90Nw_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Nw: // global
           if (I64[R1 + 39] == I64[R1 + 47]) goto c90PS; else goto c90Pl;
       c90PS: // global
           I64[Sp + 32] = block_c90O4_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto u90Qs; else goto c90O5;
       u90Qs: // global
           call _c90O4(R1) args: 0, res: 0, upd: 0;
       c90O5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c90Pl: // global
           I64[Sp] = block_c90P2_info;
           _s90ra::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s90ra::P64;
           if (R1 & 7 != 0) goto u90Qr; else goto c90Pm;
       u90Qr: // global
           call _c90P2(R1) args: 0, res: 0, upd: 0;
       c90Pm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90O4() //  [R1]
         { info_tbl: [(c90O4,
                       label: block_c90O4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90O4: // global
           _s90si::P64 = P64[R1 + 7];
           _s90sn::I64 = I64[R1 + 47] - I64[R1 + 39];
           if (%MO_S_Gt_W64(_s90sn::I64, 0)) goto c90Qa; else goto c90Qb;
       c90Qa: // global
           P64[Sp - 24] = _s90si::P64;
           I64[Sp - 16] = _s90sn::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           I64[Sp] = I64[R1 + 23];
           Sp = Sp - 32;
           call _c90Om() args: 0, res: 0, upd: 0;
       c90Qb: // global
           call MO_Touch(_s90si::P64);
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c90Om() //  []
         { info_tbl: [(c90Om,
                       label: block_c90Om_info
                       rep:StackRep [False, True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Om: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c90Q5; else goto c90Q4;
       c90Q5: // global
           HpAlloc = 40;
           I64[Sp] = block_c90Om_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c90Q4: // global
           _s90sA::P64 = P64[Sp + 24];
           _s90sC::I64 = I64[Sp + 16];
           if (_s90sC::I64 != 0) goto c90Q7; else goto c90Q8;
       c90Q7: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W32_W64(I32[I64[Sp + 32] + (_s90sC::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s90sA::P64;
           I64[Sp + 16] = _s90sC::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           call _c90Om() args: 0, res: 0, upd: 0;
       c90Q8: // global
           Hp = Hp - 40;
           P64[Sp + 24] = _s90sA::P64;
           Sp = Sp + 8;
           call _c90PV() args: 0, res: 0, upd: 0;
     }
 },
 _c90PV() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90PV: // global
           Hp = Hp + 40;
           _s90sq::P64 = P64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c90Q2; else goto c90Q1;
       c90Q2: // global
           HpAlloc = 40;
           I64[Sp - 8] = block_c90PU_info;
           R1 = _s90sq::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c90Q1: // global
           _s90su::I64 = %MO_UU_Conv_W32_W64(I32[I64[Sp + 24]]);
           call MO_Touch(P64[Sp]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s90su::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s90sq::P64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c90PU() //  [R1]
         { info_tbl: [(c90PU,
                       label: block_c90PU_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90PU: // global
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c90PV() args: 0, res: 0, upd: 0;
     }
 },
 _c90P2() //  [R1]
         { info_tbl: [(c90P2,
                       label: block_c90P2_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90P2: // global
           _s90r9::P64 = P64[Sp + 8];
           if (R1 & 7 == 2) goto c90PM; else goto c90PA;
       c90PM: // global
           I64[Sp + 8] = block_c90PK_info;
           R1 = _s90r9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u90Qy; else goto c90PN;
       u90Qy: // global
           call _c90PK(R1) args: 0, res: 0, upd: 0;
       c90PN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c90PA: // global
           _s90ra::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c90Pq_info;
           R3 = _s90r9::P64;
           R2 = _s90ra::P64;
           R1 = P64[Sp + 32];
           Sp = Sp + 16;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90PK() //  [R1]
         { info_tbl: [(c90PK,
                       label: block_c90PK_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90PK: // global
           P64[Sp + 24] = P64[Sp + 8];
           I64[Sp + 8] = I64[R1 + 23];
           P64[Sp - 16] = P64[R1 + 7];
           I64[Sp - 8] = I64[R1 + 39];
           I64[Sp] = I64[R1 + 47];
           Sp = Sp - 16;
           call _s90ri() args: 0, res: 0, upd: 0;
     }
 },
 _c90Pq() //  [R1]
         { info_tbl: [(c90Pq,
                       label: block_c90Pq_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Pq: // global
           I64[Sp] = block_c90Ps_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u90Qz; else goto c90Pt;
       u90Qz: // global
           call _c90Ps(R1) args: 0, res: 0, upd: 0;
       c90Pt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90Ps() //  [R1]
         { info_tbl: [(c90Ps,
                       label: block_c90Ps_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Ps: // global
           I64[Sp] = block_c90Px_info;
           _s90s0::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp + 16] = _s90s0::P64;
           if (R1 & 7 != 0) goto u90QA; else goto c90PD;
       u90QA: // global
           call _c90Px(R1) args: 0, res: 0, upd: 0;
       c90PD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90Px() //  [R1]
         { info_tbl: [(c90Px,
                       label: block_c90Px_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Px: // global
           P64[Sp - 24] = P64[R1 + 7];
           I64[Sp - 16] = I64[R1 + 39];
           I64[Sp - 8] = I64[R1 + 47];
           I64[Sp] = I64[R1 + 23];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp - 24;
           call _s90ri() args: 0, res: 0, upd: 0;
     }
 },
 _s90ri() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       s90ri: // global
           _s90rp::I64 = I64[Sp + 16] - I64[Sp + 8];
           if (%MO_S_Gt_W64(_s90rp::I64, 0)) goto c90Pf; else goto c90Pg;
       c90Pf: // global
           P64[Sp + 8] = GHC.Types.[]_closure+1;
           I64[Sp + 16] = _s90rp::I64 - 1;
           Sp = Sp - 8;
           call _c90NW() args: 0, res: 0, upd: 0;
       c90Pg: // global
           _s90qU::P64 = P64[Sp + 32];
           _s90rk::P64 = P64[Sp + 40];
           call MO_Touch(P64[Sp]);
           I64[Sp + 40] = block_c90OM_info;
           R2 = _s90rk::P64;
           R1 = _s90qU::P64;
           Sp = Sp + 40;
           call $wgo_s90qU_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90NW() //  []
         { info_tbl: [(c90NW,
                       label: block_c90NW_info
                       rep:StackRep [False, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90NW: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c90Pa; else goto c90P9;
       c90Pa: // global
           HpAlloc = 40;
           I64[Sp] = block_c90NW_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c90P9: // global
           _s90rl::I64 = I64[Sp + 32];
           _s90rG::P64 = P64[Sp + 16];
           _s90rI::I64 = I64[Sp + 24];
           if (_s90rI::I64 != 0) goto c90Pc; else goto c90Pd;
       c90Pc: // global
           _s90rL::I64 = %MO_UU_Conv_W32_W64(I32[_s90rl::I64 + (_s90rI::I64 << 2)]);
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = _s90rL::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s90rG::P64;
           I64[Sp + 24] = _s90rI::I64 - 1;
           P64[Sp + 16] = Hp - 14;
           call _c90NW() args: 0, res: 0, upd: 0;
       c90Pd: // global
           Hp = Hp - 40;
           _s90qU::P64 = P64[Sp + 40];
           _s90rk::P64 = P64[Sp + 48];
           _s90rw::I64 = %MO_UU_Conv_W32_W64(I32[_s90rl::I64]);
           call MO_Touch(P64[Sp + 8]);
           I64[Sp + 32] = block_c90Ox_info;
           R2 = _s90rk::P64;
           R1 = _s90qU::P64;
           I64[Sp + 40] = _s90rw::I64;
           P64[Sp + 48] = _s90rG::P64;
           Sp = Sp + 32;
           call $wgo_s90qU_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90Ox() //  [R1]
         { info_tbl: [(c90Ox,
                       label: block_c90Ox_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Ox: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c90P7; else goto c90P6;
       c90P7: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c90P6: // global
           I64[Hp - 32] = sat_s90rD_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c90OM() //  [R1]
         { info_tbl: [(c90OM,
                       label: block_c90OM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90OM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c90Pj; else goto c90Pi;
       c90Pj: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c90Pi: // global
           I64[Hp - 16] = sat_s90rU_info;
           P64[Hp] = R1;
           R1 = Hp - 16;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s90sP_entry() //  [R1, R2]
         { info_tbl: [(c90QF,
                       label: sat_s90sP_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90QF: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c90QG; else goto c90QH;
       c90QG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90QH: // global
           I64[Sp - 24] = block_c90MJ_info;
           _s90qx::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp - 16] = _s90qx::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u90R1; else goto c90MK;
       u90R1: // global
           call _c90MJ(R1) args: 0, res: 0, upd: 0;
       c90MK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90MJ() //  [R1]
         { info_tbl: [(c90MJ,
                       label: block_c90MJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90MJ: // global
           I64[Sp - 8] = block_c90MO_info;
           _s90qB::I64 = I64[R1 + 7];
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp] = _s90qB::I64;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90MO() //  [R1]
         { info_tbl: [(c90MO,
                       label: block_c90MO_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90MO: // global
           I64[Sp] = block_c90MQ_info;
           _s90qE::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s90qE::P64;
           if (R1 & 7 != 0) goto u90R0; else goto c90MR;
       u90R0: // global
           call _c90MQ(R1) args: 0, res: 0, upd: 0;
       c90MR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90MQ() //  [R1]
         { info_tbl: [(c90MQ,
                       label: block_c90MQ_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90MQ: // global
           _s90qG::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_s90qG::I64, 1)) goto c90QY; else goto c90QZ;
       c90QY: // global
           _s90qI::I64 = _s90qG::I64;
           goto s90qH;
       c90QZ: // global
           _s90qI::I64 = 1;
           goto s90qH;
       s90qH: // global
           _s90qJ::I64 = _s90qI::I64 << 2;
           if (%MO_S_Ge_W64(_s90qJ::I64, 0)) goto c90QP; else goto c90QU;
       c90QP: // global
           I64[Sp - 24] = block_c90N6_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = _s90qI::I64;
           I64[Sp - 8] = _s90qJ::I64;
           I64[Sp] = _s90qG::I64;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c90QU: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c90N6() //  [R1]
         { info_tbl: [(c90N6,
                       label: block_c90N6_info
                       rep:StackRep [True, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90N6: // global
           I64[Sp] = block_c90N8_info;
           _s90qN::P64 = R1;
           R1 = I64[Sp + 16];
           P64[Sp + 16] = _s90qN::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90N8() //  [R1]
         { info_tbl: [(c90N8,
                       label: block_c90N8_info
                       rep:StackRep [True, False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90N8: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto c90QT; else goto c90QS;
       c90QT: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c90QS: // global
           I64[Hp - 168] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 160] = R1;
           P64[Hp - 152] = P64[Sp + 16];
           I64[Hp - 144] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 136] = Hp - 166;
           P64[Hp - 128] = GHC.IO.Buffer.WriteBuffer_closure+2;
           P64[Hp - 120] = R1 + 16;
           I64[Hp - 112] = I64[Sp + 8];
           I64[Hp - 104] = 0;
           I64[Hp - 96] = 0;
           I64[Hp - 88] = $wgo_s90qU_info;
           P64[Hp - 80] = P64[Sp + 48];
           P64[Hp - 72] = Hp - 143;
           I64[Hp - 64] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 56] = P64[Sp + 40];
           I64[Hp - 48] = GHC.IO.Buffer.Buffer_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = GHC.IO.Buffer.ReadBuffer_closure+1;
           I64[Hp - 24] = I64[Sp + 32];
           _s90qG::I64 = I64[Sp + 24];
           I64[Hp - 16] = _s90qG::I64;
           I64[Hp - 8] = 0;
           I64[Hp] = _s90qG::I64;
           R2 = Hp - 47;
           R1 = Hp - 86;
           Sp = Sp + 56;
           call $wgo_s90qU_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.C.String.peekCStringLen1_entry() //  [R2]
         { info_tbl: [(c90R2,
                       label: Foreign.C.String.peekCStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90R2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c90R3; else goto c90R4;
       c90R3: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90R4: // global
           I64[Sp - 16] = block_c90Ms_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90Ms() //  [R1]
         { info_tbl: [(c90Ms,
                       label: block_c90Ms_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Ms: // global
           I64[Sp] = block_c90Mu_info;
           R1 = R1;
           if (R1 & 7 != 0) goto u90Ra; else goto c90Mv;
       u90Ra: // global
           call _c90Mu(R1) args: 0, res: 0, upd: 0;
       c90Mv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90Mu() //  [R1]
         { info_tbl: [(c90Mu,
                       label: block_c90Mu_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Mu: // global
           I64[Sp] = block_c90Mz_info;
           _s90qt::P64 = P64[R1 + 15];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s90qt::P64;
           if (R1 & 7 != 0) goto u90Rb; else goto c90MA;
       u90Rb: // global
           call _c90Mz(R1) args: 0, res: 0, upd: 0;
       c90MA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90Mz() //  [R1]
         { info_tbl: [(c90Mz,
                       label: block_c90Mz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Mz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c90R9; else goto c90R8;
       c90R9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c90R8: // global
           _s90qw::P64 = P64[R1 + 7];
           _s90qx::P64 = P64[R1 + 15];
           I64[Hp - 16] = sat_s90sP_info;
           P64[Hp - 8] = _s90qw::P64;
           P64[Hp] = _s90qx::P64;
           R4 = Hp - 14;
           R3 = GHC.IO.Encoding.Types.close_closure+1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.IO.bracket1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.390069316 UTC

[section ""data" . Foreign.C.String.peekCStringLen_closure" {
     Foreign.C.String.peekCStringLen_closure:
         const Foreign.C.String.peekCStringLen_info;
         const 0;
 },
 Foreign.C.String.peekCStringLen_entry() //  [R2]
         { info_tbl: [(c90Uz,
                       label: Foreign.C.String.peekCStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Uz: // global
           R2 = R2;
           call Foreign.C.String.peekCStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.393631773 UTC

[section ""data" . Foreign.C.String.peekCString1_closure" {
     Foreign.C.String.peekCString1_closure:
         const Foreign.C.String.peekCString1_info;
         const 0;
 },
 Foreign.C.String.peekCString1_entry() //  [R2]
         { info_tbl: [(c90UM,
                       label: Foreign.C.String.peekCString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90UM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c90UN; else goto c90UO;
       c90UN: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90UO: // global
           I64[Sp - 16] = block_c90UK_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90UK() //  [R1]
         { info_tbl: [(c90UK,
                       label: block_c90UK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90UK: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.peekCString1_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.398592757 UTC

[section ""data" . Foreign.C.String.peekCString_closure" {
     Foreign.C.String.peekCString_closure:
         const Foreign.C.String.peekCString_info;
         const 0;
 },
 Foreign.C.String.peekCString_entry() //  [R2]
         { info_tbl: [(c90V3,
                       label: Foreign.C.String.peekCString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90V3: // global
           R2 = R2;
           call Foreign.C.String.peekCString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.401856756 UTC

[section ""data" . Foreign.C.String.castCSCharToChar_closure" {
     Foreign.C.String.castCSCharToChar_closure:
         const Foreign.C.String.castCSCharToChar_info;
 },
 Foreign.C.String.castCSCharToChar_entry() //  [R2]
         { info_tbl: [(c90Vh,
                       label: Foreign.C.String.castCSCharToChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Vh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c90Vx; else goto c90Vy;
       c90Vx: // global
           R2 = R2;
           R1 = Foreign.C.String.castCSCharToChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90Vy: // global
           I64[Sp - 8] = block_c90Ve_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u90VC; else goto c90Vf;
       u90VC: // global
           call _c90Ve(R1) args: 0, res: 0, upd: 0;
       c90Vf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90Ve() //  [R1]
         { info_tbl: [(c90Ve,
                       label: block_c90Ve_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Ve: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c90VB; else goto c90VA;
       c90VB: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c90VA: // global
           _s90t1::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s90t1::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.407531032 UTC

[section ""data" . Foreign.C.String.castCUCharToChar_closure" {
     Foreign.C.String.castCUCharToChar_closure:
         const Foreign.C.String.castCUCharToChar_info;
 },
 Foreign.C.String.castCUCharToChar_entry() //  [R2]
         { info_tbl: [(c90VX,
                       label: Foreign.C.String.castCUCharToChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90VX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c90W7; else goto c90W8;
       c90W7: // global
           R2 = R2;
           R1 = Foreign.C.String.castCUCharToChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90W8: // global
           I64[Sp - 8] = block_c90VU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u90Wc; else goto c90VV;
       u90Wc: // global
           call _c90VU(R1) args: 0, res: 0, upd: 0;
       c90VV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90VU() //  [R1]
         { info_tbl: [(c90VU,
                       label: block_c90VU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90VU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c90Wb; else goto c90Wa;
       c90Wb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c90Wa: // global
           _s90t6::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s90t6::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.413291404 UTC

[section ""data" . Foreign.C.String.castCCharToChar_closure" {
     Foreign.C.String.castCCharToChar_closure:
         const Foreign.C.String.castCCharToChar_info;
 },
 Foreign.C.String.castCCharToChar_entry() //  [R2]
         { info_tbl: [(c90Ww,
                       label: Foreign.C.String.castCCharToChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Ww: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c90WM; else goto c90WN;
       c90WM: // global
           R2 = R2;
           R1 = Foreign.C.String.castCCharToChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90WN: // global
           I64[Sp - 8] = block_c90Wt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u90WR; else goto c90Wu;
       u90WR: // global
           call _c90Wt(R1) args: 0, res: 0, upd: 0;
       c90Wu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90Wt() //  [R1]
         { info_tbl: [(c90Wt,
                       label: block_c90Wt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Wt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c90WQ; else goto c90WP;
       c90WQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c90WP: // global
           _s90td::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s90td::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.419346294 UTC

[section ""data" . Foreign.C.String.$wpeekCAString_closure" {
     Foreign.C.String.$wpeekCAString_closure:
         const Foreign.C.String.$wpeekCAString_info;
 },
 Foreign.C.String.$wpeekCAString_entry() //  [R2]
         { info_tbl: [(c90XL,
                       label: Foreign.C.String.$wpeekCAString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90XL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c90XM; else goto c90XN;
       c90XM: // global
           R2 = R2;
           R1 = Foreign.C.String.$wpeekCAString_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90XN: // global
           _s90te::I64 = R2;
           _s90tH::I64 = 0;
           goto c90Ye;
       c90Ye: // global
           if (I8[_s90te::I64 + _s90tH::I64] == 0 :: W8) goto c90Yk; else goto c90Yj;
       c90Yk: // global
           if (%MO_S_Gt_W64(_s90tH::I64, 0)) goto c90Yb; else goto c90Yc;
       c90Yb: // global
           I64[Sp - 24] = _s90te::I64;
           P64[Sp - 16] = GHC.Types.[]_closure+1;
           I64[Sp - 8] = _s90tH::I64 - 1;
           Sp = Sp - 32;
           call _c90Xm() args: 0, res: 0, upd: 0;
       c90Yc: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c90Yj: // global
           _s90tH::I64 = _s90tH::I64 + 1;
           goto c90Ye;
     }
 },
 _c90Xm() //  []
         { info_tbl: [(c90Xm,
                       label: block_c90Xm_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Xm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c90XR; else goto c90XQ;
       c90XR: // global
           HpAlloc = 40;
           I64[Sp] = block_c90Xm_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c90XQ: // global
           _s90tl::P64 = P64[Sp + 16];
           _s90tm::I64 = I64[Sp + 24];
           _s90tq::I64 = %MO_SS_Conv_W8_W64(I8[I64[Sp + 8] + _s90tm::I64]);
           if (%MO_S_Gt_W64(_s90tm::I64, 0)) goto c90XT; else goto c90Y9;
       c90XT: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s90tq::I64));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s90tl::P64;
           P64[Sp + 16] = Hp - 14;
           I64[Sp + 24] = _s90tm::I64 - 1;
           call _c90Xm() args: 0, res: 0, upd: 0;
       c90Y9: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s90tq::I64));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s90tl::P64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.426202513 UTC

[section ""data" . Foreign.C.String.peekCAString1_closure" {
     Foreign.C.String.peekCAString1_closure:
         const Foreign.C.String.peekCAString1_info;
 },
 Foreign.C.String.peekCAString1_entry() //  [R2]
         { info_tbl: [(c90Z0,
                       label: Foreign.C.String.peekCAString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Z0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c90Z1; else goto c90Z2;
       c90Z1: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCAString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c90Z2: // global
           I64[Sp - 8] = block_c90YX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u90Z6; else goto c90YY;
       u90Z6: // global
           call _c90YX(R1) args: 0, res: 0, upd: 0;
       c90YY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90YX() //  [R1]
         { info_tbl: [(c90YX,
                       label: block_c90YX_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90YX: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call Foreign.C.String.$wpeekCAString_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.431190409 UTC

[section ""data" . Foreign.C.String.peekCAString_closure" {
     Foreign.C.String.peekCAString_closure:
         const Foreign.C.String.peekCAString_info;
 },
 Foreign.C.String.peekCAString_entry() //  [R2]
         { info_tbl: [(c90Zl,
                       label: Foreign.C.String.peekCAString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90Zl: // global
           R2 = R2;
           call Foreign.C.String.peekCAString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.435120288 UTC

[section ""data" . Foreign.C.String.$wpeekCAStringLen_closure" {
     Foreign.C.String.$wpeekCAStringLen_closure:
         const Foreign.C.String.$wpeekCAStringLen_info;
 },
 Foreign.C.String.$wpeekCAStringLen_entry() //  [R2, R3]
         { info_tbl: [(c9108,
                       label: Foreign.C.String.$wpeekCAStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9108: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9109; else goto c910a;
       c9109: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.$wpeekCAStringLen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c910a: // global
           if (%MO_S_Gt_W64(R3, 0)) goto c9106; else goto c9107;
       c9106: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = GHC.Types.[]_closure+1;
           I64[Sp - 8] = R3 - 1;
           Sp = Sp - 24;
           call _c90ZE() args: 0, res: 0, upd: 0;
       c9107: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c90ZE() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90ZE: // global
           I64[Sp - 8] = block_c90ZH_info;
           R1 = P64[Sp];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u910z; else goto c90ZI;
       u910z: // global
           call _c90ZH(R1) args: 0, res: 0, upd: 0;
       c90ZI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c90ZH() //  [R1]
         { info_tbl: [(c90ZH,
                       label: block_c90ZH_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c90ZH: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c910e; else goto c910d;
       c910e: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c910d: // global
           _s90tX::P64 = P64[Sp + 16];
           _s90tY::I64 = I64[Sp + 24];
           _s90u4::I64 = %MO_SS_Conv_W8_W64(I8[I64[R1 + 7] + _s90tY::I64]);
           if (_s90tY::I64 == 0) goto c910w; else goto c910g;
       c910w: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s90u4::I64));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s90tX::P64;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c910g: // global
           I64[Hp - 32] = GHC.Types.C#_con_info;
           I64[Hp - 24] = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(_s90u4::I64));
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s90tX::P64;
           P64[Sp + 16] = Hp - 14;
           I64[Sp + 24] = _s90tY::I64 - 1;
           Sp = Sp + 8;
           call _c90ZE() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.442340307 UTC

[section ""data" . Foreign.C.String.peekCAStringLen1_closure" {
     Foreign.C.String.peekCAStringLen1_closure:
         const Foreign.C.String.peekCAStringLen1_info;
 },
 Foreign.C.String.peekCAStringLen1_entry() //  [R2]
         { info_tbl: [(c911e,
                       label: Foreign.C.String.peekCAStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c911e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c911i; else goto c911j;
       c911i: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCAStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c911j: // global
           I64[Sp - 8] = block_c911b_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u911r; else goto c911c;
       u911r: // global
           call _c911b(R1) args: 0, res: 0, upd: 0;
       c911c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c911b() //  [R1]
         { info_tbl: [(c911b,
                       label: block_c911b_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c911b: // global
           I64[Sp - 8] = block_c911h_info;
           _s90un::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s90un::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u911q; else goto c911l;
       u911q: // global
           call _c911h(R1) args: 0, res: 0, upd: 0;
       c911l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c911h() //  [R1]
         { info_tbl: [(c911h,
                       label: block_c911h_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c911h: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.C.String.$wpeekCAStringLen_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.450961561 UTC

[section ""data" . Foreign.C.String.peekCAStringLen_closure" {
     Foreign.C.String.peekCAStringLen_closure:
         const Foreign.C.String.peekCAStringLen_info;
 },
 Foreign.C.String.peekCAStringLen_entry() //  [R2]
         { info_tbl: [(c911L,
                       label: Foreign.C.String.peekCAStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c911L: // global
           R2 = R2;
           call Foreign.C.String.peekCAStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.454379027 UTC

[section ""data" . Foreign.C.String.castCWcharToChar_closure" {
     Foreign.C.String.castCWcharToChar_closure:
         const Foreign.C.String.castCWcharToChar_info;
         const 0;
 },
 Foreign.C.String.castCWcharToChar_entry() //  [R2]
         { info_tbl: [(c911Z,
                       label: Foreign.C.String.castCWcharToChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c911Z: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9120; else goto c9121;
       c9120: // global
           R2 = R2;
           R1 = Foreign.C.String.castCWcharToChar_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9121: // global
           I64[Sp - 8] = block_c911W_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u912l; else goto c911X;
       u912l: // global
           call _c911W(R1) args: 0, res: 0, upd: 0;
       c911X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c911W() //  [R1]
         { info_tbl: [(c911W,
                       label: block_c911W_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c911W: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9126; else goto c9125;
       c9126: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9125: // global
           _s90ut::I64 = I64[R1 + 7];
           if (_s90ut::I64 > 1114111) goto c912d; else goto c912k;
       c912d: // global
           Hp = Hp - 16;
           R2 = _s90ut::I64;
           Sp = Sp + 8;
           call GHC.Char.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       c912k: // global
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s90ut::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.460101317 UTC

[section ""data" . Foreign.C.String.peekCWString2_closure" {
     Foreign.C.String.peekCWString2_closure:
         const Foreign.C.String.peekCWString2_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.C.String.peekCWString2_entry() //  [R1]
         { info_tbl: [(c912E,
                       label: Foreign.C.String.peekCWString2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c912E: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c912F; else goto c912G;
       c912F: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c912G: // global
           (_c912B::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c912B::I64 == 0) goto c912D; else goto c912C;
       c912D: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c912C: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c912B::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = Foreign.C.String.castCWcharToChar_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.464872117 UTC

[section ""data" . Foreign.C.String.$wpeekCWStringLen_closure" {
     Foreign.C.String.$wpeekCWStringLen_closure:
         const Foreign.C.String.$wpeekCWStringLen_info;
         const 0;
 },
 sat_s90uL_entry() //  [R1]
         { info_tbl: [(c913u,
                       label: sat_s90uL_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c913u: // global
           _s90uL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c913v; else goto c913w;
       c913w: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c913y; else goto c913x;
       c913y: // global
           HpAlloc = 40;
           goto c913v;
       c913v: // global
           R1 = _s90uL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c913x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s90uL::P64;
           _s90uC::P64 = P64[_s90uL::P64 + 16];
           _s90uI::I64 = I64[_s90uL::P64 + 24];
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = _s90uI::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s90uC::P64;
           R3 = Hp - 14;
           R2 = Foreign.C.String.castCWcharToChar_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.C.String.$wpeekCWStringLen_entry() //  [R2, R3]
         { info_tbl: [(c913C,
                       label: Foreign.C.String.$wpeekCWStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c913C: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c913D; else goto c913E;
       c913D: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.$wpeekCWStringLen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c913E: // global
           if (%MO_S_Gt_W64(R3, 0)) goto c913A; else goto c913B;
       c913A: // global
           P64[Sp - 24] = R2;
           I64[Sp - 16] = R3 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call _c9134() args: 0, res: 0, upd: 0;
       c913B: // global
           R1 = Foreign.C.String.peekCWString2_closure;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c9134() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9134: // global
           _s90ux::P64 = P64[Sp];
           _s90uQ::I64 = I64[Sp + 8];
           if (_s90uQ::I64 != 0) goto c913L; else goto c913P;
       c913L: // global
           I64[Sp - 8] = block_c9139_info;
           R1 = _s90ux::P64;
           I64[Sp + 8] = _s90uQ::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u913T; else goto c913a;
       u913T: // global
           call _c9139(R1) args: 0, res: 0, upd: 0;
       c913a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       c913P: // global
           I64[Sp + 8] = block_c913j_info;
           R1 = _s90ux::P64;
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto u913U; else goto c913k;
       u913U: // global
           call _c913j(R1) args: 0, res: 0, upd: 0;
       c913k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9139() //  [R1]
         { info_tbl: [(c9139,
                       label: block_c9139_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9139: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c913O; else goto c913N;
       c913O: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c913N: // global
           _s90uQ::I64 = I64[Sp + 16];
           _s90uV::I64 = %MO_SS_Conv_W32_W64(I32[I64[R1 + 7] + (_s90uQ::I64 << 2)]);
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = _s90uV::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 16] = _s90uQ::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           Sp = Sp + 8;
           call _c9134() args: 0, res: 0, upd: 0;
     }
 },
 _c913j() //  [R1]
         { info_tbl: [(c913j,
                       label: block_c913j_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c913j: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto c913I; else goto c913H;
       c913I: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c913H: // global
           _s90uI::I64 = %MO_SS_Conv_W32_W64(I32[I64[R1 + 7]]);
           I64[Hp - 24] = sat_s90uL_info;
           P64[Hp - 8] = P64[Sp + 8];
           I64[Hp] = _s90uI::I64;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.476797132 UTC

[section ""data" . Foreign.C.String.peekCWStringLen1_closure" {
     Foreign.C.String.peekCWStringLen1_closure:
         const Foreign.C.String.peekCWStringLen1_info;
         const 0;
 },
 Foreign.C.String.peekCWStringLen1_entry() //  [R2]
         { info_tbl: [(c914J,
                       label: Foreign.C.String.peekCWStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c914J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c914N; else goto c914O;
       c914N: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCWStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c914O: // global
           I64[Sp - 8] = block_c914G_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u914W; else goto c914H;
       u914W: // global
           call _c914G(R1) args: 0, res: 0, upd: 0;
       c914H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c914G() //  [R1]
         { info_tbl: [(c914G,
                       label: block_c914G_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c914G: // global
           I64[Sp - 8] = block_c914M_info;
           _s90v3::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _s90v3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u914V; else goto c914Q;
       u914V: // global
           call _c914M(R1) args: 0, res: 0, upd: 0;
       c914Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c914M() //  [R1]
         { info_tbl: [(c914M,
                       label: block_c914M_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c914M: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.C.String.$wpeekCWStringLen_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.483647106 UTC

[section ""data" . Foreign.C.String.peekCWStringLen_closure" {
     Foreign.C.String.peekCWStringLen_closure:
         const Foreign.C.String.peekCWStringLen_info;
         const 0;
 },
 Foreign.C.String.peekCWStringLen_entry() //  [R2]
         { info_tbl: [(c915g,
                       label: Foreign.C.String.peekCWStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c915g: // global
           R2 = R2;
           call Foreign.C.String.peekCWStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.487247639 UTC

[section ""data" . Foreign.C.String.newCWString3_closure" {
     Foreign.C.String.newCWString3_closure:
         const GHC.Int.I32#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.489765255 UTC

[section ""data" . Foreign.C.String.$wpeekCWString_closure" {
     Foreign.C.String.$wpeekCWString_closure:
         const Foreign.C.String.$wpeekCWString_info;
         const 0;
 },
 sat_s90vl_entry() //  [R1]
         { info_tbl: [(c915X,
                       label: sat_s90vl_info
                       rep:HeapRep 1 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c915X: // global
           _s90vl::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto c915Y; else goto c915Z;
       c915Z: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c9161; else goto c9160;
       c9161: // global
           HpAlloc = 40;
           goto c915Y;
       c915Y: // global
           R1 = _s90vl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c9160: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s90vl::P64;
           _s90ve::P64 = P64[_s90vl::P64 + 16];
           _s90vi::I64 = I64[_s90vl::P64 + 24];
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = _s90vi::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s90ve::P64;
           R3 = Hp - 14;
           R2 = Foreign.C.String.castCWcharToChar_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.C.String.$wpeekCWString_entry() //  [R2]
         { info_tbl: [(c9164,
                       label: Foreign.C.String.$wpeekCWString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9164: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c9165; else goto c9166;
       c9165: // global
           R2 = R2;
           R1 = Foreign.C.String.$wpeekCWString_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9166: // global
           _s90v7::I64 = R2;
           _s90vz::I64 = 0;
           goto c916l;
       c916l: // global
           if (I32[_s90v7::I64 + (_s90vz::I64 << 2)] == 0 :: W32) goto c916r; else goto c916q;
       c916r: // global
           if (%MO_S_Gt_W64(_s90vz::I64, 0)) goto c916i; else goto c916j;
       c916i: // global
           I64[Sp - 24] = _s90v7::I64;
           I64[Sp - 16] = _s90vz::I64 - 1;
           P64[Sp - 8] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call _c915H() args: 0, res: 0, upd: 0;
       c916j: // global
           R1 = Foreign.C.String.peekCWString2_closure;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c916q: // global
           _s90vz::I64 = _s90vz::I64 + 1;
           goto c916l;
     }
 },
 _c915H() //  []
         { info_tbl: [(c915H,
                       label: block_c915H_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c915H: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c916d; else goto c916c;
       c916d: // global
           HpAlloc = 40;
           I64[Sp] = block_c915H_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c916c: // global
           _s90vo::P64 = P64[Sp + 24];
           _s90vq::I64 = I64[Sp + 16];
           if (_s90vq::I64 != 0) goto c916f; else goto c916g;
       c916f: // global
           I64[Hp - 32] = GHC.Int.I32#_con_info;
           I64[Hp - 24] = %MO_SS_Conv_W32_W64(I32[I64[Sp + 8] + (_s90vq::I64 << 2)]);
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = _s90vo::P64;
           I64[Sp + 16] = _s90vq::I64 - 1;
           P64[Sp + 24] = Hp - 14;
           call _c915H() args: 0, res: 0, upd: 0;
       c916g: // global
           Hp = Hp - 40;
           P64[Sp + 24] = _s90vo::P64;
           Sp = Sp + 8;
           call _c915P() args: 0, res: 0, upd: 0;
     }
 },
 _c915P() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c915P: // global
           Hp = Hp + 32;
           _s90ve::P64 = P64[Sp + 16];
           if (Hp > HpLim) (likely: False) goto c916a; else goto c9169;
       c916a: // global
           HpAlloc = 32;
           I64[Sp - 8] = block_c915O_info;
           R1 = _s90ve::P64;
           Sp = Sp - 8;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9169: // global
           I64[Hp - 24] = sat_s90vl_info;
           P64[Hp - 8] = _s90ve::P64;
           I64[Hp] = %MO_SS_Conv_W32_W64(I32[I64[Sp]]);
           R1 = Hp - 24;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c915O() //  [R1]
         { info_tbl: [(c915O,
                       label: block_c915O_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c915O: // global
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _c915P() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.501305408 UTC

[section ""data" . Foreign.C.String.peekCWString1_closure" {
     Foreign.C.String.peekCWString1_closure:
         const Foreign.C.String.peekCWString1_info;
         const 0;
 },
 Foreign.C.String.peekCWString1_entry() //  [R2]
         { info_tbl: [(c917m,
                       label: Foreign.C.String.peekCWString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c917m: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c917n; else goto c917o;
       c917n: // global
           R2 = R2;
           R1 = Foreign.C.String.peekCWString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c917o: // global
           I64[Sp - 8] = block_c917j_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u917s; else goto c917k;
       u917s: // global
           call _c917j(R1) args: 0, res: 0, upd: 0;
       c917k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c917j() //  [R1]
         { info_tbl: [(c917j,
                       label: block_c917j_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c917j: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call Foreign.C.String.$wpeekCWString_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.506106046 UTC

[section ""data" . Foreign.C.String.peekCWString_closure" {
     Foreign.C.String.peekCWString_closure:
         const Foreign.C.String.peekCWString_info;
         const 0;
 },
 Foreign.C.String.peekCWString_entry() //  [R2]
         { info_tbl: [(c917H,
                       label: Foreign.C.String.peekCWString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c917H: // global
           R2 = R2;
           call Foreign.C.String.peekCWString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.509584671 UTC

[section ""data" . Foreign.C.String.newCWString2_closure" {
     Foreign.C.String.newCWString2_closure:
         const Foreign.C.String.newCWString2_info;
 },
 Foreign.C.String.newCWString2_entry() //  [R2]
         { info_tbl: [(c917V,
                       label: Foreign.C.String.newCWString2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c917V: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c9185; else goto c9186;
       c9185: // global
           R2 = R2;
           R1 = Foreign.C.String.newCWString2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c9186: // global
           I64[Sp - 8] = block_c917S_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u918a; else goto c917T;
       u918a: // global
           call _c917S(R1) args: 0, res: 0, upd: 0;
       c917T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c917S() //  [R1]
         { info_tbl: [(c917S,
                       label: block_c917S_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c917S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c9189; else goto c9188;
       c9189: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c9188: // global
           _s90vO::I64 = %MO_SS_Conv_W32_W64(%MO_SS_Conv_W64_W32(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I32#_con_info;
           I64[Hp] = _s90vO::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.515774958 UTC

[section ""data" . Foreign.C.String.withCWStringLen1_closure" {
     Foreign.C.String.withCWStringLen1_closure:
         const Foreign.C.String.withCWStringLen1_info;
 },
 Foreign.C.String.withCWStringLen1_entry() //  [R2, R3]
         { info_tbl: [(c918u,
                       label: Foreign.C.String.withCWStringLen1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c918u: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c918y; else goto c918z;
       c918y: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.withCWStringLen1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c918z: // global
           I64[Sp - 16] = block_c918s_info;
           _s90vQ::P64 = R3;
           R3 = R2;
           R2 = Foreign.C.String.newCWString2_closure+1;
           P64[Sp - 8] = _s90vQ::P64;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c918s() //  [R1]
         { info_tbl: [(c918s,
                       label: block_c918s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c918s: // global
           I64[Sp - 8] = block_c918x_info;
           R3 = 0;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c918x() //  [R1]
         { info_tbl: [(c918x,
                       label: block_c918x_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c918x: // global
           I64[Sp - 8] = block_c918I_info;
           R2 = 4;
           _s90vT::I64 = R1;
           R1 = R1 << 2;
           I64[Sp] = _s90vT::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c918I() //  [R1]
         { info_tbl: [(c918I,
                       label: block_c918I_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c918I: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c9194() args: 0, res: 0, upd: 0;
     }
 },
 _c9194() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9194: // global
           _s90wc::P64 = P64[Sp];
           I64[Sp] = block_c9197_info;
           R1 = _s90wc::P64;
           if (R1 & 7 != 0) goto u919x; else goto c9199;
       u919x: // global
           call _c9197(R1) args: 0, res: 0, upd: 0;
       c9199: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c9197() //  [R1]
         { info_tbl: [(c9197,
                       label: block_c9197_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c9197: // global
           if (R1 & 7 == 1) goto u919u; else goto c919k;
       u919u: // global
           Sp = Sp + 8;
           call _c918R() args: 0, res: 0, upd: 0;
       c919k: // global
           I64[Sp - 8] = block_c919i_info;
           _s90wh::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s90wh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u919y; else goto c919l;
       u919y: // global
           call _c919i(R1) args: 0, res: 0, upd: 0;
       c919l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c918R() //  []
         { info_tbl: [(c918R,
                       label: block_c918R_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c918R: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c918Z; else goto c918Y;
       c918Z: // global
           HpAlloc = 56;
           I64[Sp] = block_c918R_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c918Y: // global
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = I64[Sp + 16];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           I64[Sp + 16] = block_c918W_info;
           R2 = Hp - 15;
           R1 = P64[Sp + 32];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c918W() //  [R1]
         { info_tbl: [(c918W,
                       label: block_c918W_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c918W: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c919i() //  [R1]
         { info_tbl: [(c919i,
                       label: block_c919i_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c919i: // global
           _s90wd::I64 = I64[Sp + 16];
           _s90wh::P64 = P64[Sp + 8];
           I32[I64[Sp + 24] + (_s90wd::I64 << 2)] = %MO_UU_Conv_W64_W32(I64[R1 + 7]);
           P64[Sp + 8] = _s90wh::P64;
           I64[Sp + 16] = _s90wd::I64 + 1;
           Sp = Sp + 8;
           call _c9194() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.531933388 UTC

[section ""data" . Foreign.C.String.withCWStringLen_closure" {
     Foreign.C.String.withCWStringLen_closure:
         const Foreign.C.String.withCWStringLen_info;
 },
 Foreign.C.String.withCWStringLen_entry() //  [R2, R3]
         { info_tbl: [(c91av,
                       label: Foreign.C.String.withCWStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91av: // global
           R3 = R3;
           R2 = R2;
           call Foreign.C.String.withCWStringLen1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.535644779 UTC

[section ""data" . Foreign.C.String.withCWString_closure" {
     Foreign.C.String.withCWString_closure:
         const Foreign.C.String.withCWString_info;
         const 0;
 },
 vals_s90wn_entry() //  [R1]
         { info_tbl: [(c91aK,
                       label: vals_s90wn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91aK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c91aL; else goto c91aM;
       c91aL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c91aM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = Foreign.C.String.newCWString2_closure+1;
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s90wq_entry() //  [R1]
         { info_tbl: [(c91aX,
                       label: sat_s90wq_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91aX: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_s90wr_entry() //  [R1, R2]
         { info_tbl: [(c91b0,
                       label: sat_s90wr_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91b0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c91b4; else goto c91b3;
       c91b4: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c91b3: // global
           _s90wn::P64 = P64[R1 + 7];
           I64[Hp - 8] = sat_s90wq_info;
           P64[Hp] = R2;
           R5 = Hp - 7;
           R4 = _s90wn::P64;
           R3 = Foreign.C.String.newCWString3_closure+1;
           R2 = Foreign.C.Types.$fStorableCWchar_closure;
           call Foreign.Marshal.Array.withArrayLen0_entry(R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.C.String.withCWString_entry() //  [R2]
         { info_tbl: [(c91b5,
                       label: Foreign.C.String.withCWString_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91b5: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c91b9; else goto c91b8;
       c91b9: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.C.String.withCWString_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c91b8: // global
           I64[Hp - 32] = vals_s90wn_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s90wr_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.544384683 UTC

[section ""data" . Foreign.C.String.newCWString1_closure" {
     Foreign.C.String.newCWString1_closure:
         const Foreign.C.String.newCWString1_info;
         const 0;
 },
 Foreign.C.String.newCWString1_entry() //  [R2]
         { info_tbl: [(c91bA,
                       label: Foreign.C.String.newCWString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91bA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c91bB; else goto c91bC;
       c91bB: // global
           R2 = R2;
           R1 = Foreign.C.String.newCWString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c91bC: // global
           I64[Sp - 8] = block_c91by_info;
           R3 = R2;
           R2 = Foreign.C.String.newCWString2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c91by() //  [R1]
         { info_tbl: [(c91by,
                       label: block_c91by_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91by: // global
           R4 = R1;
           R3 = Foreign.C.String.newCWString3_closure+1;
           R2 = Foreign.C.Types.$fStorableCWchar_closure;
           Sp = Sp + 8;
           call Foreign.Marshal.Array.newArray3_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.549864783 UTC

[section ""data" . Foreign.C.String.newCWString_closure" {
     Foreign.C.String.newCWString_closure:
         const Foreign.C.String.newCWString_info;
         const 0;
 },
 Foreign.C.String.newCWString_entry() //  [R2]
         { info_tbl: [(c91bT,
                       label: Foreign.C.String.newCWString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91bT: // global
           R2 = R2;
           call Foreign.C.String.newCWString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.553223996 UTC

[section ""data" . Foreign.C.String.newCWStringLen1_closure" {
     Foreign.C.String.newCWStringLen1_closure:
         const Foreign.C.String.newCWStringLen1_info;
         const 0;
 },
 sat_s90wC_entry() //  [R1]
         { info_tbl: [(c91cg,
                       label: sat_s90wC_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91cg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c91ck; else goto c91cl;
       c91ck: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c91cl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c91ce_info;
           R3 = 0;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _c91ce() //  [R1]
         { info_tbl: [(c91ce,
                       label: block_c91ce_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91ce: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c91co; else goto c91cn;
       c91co: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c91cn: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.C.String.newCWStringLen1_entry() //  [R2]
         { info_tbl: [(c91cp,
                       label: Foreign.C.String.newCWStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91cp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c91cr; else goto c91cs;
       c91cr: // global
           R2 = R2;
           R1 = Foreign.C.String.newCWStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c91cs: // global
           I64[Sp - 8] = block_c91c4_info;
           R3 = R2;
           R2 = Foreign.C.String.newCWString2_closure+1;
           Sp = Sp - 8;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c91c4() //  [R1]
         { info_tbl: [(c91c4,
                       label: block_c91c4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91c4: // global
           I64[Sp - 8] = block_c91c8_info;
           R3 = R1;
           R2 = Foreign.C.Types.$fStorableCWchar_closure;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call Foreign.Marshal.Array.newArray1_entry(R3,
                                                      R2) args: 8, res: 8, upd: 8;
     }
 },
 _c91c8() //  [R1]
         { info_tbl: [(c91c8,
                       label: block_c91c8_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91c8: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c91cw; else goto c91cv;
       c91cw: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c91cv: // global
           I64[Hp - 40] = sat_s90wC_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 40;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.563833458 UTC

[section ""data" . Foreign.C.String.newCWStringLen_closure" {
     Foreign.C.String.newCWStringLen_closure:
         const Foreign.C.String.newCWStringLen_info;
         const 0;
 },
 Foreign.C.String.newCWStringLen_entry() //  [R2]
         { info_tbl: [(c91d4,
                       label: Foreign.C.String.newCWStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91d4: // global
           R2 = R2;
           call Foreign.C.String.newCWStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.567216801 UTC

[section ""data" . Foreign.C.String.castCharToCChar1_closure" {
     Foreign.C.String.castCharToCChar1_closure:
         const Foreign.C.String.castCharToCChar1_info;
 },
 Foreign.C.String.castCharToCChar1_entry() //  [R2]
         { info_tbl: [(c91di,
                       label: Foreign.C.String.castCharToCChar1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91di: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c91ds; else goto c91dt;
       c91ds: // global
           R2 = R2;
           R1 = Foreign.C.String.castCharToCChar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c91dt: // global
           I64[Sp - 8] = block_c91df_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u91dx; else goto c91dg;
       u91dx: // global
           call _c91df(R1) args: 0, res: 0, upd: 0;
       c91dg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c91df() //  [R1]
         { info_tbl: [(c91df,
                       label: block_c91df_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91df: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c91dw; else goto c91dv;
       c91dw: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c91dv: // global
           _s90wI::I64 = %MO_SS_Conv_W8_W64(%MO_SS_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Int.I8#_con_info;
           I64[Hp] = _s90wI::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.572606674 UTC

[section ""data" . Foreign.C.String.castCharToCSChar_closure" {
     Foreign.C.String.castCharToCSChar_closure:
         const Foreign.C.String.castCharToCSChar_info;
 },
 Foreign.C.String.castCharToCSChar_entry() //  [R2]
         { info_tbl: [(c91dP,
                       label: Foreign.C.String.castCharToCSChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91dP: // global
           R2 = R2;
           call Foreign.C.String.castCharToCChar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.576134245 UTC

[section ""data" . Foreign.C.String.castCharToCUChar1_closure" {
     Foreign.C.String.castCharToCUChar1_closure:
         const Foreign.C.String.castCharToCUChar1_info;
 },
 Foreign.C.String.castCharToCUChar1_entry() //  [R2]
         { info_tbl: [(c91e3,
                       label: Foreign.C.String.castCharToCUChar1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91e3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c91eg; else goto c91eh;
       c91eg: // global
           R2 = R2;
           R1 = Foreign.C.String.castCharToCUChar1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c91eh: // global
           I64[Sp - 8] = block_c91e0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u91el; else goto c91e1;
       u91el: // global
           call _c91e0(R1) args: 0, res: 0, upd: 0;
       c91e1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c91e0() //  [R1]
         { info_tbl: [(c91e0,
                       label: block_c91e0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91e0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c91ek; else goto c91ej;
       c91ek: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c91ej: // global
           _s90wO::I64 = %MO_UU_Conv_W8_W64(%MO_UU_Conv_W64_W8(I64[R1 + 7]));
           I64[Hp - 8] = GHC.Word.W8#_con_info;
           I64[Hp] = _s90wO::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.581604864 UTC

[section ""data" . Foreign.C.String.castCharToCUChar_closure" {
     Foreign.C.String.castCharToCUChar_closure:
         const Foreign.C.String.castCharToCUChar_info;
 },
 Foreign.C.String.castCharToCUChar_entry() //  [R2]
         { info_tbl: [(c91eD,
                       label: Foreign.C.String.castCharToCUChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91eD: // global
           R2 = R2;
           call Foreign.C.String.castCharToCUChar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.584634032 UTC

[section ""data" . Foreign.C.String.castCharToCChar_closure" {
     Foreign.C.String.castCharToCChar_closure:
         const Foreign.C.String.castCharToCChar_info;
 },
 Foreign.C.String.castCharToCChar_entry() //  [R2]
         { info_tbl: [(c91eO,
                       label: Foreign.C.String.castCharToCChar_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91eO: // global
           R2 = R2;
           call Foreign.C.String.castCharToCChar1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.588440754 UTC

[section ""data" . Foreign.C.String.newCAString1_closure" {
     Foreign.C.String.newCAString1_closure:
         const Foreign.C.String.newCAString1_info;
         const 0;
 },
 Foreign.C.String.newCAString1_entry() //  [R2]
         { info_tbl: [(c91f1,
                       label: Foreign.C.String.newCAString1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91f1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c91f2; else goto c91f3;
       c91f2: // global
           R2 = R2;
           R1 = Foreign.C.String.newCAString1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c91f3: // global
           I64[Sp - 16] = block_c91eZ_info;
           R3 = 0;
           _s90wP::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s90wP::P64;
           Sp = Sp - 16;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c91eZ() //  [R1]
         { info_tbl: [(c91eZ,
                       label: block_c91eZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91eZ: // global
           _s90wP::P64 = P64[Sp + 8];
           (_s90wX::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(R1 + 1);
           if (_s90wX::I64 == 0) goto c91fR; else goto c91fQ;
       c91fR: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c91fQ: // global
           I64[Sp - 8] = 0;
           P64[Sp] = _s90wP::P64;
           I64[Sp + 8] = _s90wX::I64;
           Sp = Sp - 8;
           call _c91ft() args: 0, res: 0, upd: 0;
     }
 },
 _c91ft() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91ft: // global
           I64[Sp - 8] = block_c91fw_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u91g6; else goto c91fy;
       u91g6: // global
           call _c91fw(R1) args: 0, res: 0, upd: 0;
       c91fy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c91fw() //  [R1]
         { info_tbl: [(c91fw,
                       label: block_c91fw_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91fw: // global
           if (R1 & 7 == 1) goto c91fE; else goto c91fJ;
       c91fE: // global
           I64[Sp + 16] = I64[Sp + 8];
           Sp = Sp + 16;
           call _c91fl() args: 0, res: 0, upd: 0;
       c91fJ: // global
           I64[Sp] = block_c91fH_info;
           _s90xa::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _s90xa::P64;
           if (R1 & 7 != 0) goto u91g7; else goto c91fK;
       u91g7: // global
           call _c91fH(R1) args: 0, res: 0, upd: 0;
       c91fK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c91fl() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91fl: // global
           Hp = Hp + 16;
           _s90x0::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c91fq; else goto c91fp;
       c91fq: // global
           HpAlloc = 16;
           I64[Sp] = block_c91fk_info;
           R1 = _s90x0::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c91fp: // global
           _s90wX::I64 = I64[Sp + 8];
           I8[_s90wX::I64 + _s90x0::I64] = 0 :: W8;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s90wX::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c91fk() //  [R1]
         { info_tbl: [(c91fk,
                       label: block_c91fk_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91fk: // global
           I64[Sp] = R1;
           call _c91fl() args: 0, res: 0, upd: 0;
     }
 },
 _c91fH() //  [R1]
         { info_tbl: [(c91fH,
                       label: block_c91fH_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91fH: // global
           _s90x6::I64 = I64[Sp + 8];
           _s90xa::P64 = P64[Sp + 16];
           I8[I64[Sp + 24] + _s90x6::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 16] = _s90xa::P64;
           I64[Sp + 8] = _s90x6::I64 + 1;
           Sp = Sp + 8;
           call _c91ft() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.600975401 UTC

[section ""data" . Foreign.C.String.newCAString_closure" {
     Foreign.C.String.newCAString_closure:
         const Foreign.C.String.newCAString_info;
         const 0;
 },
 Foreign.C.String.newCAString_entry() //  [R2]
         { info_tbl: [(c91gN,
                       label: Foreign.C.String.newCAString_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91gN: // global
           R2 = R2;
           call Foreign.C.String.newCAString1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.605233621 UTC

[section ""data" . Foreign.C.String.newCAStringLen1_closure" {
     Foreign.C.String.newCAStringLen1_closure:
         const Foreign.C.String.newCAStringLen1_info;
         const 0;
 },
 Foreign.C.String.newCAStringLen1_entry() //  [R2]
         { info_tbl: [(c91h0,
                       label: Foreign.C.String.newCAStringLen1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91h0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c91h1; else goto c91h2;
       c91h1: // global
           R2 = R2;
           R1 = Foreign.C.String.newCAStringLen1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c91h2: // global
           I64[Sp - 16] = block_c91gY_info;
           R3 = 0;
           _s90xh::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s90xh::P64;
           Sp = Sp - 16;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c91gY() //  [R1]
         { info_tbl: [(c91gY,
                       label: block_c91gY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91gY: // global
           _s90xh::P64 = P64[Sp + 8];
           (_s90xp::I64) = call "ccall" arg hints:  []  result hints:  [PtrHint] malloc(R1 + 1);
           if (_s90xp::I64 == 0) goto c91hS; else goto c91hR;
       c91hS: // global
           R1 = Foreign.Marshal.Alloc.malloc1_closure;
           Sp = Sp + 16;
           call stg_raiseIO#(R1) args: 8, res: 0, upd: 8;
       c91hR: // global
           P64[Sp - 16] = _s90xh::P64;
           I64[Sp - 8] = 0;
           I64[Sp] = _s90xp::I64;
           I64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _c91hu() args: 0, res: 0, upd: 0;
     }
 },
 _c91hu() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91hu: // global
           _s90xx::P64 = P64[Sp];
           I64[Sp] = block_c91hx_info;
           R1 = _s90xx::P64;
           if (R1 & 7 != 0) goto u91i5; else goto c91hz;
       u91i5: // global
           call _c91hx(R1) args: 0, res: 0, upd: 0;
       c91hz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c91hx() //  [R1]
         { info_tbl: [(c91hx,
                       label: block_c91hx_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91hx: // global
           if (R1 & 7 == 1) goto u91i2; else goto c91hK;
       u91i2: // global
           Sp = Sp + 8;
           call _c91hk() args: 0, res: 0, upd: 0;
       c91hK: // global
           I64[Sp - 8] = block_c91hI_info;
           _s90xC::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s90xC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u91i6; else goto c91hL;
       u91i6: // global
           call _c91hI(R1) args: 0, res: 0, upd: 0;
       c91hL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c91hk() //  []
         { info_tbl: [(c91hk,
                       label: block_c91hk_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91hk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c91hr; else goto c91hq;
       c91hr: // global
           HpAlloc = 56;
           I64[Sp] = block_c91hk_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c91hq: // global
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = I64[Sp + 16];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c91hI() //  [R1]
         { info_tbl: [(c91hI,
                       label: block_c91hI_info
                       rep:StackRep [False, True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91hI: // global
           _s90xy::I64 = I64[Sp + 16];
           _s90xC::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s90xy::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s90xC::P64;
           I64[Sp + 16] = _s90xy::I64 + 1;
           Sp = Sp + 8;
           call _c91hu() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.617063662 UTC

[section ""data" . Foreign.C.String.newCAStringLen_closure" {
     Foreign.C.String.newCAStringLen_closure:
         const Foreign.C.String.newCAStringLen_info;
         const 0;
 },
 Foreign.C.String.newCAStringLen_entry() //  [R2]
         { info_tbl: [(c91iP,
                       label: Foreign.C.String.newCAStringLen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91iP: // global
           R2 = R2;
           call Foreign.C.String.newCAStringLen1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.621374172 UTC

[section ""data" . Foreign.C.String.withCAString1_closure" {
     Foreign.C.String.withCAString1_closure:
         const Foreign.C.String.withCAString1_info;
 },
 Foreign.C.String.withCAString1_entry() //  [R2, R3]
         { info_tbl: [(c91j2,
                       label: Foreign.C.String.withCAString1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91j2: // global
           if ((Sp + -48) < SpLim) (likely: False) goto c91j3; else goto c91j4;
       c91j3: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.withCAString1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c91j4: // global
           I64[Sp - 24] = block_c91j0_info;
           _s90xL::P64 = R3;
           R3 = 0;
           _s90xK::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s90xK::P64;
           P64[Sp - 8] = _s90xL::P64;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c91j0() //  [R1]
         { info_tbl: [(c91j0,
                       label: block_c91j0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91j0: // global
           I64[Sp] = block_c91jb_info;
           R2 = 1;
           R1 = R1 + 1;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c91jb() //  [R1]
         { info_tbl: [(c91jb,
                       label: block_c91jb_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91jb: // global
           P64[Sp - 16] = P64[Sp + 8];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 8] = R1;
           Sp = Sp - 16;
           call _c91jv() args: 0, res: 0, upd: 0;
     }
 },
 _c91jv() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91jv: // global
           _s90y6::P64 = P64[Sp];
           I64[Sp] = block_c91jy_info;
           R1 = _s90y6::P64;
           if (R1 & 7 != 0) goto u91k6; else goto c91jA;
       u91k6: // global
           call _c91jy(R1) args: 0, res: 0, upd: 0;
       c91jA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c91jy() //  [R1]
         { info_tbl: [(c91jy,
                       label: block_c91jy_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91jy: // global
           if (R1 & 7 == 1) goto c91jG; else goto c91jL;
       c91jG: // global
           I64[Sp + 8] = I64[Sp + 8];
           Sp = Sp + 8;
           call _c91jk() args: 0, res: 0, upd: 0;
       c91jL: // global
           I64[Sp - 8] = block_c91jJ_info;
           _s90yb::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s90yb::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u91k7; else goto c91jM;
       u91k7: // global
           call _c91jJ(R1) args: 0, res: 0, upd: 0;
       c91jM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c91jk() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91jk: // global
           Hp = Hp + 16;
           _s90xX::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto c91jq; else goto c91jp;
       c91jq: // global
           HpAlloc = 16;
           I64[Sp] = block_c91jj_info;
           R1 = _s90xX::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c91jp: // global
           _s90xL::P64 = P64[Sp + 24];
           _s90xV::I64 = I64[Sp + 8];
           I8[_s90xV::I64 + _s90xX::I64] = 0 :: W8;
           I64[Hp - 8] = GHC.Ptr.Ptr_con_info;
           I64[Hp] = _s90xV::I64;
           I64[Sp + 8] = block_c91jn_info;
           R2 = Hp - 7;
           R1 = _s90xL::P64;
           Sp = Sp + 8;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c91jj() //  [R1]
         { info_tbl: [(c91jj,
                       label: block_c91jj_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91jj: // global
           I64[Sp] = R1;
           call _c91jk() args: 0, res: 0, upd: 0;
     }
 },
 _c91jn() //  [R1]
         { info_tbl: [(c91jn,
                       label: block_c91jn_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91jn: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c91jJ() //  [R1]
         { info_tbl: [(c91jJ,
                       label: block_c91jJ_info
                       rep:StackRep [False, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91jJ: // global
           _s90y7::I64 = I64[Sp + 16];
           _s90yb::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s90y7::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s90yb::P64;
           I64[Sp + 16] = _s90y7::I64 + 1;
           Sp = Sp + 8;
           call _c91jv() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.63713569 UTC

[section ""data" . Foreign.C.String.withCAString_closure" {
     Foreign.C.String.withCAString_closure:
         const Foreign.C.String.withCAString_info;
 },
 Foreign.C.String.withCAString_entry() //  [R2, R3]
         { info_tbl: [(c91kX,
                       label: Foreign.C.String.withCAString_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91kX: // global
           R3 = R3;
           R2 = R2;
           call Foreign.C.String.withCAString1_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.641165484 UTC

[section ""data" . Foreign.C.String.withCAStringLen1_closure" {
     Foreign.C.String.withCAStringLen1_closure:
         const Foreign.C.String.withCAStringLen1_info;
 },
 Foreign.C.String.withCAStringLen1_entry() //  [R2, R3]
         { info_tbl: [(c91la,
                       label: Foreign.C.String.withCAStringLen1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91la: // global
           if ((Sp + -56) < SpLim) (likely: False) goto c91lb; else goto c91lc;
       c91lb: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.C.String.withCAStringLen1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c91lc: // global
           I64[Sp - 24] = block_c91l8_info;
           _s90yj::P64 = R3;
           R3 = 0;
           _s90yi::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s90yi::P64;
           P64[Sp - 8] = _s90yj::P64;
           Sp = Sp - 24;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _c91l8() //  [R1]
         { info_tbl: [(c91l8,
                       label: block_c91l8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91l8: // global
           I64[Sp - 8] = block_c91lf_info;
           R2 = 1;
           _s90yl::I64 = R1;
           R1 = R1;
           I64[Sp] = _s90yl::I64;
           Sp = Sp - 8;
           call stg_newAlignedPinnedByteArray#(R2,
                                               R1) args: 8, res: 8, upd: 8;
     }
 },
 _c91lf() //  [R1]
         { info_tbl: [(c91lf,
                       label: block_c91lf_info
                       rep:StackRep [True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91lf: // global
           P64[Sp - 16] = P64[Sp + 16];
           I64[Sp - 8] = 0;
           P64[Sp] = R1 + 16;
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call _c91lC() args: 0, res: 0, upd: 0;
     }
 },
 _c91lC() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91lC: // global
           _s90yD::P64 = P64[Sp];
           I64[Sp] = block_c91lF_info;
           R1 = _s90yD::P64;
           if (R1 & 7 != 0) goto u91mb; else goto c91lH;
       u91mb: // global
           call _c91lF(R1) args: 0, res: 0, upd: 0;
       c91lH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c91lF() //  [R1]
         { info_tbl: [(c91lF,
                       label: block_c91lF_info
                       rep:StackRep [True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91lF: // global
           if (R1 & 7 == 1) goto u91m8; else goto c91lS;
       u91m8: // global
           Sp = Sp + 8;
           call _c91lp() args: 0, res: 0, upd: 0;
       c91lS: // global
           I64[Sp - 8] = block_c91lQ_info;
           _s90yI::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s90yI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u91mc; else goto c91lT;
       u91mc: // global
           call _c91lQ(R1) args: 0, res: 0, upd: 0;
       c91lT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c91lp() //  []
         { info_tbl: [(c91lp,
                       label: block_c91lp_info
                       rep:StackRep [True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91lp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c91lx; else goto c91lw;
       c91lx: // global
           HpAlloc = 56;
           I64[Sp] = block_c91lp_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       c91lw: // global
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = I64[Sp + 16];
           I64[Hp - 32] = GHC.Ptr.Ptr_con_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           I64[Sp + 16] = block_c91lu_info;
           R2 = Hp - 15;
           R1 = P64[Sp + 32];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c91lu() //  [R1]
         { info_tbl: [(c91lu,
                       label: block_c91lu_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91lu: // global
           call MO_Touch(P64[Sp + 8]);
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c91lQ() //  [R1]
         { info_tbl: [(c91lQ,
                       label: block_c91lQ_info
                       rep:StackRep [False, True, True, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91lQ: // global
           _s90yE::I64 = I64[Sp + 16];
           _s90yI::P64 = P64[Sp + 8];
           I8[I64[Sp + 24] + _s90yE::I64] = %MO_SS_Conv_W64_W8(I64[R1 + 7]);
           P64[Sp + 8] = _s90yI::P64;
           I64[Sp + 16] = _s90yE::I64 + 1;
           Sp = Sp + 8;
           call _c91lC() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.656318443 UTC

[section ""data" . Foreign.C.String.withCAStringLen_closure" {
     Foreign.C.String.withCAStringLen_closure:
         const Foreign.C.String.withCAStringLen_info;
 },
 Foreign.C.String.withCAStringLen_entry() //  [R2, R3]
         { info_tbl: [(c91n5,
                       label: Foreign.C.String.withCAStringLen_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c91n5: // global
           R3 = R3;
           R2 = R2;
           call Foreign.C.String.withCAStringLen1_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:04:10.659422877 UTC

[section ""relreadonly" . S90Bc_srt" {
     S90Bc_srt:
         const GHC.IO.Encoding.getForeignEncoding_closure;
         const Foreign.C.String.withCStringLen1_closure;
         const Foreign.C.String.withCString1_closure;
         const GHC.Foreign.charIsRepresentable1_closure;
         const Foreign.C.String.charIsRepresentable1_closure;
         const Foreign.Marshal.Alloc.malloc1_closure;
         const Foreign.Marshal.Alloc.realloc2_closure;
         const Foreign.C.String.newCStringLen1_closure;
         const GHC.Foreign.newCString1_closure;
         const Foreign.C.String.newCString1_closure;
         const GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
         const Foreign.C.String.peekCStringLen1_closure;
         const GHC.Foreign.peekCString1_closure;
         const Foreign.C.String.peekCString1_closure;
         const GHC.Char.$wlvl_closure;
         const Foreign.C.String.castCWcharToChar_closure;
         const Foreign.C.String.peekCWString2_closure;
         const Foreign.C.String.$wpeekCWStringLen_closure;
         const Foreign.C.String.peekCWStringLen1_closure;
         const Foreign.C.String.$wpeekCWString_closure;
         const Foreign.C.String.peekCWString1_closure;
         const Foreign.Marshal.Array.withArrayLen0_closure;
         const Foreign.C.String.withCWString_closure;
         const Foreign.Marshal.Array.newArray3_closure;
         const Foreign.C.String.newCWString1_closure;
         const Foreign.Marshal.Array.newArray1_closure;
         const Foreign.C.String.newCWStringLen1_closure;
         const Foreign.C.String.newCAString1_closure;
         const Foreign.C.String.newCAStringLen1_closure;
 }]

