
==================== Output Cmm ====================
2018-03-16 16:02:53.869662778 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:02:53.871047512 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$wnewForeignPtr_closure" {
     Foreign.ForeignPtr.Imp.$wnewForeignPtr_closure:
         const Foreign.ForeignPtr.Imp.$wnewForeignPtr_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.$wnewForeignPtr_entry() //  [R2, R3]
         { info_tbl: [(c7N5S,
                       label: Foreign.ForeignPtr.Imp.$wnewForeignPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N5S: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7N5T; else goto c7N5U;
       c7N5T: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.$wnewForeignPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7N5U: // global
           I64[Sp - 24] = block_c7N5M_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7N5M() //  [R1]
         { info_tbl: [(c7N5M,
                       label: block_c7N5M_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N5M: // global
           I64[Sp] = block_c7N5O_info;
           R6 = I64[Sp + 16];
           R5 = 0;
           R4 = 0;
           R3 = I64[Sp + 8];
           R2 = R1;
           P64[Sp - 8] = GHC.Tuple.()_closure+1;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.ForeignPtr.$winsertCFinalizer_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _c7N5O() //  [R1]
         { info_tbl: [(c7N5O,
                       label: block_c7N5O_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N5O: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7N5Y; else goto c7N5X;
       c7N5Y: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7N5X: // global
           I64[Hp - 32] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.872625762 UTC

[section ""data" . Foreign.ForeignPtr.Imp.newForeignPtr1_closure" {
     Foreign.ForeignPtr.Imp.newForeignPtr1_closure:
         const Foreign.ForeignPtr.Imp.newForeignPtr1_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.newForeignPtr1_entry() //  [R2, R3]
         { info_tbl: [(c7N67,
                       label: Foreign.ForeignPtr.Imp.newForeignPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N67: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7N6b; else goto c7N6c;
       c7N6b: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.newForeignPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7N6c: // global
           I64[Sp - 16] = block_c7N64_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7N6k; else goto c7N65;
       u7N6k: // global
           call _c7N64(R1) args: 0, res: 0, upd: 0;
       c7N65: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7N64() //  [R1]
         { info_tbl: [(c7N64,
                       label: block_c7N64_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N64: // global
           I64[Sp] = block_c7N6a_info;
           _s7N4q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7N4q::I64;
           if (R1 & 7 != 0) goto u7N6j; else goto c7N6e;
       u7N6j: // global
           call _c7N6a(R1) args: 0, res: 0, upd: 0;
       c7N6e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7N6a() //  [R1]
         { info_tbl: [(c7N6a,
                       label: block_c7N6a_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N6a: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.ForeignPtr.Imp.$wnewForeignPtr_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.873931666 UTC

[section ""data" . Foreign.ForeignPtr.Imp.newForeignPtr_closure" {
     Foreign.ForeignPtr.Imp.newForeignPtr_closure:
         const Foreign.ForeignPtr.Imp.newForeignPtr_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.newForeignPtr_entry() //  [R2, R3]
         { info_tbl: [(c7N6p,
                       label: Foreign.ForeignPtr.Imp.newForeignPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N6p: // global
           R3 = R3;
           R2 = R2;
           call Foreign.ForeignPtr.Imp.newForeignPtr1_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.87507817 UTC

[section ""data" . Foreign.ForeignPtr.Imp.withForeignPtr1_closure" {
     Foreign.ForeignPtr.Imp.withForeignPtr1_closure:
         const Foreign.ForeignPtr.Imp.withForeignPtr1_info;
 },
 sat_s7N4w_entry() //  [R1]
         { info_tbl: [(c7N6A,
                       label: sat_s7N4w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N6A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7N6B; else goto c7N6C;
       c7N6B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7N6C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.ForeignPtr.unsafeForeignPtrToPtr_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.ForeignPtr.Imp.withForeignPtr1_entry() //  [R2, R3]
         { info_tbl: [(c7N6I,
                       label: Foreign.ForeignPtr.Imp.withForeignPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N6I: // global
           _s7N4u::P64 = R3;
           _s7N4t::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c7N6J; else goto c7N6K;
       c7N6K: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7N6M; else goto c7N6L;
       c7N6M: // global
           HpAlloc = 24;
           goto c7N6J;
       c7N6J: // global
           R3 = _s7N4u::P64;
           R2 = _s7N4t::P64;
           R1 = Foreign.ForeignPtr.Imp.withForeignPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7N6L: // global
           I64[Hp - 16] = sat_s7N4w_info;
           P64[Hp] = _s7N4t::P64;
           I64[Sp - 16] = block_c7N6D_info;
           R2 = Hp - 16;
           R1 = _s7N4u::P64;
           P64[Sp - 8] = _s7N4t::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7N6D() //  [R1]
         { info_tbl: [(c7N6D,
                       label: block_c7N6D_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N6D: // global
           I64[Sp] = block_c7N6F_info;
           _s7N4z::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7N4z::P64;
           if (R1 & 7 != 0) goto u7N6S; else goto c7N6G;
       u7N6S: // global
           call _c7N6F(R1) args: 0, res: 0, upd: 0;
       c7N6G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7N6F() //  [R1]
         { info_tbl: [(c7N6F,
                       label: block_c7N6F_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N6F: // global
           _s7N4z::P64 = P64[Sp + 8];
           call MO_Touch(P64[R1 + 7]);
           R1 = _s7N4z::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.876788675 UTC

[section ""data" . Foreign.ForeignPtr.Imp.withForeignPtr_closure" {
     Foreign.ForeignPtr.Imp.withForeignPtr_closure:
         const Foreign.ForeignPtr.Imp.withForeignPtr_info;
 },
 Foreign.ForeignPtr.Imp.withForeignPtr_entry() //  [R2, R3]
         { info_tbl: [(c7N6X,
                       label: Foreign.ForeignPtr.Imp.withForeignPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N6X: // global
           R3 = R3;
           R2 = R2;
           call Foreign.ForeignPtr.Imp.withForeignPtr1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.877786115 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_closure" {
     Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_closure:
         const Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_entry() //  [R2, R3, R4]
         { info_tbl: [(c7N7a,
                       label: Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N7a: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7N7b; else goto c7N7c;
       c7N7b: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7N7c: // global
           I64[Sp - 32] = block_c7N74_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7N74() //  [R1]
         { info_tbl: [(c7N74,
                       label: block_c7N74_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N74: // global
           _s7N4E::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c7N76_info;
           R6 = I64[Sp + 24];
           R5 = I64[Sp + 16];
           R4 = 1;
           R3 = _s7N4E::I64;
           R2 = R1;
           P64[Sp] = GHC.Tuple.()_closure+1;
           P64[Sp + 16] = R1;
           call GHC.ForeignPtr.$winsertCFinalizer_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _c7N76() //  [R1]
         { info_tbl: [(c7N76,
                       label: block_c7N76_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N76: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7N7g; else goto c7N7f;
       c7N7g: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7N7f: // global
           I64[Hp - 32] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.879323387 UTC

[section ""data" . Foreign.ForeignPtr.Imp.newForeignPtrEnv1_closure" {
     Foreign.ForeignPtr.Imp.newForeignPtrEnv1_closure:
         const Foreign.ForeignPtr.Imp.newForeignPtrEnv1_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.newForeignPtrEnv1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7N7o,
                       label: Foreign.ForeignPtr.Imp.newForeignPtrEnv1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N7o: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7N7x; else goto c7N7y;
       c7N7x: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.newForeignPtrEnv1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7N7y: // global
           I64[Sp - 24] = block_c7N7l_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7N7H; else goto c7N7m;
       u7N7H: // global
           call _c7N7l(R1) args: 0, res: 0, upd: 0;
       c7N7m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7N7l() //  [R1]
         { info_tbl: [(c7N7l,
                       label: block_c7N7l_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N7l: // global
           I64[Sp] = block_c7N7r_info;
           _s7N4V::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7N4V::I64;
           if (R1 & 7 != 0) goto u7N7G; else goto c7N7s;
       u7N7G: // global
           call _c7N7r(R1) args: 0, res: 0, upd: 0;
       c7N7s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7N7r() //  [R1]
         { info_tbl: [(c7N7r,
                       label: block_c7N7r_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N7r: // global
           I64[Sp] = block_c7N7w_info;
           _s7N4X::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s7N4X::I64;
           if (R1 & 7 != 0) goto u7N7I; else goto c7N7B;
       u7N7I: // global
           call _c7N7w(R1) args: 0, res: 0, upd: 0;
       c7N7B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7N7w() //  [R1]
         { info_tbl: [(c7N7w,
                       label: block_c7N7w_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N7w: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.881042781 UTC

[section ""data" . Foreign.ForeignPtr.Imp.newForeignPtrEnv_closure" {
     Foreign.ForeignPtr.Imp.newForeignPtrEnv_closure:
         const Foreign.ForeignPtr.Imp.newForeignPtrEnv_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.newForeignPtrEnv_entry() //  [R2, R3, R4]
         { info_tbl: [(c7N7N,
                       label: Foreign.ForeignPtr.Imp.newForeignPtrEnv_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N7N: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.ForeignPtr.Imp.newForeignPtrEnv1_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.881778819 UTC

[section ""cstring" . lvl_r7N3Z_bytes" {
     lvl_r7N3Z_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.88252432 UTC

[section ""data" . lvl1_r7N40_closure" {
     lvl1_r7N40_closure:
         const lvl1_r7N40_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r7N40_entry() //  [R1]
         { info_tbl: [(c7N7W,
                       label: lvl1_r7N40_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N7W: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7N7X; else goto c7N7Y;
       c7N7X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7N7Y: // global
           (_c7N7T::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7N7T::I64 == 0) goto c7N7V; else goto c7N7U;
       c7N7V: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7N7U: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7N7T::I64;
           R2 = lvl_r7N3Z_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.883360841 UTC

[section ""cstring" . Foreign.ForeignPtr.Imp.$trModule4_bytes" {
     Foreign.ForeignPtr.Imp.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.884075987 UTC

[section ""data" . lvl2_r7N41_closure" {
     lvl2_r7N41_closure:
         const lvl2_r7N41_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r7N41_entry() //  [R1]
         { info_tbl: [(c7N85,
                       label: lvl2_r7N41_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N85: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7N86; else goto c7N87;
       c7N86: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7N87: // global
           (_c7N82::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7N82::I64 == 0) goto c7N84; else goto c7N83;
       c7N84: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7N83: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7N82::I64;
           R2 = Foreign.ForeignPtr.Imp.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.885173353 UTC

[section ""cstring" . Foreign.ForeignPtr.Imp.$trModule2_bytes" {
     Foreign.ForeignPtr.Imp.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,70,111,114,101,105,103,110,80,116,114,46,73,109,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.885910749 UTC

[section ""data" . lvl3_r7N42_closure" {
     lvl3_r7N42_closure:
         const lvl3_r7N42_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r7N42_entry() //  [R1]
         { info_tbl: [(c7N8e,
                       label: lvl3_r7N42_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N8e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7N8f; else goto c7N8g;
       c7N8f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7N8g: // global
           (_c7N8b::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7N8b::I64 == 0) goto c7N8d; else goto c7N8c;
       c7N8d: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7N8c: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7N8b::I64;
           R2 = Foreign.ForeignPtr.Imp.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.88676727 UTC

[section ""cstring" . lvl4_r7N43_bytes" {
     lvl4_r7N43_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,70,111,114,101,105,103,110,80,116,114,47,73,109,112,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.887457898 UTC

[section ""data" . lvl5_r7N44_closure" {
     lvl5_r7N44_closure:
         const lvl5_r7N44_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r7N44_entry() //  [R1]
         { info_tbl: [(c7N8n,
                       label: lvl5_r7N44_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N8n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7N8o; else goto c7N8p;
       c7N8o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7N8p: // global
           (_c7N8k::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7N8k::I64 == 0) goto c7N8m; else goto c7N8l;
       c7N8m: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7N8l: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7N8k::I64;
           R2 = lvl4_r7N43_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.888299329 UTC

[section ""data" . lvl6_r7N45_closure" {
     lvl6_r7N45_closure:
         const GHC.Types.I#_con_info;
         const 110;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.889072743 UTC

[section ""data" . lvl7_r7N46_closure" {
     lvl7_r7N46_closure:
         const GHC.Types.I#_con_info;
         const 35;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.889640117 UTC

[section ""data" . lvl8_r7N47_closure" {
     lvl8_r7N47_closure:
         const GHC.Types.I#_con_info;
         const 44;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.890184037 UTC

[section ""data" . lvl9_r7N48_closure" {
     lvl9_r7N48_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r7N41_closure;
         const lvl3_r7N42_closure;
         const lvl5_r7N44_closure;
         const lvl6_r7N45_closure+1;
         const lvl7_r7N46_closure+1;
         const lvl6_r7N45_closure+1;
         const lvl8_r7N47_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.890793402 UTC

[section ""data" . lvl10_r7N49_closure" {
     lvl10_r7N49_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r7N40_closure;
         const lvl9_r7N48_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.891550822 UTC

[section ""data" . Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_closure" {
     Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_closure:
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_entry() //  [R1]
         { info_tbl: [(c7N8w,
                       label: Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N8w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7N8x; else goto c7N8y;
       c7N8x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7N8y: // global
           (_c7N8t::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7N8t::I64 == 0) goto c7N8v; else goto c7N8u;
       c7N8v: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7N8u: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7N8t::I64;
           R2 = lvl10_r7N49_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.893574785 UTC

[section ""data" . Foreign.ForeignPtr.Imp.mallocForeignPtrArray_closure" {
     Foreign.ForeignPtr.Imp.mallocForeignPtrArray_closure:
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray_info;
         const 0;
 },
 lvl11_s7N51_entry() //  [R1]
         { info_tbl: [(c7N8H,
                       label: lvl11_s7N51_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N8H: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7N8I; else goto c7N8J;
       c7N8I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7N8J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7N5k_entry() //  [R1, R2]
         { info_tbl: [(c7N8S,
                       label: sat_s7N5k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N8S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7N8W; else goto c7N8X;
       c7N8W: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7N8X: // global
           I64[Sp - 16] = block_c7N8P_info;
           _s7N51::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _s7N51::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7N9r; else goto c7N8Q;
       u7N9r: // global
           call _c7N8P(R1) args: 0, res: 0, upd: 0;
       c7N8Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7N8P() //  [R1]
         { info_tbl: [(c7N8P,
                       label: block_c7N8P_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N8P: // global
           I64[Sp] = block_c7N8V_info;
           _s7N55::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7N55::I64;
           if (R1 & 7 != 0) goto u7N9q; else goto c7N8Z;
       u7N9q: // global
           call _c7N8V(R1) args: 0, res: 0, upd: 0;
       c7N8Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7N8V() //  [R1]
         { info_tbl: [(c7N8V,
                       label: block_c7N8V_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N8V: // global
           _s7N58::I64 = I64[Sp + 8] * I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7N58::I64, 0)) goto c7N9k; else goto c7N9p;
       c7N9k: // global
           I64[Sp] = block_c7N9a_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp + 8] = _s7N58::I64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c7N9p: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7N9a() //  [R1]
         { info_tbl: [(c7N9a,
                       label: block_c7N9a_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N9a: // global
           I64[Sp] = block_c7N9c_info;
           _s7N5c::P64 = R1;
           R1 = I64[Sp + 8];
           P64[Sp + 8] = _s7N5c::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7N9c() //  [R1]
         { info_tbl: [(c7N9c,
                       label: block_c7N9c_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N9c: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7N9o; else goto c7N9n;
       c7N9o: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7N9n: // global
           I64[Hp - 40] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = R1 + 16;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.ForeignPtr.Imp.mallocForeignPtrArray_entry() //  [R2]
         { info_tbl: [(c7N9s,
                       label: Foreign.ForeignPtr.Imp.mallocForeignPtrArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N9s: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7N9w; else goto c7N9v;
       c7N9w: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.mallocForeignPtrArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7N9v: // global
           I64[Hp - 32] = lvl11_s7N51_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s7N5k_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.896108084 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_closure" {
     Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_closure:
         const Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c7N9D,
                       label: Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N9D: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7N9E; else goto c7N9F;
       c7N9E: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7N9F: // global
           I64[Sp - 16] = block_c7N9B_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_closure;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7N9B() //  [R1]
         { info_tbl: [(c7N9B,
                       label: block_c7N9B_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N9B: // global
           _s7N5q::I64 = (I64[Sp + 8] + 1) * I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7N5q::I64, 0)) goto c7Na2; else goto c7Na7;
       c7Na2: // global
           I64[Sp] = block_c7N9S_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp + 8] = _s7N5q::I64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c7Na7: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7N9S() //  [R1]
         { info_tbl: [(c7N9S,
                       label: block_c7N9S_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N9S: // global
           I64[Sp] = block_c7N9U_info;
           _s7N5v::P64 = R1;
           R1 = I64[Sp + 8];
           P64[Sp + 8] = _s7N5v::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7N9U() //  [R1]
         { info_tbl: [(c7N9U,
                       label: block_c7N9U_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7N9U: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7Na6; else goto c7Na5;
       c7Na6: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Na5: // global
           I64[Hp - 40] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = R1 + 16;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.898068894 UTC

[section ""data" . Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_closure" {
     Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_closure:
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_entry() //  [R2, R3]
         { info_tbl: [(c7Naf,
                       label: Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Naf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Nag; else goto c7Nah;
       c7Nag: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Nah: // global
           I64[Sp - 16] = block_c7Nac_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Nal; else goto c7Nad;
       u7Nal: // global
           call _c7Nac(R1) args: 0, res: 0, upd: 0;
       c7Nad: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Nac() //  [R1]
         { info_tbl: [(c7Nac,
                       label: block_c7Nac_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nac: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_entry(R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.899159017 UTC

[section ""data" . Foreign.ForeignPtr.Imp.mallocForeignPtrArray0_closure" {
     Foreign.ForeignPtr.Imp.mallocForeignPtrArray0_closure:
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray0_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.mallocForeignPtrArray0_entry() //  [R2, R3]
         { info_tbl: [(c7Naq,
                       label: Foreign.ForeignPtr.Imp.mallocForeignPtrArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Naq: // global
           R3 = R3;
           R2 = R2;
           call Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.899836659 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$trModule3_closure" {
     Foreign.ForeignPtr.Imp.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.ForeignPtr.Imp.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.900404748 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$trModule1_closure" {
     Foreign.ForeignPtr.Imp.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.ForeignPtr.Imp.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.90093876 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$trModule_closure" {
     Foreign.ForeignPtr.Imp.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.ForeignPtr.Imp.$trModule3_closure+1;
         const Foreign.ForeignPtr.Imp.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.90154039 UTC

[section ""relreadonly" . S7N5Z_srt" {
     S7N5Z_srt:
         const GHC.ForeignPtr.$winsertCFinalizer_closure;
         const Foreign.ForeignPtr.Imp.$wnewForeignPtr_closure;
         const Foreign.ForeignPtr.Imp.newForeignPtr1_closure;
         const Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_closure;
         const Foreign.ForeignPtr.Imp.newForeignPtrEnv1_closure;
         const GHC.Err.undefined_closure;
         const lvl10_r7N49_closure;
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_closure;
         const GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray_closure;
         const Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_closure;
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.902340208 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:02:53.903162297 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$wnewForeignPtr_closure" {
     Foreign.ForeignPtr.Imp.$wnewForeignPtr_closure:
         const Foreign.ForeignPtr.Imp.$wnewForeignPtr_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.$wnewForeignPtr_entry() //  [R2, R3]
         { info_tbl: [(c7NaD,
                       label: Foreign.ForeignPtr.Imp.$wnewForeignPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NaD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7NaE; else goto c7NaF;
       c7NaE: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.$wnewForeignPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7NaF: // global
           I64[Sp - 24] = block_c7Nax_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Nax() //  [R1]
         { info_tbl: [(c7Nax,
                       label: block_c7Nax_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nax: // global
           I64[Sp] = block_c7Naz_info;
           R6 = I64[Sp + 16];
           R5 = 0;
           R4 = 0;
           R3 = I64[Sp + 8];
           R2 = R1;
           P64[Sp - 8] = GHC.Tuple.()_closure+1;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.ForeignPtr.$winsertCFinalizer_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _c7Naz() //  [R1]
         { info_tbl: [(c7Naz,
                       label: block_c7Naz_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Naz: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7NaJ; else goto c7NaI;
       c7NaJ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7NaI: // global
           I64[Hp - 32] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.904644008 UTC

[section ""data" . Foreign.ForeignPtr.Imp.newForeignPtr1_closure" {
     Foreign.ForeignPtr.Imp.newForeignPtr1_closure:
         const Foreign.ForeignPtr.Imp.newForeignPtr1_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.newForeignPtr1_entry() //  [R2, R3]
         { info_tbl: [(c7NaR,
                       label: Foreign.ForeignPtr.Imp.newForeignPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NaR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7NaV; else goto c7NaW;
       c7NaV: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.newForeignPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7NaW: // global
           I64[Sp - 16] = block_c7NaO_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Nb4; else goto c7NaP;
       u7Nb4: // global
           call _c7NaO(R1) args: 0, res: 0, upd: 0;
       c7NaP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7NaO() //  [R1]
         { info_tbl: [(c7NaO,
                       label: block_c7NaO_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NaO: // global
           I64[Sp] = block_c7NaU_info;
           _s7N4q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7N4q::I64;
           if (R1 & 7 != 0) goto u7Nb3; else goto c7NaY;
       u7Nb3: // global
           call _c7NaU(R1) args: 0, res: 0, upd: 0;
       c7NaY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7NaU() //  [R1]
         { info_tbl: [(c7NaU,
                       label: block_c7NaU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NaU: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.ForeignPtr.Imp.$wnewForeignPtr_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.905910316 UTC

[section ""data" . Foreign.ForeignPtr.Imp.newForeignPtr_closure" {
     Foreign.ForeignPtr.Imp.newForeignPtr_closure:
         const Foreign.ForeignPtr.Imp.newForeignPtr_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.newForeignPtr_entry() //  [R2, R3]
         { info_tbl: [(c7Nb9,
                       label: Foreign.ForeignPtr.Imp.newForeignPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nb9: // global
           R3 = R3;
           R2 = R2;
           call Foreign.ForeignPtr.Imp.newForeignPtr1_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.907219671 UTC

[section ""data" . Foreign.ForeignPtr.Imp.withForeignPtr1_closure" {
     Foreign.ForeignPtr.Imp.withForeignPtr1_closure:
         const Foreign.ForeignPtr.Imp.withForeignPtr1_info;
 },
 sat_s7N4w_entry() //  [R1]
         { info_tbl: [(c7Nbk,
                       label: sat_s7N4w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nbk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Nbl; else goto c7Nbm;
       c7Nbl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Nbm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.ForeignPtr.unsafeForeignPtrToPtr_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.ForeignPtr.Imp.withForeignPtr1_entry() //  [R2, R3]
         { info_tbl: [(c7Nbs,
                       label: Foreign.ForeignPtr.Imp.withForeignPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nbs: // global
           _s7N4u::P64 = R3;
           _s7N4t::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c7Nbt; else goto c7Nbu;
       c7Nbu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Nbw; else goto c7Nbv;
       c7Nbw: // global
           HpAlloc = 24;
           goto c7Nbt;
       c7Nbt: // global
           R3 = _s7N4u::P64;
           R2 = _s7N4t::P64;
           R1 = Foreign.ForeignPtr.Imp.withForeignPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Nbv: // global
           I64[Hp - 16] = sat_s7N4w_info;
           P64[Hp] = _s7N4t::P64;
           I64[Sp - 16] = block_c7Nbn_info;
           R2 = Hp - 16;
           R1 = _s7N4u::P64;
           P64[Sp - 8] = _s7N4t::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Nbn() //  [R1]
         { info_tbl: [(c7Nbn,
                       label: block_c7Nbn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nbn: // global
           I64[Sp] = block_c7Nbp_info;
           _s7N4z::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7N4z::P64;
           if (R1 & 7 != 0) goto u7NbC; else goto c7Nbq;
       u7NbC: // global
           call _c7Nbp(R1) args: 0, res: 0, upd: 0;
       c7Nbq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Nbp() //  [R1]
         { info_tbl: [(c7Nbp,
                       label: block_c7Nbp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nbp: // global
           _s7N4z::P64 = P64[Sp + 8];
           call MO_Touch(P64[R1 + 7]);
           R1 = _s7N4z::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.908710626 UTC

[section ""data" . Foreign.ForeignPtr.Imp.withForeignPtr_closure" {
     Foreign.ForeignPtr.Imp.withForeignPtr_closure:
         const Foreign.ForeignPtr.Imp.withForeignPtr_info;
 },
 Foreign.ForeignPtr.Imp.withForeignPtr_entry() //  [R2, R3]
         { info_tbl: [(c7NbH,
                       label: Foreign.ForeignPtr.Imp.withForeignPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NbH: // global
           R3 = R3;
           R2 = R2;
           call Foreign.ForeignPtr.Imp.withForeignPtr1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.909757547 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_closure" {
     Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_closure:
         const Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_entry() //  [R2, R3, R4]
         { info_tbl: [(c7NbU,
                       label: Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NbU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7NbV; else goto c7NbW;
       c7NbV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7NbW: // global
           I64[Sp - 32] = block_c7NbO_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7NbO() //  [R1]
         { info_tbl: [(c7NbO,
                       label: block_c7NbO_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NbO: // global
           _s7N4E::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c7NbQ_info;
           R6 = I64[Sp + 24];
           R5 = I64[Sp + 16];
           R4 = 1;
           R3 = _s7N4E::I64;
           R2 = R1;
           P64[Sp] = GHC.Tuple.()_closure+1;
           P64[Sp + 16] = R1;
           call GHC.ForeignPtr.$winsertCFinalizer_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _c7NbQ() //  [R1]
         { info_tbl: [(c7NbQ,
                       label: block_c7NbQ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NbQ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7Nc0; else goto c7NbZ;
       c7Nc0: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7NbZ: // global
           I64[Hp - 32] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.911625145 UTC

[section ""data" . Foreign.ForeignPtr.Imp.newForeignPtrEnv1_closure" {
     Foreign.ForeignPtr.Imp.newForeignPtrEnv1_closure:
         const Foreign.ForeignPtr.Imp.newForeignPtrEnv1_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.newForeignPtrEnv1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Nc8,
                       label: Foreign.ForeignPtr.Imp.newForeignPtrEnv1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nc8: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Nch; else goto c7Nci;
       c7Nch: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.newForeignPtrEnv1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Nci: // global
           I64[Sp - 24] = block_c7Nc5_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7Ncr; else goto c7Nc6;
       u7Ncr: // global
           call _c7Nc5(R1) args: 0, res: 0, upd: 0;
       c7Nc6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Nc5() //  [R1]
         { info_tbl: [(c7Nc5,
                       label: block_c7Nc5_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nc5: // global
           I64[Sp] = block_c7Ncb_info;
           _s7N4V::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7N4V::I64;
           if (R1 & 7 != 0) goto u7Ncq; else goto c7Ncc;
       u7Ncq: // global
           call _c7Ncb(R1) args: 0, res: 0, upd: 0;
       c7Ncc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ncb() //  [R1]
         { info_tbl: [(c7Ncb,
                       label: block_c7Ncb_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ncb: // global
           I64[Sp] = block_c7Ncg_info;
           _s7N4X::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s7N4X::I64;
           if (R1 & 7 != 0) goto u7Ncs; else goto c7Ncl;
       u7Ncs: // global
           call _c7Ncg(R1) args: 0, res: 0, upd: 0;
       c7Ncl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ncg() //  [R1]
         { info_tbl: [(c7Ncg,
                       label: block_c7Ncg_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ncg: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.913071378 UTC

[section ""data" . Foreign.ForeignPtr.Imp.newForeignPtrEnv_closure" {
     Foreign.ForeignPtr.Imp.newForeignPtrEnv_closure:
         const Foreign.ForeignPtr.Imp.newForeignPtrEnv_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.newForeignPtrEnv_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Ncx,
                       label: Foreign.ForeignPtr.Imp.newForeignPtrEnv_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ncx: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.ForeignPtr.Imp.newForeignPtrEnv1_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.914017116 UTC

[section ""cstring" . lvl_r7N3Z_bytes" {
     lvl_r7N3Z_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.914727839 UTC

[section ""data" . lvl1_r7N40_closure" {
     lvl1_r7N40_closure:
         const lvl1_r7N40_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r7N40_entry() //  [R1]
         { info_tbl: [(c7NcG,
                       label: lvl1_r7N40_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NcG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7NcH; else goto c7NcI;
       c7NcH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7NcI: // global
           (_c7NcD::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7NcD::I64 == 0) goto c7NcF; else goto c7NcE;
       c7NcF: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7NcE: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7NcD::I64;
           R2 = lvl_r7N3Z_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.915790378 UTC

[section ""cstring" . Foreign.ForeignPtr.Imp.$trModule4_bytes" {
     Foreign.ForeignPtr.Imp.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.916458995 UTC

[section ""data" . lvl2_r7N41_closure" {
     lvl2_r7N41_closure:
         const lvl2_r7N41_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r7N41_entry() //  [R1]
         { info_tbl: [(c7NcP,
                       label: lvl2_r7N41_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NcP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7NcQ; else goto c7NcR;
       c7NcQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7NcR: // global
           (_c7NcM::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7NcM::I64 == 0) goto c7NcO; else goto c7NcN;
       c7NcO: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7NcN: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7NcM::I64;
           R2 = Foreign.ForeignPtr.Imp.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.917307177 UTC

[section ""cstring" . Foreign.ForeignPtr.Imp.$trModule2_bytes" {
     Foreign.ForeignPtr.Imp.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,70,111,114,101,105,103,110,80,116,114,46,73,109,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.917983012 UTC

[section ""data" . lvl3_r7N42_closure" {
     lvl3_r7N42_closure:
         const lvl3_r7N42_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r7N42_entry() //  [R1]
         { info_tbl: [(c7NcY,
                       label: lvl3_r7N42_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NcY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7NcZ; else goto c7Nd0;
       c7NcZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Nd0: // global
           (_c7NcV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7NcV::I64 == 0) goto c7NcX; else goto c7NcW;
       c7NcX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7NcW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7NcV::I64;
           R2 = Foreign.ForeignPtr.Imp.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.918787559 UTC

[section ""cstring" . lvl4_r7N43_bytes" {
     lvl4_r7N43_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,70,111,114,101,105,103,110,80,116,114,47,73,109,112,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.919716957 UTC

[section ""data" . lvl5_r7N44_closure" {
     lvl5_r7N44_closure:
         const lvl5_r7N44_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r7N44_entry() //  [R1]
         { info_tbl: [(c7Nd7,
                       label: lvl5_r7N44_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nd7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Nd8; else goto c7Nd9;
       c7Nd8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Nd9: // global
           (_c7Nd4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Nd4::I64 == 0) goto c7Nd6; else goto c7Nd5;
       c7Nd6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Nd5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Nd4::I64;
           R2 = lvl4_r7N43_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.920557135 UTC

[section ""data" . lvl6_r7N45_closure" {
     lvl6_r7N45_closure:
         const GHC.Types.I#_con_info;
         const 110;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.921077084 UTC

[section ""data" . lvl7_r7N46_closure" {
     lvl7_r7N46_closure:
         const GHC.Types.I#_con_info;
         const 35;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.921669518 UTC

[section ""data" . lvl8_r7N47_closure" {
     lvl8_r7N47_closure:
         const GHC.Types.I#_con_info;
         const 44;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.922229466 UTC

[section ""data" . lvl9_r7N48_closure" {
     lvl9_r7N48_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r7N41_closure;
         const lvl3_r7N42_closure;
         const lvl5_r7N44_closure;
         const lvl6_r7N45_closure+1;
         const lvl7_r7N46_closure+1;
         const lvl6_r7N45_closure+1;
         const lvl8_r7N47_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.922827642 UTC

[section ""data" . lvl10_r7N49_closure" {
     lvl10_r7N49_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r7N40_closure;
         const lvl9_r7N48_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.923811436 UTC

[section ""data" . Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_closure" {
     Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_closure:
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_entry() //  [R1]
         { info_tbl: [(c7Ndg,
                       label: Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ndg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Ndh; else goto c7Ndi;
       c7Ndh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Ndi: // global
           (_c7Ndd::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Ndd::I64 == 0) goto c7Ndf; else goto c7Nde;
       c7Ndf: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Nde: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Ndd::I64;
           R2 = lvl10_r7N49_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.925538079 UTC

[section ""data" . Foreign.ForeignPtr.Imp.mallocForeignPtrArray_closure" {
     Foreign.ForeignPtr.Imp.mallocForeignPtrArray_closure:
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray_info;
         const 0;
 },
 lvl11_s7N51_entry() //  [R1]
         { info_tbl: [(c7Ndr,
                       label: lvl11_s7N51_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ndr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Nds; else goto c7Ndt;
       c7Nds: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Ndt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7N5k_entry() //  [R1, R2]
         { info_tbl: [(c7NdC,
                       label: sat_s7N5k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NdC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7NdG; else goto c7NdH;
       c7NdG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7NdH: // global
           I64[Sp - 16] = block_c7Ndz_info;
           _s7N51::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _s7N51::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Neb; else goto c7NdA;
       u7Neb: // global
           call _c7Ndz(R1) args: 0, res: 0, upd: 0;
       c7NdA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ndz() //  [R1]
         { info_tbl: [(c7Ndz,
                       label: block_c7Ndz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ndz: // global
           I64[Sp] = block_c7NdF_info;
           _s7N55::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7N55::I64;
           if (R1 & 7 != 0) goto u7Nea; else goto c7NdJ;
       u7Nea: // global
           call _c7NdF(R1) args: 0, res: 0, upd: 0;
       c7NdJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7NdF() //  [R1]
         { info_tbl: [(c7NdF,
                       label: block_c7NdF_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NdF: // global
           _s7N58::I64 = I64[Sp + 8] * I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7N58::I64, 0)) goto c7Ne4; else goto c7Ne9;
       c7Ne4: // global
           I64[Sp] = block_c7NdU_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp + 8] = _s7N58::I64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c7Ne9: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7NdU() //  [R1]
         { info_tbl: [(c7NdU,
                       label: block_c7NdU_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NdU: // global
           I64[Sp] = block_c7NdW_info;
           _s7N5c::P64 = R1;
           R1 = I64[Sp + 8];
           P64[Sp + 8] = _s7N5c::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7NdW() //  [R1]
         { info_tbl: [(c7NdW,
                       label: block_c7NdW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NdW: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7Ne8; else goto c7Ne7;
       c7Ne8: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Ne7: // global
           I64[Hp - 40] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = R1 + 16;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.ForeignPtr.Imp.mallocForeignPtrArray_entry() //  [R2]
         { info_tbl: [(c7Nec,
                       label: Foreign.ForeignPtr.Imp.mallocForeignPtrArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nec: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7Neg; else goto c7Nef;
       c7Neg: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.mallocForeignPtrArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Nef: // global
           I64[Hp - 32] = lvl11_s7N51_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s7N5k_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.928334084 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_closure" {
     Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_closure:
         const Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c7Nen,
                       label: Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nen: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Neo; else goto c7Nep;
       c7Neo: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Nep: // global
           I64[Sp - 16] = block_c7Nel_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_closure;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7Nel() //  [R1]
         { info_tbl: [(c7Nel,
                       label: block_c7Nel_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nel: // global
           _s7N5q::I64 = (I64[Sp + 8] + 1) * I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7N5q::I64, 0)) goto c7NeM; else goto c7NeR;
       c7NeM: // global
           I64[Sp] = block_c7NeC_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp + 8] = _s7N5q::I64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c7NeR: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7NeC() //  [R1]
         { info_tbl: [(c7NeC,
                       label: block_c7NeC_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NeC: // global
           I64[Sp] = block_c7NeE_info;
           _s7N5v::P64 = R1;
           R1 = I64[Sp + 8];
           P64[Sp + 8] = _s7N5v::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7NeE() //  [R1]
         { info_tbl: [(c7NeE,
                       label: block_c7NeE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NeE: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7NeQ; else goto c7NeP;
       c7NeQ: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7NeP: // global
           I64[Hp - 40] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = R1 + 16;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.930655084 UTC

[section ""data" . Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_closure" {
     Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_closure:
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_entry() //  [R2, R3]
         { info_tbl: [(c7NeZ,
                       label: Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NeZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Nf0; else goto c7Nf1;
       c7Nf0: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Nf1: // global
           I64[Sp - 16] = block_c7NeW_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Nf5; else goto c7NeX;
       u7Nf5: // global
           call _c7NeW(R1) args: 0, res: 0, upd: 0;
       c7NeX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7NeW() //  [R1]
         { info_tbl: [(c7NeW,
                       label: block_c7NeW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NeW: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_entry(R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.931768596 UTC

[section ""data" . Foreign.ForeignPtr.Imp.mallocForeignPtrArray0_closure" {
     Foreign.ForeignPtr.Imp.mallocForeignPtrArray0_closure:
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray0_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.mallocForeignPtrArray0_entry() //  [R2, R3]
         { info_tbl: [(c7Nfa,
                       label: Foreign.ForeignPtr.Imp.mallocForeignPtrArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nfa: // global
           R3 = R3;
           R2 = R2;
           call Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.93249043 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$trModule3_closure" {
     Foreign.ForeignPtr.Imp.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.ForeignPtr.Imp.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.933293272 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$trModule1_closure" {
     Foreign.ForeignPtr.Imp.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.ForeignPtr.Imp.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.933801893 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$trModule_closure" {
     Foreign.ForeignPtr.Imp.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.ForeignPtr.Imp.$trModule3_closure+1;
         const Foreign.ForeignPtr.Imp.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.934355545 UTC

[section ""relreadonly" . S7N5Z_srt" {
     S7N5Z_srt:
         const GHC.ForeignPtr.$winsertCFinalizer_closure;
         const Foreign.ForeignPtr.Imp.$wnewForeignPtr_closure;
         const Foreign.ForeignPtr.Imp.newForeignPtr1_closure;
         const Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_closure;
         const Foreign.ForeignPtr.Imp.newForeignPtrEnv1_closure;
         const GHC.Err.undefined_closure;
         const lvl10_r7N49_closure;
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_closure;
         const GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray_closure;
         const Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_closure;
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.935171371 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:02:53.93660195 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$wnewForeignPtr_closure" {
     Foreign.ForeignPtr.Imp.$wnewForeignPtr_closure:
         const Foreign.ForeignPtr.Imp.$wnewForeignPtr_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.$wnewForeignPtr_entry() //  [R2, R3]
         { info_tbl: [(c7Nfn,
                       label: Foreign.ForeignPtr.Imp.$wnewForeignPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nfn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Nfo; else goto c7Nfp;
       c7Nfo: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.$wnewForeignPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Nfp: // global
           I64[Sp - 24] = block_c7Nfh_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Nfh() //  [R1]
         { info_tbl: [(c7Nfh,
                       label: block_c7Nfh_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nfh: // global
           I64[Sp] = block_c7Nfj_info;
           R6 = I64[Sp + 16];
           R5 = 0;
           R4 = 0;
           R3 = I64[Sp + 8];
           R2 = R1;
           P64[Sp - 8] = GHC.Tuple.()_closure+1;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.ForeignPtr.$winsertCFinalizer_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _c7Nfj() //  [R1]
         { info_tbl: [(c7Nfj,
                       label: block_c7Nfj_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nfj: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7Nft; else goto c7Nfs;
       c7Nft: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Nfs: // global
           I64[Hp - 32] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.944663237 UTC

[section ""data" . Foreign.ForeignPtr.Imp.newForeignPtr1_closure" {
     Foreign.ForeignPtr.Imp.newForeignPtr1_closure:
         const Foreign.ForeignPtr.Imp.newForeignPtr1_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.newForeignPtr1_entry() //  [R2, R3]
         { info_tbl: [(c7NfQ,
                       label: Foreign.ForeignPtr.Imp.newForeignPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NfQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7NfU; else goto c7NfV;
       c7NfU: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.newForeignPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7NfV: // global
           I64[Sp - 16] = block_c7NfN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Ng3; else goto c7NfO;
       u7Ng3: // global
           call _c7NfN(R1) args: 0, res: 0, upd: 0;
       c7NfO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7NfN() //  [R1]
         { info_tbl: [(c7NfN,
                       label: block_c7NfN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NfN: // global
           I64[Sp] = block_c7NfT_info;
           _s7N4q::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7N4q::I64;
           if (R1 & 7 != 0) goto u7Ng2; else goto c7NfX;
       u7Ng2: // global
           call _c7NfT(R1) args: 0, res: 0, upd: 0;
       c7NfX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7NfT() //  [R1]
         { info_tbl: [(c7NfT,
                       label: block_c7NfT_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NfT: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.ForeignPtr.Imp.$wnewForeignPtr_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.9515534 UTC

[section ""data" . Foreign.ForeignPtr.Imp.newForeignPtr_closure" {
     Foreign.ForeignPtr.Imp.newForeignPtr_closure:
         const Foreign.ForeignPtr.Imp.newForeignPtr_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.newForeignPtr_entry() //  [R2, R3]
         { info_tbl: [(c7Ngl,
                       label: Foreign.ForeignPtr.Imp.newForeignPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ngl: // global
           R3 = R3;
           R2 = R2;
           call Foreign.ForeignPtr.Imp.newForeignPtr1_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.9551279 UTC

[section ""data" . Foreign.ForeignPtr.Imp.withForeignPtr1_closure" {
     Foreign.ForeignPtr.Imp.withForeignPtr1_closure:
         const Foreign.ForeignPtr.Imp.withForeignPtr1_info;
 },
 sat_s7N4w_entry() //  [R1]
         { info_tbl: [(c7NgA,
                       label: sat_s7N4w_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NgA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7NgB; else goto c7NgC;
       c7NgB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7NgC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.ForeignPtr.unsafeForeignPtrToPtr_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.ForeignPtr.Imp.withForeignPtr1_entry() //  [R2, R3]
         { info_tbl: [(c7NgI,
                       label: Foreign.ForeignPtr.Imp.withForeignPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NgI: // global
           _s7N4u::P64 = R3;
           _s7N4t::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c7NgJ; else goto c7NgK;
       c7NgK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7NgM; else goto c7NgL;
       c7NgM: // global
           HpAlloc = 24;
           goto c7NgJ;
       c7NgJ: // global
           R3 = _s7N4u::P64;
           R2 = _s7N4t::P64;
           R1 = Foreign.ForeignPtr.Imp.withForeignPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7NgL: // global
           I64[Hp - 16] = sat_s7N4w_info;
           P64[Hp] = _s7N4t::P64;
           I64[Sp - 16] = block_c7NgD_info;
           R2 = Hp - 16;
           R1 = _s7N4u::P64;
           P64[Sp - 8] = _s7N4t::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7NgD() //  [R1]
         { info_tbl: [(c7NgD,
                       label: block_c7NgD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NgD: // global
           I64[Sp] = block_c7NgF_info;
           _s7N4z::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7N4z::P64;
           if (R1 & 7 != 0) goto u7NgS; else goto c7NgG;
       u7NgS: // global
           call _c7NgF(R1) args: 0, res: 0, upd: 0;
       c7NgG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7NgF() //  [R1]
         { info_tbl: [(c7NgF,
                       label: block_c7NgF_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NgF: // global
           _s7N4z::P64 = P64[Sp + 8];
           call MO_Touch(P64[R1 + 7]);
           R1 = _s7N4z::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.964007467 UTC

[section ""data" . Foreign.ForeignPtr.Imp.withForeignPtr_closure" {
     Foreign.ForeignPtr.Imp.withForeignPtr_closure:
         const Foreign.ForeignPtr.Imp.withForeignPtr_info;
 },
 Foreign.ForeignPtr.Imp.withForeignPtr_entry() //  [R2, R3]
         { info_tbl: [(c7Nhe,
                       label: Foreign.ForeignPtr.Imp.withForeignPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nhe: // global
           R3 = R3;
           R2 = R2;
           call Foreign.ForeignPtr.Imp.withForeignPtr1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.967540297 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_closure" {
     Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_closure:
         const Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Nhv,
                       label: Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nhv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Nhw; else goto c7Nhx;
       c7Nhw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Nhx: // global
           I64[Sp - 32] = block_c7Nhp_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Nhp() //  [R1]
         { info_tbl: [(c7Nhp,
                       label: block_c7Nhp_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nhp: // global
           _s7N4E::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c7Nhr_info;
           R6 = I64[Sp + 24];
           R5 = I64[Sp + 16];
           R4 = 1;
           R3 = _s7N4E::I64;
           R2 = R1;
           P64[Sp] = GHC.Tuple.()_closure+1;
           P64[Sp + 16] = R1;
           call GHC.ForeignPtr.$winsertCFinalizer_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _c7Nhr() //  [R1]
         { info_tbl: [(c7Nhr,
                       label: block_c7Nhr_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nhr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7NhB; else goto c7NhA;
       c7NhB: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7NhA: // global
           I64[Hp - 32] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.976310159 UTC

[section ""data" . Foreign.ForeignPtr.Imp.newForeignPtrEnv1_closure" {
     Foreign.ForeignPtr.Imp.newForeignPtrEnv1_closure:
         const Foreign.ForeignPtr.Imp.newForeignPtrEnv1_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.newForeignPtrEnv1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7NhY,
                       label: Foreign.ForeignPtr.Imp.newForeignPtrEnv1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NhY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Ni7; else goto c7Ni8;
       c7Ni7: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.newForeignPtrEnv1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Ni8: // global
           I64[Sp - 24] = block_c7NhV_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7Nih; else goto c7NhW;
       u7Nih: // global
           call _c7NhV(R1) args: 0, res: 0, upd: 0;
       c7NhW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7NhV() //  [R1]
         { info_tbl: [(c7NhV,
                       label: block_c7NhV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NhV: // global
           I64[Sp] = block_c7Ni1_info;
           _s7N4V::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7N4V::I64;
           if (R1 & 7 != 0) goto u7Nig; else goto c7Ni2;
       u7Nig: // global
           call _c7Ni1(R1) args: 0, res: 0, upd: 0;
       c7Ni2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ni1() //  [R1]
         { info_tbl: [(c7Ni1,
                       label: block_c7Ni1_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ni1: // global
           I64[Sp] = block_c7Ni6_info;
           _s7N4X::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s7N4X::I64;
           if (R1 & 7 != 0) goto u7Nii; else goto c7Nib;
       u7Nii: // global
           call _c7Ni6(R1) args: 0, res: 0, upd: 0;
       c7Nib: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ni6() //  [R1]
         { info_tbl: [(c7Ni6,
                       label: block_c7Ni6_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ni6: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.986214267 UTC

[section ""data" . Foreign.ForeignPtr.Imp.newForeignPtrEnv_closure" {
     Foreign.ForeignPtr.Imp.newForeignPtrEnv_closure:
         const Foreign.ForeignPtr.Imp.newForeignPtrEnv_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.newForeignPtrEnv_entry() //  [R2, R3, R4]
         { info_tbl: [(c7NiE,
                       label: Foreign.ForeignPtr.Imp.newForeignPtrEnv_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NiE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.ForeignPtr.Imp.newForeignPtrEnv1_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.98949366 UTC

[section ""cstring" . lvl_r7N3Z_bytes" {
     lvl_r7N3Z_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.991265078 UTC

[section ""data" . lvl1_r7N40_closure" {
     lvl1_r7N40_closure:
         const lvl1_r7N40_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r7N40_entry() //  [R1]
         { info_tbl: [(c7NiS,
                       label: lvl1_r7N40_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NiS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7NiT; else goto c7NiU;
       c7NiT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7NiU: // global
           (_c7NiP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7NiP::I64 == 0) goto c7NiR; else goto c7NiQ;
       c7NiR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7NiQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7NiP::I64;
           R2 = lvl_r7N3Z_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.995174252 UTC

[section ""cstring" . Foreign.ForeignPtr.Imp.$trModule4_bytes" {
     Foreign.ForeignPtr.Imp.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:53.997110004 UTC

[section ""data" . lvl2_r7N41_closure" {
     lvl2_r7N41_closure:
         const lvl2_r7N41_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r7N41_entry() //  [R1]
         { info_tbl: [(c7Nj9,
                       label: lvl2_r7N41_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nj9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Nja; else goto c7Njb;
       c7Nja: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Njb: // global
           (_c7Nj6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Nj6::I64 == 0) goto c7Nj8; else goto c7Nj7;
       c7Nj8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Nj7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Nj6::I64;
           R2 = Foreign.ForeignPtr.Imp.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.000871826 UTC

[section ""cstring" . Foreign.ForeignPtr.Imp.$trModule2_bytes" {
     Foreign.ForeignPtr.Imp.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,70,111,114,101,105,103,110,80,116,114,46,73,109,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.002600801 UTC

[section ""data" . lvl3_r7N42_closure" {
     lvl3_r7N42_closure:
         const lvl3_r7N42_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r7N42_entry() //  [R1]
         { info_tbl: [(c7Njq,
                       label: lvl3_r7N42_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Njq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Njr; else goto c7Njs;
       c7Njr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Njs: // global
           (_c7Njn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Njn::I64 == 0) goto c7Njp; else goto c7Njo;
       c7Njp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Njo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Njn::I64;
           R2 = Foreign.ForeignPtr.Imp.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.006720856 UTC

[section ""cstring" . lvl4_r7N43_bytes" {
     lvl4_r7N43_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,70,111,114,101,105,103,110,80,116,114,47,73,109,112,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.008496658 UTC

[section ""data" . lvl5_r7N44_closure" {
     lvl5_r7N44_closure:
         const lvl5_r7N44_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r7N44_entry() //  [R1]
         { info_tbl: [(c7NjH,
                       label: lvl5_r7N44_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NjH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7NjI; else goto c7NjJ;
       c7NjI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7NjJ: // global
           (_c7NjE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7NjE::I64 == 0) goto c7NjG; else goto c7NjF;
       c7NjG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7NjF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7NjE::I64;
           R2 = lvl4_r7N43_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.01236077 UTC

[section ""data" . lvl6_r7N45_closure" {
     lvl6_r7N45_closure:
         const GHC.Types.I#_con_info;
         const 110;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.014262358 UTC

[section ""data" . lvl7_r7N46_closure" {
     lvl7_r7N46_closure:
         const GHC.Types.I#_con_info;
         const 35;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.015835705 UTC

[section ""data" . lvl8_r7N47_closure" {
     lvl8_r7N47_closure:
         const GHC.Types.I#_con_info;
         const 44;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.017600503 UTC

[section ""data" . lvl9_r7N48_closure" {
     lvl9_r7N48_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r7N41_closure;
         const lvl3_r7N42_closure;
         const lvl5_r7N44_closure;
         const lvl6_r7N45_closure+1;
         const lvl7_r7N46_closure+1;
         const lvl6_r7N45_closure+1;
         const lvl8_r7N47_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.019318438 UTC

[section ""data" . lvl10_r7N49_closure" {
     lvl10_r7N49_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r7N40_closure;
         const lvl9_r7N48_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.02141944 UTC

[section ""data" . Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_closure" {
     Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_closure:
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_entry() //  [R1]
         { info_tbl: [(c7Nk2,
                       label: Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nk2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Nk3; else goto c7Nk4;
       c7Nk3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Nk4: // global
           (_c7NjZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7NjZ::I64 == 0) goto c7Nk1; else goto c7Nk0;
       c7Nk1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Nk0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7NjZ::I64;
           R2 = lvl10_r7N49_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.027213556 UTC

[section ""data" . Foreign.ForeignPtr.Imp.mallocForeignPtrArray_closure" {
     Foreign.ForeignPtr.Imp.mallocForeignPtrArray_closure:
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray_info;
         const 0;
 },
 lvl11_s7N51_entry() //  [R1]
         { info_tbl: [(c7Nkk,
                       label: lvl11_s7N51_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nkk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Nkl; else goto c7Nkm;
       c7Nkl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Nkm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7N5k_entry() //  [R1, R2]
         { info_tbl: [(c7Nkv,
                       label: sat_s7N5k_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nkv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Nkz; else goto c7NkA;
       c7Nkz: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7NkA: // global
           I64[Sp - 16] = block_c7Nks_info;
           _s7N51::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _s7N51::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Nl4; else goto c7Nkt;
       u7Nl4: // global
           call _c7Nks(R1) args: 0, res: 0, upd: 0;
       c7Nkt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Nks() //  [R1]
         { info_tbl: [(c7Nks,
                       label: block_c7Nks_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nks: // global
           I64[Sp] = block_c7Nky_info;
           _s7N55::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7N55::I64;
           if (R1 & 7 != 0) goto u7Nl3; else goto c7NkC;
       u7Nl3: // global
           call _c7Nky(R1) args: 0, res: 0, upd: 0;
       c7NkC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Nky() //  [R1]
         { info_tbl: [(c7Nky,
                       label: block_c7Nky_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nky: // global
           _s7N58::I64 = I64[Sp + 8] * I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7N58::I64, 0)) goto c7NkX; else goto c7Nl2;
       c7NkX: // global
           I64[Sp] = block_c7NkN_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp + 8] = _s7N58::I64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c7Nl2: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7NkN() //  [R1]
         { info_tbl: [(c7NkN,
                       label: block_c7NkN_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NkN: // global
           I64[Sp] = block_c7NkP_info;
           _s7N5c::P64 = R1;
           R1 = I64[Sp + 8];
           P64[Sp + 8] = _s7N5c::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7NkP() //  [R1]
         { info_tbl: [(c7NkP,
                       label: block_c7NkP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NkP: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7Nl1; else goto c7Nl0;
       c7Nl1: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Nl0: // global
           I64[Hp - 40] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = R1 + 16;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.ForeignPtr.Imp.mallocForeignPtrArray_entry() //  [R2]
         { info_tbl: [(c7Nl5,
                       label: Foreign.ForeignPtr.Imp.mallocForeignPtrArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nl5: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7Nl9; else goto c7Nl8;
       c7Nl9: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.mallocForeignPtrArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Nl8: // global
           I64[Hp - 32] = lvl11_s7N51_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s7N5k_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.042723432 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_closure" {
     Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_closure:
         const Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c7NlO,
                       label: Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NlO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7NlP; else goto c7NlQ;
       c7NlP: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7NlQ: // global
           I64[Sp - 16] = block_c7NlM_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_closure;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7NlM() //  [R1]
         { info_tbl: [(c7NlM,
                       label: block_c7NlM_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NlM: // global
           _s7N5q::I64 = (I64[Sp + 8] + 1) * I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7N5q::I64, 0)) goto c7Nmd; else goto c7Nmi;
       c7Nmd: // global
           I64[Sp] = block_c7Nm3_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp + 8] = _s7N5q::I64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c7Nmi: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Nm3() //  [R1]
         { info_tbl: [(c7Nm3,
                       label: block_c7Nm3_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nm3: // global
           I64[Sp] = block_c7Nm5_info;
           _s7N5v::P64 = R1;
           R1 = I64[Sp + 8];
           P64[Sp + 8] = _s7N5v::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Nm5() //  [R1]
         { info_tbl: [(c7Nm5,
                       label: block_c7Nm5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nm5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7Nmh; else goto c7Nmg;
       c7Nmh: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Nmg: // global
           I64[Hp - 40] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = R1 + 16;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.052875129 UTC

[section ""data" . Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_closure" {
     Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_closure:
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_entry() //  [R2, R3]
         { info_tbl: [(c7NmL,
                       label: Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NmL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7NmM; else goto c7NmN;
       c7NmM: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7NmN: // global
           I64[Sp - 16] = block_c7NmI_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7NmR; else goto c7NmJ;
       u7NmR: // global
           call _c7NmI(R1) args: 0, res: 0, upd: 0;
       c7NmJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7NmI() //  [R1]
         { info_tbl: [(c7NmI,
                       label: block_c7NmI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NmI: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_entry(R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.058603581 UTC

[section ""data" . Foreign.ForeignPtr.Imp.mallocForeignPtrArray0_closure" {
     Foreign.ForeignPtr.Imp.mallocForeignPtrArray0_closure:
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray0_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.mallocForeignPtrArray0_entry() //  [R2, R3]
         { info_tbl: [(c7Nn5,
                       label: Foreign.ForeignPtr.Imp.mallocForeignPtrArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nn5: // global
           R3 = R3;
           R2 = R2;
           call Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.062113924 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$trModule3_closure" {
     Foreign.ForeignPtr.Imp.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.ForeignPtr.Imp.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.063706842 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$trModule1_closure" {
     Foreign.ForeignPtr.Imp.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.ForeignPtr.Imp.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.065604675 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$trModule_closure" {
     Foreign.ForeignPtr.Imp.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.ForeignPtr.Imp.$trModule3_closure+1;
         const Foreign.ForeignPtr.Imp.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.067288131 UTC

[section ""relreadonly" . S7N5Z_srt" {
     S7N5Z_srt:
         const GHC.ForeignPtr.$winsertCFinalizer_closure;
         const Foreign.ForeignPtr.Imp.$wnewForeignPtr_closure;
         const Foreign.ForeignPtr.Imp.newForeignPtr1_closure;
         const Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_closure;
         const Foreign.ForeignPtr.Imp.newForeignPtrEnv1_closure;
         const GHC.Err.undefined_closure;
         const lvl10_r7N49_closure;
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_closure;
         const GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray_closure;
         const Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_closure;
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.571181437 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:02:54.572769587 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$wnewForeignPtr_closure" {
     Foreign.ForeignPtr.Imp.$wnewForeignPtr_closure:
         const Foreign.ForeignPtr.Imp.$wnewForeignPtr_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.$wnewForeignPtr_entry() //  [R2, R3]
         { info_tbl: [(c7NoX,
                       label: Foreign.ForeignPtr.Imp.$wnewForeignPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NoX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7NoY; else goto c7NoZ;
       c7NoY: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.$wnewForeignPtr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7NoZ: // global
           I64[Sp - 24] = block_c7NoR_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7NoR() //  [R1]
         { info_tbl: [(c7NoR,
                       label: block_c7NoR_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NoR: // global
           I64[Sp] = block_c7NoT_info;
           R6 = I64[Sp + 16];
           R5 = 0;
           R4 = 0;
           R3 = I64[Sp + 8];
           R2 = R1;
           P64[Sp - 8] = GHC.Tuple.()_closure+1;
           P64[Sp + 8] = R1;
           Sp = Sp - 8;
           call GHC.ForeignPtr.$winsertCFinalizer_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _c7NoT() //  [R1]
         { info_tbl: [(c7NoT,
                       label: block_c7NoT_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NoT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7Np3; else goto c7Np2;
       c7Np3: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Np2: // global
           I64[Hp - 32] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.580957643 UTC

[section ""data" . Foreign.ForeignPtr.Imp.newForeignPtr1_closure" {
     Foreign.ForeignPtr.Imp.newForeignPtr1_closure:
         const Foreign.ForeignPtr.Imp.newForeignPtr1_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.newForeignPtr1_entry() //  [R2, R3]
         { info_tbl: [(c7Npy,
                       label: Foreign.ForeignPtr.Imp.newForeignPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Npy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7NpC; else goto c7NpD;
       c7NpC: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.newForeignPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7NpD: // global
           I64[Sp - 16] = block_c7Npv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7NpL; else goto c7Npw;
       u7NpL: // global
           call _c7Npv(R1) args: 0, res: 0, upd: 0;
       c7Npw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Npv() //  [R1]
         { info_tbl: [(c7Npv,
                       label: block_c7Npv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Npv: // global
           I64[Sp] = block_c7NpB_info;
           _s7Nnv::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7Nnv::I64;
           if (R1 & 7 != 0) goto u7NpK; else goto c7NpF;
       u7NpK: // global
           call _c7NpB(R1) args: 0, res: 0, upd: 0;
       c7NpF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7NpB() //  [R1]
         { info_tbl: [(c7NpB,
                       label: block_c7NpB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NpB: // global
           R3 = I64[R1 + 7];
           R2 = I64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.ForeignPtr.Imp.$wnewForeignPtr_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.588482511 UTC

[section ""data" . Foreign.ForeignPtr.Imp.newForeignPtr_closure" {
     Foreign.ForeignPtr.Imp.newForeignPtr_closure:
         const Foreign.ForeignPtr.Imp.newForeignPtr_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.newForeignPtr_entry() //  [R2, R3]
         { info_tbl: [(c7Nq5,
                       label: Foreign.ForeignPtr.Imp.newForeignPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nq5: // global
           R3 = R3;
           R2 = R2;
           call Foreign.ForeignPtr.Imp.newForeignPtr1_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.592383389 UTC

[section ""data" . Foreign.ForeignPtr.Imp.withForeignPtr1_closure" {
     Foreign.ForeignPtr.Imp.withForeignPtr1_closure:
         const Foreign.ForeignPtr.Imp.withForeignPtr1_info;
 },
 sat_s7NnB_entry() //  [R1]
         { info_tbl: [(c7Nqk,
                       label: sat_s7NnB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nqk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Nql; else goto c7Nqm;
       c7Nql: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Nqm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.ForeignPtr.unsafeForeignPtrToPtr_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 Foreign.ForeignPtr.Imp.withForeignPtr1_entry() //  [R2, R3]
         { info_tbl: [(c7Nqs,
                       label: Foreign.ForeignPtr.Imp.withForeignPtr1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nqs: // global
           _s7Nnz::P64 = R3;
           _s7Nny::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto c7Nqt; else goto c7Nqu;
       c7Nqu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c7Nqw; else goto c7Nqv;
       c7Nqw: // global
           HpAlloc = 24;
           goto c7Nqt;
       c7Nqt: // global
           R3 = _s7Nnz::P64;
           R2 = _s7Nny::P64;
           R1 = Foreign.ForeignPtr.Imp.withForeignPtr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Nqv: // global
           I64[Hp - 16] = sat_s7NnB_info;
           P64[Hp] = _s7Nny::P64;
           I64[Sp - 16] = block_c7Nqn_info;
           R2 = Hp - 16;
           R1 = _s7Nnz::P64;
           P64[Sp - 8] = _s7Nny::P64;
           Sp = Sp - 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Nqn() //  [R1]
         { info_tbl: [(c7Nqn,
                       label: block_c7Nqn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nqn: // global
           I64[Sp] = block_c7Nqp_info;
           _s7NnE::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7NnE::P64;
           if (R1 & 7 != 0) goto u7NqC; else goto c7Nqq;
       u7NqC: // global
           call _c7Nqp(R1) args: 0, res: 0, upd: 0;
       c7Nqq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Nqp() //  [R1]
         { info_tbl: [(c7Nqp,
                       label: block_c7Nqp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nqp: // global
           _s7NnE::P64 = P64[Sp + 8];
           call MO_Touch(P64[R1 + 7]);
           R1 = _s7NnE::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.601957826 UTC

[section ""data" . Foreign.ForeignPtr.Imp.withForeignPtr_closure" {
     Foreign.ForeignPtr.Imp.withForeignPtr_closure:
         const Foreign.ForeignPtr.Imp.withForeignPtr_info;
 },
 Foreign.ForeignPtr.Imp.withForeignPtr_entry() //  [R2, R3]
         { info_tbl: [(c7Nr2,
                       label: Foreign.ForeignPtr.Imp.withForeignPtr_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nr2: // global
           R3 = R3;
           R2 = R2;
           call Foreign.ForeignPtr.Imp.withForeignPtr1_entry(R3,
                                                             R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.60651485 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_closure" {
     Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_closure:
         const Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_entry() //  [R2, R3, R4]
         { info_tbl: [(c7Nrj,
                       label: Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 16} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nrj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Nrk; else goto c7Nrl;
       c7Nrk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Nrl: // global
           I64[Sp - 32] = block_c7Nrd_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp - 24] = R2;
           I64[Sp - 16] = R3;
           I64[Sp - 8] = R4;
           Sp = Sp - 32;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Nrd() //  [R1]
         { info_tbl: [(c7Nrd,
                       label: block_c7Nrd_info
                       rep:StackRep [True, True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nrd: // global
           _s7NnJ::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_c7Nrf_info;
           R6 = I64[Sp + 24];
           R5 = I64[Sp + 16];
           R4 = 1;
           R3 = _s7NnJ::I64;
           R2 = R1;
           P64[Sp] = GHC.Tuple.()_closure+1;
           P64[Sp + 16] = R1;
           call GHC.ForeignPtr.$winsertCFinalizer_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 8, upd: 8;
     }
 },
 _c7Nrf() //  [R1]
         { info_tbl: [(c7Nrf,
                       label: block_c7Nrf_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nrf: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7Nrp; else goto c7Nro;
       c7Nrp: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Nro: // global
           I64[Hp - 32] = GHC.ForeignPtr.PlainForeignPtr_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 31;
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.614925601 UTC

[section ""data" . Foreign.ForeignPtr.Imp.newForeignPtrEnv1_closure" {
     Foreign.ForeignPtr.Imp.newForeignPtrEnv1_closure:
         const Foreign.ForeignPtr.Imp.newForeignPtrEnv1_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.newForeignPtrEnv1_entry() //  [R2, R3, R4]
         { info_tbl: [(c7NrT,
                       label: Foreign.ForeignPtr.Imp.newForeignPtrEnv1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NrT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c7Ns2; else goto c7Ns3;
       c7Ns2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.newForeignPtrEnv1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Ns3: // global
           I64[Sp - 24] = block_c7NrQ_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto u7Nsc; else goto c7NrR;
       u7Nsc: // global
           call _c7NrQ(R1) args: 0, res: 0, upd: 0;
       c7NrR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7NrQ() //  [R1]
         { info_tbl: [(c7NrQ,
                       label: block_c7NrQ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NrQ: // global
           I64[Sp] = block_c7NrW_info;
           _s7No0::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7No0::I64;
           if (R1 & 7 != 0) goto u7Nsb; else goto c7NrX;
       u7Nsb: // global
           call _c7NrW(R1) args: 0, res: 0, upd: 0;
       c7NrX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7NrW() //  [R1]
         { info_tbl: [(c7NrW,
                       label: block_c7NrW_info
                       rep:StackRep [True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NrW: // global
           I64[Sp] = block_c7Ns1_info;
           _s7No2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _s7No2::I64;
           if (R1 & 7 != 0) goto u7Nsd; else goto c7Ns6;
       u7Nsd: // global
           call _c7Ns1(R1) args: 0, res: 0, upd: 0;
       c7Ns6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Ns1() //  [R1]
         { info_tbl: [(c7Ns1,
                       label: block_c7Ns1_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ns1: // global
           R4 = I64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_entry(R4,
                                                                R3,
                                                                R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.625161817 UTC

[section ""data" . Foreign.ForeignPtr.Imp.newForeignPtrEnv_closure" {
     Foreign.ForeignPtr.Imp.newForeignPtrEnv_closure:
         const Foreign.ForeignPtr.Imp.newForeignPtrEnv_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.newForeignPtrEnv_entry() //  [R2, R3, R4]
         { info_tbl: [(c7NsC,
                       label: Foreign.ForeignPtr.Imp.newForeignPtrEnv_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NsC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Foreign.ForeignPtr.Imp.newForeignPtrEnv1_entry(R4,
                                                               R3,
                                                               R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.62878028 UTC

[section ""cstring" . lvl_r7N3Z_bytes" {
     lvl_r7N3Z_bytes:
         I8[] [117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.63095239 UTC

[section ""data" . lvl1_r7N40_closure" {
     lvl1_r7N40_closure:
         const lvl1_r7N40_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r7N40_entry() //  [R1]
         { info_tbl: [(c7NsQ,
                       label: lvl1_r7N40_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NsQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7NsR; else goto c7NsS;
       c7NsR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7NsS: // global
           (_c7NsN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7NsN::I64 == 0) goto c7NsP; else goto c7NsO;
       c7NsP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7NsO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7NsN::I64;
           R2 = lvl_r7N3Z_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.635356777 UTC

[section ""cstring" . Foreign.ForeignPtr.Imp.$trModule4_bytes" {
     Foreign.ForeignPtr.Imp.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.637473221 UTC

[section ""data" . lvl2_r7N41_closure" {
     lvl2_r7N41_closure:
         const lvl2_r7N41_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_r7N41_entry() //  [R1]
         { info_tbl: [(c7Nt8,
                       label: lvl2_r7N41_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nt8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Nt9; else goto c7Nta;
       c7Nt9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Nta: // global
           (_c7Nt5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Nt5::I64 == 0) goto c7Nt7; else goto c7Nt6;
       c7Nt7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Nt6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Nt5::I64;
           R2 = Foreign.ForeignPtr.Imp.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.641954896 UTC

[section ""cstring" . Foreign.ForeignPtr.Imp.$trModule2_bytes" {
     Foreign.ForeignPtr.Imp.$trModule2_bytes:
         I8[] [70,111,114,101,105,103,110,46,70,111,114,101,105,103,110,80,116,114,46,73,109,112]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.644890249 UTC

[section ""data" . lvl3_r7N42_closure" {
     lvl3_r7N42_closure:
         const lvl3_r7N42_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r7N42_entry() //  [R1]
         { info_tbl: [(c7Ntq,
                       label: lvl3_r7N42_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Ntq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Ntr; else goto c7Nts;
       c7Ntr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Nts: // global
           (_c7Ntn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Ntn::I64 == 0) goto c7Ntp; else goto c7Nto;
       c7Ntp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Nto: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Ntn::I64;
           R2 = Foreign.ForeignPtr.Imp.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.649188203 UTC

[section ""cstring" . lvl4_r7N43_bytes" {
     lvl4_r7N43_bytes:
         I8[] [46,47,70,111,114,101,105,103,110,47,70,111,114,101,105,103,110,80,116,114,47,73,109,112,46,104,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.651391488 UTC

[section ""data" . lvl5_r7N44_closure" {
     lvl5_r7N44_closure:
         const lvl5_r7N44_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_r7N44_entry() //  [R1]
         { info_tbl: [(c7NtI,
                       label: lvl5_r7N44_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NtI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7NtJ; else goto c7NtK;
       c7NtJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7NtK: // global
           (_c7NtF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7NtF::I64 == 0) goto c7NtH; else goto c7NtG;
       c7NtH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7NtG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7NtF::I64;
           R2 = lvl4_r7N43_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.656146108 UTC

[section ""data" . lvl6_r7N45_closure" {
     lvl6_r7N45_closure:
         const GHC.Types.I#_con_info;
         const 110;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.658001673 UTC

[section ""data" . lvl7_r7N46_closure" {
     lvl7_r7N46_closure:
         const GHC.Types.I#_con_info;
         const 35;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.659757561 UTC

[section ""data" . lvl8_r7N47_closure" {
     lvl8_r7N47_closure:
         const GHC.Types.I#_con_info;
         const 44;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.66158504 UTC

[section ""data" . lvl9_r7N48_closure" {
     lvl9_r7N48_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl2_r7N41_closure;
         const lvl3_r7N42_closure;
         const lvl5_r7N44_closure;
         const lvl6_r7N45_closure+1;
         const lvl7_r7N46_closure+1;
         const lvl6_r7N45_closure+1;
         const lvl8_r7N47_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.663485318 UTC

[section ""data" . lvl10_r7N49_closure" {
     lvl10_r7N49_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl1_r7N40_closure;
         const lvl9_r7N48_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.66581466 UTC

[section ""data" . Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_closure" {
     Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_closure:
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_info;
         const 0;
         const 0;
         const 0;
 },
 Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_entry() //  [R1]
         { info_tbl: [(c7Nu4,
                       label: Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nu4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Nu5; else goto c7Nu6;
       c7Nu5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Nu6: // global
           (_c7Nu1::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c7Nu1::I64 == 0) goto c7Nu3; else goto c7Nu2;
       c7Nu3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c7Nu2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c7Nu1::I64;
           R2 = lvl10_r7N49_closure+2;
           Sp = Sp - 16;
           call GHC.Err.undefined_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.671915164 UTC

[section ""data" . Foreign.ForeignPtr.Imp.mallocForeignPtrArray_closure" {
     Foreign.ForeignPtr.Imp.mallocForeignPtrArray_closure:
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray_info;
         const 0;
 },
 lvl11_s7No6_entry() //  [R1]
         { info_tbl: [(c7Nun,
                       label: lvl11_s7No6_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nun: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Nuo; else goto c7Nup;
       c7Nuo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c7Nup: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_closure;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_s7Nop_entry() //  [R1, R2]
         { info_tbl: [(c7Nuy,
                       label: sat_s7Nop_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nuy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7NuC; else goto c7NuD;
       c7NuC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7NuD: // global
           I64[Sp - 16] = block_c7Nuv_info;
           _s7No6::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 8] = _s7No6::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Nv7; else goto c7Nuw;
       u7Nv7: // global
           call _c7Nuv(R1) args: 0, res: 0, upd: 0;
       c7Nuw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Nuv() //  [R1]
         { info_tbl: [(c7Nuv,
                       label: block_c7Nuv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nuv: // global
           I64[Sp] = block_c7NuB_info;
           _s7Noa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7Noa::I64;
           if (R1 & 7 != 0) goto u7Nv6; else goto c7NuF;
       u7Nv6: // global
           call _c7NuB(R1) args: 0, res: 0, upd: 0;
       c7NuF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7NuB() //  [R1]
         { info_tbl: [(c7NuB,
                       label: block_c7NuB_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NuB: // global
           _s7Nod::I64 = I64[Sp + 8] * I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7Nod::I64, 0)) goto c7Nv0; else goto c7Nv5;
       c7Nv0: // global
           I64[Sp] = block_c7NuQ_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp + 8] = _s7Nod::I64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c7Nv5: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7NuQ() //  [R1]
         { info_tbl: [(c7NuQ,
                       label: block_c7NuQ_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NuQ: // global
           I64[Sp] = block_c7NuS_info;
           _s7Noh::P64 = R1;
           R1 = I64[Sp + 8];
           P64[Sp + 8] = _s7Noh::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7NuS() //  [R1]
         { info_tbl: [(c7NuS,
                       label: block_c7NuS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7NuS: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7Nv4; else goto c7Nv3;
       c7Nv4: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Nv3: // global
           I64[Hp - 40] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = R1 + 16;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Foreign.ForeignPtr.Imp.mallocForeignPtrArray_entry() //  [R2]
         { info_tbl: [(c7Nv8,
                       label: Foreign.ForeignPtr.Imp.mallocForeignPtrArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nv8: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c7Nvc; else goto c7Nvb;
       c7Nvc: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.mallocForeignPtrArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c7Nvb: // global
           I64[Hp - 32] = lvl11_s7No6_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s7Nop_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.690048241 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_closure" {
     Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_closure:
         const Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_entry() //  [R2,
                                                              R3]
         { info_tbl: [(c7Nw3,
                       label: Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nw3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto c7Nw4; else goto c7Nw5;
       c7Nw4: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Nw5: // global
           I64[Sp - 16] = block_c7Nw1_info;
           R2 = R2;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_closure;
           I64[Sp - 8] = R3;
           Sp = Sp - 32;
           call Foreign.Storable.sizeOf_entry(R2) args: 24, res: 8, upd: 8;
     }
 },
 _c7Nw1() //  [R1]
         { info_tbl: [(c7Nw1,
                       label: block_c7Nw1_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nw1: // global
           _s7Nov::I64 = (I64[Sp + 8] + 1) * I64[R1 + 7];
           if (%MO_S_Ge_W64(_s7Nov::I64, 0)) goto c7Nws; else goto c7Nwx;
       c7Nws: // global
           I64[Sp] = block_c7Nwi_info;
           R1 = GHC.ForeignPtr.NoFinalizers_closure+1;
           I64[Sp + 8] = _s7Nov::I64;
           call stg_newMutVar#(R1) args: 8, res: 8, upd: 8;
       c7Nwx: // global
           R1 = GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c7Nwi() //  [R1]
         { info_tbl: [(c7Nwi,
                       label: block_c7Nwi_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nwi: // global
           I64[Sp] = block_c7Nwk_info;
           _s7NoA::P64 = R1;
           R1 = I64[Sp + 8];
           P64[Sp + 8] = _s7NoA::P64;
           call stg_newPinnedByteArray#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Nwk() //  [R1]
         { info_tbl: [(c7Nwk,
                       label: block_c7Nwk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nwk: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c7Nww; else goto c7Nwv;
       c7Nww: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c7Nwv: // global
           I64[Hp - 40] = GHC.ForeignPtr.MallocPtr_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = GHC.ForeignPtr.ForeignPtr_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = R1 + 16;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.700919443 UTC

[section ""data" . Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_closure" {
     Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_closure:
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_entry() //  [R2, R3]
         { info_tbl: [(c7Nx8,
                       label: Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nx8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c7Nx9; else goto c7Nxa;
       c7Nx9: // global
           R3 = R3;
           R2 = R2;
           R1 = Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c7Nxa: // global
           I64[Sp - 16] = block_c7Nx5_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto u7Nxe; else goto c7Nx6;
       u7Nxe: // global
           call _c7Nx5(R1) args: 0, res: 0, upd: 0;
       c7Nx6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c7Nx5() //  [R1]
         { info_tbl: [(c7Nx5,
                       label: block_c7Nx5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nx5: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_entry(R3,
                                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.706777826 UTC

[section ""data" . Foreign.ForeignPtr.Imp.mallocForeignPtrArray0_closure" {
     Foreign.ForeignPtr.Imp.mallocForeignPtrArray0_closure:
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray0_info;
         const 0;
 },
 Foreign.ForeignPtr.Imp.mallocForeignPtrArray0_entry() //  [R2, R3]
         { info_tbl: [(c7Nxt,
                       label: Foreign.ForeignPtr.Imp.mallocForeignPtrArray0_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c7Nxt: // global
           R3 = R3;
           R2 = R2;
           call Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_entry(R3,
                                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.710208363 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$trModule3_closure" {
     Foreign.ForeignPtr.Imp.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.ForeignPtr.Imp.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.712062778 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$trModule1_closure" {
     Foreign.ForeignPtr.Imp.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Foreign.ForeignPtr.Imp.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.713975154 UTC

[section ""data" . Foreign.ForeignPtr.Imp.$trModule_closure" {
     Foreign.ForeignPtr.Imp.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Foreign.ForeignPtr.Imp.$trModule3_closure+1;
         const Foreign.ForeignPtr.Imp.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:02:54.715714753 UTC

[section ""relreadonly" . S7Np4_srt" {
     S7Np4_srt:
         const GHC.ForeignPtr.$winsertCFinalizer_closure;
         const Foreign.ForeignPtr.Imp.$wnewForeignPtr_closure;
         const Foreign.ForeignPtr.Imp.newForeignPtr1_closure;
         const Foreign.ForeignPtr.Imp.$wnewForeignPtrEnv_closure;
         const Foreign.ForeignPtr.Imp.newForeignPtrEnv1_closure;
         const GHC.Err.undefined_closure;
         const lvl10_r7N49_closure;
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray1_closure;
         const GHC.ForeignPtr.mallocForeignPtrBytes2_closure;
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray_closure;
         const Foreign.ForeignPtr.Imp.$wmallocForeignPtrArray0_closure;
         const Foreign.ForeignPtr.Imp.mallocForeignPtrArray2_closure;
 }]

