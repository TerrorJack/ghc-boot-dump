
==================== Tidy Core ====================
2018-03-16 15:59:30.363051853 UTC

Result size of Tidy Core
  = {terms: 2,650, types: 4,650, coercions: 1,312, joins: 0/4}

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
sizeOf :: forall a. Storable a => a -> Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(SLLLLLLL),U(U,A,A,A,A,A,A,A)>,
 RULES: Built in rule for sizeOf: "Class op sizeOf"]
sizeOf
  = \ (@ a_a4D8k) (v_B1 :: Storable a_a4D8k) ->
      case v_B1 of v_B1
      { Foreign.Storable.C:Storable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8
                                    v_B9 ->
      v_B2
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
alignment :: forall a. Storable a => a -> Int
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LSLLLLLL),U(A,U,A,A,A,A,A,A)>,
 RULES: Built in rule for alignment: "Class op alignment"]
alignment
  = \ (@ a_a4D8k) (v_B1 :: Storable a_a4D8k) ->
      case v_B1 of v_B1
      { Foreign.Storable.C:Storable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8
                                    v_B9 ->
      v_B3
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
peekElemOff :: forall a. Storable a => Ptr a -> Int -> IO a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLSLLLLL),U(A,A,U,A,A,A,A,A)>,
 RULES: Built in rule for peekElemOff: "Class op peekElemOff"]
peekElemOff
  = \ (@ a_a4D8k) (v_B1 :: Storable a_a4D8k) ->
      case v_B1 of v_B1
      { Foreign.Storable.C:Storable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8
                                    v_B9 ->
      v_B4
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
pokeElemOff :: forall a. Storable a => Ptr a -> Int -> a -> IO ()
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLSLLLL),U(A,A,A,U,A,A,A,A)>,
 RULES: Built in rule for pokeElemOff: "Class op pokeElemOff"]
pokeElemOff
  = \ (@ a_a4D8k) (v_B1 :: Storable a_a4D8k) ->
      case v_B1 of v_B1
      { Foreign.Storable.C:Storable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8
                                    v_B9 ->
      v_B5
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
peekByteOff
  :: forall a. Storable a => forall b. Ptr b -> Int -> IO a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLSLLL),U(A,A,A,A,U,A,A,A)>,
 RULES: Built in rule for peekByteOff: "Class op peekByteOff"]
peekByteOff
  = \ (@ a_a4D8k) (v_B1 :: Storable a_a4D8k) ->
      case v_B1 of v_B1
      { Foreign.Storable.C:Storable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8
                                    v_B9 ->
      v_B6
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
pokeByteOff
  :: forall a. Storable a => forall b. Ptr b -> Int -> a -> IO ()
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLSLL),U(A,A,A,A,A,U,A,A)>,
 RULES: Built in rule for pokeByteOff: "Class op pokeByteOff"]
pokeByteOff
  = \ (@ a_a4D8k) (v_B1 :: Storable a_a4D8k) ->
      case v_B1 of v_B1
      { Foreign.Storable.C:Storable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8
                                    v_B9 ->
      v_B7
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
peek :: forall a. Storable a => Ptr a -> IO a
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLSL),U(A,A,A,A,A,A,U,A)>,
 RULES: Built in rule for peek: "Class op peek"]
peek
  = \ (@ a_a4D8k) (v_B1 :: Storable a_a4D8k) ->
      case v_B1 of v_B1
      { Foreign.Storable.C:Storable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8
                                    v_B9 ->
      v_B8
      }

-- RHS size: {terms: 6, types: 45, coercions: 0, joins: 0/0}
poke :: forall a. Storable a => Ptr a -> a -> IO ()
[GblId[ClassOp],
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLS),U(A,A,A,A,A,A,A,U)>,
 RULES: Built in rule for poke: "Class op poke"]
poke
  = \ (@ a_a4D8k) (v_B1 :: Storable a_a4D8k) ->
      case v_B1 of v_B1
      { Foreign.Storable.C:Storable v_B2 v_B3 v_B4 v_B5 v_B6 v_B7 v_B8
                                    v_B9 ->
      v_B9
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorable()7 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.Storable.$fStorable()7 = GHC.Types.I# 1#

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorable()_$calignment :: () -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Foreign.Storable.$fStorable()7}]
Foreign.Storable.$fStorable()_$calignment
  = \ _ [Occ=Dead] -> Foreign.Storable.$fStorable()7

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorable()8 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.Storable.$fStorable()8 = GHC.Types.I# 0#

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorable()_$csizeOf :: () -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Foreign.Storable.$fStorable()8}]
Foreign.Storable.$fStorable()_$csizeOf
  = \ _ [Occ=Dead] -> Foreign.Storable.$fStorable()8

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableBool7 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.Storable.$fStorableBool7 = GHC.Types.I# 4#

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableChar_$calignment :: Char -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Foreign.Storable.$fStorableBool7}]
Foreign.Storable.$fStorableChar_$calignment
  = \ _ [Occ=Dead] -> Foreign.Storable.$fStorableBool7

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableDouble5 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.Storable.$fStorableDouble5 = GHC.Types.I# 8#

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt_$calignment :: Int -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Foreign.Storable.$fStorableDouble5}]
Foreign.Storable.$fStorableInt_$calignment
  = \ _ [Occ=Dead] -> Foreign.Storable.$fStorableDouble5

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord_$calignment :: Word -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Foreign.Storable.$fStorableDouble5}]
Foreign.Storable.$fStorableWord_$calignment
  = \ _ [Occ=Dead] -> Foreign.Storable.$fStorableDouble5

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorablePtr_$calignment
  :: forall a. Ptr a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a4Drd) _ [Occ=Dead] ->
                 Foreign.Storable.$fStorableDouble5}]
Foreign.Storable.$fStorablePtr_$calignment
  = \ (@ a_a4Drd) _ [Occ=Dead] -> Foreign.Storable.$fStorableDouble5

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableFunPtr_$calignment
  :: forall a. FunPtr a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a4Dqs) _ [Occ=Dead] ->
                 Foreign.Storable.$fStorableDouble5}]
Foreign.Storable.$fStorableFunPtr_$calignment
  = \ (@ a_a4Dqs) _ [Occ=Dead] -> Foreign.Storable.$fStorableDouble5

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableStablePtr_$calignment
  :: forall a. StablePtr a -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ a_a4DpH) _ [Occ=Dead] ->
                 Foreign.Storable.$fStorableDouble5}]
Foreign.Storable.$fStorableStablePtr_$calignment
  = \ (@ a_a4DpH) _ [Occ=Dead] -> Foreign.Storable.$fStorableDouble5

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableFloat_$calignment :: Float -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Foreign.Storable.$fStorableBool7}]
Foreign.Storable.$fStorableFloat_$calignment
  = \ _ [Occ=Dead] -> Foreign.Storable.$fStorableBool7

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableDouble_$calignment :: Double -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Foreign.Storable.$fStorableDouble5}]
Foreign.Storable.$fStorableDouble_$calignment
  = \ _ [Occ=Dead] -> Foreign.Storable.$fStorableDouble5

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord8_$calignment :: Word8 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Foreign.Storable.$fStorable()7}]
Foreign.Storable.$fStorableWord8_$calignment
  = \ _ [Occ=Dead] -> Foreign.Storable.$fStorable()7

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt10 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.Storable.$fStorableInt10 = GHC.Types.I# 2#

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord16_$calignment :: Word16 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Foreign.Storable.$fStorableInt10}]
Foreign.Storable.$fStorableWord16_$calignment
  = \ _ [Occ=Dead] -> Foreign.Storable.$fStorableInt10

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord32_$calignment :: Word32 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Foreign.Storable.$fStorableBool7}]
Foreign.Storable.$fStorableWord32_$calignment
  = \ _ [Occ=Dead] -> Foreign.Storable.$fStorableBool7

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord64_$calignment :: Word64 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Foreign.Storable.$fStorableDouble5}]
Foreign.Storable.$fStorableWord64_$calignment
  = \ _ [Occ=Dead] -> Foreign.Storable.$fStorableDouble5

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt8_$calignment :: Int8 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Foreign.Storable.$fStorable()7}]
Foreign.Storable.$fStorableInt8_$calignment
  = \ _ [Occ=Dead] -> Foreign.Storable.$fStorable()7

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt16_$calignment :: Int16 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Foreign.Storable.$fStorableInt10}]
Foreign.Storable.$fStorableInt16_$calignment
  = \ _ [Occ=Dead] -> Foreign.Storable.$fStorableInt10

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt32_$calignment :: Int32 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Foreign.Storable.$fStorableBool7}]
Foreign.Storable.$fStorableInt32_$calignment
  = \ _ [Occ=Dead] -> Foreign.Storable.$fStorableBool7

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt64_$calignment :: Int64 -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Foreign.Storable.$fStorableDouble5}]
Foreign.Storable.$fStorableInt64_$calignment
  = \ _ [Occ=Dead] -> Foreign.Storable.$fStorableDouble5

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_r4Ff9 :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl_r4Ff9 = "undefined"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl1_r4Ffa :: [Char]
[GblId]
lvl1_r4Ffa = unpackCString# lvl_r4Ff9

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.Storable.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
Foreign.Storable.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl2_r4Ffb :: [Char]
[GblId]
lvl2_r4Ffb = unpackCString# Foreign.Storable.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.Storable.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 50 0}]
Foreign.Storable.$trModule2 = "Foreign.Storable"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl3_r4Ffc :: [Char]
[GblId]
lvl3_r4Ffc = unpackCString# Foreign.Storable.$trModule2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl4_r4Ffd :: Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []]
lvl4_r4Ffd = "./Foreign/Storable.hs"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl5_r4Ffe :: [Char]
[GblId]
lvl5_r4Ffe = unpackCString# lvl4_r4Ffd

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl6_r4Fff :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl6_r4Fff = GHC.Types.I# 238#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl7_r4Ffg :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl7_r4Ffg = GHC.Types.I# 30#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl8_r4Ffh :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl8_r4Ffh = GHC.Types.I# 39#

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
lvl9_r4Ffi :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []]
lvl9_r4Ffi
  = GHC.Stack.Types.SrcLoc
      lvl2_r4Ffb
      lvl3_r4Ffc
      lvl5_r4Ffe
      lvl6_r4Fff
      lvl7_r4Ffg
      lvl6_r4Fff
      lvl8_r4Ffh

-- RHS size: {terms: 4, types: 0, coercions: 0, joins: 0/0}
lvl10_r4Ffj :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []]
lvl10_r4Ffj
  = GHC.Stack.Types.PushCallStack
      lvl1_r4Ffa lvl9_r4Ffi GHC.Stack.Types.EmptyCallStack

-- RHS size: {terms: 3, types: 4, coercions: 4, joins: 0/0}
Foreign.Storable.$fStorableRatio8 :: forall a. a
[GblId, Str=x]
Foreign.Storable.$fStorableRatio8
  = \ (@ a_a4DgH) ->
      undefined
        @ 'LiftedRep
        @ a_a4DgH
        (lvl10_r4Ffj
         `cast` (Sym (GHC.Classes.N:IP[0]
                          <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                 :: (GHC.Stack.Types.CallStack :: *)
                    ~R# (?callStack::GHC.Stack.Types.CallStack :: Constraint)))

-- RHS size: {terms: 9, types: 11, coercions: 0, joins: 0/1}
Foreign.Storable.$fStorableRatio_$calignment
  :: forall a. (Storable a, Integral a) => Ratio a -> Int
[GblId,
 Arity=2,
 Str=<L,1*U(A,1*C1(U),A,A,A,A,A,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4DgH)
                 ($dStorable_a4DgI [Occ=Once] :: Storable a_a4DgH)
                 _ [Occ=Dead] ->
                 let {
                   lvl20_s4DYH [Occ=OnceL] :: Int
                   [LclId]
                   lvl20_s4DYH
                     = alignment
                         @ a_a4DgH
                         $dStorable_a4DgI
                         (Foreign.Storable.$fStorableRatio8 @ a_a4DgH) } in
                 \ _ [Occ=Dead] -> lvl20_s4DYH}]
Foreign.Storable.$fStorableRatio_$calignment
  = \ (@ a_a4DgH)
      ($dStorable_a4DgI :: Storable a_a4DgH)
      _ [Occ=Dead] ->
      let {
        lvl20_s4DYH :: Int
        [LclId]
        lvl20_s4DYH
          = alignment
              @ a_a4DgH
              $dStorable_a4DgI
              (Foreign.Storable.$fStorableRatio8 @ a_a4DgH) } in
      \ _ [Occ=Dead] -> lvl20_s4DYH

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableFingerprint_$calignment
  :: Fingerprint -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Foreign.Storable.$fStorableDouble5}]
Foreign.Storable.$fStorableFingerprint_$calignment
  = \ _ [Occ=Dead] -> Foreign.Storable.$fStorableDouble5

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableFingerprint7 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.Storable.$fStorableFingerprint7 = GHC.Types.I# 16#

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableFingerprint_$csizeOf
  :: Fingerprint -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Foreign.Storable.$fStorableFingerprint7}]
Foreign.Storable.$fStorableFingerprint_$csizeOf
  = \ _ [Occ=Dead] -> Foreign.Storable.$fStorableFingerprint7

-- RHS size: {terms: 7, types: 7, coercions: 0, joins: 0/0}
Foreign.Storable.$dmpoke
  :: forall a. Storable a => Ptr a -> a -> IO ()
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLLC(C(S))LLLL),1*U(A,A,A,1*C1(C1(U)),A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4D8k)
                 ($dStorable_a4DeX [Occ=Once] :: Storable a_a4D8k)
                 (ptr_a4D8z [Occ=Once] :: Ptr a_a4D8k) ->
                 pokeElemOff
                   @ a_a4D8k $dStorable_a4DeX ptr_a4D8z (GHC.Types.I# 0#)}]
Foreign.Storable.$dmpoke
  = \ (@ a_a4D8k)
      ($dStorable_a4DeX :: Storable a_a4D8k)
      (ptr_a4D8z :: Ptr a_a4D8k) ->
      pokeElemOff
        @ a_a4D8k $dStorable_a4DeX ptr_a4D8z Foreign.Storable.$fStorable()8

-- RHS size: {terms: 7, types: 7, coercions: 0, joins: 0/0}
Foreign.Storable.$dmpeek :: forall a. Storable a => Ptr a -> IO a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(LLC(C(S))LLLLL),1*U(A,A,1*C1(C1(U)),A,A,A,A,A)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4D8k)
                 ($dStorable_a4DeX [Occ=Once] :: Storable a_a4D8k)
                 (ptr_a4D8y [Occ=Once] :: Ptr a_a4D8k) ->
                 peekElemOff
                   @ a_a4D8k $dStorable_a4DeX ptr_a4D8y (GHC.Types.I# 0#)}]
Foreign.Storable.$dmpeek
  = \ (@ a_a4D8k)
      ($dStorable_a4DeX :: Storable a_a4D8k)
      (ptr_a4D8y :: Ptr a_a4D8k) ->
      peekElemOff
        @ a_a4D8k $dStorable_a4DeX ptr_a4D8y Foreign.Storable.$fStorable()8

-- RHS size: {terms: 17, types: 16, coercions: 0, joins: 0/0}
Foreign.Storable.$dmpokeByteOff
  :: forall a. Storable a => forall b. Ptr b -> Int -> a -> IO ()
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(S)),1*U(A,A,A,A,A,A,A,1*C1(U))><L,1*U(U)><L,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4D8k)
                 ($dStorable_a4DeX [Occ=Once] :: Storable a_a4D8k)
                 (@ b_a4DfH)
                 (ptr_a4D8w [Occ=Once!] :: Ptr b_a4DfH)
                 (off_a4D8x [Occ=Once!] :: Int) ->
                 poke
                   @ a_a4D8k
                   $dStorable_a4DeX
                   (case ptr_a4D8w of { Ptr addr_a46Xg [Occ=Once] ->
                    case off_a4D8x of { I# d_a46Xh [Occ=Once] ->
                    GHC.Ptr.Ptr @ a_a4D8k (plusAddr# addr_a46Xg d_a46Xh)
                    }
                    })}]
Foreign.Storable.$dmpokeByteOff
  = \ (@ a_a4D8k)
      ($dStorable_a4DeX :: Storable a_a4D8k)
      (@ b_a4DfH)
      (ptr_a4D8w :: Ptr b_a4DfH)
      (off_a4D8x :: Int) ->
      poke
        @ a_a4D8k
        $dStorable_a4DeX
        (case ptr_a4D8w of { Ptr addr_a46Xg ->
         case off_a4D8x of { I# d_a46Xh ->
         GHC.Ptr.Ptr @ a_a4D8k (plusAddr# addr_a46Xg d_a46Xh)
         }
         })

-- RHS size: {terms: 17, types: 16, coercions: 0, joins: 0/0}
Foreign.Storable.$dmpeekByteOff
  :: forall a. Storable a => forall b. Ptr b -> Int -> IO a
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(LLLLLLC(S)L),1*U(A,A,A,A,A,A,1*C1(U),A)><L,1*U(U)><L,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4D8k)
                 ($dStorable_a4DeX [Occ=Once] :: Storable a_a4D8k)
                 (@ b_a4Dfy)
                 (ptr_a4D8u [Occ=Once!] :: Ptr b_a4Dfy)
                 (off_a4D8v [Occ=Once!] :: Int) ->
                 peek
                   @ a_a4D8k
                   $dStorable_a4DeX
                   (case ptr_a4D8u of { Ptr addr_a46Xg [Occ=Once] ->
                    case off_a4D8v of { I# d_a46Xh [Occ=Once] ->
                    GHC.Ptr.Ptr @ a_a4D8k (plusAddr# addr_a46Xg d_a46Xh)
                    }
                    })}]
Foreign.Storable.$dmpeekByteOff
  = \ (@ a_a4D8k)
      ($dStorable_a4DeX :: Storable a_a4D8k)
      (@ b_a4Dfy)
      (ptr_a4D8u :: Ptr b_a4Dfy)
      (off_a4D8v :: Int) ->
      peek
        @ a_a4D8k
        $dStorable_a4DeX
        (case ptr_a4D8u of { Ptr addr_a46Xg ->
         case off_a4D8v of { I# d_a46Xh ->
         GHC.Ptr.Ptr @ a_a4D8k (plusAddr# addr_a46Xg d_a46Xh)
         }
         })

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt17
  :: Ptr Int64 -> State# RealWorld -> (# State# RealWorld, Int64 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_a4D8y [Occ=Once!] :: Ptr Int64)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_a4D8y of { Ptr a_a4ANY [Occ=Once] ->
                 case readInt64OffAddr# @ RealWorld a_a4ANY 0# eta_B1 of
                 { (# ipv_s4B6H [Occ=Once], ipv1_s4B6I [Occ=Once] #) ->
                 (# ipv_s4B6H, GHC.Int.I64# ipv1_s4B6I #)
                 }
                 }}]
Foreign.Storable.$fStorableInt17
  = \ (ptr_a4D8y :: Ptr Int64) (eta_B1 :: State# RealWorld) ->
      case ptr_a4D8y of { Ptr a_a4ANY ->
      case readInt64OffAddr# @ RealWorld a_a4ANY 0# eta_B1 of
      { (# ipv_s4B6H, ipv1_s4B6I #) ->
      (# ipv_s4B6H, GHC.Int.I64# ipv1_s4B6I #)
      }
      }

-- RHS size: {terms: 22, types: 31, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt19
  :: forall b.
     Ptr b -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4DiU)
                 (ptr_a4D8u [Occ=Once!] :: Ptr b_a4DiU)
                 (off_a4D8v [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_a4D8u of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_a4D8v of { I# d_a46Xh [Occ=Once] ->
                 case readInt64OffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
                 of
                 { (# ipv_s4B6H [Occ=Once], ipv1_s4B6I [Occ=Once] #) ->
                 (# ipv_s4B6H, GHC.Int.I64# ipv1_s4B6I #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableInt19
  = \ (@ b_a4DiU)
      (ptr_a4D8u :: Ptr b_a4DiU)
      (off_a4D8v :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ptr_a4D8u of { Ptr addr_a46Xg ->
      case off_a4D8v of { I# d_a46Xh ->
      case readInt64OffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
      of
      { (# ipv_s4B6H, ipv1_s4B6I #) ->
      (# ipv_s4B6H, GHC.Int.I64# ipv1_s4B6I #)
      }
      }
      }

-- RHS size: {terms: 19, types: 20, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt15
  :: Ptr Int64
     -> Int64 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_a4D8z [Occ=Once!] :: Ptr Int64)
                 (ds2_d4AZ2 [Occ=Once!] :: Int64)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_a4D8z of { Ptr a_a4APg [Occ=Once] ->
                 case ds2_d4AZ2 of { I64# x_a4APi [Occ=Once] ->
                 case writeInt64OffAddr# @ RealWorld a_a4APg 0# x_a4APi eta_B1
                 of s2_a4APk
                 { __DEFAULT ->
                 (# s2_a4APk, GHC.Tuple.() #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableInt15
  = \ (ptr_a4D8z :: Ptr Int64)
      (ds2_d4AZ2 :: Int64)
      (eta_B1 :: State# RealWorld) ->
      case ptr_a4D8z of { Ptr a_a4APg ->
      case ds2_d4AZ2 of { I64# x_a4APi ->
      case writeInt64OffAddr# @ RealWorld a_a4APg 0# x_a4APi eta_B1
      of s2_a4APk
      { __DEFAULT ->
      (# s2_a4APk, GHC.Tuple.() #)
      }
      }
      }

-- RHS size: {terms: 26, types: 25, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt18
  :: forall b.
     Ptr b
     -> Int -> Int64 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4Dj2)
                 (ptr_a4D8w [Occ=Once!] :: Ptr b_a4Dj2)
                 (off_a4D8x [Occ=Once!] :: Int)
                 (eta_B2 [Occ=Once!] :: Int64)
                 (eta1_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_a4D8w of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_a4D8x of { I# d_a46Xh [Occ=Once] ->
                 case eta_B2 of { I64# x_a4APi [Occ=Once] ->
                 case writeInt64OffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4APi eta1_B1
                 of s2_a4APk
                 { __DEFAULT ->
                 (# s2_a4APk, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
Foreign.Storable.$fStorableInt18
  = \ (@ b_a4Dj2)
      (ptr_a4D8w :: Ptr b_a4Dj2)
      (off_a4D8x :: Int)
      (eta_B2 :: Int64)
      (eta1_B1 :: State# RealWorld) ->
      case ptr_a4D8w of { Ptr addr_a46Xg ->
      case off_a4D8x of { I# d_a46Xh ->
      case eta_B2 of { I64# x_a4APi ->
      case writeInt64OffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4APi eta1_B1
      of s2_a4APk
      { __DEFAULT ->
      (# s2_a4APk, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 56, joins: 0/0}
Foreign.Storable.$fStorableInt64 [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable Int64
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: Int64
                                   Foreign.Storable.$fStorableInt64_$calignment
                                   Foreign.Storable.$fStorableInt64_$calignment
                                   GHC.Storable.readInt64OffPtr1
                                   `cast` (<Ptr Int64>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Int64>_R)
                                           :: (Ptr Int64
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (Ptr Int64 -> Int -> IO Int64 :: *))
                                   GHC.Storable.writeInt64OffPtr1
                                   `cast` (<Ptr Int64>_R
                                           ->_R <Int>_R
                                           ->_R <Int64>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Int64
                                               -> Int
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Int64 -> Int -> Int64 -> IO () :: *))
                                   Foreign.Storable.$fStorableInt19
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Int64>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> IO Int64 :: *))
                                   Foreign.Storable.$fStorableInt18
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <Int64>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> Int64 -> IO () :: *))
                                   Foreign.Storable.$fStorableInt17
                                   `cast` (<Ptr Int64>_R ->_R Sym (GHC.Types.N:IO[0] <Int64>_R)
                                           :: (Ptr Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int64 #) :: *)
                                              ~R# (Ptr Int64 -> IO Int64 :: *))
                                   Foreign.Storable.$fStorableInt15
                                   `cast` (<Ptr Int64>_R
                                           ->_R <Int64>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Int64
                                               -> Int64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Int64 -> Int64 -> IO () :: *))]
Foreign.Storable.$fStorableInt64
  = Foreign.Storable.C:Storable
      @ Int64
      Foreign.Storable.$fStorableInt64_$calignment
      Foreign.Storable.$fStorableInt64_$calignment
      (GHC.Storable.readInt64OffPtr1
       `cast` (<Ptr Int64>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] <Int64>_R)
               :: (Ptr Int64
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (Ptr Int64 -> Int -> IO Int64 :: *)))
      (GHC.Storable.writeInt64OffPtr1
       `cast` (<Ptr Int64>_R
               ->_R <Int>_R
               ->_R <Int64>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Int64
                   -> Int
                   -> Int64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Int64 -> Int -> Int64 -> IO () :: *)))
      (Foreign.Storable.$fStorableInt19
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R ->_R <Int>_R ->_R Sym (GHC.Types.N:IO[0] <Int64>_R)
               :: (forall b.
                   Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (forall b. Ptr b -> Int -> IO Int64 :: *)))
      (Foreign.Storable.$fStorableInt18
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R
               ->_R <Int>_R
               ->_R <Int64>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   Ptr b
                   -> Int
                   -> Int64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. Ptr b -> Int -> Int64 -> IO () :: *)))
      (Foreign.Storable.$fStorableInt17
       `cast` (<Ptr Int64>_R ->_R Sym (GHC.Types.N:IO[0] <Int64>_R)
               :: (Ptr Int64
                   -> State# RealWorld -> (# State# RealWorld, Int64 #) :: *)
                  ~R# (Ptr Int64 -> IO Int64 :: *)))
      (Foreign.Storable.$fStorableInt15
       `cast` (<Ptr Int64>_R
               ->_R <Int64>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Int64
                   -> Int64 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Int64 -> Int64 -> IO () :: *)))

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt12
  :: Ptr Int32 -> State# RealWorld -> (# State# RealWorld, Int32 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4Dc4 [Occ=Once!] :: Ptr Int32)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dc4 of { Ptr a_a4ANO [Occ=Once] ->
                 case readInt32OffAddr# @ RealWorld a_a4ANO 0# eta_B1 of
                 { (# ipv_s4B6v [Occ=Once], ipv1_s4B6w [Occ=Once] #) ->
                 (# ipv_s4B6v, GHC.Int.I32# ipv1_s4B6w #)
                 }
                 }}]
Foreign.Storable.$fStorableInt12
  = \ (ptr_X4Dc4 :: Ptr Int32) (eta_B1 :: State# RealWorld) ->
      case ptr_X4Dc4 of { Ptr a_a4ANO ->
      case readInt32OffAddr# @ RealWorld a_a4ANO 0# eta_B1 of
      { (# ipv_s4B6v, ipv1_s4B6w #) ->
      (# ipv_s4B6v, GHC.Int.I32# ipv1_s4B6w #)
      }
      }

-- RHS size: {terms: 22, types: 31, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt14
  :: forall b.
     Ptr b -> Int -> State# RealWorld -> (# State# RealWorld, Int32 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4DjC)
                 (ptr_X4DcH [Occ=Once!] :: Ptr b_a4DjC)
                 (off_X4DcJ [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DcH of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4DcJ of { I# d_a46Xh [Occ=Once] ->
                 case readInt32OffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
                 of
                 { (# ipv_s4B6v [Occ=Once], ipv1_s4B6w [Occ=Once] #) ->
                 (# ipv_s4B6v, GHC.Int.I32# ipv1_s4B6w #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableInt14
  = \ (@ b_a4DjC)
      (ptr_X4DcH :: Ptr b_a4DjC)
      (off_X4DcJ :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4DcH of { Ptr addr_a46Xg ->
      case off_X4DcJ of { I# d_a46Xh ->
      case readInt32OffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
      of
      { (# ipv_s4B6v, ipv1_s4B6w #) ->
      (# ipv_s4B6v, GHC.Int.I32# ipv1_s4B6w #)
      }
      }
      }

-- RHS size: {terms: 19, types: 20, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt11
  :: Ptr Int32
     -> Int32 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4Dc0 [Occ=Once!] :: Ptr Int32)
                 (ds2_d4AZq [Occ=Once!] :: Int32)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dc0 of { Ptr a_a4AP6 [Occ=Once] ->
                 case ds2_d4AZq of { I32# x_a4AP8 [Occ=Once] ->
                 case writeInt32OffAddr# @ RealWorld a_a4AP6 0# x_a4AP8 eta_B1
                 of s2_a4APa
                 { __DEFAULT ->
                 (# s2_a4APa, GHC.Tuple.() #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableInt11
  = \ (ptr_X4Dc0 :: Ptr Int32)
      (ds2_d4AZq :: Int32)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Dc0 of { Ptr a_a4AP6 ->
      case ds2_d4AZq of { I32# x_a4AP8 ->
      case writeInt32OffAddr# @ RealWorld a_a4AP6 0# x_a4AP8 eta_B1
      of s2_a4APa
      { __DEFAULT ->
      (# s2_a4APa, GHC.Tuple.() #)
      }
      }
      }

-- RHS size: {terms: 26, types: 25, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt13
  :: forall b.
     Ptr b
     -> Int -> Int32 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4DjK)
                 (ptr_X4DcQ [Occ=Once!] :: Ptr b_a4DjK)
                 (off_X4DcS [Occ=Once!] :: Int)
                 (eta_X4o [Occ=Once!] :: Int32)
                 (eta1_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DcQ of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4DcS of { I# d_a46Xh [Occ=Once] ->
                 case eta_X4o of { I32# x_a4AP8 [Occ=Once] ->
                 case writeInt32OffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AP8 eta1_B1
                 of s2_a4APa
                 { __DEFAULT ->
                 (# s2_a4APa, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
Foreign.Storable.$fStorableInt13
  = \ (@ b_a4DjK)
      (ptr_X4DcQ :: Ptr b_a4DjK)
      (off_X4DcS :: Int)
      (eta_X4o :: Int32)
      (eta1_B1 :: State# RealWorld) ->
      case ptr_X4DcQ of { Ptr addr_a46Xg ->
      case off_X4DcS of { I# d_a46Xh ->
      case eta_X4o of { I32# x_a4AP8 ->
      case writeInt32OffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AP8 eta1_B1
      of s2_a4APa
      { __DEFAULT ->
      (# s2_a4APa, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 56, joins: 0/0}
Foreign.Storable.$fStorableInt32 [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable Int32
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: Int32
                                   Foreign.Storable.$fStorableInt32_$calignment
                                   Foreign.Storable.$fStorableInt32_$calignment
                                   GHC.Storable.readInt32OffPtr1
                                   `cast` (<Ptr Int32>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Int32>_R)
                                           :: (Ptr Int32
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int32 #) :: *)
                                              ~R# (Ptr Int32 -> Int -> IO Int32 :: *))
                                   GHC.Storable.writeInt32OffPtr1
                                   `cast` (<Ptr Int32>_R
                                           ->_R <Int>_R
                                           ->_R <Int32>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Int32
                                               -> Int
                                               -> Int32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Int32 -> Int -> Int32 -> IO () :: *))
                                   Foreign.Storable.$fStorableInt14
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Int32>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int32 #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> IO Int32 :: *))
                                   Foreign.Storable.$fStorableInt13
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <Int32>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> Int32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> Int32 -> IO () :: *))
                                   Foreign.Storable.$fStorableInt12
                                   `cast` (<Ptr Int32>_R ->_R Sym (GHC.Types.N:IO[0] <Int32>_R)
                                           :: (Ptr Int32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int32 #) :: *)
                                              ~R# (Ptr Int32 -> IO Int32 :: *))
                                   Foreign.Storable.$fStorableInt11
                                   `cast` (<Ptr Int32>_R
                                           ->_R <Int32>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Int32
                                               -> Int32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Int32 -> Int32 -> IO () :: *))]
Foreign.Storable.$fStorableInt32
  = Foreign.Storable.C:Storable
      @ Int32
      Foreign.Storable.$fStorableInt32_$calignment
      Foreign.Storable.$fStorableInt32_$calignment
      (GHC.Storable.readInt32OffPtr1
       `cast` (<Ptr Int32>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] <Int32>_R)
               :: (Ptr Int32
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int32 #) :: *)
                  ~R# (Ptr Int32 -> Int -> IO Int32 :: *)))
      (GHC.Storable.writeInt32OffPtr1
       `cast` (<Ptr Int32>_R
               ->_R <Int>_R
               ->_R <Int32>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Int32
                   -> Int
                   -> Int32
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Int32 -> Int -> Int32 -> IO () :: *)))
      (Foreign.Storable.$fStorableInt14
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R ->_R <Int>_R ->_R Sym (GHC.Types.N:IO[0] <Int32>_R)
               :: (forall b.
                   Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int32 #) :: *)
                  ~R# (forall b. Ptr b -> Int -> IO Int32 :: *)))
      (Foreign.Storable.$fStorableInt13
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R
               ->_R <Int>_R
               ->_R <Int32>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   Ptr b
                   -> Int
                   -> Int32
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. Ptr b -> Int -> Int32 -> IO () :: *)))
      (Foreign.Storable.$fStorableInt12
       `cast` (<Ptr Int32>_R ->_R Sym (GHC.Types.N:IO[0] <Int32>_R)
               :: (Ptr Int32
                   -> State# RealWorld -> (# State# RealWorld, Int32 #) :: *)
                  ~R# (Ptr Int32 -> IO Int32 :: *)))
      (Foreign.Storable.$fStorableInt11
       `cast` (<Ptr Int32>_R
               ->_R <Int32>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Int32
                   -> Int32 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Int32 -> Int32 -> IO () :: *)))

-- RHS size: {terms: 2, types: 1, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableBool_$csizeOf :: Bool -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<L,A>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] -> Foreign.Storable.$fStorableBool7}]
Foreign.Storable.$fStorableBool_$csizeOf
  = \ _ [Occ=Dead] -> Foreign.Storable.$fStorableBool7

-- RHS size: {terms: 34, types: 32, coercions: 7, joins: 0/0}
Foreign.Storable.$fStorableBool5
  :: Ptr Bool
     -> Int -> Bool -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,1*U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_a4D8O [Occ=Once] :: Ptr Bool)
                 (i_a4D8P [Occ=Once!] :: Int)
                 (x_a4D8Q [Occ=Once!] :: Bool)
                 (eta_B1 [Occ=Once*] :: State# RealWorld) ->
                 case p_a4D8O
                      `cast` ((Ptr Univ(phantom phantom <*>_N :: Bool, Int32))_R
                              :: (Ptr Bool :: *) ~R# (Ptr Int32 :: *))
                 of
                 { Ptr a_a4AP6 [Occ=Once*] ->
                 case i_a4D8P of { I# i1_a4AP7 [Occ=Once*] ->
                 case x_a4D8Q of {
                   False ->
                     case writeInt32OffAddr# @ RealWorld a_a4AP6 i1_a4AP7 0# eta_B1
                     of s2_a4APa
                     { __DEFAULT ->
                     (# s2_a4APa, GHC.Tuple.() #)
                     };
                   True ->
                     case writeInt32OffAddr# @ RealWorld a_a4AP6 i1_a4AP7 1# eta_B1
                     of s2_a4APa
                     { __DEFAULT ->
                     (# s2_a4APa, GHC.Tuple.() #)
                     }
                 }
                 }
                 }}]
Foreign.Storable.$fStorableBool5
  = \ (p_a4D8O :: Ptr Bool)
      (i_a4D8P :: Int)
      (x_a4D8Q :: Bool)
      (eta_B1 :: State# RealWorld) ->
      case p_a4D8O
           `cast` ((Ptr Univ(phantom phantom <*>_N :: Bool, Int32))_R
                   :: (Ptr Bool :: *) ~R# (Ptr Int32 :: *))
      of
      { Ptr a_a4AP6 ->
      case i_a4D8P of { I# i1_a4AP7 ->
      case x_a4D8Q of {
        False ->
          case writeInt32OffAddr# @ RealWorld a_a4AP6 i1_a4AP7 0# eta_B1
          of s2_a4APa
          { __DEFAULT ->
          (# s2_a4APa, GHC.Tuple.() #)
          };
        True ->
          case writeInt32OffAddr# @ RealWorld a_a4AP6 i1_a4AP7 1# eta_B1
          of s2_a4APa
          { __DEFAULT ->
          (# s2_a4APa, GHC.Tuple.() #)
          }
      }
      }
      }

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt6
  :: Ptr Int16 -> State# RealWorld -> (# State# RealWorld, Int16 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4Dhj [Occ=Once!] :: Ptr Int16)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dhj of { Ptr a_a4ANE [Occ=Once] ->
                 case readInt16OffAddr# @ RealWorld a_a4ANE 0# eta_B1 of
                 { (# ipv_s4B6j [Occ=Once], ipv1_s4B6k [Occ=Once] #) ->
                 (# ipv_s4B6j, GHC.Int.I16# ipv1_s4B6k #)
                 }
                 }}]
Foreign.Storable.$fStorableInt6
  = \ (ptr_X4Dhj :: Ptr Int16) (eta_B1 :: State# RealWorld) ->
      case ptr_X4Dhj of { Ptr a_a4ANE ->
      case readInt16OffAddr# @ RealWorld a_a4ANE 0# eta_B1 of
      { (# ipv_s4B6j, ipv1_s4B6k #) ->
      (# ipv_s4B6j, GHC.Int.I16# ipv1_s4B6k #)
      }
      }

-- RHS size: {terms: 22, types: 31, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt9
  :: forall b.
     Ptr b -> Int -> State# RealWorld -> (# State# RealWorld, Int16 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4Dkk)
                 (ptr_X4Dd0 [Occ=Once!] :: Ptr b_a4Dkk)
                 (off_X4Dd2 [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dd0 of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4Dd2 of { I# d_a46Xh [Occ=Once] ->
                 case readInt16OffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
                 of
                 { (# ipv_s4B6j [Occ=Once], ipv1_s4B6k [Occ=Once] #) ->
                 (# ipv_s4B6j, GHC.Int.I16# ipv1_s4B6k #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableInt9
  = \ (@ b_a4Dkk)
      (ptr_X4Dd0 :: Ptr b_a4Dkk)
      (off_X4Dd2 :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Dd0 of { Ptr addr_a46Xg ->
      case off_X4Dd2 of { I# d_a46Xh ->
      case readInt16OffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
      of
      { (# ipv_s4B6j, ipv1_s4B6k #) ->
      (# ipv_s4B6j, GHC.Int.I16# ipv1_s4B6k #)
      }
      }
      }

-- RHS size: {terms: 19, types: 20, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt5
  :: Ptr Int16
     -> Int16 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4DcM [Occ=Once!] :: Ptr Int16)
                 (ds2_d4AZO [Occ=Once!] :: Int16)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DcM of { Ptr a_a4AOW [Occ=Once] ->
                 case ds2_d4AZO of { I16# x_a4AOY [Occ=Once] ->
                 case writeInt16OffAddr# @ RealWorld a_a4AOW 0# x_a4AOY eta_B1
                 of s2_a4AP0
                 { __DEFAULT ->
                 (# s2_a4AP0, GHC.Tuple.() #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableInt5
  = \ (ptr_X4DcM :: Ptr Int16)
      (ds2_d4AZO :: Int16)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4DcM of { Ptr a_a4AOW ->
      case ds2_d4AZO of { I16# x_a4AOY ->
      case writeInt16OffAddr# @ RealWorld a_a4AOW 0# x_a4AOY eta_B1
      of s2_a4AP0
      { __DEFAULT ->
      (# s2_a4AP0, GHC.Tuple.() #)
      }
      }
      }

-- RHS size: {terms: 26, types: 25, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt7
  :: forall b.
     Ptr b
     -> Int -> Int16 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4Dks)
                 (ptr_X4Dd9 [Occ=Once!] :: Ptr b_a4Dks)
                 (off_X4Ddb [Occ=Once!] :: Int)
                 (eta_X4H [Occ=Once!] :: Int16)
                 (eta1_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dd9 of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4Ddb of { I# d_a46Xh [Occ=Once] ->
                 case eta_X4H of { I16# x_a4AOY [Occ=Once] ->
                 case writeInt16OffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AOY eta1_B1
                 of s2_a4AP0
                 { __DEFAULT ->
                 (# s2_a4AP0, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
Foreign.Storable.$fStorableInt7
  = \ (@ b_a4Dks)
      (ptr_X4Dd9 :: Ptr b_a4Dks)
      (off_X4Ddb :: Int)
      (eta_X4H :: Int16)
      (eta1_B1 :: State# RealWorld) ->
      case ptr_X4Dd9 of { Ptr addr_a46Xg ->
      case off_X4Ddb of { I# d_a46Xh ->
      case eta_X4H of { I16# x_a4AOY ->
      case writeInt16OffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AOY eta1_B1
      of s2_a4AP0
      { __DEFAULT ->
      (# s2_a4AP0, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 56, joins: 0/0}
Foreign.Storable.$fStorableInt16 [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable Int16
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: Int16
                                   Foreign.Storable.$fStorableInt16_$calignment
                                   Foreign.Storable.$fStorableInt16_$calignment
                                   GHC.Storable.readInt16OffPtr1
                                   `cast` (<Ptr Int16>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Int16>_R)
                                           :: (Ptr Int16
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int16 #) :: *)
                                              ~R# (Ptr Int16 -> Int -> IO Int16 :: *))
                                   GHC.Storable.writeInt16OffPtr1
                                   `cast` (<Ptr Int16>_R
                                           ->_R <Int>_R
                                           ->_R <Int16>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Int16
                                               -> Int
                                               -> Int16
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Int16 -> Int -> Int16 -> IO () :: *))
                                   Foreign.Storable.$fStorableInt9
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Int16>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int16 #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> IO Int16 :: *))
                                   Foreign.Storable.$fStorableInt7
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <Int16>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> Int16
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> Int16 -> IO () :: *))
                                   Foreign.Storable.$fStorableInt6
                                   `cast` (<Ptr Int16>_R ->_R Sym (GHC.Types.N:IO[0] <Int16>_R)
                                           :: (Ptr Int16
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int16 #) :: *)
                                              ~R# (Ptr Int16 -> IO Int16 :: *))
                                   Foreign.Storable.$fStorableInt5
                                   `cast` (<Ptr Int16>_R
                                           ->_R <Int16>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Int16
                                               -> Int16
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Int16 -> Int16 -> IO () :: *))]
Foreign.Storable.$fStorableInt16
  = Foreign.Storable.C:Storable
      @ Int16
      Foreign.Storable.$fStorableInt16_$calignment
      Foreign.Storable.$fStorableInt16_$calignment
      (GHC.Storable.readInt16OffPtr1
       `cast` (<Ptr Int16>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] <Int16>_R)
               :: (Ptr Int16
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int16 #) :: *)
                  ~R# (Ptr Int16 -> Int -> IO Int16 :: *)))
      (GHC.Storable.writeInt16OffPtr1
       `cast` (<Ptr Int16>_R
               ->_R <Int>_R
               ->_R <Int16>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Int16
                   -> Int
                   -> Int16
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Int16 -> Int -> Int16 -> IO () :: *)))
      (Foreign.Storable.$fStorableInt9
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R ->_R <Int>_R ->_R Sym (GHC.Types.N:IO[0] <Int16>_R)
               :: (forall b.
                   Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int16 #) :: *)
                  ~R# (forall b. Ptr b -> Int -> IO Int16 :: *)))
      (Foreign.Storable.$fStorableInt7
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R
               ->_R <Int>_R
               ->_R <Int16>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   Ptr b
                   -> Int
                   -> Int16
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. Ptr b -> Int -> Int16 -> IO () :: *)))
      (Foreign.Storable.$fStorableInt6
       `cast` (<Ptr Int16>_R ->_R Sym (GHC.Types.N:IO[0] <Int16>_R)
               :: (Ptr Int16
                   -> State# RealWorld -> (# State# RealWorld, Int16 #) :: *)
                  ~R# (Ptr Int16 -> IO Int16 :: *)))
      (Foreign.Storable.$fStorableInt5
       `cast` (<Ptr Int16>_R
               ->_R <Int16>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Int16
                   -> Int16 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Int16 -> Int16 -> IO () :: *)))

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt21
  :: Ptr Int8 -> State# RealWorld -> (# State# RealWorld, Int8 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4Dd1 [Occ=Once!] :: Ptr Int8)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dd1 of { Ptr a_a4ANu [Occ=Once] ->
                 case readInt8OffAddr# @ RealWorld a_a4ANu 0# eta_B1 of
                 { (# ipv_s4B67 [Occ=Once], ipv1_s4B68 [Occ=Once] #) ->
                 (# ipv_s4B67, GHC.Int.I8# ipv1_s4B68 #)
                 }
                 }}]
Foreign.Storable.$fStorableInt21
  = \ (ptr_X4Dd1 :: Ptr Int8) (eta_B1 :: State# RealWorld) ->
      case ptr_X4Dd1 of { Ptr a_a4ANu ->
      case readInt8OffAddr# @ RealWorld a_a4ANu 0# eta_B1 of
      { (# ipv_s4B67, ipv1_s4B68 #) ->
      (# ipv_s4B67, GHC.Int.I8# ipv1_s4B68 #)
      }
      }

-- RHS size: {terms: 22, types: 31, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt23
  :: forall b.
     Ptr b -> Int -> State# RealWorld -> (# State# RealWorld, Int8 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4Dl2)
                 (ptr_X4Ddg [Occ=Once!] :: Ptr b_a4Dl2)
                 (off_X4Ddi [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Ddg of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4Ddi of { I# d_a46Xh [Occ=Once] ->
                 case readInt8OffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
                 of
                 { (# ipv_s4B67 [Occ=Once], ipv1_s4B68 [Occ=Once] #) ->
                 (# ipv_s4B67, GHC.Int.I8# ipv1_s4B68 #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableInt23
  = \ (@ b_a4Dl2)
      (ptr_X4Ddg :: Ptr b_a4Dl2)
      (off_X4Ddi :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Ddg of { Ptr addr_a46Xg ->
      case off_X4Ddi of { I# d_a46Xh ->
      case readInt8OffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
      of
      { (# ipv_s4B67, ipv1_s4B68 #) ->
      (# ipv_s4B67, GHC.Int.I8# ipv1_s4B68 #)
      }
      }
      }

-- RHS size: {terms: 19, types: 20, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt20
  :: Ptr Int8
     -> Int8 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4DcX [Occ=Once!] :: Ptr Int8)
                 (ds2_d4B0c [Occ=Once!] :: Int8)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DcX of { Ptr a_a4AOM [Occ=Once] ->
                 case ds2_d4B0c of { I8# x_a4AOO [Occ=Once] ->
                 case writeInt8OffAddr# @ RealWorld a_a4AOM 0# x_a4AOO eta_B1
                 of s2_a4AOQ
                 { __DEFAULT ->
                 (# s2_a4AOQ, GHC.Tuple.() #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableInt20
  = \ (ptr_X4DcX :: Ptr Int8)
      (ds2_d4B0c :: Int8)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4DcX of { Ptr a_a4AOM ->
      case ds2_d4B0c of { I8# x_a4AOO ->
      case writeInt8OffAddr# @ RealWorld a_a4AOM 0# x_a4AOO eta_B1
      of s2_a4AOQ
      { __DEFAULT ->
      (# s2_a4AOQ, GHC.Tuple.() #)
      }
      }
      }

-- RHS size: {terms: 26, types: 25, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt22
  :: forall b.
     Ptr b
     -> Int -> Int8 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4Dla)
                 (ptr_X4Ddp [Occ=Once!] :: Ptr b_a4Dla)
                 (off_X4Ddr [Occ=Once!] :: Int)
                 (eta_X4X [Occ=Once!] :: Int8)
                 (eta1_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Ddp of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4Ddr of { I# d_a46Xh [Occ=Once] ->
                 case eta_X4X of { I8# x_a4AOO [Occ=Once] ->
                 case writeInt8OffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AOO eta1_B1
                 of s2_a4AOQ
                 { __DEFAULT ->
                 (# s2_a4AOQ, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
Foreign.Storable.$fStorableInt22
  = \ (@ b_a4Dla)
      (ptr_X4Ddp :: Ptr b_a4Dla)
      (off_X4Ddr :: Int)
      (eta_X4X :: Int8)
      (eta1_B1 :: State# RealWorld) ->
      case ptr_X4Ddp of { Ptr addr_a46Xg ->
      case off_X4Ddr of { I# d_a46Xh ->
      case eta_X4X of { I8# x_a4AOO ->
      case writeInt8OffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AOO eta1_B1
      of s2_a4AOQ
      { __DEFAULT ->
      (# s2_a4AOQ, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 56, joins: 0/0}
Foreign.Storable.$fStorableInt8 [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable Int8
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: Int8
                                   Foreign.Storable.$fStorableInt8_$calignment
                                   Foreign.Storable.$fStorableInt8_$calignment
                                   GHC.Storable.readInt8OffPtr1
                                   `cast` (<Ptr Int8>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Int8>_R)
                                           :: (Ptr Int8
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int8 #) :: *)
                                              ~R# (Ptr Int8 -> Int -> IO Int8 :: *))
                                   GHC.Storable.writeInt8OffPtr1
                                   `cast` (<Ptr Int8>_R
                                           ->_R <Int>_R
                                           ->_R <Int8>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Int8
                                               -> Int
                                               -> Int8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Int8 -> Int -> Int8 -> IO () :: *))
                                   Foreign.Storable.$fStorableInt23
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Int8>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int8 #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> IO Int8 :: *))
                                   Foreign.Storable.$fStorableInt22
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <Int8>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> Int8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> Int8 -> IO () :: *))
                                   Foreign.Storable.$fStorableInt21
                                   `cast` (<Ptr Int8>_R ->_R Sym (GHC.Types.N:IO[0] <Int8>_R)
                                           :: (Ptr Int8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int8 #) :: *)
                                              ~R# (Ptr Int8 -> IO Int8 :: *))
                                   Foreign.Storable.$fStorableInt20
                                   `cast` (<Ptr Int8>_R
                                           ->_R <Int8>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Int8
                                               -> Int8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Int8 -> Int8 -> IO () :: *))]
Foreign.Storable.$fStorableInt8
  = Foreign.Storable.C:Storable
      @ Int8
      Foreign.Storable.$fStorableInt8_$calignment
      Foreign.Storable.$fStorableInt8_$calignment
      (GHC.Storable.readInt8OffPtr1
       `cast` (<Ptr Int8>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] <Int8>_R)
               :: (Ptr Int8
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int8 #) :: *)
                  ~R# (Ptr Int8 -> Int -> IO Int8 :: *)))
      (GHC.Storable.writeInt8OffPtr1
       `cast` (<Ptr Int8>_R
               ->_R <Int>_R
               ->_R <Int8>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Int8
                   -> Int
                   -> Int8
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Int8 -> Int -> Int8 -> IO () :: *)))
      (Foreign.Storable.$fStorableInt23
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R ->_R <Int>_R ->_R Sym (GHC.Types.N:IO[0] <Int8>_R)
               :: (forall b.
                   Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int8 #) :: *)
                  ~R# (forall b. Ptr b -> Int -> IO Int8 :: *)))
      (Foreign.Storable.$fStorableInt22
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R
               ->_R <Int>_R
               ->_R <Int8>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   Ptr b
                   -> Int
                   -> Int8
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. Ptr b -> Int -> Int8 -> IO () :: *)))
      (Foreign.Storable.$fStorableInt21
       `cast` (<Ptr Int8>_R ->_R Sym (GHC.Types.N:IO[0] <Int8>_R)
               :: (Ptr Int8
                   -> State# RealWorld -> (# State# RealWorld, Int8 #) :: *)
                  ~R# (Ptr Int8 -> IO Int8 :: *)))
      (Foreign.Storable.$fStorableInt20
       `cast` (<Ptr Int8>_R
               ->_R <Int8>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Int8
                   -> Int8 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Int8 -> Int8 -> IO () :: *)))

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord15
  :: Ptr Word64 -> State# RealWorld -> (# State# RealWorld, Word64 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4Ddc [Occ=Once!] :: Ptr Word64)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Ddc of { Ptr a_a4AO3 [Occ=Once] ->
                 case readWord64OffAddr# @ RealWorld a_a4AO3 0# eta_B1 of
                 { (# ipv_s4B6N [Occ=Once], ipv1_s4B6O [Occ=Once] #) ->
                 (# ipv_s4B6N, GHC.Word.W64# ipv1_s4B6O #)
                 }
                 }}]
Foreign.Storable.$fStorableWord15
  = \ (ptr_X4Ddc :: Ptr Word64) (eta_B1 :: State# RealWorld) ->
      case ptr_X4Ddc of { Ptr a_a4AO3 ->
      case readWord64OffAddr# @ RealWorld a_a4AO3 0# eta_B1 of
      { (# ipv_s4B6N, ipv1_s4B6O #) ->
      (# ipv_s4B6N, GHC.Word.W64# ipv1_s4B6O #)
      }
      }

-- RHS size: {terms: 22, types: 31, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord18
  :: forall b.
     Ptr b -> Int -> State# RealWorld -> (# State# RealWorld, Word64 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4DlK)
                 (ptr_X4Ddw [Occ=Once!] :: Ptr b_a4DlK)
                 (off_X4Ddy [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Ddw of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4Ddy of { I# d_a46Xh [Occ=Once] ->
                 case readWord64OffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
                 of
                 { (# ipv_s4B6N [Occ=Once], ipv1_s4B6O [Occ=Once] #) ->
                 (# ipv_s4B6N, GHC.Word.W64# ipv1_s4B6O #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableWord18
  = \ (@ b_a4DlK)
      (ptr_X4Ddw :: Ptr b_a4DlK)
      (off_X4Ddy :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Ddw of { Ptr addr_a46Xg ->
      case off_X4Ddy of { I# d_a46Xh ->
      case readWord64OffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
      of
      { (# ipv_s4B6N, ipv1_s4B6O #) ->
      (# ipv_s4B6N, GHC.Word.W64# ipv1_s4B6O #)
      }
      }
      }

-- RHS size: {terms: 19, types: 20, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord14
  :: Ptr Word64
     -> Word64 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4Dd8 [Occ=Once!] :: Ptr Word64)
                 (ds2_d4AYQ [Occ=Once!] :: Word64)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dd8 of { Ptr a_a4APl [Occ=Once] ->
                 case ds2_d4AYQ of { W64# x_a4APn [Occ=Once] ->
                 case writeWord64OffAddr# @ RealWorld a_a4APl 0# x_a4APn eta_B1
                 of s2_a4APp
                 { __DEFAULT ->
                 (# s2_a4APp, GHC.Tuple.() #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableWord14
  = \ (ptr_X4Dd8 :: Ptr Word64)
      (ds2_d4AYQ :: Word64)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Dd8 of { Ptr a_a4APl ->
      case ds2_d4AYQ of { W64# x_a4APn ->
      case writeWord64OffAddr# @ RealWorld a_a4APl 0# x_a4APn eta_B1
      of s2_a4APp
      { __DEFAULT ->
      (# s2_a4APp, GHC.Tuple.() #)
      }
      }
      }

-- RHS size: {terms: 26, types: 25, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord17
  :: forall b.
     Ptr b
     -> Int -> Word64 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4DlS)
                 (ptr_X4DdF [Occ=Once!] :: Ptr b_a4DlS)
                 (off_X4DdH [Occ=Once!] :: Int)
                 (eta_X5d [Occ=Once!] :: Word64)
                 (eta1_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DdF of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4DdH of { I# d_a46Xh [Occ=Once] ->
                 case eta_X5d of { W64# x_a4APn [Occ=Once] ->
                 case writeWord64OffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4APn eta1_B1
                 of s2_a4APp
                 { __DEFAULT ->
                 (# s2_a4APp, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
Foreign.Storable.$fStorableWord17
  = \ (@ b_a4DlS)
      (ptr_X4DdF :: Ptr b_a4DlS)
      (off_X4DdH :: Int)
      (eta_X5d :: Word64)
      (eta1_B1 :: State# RealWorld) ->
      case ptr_X4DdF of { Ptr addr_a46Xg ->
      case off_X4DdH of { I# d_a46Xh ->
      case eta_X5d of { W64# x_a4APn ->
      case writeWord64OffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4APn eta1_B1
      of s2_a4APp
      { __DEFAULT ->
      (# s2_a4APp, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 56, joins: 0/0}
Foreign.Storable.$fStorableWord64 [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable Word64
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: Word64
                                   Foreign.Storable.$fStorableWord64_$calignment
                                   Foreign.Storable.$fStorableWord64_$calignment
                                   GHC.Storable.readWord64OffPtr1
                                   `cast` (<Ptr Word64>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Word64>_R)
                                           :: (Ptr Word64
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word64 #) :: *)
                                              ~R# (Ptr Word64 -> Int -> IO Word64 :: *))
                                   GHC.Storable.writeWord64OffPtr1
                                   `cast` (<Ptr Word64>_R
                                           ->_R <Int>_R
                                           ->_R <Word64>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Word64
                                               -> Int
                                               -> Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Word64 -> Int -> Word64 -> IO () :: *))
                                   Foreign.Storable.$fStorableWord18
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Word64>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word64 #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> IO Word64 :: *))
                                   Foreign.Storable.$fStorableWord17
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <Word64>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> Word64 -> IO () :: *))
                                   Foreign.Storable.$fStorableWord15
                                   `cast` (<Ptr Word64>_R ->_R Sym (GHC.Types.N:IO[0] <Word64>_R)
                                           :: (Ptr Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word64 #) :: *)
                                              ~R# (Ptr Word64 -> IO Word64 :: *))
                                   Foreign.Storable.$fStorableWord14
                                   `cast` (<Ptr Word64>_R
                                           ->_R <Word64>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Word64
                                               -> Word64
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Word64 -> Word64 -> IO () :: *))]
Foreign.Storable.$fStorableWord64
  = Foreign.Storable.C:Storable
      @ Word64
      Foreign.Storable.$fStorableWord64_$calignment
      Foreign.Storable.$fStorableWord64_$calignment
      (GHC.Storable.readWord64OffPtr1
       `cast` (<Ptr Word64>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] <Word64>_R)
               :: (Ptr Word64
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word64 #) :: *)
                  ~R# (Ptr Word64 -> Int -> IO Word64 :: *)))
      (GHC.Storable.writeWord64OffPtr1
       `cast` (<Ptr Word64>_R
               ->_R <Int>_R
               ->_R <Word64>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Word64
                   -> Int
                   -> Word64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Word64 -> Int -> Word64 -> IO () :: *)))
      (Foreign.Storable.$fStorableWord18
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R ->_R <Int>_R ->_R Sym (GHC.Types.N:IO[0] <Word64>_R)
               :: (forall b.
                   Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word64 #) :: *)
                  ~R# (forall b. Ptr b -> Int -> IO Word64 :: *)))
      (Foreign.Storable.$fStorableWord17
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R
               ->_R <Int>_R
               ->_R <Word64>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   Ptr b
                   -> Int
                   -> Word64
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. Ptr b -> Int -> Word64 -> IO () :: *)))
      (Foreign.Storable.$fStorableWord15
       `cast` (<Ptr Word64>_R ->_R Sym (GHC.Types.N:IO[0] <Word64>_R)
               :: (Ptr Word64
                   -> State# RealWorld -> (# State# RealWorld, Word64 #) :: *)
                  ~R# (Ptr Word64 -> IO Word64 :: *)))
      (Foreign.Storable.$fStorableWord14
       `cast` (<Ptr Word64>_R
               ->_R <Word64>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Word64
                   -> Word64 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Word64 -> Word64 -> IO () :: *)))

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord11
  :: Ptr Word32 -> State# RealWorld -> (# State# RealWorld, Word32 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4Ddn [Occ=Once!] :: Ptr Word32)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Ddn of { Ptr a_a4ANT [Occ=Once] ->
                 case readWord32OffAddr# @ RealWorld a_a4ANT 0# eta_B1 of
                 { (# ipv_s4B6B [Occ=Once], ipv1_s4B6C [Occ=Once] #) ->
                 (# ipv_s4B6B, GHC.Word.W32# ipv1_s4B6C #)
                 }
                 }}]
Foreign.Storable.$fStorableWord11
  = \ (ptr_X4Ddn :: Ptr Word32) (eta_B1 :: State# RealWorld) ->
      case ptr_X4Ddn of { Ptr a_a4ANT ->
      case readWord32OffAddr# @ RealWorld a_a4ANT 0# eta_B1 of
      { (# ipv_s4B6B, ipv1_s4B6C #) ->
      (# ipv_s4B6B, GHC.Word.W32# ipv1_s4B6C #)
      }
      }

-- RHS size: {terms: 22, types: 31, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord13
  :: forall b.
     Ptr b -> Int -> State# RealWorld -> (# State# RealWorld, Word32 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4Dms)
                 (ptr_X4DdM [Occ=Once!] :: Ptr b_a4Dms)
                 (off_X4DdO [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DdM of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4DdO of { I# d_a46Xh [Occ=Once] ->
                 case readWord32OffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
                 of
                 { (# ipv_s4B6B [Occ=Once], ipv1_s4B6C [Occ=Once] #) ->
                 (# ipv_s4B6B, GHC.Word.W32# ipv1_s4B6C #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableWord13
  = \ (@ b_a4Dms)
      (ptr_X4DdM :: Ptr b_a4Dms)
      (off_X4DdO :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4DdM of { Ptr addr_a46Xg ->
      case off_X4DdO of { I# d_a46Xh ->
      case readWord32OffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
      of
      { (# ipv_s4B6B, ipv1_s4B6C #) ->
      (# ipv_s4B6B, GHC.Word.W32# ipv1_s4B6C #)
      }
      }
      }

-- RHS size: {terms: 19, types: 20, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord10
  :: Ptr Word32
     -> Word32 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4Ddj [Occ=Once!] :: Ptr Word32)
                 (ds2_d4AZe [Occ=Once!] :: Word32)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Ddj of { Ptr a_a4APb [Occ=Once] ->
                 case ds2_d4AZe of { W32# x_a4APd [Occ=Once] ->
                 case writeWord32OffAddr# @ RealWorld a_a4APb 0# x_a4APd eta_B1
                 of s2_a4APf
                 { __DEFAULT ->
                 (# s2_a4APf, GHC.Tuple.() #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableWord10
  = \ (ptr_X4Ddj :: Ptr Word32)
      (ds2_d4AZe :: Word32)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Ddj of { Ptr a_a4APb ->
      case ds2_d4AZe of { W32# x_a4APd ->
      case writeWord32OffAddr# @ RealWorld a_a4APb 0# x_a4APd eta_B1
      of s2_a4APf
      { __DEFAULT ->
      (# s2_a4APf, GHC.Tuple.() #)
      }
      }
      }

-- RHS size: {terms: 26, types: 25, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord12
  :: forall b.
     Ptr b
     -> Int -> Word32 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4DmA)
                 (ptr_X4DdV [Occ=Once!] :: Ptr b_a4DmA)
                 (off_X4DdX [Occ=Once!] :: Int)
                 (eta_X5t [Occ=Once!] :: Word32)
                 (eta1_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DdV of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4DdX of { I# d_a46Xh [Occ=Once] ->
                 case eta_X5t of { W32# x_a4APd [Occ=Once] ->
                 case writeWord32OffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4APd eta1_B1
                 of s2_a4APf
                 { __DEFAULT ->
                 (# s2_a4APf, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
Foreign.Storable.$fStorableWord12
  = \ (@ b_a4DmA)
      (ptr_X4DdV :: Ptr b_a4DmA)
      (off_X4DdX :: Int)
      (eta_X5t :: Word32)
      (eta1_B1 :: State# RealWorld) ->
      case ptr_X4DdV of { Ptr addr_a46Xg ->
      case off_X4DdX of { I# d_a46Xh ->
      case eta_X5t of { W32# x_a4APd ->
      case writeWord32OffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4APd eta1_B1
      of s2_a4APf
      { __DEFAULT ->
      (# s2_a4APf, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 56, joins: 0/0}
Foreign.Storable.$fStorableWord32 [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable Word32
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: Word32
                                   Foreign.Storable.$fStorableWord32_$calignment
                                   Foreign.Storable.$fStorableWord32_$calignment
                                   GHC.Storable.readWord32OffPtr1
                                   `cast` (<Ptr Word32>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Word32>_R)
                                           :: (Ptr Word32
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word32 #) :: *)
                                              ~R# (Ptr Word32 -> Int -> IO Word32 :: *))
                                   GHC.Storable.writeWord32OffPtr1
                                   `cast` (<Ptr Word32>_R
                                           ->_R <Int>_R
                                           ->_R <Word32>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Word32
                                               -> Int
                                               -> Word32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Word32 -> Int -> Word32 -> IO () :: *))
                                   Foreign.Storable.$fStorableWord13
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Word32>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word32 #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> IO Word32 :: *))
                                   Foreign.Storable.$fStorableWord12
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <Word32>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> Word32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> Word32 -> IO () :: *))
                                   Foreign.Storable.$fStorableWord11
                                   `cast` (<Ptr Word32>_R ->_R Sym (GHC.Types.N:IO[0] <Word32>_R)
                                           :: (Ptr Word32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word32 #) :: *)
                                              ~R# (Ptr Word32 -> IO Word32 :: *))
                                   Foreign.Storable.$fStorableWord10
                                   `cast` (<Ptr Word32>_R
                                           ->_R <Word32>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Word32
                                               -> Word32
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Word32 -> Word32 -> IO () :: *))]
Foreign.Storable.$fStorableWord32
  = Foreign.Storable.C:Storable
      @ Word32
      Foreign.Storable.$fStorableWord32_$calignment
      Foreign.Storable.$fStorableWord32_$calignment
      (GHC.Storable.readWord32OffPtr1
       `cast` (<Ptr Word32>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] <Word32>_R)
               :: (Ptr Word32
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word32 #) :: *)
                  ~R# (Ptr Word32 -> Int -> IO Word32 :: *)))
      (GHC.Storable.writeWord32OffPtr1
       `cast` (<Ptr Word32>_R
               ->_R <Int>_R
               ->_R <Word32>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Word32
                   -> Int
                   -> Word32
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Word32 -> Int -> Word32 -> IO () :: *)))
      (Foreign.Storable.$fStorableWord13
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R ->_R <Int>_R ->_R Sym (GHC.Types.N:IO[0] <Word32>_R)
               :: (forall b.
                   Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word32 #) :: *)
                  ~R# (forall b. Ptr b -> Int -> IO Word32 :: *)))
      (Foreign.Storable.$fStorableWord12
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R
               ->_R <Int>_R
               ->_R <Word32>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   Ptr b
                   -> Int
                   -> Word32
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. Ptr b -> Int -> Word32 -> IO () :: *)))
      (Foreign.Storable.$fStorableWord11
       `cast` (<Ptr Word32>_R ->_R Sym (GHC.Types.N:IO[0] <Word32>_R)
               :: (Ptr Word32
                   -> State# RealWorld -> (# State# RealWorld, Word32 #) :: *)
                  ~R# (Ptr Word32 -> IO Word32 :: *)))
      (Foreign.Storable.$fStorableWord10
       `cast` (<Ptr Word32>_R
               ->_R <Word32>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Word32
                   -> Word32 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Word32 -> Word32 -> IO () :: *)))

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord6
  :: Ptr Word16 -> State# RealWorld -> (# State# RealWorld, Word16 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4Dj3 [Occ=Once!] :: Ptr Word16)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dj3 of { Ptr a_a4ANJ [Occ=Once] ->
                 case readWord16OffAddr# @ RealWorld a_a4ANJ 0# eta_B1 of
                 { (# ipv_s4B6p [Occ=Once], ipv1_s4B6q [Occ=Once] #) ->
                 (# ipv_s4B6p, GHC.Word.W16# ipv1_s4B6q #)
                 }
                 }}]
Foreign.Storable.$fStorableWord6
  = \ (ptr_X4Dj3 :: Ptr Word16) (eta_B1 :: State# RealWorld) ->
      case ptr_X4Dj3 of { Ptr a_a4ANJ ->
      case readWord16OffAddr# @ RealWorld a_a4ANJ 0# eta_B1 of
      { (# ipv_s4B6p, ipv1_s4B6q #) ->
      (# ipv_s4B6p, GHC.Word.W16# ipv1_s4B6q #)
      }
      }

-- RHS size: {terms: 22, types: 31, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord9
  :: forall b.
     Ptr b -> Int -> State# RealWorld -> (# State# RealWorld, Word16 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4Dna)
                 (ptr_X4De2 [Occ=Once!] :: Ptr b_a4Dna)
                 (off_X4De4 [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4De2 of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4De4 of { I# d_a46Xh [Occ=Once] ->
                 case readWord16OffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
                 of
                 { (# ipv_s4B6p [Occ=Once], ipv1_s4B6q [Occ=Once] #) ->
                 (# ipv_s4B6p, GHC.Word.W16# ipv1_s4B6q #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableWord9
  = \ (@ b_a4Dna)
      (ptr_X4De2 :: Ptr b_a4Dna)
      (off_X4De4 :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4De2 of { Ptr addr_a46Xg ->
      case off_X4De4 of { I# d_a46Xh ->
      case readWord16OffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
      of
      { (# ipv_s4B6p, ipv1_s4B6q #) ->
      (# ipv_s4B6p, GHC.Word.W16# ipv1_s4B6q #)
      }
      }
      }

-- RHS size: {terms: 19, types: 20, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord5
  :: Ptr Word16
     -> Word16 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4Ddu [Occ=Once!] :: Ptr Word16)
                 (ds2_d4AZC [Occ=Once!] :: Word16)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Ddu of { Ptr a_a4AP1 [Occ=Once] ->
                 case ds2_d4AZC of { W16# x_a4AP3 [Occ=Once] ->
                 case writeWord16OffAddr# @ RealWorld a_a4AP1 0# x_a4AP3 eta_B1
                 of s2_a4AP5
                 { __DEFAULT ->
                 (# s2_a4AP5, GHC.Tuple.() #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableWord5
  = \ (ptr_X4Ddu :: Ptr Word16)
      (ds2_d4AZC :: Word16)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Ddu of { Ptr a_a4AP1 ->
      case ds2_d4AZC of { W16# x_a4AP3 ->
      case writeWord16OffAddr# @ RealWorld a_a4AP1 0# x_a4AP3 eta_B1
      of s2_a4AP5
      { __DEFAULT ->
      (# s2_a4AP5, GHC.Tuple.() #)
      }
      }
      }

-- RHS size: {terms: 26, types: 25, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord7
  :: forall b.
     Ptr b
     -> Int -> Word16 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4Dni)
                 (ptr_X4Deb [Occ=Once!] :: Ptr b_a4Dni)
                 (off_X4Ded [Occ=Once!] :: Int)
                 (eta_X5J [Occ=Once!] :: Word16)
                 (eta1_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Deb of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4Ded of { I# d_a46Xh [Occ=Once] ->
                 case eta_X5J of { W16# x_a4AP3 [Occ=Once] ->
                 case writeWord16OffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AP3 eta1_B1
                 of s2_a4AP5
                 { __DEFAULT ->
                 (# s2_a4AP5, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
Foreign.Storable.$fStorableWord7
  = \ (@ b_a4Dni)
      (ptr_X4Deb :: Ptr b_a4Dni)
      (off_X4Ded :: Int)
      (eta_X5J :: Word16)
      (eta1_B1 :: State# RealWorld) ->
      case ptr_X4Deb of { Ptr addr_a46Xg ->
      case off_X4Ded of { I# d_a46Xh ->
      case eta_X5J of { W16# x_a4AP3 ->
      case writeWord16OffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AP3 eta1_B1
      of s2_a4AP5
      { __DEFAULT ->
      (# s2_a4AP5, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 56, joins: 0/0}
Foreign.Storable.$fStorableWord16 [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable Word16
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: Word16
                                   Foreign.Storable.$fStorableWord16_$calignment
                                   Foreign.Storable.$fStorableWord16_$calignment
                                   GHC.Storable.readWord16OffPtr1
                                   `cast` (<Ptr Word16>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Word16>_R)
                                           :: (Ptr Word16
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word16 #) :: *)
                                              ~R# (Ptr Word16 -> Int -> IO Word16 :: *))
                                   GHC.Storable.writeWord16OffPtr1
                                   `cast` (<Ptr Word16>_R
                                           ->_R <Int>_R
                                           ->_R <Word16>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Word16
                                               -> Int
                                               -> Word16
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Word16 -> Int -> Word16 -> IO () :: *))
                                   Foreign.Storable.$fStorableWord9
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Word16>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word16 #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> IO Word16 :: *))
                                   Foreign.Storable.$fStorableWord7
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <Word16>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> Word16
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> Word16 -> IO () :: *))
                                   Foreign.Storable.$fStorableWord6
                                   `cast` (<Ptr Word16>_R ->_R Sym (GHC.Types.N:IO[0] <Word16>_R)
                                           :: (Ptr Word16
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word16 #) :: *)
                                              ~R# (Ptr Word16 -> IO Word16 :: *))
                                   Foreign.Storable.$fStorableWord5
                                   `cast` (<Ptr Word16>_R
                                           ->_R <Word16>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Word16
                                               -> Word16
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Word16 -> Word16 -> IO () :: *))]
Foreign.Storable.$fStorableWord16
  = Foreign.Storable.C:Storable
      @ Word16
      Foreign.Storable.$fStorableWord16_$calignment
      Foreign.Storable.$fStorableWord16_$calignment
      (GHC.Storable.readWord16OffPtr1
       `cast` (<Ptr Word16>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] <Word16>_R)
               :: (Ptr Word16
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word16 #) :: *)
                  ~R# (Ptr Word16 -> Int -> IO Word16 :: *)))
      (GHC.Storable.writeWord16OffPtr1
       `cast` (<Ptr Word16>_R
               ->_R <Int>_R
               ->_R <Word16>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Word16
                   -> Int
                   -> Word16
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Word16 -> Int -> Word16 -> IO () :: *)))
      (Foreign.Storable.$fStorableWord9
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R ->_R <Int>_R ->_R Sym (GHC.Types.N:IO[0] <Word16>_R)
               :: (forall b.
                   Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word16 #) :: *)
                  ~R# (forall b. Ptr b -> Int -> IO Word16 :: *)))
      (Foreign.Storable.$fStorableWord7
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R
               ->_R <Int>_R
               ->_R <Word16>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   Ptr b
                   -> Int
                   -> Word16
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. Ptr b -> Int -> Word16 -> IO () :: *)))
      (Foreign.Storable.$fStorableWord6
       `cast` (<Ptr Word16>_R ->_R Sym (GHC.Types.N:IO[0] <Word16>_R)
               :: (Ptr Word16
                   -> State# RealWorld -> (# State# RealWorld, Word16 #) :: *)
                  ~R# (Ptr Word16 -> IO Word16 :: *)))
      (Foreign.Storable.$fStorableWord5
       `cast` (<Ptr Word16>_R
               ->_R <Word16>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Word16
                   -> Word16 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Word16 -> Word16 -> IO () :: *)))

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableDouble2
  :: Ptr Double -> State# RealWorld -> (# State# RealWorld, Double #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4DdJ [Occ=Once!] :: Ptr Double)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DdJ of { Ptr a_a4ANk [Occ=Once] ->
                 case readDoubleOffAddr# @ RealWorld a_a4ANk 0# eta_B1 of
                 { (# ipv_s4B5V [Occ=Once], ipv1_s4B5W [Occ=Once] #) ->
                 (# ipv_s4B5V, GHC.Types.D# ipv1_s4B5W #)
                 }
                 }}]
Foreign.Storable.$fStorableDouble2
  = \ (ptr_X4DdJ :: Ptr Double) (eta_B1 :: State# RealWorld) ->
      case ptr_X4DdJ of { Ptr a_a4ANk ->
      case readDoubleOffAddr# @ RealWorld a_a4ANk 0# eta_B1 of
      { (# ipv_s4B5V, ipv1_s4B5W #) ->
      (# ipv_s4B5V, GHC.Types.D# ipv1_s4B5W #)
      }
      }

-- RHS size: {terms: 22, types: 31, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableDouble4
  :: forall b.
     Ptr b -> Int -> State# RealWorld -> (# State# RealWorld, Double #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4DoA)
                 (ptr_X4Dei [Occ=Once!] :: Ptr b_a4DoA)
                 (off_X4Dek [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dei of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4Dek of { I# d_a46Xh [Occ=Once] ->
                 case readDoubleOffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
                 of
                 { (# ipv_s4B5V [Occ=Once], ipv1_s4B5W [Occ=Once] #) ->
                 (# ipv_s4B5V, GHC.Types.D# ipv1_s4B5W #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableDouble4
  = \ (@ b_a4DoA)
      (ptr_X4Dei :: Ptr b_a4DoA)
      (off_X4Dek :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Dei of { Ptr addr_a46Xg ->
      case off_X4Dek of { I# d_a46Xh ->
      case readDoubleOffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
      of
      { (# ipv_s4B5V, ipv1_s4B5W #) ->
      (# ipv_s4B5V, GHC.Types.D# ipv1_s4B5W #)
      }
      }
      }

-- RHS size: {terms: 19, types: 20, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableDouble1
  :: Ptr Double
     -> Double -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4Djx [Occ=Once!] :: Ptr Double)
                 (ds2_d4B0A [Occ=Once!] :: Double)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Djx of { Ptr a_a4AOC [Occ=Once] ->
                 case ds2_d4B0A of { D# x_a4AOE [Occ=Once] ->
                 case writeDoubleOffAddr# @ RealWorld a_a4AOC 0# x_a4AOE eta_B1
                 of s2_a4AOG
                 { __DEFAULT ->
                 (# s2_a4AOG, GHC.Tuple.() #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableDouble1
  = \ (ptr_X4Djx :: Ptr Double)
      (ds2_d4B0A :: Double)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Djx of { Ptr a_a4AOC ->
      case ds2_d4B0A of { D# x_a4AOE ->
      case writeDoubleOffAddr# @ RealWorld a_a4AOC 0# x_a4AOE eta_B1
      of s2_a4AOG
      { __DEFAULT ->
      (# s2_a4AOG, GHC.Tuple.() #)
      }
      }
      }

-- RHS size: {terms: 26, types: 25, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableDouble3
  :: forall b.
     Ptr b
     -> Int -> Double -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4DoI)
                 (ptr_X4Der [Occ=Once!] :: Ptr b_a4DoI)
                 (off_X4Det [Occ=Once!] :: Int)
                 (eta_X5Z [Occ=Once!] :: Double)
                 (eta1_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Der of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4Det of { I# d_a46Xh [Occ=Once] ->
                 case eta_X5Z of { D# x_a4AOE [Occ=Once] ->
                 case writeDoubleOffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AOE eta1_B1
                 of s2_a4AOG
                 { __DEFAULT ->
                 (# s2_a4AOG, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
Foreign.Storable.$fStorableDouble3
  = \ (@ b_a4DoI)
      (ptr_X4Der :: Ptr b_a4DoI)
      (off_X4Det :: Int)
      (eta_X5Z :: Double)
      (eta1_B1 :: State# RealWorld) ->
      case ptr_X4Der of { Ptr addr_a46Xg ->
      case off_X4Det of { I# d_a46Xh ->
      case eta_X5Z of { D# x_a4AOE ->
      case writeDoubleOffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AOE eta1_B1
      of s2_a4AOG
      { __DEFAULT ->
      (# s2_a4AOG, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 56, joins: 0/0}
Foreign.Storable.$fStorableDouble [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable Double
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: Double
                                   Foreign.Storable.$fStorableDouble_$calignment
                                   Foreign.Storable.$fStorableDouble_$calignment
                                   GHC.Storable.readDoubleOffPtr1
                                   `cast` (<Ptr Double>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Double>_R)
                                           :: (Ptr Double
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Double #) :: *)
                                              ~R# (Ptr Double -> Int -> IO Double :: *))
                                   GHC.Storable.writeDoubleOffPtr1
                                   `cast` (<Ptr Double>_R
                                           ->_R <Int>_R
                                           ->_R <Double>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Double
                                               -> Int
                                               -> Double
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Double -> Int -> Double -> IO () :: *))
                                   Foreign.Storable.$fStorableDouble4
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Double>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Double #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> IO Double :: *))
                                   Foreign.Storable.$fStorableDouble3
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <Double>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> Double
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> Double -> IO () :: *))
                                   Foreign.Storable.$fStorableDouble2
                                   `cast` (<Ptr Double>_R ->_R Sym (GHC.Types.N:IO[0] <Double>_R)
                                           :: (Ptr Double
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Double #) :: *)
                                              ~R# (Ptr Double -> IO Double :: *))
                                   Foreign.Storable.$fStorableDouble1
                                   `cast` (<Ptr Double>_R
                                           ->_R <Double>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Double
                                               -> Double
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Double -> Double -> IO () :: *))]
Foreign.Storable.$fStorableDouble
  = Foreign.Storable.C:Storable
      @ Double
      Foreign.Storable.$fStorableDouble_$calignment
      Foreign.Storable.$fStorableDouble_$calignment
      (GHC.Storable.readDoubleOffPtr1
       `cast` (<Ptr Double>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] <Double>_R)
               :: (Ptr Double
                   -> Int -> State# RealWorld -> (# State# RealWorld, Double #) :: *)
                  ~R# (Ptr Double -> Int -> IO Double :: *)))
      (GHC.Storable.writeDoubleOffPtr1
       `cast` (<Ptr Double>_R
               ->_R <Int>_R
               ->_R <Double>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Double
                   -> Int
                   -> Double
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Double -> Int -> Double -> IO () :: *)))
      (Foreign.Storable.$fStorableDouble4
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R ->_R <Int>_R ->_R Sym (GHC.Types.N:IO[0] <Double>_R)
               :: (forall b.
                   Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Double #) :: *)
                  ~R# (forall b. Ptr b -> Int -> IO Double :: *)))
      (Foreign.Storable.$fStorableDouble3
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R
               ->_R <Int>_R
               ->_R <Double>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   Ptr b
                   -> Int
                   -> Double
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. Ptr b -> Int -> Double -> IO () :: *)))
      (Foreign.Storable.$fStorableDouble2
       `cast` (<Ptr Double>_R ->_R Sym (GHC.Types.N:IO[0] <Double>_R)
               :: (Ptr Double
                   -> State# RealWorld -> (# State# RealWorld, Double #) :: *)
                  ~R# (Ptr Double -> IO Double :: *)))
      (Foreign.Storable.$fStorableDouble1
       `cast` (<Ptr Double>_R
               ->_R <Double>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Double
                   -> Double -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Double -> Double -> IO () :: *)))

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableFloat2
  :: Ptr Float -> State# RealWorld -> (# State# RealWorld, Float #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4DdU [Occ=Once!] :: Ptr Float)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DdU of { Ptr a_a4ANf [Occ=Once] ->
                 case readFloatOffAddr# @ RealWorld a_a4ANf 0# eta_B1 of
                 { (# ipv_s4B5P [Occ=Once], ipv1_s4B5Q [Occ=Once] #) ->
                 (# ipv_s4B5P, GHC.Types.F# ipv1_s4B5Q #)
                 }
                 }}]
Foreign.Storable.$fStorableFloat2
  = \ (ptr_X4DdU :: Ptr Float) (eta_B1 :: State# RealWorld) ->
      case ptr_X4DdU of { Ptr a_a4ANf ->
      case readFloatOffAddr# @ RealWorld a_a4ANf 0# eta_B1 of
      { (# ipv_s4B5P, ipv1_s4B5Q #) ->
      (# ipv_s4B5P, GHC.Types.F# ipv1_s4B5Q #)
      }
      }

-- RHS size: {terms: 22, types: 31, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableFloat4
  :: forall b.
     Ptr b -> Int -> State# RealWorld -> (# State# RealWorld, Float #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4Dpi)
                 (ptr_X4Dey [Occ=Once!] :: Ptr b_a4Dpi)
                 (off_X4DeA [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dey of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4DeA of { I# d_a46Xh [Occ=Once] ->
                 case readFloatOffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
                 of
                 { (# ipv_s4B5P [Occ=Once], ipv1_s4B5Q [Occ=Once] #) ->
                 (# ipv_s4B5P, GHC.Types.F# ipv1_s4B5Q #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableFloat4
  = \ (@ b_a4Dpi)
      (ptr_X4Dey :: Ptr b_a4Dpi)
      (off_X4DeA :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Dey of { Ptr addr_a46Xg ->
      case off_X4DeA of { I# d_a46Xh ->
      case readFloatOffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
      of
      { (# ipv_s4B5P, ipv1_s4B5Q #) ->
      (# ipv_s4B5P, GHC.Types.F# ipv1_s4B5Q #)
      }
      }
      }

-- RHS size: {terms: 19, types: 20, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableFloat1
  :: Ptr Float
     -> Float -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4DdQ [Occ=Once!] :: Ptr Float)
                 (ds2_d4B0M [Occ=Once!] :: Float)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DdQ of { Ptr a_a4AOx [Occ=Once] ->
                 case ds2_d4B0M of { F# x_a4AOz [Occ=Once] ->
                 case writeFloatOffAddr# @ RealWorld a_a4AOx 0# x_a4AOz eta_B1
                 of s2_a4AOB
                 { __DEFAULT ->
                 (# s2_a4AOB, GHC.Tuple.() #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableFloat1
  = \ (ptr_X4DdQ :: Ptr Float)
      (ds2_d4B0M :: Float)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4DdQ of { Ptr a_a4AOx ->
      case ds2_d4B0M of { F# x_a4AOz ->
      case writeFloatOffAddr# @ RealWorld a_a4AOx 0# x_a4AOz eta_B1
      of s2_a4AOB
      { __DEFAULT ->
      (# s2_a4AOB, GHC.Tuple.() #)
      }
      }
      }

-- RHS size: {terms: 26, types: 25, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableFloat3
  :: forall b.
     Ptr b
     -> Int -> Float -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4Dpq)
                 (ptr_X4DeH [Occ=Once!] :: Ptr b_a4Dpq)
                 (off_X4DeJ [Occ=Once!] :: Int)
                 (eta_X6f [Occ=Once!] :: Float)
                 (eta1_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DeH of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4DeJ of { I# d_a46Xh [Occ=Once] ->
                 case eta_X6f of { F# x_a4AOz [Occ=Once] ->
                 case writeFloatOffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AOz eta1_B1
                 of s2_a4AOB
                 { __DEFAULT ->
                 (# s2_a4AOB, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
Foreign.Storable.$fStorableFloat3
  = \ (@ b_a4Dpq)
      (ptr_X4DeH :: Ptr b_a4Dpq)
      (off_X4DeJ :: Int)
      (eta_X6f :: Float)
      (eta1_B1 :: State# RealWorld) ->
      case ptr_X4DeH of { Ptr addr_a46Xg ->
      case off_X4DeJ of { I# d_a46Xh ->
      case eta_X6f of { F# x_a4AOz ->
      case writeFloatOffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AOz eta1_B1
      of s2_a4AOB
      { __DEFAULT ->
      (# s2_a4AOB, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 56, joins: 0/0}
Foreign.Storable.$fStorableFloat [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable Float
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: Float
                                   Foreign.Storable.$fStorableFloat_$calignment
                                   Foreign.Storable.$fStorableFloat_$calignment
                                   GHC.Storable.readFloatOffPtr1
                                   `cast` (<Ptr Float>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Float>_R)
                                           :: (Ptr Float
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Float #) :: *)
                                              ~R# (Ptr Float -> Int -> IO Float :: *))
                                   GHC.Storable.writeFloatOffPtr1
                                   `cast` (<Ptr Float>_R
                                           ->_R <Int>_R
                                           ->_R <Float>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Float
                                               -> Int
                                               -> Float
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Float -> Int -> Float -> IO () :: *))
                                   Foreign.Storable.$fStorableFloat4
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Float>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Float #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> IO Float :: *))
                                   Foreign.Storable.$fStorableFloat3
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <Float>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> Float
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> Float -> IO () :: *))
                                   Foreign.Storable.$fStorableFloat2
                                   `cast` (<Ptr Float>_R ->_R Sym (GHC.Types.N:IO[0] <Float>_R)
                                           :: (Ptr Float
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Float #) :: *)
                                              ~R# (Ptr Float -> IO Float :: *))
                                   Foreign.Storable.$fStorableFloat1
                                   `cast` (<Ptr Float>_R
                                           ->_R <Float>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Float
                                               -> Float
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Float -> Float -> IO () :: *))]
Foreign.Storable.$fStorableFloat
  = Foreign.Storable.C:Storable
      @ Float
      Foreign.Storable.$fStorableFloat_$calignment
      Foreign.Storable.$fStorableFloat_$calignment
      (GHC.Storable.readFloatOffPtr1
       `cast` (<Ptr Float>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] <Float>_R)
               :: (Ptr Float
                   -> Int -> State# RealWorld -> (# State# RealWorld, Float #) :: *)
                  ~R# (Ptr Float -> Int -> IO Float :: *)))
      (GHC.Storable.writeFloatOffPtr1
       `cast` (<Ptr Float>_R
               ->_R <Int>_R
               ->_R <Float>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Float
                   -> Int
                   -> Float
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Float -> Int -> Float -> IO () :: *)))
      (Foreign.Storable.$fStorableFloat4
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R ->_R <Int>_R ->_R Sym (GHC.Types.N:IO[0] <Float>_R)
               :: (forall b.
                   Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Float #) :: *)
                  ~R# (forall b. Ptr b -> Int -> IO Float :: *)))
      (Foreign.Storable.$fStorableFloat3
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R
               ->_R <Int>_R
               ->_R <Float>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   Ptr b
                   -> Int
                   -> Float
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. Ptr b -> Int -> Float -> IO () :: *)))
      (Foreign.Storable.$fStorableFloat2
       `cast` (<Ptr Float>_R ->_R Sym (GHC.Types.N:IO[0] <Float>_R)
               :: (Ptr Float
                   -> State# RealWorld -> (# State# RealWorld, Float #) :: *)
                  ~R# (Ptr Float -> IO Float :: *)))
      (Foreign.Storable.$fStorableFloat1
       `cast` (<Ptr Float>_R
               ->_R <Float>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Float
                   -> Float -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Float -> Float -> IO () :: *)))

-- RHS size: {terms: 16, types: 35, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableStablePtr2
  :: forall a.
     Ptr (StablePtr a)
     -> State# RealWorld -> (# State# RealWorld, StablePtr a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4DpH)
                 (ptr_X4DjC [Occ=Once!] :: Ptr (StablePtr a_a4DpH))
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DjC of { Ptr a1_a4ANp [Occ=Once] ->
                 case readStablePtrOffAddr# @ RealWorld @ a_a4DpH a1_a4ANp 0# eta_B1
                 of
                 { (# ipv_s4B61 [Occ=Once], ipv1_s4B62 [Occ=Once] #) ->
                 (# ipv_s4B61, GHC.Stable.StablePtr @ a_a4DpH ipv1_s4B62 #)
                 }
                 }}]
Foreign.Storable.$fStorableStablePtr2
  = \ (@ a_a4DpH)
      (ptr_X4DjC :: Ptr (StablePtr a_a4DpH))
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4DjC of { Ptr a1_a4ANp ->
      case readStablePtrOffAddr# @ RealWorld @ a_a4DpH a1_a4ANp 0# eta_B1
      of
      { (# ipv_s4B61, ipv1_s4B62 #) ->
      (# ipv_s4B61, GHC.Stable.StablePtr @ a_a4DpH ipv1_s4B62 #)
      }
      }

-- RHS size: {terms: 23, types: 38, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableStablePtr4
  :: forall a b.
     Ptr b
     -> Int -> State# RealWorld -> (# State# RealWorld, StablePtr a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4DpH)
                 (@ b_a4Dq3)
                 (ptr_X4DeP [Occ=Once!] :: Ptr b_a4Dq3)
                 (off_X4DeR [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DeP of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4DeR of { I# d_a46Xh [Occ=Once] ->
                 case readStablePtrOffAddr#
                        @ RealWorld @ a_a4DpH (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
                 of
                 { (# ipv_s4B61 [Occ=Once], ipv1_s4B62 [Occ=Once] #) ->
                 (# ipv_s4B61, GHC.Stable.StablePtr @ a_a4DpH ipv1_s4B62 #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableStablePtr4
  = \ (@ a_a4DpH)
      (@ b_a4Dq3)
      (ptr_X4DeP :: Ptr b_a4Dq3)
      (off_X4DeR :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4DeP of { Ptr addr_a46Xg ->
      case off_X4DeR of { I# d_a46Xh ->
      case readStablePtrOffAddr#
             @ RealWorld @ a_a4DpH (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
      of
      { (# ipv_s4B61, ipv1_s4B62 #) ->
      (# ipv_s4B61, GHC.Stable.StablePtr @ a_a4DpH ipv1_s4B62 #)
      }
      }
      }

-- RHS size: {terms: 20, types: 28, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableStablePtr1
  :: forall a.
     Ptr (StablePtr a)
     -> StablePtr a -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X4Dw6)
                 (ptr_X4Djx [Occ=Once!] :: Ptr (StablePtr a_X4Dw6))
                 (ds2_d4B0o [Occ=Once!] :: StablePtr a_X4Dw6)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Djx of { Ptr a1_a4AOH [Occ=Once] ->
                 case ds2_d4B0o of { GHC.Stable.StablePtr x_a4AOJ [Occ=Once] ->
                 case writeStablePtrOffAddr#
                        @ a_X4Dw6 @ RealWorld a1_a4AOH 0# x_a4AOJ eta_B1
                 of s2_a4AOL
                 { __DEFAULT ->
                 (# s2_a4AOL, GHC.Tuple.() #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableStablePtr1
  = \ (@ a_X4Dw6)
      (ptr_X4Djx :: Ptr (StablePtr a_X4Dw6))
      (ds2_d4B0o :: StablePtr a_X4Dw6)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Djx of { Ptr a1_a4AOH ->
      case ds2_d4B0o of { GHC.Stable.StablePtr x_a4AOJ ->
      case writeStablePtrOffAddr#
             @ a_X4Dw6 @ RealWorld a1_a4AOH 0# x_a4AOJ eta_B1
      of s2_a4AOL
      { __DEFAULT ->
      (# s2_a4AOL, GHC.Tuple.() #)
      }
      }
      }

-- RHS size: {terms: 27, types: 31, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableStablePtr3
  :: forall a b.
     Ptr b
     -> Int
     -> StablePtr a
     -> State# RealWorld
     -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X4Dw8)
                 (@ b_a4Dqb)
                 (ptr_X4DeZ [Occ=Once!] :: Ptr b_a4Dqb)
                 (off_X4Df1 [Occ=Once!] :: Int)
                 (eta_X6x [Occ=Once!] :: StablePtr a_X4Dw8)
                 (eta1_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DeZ of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4Df1 of { I# d_a46Xh [Occ=Once] ->
                 case eta_X6x of { GHC.Stable.StablePtr x_a4AOJ [Occ=Once] ->
                 case writeStablePtrOffAddr#
                        @ a_X4Dw8
                        @ RealWorld
                        (plusAddr# addr_a46Xg d_a46Xh)
                        0#
                        x_a4AOJ
                        eta1_B1
                 of s2_a4AOL
                 { __DEFAULT ->
                 (# s2_a4AOL, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
Foreign.Storable.$fStorableStablePtr3
  = \ (@ a_X4Dw8)
      (@ b_a4Dqb)
      (ptr_X4DeZ :: Ptr b_a4Dqb)
      (off_X4Df1 :: Int)
      (eta_X6x :: StablePtr a_X4Dw8)
      (eta1_B1 :: State# RealWorld) ->
      case ptr_X4DeZ of { Ptr addr_a46Xg ->
      case off_X4Df1 of { I# d_a46Xh ->
      case eta_X6x of { GHC.Stable.StablePtr x_a4AOJ ->
      case writeStablePtrOffAddr#
             @ a_X4Dw8
             @ RealWorld
             (plusAddr# addr_a46Xg d_a46Xh)
             0#
             x_a4AOJ
             eta1_B1
      of s2_a4AOL
      { __DEFAULT ->
      (# s2_a4AOL, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 10, types: 12, coercions: 66, joins: 0/0}
Foreign.Storable.$fStorableStablePtr [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Storable (StablePtr a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_a4D8J) ->
       Foreign.Storable.C:Storable TYPE: StablePtr a_a4D8J
                                   Foreign.Storable.$fStorableStablePtr_$calignment @ a_a4D8J
                                   Foreign.Storable.$fStorableStablePtr_$calignment @ a_a4D8J
                                   (GHC.Storable.readStablePtrOffPtr1 @ a_a4D8J)
                                   `cast` (<Ptr (StablePtr a_a4D8J)>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <StablePtr a_a4D8J>_R)
                                           :: (Ptr (StablePtr a_a4D8J)
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, StablePtr a_a4D8J #) :: *)
                                              ~R# (Ptr (StablePtr a_a4D8J)
                                                   -> Int -> IO (StablePtr a_a4D8J) :: *))
                                   (GHC.Storable.writeStablePtrOffPtr1 @ a_a4D8J)
                                   `cast` (<Ptr (StablePtr a_a4D8J)>_R
                                           ->_R <Int>_R
                                           ->_R <StablePtr a_a4D8J>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr (StablePtr a_a4D8J)
                                               -> Int
                                               -> StablePtr a_a4D8J
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr (StablePtr a_a4D8J)
                                                   -> Int -> StablePtr a_a4D8J -> IO () :: *))
                                   (Foreign.Storable.$fStorableStablePtr4 @ a_a4D8J)
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <StablePtr a_a4D8J>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, StablePtr a_a4D8J #) :: *)
                                              ~R# (forall b.
                                                   Ptr b -> Int -> IO (StablePtr a_a4D8J) :: *))
                                   (Foreign.Storable.$fStorableStablePtr3 @ a_a4D8J)
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <StablePtr a_a4D8J>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> StablePtr a_a4D8J
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   Ptr b -> Int -> StablePtr a_a4D8J -> IO () :: *))
                                   (Foreign.Storable.$fStorableStablePtr2 @ a_a4D8J)
                                   `cast` (<Ptr (StablePtr a_a4D8J)>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <StablePtr a_a4D8J>_R)
                                           :: (Ptr (StablePtr a_a4D8J)
                                               -> State# RealWorld
                                               -> (# State# RealWorld, StablePtr a_a4D8J #) :: *)
                                              ~R# (Ptr (StablePtr a_a4D8J)
                                                   -> IO (StablePtr a_a4D8J) :: *))
                                   (Foreign.Storable.$fStorableStablePtr1 @ a_a4D8J)
                                   `cast` (<Ptr (StablePtr a_a4D8J)>_R
                                           ->_R <StablePtr a_a4D8J>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr (StablePtr a_a4D8J)
                                               -> StablePtr a_a4D8J
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr (StablePtr a_a4D8J)
                                                   -> StablePtr a_a4D8J -> IO () :: *))]
Foreign.Storable.$fStorableStablePtr
  = \ (@ a_X4Dwf) ->
      Foreign.Storable.C:Storable
        @ (StablePtr a_X4Dwf)
        (Foreign.Storable.$fStorableStablePtr_$calignment @ a_X4Dwf)
        (Foreign.Storable.$fStorableStablePtr_$calignment @ a_X4Dwf)
        ((GHC.Storable.readStablePtrOffPtr1 @ a_X4Dwf)
         `cast` (<Ptr (StablePtr a_X4Dwf)>_R
                 ->_R <Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <StablePtr a_X4Dwf>_R)
                 :: (Ptr (StablePtr a_X4Dwf)
                     -> Int
                     -> State# RealWorld
                     -> (# State# RealWorld, StablePtr a_X4Dwf #) :: *)
                    ~R# (Ptr (StablePtr a_X4Dwf)
                         -> Int -> IO (StablePtr a_X4Dwf) :: *)))
        ((GHC.Storable.writeStablePtrOffPtr1 @ a_X4Dwf)
         `cast` (<Ptr (StablePtr a_X4Dwf)>_R
                 ->_R <Int>_R
                 ->_R <StablePtr a_X4Dwf>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                 :: (Ptr (StablePtr a_X4Dwf)
                     -> Int
                     -> StablePtr a_X4Dwf
                     -> State# RealWorld
                     -> (# State# RealWorld, () #) :: *)
                    ~R# (Ptr (StablePtr a_X4Dwf)
                         -> Int -> StablePtr a_X4Dwf -> IO () :: *)))
        ((Foreign.Storable.$fStorableStablePtr4 @ a_X4Dwf)
         `cast` (forall (b :: <*>_N).
                 <Ptr b>_R
                 ->_R <Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <StablePtr a_X4Dwf>_R)
                 :: (forall b.
                     Ptr b
                     -> Int
                     -> State# RealWorld
                     -> (# State# RealWorld, StablePtr a_X4Dwf #) :: *)
                    ~R# (forall b. Ptr b -> Int -> IO (StablePtr a_X4Dwf) :: *)))
        ((Foreign.Storable.$fStorableStablePtr3 @ a_X4Dwf)
         `cast` (forall (b :: <*>_N).
                 <Ptr b>_R
                 ->_R <Int>_R
                 ->_R <StablePtr a_X4Dwf>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                 :: (forall b.
                     Ptr b
                     -> Int
                     -> StablePtr a_X4Dwf
                     -> State# RealWorld
                     -> (# State# RealWorld, () #) :: *)
                    ~R# (forall b. Ptr b -> Int -> StablePtr a_X4Dwf -> IO () :: *)))
        ((Foreign.Storable.$fStorableStablePtr2 @ a_X4Dwf)
         `cast` (<Ptr (StablePtr a_X4Dwf)>_R
                 ->_R Sym (GHC.Types.N:IO[0] <StablePtr a_X4Dwf>_R)
                 :: (Ptr (StablePtr a_X4Dwf)
                     -> State# RealWorld
                     -> (# State# RealWorld, StablePtr a_X4Dwf #) :: *)
                    ~R# (Ptr (StablePtr a_X4Dwf) -> IO (StablePtr a_X4Dwf) :: *)))
        ((Foreign.Storable.$fStorableStablePtr1 @ a_X4Dwf)
         `cast` (<Ptr (StablePtr a_X4Dwf)>_R
                 ->_R <StablePtr a_X4Dwf>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                 :: (Ptr (StablePtr a_X4Dwf)
                     -> StablePtr a_X4Dwf
                     -> State# RealWorld
                     -> (# State# RealWorld, () #) :: *)
                    ~R# (Ptr (StablePtr a_X4Dwf) -> StablePtr a_X4Dwf -> IO () :: *)))

-- RHS size: {terms: 16, types: 32, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableFunPtr2
  :: forall a.
     Ptr (FunPtr a)
     -> State# RealWorld -> (# State# RealWorld, FunPtr a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4Dqs)
                 (ptr_X4DjQ [Occ=Once!] :: Ptr (FunPtr a_a4Dqs))
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DjQ of { Ptr a1_a4ANa [Occ=Once] ->
                 case readAddrOffAddr# @ RealWorld a1_a4ANa 0# eta_B1 of
                 { (# ipv_s4B5J [Occ=Once], ipv1_s4B5K [Occ=Once] #) ->
                 (# ipv_s4B5J, GHC.Ptr.FunPtr @ a_a4Dqs ipv1_s4B5K #)
                 }
                 }}]
Foreign.Storable.$fStorableFunPtr2
  = \ (@ a_a4Dqs)
      (ptr_X4DjQ :: Ptr (FunPtr a_a4Dqs))
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4DjQ of { Ptr a1_a4ANa ->
      case readAddrOffAddr# @ RealWorld a1_a4ANa 0# eta_B1 of
      { (# ipv_s4B5J, ipv1_s4B5K #) ->
      (# ipv_s4B5J, GHC.Ptr.FunPtr @ a_a4Dqs ipv1_s4B5K #)
      }
      }

-- RHS size: {terms: 23, types: 35, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableFunPtr4
  :: forall a b.
     Ptr b
     -> Int -> State# RealWorld -> (# State# RealWorld, FunPtr a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4Dqs)
                 (@ b_a4DqO)
                 (ptr_X4Df7 [Occ=Once!] :: Ptr b_a4DqO)
                 (off_X4Df9 [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Df7 of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4Df9 of { I# d_a46Xh [Occ=Once] ->
                 case readAddrOffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
                 of
                 { (# ipv_s4B5J [Occ=Once], ipv1_s4B5K [Occ=Once] #) ->
                 (# ipv_s4B5J, GHC.Ptr.FunPtr @ a_a4Dqs ipv1_s4B5K #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableFunPtr4
  = \ (@ a_a4Dqs)
      (@ b_a4DqO)
      (ptr_X4Df7 :: Ptr b_a4DqO)
      (off_X4Df9 :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Df7 of { Ptr addr_a46Xg ->
      case off_X4Df9 of { I# d_a46Xh ->
      case readAddrOffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
      of
      { (# ipv_s4B5J, ipv1_s4B5K #) ->
      (# ipv_s4B5J, GHC.Ptr.FunPtr @ a_a4Dqs ipv1_s4B5K #)
      }
      }
      }

-- RHS size: {terms: 20, types: 26, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableFunPtr1
  :: forall a.
     Ptr (FunPtr a)
     -> FunPtr a -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X4Dx9)
                 (ptr_X4Dpn [Occ=Once!] :: Ptr (FunPtr a_X4Dx9))
                 (ds2_d4B0Y [Occ=Once!] :: FunPtr a_X4Dx9)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dpn of { Ptr a1_a4AOs [Occ=Once] ->
                 case ds2_d4B0Y of { FunPtr x_a4AOu [Occ=Once] ->
                 case writeAddrOffAddr# @ RealWorld a1_a4AOs 0# x_a4AOu eta_B1
                 of s2_a4AOw
                 { __DEFAULT ->
                 (# s2_a4AOw, GHC.Tuple.() #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableFunPtr1
  = \ (@ a_X4Dx9)
      (ptr_X4Dpn :: Ptr (FunPtr a_X4Dx9))
      (ds2_d4B0Y :: FunPtr a_X4Dx9)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Dpn of { Ptr a1_a4AOs ->
      case ds2_d4B0Y of { FunPtr x_a4AOu ->
      case writeAddrOffAddr# @ RealWorld a1_a4AOs 0# x_a4AOu eta_B1
      of s2_a4AOw
      { __DEFAULT ->
      (# s2_a4AOw, GHC.Tuple.() #)
      }
      }
      }

-- RHS size: {terms: 27, types: 29, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableFunPtr3
  :: forall a b.
     Ptr b
     -> Int
     -> FunPtr a
     -> State# RealWorld
     -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X4Dxb)
                 (@ b_a4DqW)
                 (ptr_X4Dfh [Occ=Once!] :: Ptr b_a4DqW)
                 (off_X4Dfj [Occ=Once!] :: Int)
                 (eta_X6P [Occ=Once!] :: FunPtr a_X4Dxb)
                 (eta1_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dfh of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4Dfj of { I# d_a46Xh [Occ=Once] ->
                 case eta_X6P of { FunPtr x_a4AOu [Occ=Once] ->
                 case writeAddrOffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AOu eta1_B1
                 of s2_a4AOw
                 { __DEFAULT ->
                 (# s2_a4AOw, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
Foreign.Storable.$fStorableFunPtr3
  = \ (@ a_X4Dxb)
      (@ b_a4DqW)
      (ptr_X4Dfh :: Ptr b_a4DqW)
      (off_X4Dfj :: Int)
      (eta_X6P :: FunPtr a_X4Dxb)
      (eta1_B1 :: State# RealWorld) ->
      case ptr_X4Dfh of { Ptr addr_a46Xg ->
      case off_X4Dfj of { I# d_a46Xh ->
      case eta_X6P of { FunPtr x_a4AOu ->
      case writeAddrOffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AOu eta1_B1
      of s2_a4AOw
      { __DEFAULT ->
      (# s2_a4AOw, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 10, types: 12, coercions: 66, joins: 0/0}
Foreign.Storable.$fStorableFunPtr [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Storable (FunPtr a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_a4D8K) ->
       Foreign.Storable.C:Storable TYPE: FunPtr a_a4D8K
                                   Foreign.Storable.$fStorableFunPtr_$calignment @ a_a4D8K
                                   Foreign.Storable.$fStorableFunPtr_$calignment @ a_a4D8K
                                   (GHC.Storable.readFunPtrOffPtr1 @ a_a4D8K)
                                   `cast` (<Ptr (FunPtr a_a4D8K)>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <FunPtr a_a4D8K>_R)
                                           :: (Ptr (FunPtr a_a4D8K)
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, FunPtr a_a4D8K #) :: *)
                                              ~R# (Ptr (FunPtr a_a4D8K)
                                                   -> Int -> IO (FunPtr a_a4D8K) :: *))
                                   (GHC.Storable.writeFunPtrOffPtr1 @ a_a4D8K)
                                   `cast` (<Ptr (FunPtr a_a4D8K)>_R
                                           ->_R <Int>_R
                                           ->_R <FunPtr a_a4D8K>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr (FunPtr a_a4D8K)
                                               -> Int
                                               -> FunPtr a_a4D8K
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr (FunPtr a_a4D8K)
                                                   -> Int -> FunPtr a_a4D8K -> IO () :: *))
                                   (Foreign.Storable.$fStorableFunPtr4 @ a_a4D8K)
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <FunPtr a_a4D8K>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, FunPtr a_a4D8K #) :: *)
                                              ~R# (forall b.
                                                   Ptr b -> Int -> IO (FunPtr a_a4D8K) :: *))
                                   (Foreign.Storable.$fStorableFunPtr3 @ a_a4D8K)
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <FunPtr a_a4D8K>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> FunPtr a_a4D8K
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   Ptr b -> Int -> FunPtr a_a4D8K -> IO () :: *))
                                   (Foreign.Storable.$fStorableFunPtr2 @ a_a4D8K)
                                   `cast` (<Ptr (FunPtr a_a4D8K)>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <FunPtr a_a4D8K>_R)
                                           :: (Ptr (FunPtr a_a4D8K)
                                               -> State# RealWorld
                                               -> (# State# RealWorld, FunPtr a_a4D8K #) :: *)
                                              ~R# (Ptr (FunPtr a_a4D8K)
                                                   -> IO (FunPtr a_a4D8K) :: *))
                                   (Foreign.Storable.$fStorableFunPtr1 @ a_a4D8K)
                                   `cast` (<Ptr (FunPtr a_a4D8K)>_R
                                           ->_R <FunPtr a_a4D8K>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr (FunPtr a_a4D8K)
                                               -> FunPtr a_a4D8K
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr (FunPtr a_a4D8K)
                                                   -> FunPtr a_a4D8K -> IO () :: *))]
Foreign.Storable.$fStorableFunPtr
  = \ (@ a_X4Dxi) ->
      Foreign.Storable.C:Storable
        @ (FunPtr a_X4Dxi)
        (Foreign.Storable.$fStorableFunPtr_$calignment @ a_X4Dxi)
        (Foreign.Storable.$fStorableFunPtr_$calignment @ a_X4Dxi)
        ((GHC.Storable.readFunPtrOffPtr1 @ a_X4Dxi)
         `cast` (<Ptr (FunPtr a_X4Dxi)>_R
                 ->_R <Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <FunPtr a_X4Dxi>_R)
                 :: (Ptr (FunPtr a_X4Dxi)
                     -> Int
                     -> State# RealWorld
                     -> (# State# RealWorld, FunPtr a_X4Dxi #) :: *)
                    ~R# (Ptr (FunPtr a_X4Dxi) -> Int -> IO (FunPtr a_X4Dxi) :: *)))
        ((GHC.Storable.writeFunPtrOffPtr1 @ a_X4Dxi)
         `cast` (<Ptr (FunPtr a_X4Dxi)>_R
                 ->_R <Int>_R
                 ->_R <FunPtr a_X4Dxi>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                 :: (Ptr (FunPtr a_X4Dxi)
                     -> Int
                     -> FunPtr a_X4Dxi
                     -> State# RealWorld
                     -> (# State# RealWorld, () #) :: *)
                    ~R# (Ptr (FunPtr a_X4Dxi) -> Int -> FunPtr a_X4Dxi -> IO () :: *)))
        ((Foreign.Storable.$fStorableFunPtr4 @ a_X4Dxi)
         `cast` (forall (b :: <*>_N).
                 <Ptr b>_R
                 ->_R <Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <FunPtr a_X4Dxi>_R)
                 :: (forall b.
                     Ptr b
                     -> Int
                     -> State# RealWorld
                     -> (# State# RealWorld, FunPtr a_X4Dxi #) :: *)
                    ~R# (forall b. Ptr b -> Int -> IO (FunPtr a_X4Dxi) :: *)))
        ((Foreign.Storable.$fStorableFunPtr3 @ a_X4Dxi)
         `cast` (forall (b :: <*>_N).
                 <Ptr b>_R
                 ->_R <Int>_R
                 ->_R <FunPtr a_X4Dxi>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                 :: (forall b.
                     Ptr b
                     -> Int
                     -> FunPtr a_X4Dxi
                     -> State# RealWorld
                     -> (# State# RealWorld, () #) :: *)
                    ~R# (forall b. Ptr b -> Int -> FunPtr a_X4Dxi -> IO () :: *)))
        ((Foreign.Storable.$fStorableFunPtr2 @ a_X4Dxi)
         `cast` (<Ptr (FunPtr a_X4Dxi)>_R
                 ->_R Sym (GHC.Types.N:IO[0] <FunPtr a_X4Dxi>_R)
                 :: (Ptr (FunPtr a_X4Dxi)
                     -> State# RealWorld -> (# State# RealWorld, FunPtr a_X4Dxi #) :: *)
                    ~R# (Ptr (FunPtr a_X4Dxi) -> IO (FunPtr a_X4Dxi) :: *)))
        ((Foreign.Storable.$fStorableFunPtr1 @ a_X4Dxi)
         `cast` (<Ptr (FunPtr a_X4Dxi)>_R
                 ->_R <FunPtr a_X4Dxi>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                 :: (Ptr (FunPtr a_X4Dxi)
                     -> FunPtr a_X4Dxi
                     -> State# RealWorld
                     -> (# State# RealWorld, () #) :: *)
                    ~R# (Ptr (FunPtr a_X4Dxi) -> FunPtr a_X4Dxi -> IO () :: *)))

-- RHS size: {terms: 16, types: 32, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorablePtr2
  :: forall a.
     Ptr (Ptr a) -> State# RealWorld -> (# State# RealWorld, Ptr a #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4Drd)
                 (ptr_X4Dk4 [Occ=Once!] :: Ptr (Ptr a_a4Drd))
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dk4 of { Ptr a1_a4AN5 [Occ=Once] ->
                 case readAddrOffAddr# @ RealWorld a1_a4AN5 0# eta_B1 of
                 { (# ipv_s4B5D [Occ=Once], ipv1_s4B5E [Occ=Once] #) ->
                 (# ipv_s4B5D, GHC.Ptr.Ptr @ a_a4Drd ipv1_s4B5E #)
                 }
                 }}]
Foreign.Storable.$fStorablePtr2
  = \ (@ a_a4Drd)
      (ptr_X4Dk4 :: Ptr (Ptr a_a4Drd))
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Dk4 of { Ptr a1_a4AN5 ->
      case readAddrOffAddr# @ RealWorld a1_a4AN5 0# eta_B1 of
      { (# ipv_s4B5D, ipv1_s4B5E #) ->
      (# ipv_s4B5D, GHC.Ptr.Ptr @ a_a4Drd ipv1_s4B5E #)
      }
      }

-- RHS size: {terms: 23, types: 35, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorablePtr4
  :: forall a b.
     Ptr b -> Int -> State# RealWorld -> (# State# RealWorld, Ptr a #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4Drd)
                 (@ b_a4Drz)
                 (ptr_X4Dfp [Occ=Once!] :: Ptr b_a4Drz)
                 (off_X4Dfr [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dfp of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4Dfr of { I# d_a46Xh [Occ=Once] ->
                 case readAddrOffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
                 of
                 { (# ipv_s4B5D [Occ=Once], ipv1_s4B5E [Occ=Once] #) ->
                 (# ipv_s4B5D, GHC.Ptr.Ptr @ a_a4Drd ipv1_s4B5E #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorablePtr4
  = \ (@ a_a4Drd)
      (@ b_a4Drz)
      (ptr_X4Dfp :: Ptr b_a4Drz)
      (off_X4Dfr :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Dfp of { Ptr addr_a46Xg ->
      case off_X4Dfr of { I# d_a46Xh ->
      case readAddrOffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
      of
      { (# ipv_s4B5D, ipv1_s4B5E #) ->
      (# ipv_s4B5D, GHC.Ptr.Ptr @ a_a4Drd ipv1_s4B5E #)
      }
      }
      }

-- RHS size: {terms: 20, types: 26, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorablePtr1
  :: forall a.
     Ptr (Ptr a)
     -> Ptr a -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X4Dyc)
                 (ptr_X4DjZ [Occ=Once!] :: Ptr (Ptr a_X4Dyc))
                 (ds2_d4B1a [Occ=Once!] :: Ptr a_X4Dyc)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DjZ of { Ptr a1_a4AOn [Occ=Once] ->
                 case ds2_d4B1a of { Ptr x_a4AOp [Occ=Once] ->
                 case writeAddrOffAddr# @ RealWorld a1_a4AOn 0# x_a4AOp eta_B1
                 of s2_a4AOr
                 { __DEFAULT ->
                 (# s2_a4AOr, GHC.Tuple.() #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorablePtr1
  = \ (@ a_X4Dyc)
      (ptr_X4DjZ :: Ptr (Ptr a_X4Dyc))
      (ds2_d4B1a :: Ptr a_X4Dyc)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4DjZ of { Ptr a1_a4AOn ->
      case ds2_d4B1a of { Ptr x_a4AOp ->
      case writeAddrOffAddr# @ RealWorld a1_a4AOn 0# x_a4AOp eta_B1
      of s2_a4AOr
      { __DEFAULT ->
      (# s2_a4AOr, GHC.Tuple.() #)
      }
      }
      }

-- RHS size: {terms: 27, types: 29, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorablePtr3
  :: forall a b.
     Ptr b
     -> Int -> Ptr a -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X4Dye)
                 (@ b_a4DrH)
                 (ptr_X4Dfz [Occ=Once!] :: Ptr b_a4DrH)
                 (off_X4DfB [Occ=Once!] :: Int)
                 (eta_X77 [Occ=Once!] :: Ptr a_X4Dye)
                 (eta1_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dfz of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4DfB of { I# d_a46Xh [Occ=Once] ->
                 case eta_X77 of { Ptr x_a4AOp [Occ=Once] ->
                 case writeAddrOffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AOp eta1_B1
                 of s2_a4AOr
                 { __DEFAULT ->
                 (# s2_a4AOr, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
Foreign.Storable.$fStorablePtr3
  = \ (@ a_X4Dye)
      (@ b_a4DrH)
      (ptr_X4Dfz :: Ptr b_a4DrH)
      (off_X4DfB :: Int)
      (eta_X77 :: Ptr a_X4Dye)
      (eta1_B1 :: State# RealWorld) ->
      case ptr_X4Dfz of { Ptr addr_a46Xg ->
      case off_X4DfB of { I# d_a46Xh ->
      case eta_X77 of { Ptr x_a4AOp ->
      case writeAddrOffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AOp eta1_B1
      of s2_a4AOr
      { __DEFAULT ->
      (# s2_a4AOr, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 10, types: 12, coercions: 66, joins: 0/0}
Foreign.Storable.$fStorablePtr [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. Storable (Ptr a)
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ (@ a_a4D8L) ->
       Foreign.Storable.C:Storable TYPE: Ptr a_a4D8L
                                   Foreign.Storable.$fStorablePtr_$calignment @ a_a4D8L
                                   Foreign.Storable.$fStorablePtr_$calignment @ a_a4D8L
                                   (GHC.Storable.readPtrOffPtr1 @ a_a4D8L)
                                   `cast` (<Ptr (Ptr a_a4D8L)>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Ptr a_a4D8L>_R)
                                           :: (Ptr (Ptr a_a4D8L)
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Ptr a_a4D8L #) :: *)
                                              ~R# (Ptr (Ptr a_a4D8L)
                                                   -> Int -> IO (Ptr a_a4D8L) :: *))
                                   (GHC.Storable.writePtrOffPtr1 @ a_a4D8L)
                                   `cast` (<Ptr (Ptr a_a4D8L)>_R
                                           ->_R <Int>_R
                                           ->_R <Ptr a_a4D8L>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr (Ptr a_a4D8L)
                                               -> Int
                                               -> Ptr a_a4D8L
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr (Ptr a_a4D8L)
                                                   -> Int -> Ptr a_a4D8L -> IO () :: *))
                                   (Foreign.Storable.$fStorablePtr4 @ a_a4D8L)
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Ptr a_a4D8L>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Ptr a_a4D8L #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> IO (Ptr a_a4D8L) :: *))
                                   (Foreign.Storable.$fStorablePtr3 @ a_a4D8L)
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <Ptr a_a4D8L>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> Ptr a_a4D8L
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   Ptr b -> Int -> Ptr a_a4D8L -> IO () :: *))
                                   (Foreign.Storable.$fStorablePtr2 @ a_a4D8L)
                                   `cast` (<Ptr (Ptr a_a4D8L)>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Ptr a_a4D8L>_R)
                                           :: (Ptr (Ptr a_a4D8L)
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Ptr a_a4D8L #) :: *)
                                              ~R# (Ptr (Ptr a_a4D8L) -> IO (Ptr a_a4D8L) :: *))
                                   (Foreign.Storable.$fStorablePtr1 @ a_a4D8L)
                                   `cast` (<Ptr (Ptr a_a4D8L)>_R
                                           ->_R <Ptr a_a4D8L>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr (Ptr a_a4D8L)
                                               -> Ptr a_a4D8L
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr (Ptr a_a4D8L) -> Ptr a_a4D8L -> IO () :: *))]
Foreign.Storable.$fStorablePtr
  = \ (@ a_X4Dyl) ->
      Foreign.Storable.C:Storable
        @ (Ptr a_X4Dyl)
        (Foreign.Storable.$fStorablePtr_$calignment @ a_X4Dyl)
        (Foreign.Storable.$fStorablePtr_$calignment @ a_X4Dyl)
        ((GHC.Storable.readPtrOffPtr1 @ a_X4Dyl)
         `cast` (<Ptr (Ptr a_X4Dyl)>_R
                 ->_R <Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Ptr a_X4Dyl>_R)
                 :: (Ptr (Ptr a_X4Dyl)
                     -> Int
                     -> State# RealWorld
                     -> (# State# RealWorld, Ptr a_X4Dyl #) :: *)
                    ~R# (Ptr (Ptr a_X4Dyl) -> Int -> IO (Ptr a_X4Dyl) :: *)))
        ((GHC.Storable.writePtrOffPtr1 @ a_X4Dyl)
         `cast` (<Ptr (Ptr a_X4Dyl)>_R
                 ->_R <Int>_R
                 ->_R <Ptr a_X4Dyl>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                 :: (Ptr (Ptr a_X4Dyl)
                     -> Int
                     -> Ptr a_X4Dyl
                     -> State# RealWorld
                     -> (# State# RealWorld, () #) :: *)
                    ~R# (Ptr (Ptr a_X4Dyl) -> Int -> Ptr a_X4Dyl -> IO () :: *)))
        ((Foreign.Storable.$fStorablePtr4 @ a_X4Dyl)
         `cast` (forall (b :: <*>_N).
                 <Ptr b>_R ->_R <Int>_R ->_R Sym (GHC.Types.N:IO[0] <Ptr a_X4Dyl>_R)
                 :: (forall b.
                     Ptr b
                     -> Int
                     -> State# RealWorld
                     -> (# State# RealWorld, Ptr a_X4Dyl #) :: *)
                    ~R# (forall b. Ptr b -> Int -> IO (Ptr a_X4Dyl) :: *)))
        ((Foreign.Storable.$fStorablePtr3 @ a_X4Dyl)
         `cast` (forall (b :: <*>_N).
                 <Ptr b>_R
                 ->_R <Int>_R
                 ->_R <Ptr a_X4Dyl>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                 :: (forall b.
                     Ptr b
                     -> Int
                     -> Ptr a_X4Dyl
                     -> State# RealWorld
                     -> (# State# RealWorld, () #) :: *)
                    ~R# (forall b. Ptr b -> Int -> Ptr a_X4Dyl -> IO () :: *)))
        ((Foreign.Storable.$fStorablePtr2 @ a_X4Dyl)
         `cast` (<Ptr (Ptr a_X4Dyl)>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Ptr a_X4Dyl>_R)
                 :: (Ptr (Ptr a_X4Dyl)
                     -> State# RealWorld -> (# State# RealWorld, Ptr a_X4Dyl #) :: *)
                    ~R# (Ptr (Ptr a_X4Dyl) -> IO (Ptr a_X4Dyl) :: *)))
        ((Foreign.Storable.$fStorablePtr1 @ a_X4Dyl)
         `cast` (<Ptr (Ptr a_X4Dyl)>_R
                 ->_R <Ptr a_X4Dyl>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                 :: (Ptr (Ptr a_X4Dyl)
                     -> Ptr a_X4Dyl
                     -> State# RealWorld
                     -> (# State# RealWorld, () #) :: *)
                    ~R# (Ptr (Ptr a_X4Dyl) -> Ptr a_X4Dyl -> IO () :: *)))

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord2
  :: Ptr Word -> State# RealWorld -> (# State# RealWorld, Word #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4Deq [Occ=Once!] :: Ptr Word)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Deq of { Ptr a_a4AN0 [Occ=Once] ->
                 case readWordOffAddr# @ RealWorld a_a4AN0 0# eta_B1 of
                 { (# ipv_s4B5x [Occ=Once], ipv1_s4B5y [Occ=Once] #) ->
                 (# ipv_s4B5x, GHC.Types.W# ipv1_s4B5y #)
                 }
                 }}]
Foreign.Storable.$fStorableWord2
  = \ (ptr_X4Deq :: Ptr Word) (eta_B1 :: State# RealWorld) ->
      case ptr_X4Deq of { Ptr a_a4AN0 ->
      case readWordOffAddr# @ RealWorld a_a4AN0 0# eta_B1 of
      { (# ipv_s4B5x, ipv1_s4B5y #) ->
      (# ipv_s4B5x, GHC.Types.W# ipv1_s4B5y #)
      }
      }

-- RHS size: {terms: 22, types: 31, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord4
  :: forall b.
     Ptr b -> Int -> State# RealWorld -> (# State# RealWorld, Word #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4Dsh)
                 (ptr_X4DfG [Occ=Once!] :: Ptr b_a4Dsh)
                 (off_X4DfI [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DfG of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4DfI of { I# d_a46Xh [Occ=Once] ->
                 case readWordOffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
                 of
                 { (# ipv_s4B5x [Occ=Once], ipv1_s4B5y [Occ=Once] #) ->
                 (# ipv_s4B5x, GHC.Types.W# ipv1_s4B5y #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableWord4
  = \ (@ b_a4Dsh)
      (ptr_X4DfG :: Ptr b_a4Dsh)
      (off_X4DfI :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4DfG of { Ptr addr_a46Xg ->
      case off_X4DfI of { I# d_a46Xh ->
      case readWordOffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
      of
      { (# ipv_s4B5x, ipv1_s4B5y #) ->
      (# ipv_s4B5x, GHC.Types.W# ipv1_s4B5y #)
      }
      }
      }

-- RHS size: {terms: 19, types: 20, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord1
  :: Ptr Word
     -> Word -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4Dem [Occ=Once!] :: Ptr Word)
                 (ds2_d4B1m [Occ=Once!] :: Word)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dem of { Ptr a_a4AOi [Occ=Once] ->
                 case ds2_d4B1m of { W# x_a4AOk [Occ=Once] ->
                 case writeWordOffAddr# @ RealWorld a_a4AOi 0# x_a4AOk eta_B1
                 of s2_a4AOm
                 { __DEFAULT ->
                 (# s2_a4AOm, GHC.Tuple.() #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableWord1
  = \ (ptr_X4Dem :: Ptr Word)
      (ds2_d4B1m :: Word)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Dem of { Ptr a_a4AOi ->
      case ds2_d4B1m of { W# x_a4AOk ->
      case writeWordOffAddr# @ RealWorld a_a4AOi 0# x_a4AOk eta_B1
      of s2_a4AOm
      { __DEFAULT ->
      (# s2_a4AOm, GHC.Tuple.() #)
      }
      }
      }

-- RHS size: {terms: 26, types: 25, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord3
  :: forall b.
     Ptr b
     -> Int -> Word -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4Dsp)
                 (ptr_X4DfP [Occ=Once!] :: Ptr b_a4Dsp)
                 (off_X4DfR [Occ=Once!] :: Int)
                 (eta_X7n [Occ=Once!] :: Word)
                 (eta1_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DfP of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4DfR of { I# d_a46Xh [Occ=Once] ->
                 case eta_X7n of { W# x_a4AOk [Occ=Once] ->
                 case writeWordOffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AOk eta1_B1
                 of s2_a4AOm
                 { __DEFAULT ->
                 (# s2_a4AOm, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
Foreign.Storable.$fStorableWord3
  = \ (@ b_a4Dsp)
      (ptr_X4DfP :: Ptr b_a4Dsp)
      (off_X4DfR :: Int)
      (eta_X7n :: Word)
      (eta1_B1 :: State# RealWorld) ->
      case ptr_X4DfP of { Ptr addr_a46Xg ->
      case off_X4DfR of { I# d_a46Xh ->
      case eta_X7n of { W# x_a4AOk ->
      case writeWordOffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AOk eta1_B1
      of s2_a4AOm
      { __DEFAULT ->
      (# s2_a4AOm, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 56, joins: 0/0}
Foreign.Storable.$fStorableWord [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable Word
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: Word
                                   Foreign.Storable.$fStorableWord_$calignment
                                   Foreign.Storable.$fStorableWord_$calignment
                                   GHC.Storable.readWordOffPtr1
                                   `cast` (<Ptr Word>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Word>_R)
                                           :: (Ptr Word
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word #) :: *)
                                              ~R# (Ptr Word -> Int -> IO Word :: *))
                                   GHC.Storable.writeWordOffPtr1
                                   `cast` (<Ptr Word>_R
                                           ->_R <Int>_R
                                           ->_R <Word>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Word
                                               -> Int
                                               -> Word
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Word -> Int -> Word -> IO () :: *))
                                   Foreign.Storable.$fStorableWord4
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Word>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> IO Word :: *))
                                   Foreign.Storable.$fStorableWord3
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <Word>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> Word
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> Word -> IO () :: *))
                                   Foreign.Storable.$fStorableWord2
                                   `cast` (<Ptr Word>_R ->_R Sym (GHC.Types.N:IO[0] <Word>_R)
                                           :: (Ptr Word
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word #) :: *)
                                              ~R# (Ptr Word -> IO Word :: *))
                                   Foreign.Storable.$fStorableWord1
                                   `cast` (<Ptr Word>_R
                                           ->_R <Word>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Word
                                               -> Word
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Word -> Word -> IO () :: *))]
Foreign.Storable.$fStorableWord
  = Foreign.Storable.C:Storable
      @ Word
      Foreign.Storable.$fStorableWord_$calignment
      Foreign.Storable.$fStorableWord_$calignment
      (GHC.Storable.readWordOffPtr1
       `cast` (<Ptr Word>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] <Word>_R)
               :: (Ptr Word
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word #) :: *)
                  ~R# (Ptr Word -> Int -> IO Word :: *)))
      (GHC.Storable.writeWordOffPtr1
       `cast` (<Ptr Word>_R
               ->_R <Int>_R
               ->_R <Word>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Word
                   -> Int
                   -> Word
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Word -> Int -> Word -> IO () :: *)))
      (Foreign.Storable.$fStorableWord4
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R ->_R <Int>_R ->_R Sym (GHC.Types.N:IO[0] <Word>_R)
               :: (forall b.
                   Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word #) :: *)
                  ~R# (forall b. Ptr b -> Int -> IO Word :: *)))
      (Foreign.Storable.$fStorableWord3
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R
               ->_R <Int>_R
               ->_R <Word>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   Ptr b
                   -> Int
                   -> Word
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. Ptr b -> Int -> Word -> IO () :: *)))
      (Foreign.Storable.$fStorableWord2
       `cast` (<Ptr Word>_R ->_R Sym (GHC.Types.N:IO[0] <Word>_R)
               :: (Ptr Word
                   -> State# RealWorld -> (# State# RealWorld, Word #) :: *)
                  ~R# (Ptr Word -> IO Word :: *)))
      (Foreign.Storable.$fStorableWord1
       `cast` (<Ptr Word>_R
               ->_R <Word>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Word
                   -> Word -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Word -> Word -> IO () :: *)))

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt2
  :: Ptr Int -> State# RealWorld -> (# State# RealWorld, Int #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4DeB [Occ=Once!] :: Ptr Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DeB of { Ptr a_a4AMV [Occ=Once] ->
                 case readIntOffAddr# @ RealWorld a_a4AMV 0# eta_B1 of
                 { (# ipv_s4B5r [Occ=Once], ipv1_s4B5s [Occ=Once] #) ->
                 (# ipv_s4B5r, GHC.Types.I# ipv1_s4B5s #)
                 }
                 }}]
Foreign.Storable.$fStorableInt2
  = \ (ptr_X4DeB :: Ptr Int) (eta_B1 :: State# RealWorld) ->
      case ptr_X4DeB of { Ptr a_a4AMV ->
      case readIntOffAddr# @ RealWorld a_a4AMV 0# eta_B1 of
      { (# ipv_s4B5r, ipv1_s4B5s #) ->
      (# ipv_s4B5r, GHC.Types.I# ipv1_s4B5s #)
      }
      }

-- RHS size: {terms: 22, types: 31, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt4
  :: forall b.
     Ptr b -> Int -> State# RealWorld -> (# State# RealWorld, Int #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4DsZ)
                 (ptr_X4DfW [Occ=Once!] :: Ptr b_a4DsZ)
                 (off_X4DfY [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DfW of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4DfY of { I# d_a46Xh [Occ=Once] ->
                 case readIntOffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
                 of
                 { (# ipv_s4B5r [Occ=Once], ipv1_s4B5s [Occ=Once] #) ->
                 (# ipv_s4B5r, GHC.Types.I# ipv1_s4B5s #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableInt4
  = \ (@ b_a4DsZ)
      (ptr_X4DfW :: Ptr b_a4DsZ)
      (off_X4DfY :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4DfW of { Ptr addr_a46Xg ->
      case off_X4DfY of { I# d_a46Xh ->
      case readIntOffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
      of
      { (# ipv_s4B5r, ipv1_s4B5s #) ->
      (# ipv_s4B5r, GHC.Types.I# ipv1_s4B5s #)
      }
      }
      }

-- RHS size: {terms: 19, types: 20, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt1
  :: Ptr Int -> Int -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4Dex [Occ=Once!] :: Ptr Int)
                 (ds2_d4B1y [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dex of { Ptr a_a4AOd [Occ=Once] ->
                 case ds2_d4B1y of { I# x_a4AOf [Occ=Once] ->
                 case writeIntOffAddr# @ RealWorld a_a4AOd 0# x_a4AOf eta_B1
                 of s2_a4AOh
                 { __DEFAULT ->
                 (# s2_a4AOh, GHC.Tuple.() #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableInt1
  = \ (ptr_X4Dex :: Ptr Int)
      (ds2_d4B1y :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Dex of { Ptr a_a4AOd ->
      case ds2_d4B1y of { I# x_a4AOf ->
      case writeIntOffAddr# @ RealWorld a_a4AOd 0# x_a4AOf eta_B1
      of s2_a4AOh
      { __DEFAULT ->
      (# s2_a4AOh, GHC.Tuple.() #)
      }
      }
      }

-- RHS size: {terms: 26, types: 25, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableInt3
  :: forall b.
     Ptr b
     -> Int -> Int -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4Dt7)
                 (ptr_X4Dg5 [Occ=Once!] :: Ptr b_a4Dt7)
                 (off_X4Dg7 [Occ=Once!] :: Int)
                 (eta_X7D [Occ=Once!] :: Int)
                 (eta1_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dg5 of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4Dg7 of { I# d_a46Xh [Occ=Once] ->
                 case eta_X7D of { I# x_a4AOf [Occ=Once] ->
                 case writeIntOffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AOf eta1_B1
                 of s2_a4AOh
                 { __DEFAULT ->
                 (# s2_a4AOh, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
Foreign.Storable.$fStorableInt3
  = \ (@ b_a4Dt7)
      (ptr_X4Dg5 :: Ptr b_a4Dt7)
      (off_X4Dg7 :: Int)
      (eta_X7D :: Int)
      (eta1_B1 :: State# RealWorld) ->
      case ptr_X4Dg5 of { Ptr addr_a46Xg ->
      case off_X4Dg7 of { I# d_a46Xh ->
      case eta_X7D of { I# x_a4AOf ->
      case writeIntOffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AOf eta1_B1
      of s2_a4AOh
      { __DEFAULT ->
      (# s2_a4AOh, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 56, joins: 0/0}
Foreign.Storable.$fStorableInt [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable Int
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: Int
                                   Foreign.Storable.$fStorableInt_$calignment
                                   Foreign.Storable.$fStorableInt_$calignment
                                   GHC.Storable.readIntOffPtr1
                                   `cast` (<Ptr Int>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Int>_R)
                                           :: (Ptr Int
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int #) :: *)
                                              ~R# (Ptr Int -> Int -> IO Int :: *))
                                   GHC.Storable.writeIntOffPtr1
                                   `cast` (<Ptr Int>_R
                                           ->_R <Int>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Int
                                               -> Int
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Int -> Int -> Int -> IO () :: *))
                                   Foreign.Storable.$fStorableInt4
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Int>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> IO Int :: *))
                                   Foreign.Storable.$fStorableInt3
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> Int -> IO () :: *))
                                   Foreign.Storable.$fStorableInt2
                                   `cast` (<Ptr Int>_R ->_R Sym (GHC.Types.N:IO[0] <Int>_R)
                                           :: (Ptr Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Int #) :: *)
                                              ~R# (Ptr Int -> IO Int :: *))
                                   Foreign.Storable.$fStorableInt1
                                   `cast` (<Ptr Int>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Int
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Int -> Int -> IO () :: *))]
Foreign.Storable.$fStorableInt
  = Foreign.Storable.C:Storable
      @ Int
      Foreign.Storable.$fStorableInt_$calignment
      Foreign.Storable.$fStorableInt_$calignment
      (GHC.Storable.readIntOffPtr1
       `cast` (<Ptr Int>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] <Int>_R)
               :: (Ptr Int
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int #) :: *)
                  ~R# (Ptr Int -> Int -> IO Int :: *)))
      (GHC.Storable.writeIntOffPtr1
       `cast` (<Ptr Int>_R
               ->_R <Int>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Int
                   -> Int
                   -> Int
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Int -> Int -> Int -> IO () :: *)))
      (Foreign.Storable.$fStorableInt4
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R ->_R <Int>_R ->_R Sym (GHC.Types.N:IO[0] <Int>_R)
               :: (forall b.
                   Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Int #) :: *)
                  ~R# (forall b. Ptr b -> Int -> IO Int :: *)))
      (Foreign.Storable.$fStorableInt3
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R
               ->_R <Int>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   Ptr b
                   -> Int
                   -> Int
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. Ptr b -> Int -> Int -> IO () :: *)))
      (Foreign.Storable.$fStorableInt2
       `cast` (<Ptr Int>_R ->_R Sym (GHC.Types.N:IO[0] <Int>_R)
               :: (Ptr Int
                   -> State# RealWorld -> (# State# RealWorld, Int #) :: *)
                  ~R# (Ptr Int -> IO Int :: *)))
      (Foreign.Storable.$fStorableInt1
       `cast` (<Ptr Int>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Int
                   -> Int -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Int -> Int -> IO () :: *)))

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableChar2
  :: Ptr Char -> State# RealWorld -> (# State# RealWorld, Char #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4DeM [Occ=Once!] :: Ptr Char)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DeM of { Ptr a_a4AMQ [Occ=Once] ->
                 case readWideCharOffAddr# @ RealWorld a_a4AMQ 0# eta_B1 of
                 { (# ipv_s4B5l [Occ=Once], ipv1_s4B5m [Occ=Once] #) ->
                 (# ipv_s4B5l, GHC.Types.C# ipv1_s4B5m #)
                 }
                 }}]
Foreign.Storable.$fStorableChar2
  = \ (ptr_X4DeM :: Ptr Char) (eta_B1 :: State# RealWorld) ->
      case ptr_X4DeM of { Ptr a_a4AMQ ->
      case readWideCharOffAddr# @ RealWorld a_a4AMQ 0# eta_B1 of
      { (# ipv_s4B5l, ipv1_s4B5m #) ->
      (# ipv_s4B5l, GHC.Types.C# ipv1_s4B5m #)
      }
      }

-- RHS size: {terms: 22, types: 31, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableChar4
  :: forall b.
     Ptr b -> Int -> State# RealWorld -> (# State# RealWorld, Char #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4DtH)
                 (ptr_X4Dgc [Occ=Once!] :: Ptr b_a4DtH)
                 (off_X4Dge [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dgc of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4Dge of { I# d_a46Xh [Occ=Once] ->
                 case readWideCharOffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
                 of
                 { (# ipv_s4B5l [Occ=Once], ipv1_s4B5m [Occ=Once] #) ->
                 (# ipv_s4B5l, GHC.Types.C# ipv1_s4B5m #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableChar4
  = \ (@ b_a4DtH)
      (ptr_X4Dgc :: Ptr b_a4DtH)
      (off_X4Dge :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Dgc of { Ptr addr_a46Xg ->
      case off_X4Dge of { I# d_a46Xh ->
      case readWideCharOffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
      of
      { (# ipv_s4B5l, ipv1_s4B5m #) ->
      (# ipv_s4B5l, GHC.Types.C# ipv1_s4B5m #)
      }
      }
      }

-- RHS size: {terms: 19, types: 20, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableChar1
  :: Ptr Char
     -> Char -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4DeI [Occ=Once!] :: Ptr Char)
                 (ds2_d4B1K [Occ=Once!] :: Char)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DeI of { Ptr a_a4AO8 [Occ=Once] ->
                 case ds2_d4B1K of { C# x_a4AOa [Occ=Once] ->
                 case writeWideCharOffAddr# @ RealWorld a_a4AO8 0# x_a4AOa eta_B1
                 of s2_a4AOc
                 { __DEFAULT ->
                 (# s2_a4AOc, GHC.Tuple.() #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableChar1
  = \ (ptr_X4DeI :: Ptr Char)
      (ds2_d4B1K :: Char)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4DeI of { Ptr a_a4AO8 ->
      case ds2_d4B1K of { C# x_a4AOa ->
      case writeWideCharOffAddr# @ RealWorld a_a4AO8 0# x_a4AOa eta_B1
      of s2_a4AOc
      { __DEFAULT ->
      (# s2_a4AOc, GHC.Tuple.() #)
      }
      }
      }

-- RHS size: {terms: 26, types: 25, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableChar3
  :: forall b.
     Ptr b
     -> Int -> Char -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4DtP)
                 (ptr_X4Dgl [Occ=Once!] :: Ptr b_a4DtP)
                 (off_X4Dgn [Occ=Once!] :: Int)
                 (eta_X7T [Occ=Once!] :: Char)
                 (eta1_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dgl of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4Dgn of { I# d_a46Xh [Occ=Once] ->
                 case eta_X7T of { C# x_a4AOa [Occ=Once] ->
                 case writeWideCharOffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AOa eta1_B1
                 of s2_a4AOc
                 { __DEFAULT ->
                 (# s2_a4AOc, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
Foreign.Storable.$fStorableChar3
  = \ (@ b_a4DtP)
      (ptr_X4Dgl :: Ptr b_a4DtP)
      (off_X4Dgn :: Int)
      (eta_X7T :: Char)
      (eta1_B1 :: State# RealWorld) ->
      case ptr_X4Dgl of { Ptr addr_a46Xg ->
      case off_X4Dgn of { I# d_a46Xh ->
      case eta_X7T of { C# x_a4AOa ->
      case writeWideCharOffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AOa eta1_B1
      of s2_a4AOc
      { __DEFAULT ->
      (# s2_a4AOc, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 56, joins: 0/0}
Foreign.Storable.$fStorableChar [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable Char
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: Char
                                   Foreign.Storable.$fStorableChar_$calignment
                                   Foreign.Storable.$fStorableChar_$calignment
                                   GHC.Storable.readWideCharOffPtr1
                                   `cast` (<Ptr Char>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Char>_R)
                                           :: (Ptr Char
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Char #) :: *)
                                              ~R# (Ptr Char -> Int -> IO Char :: *))
                                   GHC.Storable.writeWideCharOffPtr1
                                   `cast` (<Ptr Char>_R
                                           ->_R <Int>_R
                                           ->_R <Char>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Char
                                               -> Int
                                               -> Char
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Char -> Int -> Char -> IO () :: *))
                                   Foreign.Storable.$fStorableChar4
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Char>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Char #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> IO Char :: *))
                                   Foreign.Storable.$fStorableChar3
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <Char>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> Char
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> Char -> IO () :: *))
                                   Foreign.Storable.$fStorableChar2
                                   `cast` (<Ptr Char>_R ->_R Sym (GHC.Types.N:IO[0] <Char>_R)
                                           :: (Ptr Char
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Char #) :: *)
                                              ~R# (Ptr Char -> IO Char :: *))
                                   Foreign.Storable.$fStorableChar1
                                   `cast` (<Ptr Char>_R
                                           ->_R <Char>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Char
                                               -> Char
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Char -> Char -> IO () :: *))]
Foreign.Storable.$fStorableChar
  = Foreign.Storable.C:Storable
      @ Char
      Foreign.Storable.$fStorableChar_$calignment
      Foreign.Storable.$fStorableChar_$calignment
      (GHC.Storable.readWideCharOffPtr1
       `cast` (<Ptr Char>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] <Char>_R)
               :: (Ptr Char
                   -> Int -> State# RealWorld -> (# State# RealWorld, Char #) :: *)
                  ~R# (Ptr Char -> Int -> IO Char :: *)))
      (GHC.Storable.writeWideCharOffPtr1
       `cast` (<Ptr Char>_R
               ->_R <Int>_R
               ->_R <Char>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Char
                   -> Int
                   -> Char
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Char -> Int -> Char -> IO () :: *)))
      (Foreign.Storable.$fStorableChar4
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R ->_R <Int>_R ->_R Sym (GHC.Types.N:IO[0] <Char>_R)
               :: (forall b.
                   Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Char #) :: *)
                  ~R# (forall b. Ptr b -> Int -> IO Char :: *)))
      (Foreign.Storable.$fStorableChar3
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R
               ->_R <Int>_R
               ->_R <Char>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   Ptr b
                   -> Int
                   -> Char
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. Ptr b -> Int -> Char -> IO () :: *)))
      (Foreign.Storable.$fStorableChar2
       `cast` (<Ptr Char>_R ->_R Sym (GHC.Types.N:IO[0] <Char>_R)
               :: (Ptr Char
                   -> State# RealWorld -> (# State# RealWorld, Char #) :: *)
                  ~R# (Ptr Char -> IO Char :: *)))
      (Foreign.Storable.$fStorableChar1
       `cast` (<Ptr Char>_R
               ->_R <Char>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Char
                   -> Char -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Char -> Char -> IO () :: *)))

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.Storable.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.Storable.$trModule3
  = GHC.Types.TrNameS Foreign.Storable.$trModule4

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.Storable.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.Storable.$trModule1
  = GHC.Types.TrNameS Foreign.Storable.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.Storable.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Foreign.Storable.$trModule
  = GHC.Types.Module
      Foreign.Storable.$trModule3 Foreign.Storable.$trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep_r4Ffk :: KindRep
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []]
$krep_r4Ffk
  = GHC.Types.KindRepTyConApp
      GHC.Types.$tcConstraint (GHC.Types.[] @ KindRep)

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Foreign.Storable.$tcStorable1 [InlPrag=NOUSERINLINE[~]] :: KindRep
[GblId, Caf=NoCafRefs, Str=m4, Unf=OtherCon []]
Foreign.Storable.$tcStorable1
  = GHC.Types.KindRepFun GHC.Types.krep$* $krep_r4Ffk

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Foreign.Storable.$tcStorable3 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 0}]
Foreign.Storable.$tcStorable3 = "Storable"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Foreign.Storable.$tcStorable2 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
Foreign.Storable.$tcStorable2
  = GHC.Types.TrNameS Foreign.Storable.$tcStorable3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
Foreign.Storable.$tcStorable :: TyCon
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 70}]
Foreign.Storable.$tcStorable
  = GHC.Types.TyCon
      9192657549155052097##
      13909834202100645491##
      Foreign.Storable.$trModule
      Foreign.Storable.$tcStorable2
      0#
      Foreign.Storable.$tcStorable1

-- RHS size: {terms: 15, types: 26, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord20
  :: Ptr Word8 -> State# RealWorld -> (# State# RealWorld, Word8 #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4Dnc [Occ=Once!] :: Ptr Word8)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dnc of { Ptr a_a4ANz [Occ=Once] ->
                 case readWord8OffAddr# @ RealWorld a_a4ANz 0# eta_B1 of
                 { (# ipv_s4B6d [Occ=Once], ipv1_s4B6e [Occ=Once] #) ->
                 (# ipv_s4B6d, GHC.Word.W8# ipv1_s4B6e #)
                 }
                 }}]
Foreign.Storable.$fStorableWord20
  = \ (ptr_X4Dnc :: Ptr Word8) (eta_B1 :: State# RealWorld) ->
      case ptr_X4Dnc of { Ptr a_a4ANz ->
      case readWord8OffAddr# @ RealWorld a_a4ANz 0# eta_B1 of
      { (# ipv_s4B6d, ipv1_s4B6e #) ->
      (# ipv_s4B6d, GHC.Word.W8# ipv1_s4B6e #)
      }
      }

-- RHS size: {terms: 22, types: 31, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord22
  :: forall b.
     Ptr b -> Int -> State# RealWorld -> (# State# RealWorld, Word8 #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4DnS)
                 (ptr_X4DgC [Occ=Once!] :: Ptr b_a4DnS)
                 (off_X4DgE [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DgC of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4DgE of { I# d_a46Xh [Occ=Once] ->
                 case readWord8OffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
                 of
                 { (# ipv_s4B6d [Occ=Once], ipv1_s4B6e [Occ=Once] #) ->
                 (# ipv_s4B6d, GHC.Word.W8# ipv1_s4B6e #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableWord22
  = \ (@ b_a4DnS)
      (ptr_X4DgC :: Ptr b_a4DnS)
      (off_X4DgE :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4DgC of { Ptr addr_a46Xg ->
      case off_X4DgE of { I# d_a46Xh ->
      case readWord8OffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
      of
      { (# ipv_s4B6d, ipv1_s4B6e #) ->
      (# ipv_s4B6d, GHC.Word.W8# ipv1_s4B6e #)
      }
      }
      }

-- RHS size: {terms: 19, types: 20, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord19
  :: Ptr Word8
     -> Word8 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4Df3 [Occ=Once!] :: Ptr Word8)
                 (ds2_d4B00 [Occ=Once!] :: Word8)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Df3 of { Ptr a_a4AOR [Occ=Once] ->
                 case ds2_d4B00 of { W8# x_a4AOT [Occ=Once] ->
                 case writeWord8OffAddr# @ RealWorld a_a4AOR 0# x_a4AOT eta_B1
                 of s2_a4AOV
                 { __DEFAULT ->
                 (# s2_a4AOV, GHC.Tuple.() #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableWord19
  = \ (ptr_X4Df3 :: Ptr Word8)
      (ds2_d4B00 :: Word8)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Df3 of { Ptr a_a4AOR ->
      case ds2_d4B00 of { W8# x_a4AOT ->
      case writeWord8OffAddr# @ RealWorld a_a4AOR 0# x_a4AOT eta_B1
      of s2_a4AOV
      { __DEFAULT ->
      (# s2_a4AOV, GHC.Tuple.() #)
      }
      }
      }

-- RHS size: {terms: 26, types: 25, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableWord21
  :: forall b.
     Ptr b
     -> Int -> Word8 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4Do0)
                 (ptr_X4DgL [Occ=Once!] :: Ptr b_a4Do0)
                 (off_X4DgN [Occ=Once!] :: Int)
                 (eta_X8j [Occ=Once!] :: Word8)
                 (eta1_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4DgL of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4DgN of { I# d_a46Xh [Occ=Once] ->
                 case eta_X8j of { W8# x_a4AOT [Occ=Once] ->
                 case writeWord8OffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AOT eta1_B1
                 of s2_a4AOV
                 { __DEFAULT ->
                 (# s2_a4AOV, GHC.Tuple.() #)
                 }
                 }
                 }
                 }}]
Foreign.Storable.$fStorableWord21
  = \ (@ b_a4Do0)
      (ptr_X4DgL :: Ptr b_a4Do0)
      (off_X4DgN :: Int)
      (eta_X8j :: Word8)
      (eta1_B1 :: State# RealWorld) ->
      case ptr_X4DgL of { Ptr addr_a46Xg ->
      case off_X4DgN of { I# d_a46Xh ->
      case eta_X8j of { W8# x_a4AOT ->
      case writeWord8OffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# x_a4AOT eta1_B1
      of s2_a4AOV
      { __DEFAULT ->
      (# s2_a4AOV, GHC.Tuple.() #)
      }
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 56, joins: 0/0}
Foreign.Storable.$fStorableWord8 [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable Word8
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: Word8
                                   Foreign.Storable.$fStorableWord8_$calignment
                                   Foreign.Storable.$fStorableWord8_$calignment
                                   GHC.Storable.readWord8OffPtr1
                                   `cast` (<Ptr Word8>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Word8>_R)
                                           :: (Ptr Word8
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word8 #) :: *)
                                              ~R# (Ptr Word8 -> Int -> IO Word8 :: *))
                                   GHC.Storable.writeWord8OffPtr1
                                   `cast` (<Ptr Word8>_R
                                           ->_R <Int>_R
                                           ->_R <Word8>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Word8
                                               -> Int
                                               -> Word8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Word8 -> Int -> Word8 -> IO () :: *))
                                   Foreign.Storable.$fStorableWord22
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Word8>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word8 #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> IO Word8 :: *))
                                   Foreign.Storable.$fStorableWord21
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <Word8>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> Word8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> Word8 -> IO () :: *))
                                   Foreign.Storable.$fStorableWord20
                                   `cast` (<Ptr Word8>_R ->_R Sym (GHC.Types.N:IO[0] <Word8>_R)
                                           :: (Ptr Word8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Word8 #) :: *)
                                              ~R# (Ptr Word8 -> IO Word8 :: *))
                                   Foreign.Storable.$fStorableWord19
                                   `cast` (<Ptr Word8>_R
                                           ->_R <Word8>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Word8
                                               -> Word8
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Word8 -> Word8 -> IO () :: *))]
Foreign.Storable.$fStorableWord8
  = Foreign.Storable.C:Storable
      @ Word8
      Foreign.Storable.$fStorableWord8_$calignment
      Foreign.Storable.$fStorableWord8_$calignment
      (GHC.Storable.readWord8OffPtr1
       `cast` (<Ptr Word8>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] <Word8>_R)
               :: (Ptr Word8
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word8 #) :: *)
                  ~R# (Ptr Word8 -> Int -> IO Word8 :: *)))
      (GHC.Storable.writeWord8OffPtr1
       `cast` (<Ptr Word8>_R
               ->_R <Int>_R
               ->_R <Word8>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Word8
                   -> Int
                   -> Word8
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Word8 -> Int -> Word8 -> IO () :: *)))
      (Foreign.Storable.$fStorableWord22
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R ->_R <Int>_R ->_R Sym (GHC.Types.N:IO[0] <Word8>_R)
               :: (forall b.
                   Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Word8 #) :: *)
                  ~R# (forall b. Ptr b -> Int -> IO Word8 :: *)))
      (Foreign.Storable.$fStorableWord21
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R
               ->_R <Int>_R
               ->_R <Word8>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   Ptr b
                   -> Int
                   -> Word8
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. Ptr b -> Int -> Word8 -> IO () :: *)))
      (Foreign.Storable.$fStorableWord20
       `cast` (<Ptr Word8>_R ->_R Sym (GHC.Types.N:IO[0] <Word8>_R)
               :: (Ptr Word8
                   -> State# RealWorld -> (# State# RealWorld, Word8 #) :: *)
                  ~R# (Ptr Word8 -> IO Word8 :: *)))
      (Foreign.Storable.$fStorableWord19
       `cast` (<Ptr Word8>_R
               ->_R <Word8>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Word8
                   -> Word8 -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Word8 -> Word8 -> IO () :: *)))

-- RHS size: {terms: 24, types: 44, coercions: 20, joins: 0/0}
Foreign.Storable.$fStorableRatio2
  :: forall a.
     (Storable a, Integral a) =>
     Ptr (Ratio a)
     -> State# RealWorld -> (# State# RealWorld, Ratio a #)
[GblId,
 Arity=4,
 Str=<S(LLLLLLC(C(S(SL)))L),U(A,A,1*C1(C1(C1(U(U,U)))),A,A,A,1*C1(C1(U(U,U))),A)><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0 0] 150 30}]
Foreign.Storable.$fStorableRatio2
  = \ (@ a_a4DgH)
      ($dStorable_a4DgI :: Storable a_a4DgH)
      ($dIntegral_a4DgJ :: Integral a_a4DgH)
      (p_a4D8B :: Ptr (Ratio a_a4DgH))
      (s_i4DEM :: State# RealWorld) ->
      case ((peek
               @ a_a4DgH
               $dStorable_a4DgI
               (p_a4D8B
                `cast` ((Ptr
                           Univ(phantom phantom <*>_N :: Ratio a_a4DgH, a_a4DgH))_R
                        :: (Ptr (Ratio a_a4DgH) :: *) ~R# (Ptr a_a4DgH :: *))))
            `cast` (GHC.Types.N:IO[0] <a_a4DgH>_R
                    :: (IO a_a4DgH :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a_a4DgH #) :: *)))
             s_i4DEM
      of
      { (# ipv_X4DLC, ipv1_X4DLE #) ->
      case ((peekElemOff
               @ a_a4DgH
               $dStorable_a4DgI
               (p_a4D8B
                `cast` ((Ptr
                           Univ(phantom phantom <*>_N :: Ratio a_a4DgH, a_a4DgH))_R
                        :: (Ptr (Ratio a_a4DgH) :: *) ~R# (Ptr a_a4DgH :: *)))
               Foreign.Storable.$fStorable()7)
            `cast` (GHC.Types.N:IO[0] <a_a4DgH>_R
                    :: (IO a_a4DgH :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, a_a4DgH #) :: *)))
             ipv_X4DLC
      of
      { (# ipv2_X4DLI, ipv3_X4DLK #) ->
      (# ipv2_X4DLI,
         % @ a_a4DgH $dIntegral_a4DgJ ipv1_X4DLE ipv3_X4DLK #)
      }
      }

-- RHS size: {terms: 22, types: 30, coercions: 20, joins: 0/0}
Foreign.Storable.$fStorableRatio1 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Storable a, Integral a) =>
     Ptr (Ratio a)
     -> Ratio a -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,A><L,U><S(SS),1*U(U,U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s4EvI)
                 (w_s4EvJ :: Storable a_s4EvI)
                 _ [Occ=Dead]
                 (w2_s4EvL :: Ptr (Ratio a_s4EvI))
                 (w3_s4EvM [Occ=Once!] :: Ratio a_s4EvI)
                 (w4_s4EvN [Occ=Once] :: State# RealWorld) ->
                 case w3_s4EvM of { :% ww1_s4EvQ [Occ=Once] ww2_s4EvR [Occ=Once] ->
                 case ((poke
                          @ a_s4EvI
                          w_s4EvJ
                          (w2_s4EvL
                           `cast` ((Ptr
                                      Univ(phantom phantom <*>_N :: Ratio a_s4EvI, a_s4EvI))_R
                                   :: (Ptr (Ratio a_s4EvI) :: *) ~R# (Ptr a_s4EvI :: *)))
                          ww1_s4EvQ)
                       `cast` (GHC.Types.N:IO[0] <()>_R
                               :: (IO () :: *)
                                  ~R# (State# RealWorld -> (# State# RealWorld, () #) :: *)))
                        w4_s4EvN
                 of
                 { (# ipv_i4DF6 [Occ=Once], _ [Occ=Dead] #) ->
                 ((pokeElemOff
                     @ a_s4EvI
                     w_s4EvJ
                     (w2_s4EvL
                      `cast` ((Ptr
                                 Univ(phantom phantom <*>_N :: Ratio a_s4EvI, a_s4EvI))_R
                              :: (Ptr (Ratio a_s4EvI) :: *) ~R# (Ptr a_s4EvI :: *)))
                     Foreign.Storable.$fStorable()7
                     ww2_s4EvR)
                  `cast` (GHC.Types.N:IO[0] <()>_R
                          :: (IO () :: *)
                             ~R# (State# RealWorld -> (# State# RealWorld, () #) :: *)))
                   ipv_i4DF6
                 }
                 }}]
Foreign.Storable.$fStorableRatio1
  = \ (@ a_s4EvI)
      (w_s4EvJ :: Storable a_s4EvI)
      _ [Occ=Dead]
      (w2_s4EvL :: Ptr (Ratio a_s4EvI))
      (w3_s4EvM :: Ratio a_s4EvI)
      (w4_s4EvN :: State# RealWorld) ->
      case w3_s4EvM of { :% ww1_s4EvQ ww2_s4EvR ->
      case ((poke
               @ a_s4EvI
               w_s4EvJ
               (w2_s4EvL
                `cast` ((Ptr
                           Univ(phantom phantom <*>_N :: Ratio a_s4EvI, a_s4EvI))_R
                        :: (Ptr (Ratio a_s4EvI) :: *) ~R# (Ptr a_s4EvI :: *)))
               ww1_s4EvQ)
            `cast` (GHC.Types.N:IO[0] <()>_R
                    :: (IO () :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, () #) :: *)))
             w4_s4EvN
      of
      { (# ipv_i4DF6, ipv1_i4DF7 #) ->
      ((pokeElemOff
          @ a_s4EvI
          w_s4EvJ
          (w2_s4EvL
           `cast` ((Ptr
                      Univ(phantom phantom <*>_N :: Ratio a_s4EvI, a_s4EvI))_R
                   :: (Ptr (Ratio a_s4EvI) :: *) ~R# (Ptr a_s4EvI :: *)))
          Foreign.Storable.$fStorable()7
          ww2_s4EvR)
       `cast` (GHC.Types.N:IO[0] <()>_R
               :: (IO () :: *)
                  ~R# (State# RealWorld -> (# State# RealWorld, () #) :: *)))
        ipv_i4DF6
      }
      }

-- RHS size: {terms: 23, types: 30, coercions: 7, joins: 0/0}
Foreign.Storable.$fStorableBool6
  :: Ptr Bool
     -> Int -> State# RealWorld -> (# State# RealWorld, Bool #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (p_a4D8M [Occ=Once] :: Ptr Bool)
                 (i_a4D8N [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case p_a4D8M
                      `cast` ((Ptr Univ(phantom phantom <*>_N :: Bool, Int32))_R
                              :: (Ptr Bool :: *) ~R# (Ptr Int32 :: *))
                 of
                 { Ptr a_a4ANO [Occ=Once] ->
                 case i_a4D8N of { I# i1_a4ANP [Occ=Once] ->
                 case readInt32OffAddr# @ RealWorld a_a4ANO i1_a4ANP eta_B1 of
                 { (# ipv_s4B6v [Occ=Once], ipv1_s4B6w [Occ=Once!] #) ->
                 (# ipv_s4B6v,
                    case ipv1_s4B6w of {
                      __DEFAULT -> GHC.Types.True;
                      0# -> GHC.Types.False
                    } #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableBool6
  = \ (p_a4D8M :: Ptr Bool)
      (i_a4D8N :: Int)
      (eta_B1 :: State# RealWorld) ->
      case p_a4D8M
           `cast` ((Ptr Univ(phantom phantom <*>_N :: Bool, Int32))_R
                   :: (Ptr Bool :: *) ~R# (Ptr Int32 :: *))
      of
      { Ptr a_a4ANO ->
      case i_a4D8N of { I# i1_a4ANP ->
      case readInt32OffAddr# @ RealWorld a_a4ANO i1_a4ANP eta_B1 of
      { (# ipv_s4B6v, ipv1_s4B6w #) ->
      (# ipv_s4B6v,
         case ipv1_s4B6w of {
           __DEFAULT -> GHC.Types.True;
           0# -> GHC.Types.False
         } #)
      }
      }
      }

-- RHS size: {terms: 19, types: 27, coercions: 7, joins: 0/0}
Foreign.Storable.$fStorableBool2
  :: Ptr Bool -> State# RealWorld -> (# State# RealWorld, Bool #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4Dfq [Occ=Once] :: Ptr Bool)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dfq
                      `cast` ((Ptr Univ(phantom phantom <*>_N :: Bool, Int32))_R
                              :: (Ptr Bool :: *) ~R# (Ptr Int32 :: *))
                 of
                 { Ptr a_a4ANO [Occ=Once] ->
                 case readInt32OffAddr# @ RealWorld a_a4ANO 0# eta_B1 of
                 { (# ipv_s4B6v [Occ=Once], ipv1_s4B6w [Occ=Once!] #) ->
                 (# ipv_s4B6v,
                    case ipv1_s4B6w of {
                      __DEFAULT -> GHC.Types.True;
                      0# -> GHC.Types.False
                    } #)
                 }
                 }}]
Foreign.Storable.$fStorableBool2
  = \ (ptr_X4Dfq :: Ptr Bool) (eta_B1 :: State# RealWorld) ->
      case ptr_X4Dfq
           `cast` ((Ptr Univ(phantom phantom <*>_N :: Bool, Int32))_R
                   :: (Ptr Bool :: *) ~R# (Ptr Int32 :: *))
      of
      { Ptr a_a4ANO ->
      case readInt32OffAddr# @ RealWorld a_a4ANO 0# eta_B1 of
      { (# ipv_s4B6v, ipv1_s4B6w #) ->
      (# ipv_s4B6v,
         case ipv1_s4B6w of {
           __DEFAULT -> GHC.Types.True;
           0# -> GHC.Types.False
         } #)
      }
      }

-- RHS size: {terms: 26, types: 32, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableBool4
  :: forall b.
     Ptr b -> Int -> State# RealWorld -> (# State# RealWorld, Bool #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4Dvj)
                 (ptr_X4Dh4 [Occ=Once!] :: Ptr b_a4Dvj)
                 (off_X4Dh6 [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 case ptr_X4Dh4 of { Ptr addr_a46Xg [Occ=Once] ->
                 case off_X4Dh6 of { I# d_a46Xh [Occ=Once] ->
                 case readInt32OffAddr#
                        @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
                 of
                 { (# ipv_s4B6v [Occ=Once], ipv1_s4B6w [Occ=Once!] #) ->
                 (# ipv_s4B6v,
                    case ipv1_s4B6w of {
                      __DEFAULT -> GHC.Types.True;
                      0# -> GHC.Types.False
                    } #)
                 }
                 }
                 }}]
Foreign.Storable.$fStorableBool4
  = \ (@ b_a4Dvj)
      (ptr_X4Dh4 :: Ptr b_a4Dvj)
      (off_X4Dh6 :: Int)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Dh4 of { Ptr addr_a46Xg ->
      case off_X4Dh6 of { I# d_a46Xh ->
      case readInt32OffAddr#
             @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# eta_B1
      of
      { (# ipv_s4B6v, ipv1_s4B6w #) ->
      (# ipv_s4B6v,
         case ipv1_s4B6w of {
           __DEFAULT -> GHC.Types.True;
           0# -> GHC.Types.False
         } #)
      }
      }
      }

-- RHS size: {terms: 30, types: 29, coercions: 7, joins: 0/0}
Foreign.Storable.$fStorableBool1
  :: Ptr Bool
     -> Bool -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,1*U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4Dfm [Occ=Once] :: Ptr Bool)
                 (x_X4Dol [Occ=Once!] :: Bool)
                 (eta_B1 [Occ=Once*] :: State# RealWorld) ->
                 case ptr_X4Dfm
                      `cast` ((Ptr Univ(phantom phantom <*>_N :: Bool, Int32))_R
                              :: (Ptr Bool :: *) ~R# (Ptr Int32 :: *))
                 of
                 { Ptr a_a4AP6 [Occ=Once*] ->
                 case x_X4Dol of {
                   False ->
                     case writeInt32OffAddr# @ RealWorld a_a4AP6 0# 0# eta_B1
                     of s2_a4APa
                     { __DEFAULT ->
                     (# s2_a4APa, GHC.Tuple.() #)
                     };
                   True ->
                     case writeInt32OffAddr# @ RealWorld a_a4AP6 0# 1# eta_B1
                     of s2_a4APa
                     { __DEFAULT ->
                     (# s2_a4APa, GHC.Tuple.() #)
                     }
                 }
                 }}]
Foreign.Storable.$fStorableBool1
  = \ (ptr_X4Dfm :: Ptr Bool)
      (x_X4Dol :: Bool)
      (eta_B1 :: State# RealWorld) ->
      case ptr_X4Dfm
           `cast` ((Ptr Univ(phantom phantom <*>_N :: Bool, Int32))_R
                   :: (Ptr Bool :: *) ~R# (Ptr Int32 :: *))
      of
      { Ptr a_a4AP6 ->
      case x_X4Dol of {
        False ->
          case writeInt32OffAddr# @ RealWorld a_a4AP6 0# 0# eta_B1
          of s2_a4APa
          { __DEFAULT ->
          (# s2_a4APa, GHC.Tuple.() #)
          };
        True ->
          case writeInt32OffAddr# @ RealWorld a_a4AP6 0# 1# eta_B1
          of s2_a4APa
          { __DEFAULT ->
          (# s2_a4APa, GHC.Tuple.() #)
          }
      }
      }

-- RHS size: {terms: 39, types: 34, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableBool3
  :: forall b.
     Ptr b
     -> Int -> Bool -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S(S),1*U(U)><S,1*U><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4Dvr)
                 (ptr_X4Dhd [Occ=Once!] :: Ptr b_a4Dvr)
                 (off_X4Dhf [Occ=Once!] :: Int)
                 (eta_X8L [Occ=Once!] :: Bool)
                 (eta1_B1 [Occ=Once*] :: State# RealWorld) ->
                 case ptr_X4Dhd of { Ptr addr_a46Xg [Occ=Once*] ->
                 case off_X4Dhf of { I# d_a46Xh [Occ=Once*] ->
                 case eta_X8L of {
                   False ->
                     case writeInt32OffAddr#
                            @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# 0# eta1_B1
                     of s2_a4APa
                     { __DEFAULT ->
                     (# s2_a4APa, GHC.Tuple.() #)
                     };
                   True ->
                     case writeInt32OffAddr#
                            @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# 1# eta1_B1
                     of s2_a4APa
                     { __DEFAULT ->
                     (# s2_a4APa, GHC.Tuple.() #)
                     }
                 }
                 }
                 }}]
Foreign.Storable.$fStorableBool3
  = \ (@ b_a4Dvr)
      (ptr_X4Dhd :: Ptr b_a4Dvr)
      (off_X4Dhf :: Int)
      (eta_X8L :: Bool)
      (eta1_B1 :: State# RealWorld) ->
      case ptr_X4Dhd of { Ptr addr_a46Xg ->
      case off_X4Dhf of { I# d_a46Xh ->
      case eta_X8L of {
        False ->
          case writeInt32OffAddr#
                 @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# 0# eta1_B1
          of s2_a4APa
          { __DEFAULT ->
          (# s2_a4APa, GHC.Tuple.() #)
          };
        True ->
          case writeInt32OffAddr#
                 @ RealWorld (plusAddr# addr_a46Xg d_a46Xh) 0# 1# eta1_B1
          of s2_a4APa
          { __DEFAULT ->
          (# s2_a4APa, GHC.Tuple.() #)
          }
      }
      }
      }

-- RHS size: {terms: 9, types: 1, coercions: 56, joins: 0/0}
Foreign.Storable.$fStorableBool [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable Bool
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: Bool
                                   Foreign.Storable.$fStorableBool_$csizeOf
                                   Foreign.Storable.$fStorableBool_$csizeOf
                                   Foreign.Storable.$fStorableBool6
                                   `cast` (<Ptr Bool>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Bool>_R)
                                           :: (Ptr Bool
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Bool #) :: *)
                                              ~R# (Ptr Bool -> Int -> IO Bool :: *))
                                   Foreign.Storable.$fStorableBool5
                                   `cast` (<Ptr Bool>_R
                                           ->_R <Int>_R
                                           ->_R <Bool>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Bool
                                               -> Int
                                               -> Bool
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Bool -> Int -> Bool -> IO () :: *))
                                   Foreign.Storable.$fStorableBool4
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Bool>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Bool #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> IO Bool :: *))
                                   Foreign.Storable.$fStorableBool3
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <Bool>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> Bool
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> Bool -> IO () :: *))
                                   Foreign.Storable.$fStorableBool2
                                   `cast` (<Ptr Bool>_R ->_R Sym (GHC.Types.N:IO[0] <Bool>_R)
                                           :: (Ptr Bool
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Bool #) :: *)
                                              ~R# (Ptr Bool -> IO Bool :: *))
                                   Foreign.Storable.$fStorableBool1
                                   `cast` (<Ptr Bool>_R
                                           ->_R <Bool>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Bool
                                               -> Bool
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Bool -> Bool -> IO () :: *))]
Foreign.Storable.$fStorableBool
  = Foreign.Storable.C:Storable
      @ Bool
      Foreign.Storable.$fStorableBool_$csizeOf
      Foreign.Storable.$fStorableBool_$csizeOf
      (Foreign.Storable.$fStorableBool6
       `cast` (<Ptr Bool>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] <Bool>_R)
               :: (Ptr Bool
                   -> Int -> State# RealWorld -> (# State# RealWorld, Bool #) :: *)
                  ~R# (Ptr Bool -> Int -> IO Bool :: *)))
      (Foreign.Storable.$fStorableBool5
       `cast` (<Ptr Bool>_R
               ->_R <Int>_R
               ->_R <Bool>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Bool
                   -> Int
                   -> Bool
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Bool -> Int -> Bool -> IO () :: *)))
      (Foreign.Storable.$fStorableBool4
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R ->_R <Int>_R ->_R Sym (GHC.Types.N:IO[0] <Bool>_R)
               :: (forall b.
                   Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, Bool #) :: *)
                  ~R# (forall b. Ptr b -> Int -> IO Bool :: *)))
      (Foreign.Storable.$fStorableBool3
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R
               ->_R <Int>_R
               ->_R <Bool>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   Ptr b
                   -> Int
                   -> Bool
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. Ptr b -> Int -> Bool -> IO () :: *)))
      (Foreign.Storable.$fStorableBool2
       `cast` (<Ptr Bool>_R ->_R Sym (GHC.Types.N:IO[0] <Bool>_R)
               :: (Ptr Bool
                   -> State# RealWorld -> (# State# RealWorld, Bool #) :: *)
                  ~R# (Ptr Bool -> IO Bool :: *)))
      (Foreign.Storable.$fStorableBool1
       `cast` (<Ptr Bool>_R
               ->_R <Bool>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Bool
                   -> Bool -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Bool -> Bool -> IO () :: *)))

-- RHS size: {terms: 5, types: 11, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorable()2
  :: Ptr () -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,A><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead] (s_i4DEU [Occ=Once] :: State# RealWorld) ->
                 (# s_i4DEU, GHC.Tuple.() #)}]
Foreign.Storable.$fStorable()2
  = \ _ [Occ=Dead] (s_i4DEU :: State# RealWorld) ->
      (# s_i4DEU, GHC.Tuple.() #)

-- RHS size: {terms: 6, types: 12, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorable()1
  :: Ptr () -> () -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 _ [Occ=Dead]
                 (s_i4DEU [Occ=Once] :: State# RealWorld) ->
                 (# s_i4DEU, GHC.Tuple.() #)}]
Foreign.Storable.$fStorable()1
  = \ _ [Occ=Dead] _ [Occ=Dead] (s_i4DEU :: State# RealWorld) ->
      (# s_i4DEU, GHC.Tuple.() #)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl11_r4Ffl :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl11_r4Ffl = GHC.Types.I# 137#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl12_r4Ffm :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl12_r4Ffm = GHC.Types.I# 31#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl13_r4Ffn :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl13_r4Ffn = GHC.Types.I# 40#

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
lvl14_r4Ffo :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []]
lvl14_r4Ffo
  = GHC.Stack.Types.SrcLoc
      lvl2_r4Ffb
      lvl3_r4Ffc
      lvl5_r4Ffe
      lvl11_r4Ffl
      lvl12_r4Ffm
      lvl11_r4Ffl
      lvl13_r4Ffn

-- RHS size: {terms: 4, types: 0, coercions: 0, joins: 0/0}
lvl15_r4Ffp :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []]
lvl15_r4Ffp
  = GHC.Stack.Types.PushCallStack
      lvl1_r4Ffa lvl14_r4Ffo GHC.Stack.Types.EmptyCallStack

-- RHS size: {terms: 3, types: 4, coercions: 4, joins: 0/0}
lvl16_r4Ffq :: forall a. a
[GblId, Str=x]
lvl16_r4Ffq
  = \ (@ a_a4D8k) ->
      undefined
        @ 'LiftedRep
        @ a_a4D8k
        (lvl15_r4Ffp
         `cast` (Sym (GHC.Classes.N:IP[0]
                          <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                 :: (GHC.Stack.Types.CallStack :: *)
                    ~R# (?callStack::GHC.Stack.Types.CallStack :: Constraint)))

-- RHS size: {terms: 19, types: 15, coercions: 0, joins: 0/0}
Foreign.Storable.$dmpeekElemOff
  :: forall a. Storable a => Ptr a -> Int -> IO a
[GblId,
 Arity=3,
 Str=<S(LLLLC(C(S))LLL),U(1*C1(U(U)),A,A,A,1*C1(C1(U)),A,A,A)><L,U><L,1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4D8k)
                 ($dStorable_X4Dm1 :: Storable a_a4D8k)
                 (ptr_a4D8p [Occ=Once] :: Ptr a_a4D8k)
                 (off_a4D8q [Occ=Once!] :: Int) ->
                 peekByteOff
                   @ a_a4D8k
                   $dStorable_X4Dm1
                   @ a_a4D8k
                   ptr_a4D8p
                   (case off_a4D8q of { I# x_i1MAD [Occ=Once] ->
                    case sizeOf
                           @ a_a4D8k
                           $dStorable_X4Dm1
                           (undefined
                              @ 'LiftedRep
                              @ a_a4D8k
                              ((GHC.Stack.Types.PushCallStack
                                  (build
                                     @ Char
                                     (\ (@ b_i1AKE) -> unpackFoldrCString# @ b_i1AKE "undefined"#))
                                  (GHC.Stack.Types.SrcLoc
                                     (build
                                        @ Char
                                        (\ (@ b_i1AKE) -> unpackFoldrCString# @ b_i1AKE "base"#))
                                     (build
                                        @ Char
                                        (\ (@ b_i1AKE) ->
                                           unpackFoldrCString# @ b_i1AKE "Foreign.Storable"#))
                                     (build
                                        @ Char
                                        (\ (@ b_i1AKE) ->
                                           unpackFoldrCString# @ b_i1AKE "./Foreign/Storable.hs"#))
                                     (GHC.Types.I# 137#)
                                     (GHC.Types.I# 31#)
                                     (GHC.Types.I# 137#)
                                     (GHC.Types.I# 40#))
                                  GHC.Stack.Types.EmptyCallStack)
                               `cast` (Sym (GHC.Classes.N:IP[0]
                                                <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                                       :: (GHC.Stack.Types.CallStack :: *)
                                          ~R# (?callStack::GHC.Stack.Types.CallStack :: Constraint))))
                    of
                    { I# y_i1MAH [Occ=Once] ->
                    GHC.Types.I# (*# x_i1MAD y_i1MAH)
                    }
                    })}]
Foreign.Storable.$dmpeekElemOff
  = \ (@ a_a4D8k)
      ($dStorable_X4Dm1 :: Storable a_a4D8k)
      (ptr_a4D8p :: Ptr a_a4D8k)
      (off_a4D8q :: Int) ->
      peekByteOff
        @ a_a4D8k
        $dStorable_X4Dm1
        @ a_a4D8k
        ptr_a4D8p
        (case off_a4D8q of { I# x_i1MAD ->
         case sizeOf @ a_a4D8k $dStorable_X4Dm1 (lvl16_r4Ffq @ a_a4D8k) of
         { I# y_i1MAH ->
         GHC.Types.I# (*# x_i1MAD y_i1MAH)
         }
         })

-- RHS size: {terms: 21, types: 15, coercions: 0, joins: 0/0}
Foreign.Storable.$dmpokeElemOff
  :: forall a. Storable a => Ptr a -> Int -> a -> IO ()
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<S(LLLLLC(C(C(S)))LL),U(1*C1(U(U)),A,A,A,A,1*C1(C1(C1(U))),A,A)><L,U><L,1*U(U)><L,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=0,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_a4D8k)
                 ($dStorable_X4Dm2 :: Storable a_a4D8k)
                 (ptr_a4D8r [Occ=Once] :: Ptr a_a4D8k)
                 (off_a4D8s [Occ=Once!] :: Int)
                 (val_a4D8t :: a_a4D8k) ->
                 pokeByteOff
                   @ a_a4D8k
                   $dStorable_X4Dm2
                   @ a_a4D8k
                   ptr_a4D8r
                   (case off_a4D8s of { I# x_i1MAD [Occ=Once] ->
                    case sizeOf @ a_a4D8k $dStorable_X4Dm2 val_a4D8t of
                    { I# y_i1MAH [Occ=Once] ->
                    GHC.Types.I# (*# x_i1MAD y_i1MAH)
                    }
                    })
                   val_a4D8t}]
Foreign.Storable.$dmpokeElemOff
  = \ (@ a_a4D8k)
      ($dStorable_X4Dm2 :: Storable a_a4D8k)
      (ptr_a4D8r :: Ptr a_a4D8k)
      (off_a4D8s :: Int)
      (val_a4D8t :: a_a4D8k) ->
      pokeByteOff
        @ a_a4D8k
        $dStorable_X4Dm2
        @ a_a4D8k
        ptr_a4D8r
        (case off_a4D8s of { I# x_i1MAD ->
         case sizeOf @ a_a4D8k $dStorable_X4Dm2 val_a4D8t of { I# y_i1MAH ->
         GHC.Types.I# (*# x_i1MAD y_i1MAH)
         }
         })
        val_a4D8t

-- RHS size: {terms: 7, types: 14, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorable()4
  :: forall b.
     Ptr b -> Int -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_a4Dw3)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (s_i4DEU [Occ=Once] :: State# RealWorld) ->
                 (# s_i4DEU, GHC.Tuple.() #)}]
Foreign.Storable.$fStorable()4
  = \ (@ b_a4Dw3)
      _ [Occ=Dead]
      _ [Occ=Dead]
      (s_i4DEU :: State# RealWorld) ->
      (# s_i4DEU, GHC.Tuple.() #)

-- RHS size: {terms: 6, types: 12, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorable()6
  :: Ptr () -> Int -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><L,A><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 _ [Occ=Dead]
                 (s_i4DEU [Occ=Once] :: State# RealWorld) ->
                 (# s_i4DEU, GHC.Tuple.() #)}]
Foreign.Storable.$fStorable()6
  = \ _ [Occ=Dead] _ [Occ=Dead] (s_i4DEU :: State# RealWorld) ->
      (# s_i4DEU, GHC.Tuple.() #)

-- RHS size: {terms: 8, types: 15, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorable()3
  :: forall b.
     Ptr b
     -> Int -> () -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ (@ b_a4Dwb)
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (s_i4DEU [Occ=Once] :: State# RealWorld) ->
                 (# s_i4DEU, GHC.Tuple.() #)}]
Foreign.Storable.$fStorable()3
  = \ (@ b_a4Dwb)
      _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (s_i4DEU :: State# RealWorld) ->
      (# s_i4DEU, GHC.Tuple.() #)

-- RHS size: {terms: 7, types: 13, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorable()5
  :: Ptr ()
     -> Int -> () -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,A><L,A><L,A><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=True)
         Tmpl= \ _ [Occ=Dead]
                 _ [Occ=Dead]
                 _ [Occ=Dead]
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 (# eta_B1, GHC.Tuple.() #)}]
Foreign.Storable.$fStorable()5
  = \ _ [Occ=Dead]
      _ [Occ=Dead]
      _ [Occ=Dead]
      (eta_B1 :: State# RealWorld) ->
      (# eta_B1, GHC.Tuple.() #)

-- RHS size: {terms: 9, types: 1, coercions: 56, joins: 0/0}
Foreign.Storable.$fStorable() [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable ()
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: ()
                                   Foreign.Storable.$fStorable()_$csizeOf
                                   Foreign.Storable.$fStorable()_$calignment
                                   Foreign.Storable.$fStorable()6
                                   `cast` (<Ptr ()>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr ()
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr () -> Int -> IO () :: *))
                                   Foreign.Storable.$fStorable()5
                                   `cast` (<Ptr ()>_R
                                           ->_R <Int>_R
                                           ->_R <()>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr ()
                                               -> Int
                                               -> ()
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr () -> Int -> () -> IO () :: *))
                                   Foreign.Storable.$fStorable()4
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> IO () :: *))
                                   Foreign.Storable.$fStorable()3
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <()>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> ()
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> () -> IO () :: *))
                                   Foreign.Storable.$fStorable()2
                                   `cast` (<Ptr ()>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr ()
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr () -> IO () :: *))
                                   Foreign.Storable.$fStorable()1
                                   `cast` (<Ptr ()>_R
                                           ->_R <()>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr ()
                                               -> ()
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr () -> () -> IO () :: *))]
Foreign.Storable.$fStorable()
  = Foreign.Storable.C:Storable
      @ ()
      Foreign.Storable.$fStorable()_$csizeOf
      Foreign.Storable.$fStorable()_$calignment
      (Foreign.Storable.$fStorable()6
       `cast` (<Ptr ()>_R ->_R <Int>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr ()
                   -> Int -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr () -> Int -> IO () :: *)))
      (Foreign.Storable.$fStorable()5
       `cast` (<Ptr ()>_R
               ->_R <Int>_R
               ->_R <()>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr ()
                   -> Int
                   -> ()
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr () -> Int -> () -> IO () :: *)))
      (Foreign.Storable.$fStorable()4
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R ->_R <Int>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   Ptr b
                   -> Int -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. Ptr b -> Int -> IO () :: *)))
      (Foreign.Storable.$fStorable()3
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R
               ->_R <Int>_R
               ->_R <()>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   Ptr b
                   -> Int
                   -> ()
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. Ptr b -> Int -> () -> IO () :: *)))
      (Foreign.Storable.$fStorable()2
       `cast` (<Ptr ()>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr () -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr () -> IO () :: *)))
      (Foreign.Storable.$fStorable()1
       `cast` (<Ptr ()>_R ->_R <()>_R ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr ()
                   -> () -> State# RealWorld -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr () -> () -> IO () :: *)))

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl17_r4Ffr :: Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []]
lvl17_r4Ffr = GHC.Types.I# 237#

-- RHS size: {terms: 8, types: 0, coercions: 0, joins: 0/0}
lvl18_r4Ffs :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []]
lvl18_r4Ffs
  = GHC.Stack.Types.SrcLoc
      lvl2_r4Ffb
      lvl3_r4Ffc
      lvl5_r4Ffe
      lvl17_r4Ffr
      lvl12_r4Ffm
      lvl17_r4Ffr
      lvl13_r4Ffn

-- RHS size: {terms: 4, types: 0, coercions: 0, joins: 0/0}
lvl19_r4Fft :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []]
lvl19_r4Fft
  = GHC.Stack.Types.PushCallStack
      lvl1_r4Ffa lvl18_r4Ffs GHC.Stack.Types.EmptyCallStack

-- RHS size: {terms: 3, types: 4, coercions: 4, joins: 0/0}
Foreign.Storable.$fStorableRatio6 :: forall a. a
[GblId, Str=x]
Foreign.Storable.$fStorableRatio6
  = \ (@ a_X4DnT) ->
      undefined
        @ 'LiftedRep
        @ a_X4DnT
        (lvl19_r4Fft
         `cast` (Sym (GHC.Classes.N:IP[0]
                          <"callStack">_N <GHC.Stack.Types.CallStack>_N)
                 :: (GHC.Stack.Types.CallStack :: *)
                    ~R# (?callStack::GHC.Stack.Types.CallStack :: Constraint)))

-- RHS size: {terms: 15, types: 13, coercions: 0, joins: 0/1}
Foreign.Storable.$fStorableRatio_$csizeOf
  :: forall a. (Storable a, Integral a) => Ratio a -> Int
[GblId,
 Arity=2,
 Str=<L,1*U(1*C1(U(U)),A,A,A,A,A,A,A)><L,A>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=2,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X4DnT)
                 ($dStorable_X4DnV [Occ=Once] :: Storable a_X4DnT)
                 _ [Occ=Dead] ->
                 let {
                   lvl20_s4DZL [Occ=OnceL!] :: Int
                   [LclId]
                   lvl20_s4DZL
                     = sizeOf
                         @ a_X4DnT
                         $dStorable_X4DnV
                         (Foreign.Storable.$fStorableRatio6 @ a_X4DnT) } in
                 \ _ [Occ=Dead] ->
                   case lvl20_s4DZL of { I# y_i1MAH [Occ=Once] ->
                   GHC.Types.I# (*# 2# y_i1MAH)
                   }}]
Foreign.Storable.$fStorableRatio_$csizeOf
  = \ (@ a_X4DnT)
      ($dStorable_X4DnV :: Storable a_X4DnT)
      _ [Occ=Dead] ->
      let {
        lvl20_s4DZL [Dmd=<L,U(U)>] :: Int
        [LclId]
        lvl20_s4DZL
          = sizeOf
              @ a_X4DnT
              $dStorable_X4DnV
              (Foreign.Storable.$fStorableRatio6 @ a_X4DnT) } in
      \ _ [Occ=Dead] ->
        case lvl20_s4DZL of { I# y_i1MAH -> GHC.Types.I# (*# 2# y_i1MAH) }

-- RHS size: {terms: 21, types: 21, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableRatio4
  :: forall a.
     (Storable a, Integral a) =>
     forall b.
     Ptr b -> Int -> State# RealWorld -> (# State# RealWorld, Ratio a #)
[GblId,
 Arity=5,
 Str=<S(LLLLLLC(C(S(SL)))L),U(A,A,C(C1(C1(U(U,U)))),A,A,A,C(C1(U(U,U))),A)><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,1*U(U)><L,1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X4DnX)
                 ($dStorable_X4DnZ [Occ=Once] :: Storable a_X4DnX)
                 ($dIntegral_X4Do1 [Occ=Once] :: Integral a_X4DnX)
                 (@ b_a4Dht)
                 (ptr_X4DhE [Occ=Once!] :: Ptr b_a4Dht)
                 (off_X4DhG [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 Foreign.Storable.$fStorableRatio2
                   @ a_X4DnX
                   $dStorable_X4DnZ
                   $dIntegral_X4Do1
                   (case ptr_X4DhE of { Ptr addr_a46Xg [Occ=Once] ->
                    case off_X4DhG of { I# d_a46Xh [Occ=Once] ->
                    GHC.Ptr.Ptr @ (Ratio a_X4DnX) (plusAddr# addr_a46Xg d_a46Xh)
                    }
                    })
                   eta_B1}]
Foreign.Storable.$fStorableRatio4
  = \ (@ a_X4DnX)
      ($dStorable_X4DnZ :: Storable a_X4DnX)
      ($dIntegral_X4Do1 :: Integral a_X4DnX)
      (@ b_a4Dht)
      (ptr_X4DhE :: Ptr b_a4Dht)
      (off_X4DhG :: Int)
      (eta_B1 :: State# RealWorld) ->
      Foreign.Storable.$fStorableRatio2
        @ a_X4DnX
        $dStorable_X4DnZ
        $dIntegral_X4Do1
        (case ptr_X4DhE of { Ptr addr_a46Xg ->
         case off_X4DhG of { I# d_a46Xh ->
         GHC.Ptr.Ptr @ (Ratio a_X4DnX) (plusAddr# addr_a46Xg d_a46Xh)
         }
         })
        eta_B1

-- RHS size: {terms: 29, types: 25, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableRatio7
  :: forall a.
     (Storable a, Integral a) =>
     Ptr (Ratio a)
     -> Int -> State# RealWorld -> (# State# RealWorld, Ratio a #)
[GblId,
 Arity=5,
 Str=<S(LLLLLLC(C(S(SL)))L),U(1*C1(U(U)),A,C(C1(C1(U(U,U)))),A,A,A,C(C1(U(U,U))),A)><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)><L,1*U(U)><L,1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=5,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_X4DnY)
                 ($dStorable_X4Do0 :: Storable a_X4DnY)
                 ($dIntegral_X4Do2 [Occ=Once] :: Integral a_X4DnY)
                 (ptr_X4DhE [Occ=Once!] :: Ptr (Ratio a_X4DnY))
                 (off_X4DhG [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 Foreign.Storable.$fStorableRatio2
                   @ a_X4DnY
                   $dStorable_X4Do0
                   $dIntegral_X4Do2
                   (case ptr_X4DhE of { Ptr addr_a46Xg [Occ=Once] ->
                    case off_X4DhG of { I# x_i1MAD [Occ=Once] ->
                    case sizeOf
                           @ a_X4DnY
                           $dStorable_X4Do0
                           (Foreign.Storable.$fStorableRatio6 @ a_X4DnY)
                    of
                    { I# y_i1MAH [Occ=Once] ->
                    GHC.Ptr.Ptr
                      @ (Ratio a_X4DnY)
                      (plusAddr# addr_a46Xg (*# x_i1MAD (*# 2# y_i1MAH)))
                    }
                    }
                    })
                   eta_B1}]
Foreign.Storable.$fStorableRatio7
  = \ (@ a_X4DnY)
      ($dStorable_X4Do0 :: Storable a_X4DnY)
      ($dIntegral_X4Do2 :: Integral a_X4DnY)
      (ptr_X4DhE :: Ptr (Ratio a_X4DnY))
      (off_X4DhG :: Int)
      (eta_B1 :: State# RealWorld) ->
      Foreign.Storable.$fStorableRatio2
        @ a_X4DnY
        $dStorable_X4Do0
        $dIntegral_X4Do2
        (case ptr_X4DhE of { Ptr addr_a46Xg ->
         case off_X4DhG of { I# x_i1MAD ->
         case sizeOf
                @ a_X4DnY
                $dStorable_X4Do0
                (Foreign.Storable.$fStorableRatio6 @ a_X4DnY)
         of
         { I# y_i1MAH ->
         GHC.Ptr.Ptr
           @ (Ratio a_X4DnY)
           (plusAddr# addr_a46Xg (*# x_i1MAD (*# 2# y_i1MAH)))
         }
         }
         })
        eta_B1

-- RHS size: {terms: 32, types: 36, coercions: 20, joins: 0/1}
Foreign.Storable.$w$cpokeByteOff [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Storable a =>
     forall b.
     Ptr b
     -> Int -> a -> a -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><L,U><L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 20 20 0 0 0] 161 0}]
Foreign.Storable.$w$cpokeByteOff
  = \ (@ a_s4EvU)
      (w_s4EvV :: Storable a_s4EvU)
      (@ b_s4EvX)
      (w1_s4EvY :: Ptr b_s4EvX)
      (w2_s4EvZ :: Int)
      (ww_s4Ew4
         :: a_s4EvU
         Unf=OtherCon [])
      (ww1_s4Ew5
         :: a_s4EvU
         Unf=OtherCon [])
      (w3_s4Ew1 :: State# RealWorld) ->
      let {
        p_a4D8F :: Ptr (Ratio a_s4EvU)
        [LclId]
        p_a4D8F
          = case w1_s4EvY of { Ptr addr_a46Xg ->
            case w2_s4EvZ of { I# d_a46Xh ->
            GHC.Ptr.Ptr @ (Ratio a_s4EvU) (plusAddr# addr_a46Xg d_a46Xh)
            }
            } } in
      case ((poke
               @ a_s4EvU
               w_s4EvV
               (p_a4D8F
                `cast` ((Ptr
                           Univ(phantom phantom <*>_N :: Ratio a_s4EvU, a_s4EvU))_R
                        :: (Ptr (Ratio a_s4EvU) :: *) ~R# (Ptr a_s4EvU :: *)))
               ww_s4Ew4)
            `cast` (GHC.Types.N:IO[0] <()>_R
                    :: (IO () :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, () #) :: *)))
             w3_s4Ew1
      of
      { (# ipv_i4DF6, ipv1_i4DF7 #) ->
      ((pokeElemOff
          @ a_s4EvU
          w_s4EvV
          (p_a4D8F
           `cast` ((Ptr
                      Univ(phantom phantom <*>_N :: Ratio a_s4EvU, a_s4EvU))_R
                   :: (Ptr (Ratio a_s4EvU) :: *) ~R# (Ptr a_s4EvU :: *)))
          Foreign.Storable.$fStorable()7
          ww1_s4Ew5)
       `cast` (GHC.Types.N:IO[0] <()>_R
               :: (IO () :: *)
                  ~R# (State# RealWorld -> (# State# RealWorld, () #) :: *)))
        ipv_i4DF6
      }

-- RHS size: {terms: 18, types: 21, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableRatio3 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Storable a, Integral a) =>
     forall b.
     Ptr b
     -> Int -> Ratio a -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=6,
 Caf=NoCafRefs,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(A,A,A,C(C1(C1(C1(U(U,U))))),A,A,A,C(C1(C1(U(U,A)))))><L,A><L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s4EvU)
                 (w_s4EvV [Occ=Once] :: Storable a_s4EvU)
                 _ [Occ=Dead]
                 (@ b_s4EvX)
                 (w2_s4EvY [Occ=Once] :: Ptr b_s4EvX)
                 (w3_s4EvZ [Occ=Once] :: Int)
                 (w4_s4Ew0 [Occ=Once!] :: Ratio a_s4EvU)
                 (w5_s4Ew1 [Occ=Once] :: State# RealWorld) ->
                 case w4_s4Ew0 of { :% ww1_s4Ew4 [Occ=Once] ww2_s4Ew5 [Occ=Once] ->
                 Foreign.Storable.$w$cpokeByteOff
                   @ a_s4EvU
                   w_s4EvV
                   @ b_s4EvX
                   w2_s4EvY
                   w3_s4EvZ
                   ww1_s4Ew4
                   ww2_s4Ew5
                   w5_s4Ew1
                 }}]
Foreign.Storable.$fStorableRatio3
  = \ (@ a_s4EvU)
      (w_s4EvV :: Storable a_s4EvU)
      _ [Occ=Dead]
      (@ b_s4EvX)
      (w2_s4EvY :: Ptr b_s4EvX)
      (w3_s4EvZ :: Int)
      (w4_s4Ew0 :: Ratio a_s4EvU)
      (w5_s4Ew1 :: State# RealWorld) ->
      case w4_s4Ew0 of { :% ww1_s4Ew4 ww2_s4Ew5 ->
      Foreign.Storable.$w$cpokeByteOff
        @ a_s4EvU
        w_s4EvV
        @ b_s4EvX
        w2_s4EvY
        w3_s4EvZ
        ww1_s4Ew4
        ww2_s4Ew5
        w5_s4Ew1
      }

-- RHS size: {terms: 40, types: 40, coercions: 20, joins: 0/1}
Foreign.Storable.$w$cpokeElemOff [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     Storable a =>
     Ptr (Ratio a)
     -> Int -> a -> a -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=6,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(1*C1(U(U)),A,A,1*C1(C1(C1(C1(U(U,U))))),A,A,A,1*C1(C1(C1(U(U,A)))))><L,1*U(U)><L,1*U(U)><L,U><L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [90 20 20 0 0 0] 203 0}]
Foreign.Storable.$w$cpokeElemOff
  = \ (@ a_s4Ew8)
      (w_s4Ew9 :: Storable a_s4Ew8)
      (w1_s4Ewb :: Ptr (Ratio a_s4Ew8))
      (w2_s4Ewc :: Int)
      (ww_s4Ewh
         :: a_s4Ew8
         Unf=OtherCon [])
      (ww1_s4Ewi
         :: a_s4Ew8
         Unf=OtherCon [])
      (w3_s4Ewe :: State# RealWorld) ->
      let {
        p_a4D8F :: Ptr (Ratio a_s4Ew8)
        [LclId]
        p_a4D8F
          = case w1_s4Ewb of { Ptr addr_a46Xg ->
            case w2_s4Ewc of { I# x_i1MAD ->
            case sizeOf
                   @ a_s4Ew8 w_s4Ew9 (Foreign.Storable.$fStorableRatio6 @ a_s4Ew8)
            of
            { I# y_i1MAH ->
            GHC.Ptr.Ptr
              @ (Ratio a_s4Ew8)
              (plusAddr# addr_a46Xg (*# x_i1MAD (*# 2# y_i1MAH)))
            }
            }
            } } in
      case ((poke
               @ a_s4Ew8
               w_s4Ew9
               (p_a4D8F
                `cast` ((Ptr
                           Univ(phantom phantom <*>_N :: Ratio a_s4Ew8, a_s4Ew8))_R
                        :: (Ptr (Ratio a_s4Ew8) :: *) ~R# (Ptr a_s4Ew8 :: *)))
               ww_s4Ewh)
            `cast` (GHC.Types.N:IO[0] <()>_R
                    :: (IO () :: *)
                       ~R# (State# RealWorld -> (# State# RealWorld, () #) :: *)))
             w3_s4Ewe
      of
      { (# ipv_i4DF6, ipv1_i4DF7 #) ->
      ((pokeElemOff
          @ a_s4Ew8
          w_s4Ew9
          (p_a4D8F
           `cast` ((Ptr
                      Univ(phantom phantom <*>_N :: Ratio a_s4Ew8, a_s4Ew8))_R
                   :: (Ptr (Ratio a_s4Ew8) :: *) ~R# (Ptr a_s4Ew8 :: *)))
          Foreign.Storable.$fStorable()7
          ww1_s4Ewi)
       `cast` (GHC.Types.N:IO[0] <()>_R
               :: (IO () :: *)
                  ~R# (State# RealWorld -> (# State# RealWorld, () #) :: *)))
        ipv_i4DF6
      }

-- RHS size: {terms: 17, types: 19, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableRatio5 [InlPrag=NOUSERINLINE[0]]
  :: forall a.
     (Storable a, Integral a) =>
     Ptr (Ratio a)
     -> Int -> Ratio a -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=6,
 Str=<S(LLLLLLLC(C(C(S(SL))))),U(C(U(U)),A,A,C(C1(C1(C1(U(U,U))))),A,A,A,C(C1(C1(U(U,A)))))><L,A><L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=6,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ a_s4Ew8)
                 (w_s4Ew9 [Occ=Once] :: Storable a_s4Ew8)
                 _ [Occ=Dead]
                 (w2_s4Ewb [Occ=Once] :: Ptr (Ratio a_s4Ew8))
                 (w3_s4Ewc [Occ=Once] :: Int)
                 (w4_s4Ewd [Occ=Once!] :: Ratio a_s4Ew8)
                 (w5_s4Ewe [Occ=Once] :: State# RealWorld) ->
                 case w4_s4Ewd of { :% ww1_s4Ewh [Occ=Once] ww2_s4Ewi [Occ=Once] ->
                 Foreign.Storable.$w$cpokeElemOff
                   @ a_s4Ew8 w_s4Ew9 w2_s4Ewb w3_s4Ewc ww1_s4Ewh ww2_s4Ewi w5_s4Ewe
                 }}]
Foreign.Storable.$fStorableRatio5
  = \ (@ a_s4Ew8)
      (w_s4Ew9 :: Storable a_s4Ew8)
      _ [Occ=Dead]
      (w2_s4Ewb :: Ptr (Ratio a_s4Ew8))
      (w3_s4Ewc :: Int)
      (w4_s4Ewd :: Ratio a_s4Ew8)
      (w5_s4Ewe :: State# RealWorld) ->
      case w4_s4Ewd of { :% ww1_s4Ewh ww2_s4Ewi ->
      Foreign.Storable.$w$cpokeElemOff
        @ a_s4Ew8 w_s4Ew9 w2_s4Ewb w3_s4Ewc ww1_s4Ewh ww2_s4Ewi w5_s4Ewe
      }

-- RHS size: {terms: 28, types: 16, coercions: 66, joins: 0/0}
Foreign.Storable.$fStorableRatio [InlPrag=NOUSERINLINE CONLIKE]
  :: forall a. (Storable a, Integral a) => Storable (Ratio a)
[GblId[DFunId],
 Arity=2,
 Str=<L,U(C(U(U)),1*C1(U),C(C1(C1(U(U,U)))),C(C1(C1(C1(U(U,U))))),A,A,C(C1(U(U,U))),C(C1(C1(U(U,A)))))><L,U(U(U(A,A,C(C1(U)),A,C(U),C(U),C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,C(C1(U)),C(C1(U)),A,A,A,A,A)>m,
 Unf=DFun: \ (@ a_a4D8A)
             (v_B1 :: Storable a_a4D8A)
             (v1_X9E :: Integral a_a4D8A) ->
       Foreign.Storable.C:Storable TYPE: Ratio a_a4D8A
                                   Foreign.Storable.$fStorableRatio_$csizeOf @ a_a4D8A v_B1 v1_X9E
                                   Foreign.Storable.$fStorableRatio_$calignment
                                     @ a_a4D8A v_B1 v1_X9E
                                   (Foreign.Storable.$fStorableRatio7 @ a_a4D8A v_B1 v1_X9E)
                                   `cast` (<Ptr (Ratio a_a4D8A)>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Ratio a_a4D8A>_R)
                                           :: (Ptr (Ratio a_a4D8A)
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Ratio a_a4D8A #) :: *)
                                              ~R# (Ptr (Ratio a_a4D8A)
                                                   -> Int -> IO (Ratio a_a4D8A) :: *))
                                   (Foreign.Storable.$fStorableRatio5 @ a_a4D8A v_B1 v1_X9E)
                                   `cast` (<Ptr (Ratio a_a4D8A)>_R
                                           ->_R <Int>_R
                                           ->_R <Ratio a_a4D8A>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr (Ratio a_a4D8A)
                                               -> Int
                                               -> Ratio a_a4D8A
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr (Ratio a_a4D8A)
                                                   -> Int -> Ratio a_a4D8A -> IO () :: *))
                                   (Foreign.Storable.$fStorableRatio4 @ a_a4D8A v_B1 v1_X9E)
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Ratio a_a4D8A>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Ratio a_a4D8A #) :: *)
                                              ~R# (forall b.
                                                   Ptr b -> Int -> IO (Ratio a_a4D8A) :: *))
                                   (Foreign.Storable.$fStorableRatio3 @ a_a4D8A v_B1 v1_X9E)
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <Ratio a_a4D8A>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> Ratio a_a4D8A
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   Ptr b -> Int -> Ratio a_a4D8A -> IO () :: *))
                                   (Foreign.Storable.$fStorableRatio2 @ a_a4D8A v_B1 v1_X9E)
                                   `cast` (<Ptr (Ratio a_a4D8A)>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Ratio a_a4D8A>_R)
                                           :: (Ptr (Ratio a_a4D8A)
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Ratio a_a4D8A #) :: *)
                                              ~R# (Ptr (Ratio a_a4D8A) -> IO (Ratio a_a4D8A) :: *))
                                   (Foreign.Storable.$fStorableRatio1 @ a_a4D8A v_B1 v1_X9E)
                                   `cast` (<Ptr (Ratio a_a4D8A)>_R
                                           ->_R <Ratio a_a4D8A>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr (Ratio a_a4D8A)
                                               -> Ratio a_a4D8A
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr (Ratio a_a4D8A)
                                                   -> Ratio a_a4D8A -> IO () :: *))]
Foreign.Storable.$fStorableRatio
  = \ (@ a_X4DnU)
      ($dStorable_X4Dxx :: Storable a_X4DnU)
      ($dIntegral_X4DxA :: Integral a_X4DnU) ->
      Foreign.Storable.C:Storable
        @ (Ratio a_X4DnU)
        (Foreign.Storable.$fStorableRatio_$csizeOf
           @ a_X4DnU $dStorable_X4Dxx $dIntegral_X4DxA)
        (Foreign.Storable.$fStorableRatio_$calignment
           @ a_X4DnU $dStorable_X4Dxx $dIntegral_X4DxA)
        ((Foreign.Storable.$fStorableRatio7
            @ a_X4DnU $dStorable_X4Dxx $dIntegral_X4DxA)
         `cast` (<Ptr (Ratio a_X4DnU)>_R
                 ->_R <Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Ratio a_X4DnU>_R)
                 :: (Ptr (Ratio a_X4DnU)
                     -> Int
                     -> State# RealWorld
                     -> (# State# RealWorld, Ratio a_X4DnU #) :: *)
                    ~R# (Ptr (Ratio a_X4DnU) -> Int -> IO (Ratio a_X4DnU) :: *)))
        ((Foreign.Storable.$fStorableRatio5
            @ a_X4DnU $dStorable_X4Dxx $dIntegral_X4DxA)
         `cast` (<Ptr (Ratio a_X4DnU)>_R
                 ->_R <Int>_R
                 ->_R <Ratio a_X4DnU>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                 :: (Ptr (Ratio a_X4DnU)
                     -> Int
                     -> Ratio a_X4DnU
                     -> State# RealWorld
                     -> (# State# RealWorld, () #) :: *)
                    ~R# (Ptr (Ratio a_X4DnU) -> Int -> Ratio a_X4DnU -> IO () :: *)))
        ((Foreign.Storable.$fStorableRatio4
            @ a_X4DnU $dStorable_X4Dxx $dIntegral_X4DxA)
         `cast` (forall (b :: <*>_N).
                 <Ptr b>_R
                 ->_R <Int>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Ratio a_X4DnU>_R)
                 :: (forall b.
                     Ptr b
                     -> Int
                     -> State# RealWorld
                     -> (# State# RealWorld, Ratio a_X4DnU #) :: *)
                    ~R# (forall b. Ptr b -> Int -> IO (Ratio a_X4DnU) :: *)))
        ((Foreign.Storable.$fStorableRatio3
            @ a_X4DnU $dStorable_X4Dxx $dIntegral_X4DxA)
         `cast` (forall (b :: <*>_N).
                 <Ptr b>_R
                 ->_R <Int>_R
                 ->_R <Ratio a_X4DnU>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                 :: (forall b.
                     Ptr b
                     -> Int
                     -> Ratio a_X4DnU
                     -> State# RealWorld
                     -> (# State# RealWorld, () #) :: *)
                    ~R# (forall b. Ptr b -> Int -> Ratio a_X4DnU -> IO () :: *)))
        ((Foreign.Storable.$fStorableRatio2
            @ a_X4DnU $dStorable_X4Dxx $dIntegral_X4DxA)
         `cast` (<Ptr (Ratio a_X4DnU)>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Ratio a_X4DnU>_R)
                 :: (Ptr (Ratio a_X4DnU)
                     -> State# RealWorld -> (# State# RealWorld, Ratio a_X4DnU #) :: *)
                    ~R# (Ptr (Ratio a_X4DnU) -> IO (Ratio a_X4DnU) :: *)))
        ((Foreign.Storable.$fStorableRatio1
            @ a_X4DnU $dStorable_X4Dxx $dIntegral_X4DxA)
         `cast` (<Ptr (Ratio a_X4DnU)>_R
                 ->_R <Ratio a_X4DnU>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                 :: (Ptr (Ratio a_X4DnU)
                     -> Ratio a_X4DnU
                     -> State# RealWorld
                     -> (# State# RealWorld, () #) :: *)
                    ~R# (Ptr (Ratio a_X4DnU) -> Ratio a_X4DnU -> IO () :: *)))

Rec {
-- RHS size: {terms: 37, types: 22, coercions: 0, joins: 0/0}
Foreign.Storable.$wpokeW64 [InlPrag=NOUSERINLINE[0],
                            Occ=LoopBreaker]
  :: Ptr Word8
     -> Int# -> Word64 -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><S,1*U><L,1*U(U)><S,U>,
 Unf=OtherCon []]
Foreign.Storable.$wpokeW64
  = \ (w_s4Ewl :: Ptr Word8)
      (ww_s4Ewr :: Int#)
      (w1_s4Ewn :: Word64)
      (w2_s4Ewo :: State# RealWorld) ->
      case ww_s4Ewr of ds_X4Dzw {
        __DEFAULT ->
          case w1_s4Ewn of { W64# ipv_s4DGi ->
          case w_s4Ewl of wild_X10 { Ptr a_a4AOR ->
          case writeWord8OffAddr#
                 @ RealWorld
                 a_a4AOR
                 (-# ds_X4Dzw 1#)
                 (narrow8Word# ipv_s4DGi)
                 w2_s4Ewo
          of s2_a4AOV
          { __DEFAULT ->
          Foreign.Storable.$wpokeW64
            wild_X10
            (-# ds_X4Dzw 1#)
            (GHC.Word.W64# (uncheckedShiftRL# ipv_s4DGi 8#))
            s2_a4AOV
          }
          }
          };
        0# -> (# w2_s4Ewo, GHC.Tuple.() #)
      }
end Rec }

-- RHS size: {terms: 24, types: 23, coercions: 16, joins: 0/0}
Foreign.Storable.$w$cpoke [InlPrag=NOUSERINLINE[0]]
  :: Ptr Fingerprint
     -> Word# -> Word# -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,U(U)><L,U><L,U><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 0 0 0] 131 0}]
Foreign.Storable.$w$cpoke
  = \ (w_s4Ewu :: Ptr Fingerprint)
      (ww_s4Ewz :: Word#)
      (ww1_s4EwA :: Word#)
      (w1_s4Eww :: State# RealWorld) ->
      case Foreign.Storable.$wpokeW64
             (w_s4Ewu
              `cast` ((Ptr Univ(phantom phantom <*>_N :: Fingerprint, Word8))_R
                      :: (Ptr Fingerprint :: *) ~R# (Ptr Word8 :: *)))
             8#
             (GHC.Word.W64# ww_s4Ewz)
             w1_s4Eww
      of
      { (# ipv_i4DF6, ipv1_i4DF7 #) ->
      Foreign.Storable.$wpokeW64
        (case w_s4Ewu
              `cast` ((Ptr Univ(phantom phantom <*>_N :: Fingerprint, Any))_R
                      :: (Ptr Fingerprint :: *) ~R# (Ptr Any :: *))
         of
         { Ptr addr_a46Xg ->
         GHC.Ptr.Ptr @ Word8 (plusAddr# addr_a46Xg 8#)
         })
        8#
        (GHC.Word.W64# ww1_s4EwA)
        ipv_i4DF6
      }

-- RHS size: {terms: 11, types: 8, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableFingerprint1 [InlPrag=NOUSERINLINE[0]]
  :: Ptr Fingerprint
     -> Fingerprint -> State# RealWorld -> (# State# RealWorld, () #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (w_s4Ewu [Occ=Once] :: Ptr Fingerprint)
                 (w1_s4Ewv [Occ=Once!] :: Fingerprint)
                 (w2_s4Eww [Occ=Once] :: State# RealWorld) ->
                 case w1_s4Ewv of
                 { Fingerprint ww1_s4Ewz [Occ=Once] ww2_s4EwA [Occ=Once] ->
                 Foreign.Storable.$w$cpoke w_s4Ewu ww1_s4Ewz ww2_s4EwA w2_s4Eww
                 }}]
Foreign.Storable.$fStorableFingerprint1
  = \ (w_s4Ewu :: Ptr Fingerprint)
      (w1_s4Ewv :: Fingerprint)
      (w2_s4Eww :: State# RealWorld) ->
      case w1_s4Ewv of { Fingerprint ww1_s4Ewz ww2_s4EwA ->
      Foreign.Storable.$w$cpoke w_s4Ewu ww1_s4Ewz ww2_s4EwA w2_s4Eww
      }

Rec {
-- RHS size: {terms: 35, types: 30, coercions: 0, joins: 0/0}
Foreign.Storable.$wpeekW64 [InlPrag=NOUSERINLINE[0],
                            Occ=LoopBreaker]
  :: Ptr Word8
     -> Int#
     -> Word#
     -> State# RealWorld
     -> (# State# RealWorld, Word64 #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><S,1*U><L,U><S,U>,
 Unf=OtherCon []]
Foreign.Storable.$wpeekW64
  = \ (w_s4EwD :: Ptr Word8)
      (ww_s4EwJ :: Int#)
      (ww1_s4EwN :: Word#)
      (w1_s4EwG :: State# RealWorld) ->
      case ww_s4EwJ of ds_X4DzI {
        __DEFAULT ->
          case w_s4EwD of { Ptr ipv_s4DGs ->
          case readWord8OffAddr# @ RealWorld ipv_s4DGs 0# w1_s4EwG of
          { (# ipv1_s4B6d, ipv2_s4B6e #) ->
          Foreign.Storable.$wpeekW64
            (GHC.Ptr.Ptr @ Word8 (plusAddr# ipv_s4DGs 1#))
            (-# ds_X4DzI 1#)
            (or# (uncheckedShiftL# ww1_s4EwN 8#) ipv2_s4B6e)
            ipv1_s4B6d
          }
          };
        0# -> (# w1_s4EwG, GHC.Word.W64# ww1_s4EwN #)
      }
end Rec }

-- RHS size: {terms: 27, types: 39, coercions: 16, joins: 0/0}
Foreign.Storable.$fStorableFingerprint2
  :: Ptr Fingerprint
     -> State# RealWorld -> (# State# RealWorld, Fingerprint #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U(U)><S,U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [20 0] 151 30}]
Foreign.Storable.$fStorableFingerprint2
  = \ (p0_a4D8R :: Ptr Fingerprint) (eta_B1 :: State# RealWorld) ->
      case Foreign.Storable.$wpeekW64
             (p0_a4D8R
              `cast` ((Ptr Univ(phantom phantom <*>_N :: Fingerprint, Word8))_R
                      :: (Ptr Fingerprint :: *) ~R# (Ptr Word8 :: *)))
             8#
             0##
             eta_B1
      of
      { (# ipv_i4DEP, ipv1_i4DEQ #) ->
      case Foreign.Storable.$wpeekW64
             (case p0_a4D8R
                   `cast` ((Ptr Univ(phantom phantom <*>_N :: Fingerprint, Any))_R
                           :: (Ptr Fingerprint :: *) ~R# (Ptr Any :: *))
              of
              { Ptr addr_a46Xg ->
              GHC.Ptr.Ptr @ Word8 (plusAddr# addr_a46Xg 8#)
              })
             8#
             0##
             ipv_i4DEP
      of
      { (# ipv2_X4DMk, ipv3_X4DMm #) ->
      (# ipv2_X4DMk,
         GHC.Fingerprint.Type.$WFingerprint ipv1_i4DEQ ipv3_X4DMm #)
      }
      }

-- RHS size: {terms: 16, types: 13, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableFingerprint4
  :: forall b.
     Ptr b
     -> Int -> State# RealWorld -> (# State# RealWorld, Fingerprint #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><L,1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4Dgk)
                 (ptr_X4Did [Occ=Once!] :: Ptr b_a4Dgk)
                 (off_X4Dif [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 Foreign.Storable.$fStorableFingerprint2
                   (case ptr_X4Did of { Ptr addr_a46Xg [Occ=Once] ->
                    case off_X4Dif of { I# d_a46Xh [Occ=Once] ->
                    GHC.Ptr.Ptr @ Fingerprint (plusAddr# addr_a46Xg d_a46Xh)
                    }
                    })
                   eta_B1}]
Foreign.Storable.$fStorableFingerprint4
  = \ (@ b_a4Dgk)
      (ptr_X4Did :: Ptr b_a4Dgk)
      (off_X4Dif :: Int)
      (eta_B1 :: State# RealWorld) ->
      Foreign.Storable.$fStorableFingerprint2
        (case ptr_X4Did of { Ptr addr_a46Xg ->
         case off_X4Dif of { I# d_a46Xh ->
         GHC.Ptr.Ptr @ Fingerprint (plusAddr# addr_a46Xg d_a46Xh)
         }
         })
        eta_B1

-- RHS size: {terms: 17, types: 11, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableFingerprint6
  :: Ptr Fingerprint
     -> Int -> State# RealWorld -> (# State# RealWorld, Fingerprint #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><L,1*U(U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=3,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4Dic [Occ=Once!] :: Ptr Fingerprint)
                 (off_X4Die [Occ=Once!] :: Int)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 Foreign.Storable.$fStorableFingerprint2
                   (case ptr_X4Dic of { Ptr addr_a46Xg [Occ=Once] ->
                    case off_X4Die of { I# x_i1MAD [Occ=Once] ->
                    GHC.Ptr.Ptr @ Fingerprint (plusAddr# addr_a46Xg (*# x_i1MAD 16#))
                    }
                    })
                   eta_B1}]
Foreign.Storable.$fStorableFingerprint6
  = \ (ptr_X4Dic :: Ptr Fingerprint)
      (off_X4Die :: Int)
      (eta_B1 :: State# RealWorld) ->
      Foreign.Storable.$fStorableFingerprint2
        (case ptr_X4Dic of { Ptr addr_a46Xg ->
         case off_X4Die of { I# x_i1MAD ->
         GHC.Ptr.Ptr @ Fingerprint (plusAddr# addr_a46Xg (*# x_i1MAD 16#))
         }
         })
        eta_B1

-- RHS size: {terms: 22, types: 17, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableFingerprint3
  :: forall b.
     Ptr b
     -> Int
     -> Fingerprint
     -> State# RealWorld
     -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (@ b_a4Dgs)
                 (ptr_X4Dio [Occ=Once!] :: Ptr b_a4Dgs)
                 (off_X4Diq [Occ=Once!] :: Int)
                 (eta_X9W [Occ=Once] :: Fingerprint)
                 (eta1_B1 [Occ=Once] :: State# RealWorld) ->
                 Foreign.Storable.$fStorableFingerprint1
                   (case ptr_X4Dio of { Ptr addr_a46Xg [Occ=Once] ->
                    case off_X4Diq of { I# d_a46Xh [Occ=Once] ->
                    GHC.Ptr.Ptr @ Fingerprint (plusAddr# addr_a46Xg d_a46Xh)
                    }
                    })
                   eta_X9W
                   eta1_B1}]
Foreign.Storable.$fStorableFingerprint3
  = \ (@ b_a4Dgs)
      (ptr_X4Dio :: Ptr b_a4Dgs)
      (off_X4Diq :: Int)
      (eta_X9W :: Fingerprint)
      (eta1_B1 :: State# RealWorld) ->
      case eta_X9W of { Fingerprint ww1_s4Ewz ww2_s4EwA ->
      Foreign.Storable.$w$cpoke
        (case ptr_X4Dio of { Ptr addr_a46Xg ->
         case off_X4Diq of { I# d_a46Xh ->
         GHC.Ptr.Ptr @ Fingerprint (plusAddr# addr_a46Xg d_a46Xh)
         }
         })
        ww1_s4Ewz
        ww2_s4EwA
        eta1_B1
      }

-- RHS size: {terms: 23, types: 15, coercions: 0, joins: 0/0}
Foreign.Storable.$fStorableFingerprint5
  :: Ptr Fingerprint
     -> Int
     -> Fingerprint
     -> State# RealWorld
     -> (# State# RealWorld, () #)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*U(U)><L,1*U(U)><S(SS),1*U(U,U)><S,U>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=4,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ptr_X4Dsl [Occ=Once!] :: Ptr Fingerprint)
                 (off_X4Dso [Occ=Once!] :: Int)
                 (val_X4Dis [Occ=Once] :: Fingerprint)
                 (eta_B1 [Occ=Once] :: State# RealWorld) ->
                 Foreign.Storable.$fStorableFingerprint1
                   (case ptr_X4Dsl of { Ptr addr_a46Xg [Occ=Once] ->
                    case off_X4Dso of { I# x_i1MAD [Occ=Once] ->
                    GHC.Ptr.Ptr @ Fingerprint (plusAddr# addr_a46Xg (*# x_i1MAD 16#))
                    }
                    })
                   val_X4Dis
                   eta_B1}]
Foreign.Storable.$fStorableFingerprint5
  = \ (ptr_X4Dsl :: Ptr Fingerprint)
      (off_X4Dso :: Int)
      (val_X4Dis :: Fingerprint)
      (eta_B1 :: State# RealWorld) ->
      case val_X4Dis of { Fingerprint ww1_s4Ewz ww2_s4EwA ->
      Foreign.Storable.$w$cpoke
        (case ptr_X4Dsl of { Ptr addr_a46Xg ->
         case off_X4Dso of { I# x_i1MAD ->
         GHC.Ptr.Ptr @ Fingerprint (plusAddr# addr_a46Xg (*# x_i1MAD 16#))
         }
         })
        ww1_s4Ewz
        ww2_s4EwA
        eta_B1
      }

-- RHS size: {terms: 9, types: 1, coercions: 56, joins: 0/0}
Foreign.Storable.$fStorableFingerprint [InlPrag=NOUSERINLINE CONLIKE]
  :: Storable Fingerprint
[GblId[DFunId],
 Caf=NoCafRefs,
 Str=m,
 Unf=DFun: \ ->
       Foreign.Storable.C:Storable TYPE: Fingerprint
                                   Foreign.Storable.$fStorableFingerprint_$csizeOf
                                   Foreign.Storable.$fStorableFingerprint_$calignment
                                   Foreign.Storable.$fStorableFingerprint6
                                   `cast` (<Ptr Fingerprint>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Fingerprint>_R)
                                           :: (Ptr Fingerprint
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Fingerprint #) :: *)
                                              ~R# (Ptr Fingerprint -> Int -> IO Fingerprint :: *))
                                   Foreign.Storable.$fStorableFingerprint5
                                   `cast` (<Ptr Fingerprint>_R
                                           ->_R <Int>_R
                                           ->_R <Fingerprint>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Fingerprint
                                               -> Int
                                               -> Fingerprint
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Fingerprint
                                                   -> Int -> Fingerprint -> IO () :: *))
                                   Foreign.Storable.$fStorableFingerprint4
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Fingerprint>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Fingerprint #) :: *)
                                              ~R# (forall b. Ptr b -> Int -> IO Fingerprint :: *))
                                   Foreign.Storable.$fStorableFingerprint3
                                   `cast` (forall (b :: <*>_N).
                                           <Ptr b>_R
                                           ->_R <Int>_R
                                           ->_R <Fingerprint>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (forall b.
                                               Ptr b
                                               -> Int
                                               -> Fingerprint
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (forall b.
                                                   Ptr b -> Int -> Fingerprint -> IO () :: *))
                                   Foreign.Storable.$fStorableFingerprint2
                                   `cast` (<Ptr Fingerprint>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <Fingerprint>_R)
                                           :: (Ptr Fingerprint
                                               -> State# RealWorld
                                               -> (# State# RealWorld, Fingerprint #) :: *)
                                              ~R# (Ptr Fingerprint -> IO Fingerprint :: *))
                                   Foreign.Storable.$fStorableFingerprint1
                                   `cast` (<Ptr Fingerprint>_R
                                           ->_R <Fingerprint>_R
                                           ->_R Sym (GHC.Types.N:IO[0] <()>_R)
                                           :: (Ptr Fingerprint
                                               -> Fingerprint
                                               -> State# RealWorld
                                               -> (# State# RealWorld, () #) :: *)
                                              ~R# (Ptr Fingerprint -> Fingerprint -> IO () :: *))]
Foreign.Storable.$fStorableFingerprint
  = Foreign.Storable.C:Storable
      @ Fingerprint
      Foreign.Storable.$fStorableFingerprint_$csizeOf
      Foreign.Storable.$fStorableFingerprint_$calignment
      (Foreign.Storable.$fStorableFingerprint6
       `cast` (<Ptr Fingerprint>_R
               ->_R <Int>_R
               ->_R Sym (GHC.Types.N:IO[0] <Fingerprint>_R)
               :: (Ptr Fingerprint
                   -> Int
                   -> State# RealWorld
                   -> (# State# RealWorld, Fingerprint #) :: *)
                  ~R# (Ptr Fingerprint -> Int -> IO Fingerprint :: *)))
      (Foreign.Storable.$fStorableFingerprint5
       `cast` (<Ptr Fingerprint>_R
               ->_R <Int>_R
               ->_R <Fingerprint>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Fingerprint
                   -> Int
                   -> Fingerprint
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Fingerprint -> Int -> Fingerprint -> IO () :: *)))
      (Foreign.Storable.$fStorableFingerprint4
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R ->_R <Int>_R ->_R Sym (GHC.Types.N:IO[0] <Fingerprint>_R)
               :: (forall b.
                   Ptr b
                   -> Int
                   -> State# RealWorld
                   -> (# State# RealWorld, Fingerprint #) :: *)
                  ~R# (forall b. Ptr b -> Int -> IO Fingerprint :: *)))
      (Foreign.Storable.$fStorableFingerprint3
       `cast` (forall (b :: <*>_N).
               <Ptr b>_R
               ->_R <Int>_R
               ->_R <Fingerprint>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (forall b.
                   Ptr b
                   -> Int
                   -> Fingerprint
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (forall b. Ptr b -> Int -> Fingerprint -> IO () :: *)))
      (Foreign.Storable.$fStorableFingerprint2
       `cast` (<Ptr Fingerprint>_R
               ->_R Sym (GHC.Types.N:IO[0] <Fingerprint>_R)
               :: (Ptr Fingerprint
                   -> State# RealWorld -> (# State# RealWorld, Fingerprint #) :: *)
                  ~R# (Ptr Fingerprint -> IO Fingerprint :: *)))
      (Foreign.Storable.$fStorableFingerprint1
       `cast` (<Ptr Fingerprint>_R
               ->_R <Fingerprint>_R
               ->_R Sym (GHC.Types.N:IO[0] <()>_R)
               :: (Ptr Fingerprint
                   -> Fingerprint
                   -> State# RealWorld
                   -> (# State# RealWorld, () #) :: *)
                  ~R# (Ptr Fingerprint -> Fingerprint -> IO () :: *)))


