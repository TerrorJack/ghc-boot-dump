
==================== Output Cmm ====================
2018-03-16 16:06:56.385532194 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:56.386457419 UTC

[section ""data" . Debug.Trace.traceEventIO2_closure" {
     Debug.Trace.traceEventIO2_closure:
         const Debug.Trace.traceEventIO2_info;
 },
 Debug.Trace.traceEventIO2_entry() //  [R2]
         { info_tbl: [(cc2vX,
                       label: Debug.Trace.traceEventIO2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2vX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc2w1; else goto cc2w2;
       cc2w1: // global
           R2 = R2;
           R1 = Debug.Trace.traceEventIO2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2w2: // global
           I64[Sp - 8] = block_cc2vU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc2w6; else goto cc2vV;
       uc2w6: // global
           call _cc2vU(R1) args: 0, res: 0, upd: 0;
       cc2vV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2vU() //  [R1]
         { info_tbl: [(cc2vU,
                       label: block_cc2vU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2vU: // global
           I64[Sp] = block_cc2w0_info;
           R1 = I64[R1 + 7];
           call stg_traceEvent#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2w0() //  []
         { info_tbl: [(cc2w0,
                       label: block_cc2w0_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2w0: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.387700632 UTC

[section ""data" . Debug.Trace.traceEventIO1_closure" {
     Debug.Trace.traceEventIO1_closure:
         const Debug.Trace.traceEventIO1_info;
         const 0;
 },
 Debug.Trace.traceEventIO1_entry() //  [R2]
         { info_tbl: [(cc2wb,
                       label: Debug.Trace.traceEventIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2wb: // global
           R4 = Debug.Trace.traceEventIO2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.388546326 UTC

[section ""data" . Debug.Trace.traceEventIO_closure" {
     Debug.Trace.traceEventIO_closure:
         const Debug.Trace.traceEventIO_info;
         const 0;
 },
 Debug.Trace.traceEventIO_entry() //  [R2]
         { info_tbl: [(cc2wj,
                       label: Debug.Trace.traceEventIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2wj: // global
           R2 = R2;
           call Debug.Trace.traceEventIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.391028456 UTC

[section ""data" . Debug.Trace.traceMarkerIO2_closure" {
     Debug.Trace.traceMarkerIO2_closure:
         const Debug.Trace.traceMarkerIO2_info;
 },
 Debug.Trace.traceMarkerIO2_entry() //  [R2]
         { info_tbl: [(cc2wt,
                       label: Debug.Trace.traceMarkerIO2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2wt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc2wx; else goto cc2wy;
       cc2wx: // global
           R2 = R2;
           R1 = Debug.Trace.traceMarkerIO2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2wy: // global
           I64[Sp - 8] = block_cc2wq_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc2wC; else goto cc2wr;
       uc2wC: // global
           call _cc2wq(R1) args: 0, res: 0, upd: 0;
       cc2wr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2wq() //  [R1]
         { info_tbl: [(cc2wq,
                       label: block_cc2wq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2wq: // global
           I64[Sp] = block_cc2ww_info;
           R1 = I64[R1 + 7];
           call stg_traceMarker#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2ww() //  []
         { info_tbl: [(cc2ww,
                       label: block_cc2ww_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2ww: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.392399102 UTC

[section ""data" . Debug.Trace.traceMarkerIO1_closure" {
     Debug.Trace.traceMarkerIO1_closure:
         const Debug.Trace.traceMarkerIO1_info;
         const 0;
 },
 Debug.Trace.traceMarkerIO1_entry() //  [R2]
         { info_tbl: [(cc2wH,
                       label: Debug.Trace.traceMarkerIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2wH: // global
           R4 = Debug.Trace.traceMarkerIO2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.393419424 UTC

[section ""data" . Debug.Trace.traceMarkerIO_closure" {
     Debug.Trace.traceMarkerIO_closure:
         const Debug.Trace.traceMarkerIO_info;
         const 0;
 },
 Debug.Trace.traceMarkerIO_entry() //  [R2]
         { info_tbl: [(cc2wO,
                       label: Debug.Trace.traceMarkerIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2wO: // global
           R2 = R2;
           call Debug.Trace.traceMarkerIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.394189091 UTC

[section ""cstring" . Debug.Trace.$trModule4_bytes" {
     Debug.Trace.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.394848016 UTC

[section ""data" . Debug.Trace.$trModule3_closure" {
     Debug.Trace.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Debug.Trace.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.395498462 UTC

[section ""cstring" . Debug.Trace.$trModule2_bytes" {
     Debug.Trace.$trModule2_bytes:
         I8[] [68,101,98,117,103,46,84,114,97,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.396127494 UTC

[section ""data" . Debug.Trace.$trModule1_closure" {
     Debug.Trace.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Debug.Trace.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.396785618 UTC

[section ""data" . Debug.Trace.$trModule_closure" {
     Debug.Trace.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Debug.Trace.$trModule3_closure+1;
         const Debug.Trace.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.397728337 UTC

[section ""data" . Debug.Trace.traceMarker_closure" {
     Debug.Trace.traceMarker_closure:
         const Debug.Trace.traceMarker_info;
         const 0;
 },
 Debug.Trace.traceMarker_entry() //  [R2, R3]
         { info_tbl: [(cc2x0,
                       label: Debug.Trace.traceMarker_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2x0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2x1; else goto cc2x2;
       cc2x1: // global
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceMarker_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2x2: // global
           I64[Sp - 16] = block_cc2wV_info;
           R4 = Debug.Trace.traceMarkerIO2_closure+2;
           _sc2tx::P64 = R3;
           R3 = R2;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp - 8] = _sc2tx::P64;
           Sp = Sp - 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2wV() //  []
         { info_tbl: [(cc2wV,
                       label: block_cc2wV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2wV: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.399641054 UTC

[section ""data" . Debug.Trace.traceEvent_closure" {
     Debug.Trace.traceEvent_closure:
         const Debug.Trace.traceEvent_info;
         const 0;
 },
 Debug.Trace.traceEvent_entry() //  [R2, R3]
         { info_tbl: [(cc2xe,
                       label: Debug.Trace.traceEvent_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2xe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2xf; else goto cc2xg;
       cc2xf: // global
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceEvent_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2xg: // global
           I64[Sp - 16] = block_cc2x9_info;
           R4 = Debug.Trace.traceEventIO2_closure+2;
           _sc2tF::P64 = R3;
           R3 = R2;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp - 8] = _sc2tF::P64;
           Sp = Sp - 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2x9() //  []
         { info_tbl: [(cc2x9,
                       label: block_cc2x9_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2x9: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.40074646 UTC

[section ""cstring" . Debug.Trace.putTraceMsg5_bytes" {
     Debug.Trace.putTraceMsg5_bytes:
         I8[] [37,115,10]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.401599579 UTC

[section ""data" . Debug.Trace.putTraceMsg4_closure" {
     Debug.Trace.putTraceMsg4_closure:
         const Debug.Trace.putTraceMsg4_info;
         const 0;
         const 0;
         const 0;
 },
 Debug.Trace.putTraceMsg4_entry() //  [R1]
         { info_tbl: [(cc2xp,
                       label: Debug.Trace.putTraceMsg4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2xp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2xq; else goto cc2xr;
       cc2xq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2xr: // global
           (_cc2xm::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc2xm::I64 == 0) goto cc2xo; else goto cc2xn;
       cc2xo: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc2xn: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc2xm::I64;
           R2 = Debug.Trace.putTraceMsg5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.402574249 UTC

[section ""cstring" . Debug.Trace.putTraceMsg3_bytes" {
     Debug.Trace.putTraceMsg3_bytes:
         I8[] [87,65,82,78,73,78,71,58,32,112,114,101,118,105,111,117,115,32,116,114,97,99,101,32,109,101,115,115,97,103,101,32,104,97,100,32,110,117,108,108,32,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.403374517 UTC

[section ""data" . Debug.Trace.putTraceMsg2_closure" {
     Debug.Trace.putTraceMsg2_closure:
         const Debug.Trace.putTraceMsg2_info;
         const 0;
         const 0;
         const 0;
 },
 Debug.Trace.putTraceMsg2_entry() //  [R1]
         { info_tbl: [(cc2xy,
                       label: Debug.Trace.putTraceMsg2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2xy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2xz; else goto cc2xA;
       cc2xz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2xA: // global
           (_cc2xv::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc2xv::I64 == 0) goto cc2xx; else goto cc2xw;
       cc2xx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc2xw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc2xv::I64;
           R2 = Debug.Trace.putTraceMsg3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.40523326 UTC

[section ""data" . Debug.Trace.$wgo_closure" {
     Debug.Trace.$wgo_closure:
         const Debug.Trace.$wgo_info;
 },
 w2_sc2tS_entry() //  [R1]
         { info_tbl: [(cc2xX,
                       label: w2_sc2tS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2xX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc2xY; else goto cc2xZ;
       cc2xY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2xZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cc2xU_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Debug.Trace.$wgo_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc2xU() //  [R1, R2]
         { info_tbl: [(cc2xU,
                       label: block_cc2xU_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2xU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc2y2; else goto cc2y1;
       cc2y2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cc2y1: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Debug.Trace.$wgo_entry() //  [R2]
         { info_tbl: [(cc2y7,
                       label: Debug.Trace.$wgo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2y7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2y8; else goto cc2y9;
       cc2y8: // global
           R2 = R2;
           R1 = Debug.Trace.$wgo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2y9: // global
           I64[Sp - 8] = block_cc2xF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc2yt; else goto cc2xG;
       uc2yt: // global
           call _cc2xF(R1) args: 0, res: 0, upd: 0;
       cc2xG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2xF() //  [R1]
         { info_tbl: [(cc2xF,
                       label: block_cc2xF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2xF: // global
           if (R1 & 7 == 1) goto cc2y4; else goto cc2y5;
       cc2y4: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cc2y5: // global
           I64[Sp - 8] = block_cc2xL_info;
           _sc2tP::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sc2tP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc2ys; else goto cc2xM;
       uc2ys: // global
           call _cc2xL(R1) args: 0, res: 0, upd: 0;
       cc2xM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2xL() //  [R1]
         { info_tbl: [(cc2xL,
                       label: block_cc2xL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2xL: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cc2yf; else goto cc2ye;
       cc2yf: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc2ye: // global
           _sc2tR::I64 = I64[R1 + 7];
           I64[Hp - 88] = w2_sc2tS_info;
           P64[Hp - 72] = P64[Sp + 8];
           _cc2xQ::P64 = Hp - 88;
           if (_sc2tR::I64 == 0) goto cc2yr; else goto cc2ym;
       cc2yr: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _cc2xQ::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cc2xQ::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cc2ym: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _cc2xQ::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _cc2xQ::P64;
           R2 = Hp - 38;
           R1 = Hp - 16;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.409015909 UTC

[section ""data" . Debug.Trace.putTraceMsg1_closure" {
     Debug.Trace.putTraceMsg1_closure:
         const Debug.Trace.putTraceMsg1_info;
         const 0;
 },
 ds_sc2uk_entry() //  [R1]
         { info_tbl: [(cc2yH,
                       label: ds_sc2uk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2yH: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc2yI; else goto cc2yJ;
       cc2yI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2yJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cc2yE_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Debug.Trace.$wgo_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc2yE() //  [R1, R2]
         { info_tbl: [(cc2yE,
                       label: block_cc2yE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2yE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc2yM; else goto cc2yL;
       cc2yM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cc2yL: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc2uG_entry() //  [R1, R2]
         { info_tbl: [(cc2z3,
                       label: sat_sc2uG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2z3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2z7; else goto cc2z8;
       cc2z7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2z8: // global
           I64[Sp - 16] = block_cc2z0_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc2zj; else goto cc2z1;
       uc2zj: // global
           call _cc2z0(R1) args: 0, res: 0, upd: 0;
       cc2z1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2z0() //  [R1]
         { info_tbl: [(cc2z0,
                       label: block_cc2z0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2z0: // global
           I64[Sp] = block_cc2z6_info;
           _sc2uA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sc2uA::I64;
           if (R1 & 7 != 0) goto uc2zi; else goto cc2za;
       uc2zi: // global
           call _cc2z6(R1) args: 0, res: 0, upd: 0;
       cc2za: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2z6() //  [R1]
         { info_tbl: [(cc2z6,
                       label: block_cc2z6_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2z6: // global
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] debugBelch2(I64[Sp + 8], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc2v2_entry() //  [R1, R2]
         { info_tbl: [(cc2zH,
                       label: sat_sc2v2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2zH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2zL; else goto cc2zM;
       cc2zL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2zM: // global
           I64[Sp - 16] = block_cc2zE_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc2zX; else goto cc2zF;
       uc2zX: // global
           call _cc2zE(R1) args: 0, res: 0, upd: 0;
       cc2zF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2zE() //  [R1]
         { info_tbl: [(cc2zE,
                       label: block_cc2zE_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2zE: // global
           I64[Sp] = block_cc2zK_info;
           _sc2uW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sc2uW::I64;
           if (R1 & 7 != 0) goto uc2zW; else goto cc2zO;
       uc2zW: // global
           call _cc2zK(R1) args: 0, res: 0, upd: 0;
       cc2zO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2zK() //  [R1]
         { info_tbl: [(cc2zK,
                       label: block_cc2zK_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2zK: // global
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] debugBelch2(I64[Sp + 8], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc2v3_entry() //  [R1, R2]
         { info_tbl: [(cc2zY,
                       label: sat_sc2v3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2zY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc2zZ; else goto cc2A0;
       cc2zZ: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2A0: // global
           I64[Sp - 32] = block_cc2yT_info;
           _sc2uk::P64 = P64[R1 + 6];
           _sc2uo::P64 = P64[R1 + 14];
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 24] = _sc2uk::P64;
           P64[Sp - 16] = _sc2uo::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2yT() //  [R1]
         { info_tbl: [(cc2yT,
                       label: block_cc2yT_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2yT: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc2A3; else goto cc2A2;
       cc2A3: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc2A2: // global
           I64[Hp - 8] = sat_sc2uG_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_cc2zk_info;
           R4 = Hp - 6;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2zk() //  []
         { info_tbl: [(cc2zk,
                       label: block_cc2zk_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2zk: // global
           I64[Sp + 16] = block_cc2zm_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uc2Ag; else goto cc2zn;
       uc2Ag: // global
           call _cc2zm(R1) args: 0, res: 0, upd: 0;
       cc2zn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2zm() //  [R1]
         { info_tbl: [(cc2zm,
                       label: block_cc2zm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2zm: // global
           I64[Sp] = block_cc2zr_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto uc2Ah; else goto cc2zs;
       uc2Ah: // global
           call _cc2zr(R1) args: 0, res: 0, upd: 0;
       cc2zs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2zr() //  [R1]
         { info_tbl: [(cc2zr,
                       label: block_cc2zr_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2zr: // global
           if (R1 & 7 == 1) goto cc2A9; else goto cc2Ab;
       cc2A9: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc2Ab: // global
           I64[Sp] = block_cc2zx_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2zx() //  [R1]
         { info_tbl: [(cc2zx,
                       label: block_cc2zx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2zx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc2Ae; else goto cc2Ad;
       cc2Ae: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc2Ad: // global
           I64[Hp - 8] = sat_sc2v2_info;
           P64[Hp] = P64[Sp + 8];
           R4 = Hp - 6;
           R3 = Debug.Trace.putTraceMsg2_closure;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Debug.Trace.putTraceMsg1_entry() //  [R2]
         { info_tbl: [(cc2Ai,
                       label: Debug.Trace.putTraceMsg1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Ai: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2Aj; else goto cc2Ak;
       cc2Aj: // global
           R2 = R2;
           R1 = Debug.Trace.putTraceMsg1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2Ak: // global
           I64[Sp - 16] = block_cc2yy_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2yy() //  [R1]
         { info_tbl: [(cc2yy,
                       label: block_cc2yy_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2yy: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cc2An; else goto cc2Am;
       cc2An: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc2Am: // global
           I64[Hp - 64] = ds_sc2uk_info;
           P64[Hp - 48] = P64[Sp + 8];
           I64[Hp - 40] = stg_sel_1_upd_info;
           _cc2yA::P64 = Hp - 64;
           P64[Hp - 24] = _cc2yA::P64;
           I64[Hp - 16] = sat_sc2v3_info;
           P64[Hp - 8] = _cc2yA::P64;
           P64[Hp] = Hp - 40;
           R4 = Hp - 14;
           R3 = Debug.Trace.putTraceMsg4_closure;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.414358728 UTC

[section ""data" . Debug.Trace.traceIO_closure" {
     Debug.Trace.traceIO_closure:
         const Debug.Trace.traceIO_info;
         const 0;
 },
 Debug.Trace.traceIO_entry() //  [R2]
         { info_tbl: [(cc2As,
                       label: Debug.Trace.traceIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2As: // global
           R2 = R2;
           call Debug.Trace.putTraceMsg1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.415164921 UTC

[section ""data" . Debug.Trace.putTraceMsg_closure" {
     Debug.Trace.putTraceMsg_closure:
         const Debug.Trace.putTraceMsg_info;
         const 0;
 },
 Debug.Trace.putTraceMsg_entry() //  [R2]
         { info_tbl: [(cc2Az,
                       label: Debug.Trace.putTraceMsg_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Az: // global
           R2 = R2;
           call Debug.Trace.putTraceMsg1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.416084843 UTC

[section ""data" . Debug.Trace.trace_closure" {
     Debug.Trace.trace_closure:
         const Debug.Trace.trace_info;
         const 0;
 },
 Debug.Trace.trace_entry() //  [R2, R3]
         { info_tbl: [(cc2AN,
                       label: Debug.Trace.trace_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2AN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc2AO; else goto cc2AP;
       cc2AO: // global
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.trace_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2AP: // global
           I64[Sp - 24] = block_cc2AG_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cc2AG() //  []
         { info_tbl: [(cc2AG,
                       label: block_cc2AG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2AG: // global
           _sc2v4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc2AI_info;
           R2 = _sc2v4::P64;
           Sp = Sp + 8;
           call Debug.Trace.putTraceMsg1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2AI() //  []
         { info_tbl: [(cc2AI,
                       label: block_cc2AI_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2AI: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.417285215 UTC

[section ""data" . Debug.Trace.traceId_closure" {
     Debug.Trace.traceId_closure:
         const Debug.Trace.traceId_info;
         const 0;
 },
 Debug.Trace.traceId_entry() //  [R2]
         { info_tbl: [(cc2AX,
                       label: Debug.Trace.traceId_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2AX: // global
           R3 = R2;
           R2 = R2;
           call Debug.Trace.trace_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.418325678 UTC

[section ""data" . Debug.Trace.traceShow_closure" {
     Debug.Trace.traceShow_closure:
         const Debug.Trace.traceShow_info;
         const 0;
 },
 sat_sc2vg_entry() //  [R1]
         { info_tbl: [(cc2B8,
                       label: sat_sc2vg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2B8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc2B9; else goto cc2Ba;
       cc2B9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2Ba: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.show_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Debug.Trace.traceShow_entry() //  [R2, R3]
         { info_tbl: [(cc2Bb,
                       label: Debug.Trace.traceShow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Bb: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc2Bf; else goto cc2Be;
       cc2Bf: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceShow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2Be: // global
           I64[Hp - 24] = sat_sc2vg_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Debug.Trace.trace_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.419722291 UTC

[section ""data" . Debug.Trace.traceShowId_closure" {
     Debug.Trace.traceShowId_closure:
         const Debug.Trace.traceShowId_info;
         const 0;
 },
 sat_sc2vj_entry() //  [R1]
         { info_tbl: [(cc2Bo,
                       label: sat_sc2vj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Bo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2Bp; else goto cc2Bq;
       cc2Bp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2Bq: // global
           R2 = P64[R1 + 16];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Show.show_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Debug.Trace.traceShowId_entry() //  [R2, R3]
         { info_tbl: [(cc2Br,
                       label: Debug.Trace.traceShowId_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Br: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc2Bv; else goto cc2Bu;
       cc2Bv: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceShowId_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2Bu: // global
           I64[Hp - 24] = sat_sc2vj_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = R3;
           R2 = Hp - 24;
           call Debug.Trace.trace_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.421051995 UTC

[section ""data" . Debug.Trace.traceM_closure" {
     Debug.Trace.traceM_closure:
         const Debug.Trace.traceM_info;
         const 0;
 },
 sat_sc2vm_entry() //  [R1]
         { info_tbl: [(cc2BE,
                       label: sat_sc2vm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2BE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc2BF; else goto cc2BG;
       cc2BF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2BG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Debug.Trace.traceM_entry() //  [R2, R3]
         { info_tbl: [(cc2BH,
                       label: Debug.Trace.traceM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2BH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc2BL; else goto cc2BK;
       cc2BL: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2BK: // global
           I64[Hp - 16] = sat_sc2vm_info;
           P64[Hp] = R2;
           _sc2vl::P64 = R3;
           R3 = Hp - 16;
           R2 = _sc2vl::P64;
           call Debug.Trace.trace_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.422684711 UTC

[section ""data" . Debug.Trace.traceShowM_closure" {
     Debug.Trace.traceShowM_closure:
         const Debug.Trace.traceShowM_info;
         const 0;
 },
 sat_sc2vr_entry() //  [R1]
         { info_tbl: [(cc2BU,
                       label: sat_sc2vr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2BU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc2BV; else goto cc2BW;
       cc2BV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2BW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc2vq_entry() //  [R1]
         { info_tbl: [(cc2C1,
                       label: sat_sc2vq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2C1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2C2; else goto cc2C3;
       cc2C2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2C3: // global
           R2 = P64[R1 + 16];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Show.show_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Debug.Trace.traceShowM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc2C4,
                       label: Debug.Trace.traceShowM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2C4: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc2C8; else goto cc2C7;
       cc2C8: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceShowM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2C7: // global
           I64[Hp - 48] = sat_sc2vr_info;
           P64[Hp - 32] = R3;
           I64[Hp - 24] = sat_sc2vq_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R3 = Hp - 48;
           R2 = Hp - 24;
           call Debug.Trace.trace_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.424966573 UTC

[section ""data" . Debug.Trace.traceStack_closure" {
     Debug.Trace.traceStack_closure:
         const Debug.Trace.traceStack_info;
         const 0;
 },
 sat_sc2vI_entry() //  [R1]
         { info_tbl: [(cc2Cz,
                       label: sat_sc2vI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Cz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc2CA; else goto cc2CB;
       cc2CA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2CB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cc2Cx_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc2Cx() //  [R1]
         { info_tbl: [(cc2Cx,
                       label: block_cc2Cx_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Cx: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Stack.CCS.renderStack_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc2vJ_entry() //  [R1]
         { info_tbl: [(cc2CF,
                       label: sat_sc2vJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2CF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc2CJ; else goto cc2CI;
       cc2CJ: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2CI: // global
           _sc2vE::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_sc2vI_info;
           P64[Hp] = _sc2vE::P64;
           R3 = Hp - 16;
           R2 = GHC.Stack.CCS.renderStack1_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Debug.Trace.traceStack_entry() //  [R2, R3]
         { info_tbl: [(cc2CR,
                       label: Debug.Trace.traceStack_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2CR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc2CS; else goto cc2CT;
       cc2CS: // global
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceStack_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2CT: // global
           I64[Sp - 24] = block_cc2Cd_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cc2Cd() //  []
         { info_tbl: [(cc2Cd,
                       label: block_cc2Cd_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Cd: // global
           _sc2vs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc2Cf_info;
           R2 = _sc2vs::P64;
           Sp = Sp + 8;
           call Debug.Trace.putTraceMsg1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Cf() //  []
         { info_tbl: [(cc2Cf,
                       label: block_cc2Cf_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Cf: // global
           I64[Sp] = block_cc2Ch_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = CCCS;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Ch() //  [R1]
         { info_tbl: [(cc2Ch,
                       label: block_cc2Ch_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Ch: // global
           I64[Sp] = block_cc2Cj_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uc2D8; else goto cc2Ck;
       uc2D8: // global
           call _cc2Cj(R1) args: 0, res: 0, upd: 0;
       cc2Ck: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Cj() //  [R1]
         { info_tbl: [(cc2Cj,
                       label: block_cc2Cj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Cj: // global
           if (R1 & 7 == 1) goto cc2CL; else goto cc2CM;
       cc2CL: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cc2CK() args: 0, res: 0, upd: 0;
       cc2CM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc2D2; else goto cc2D1;
       cc2D2: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc2D1: // global
           I64[Hp - 16] = sat_sc2vJ_info;
           P64[Hp] = R1;
           I64[Sp] = block_cc2CZ_info;
           R2 = Hp - 16;
           call Debug.Trace.putTraceMsg1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2CZ() //  []
         { info_tbl: [(cc2CZ,
                       label: block_cc2CZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2CZ: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cc2CK() args: 0, res: 0, upd: 0;
     }
 },
 _cc2CK() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2CK: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.42802244 UTC

[section ""relreadonly" . Sc2we_srt" {
     Sc2we_srt:
         const GHC.IO.Encoding.UTF8.utf8_closure;
         const Debug.Trace.traceEventIO1_closure;
         const Debug.Trace.traceMarkerIO1_closure;
         const Debug.Trace.traceMarker_closure;
         const Debug.Trace.traceEvent_closure;
         const GHC.IO.Encoding.getForeignEncoding_closure;
         const Debug.Trace.putTraceMsg2_closure;
         const Debug.Trace.putTraceMsg1_closure;
         const Debug.Trace.putTraceMsg4_closure;
         const Debug.Trace.trace_closure;
         const Debug.Trace.traceShow_closure;
         const Debug.Trace.traceShowId_closure;
         const Debug.Trace.traceM_closure;
         const Debug.Trace.traceShowM_closure;
         const GHC.Stack.CCS.renderStack_go_closure;
         const GHC.Stack.CCS.$wgo_closure;
         const Debug.Trace.traceStack_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.428634684 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:56.429373583 UTC

[section ""data" . Debug.Trace.traceEventIO2_closure" {
     Debug.Trace.traceEventIO2_closure:
         const Debug.Trace.traceEventIO2_info;
 },
 Debug.Trace.traceEventIO2_entry() //  [R2]
         { info_tbl: [(cc2Di,
                       label: Debug.Trace.traceEventIO2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Di: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc2Dm; else goto cc2Dn;
       cc2Dm: // global
           R2 = R2;
           R1 = Debug.Trace.traceEventIO2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2Dn: // global
           I64[Sp - 8] = block_cc2Df_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc2Dr; else goto cc2Dg;
       uc2Dr: // global
           call _cc2Df(R1) args: 0, res: 0, upd: 0;
       cc2Dg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Df() //  [R1]
         { info_tbl: [(cc2Df,
                       label: block_cc2Df_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Df: // global
           I64[Sp] = block_cc2Dl_info;
           R1 = I64[R1 + 7];
           call stg_traceEvent#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Dl() //  []
         { info_tbl: [(cc2Dl,
                       label: block_cc2Dl_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Dl: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.430553703 UTC

[section ""data" . Debug.Trace.traceEventIO1_closure" {
     Debug.Trace.traceEventIO1_closure:
         const Debug.Trace.traceEventIO1_info;
         const 0;
 },
 Debug.Trace.traceEventIO1_entry() //  [R2]
         { info_tbl: [(cc2Dw,
                       label: Debug.Trace.traceEventIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Dw: // global
           R4 = Debug.Trace.traceEventIO2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.431377536 UTC

[section ""data" . Debug.Trace.traceEventIO_closure" {
     Debug.Trace.traceEventIO_closure:
         const Debug.Trace.traceEventIO_info;
         const 0;
 },
 Debug.Trace.traceEventIO_entry() //  [R2]
         { info_tbl: [(cc2DD,
                       label: Debug.Trace.traceEventIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2DD: // global
           R2 = R2;
           call Debug.Trace.traceEventIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.432269611 UTC

[section ""data" . Debug.Trace.traceMarkerIO2_closure" {
     Debug.Trace.traceMarkerIO2_closure:
         const Debug.Trace.traceMarkerIO2_info;
 },
 Debug.Trace.traceMarkerIO2_entry() //  [R2]
         { info_tbl: [(cc2DN,
                       label: Debug.Trace.traceMarkerIO2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2DN: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc2DR; else goto cc2DS;
       cc2DR: // global
           R2 = R2;
           R1 = Debug.Trace.traceMarkerIO2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2DS: // global
           I64[Sp - 8] = block_cc2DK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc2DW; else goto cc2DL;
       uc2DW: // global
           call _cc2DK(R1) args: 0, res: 0, upd: 0;
       cc2DL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2DK() //  [R1]
         { info_tbl: [(cc2DK,
                       label: block_cc2DK_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2DK: // global
           I64[Sp] = block_cc2DQ_info;
           R1 = I64[R1 + 7];
           call stg_traceMarker#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2DQ() //  []
         { info_tbl: [(cc2DQ,
                       label: block_cc2DQ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2DQ: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.433655957 UTC

[section ""data" . Debug.Trace.traceMarkerIO1_closure" {
     Debug.Trace.traceMarkerIO1_closure:
         const Debug.Trace.traceMarkerIO1_info;
         const 0;
 },
 Debug.Trace.traceMarkerIO1_entry() //  [R2]
         { info_tbl: [(cc2E1,
                       label: Debug.Trace.traceMarkerIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2E1: // global
           R4 = Debug.Trace.traceMarkerIO2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.434538963 UTC

[section ""data" . Debug.Trace.traceMarkerIO_closure" {
     Debug.Trace.traceMarkerIO_closure:
         const Debug.Trace.traceMarkerIO_info;
         const 0;
 },
 Debug.Trace.traceMarkerIO_entry() //  [R2]
         { info_tbl: [(cc2E8,
                       label: Debug.Trace.traceMarkerIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2E8: // global
           R2 = R2;
           call Debug.Trace.traceMarkerIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.435257743 UTC

[section ""cstring" . Debug.Trace.$trModule4_bytes" {
     Debug.Trace.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.43585396 UTC

[section ""data" . Debug.Trace.$trModule3_closure" {
     Debug.Trace.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Debug.Trace.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.436411648 UTC

[section ""cstring" . Debug.Trace.$trModule2_bytes" {
     Debug.Trace.$trModule2_bytes:
         I8[] [68,101,98,117,103,46,84,114,97,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.436921465 UTC

[section ""data" . Debug.Trace.$trModule1_closure" {
     Debug.Trace.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Debug.Trace.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.437540871 UTC

[section ""data" . Debug.Trace.$trModule_closure" {
     Debug.Trace.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Debug.Trace.$trModule3_closure+1;
         const Debug.Trace.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.438361144 UTC

[section ""data" . Debug.Trace.traceMarker_closure" {
     Debug.Trace.traceMarker_closure:
         const Debug.Trace.traceMarker_info;
         const 0;
 },
 Debug.Trace.traceMarker_entry() //  [R2, R3]
         { info_tbl: [(cc2Ek,
                       label: Debug.Trace.traceMarker_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Ek: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2El; else goto cc2Em;
       cc2El: // global
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceMarker_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2Em: // global
           I64[Sp - 16] = block_cc2Ef_info;
           R4 = Debug.Trace.traceMarkerIO2_closure+2;
           _sc2tx::P64 = R3;
           R3 = R2;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp - 8] = _sc2tx::P64;
           Sp = Sp - 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Ef() //  []
         { info_tbl: [(cc2Ef,
                       label: block_cc2Ef_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Ef: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.439601712 UTC

[section ""data" . Debug.Trace.traceEvent_closure" {
     Debug.Trace.traceEvent_closure:
         const Debug.Trace.traceEvent_info;
         const 0;
 },
 Debug.Trace.traceEvent_entry() //  [R2, R3]
         { info_tbl: [(cc2Ey,
                       label: Debug.Trace.traceEvent_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Ey: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2Ez; else goto cc2EA;
       cc2Ez: // global
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceEvent_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2EA: // global
           I64[Sp - 16] = block_cc2Et_info;
           R4 = Debug.Trace.traceEventIO2_closure+2;
           _sc2tF::P64 = R3;
           R3 = R2;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp - 8] = _sc2tF::P64;
           Sp = Sp - 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Et() //  []
         { info_tbl: [(cc2Et,
                       label: block_cc2Et_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Et: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.441129332 UTC

[section ""cstring" . Debug.Trace.putTraceMsg5_bytes" {
     Debug.Trace.putTraceMsg5_bytes:
         I8[] [37,115,10]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.441895086 UTC

[section ""data" . Debug.Trace.putTraceMsg4_closure" {
     Debug.Trace.putTraceMsg4_closure:
         const Debug.Trace.putTraceMsg4_info;
         const 0;
         const 0;
         const 0;
 },
 Debug.Trace.putTraceMsg4_entry() //  [R1]
         { info_tbl: [(cc2EJ,
                       label: Debug.Trace.putTraceMsg4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2EJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2EK; else goto cc2EL;
       cc2EK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2EL: // global
           (_cc2EG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc2EG::I64 == 0) goto cc2EI; else goto cc2EH;
       cc2EI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc2EH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc2EG::I64;
           R2 = Debug.Trace.putTraceMsg5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.442774054 UTC

[section ""cstring" . Debug.Trace.putTraceMsg3_bytes" {
     Debug.Trace.putTraceMsg3_bytes:
         I8[] [87,65,82,78,73,78,71,58,32,112,114,101,118,105,111,117,115,32,116,114,97,99,101,32,109,101,115,115,97,103,101,32,104,97,100,32,110,117,108,108,32,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.443473635 UTC

[section ""data" . Debug.Trace.putTraceMsg2_closure" {
     Debug.Trace.putTraceMsg2_closure:
         const Debug.Trace.putTraceMsg2_info;
         const 0;
         const 0;
         const 0;
 },
 Debug.Trace.putTraceMsg2_entry() //  [R1]
         { info_tbl: [(cc2ES,
                       label: Debug.Trace.putTraceMsg2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2ES: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2ET; else goto cc2EU;
       cc2ET: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2EU: // global
           (_cc2EP::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc2EP::I64 == 0) goto cc2ER; else goto cc2EQ;
       cc2ER: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc2EQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc2EP::I64;
           R2 = Debug.Trace.putTraceMsg3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.445134971 UTC

[section ""data" . Debug.Trace.$wgo_closure" {
     Debug.Trace.$wgo_closure:
         const Debug.Trace.$wgo_info;
 },
 w2_sc2tS_entry() //  [R1]
         { info_tbl: [(cc2Fh,
                       label: w2_sc2tS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Fh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc2Fi; else goto cc2Fj;
       cc2Fi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2Fj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cc2Fe_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Debug.Trace.$wgo_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc2Fe() //  [R1, R2]
         { info_tbl: [(cc2Fe,
                       label: block_cc2Fe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Fe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc2Fm; else goto cc2Fl;
       cc2Fm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cc2Fl: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Debug.Trace.$wgo_entry() //  [R2]
         { info_tbl: [(cc2Fr,
                       label: Debug.Trace.$wgo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Fr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2Fs; else goto cc2Ft;
       cc2Fs: // global
           R2 = R2;
           R1 = Debug.Trace.$wgo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2Ft: // global
           I64[Sp - 8] = block_cc2EZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc2FN; else goto cc2F0;
       uc2FN: // global
           call _cc2EZ(R1) args: 0, res: 0, upd: 0;
       cc2F0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2EZ() //  [R1]
         { info_tbl: [(cc2EZ,
                       label: block_cc2EZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2EZ: // global
           if (R1 & 7 == 1) goto cc2Fo; else goto cc2Fp;
       cc2Fo: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cc2Fp: // global
           I64[Sp - 8] = block_cc2F5_info;
           _sc2tP::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sc2tP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc2FM; else goto cc2F6;
       uc2FM: // global
           call _cc2F5(R1) args: 0, res: 0, upd: 0;
       cc2F6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2F5() //  [R1]
         { info_tbl: [(cc2F5,
                       label: block_cc2F5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2F5: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cc2Fz; else goto cc2Fy;
       cc2Fz: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc2Fy: // global
           _sc2tR::I64 = I64[R1 + 7];
           I64[Hp - 88] = w2_sc2tS_info;
           P64[Hp - 72] = P64[Sp + 8];
           _cc2Fa::P64 = Hp - 88;
           if (_sc2tR::I64 == 0) goto cc2FL; else goto cc2FG;
       cc2FL: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _cc2Fa::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cc2Fa::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cc2FG: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _cc2Fa::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _cc2Fa::P64;
           R2 = Hp - 38;
           R1 = Hp - 16;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.449072749 UTC

[section ""data" . Debug.Trace.putTraceMsg1_closure" {
     Debug.Trace.putTraceMsg1_closure:
         const Debug.Trace.putTraceMsg1_info;
         const 0;
 },
 ds_sc2uk_entry() //  [R1]
         { info_tbl: [(cc2G1,
                       label: ds_sc2uk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2G1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc2G2; else goto cc2G3;
       cc2G2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2G3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cc2FY_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Debug.Trace.$wgo_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc2FY() //  [R1, R2]
         { info_tbl: [(cc2FY,
                       label: block_cc2FY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2FY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc2G6; else goto cc2G5;
       cc2G6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cc2G5: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc2uG_entry() //  [R1, R2]
         { info_tbl: [(cc2Gn,
                       label: sat_sc2uG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Gn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2Gr; else goto cc2Gs;
       cc2Gr: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2Gs: // global
           I64[Sp - 16] = block_cc2Gk_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc2GD; else goto cc2Gl;
       uc2GD: // global
           call _cc2Gk(R1) args: 0, res: 0, upd: 0;
       cc2Gl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Gk() //  [R1]
         { info_tbl: [(cc2Gk,
                       label: block_cc2Gk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Gk: // global
           I64[Sp] = block_cc2Gq_info;
           _sc2uA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sc2uA::I64;
           if (R1 & 7 != 0) goto uc2GC; else goto cc2Gu;
       uc2GC: // global
           call _cc2Gq(R1) args: 0, res: 0, upd: 0;
       cc2Gu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Gq() //  [R1]
         { info_tbl: [(cc2Gq,
                       label: block_cc2Gq_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Gq: // global
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] debugBelch2(I64[Sp + 8], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc2v2_entry() //  [R1, R2]
         { info_tbl: [(cc2H1,
                       label: sat_sc2v2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2H1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2H5; else goto cc2H6;
       cc2H5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2H6: // global
           I64[Sp - 16] = block_cc2GY_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc2Hh; else goto cc2GZ;
       uc2Hh: // global
           call _cc2GY(R1) args: 0, res: 0, upd: 0;
       cc2GZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2GY() //  [R1]
         { info_tbl: [(cc2GY,
                       label: block_cc2GY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2GY: // global
           I64[Sp] = block_cc2H4_info;
           _sc2uW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sc2uW::I64;
           if (R1 & 7 != 0) goto uc2Hg; else goto cc2H8;
       uc2Hg: // global
           call _cc2H4(R1) args: 0, res: 0, upd: 0;
       cc2H8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2H4() //  [R1]
         { info_tbl: [(cc2H4,
                       label: block_cc2H4_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2H4: // global
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] debugBelch2(I64[Sp + 8], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc2v3_entry() //  [R1, R2]
         { info_tbl: [(cc2Hi,
                       label: sat_sc2v3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Hi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc2Hj; else goto cc2Hk;
       cc2Hj: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2Hk: // global
           I64[Sp - 32] = block_cc2Gd_info;
           _sc2uk::P64 = P64[R1 + 6];
           _sc2uo::P64 = P64[R1 + 14];
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 24] = _sc2uk::P64;
           P64[Sp - 16] = _sc2uo::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Gd() //  [R1]
         { info_tbl: [(cc2Gd,
                       label: block_cc2Gd_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Gd: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc2Hn; else goto cc2Hm;
       cc2Hn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc2Hm: // global
           I64[Hp - 8] = sat_sc2uG_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_cc2GE_info;
           R4 = Hp - 6;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2GE() //  []
         { info_tbl: [(cc2GE,
                       label: block_cc2GE_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2GE: // global
           I64[Sp + 16] = block_cc2GG_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uc2HA; else goto cc2GH;
       uc2HA: // global
           call _cc2GG(R1) args: 0, res: 0, upd: 0;
       cc2GH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2GG() //  [R1]
         { info_tbl: [(cc2GG,
                       label: block_cc2GG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2GG: // global
           I64[Sp] = block_cc2GL_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto uc2HB; else goto cc2GM;
       uc2HB: // global
           call _cc2GL(R1) args: 0, res: 0, upd: 0;
       cc2GM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2GL() //  [R1]
         { info_tbl: [(cc2GL,
                       label: block_cc2GL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2GL: // global
           if (R1 & 7 == 1) goto cc2Ht; else goto cc2Hv;
       cc2Ht: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc2Hv: // global
           I64[Sp] = block_cc2GR_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2GR() //  [R1]
         { info_tbl: [(cc2GR,
                       label: block_cc2GR_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2GR: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc2Hy; else goto cc2Hx;
       cc2Hy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc2Hx: // global
           I64[Hp - 8] = sat_sc2v2_info;
           P64[Hp] = P64[Sp + 8];
           R4 = Hp - 6;
           R3 = Debug.Trace.putTraceMsg2_closure;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Debug.Trace.putTraceMsg1_entry() //  [R2]
         { info_tbl: [(cc2HC,
                       label: Debug.Trace.putTraceMsg1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2HC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2HD; else goto cc2HE;
       cc2HD: // global
           R2 = R2;
           R1 = Debug.Trace.putTraceMsg1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2HE: // global
           I64[Sp - 16] = block_cc2FS_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2FS() //  [R1]
         { info_tbl: [(cc2FS,
                       label: block_cc2FS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2FS: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cc2HH; else goto cc2HG;
       cc2HH: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc2HG: // global
           I64[Hp - 64] = ds_sc2uk_info;
           P64[Hp - 48] = P64[Sp + 8];
           I64[Hp - 40] = stg_sel_1_upd_info;
           _cc2FU::P64 = Hp - 64;
           P64[Hp - 24] = _cc2FU::P64;
           I64[Hp - 16] = sat_sc2v3_info;
           P64[Hp - 8] = _cc2FU::P64;
           P64[Hp] = Hp - 40;
           R4 = Hp - 14;
           R3 = Debug.Trace.putTraceMsg4_closure;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.45349231 UTC

[section ""data" . Debug.Trace.traceIO_closure" {
     Debug.Trace.traceIO_closure:
         const Debug.Trace.traceIO_info;
         const 0;
 },
 Debug.Trace.traceIO_entry() //  [R2]
         { info_tbl: [(cc2HM,
                       label: Debug.Trace.traceIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2HM: // global
           R2 = R2;
           call Debug.Trace.putTraceMsg1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.454855647 UTC

[section ""data" . Debug.Trace.putTraceMsg_closure" {
     Debug.Trace.putTraceMsg_closure:
         const Debug.Trace.putTraceMsg_info;
         const 0;
 },
 Debug.Trace.putTraceMsg_entry() //  [R2]
         { info_tbl: [(cc2HT,
                       label: Debug.Trace.putTraceMsg_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2HT: // global
           R2 = R2;
           call Debug.Trace.putTraceMsg1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.455766553 UTC

[section ""data" . Debug.Trace.trace_closure" {
     Debug.Trace.trace_closure:
         const Debug.Trace.trace_info;
         const 0;
 },
 Debug.Trace.trace_entry() //  [R2, R3]
         { info_tbl: [(cc2I7,
                       label: Debug.Trace.trace_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2I7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc2I8; else goto cc2I9;
       cc2I8: // global
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.trace_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2I9: // global
           I64[Sp - 24] = block_cc2I0_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cc2I0() //  []
         { info_tbl: [(cc2I0,
                       label: block_cc2I0_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2I0: // global
           _sc2v4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc2I2_info;
           R2 = _sc2v4::P64;
           Sp = Sp + 8;
           call Debug.Trace.putTraceMsg1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2I2() //  []
         { info_tbl: [(cc2I2,
                       label: block_cc2I2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2I2: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.456914304 UTC

[section ""data" . Debug.Trace.traceId_closure" {
     Debug.Trace.traceId_closure:
         const Debug.Trace.traceId_info;
         const 0;
 },
 Debug.Trace.traceId_entry() //  [R2]
         { info_tbl: [(cc2Ih,
                       label: Debug.Trace.traceId_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Ih: // global
           R3 = R2;
           R2 = R2;
           call Debug.Trace.trace_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.457919756 UTC

[section ""data" . Debug.Trace.traceShow_closure" {
     Debug.Trace.traceShow_closure:
         const Debug.Trace.traceShow_info;
         const 0;
 },
 sat_sc2vg_entry() //  [R1]
         { info_tbl: [(cc2Is,
                       label: sat_sc2vg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Is: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc2It; else goto cc2Iu;
       cc2It: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2Iu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.show_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Debug.Trace.traceShow_entry() //  [R2, R3]
         { info_tbl: [(cc2Iv,
                       label: Debug.Trace.traceShow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Iv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc2Iz; else goto cc2Iy;
       cc2Iz: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceShow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2Iy: // global
           I64[Hp - 24] = sat_sc2vg_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Debug.Trace.trace_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.45931694 UTC

[section ""data" . Debug.Trace.traceShowId_closure" {
     Debug.Trace.traceShowId_closure:
         const Debug.Trace.traceShowId_info;
         const 0;
 },
 sat_sc2vj_entry() //  [R1]
         { info_tbl: [(cc2II,
                       label: sat_sc2vj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2II: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2IJ; else goto cc2IK;
       cc2IJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2IK: // global
           R2 = P64[R1 + 16];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Show.show_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Debug.Trace.traceShowId_entry() //  [R2, R3]
         { info_tbl: [(cc2IL,
                       label: Debug.Trace.traceShowId_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2IL: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc2IP; else goto cc2IO;
       cc2IP: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceShowId_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2IO: // global
           I64[Hp - 24] = sat_sc2vj_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = R3;
           R2 = Hp - 24;
           call Debug.Trace.trace_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.460642436 UTC

[section ""data" . Debug.Trace.traceM_closure" {
     Debug.Trace.traceM_closure:
         const Debug.Trace.traceM_info;
         const 0;
 },
 sat_sc2vm_entry() //  [R1]
         { info_tbl: [(cc2IY,
                       label: sat_sc2vm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2IY: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc2IZ; else goto cc2J0;
       cc2IZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2J0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Debug.Trace.traceM_entry() //  [R2, R3]
         { info_tbl: [(cc2J1,
                       label: Debug.Trace.traceM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2J1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc2J5; else goto cc2J4;
       cc2J5: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2J4: // global
           I64[Hp - 16] = sat_sc2vm_info;
           P64[Hp] = R2;
           _sc2vl::P64 = R3;
           R3 = Hp - 16;
           R2 = _sc2vl::P64;
           call Debug.Trace.trace_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.462447138 UTC

[section ""data" . Debug.Trace.traceShowM_closure" {
     Debug.Trace.traceShowM_closure:
         const Debug.Trace.traceShowM_info;
         const 0;
 },
 sat_sc2vr_entry() //  [R1]
         { info_tbl: [(cc2Je,
                       label: sat_sc2vr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Je: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc2Jf; else goto cc2Jg;
       cc2Jf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2Jg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc2vq_entry() //  [R1]
         { info_tbl: [(cc2Jl,
                       label: sat_sc2vq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Jl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2Jm; else goto cc2Jn;
       cc2Jm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2Jn: // global
           R2 = P64[R1 + 16];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Show.show_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Debug.Trace.traceShowM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc2Jo,
                       label: Debug.Trace.traceShowM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Jo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc2Js; else goto cc2Jr;
       cc2Js: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceShowM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2Jr: // global
           I64[Hp - 48] = sat_sc2vr_info;
           P64[Hp - 32] = R3;
           I64[Hp - 24] = sat_sc2vq_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R3 = Hp - 48;
           R2 = Hp - 24;
           call Debug.Trace.trace_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.464672255 UTC

[section ""data" . Debug.Trace.traceStack_closure" {
     Debug.Trace.traceStack_closure:
         const Debug.Trace.traceStack_info;
         const 0;
 },
 sat_sc2vI_entry() //  [R1]
         { info_tbl: [(cc2JT,
                       label: sat_sc2vI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2JT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc2JU; else goto cc2JV;
       cc2JU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2JV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cc2JR_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc2JR() //  [R1]
         { info_tbl: [(cc2JR,
                       label: block_cc2JR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2JR: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Stack.CCS.renderStack_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc2vJ_entry() //  [R1]
         { info_tbl: [(cc2JZ,
                       label: sat_sc2vJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2JZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc2K3; else goto cc2K2;
       cc2K3: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2K2: // global
           _sc2vE::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_sc2vI_info;
           P64[Hp] = _sc2vE::P64;
           R3 = Hp - 16;
           R2 = GHC.Stack.CCS.renderStack1_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Debug.Trace.traceStack_entry() //  [R2, R3]
         { info_tbl: [(cc2Kb,
                       label: Debug.Trace.traceStack_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Kb: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc2Kc; else goto cc2Kd;
       cc2Kc: // global
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceStack_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2Kd: // global
           I64[Sp - 24] = block_cc2Jx_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cc2Jx() //  []
         { info_tbl: [(cc2Jx,
                       label: block_cc2Jx_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Jx: // global
           _sc2vs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc2Jz_info;
           R2 = _sc2vs::P64;
           Sp = Sp + 8;
           call Debug.Trace.putTraceMsg1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Jz() //  []
         { info_tbl: [(cc2Jz,
                       label: block_cc2Jz_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Jz: // global
           I64[Sp] = block_cc2JB_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = CCCS;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2JB() //  [R1]
         { info_tbl: [(cc2JB,
                       label: block_cc2JB_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2JB: // global
           I64[Sp] = block_cc2JD_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uc2Ks; else goto cc2JE;
       uc2Ks: // global
           call _cc2JD(R1) args: 0, res: 0, upd: 0;
       cc2JE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2JD() //  [R1]
         { info_tbl: [(cc2JD,
                       label: block_cc2JD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2JD: // global
           if (R1 & 7 == 1) goto cc2K5; else goto cc2K6;
       cc2K5: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cc2K4() args: 0, res: 0, upd: 0;
       cc2K6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc2Km; else goto cc2Kl;
       cc2Km: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc2Kl: // global
           I64[Hp - 16] = sat_sc2vJ_info;
           P64[Hp] = R1;
           I64[Sp] = block_cc2Kj_info;
           R2 = Hp - 16;
           call Debug.Trace.putTraceMsg1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Kj() //  []
         { info_tbl: [(cc2Kj,
                       label: block_cc2Kj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Kj: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cc2K4() args: 0, res: 0, upd: 0;
     }
 },
 _cc2K4() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2K4: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.467071398 UTC

[section ""relreadonly" . Sc2we_srt" {
     Sc2we_srt:
         const GHC.IO.Encoding.UTF8.utf8_closure;
         const Debug.Trace.traceEventIO1_closure;
         const Debug.Trace.traceMarkerIO1_closure;
         const Debug.Trace.traceMarker_closure;
         const Debug.Trace.traceEvent_closure;
         const GHC.IO.Encoding.getForeignEncoding_closure;
         const Debug.Trace.putTraceMsg2_closure;
         const Debug.Trace.putTraceMsg1_closure;
         const Debug.Trace.putTraceMsg4_closure;
         const Debug.Trace.trace_closure;
         const Debug.Trace.traceShow_closure;
         const Debug.Trace.traceShowId_closure;
         const Debug.Trace.traceM_closure;
         const Debug.Trace.traceShowM_closure;
         const GHC.Stack.CCS.renderStack_go_closure;
         const GHC.Stack.CCS.$wgo_closure;
         const Debug.Trace.traceStack_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.46798977 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:56.469983328 UTC

[section ""data" . Debug.Trace.traceEventIO2_closure" {
     Debug.Trace.traceEventIO2_closure:
         const Debug.Trace.traceEventIO2_info;
 },
 Debug.Trace.traceEventIO2_entry() //  [R2]
         { info_tbl: [(cc2KC,
                       label: Debug.Trace.traceEventIO2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2KC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc2KG; else goto cc2KH;
       cc2KG: // global
           R2 = R2;
           R1 = Debug.Trace.traceEventIO2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2KH: // global
           I64[Sp - 8] = block_cc2Kz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc2KL; else goto cc2KA;
       uc2KL: // global
           call _cc2Kz(R1) args: 0, res: 0, upd: 0;
       cc2KA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Kz() //  [R1]
         { info_tbl: [(cc2Kz,
                       label: block_cc2Kz_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Kz: // global
           I64[Sp] = block_cc2KF_info;
           R1 = I64[R1 + 7];
           call stg_traceEvent#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2KF() //  []
         { info_tbl: [(cc2KF,
                       label: block_cc2KF_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2KF: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.476495201 UTC

[section ""data" . Debug.Trace.traceEventIO1_closure" {
     Debug.Trace.traceEventIO1_closure:
         const Debug.Trace.traceEventIO1_info;
         const 0;
 },
 Debug.Trace.traceEventIO1_entry() //  [R2]
         { info_tbl: [(cc2L3,
                       label: Debug.Trace.traceEventIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2L3: // global
           R4 = Debug.Trace.traceEventIO2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.479948743 UTC

[section ""data" . Debug.Trace.traceEventIO_closure" {
     Debug.Trace.traceEventIO_closure:
         const Debug.Trace.traceEventIO_info;
         const 0;
 },
 Debug.Trace.traceEventIO_entry() //  [R2]
         { info_tbl: [(cc2Le,
                       label: Debug.Trace.traceEventIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Le: // global
           R2 = R2;
           call Debug.Trace.traceEventIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.483782046 UTC

[section ""data" . Debug.Trace.traceMarkerIO2_closure" {
     Debug.Trace.traceMarkerIO2_closure:
         const Debug.Trace.traceMarkerIO2_info;
 },
 Debug.Trace.traceMarkerIO2_entry() //  [R2]
         { info_tbl: [(cc2Ls,
                       label: Debug.Trace.traceMarkerIO2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Ls: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc2Lw; else goto cc2Lx;
       cc2Lw: // global
           R2 = R2;
           R1 = Debug.Trace.traceMarkerIO2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2Lx: // global
           I64[Sp - 8] = block_cc2Lp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc2LB; else goto cc2Lq;
       uc2LB: // global
           call _cc2Lp(R1) args: 0, res: 0, upd: 0;
       cc2Lq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Lp() //  [R1]
         { info_tbl: [(cc2Lp,
                       label: block_cc2Lp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Lp: // global
           I64[Sp] = block_cc2Lv_info;
           R1 = I64[R1 + 7];
           call stg_traceMarker#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Lv() //  []
         { info_tbl: [(cc2Lv,
                       label: block_cc2Lv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Lv: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.490719426 UTC

[section ""data" . Debug.Trace.traceMarkerIO1_closure" {
     Debug.Trace.traceMarkerIO1_closure:
         const Debug.Trace.traceMarkerIO1_info;
         const 0;
 },
 Debug.Trace.traceMarkerIO1_entry() //  [R2]
         { info_tbl: [(cc2LT,
                       label: Debug.Trace.traceMarkerIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2LT: // global
           R4 = Debug.Trace.traceMarkerIO2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.494463292 UTC

[section ""data" . Debug.Trace.traceMarkerIO_closure" {
     Debug.Trace.traceMarkerIO_closure:
         const Debug.Trace.traceMarkerIO_info;
         const 0;
 },
 Debug.Trace.traceMarkerIO_entry() //  [R2]
         { info_tbl: [(cc2M4,
                       label: Debug.Trace.traceMarkerIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2M4: // global
           R2 = R2;
           call Debug.Trace.traceMarkerIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.497672857 UTC

[section ""cstring" . Debug.Trace.$trModule4_bytes" {
     Debug.Trace.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.49931089 UTC

[section ""data" . Debug.Trace.$trModule3_closure" {
     Debug.Trace.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Debug.Trace.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.500881428 UTC

[section ""cstring" . Debug.Trace.$trModule2_bytes" {
     Debug.Trace.$trModule2_bytes:
         I8[] [68,101,98,117,103,46,84,114,97,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.502533559 UTC

[section ""data" . Debug.Trace.$trModule1_closure" {
     Debug.Trace.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Debug.Trace.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.504227464 UTC

[section ""data" . Debug.Trace.$trModule_closure" {
     Debug.Trace.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Debug.Trace.$trModule3_closure+1;
         const Debug.Trace.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.506608764 UTC

[section ""data" . Debug.Trace.traceMarker_closure" {
     Debug.Trace.traceMarker_closure:
         const Debug.Trace.traceMarker_info;
         const 0;
 },
 Debug.Trace.traceMarker_entry() //  [R2, R3]
         { info_tbl: [(cc2Mp,
                       label: Debug.Trace.traceMarker_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Mp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2Mq; else goto cc2Mr;
       cc2Mq: // global
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceMarker_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2Mr: // global
           I64[Sp - 16] = block_cc2Mk_info;
           R4 = Debug.Trace.traceMarkerIO2_closure+2;
           _sc2tx::P64 = R3;
           R3 = R2;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp - 8] = _sc2tx::P64;
           Sp = Sp - 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Mk() //  []
         { info_tbl: [(cc2Mk,
                       label: block_cc2Mk_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Mk: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.512324481 UTC

[section ""data" . Debug.Trace.traceEvent_closure" {
     Debug.Trace.traceEvent_closure:
         const Debug.Trace.traceEvent_info;
         const 0;
 },
 Debug.Trace.traceEvent_entry() //  [R2, R3]
         { info_tbl: [(cc2ML,
                       label: Debug.Trace.traceEvent_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2ML: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2MM; else goto cc2MN;
       cc2MM: // global
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceEvent_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2MN: // global
           I64[Sp - 16] = block_cc2MG_info;
           R4 = Debug.Trace.traceEventIO2_closure+2;
           _sc2tF::P64 = R3;
           R3 = R2;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp - 8] = _sc2tF::P64;
           Sp = Sp - 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2MG() //  []
         { info_tbl: [(cc2MG,
                       label: block_cc2MG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2MG: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.517575302 UTC

[section ""cstring" . Debug.Trace.putTraceMsg5_bytes" {
     Debug.Trace.putTraceMsg5_bytes:
         I8[] [37,115,10]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.519781305 UTC

[section ""data" . Debug.Trace.putTraceMsg4_closure" {
     Debug.Trace.putTraceMsg4_closure:
         const Debug.Trace.putTraceMsg4_info;
         const 0;
         const 0;
         const 0;
 },
 Debug.Trace.putTraceMsg4_entry() //  [R1]
         { info_tbl: [(cc2N5,
                       label: Debug.Trace.putTraceMsg4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2N5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2N6; else goto cc2N7;
       cc2N6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2N7: // global
           (_cc2N2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc2N2::I64 == 0) goto cc2N4; else goto cc2N3;
       cc2N4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc2N3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc2N2::I64;
           R2 = Debug.Trace.putTraceMsg5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.523964704 UTC

[section ""cstring" . Debug.Trace.putTraceMsg3_bytes" {
     Debug.Trace.putTraceMsg3_bytes:
         I8[] [87,65,82,78,73,78,71,58,32,112,114,101,118,105,111,117,115,32,116,114,97,99,101,32,109,101,115,115,97,103,101,32,104,97,100,32,110,117,108,108,32,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.525884096 UTC

[section ""data" . Debug.Trace.putTraceMsg2_closure" {
     Debug.Trace.putTraceMsg2_closure:
         const Debug.Trace.putTraceMsg2_info;
         const 0;
         const 0;
         const 0;
 },
 Debug.Trace.putTraceMsg2_entry() //  [R1]
         { info_tbl: [(cc2Nm,
                       label: Debug.Trace.putTraceMsg2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Nm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2Nn; else goto cc2No;
       cc2Nn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2No: // global
           (_cc2Nj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc2Nj::I64 == 0) goto cc2Nl; else goto cc2Nk;
       cc2Nl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc2Nk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc2Nj::I64;
           R2 = Debug.Trace.putTraceMsg3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.530858694 UTC

[section ""data" . Debug.Trace.$wgo_closure" {
     Debug.Trace.$wgo_closure:
         const Debug.Trace.$wgo_info;
 },
 w2_sc2tS_entry() //  [R1]
         { info_tbl: [(cc2NS,
                       label: w2_sc2tS_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2NS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc2NT; else goto cc2NU;
       cc2NT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2NU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cc2NP_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Debug.Trace.$wgo_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc2NP() //  [R1, R2]
         { info_tbl: [(cc2NP,
                       label: block_cc2NP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2NP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc2NX; else goto cc2NW;
       cc2NX: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cc2NW: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Debug.Trace.$wgo_entry() //  [R2]
         { info_tbl: [(cc2O2,
                       label: Debug.Trace.$wgo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2O2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2O3; else goto cc2O4;
       cc2O3: // global
           R2 = R2;
           R1 = Debug.Trace.$wgo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2O4: // global
           I64[Sp - 8] = block_cc2NA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc2Oo; else goto cc2NB;
       uc2Oo: // global
           call _cc2NA(R1) args: 0, res: 0, upd: 0;
       cc2NB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2NA() //  [R1]
         { info_tbl: [(cc2NA,
                       label: block_cc2NA_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2NA: // global
           if (R1 & 7 == 1) goto cc2NZ; else goto cc2O0;
       cc2NZ: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cc2O0: // global
           I64[Sp - 8] = block_cc2NG_info;
           _sc2tP::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sc2tP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc2On; else goto cc2NH;
       uc2On: // global
           call _cc2NG(R1) args: 0, res: 0, upd: 0;
       cc2NH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2NG() //  [R1]
         { info_tbl: [(cc2NG,
                       label: block_cc2NG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2NG: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cc2Oa; else goto cc2O9;
       cc2Oa: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc2O9: // global
           _sc2tR::I64 = I64[R1 + 7];
           I64[Hp - 88] = w2_sc2tS_info;
           P64[Hp - 72] = P64[Sp + 8];
           _cc2NL::P64 = Hp - 88;
           if (_sc2tR::I64 == 0) goto cc2Om; else goto cc2Oh;
       cc2Om: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _cc2NL::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cc2NL::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cc2Oh: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _cc2NL::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _cc2NL::P64;
           R2 = Hp - 38;
           R1 = Hp - 16;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.545126008 UTC

[section ""data" . Debug.Trace.putTraceMsg1_closure" {
     Debug.Trace.putTraceMsg1_closure:
         const Debug.Trace.putTraceMsg1_info;
         const 0;
 },
 ds_sc2uk_entry() //  [R1]
         { info_tbl: [(cc2P5,
                       label: ds_sc2uk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2P5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc2P6; else goto cc2P7;
       cc2P6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2P7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cc2P2_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Debug.Trace.$wgo_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc2P2() //  [R1, R2]
         { info_tbl: [(cc2P2,
                       label: block_cc2P2_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2P2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc2Pa; else goto cc2P9;
       cc2Pa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cc2P9: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc2uG_entry() //  [R1, R2]
         { info_tbl: [(cc2Pr,
                       label: sat_sc2uG_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Pr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2Pv; else goto cc2Pw;
       cc2Pv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2Pw: // global
           I64[Sp - 16] = block_cc2Po_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc2PH; else goto cc2Pp;
       uc2PH: // global
           call _cc2Po(R1) args: 0, res: 0, upd: 0;
       cc2Pp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Po() //  [R1]
         { info_tbl: [(cc2Po,
                       label: block_cc2Po_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Po: // global
           I64[Sp] = block_cc2Pu_info;
           _sc2uA::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sc2uA::I64;
           if (R1 & 7 != 0) goto uc2PG; else goto cc2Py;
       uc2PG: // global
           call _cc2Pu(R1) args: 0, res: 0, upd: 0;
       cc2Py: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Pu() //  [R1]
         { info_tbl: [(cc2Pu,
                       label: block_cc2Pu_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Pu: // global
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] debugBelch2(I64[Sp + 8], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc2v2_entry() //  [R1, R2]
         { info_tbl: [(cc2Q5,
                       label: sat_sc2v2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Q5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2Q9; else goto cc2Qa;
       cc2Q9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2Qa: // global
           I64[Sp - 16] = block_cc2Q2_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc2Ql; else goto cc2Q3;
       uc2Ql: // global
           call _cc2Q2(R1) args: 0, res: 0, upd: 0;
       cc2Q3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Q2() //  [R1]
         { info_tbl: [(cc2Q2,
                       label: block_cc2Q2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Q2: // global
           I64[Sp] = block_cc2Q8_info;
           _sc2uW::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sc2uW::I64;
           if (R1 & 7 != 0) goto uc2Qk; else goto cc2Qc;
       uc2Qk: // global
           call _cc2Q8(R1) args: 0, res: 0, upd: 0;
       cc2Qc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Q8() //  [R1]
         { info_tbl: [(cc2Q8,
                       label: block_cc2Q8_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Q8: // global
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] debugBelch2(I64[Sp + 8], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc2v3_entry() //  [R1, R2]
         { info_tbl: [(cc2Qm,
                       label: sat_sc2v3_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Qm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc2Qn; else goto cc2Qo;
       cc2Qn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2Qo: // global
           I64[Sp - 32] = block_cc2Ph_info;
           _sc2uk::P64 = P64[R1 + 6];
           _sc2uo::P64 = P64[R1 + 14];
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 24] = _sc2uk::P64;
           P64[Sp - 16] = _sc2uo::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Ph() //  [R1]
         { info_tbl: [(cc2Ph,
                       label: block_cc2Ph_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Ph: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc2Qr; else goto cc2Qq;
       cc2Qr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc2Qq: // global
           I64[Hp - 8] = sat_sc2uG_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_cc2PI_info;
           R4 = Hp - 6;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2PI() //  []
         { info_tbl: [(cc2PI,
                       label: block_cc2PI_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2PI: // global
           I64[Sp + 16] = block_cc2PK_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uc2QE; else goto cc2PL;
       uc2QE: // global
           call _cc2PK(R1) args: 0, res: 0, upd: 0;
       cc2PL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2PK() //  [R1]
         { info_tbl: [(cc2PK,
                       label: block_cc2PK_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2PK: // global
           I64[Sp] = block_cc2PP_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto uc2QF; else goto cc2PQ;
       uc2QF: // global
           call _cc2PP(R1) args: 0, res: 0, upd: 0;
       cc2PQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2PP() //  [R1]
         { info_tbl: [(cc2PP,
                       label: block_cc2PP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2PP: // global
           if (R1 & 7 == 1) goto cc2Qx; else goto cc2Qz;
       cc2Qx: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc2Qz: // global
           I64[Sp] = block_cc2PV_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2PV() //  [R1]
         { info_tbl: [(cc2PV,
                       label: block_cc2PV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2PV: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc2QC; else goto cc2QB;
       cc2QC: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc2QB: // global
           I64[Hp - 8] = sat_sc2v2_info;
           P64[Hp] = P64[Sp + 8];
           R4 = Hp - 6;
           R3 = Debug.Trace.putTraceMsg2_closure;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Debug.Trace.putTraceMsg1_entry() //  [R2]
         { info_tbl: [(cc2QG,
                       label: Debug.Trace.putTraceMsg1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2QG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2QH; else goto cc2QI;
       cc2QH: // global
           R2 = R2;
           R1 = Debug.Trace.putTraceMsg1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2QI: // global
           I64[Sp - 16] = block_cc2OW_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2OW() //  [R1]
         { info_tbl: [(cc2OW,
                       label: block_cc2OW_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2OW: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cc2QL; else goto cc2QK;
       cc2QL: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc2QK: // global
           I64[Hp - 64] = ds_sc2uk_info;
           P64[Hp - 48] = P64[Sp + 8];
           I64[Hp - 40] = stg_sel_1_upd_info;
           _cc2OY::P64 = Hp - 64;
           P64[Hp - 24] = _cc2OY::P64;
           I64[Hp - 16] = sat_sc2v3_info;
           P64[Hp - 8] = _cc2OY::P64;
           P64[Hp] = Hp - 40;
           R4 = Hp - 14;
           R3 = Debug.Trace.putTraceMsg4_closure;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.576843138 UTC

[section ""data" . Debug.Trace.traceIO_closure" {
     Debug.Trace.traceIO_closure:
         const Debug.Trace.traceIO_info;
         const 0;
 },
 Debug.Trace.traceIO_entry() //  [R2]
         { info_tbl: [(cc2RY,
                       label: Debug.Trace.traceIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2RY: // global
           R2 = R2;
           call Debug.Trace.putTraceMsg1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.580640692 UTC

[section ""data" . Debug.Trace.putTraceMsg_closure" {
     Debug.Trace.putTraceMsg_closure:
         const Debug.Trace.putTraceMsg_info;
         const 0;
 },
 Debug.Trace.putTraceMsg_entry() //  [R2]
         { info_tbl: [(cc2S9,
                       label: Debug.Trace.putTraceMsg_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2S9: // global
           R2 = R2;
           call Debug.Trace.putTraceMsg1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.583986888 UTC

[section ""data" . Debug.Trace.trace_closure" {
     Debug.Trace.trace_closure:
         const Debug.Trace.trace_info;
         const 0;
 },
 Debug.Trace.trace_entry() //  [R2, R3]
         { info_tbl: [(cc2Sr,
                       label: Debug.Trace.trace_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Sr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc2Ss; else goto cc2St;
       cc2Ss: // global
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.trace_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2St: // global
           I64[Sp - 24] = block_cc2Sk_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cc2Sk() //  []
         { info_tbl: [(cc2Sk,
                       label: block_cc2Sk_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Sk: // global
           _sc2v4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc2Sm_info;
           R2 = _sc2v4::P64;
           Sp = Sp + 8;
           call Debug.Trace.putTraceMsg1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Sm() //  []
         { info_tbl: [(cc2Sm,
                       label: block_cc2Sm_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Sm: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.591121129 UTC

[section ""data" . Debug.Trace.traceId_closure" {
     Debug.Trace.traceId_closure:
         const Debug.Trace.traceId_info;
         const 0;
 },
 Debug.Trace.traceId_entry() //  [R2]
         { info_tbl: [(cc2SM,
                       label: Debug.Trace.traceId_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2SM: // global
           R3 = R2;
           R2 = R2;
           call Debug.Trace.trace_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.595078386 UTC

[section ""data" . Debug.Trace.traceShow_closure" {
     Debug.Trace.traceShow_closure:
         const Debug.Trace.traceShow_info;
         const 0;
 },
 sat_sc2vg_entry() //  [R1]
         { info_tbl: [(cc2T1,
                       label: sat_sc2vg_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2T1: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc2T2; else goto cc2T3;
       cc2T2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2T3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.show_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Debug.Trace.traceShow_entry() //  [R2, R3]
         { info_tbl: [(cc2T4,
                       label: Debug.Trace.traceShow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2T4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc2T8; else goto cc2T7;
       cc2T8: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceShow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2T7: // global
           I64[Hp - 24] = sat_sc2vg_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Debug.Trace.trace_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.601213828 UTC

[section ""data" . Debug.Trace.traceShowId_closure" {
     Debug.Trace.traceShowId_closure:
         const Debug.Trace.traceShowId_info;
         const 0;
 },
 sat_sc2vj_entry() //  [R1]
         { info_tbl: [(cc2Tq,
                       label: sat_sc2vj_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Tq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2Tr; else goto cc2Ts;
       cc2Tr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2Ts: // global
           R2 = P64[R1 + 16];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Show.show_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Debug.Trace.traceShowId_entry() //  [R2, R3]
         { info_tbl: [(cc2Tt,
                       label: Debug.Trace.traceShowId_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Tt: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc2Tx; else goto cc2Tw;
       cc2Tx: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceShowId_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2Tw: // global
           I64[Hp - 24] = sat_sc2vj_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = R3;
           R2 = Hp - 24;
           call Debug.Trace.trace_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.607330191 UTC

[section ""data" . Debug.Trace.traceM_closure" {
     Debug.Trace.traceM_closure:
         const Debug.Trace.traceM_info;
         const 0;
 },
 sat_sc2vm_entry() //  [R1]
         { info_tbl: [(cc2TP,
                       label: sat_sc2vm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2TP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc2TQ; else goto cc2TR;
       cc2TQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2TR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Debug.Trace.traceM_entry() //  [R2, R3]
         { info_tbl: [(cc2TS,
                       label: Debug.Trace.traceM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2TS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc2TW; else goto cc2TV;
       cc2TW: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2TV: // global
           I64[Hp - 16] = sat_sc2vm_info;
           P64[Hp] = R2;
           _sc2vl::P64 = R3;
           R3 = Hp - 16;
           R2 = _sc2vl::P64;
           call Debug.Trace.trace_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.613658564 UTC

[section ""data" . Debug.Trace.traceShowM_closure" {
     Debug.Trace.traceShowM_closure:
         const Debug.Trace.traceShowM_info;
         const 0;
 },
 sat_sc2vr_entry() //  [R1]
         { info_tbl: [(cc2Ud,
                       label: sat_sc2vr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Ud: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc2Ue; else goto cc2Uf;
       cc2Ue: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2Uf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc2vq_entry() //  [R1]
         { info_tbl: [(cc2Uk,
                       label: sat_sc2vq_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Uk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc2Ul; else goto cc2Um;
       cc2Ul: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2Um: // global
           R2 = P64[R1 + 16];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Show.show_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Debug.Trace.traceShowM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc2Un,
                       label: Debug.Trace.traceShowM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Un: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc2Ur; else goto cc2Uq;
       cc2Ur: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceShowM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2Uq: // global
           I64[Hp - 48] = sat_sc2vr_info;
           P64[Hp - 32] = R3;
           I64[Hp - 24] = sat_sc2vq_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R3 = Hp - 48;
           R2 = Hp - 24;
           call Debug.Trace.trace_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.62252205 UTC

[section ""data" . Debug.Trace.traceStack_closure" {
     Debug.Trace.traceStack_closure:
         const Debug.Trace.traceStack_info;
         const 0;
 },
 sat_sc2vI_entry() //  [R1]
         { info_tbl: [(cc2V5,
                       label: sat_sc2vI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2V5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc2V6; else goto cc2V7;
       cc2V6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2V7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cc2V3_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc2V3() //  [R1]
         { info_tbl: [(cc2V3,
                       label: block_cc2V3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2V3: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Stack.CCS.renderStack_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc2vJ_entry() //  [R1]
         { info_tbl: [(cc2Vb,
                       label: sat_sc2vJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Vb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc2Vf; else goto cc2Ve;
       cc2Vf: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc2Ve: // global
           _sc2vE::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_sc2vI_info;
           P64[Hp] = _sc2vE::P64;
           R3 = Hp - 16;
           R2 = GHC.Stack.CCS.renderStack1_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Debug.Trace.traceStack_entry() //  [R2, R3]
         { info_tbl: [(cc2Vn,
                       label: Debug.Trace.traceStack_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Vn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc2Vo; else goto cc2Vp;
       cc2Vo: // global
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceStack_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc2Vp: // global
           I64[Sp - 24] = block_cc2UJ_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cc2UJ() //  []
         { info_tbl: [(cc2UJ,
                       label: block_cc2UJ_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2UJ: // global
           _sc2vs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc2UL_info;
           R2 = _sc2vs::P64;
           Sp = Sp + 8;
           call Debug.Trace.putTraceMsg1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2UL() //  []
         { info_tbl: [(cc2UL,
                       label: block_cc2UL_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2UL: // global
           I64[Sp] = block_cc2UN_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = CCCS;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2UN() //  [R1]
         { info_tbl: [(cc2UN,
                       label: block_cc2UN_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2UN: // global
           I64[Sp] = block_cc2UP_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uc2VE; else goto cc2UQ;
       uc2VE: // global
           call _cc2UP(R1) args: 0, res: 0, upd: 0;
       cc2UQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2UP() //  [R1]
         { info_tbl: [(cc2UP,
                       label: block_cc2UP_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2UP: // global
           if (R1 & 7 == 1) goto cc2Vh; else goto cc2Vi;
       cc2Vh: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cc2Vg() args: 0, res: 0, upd: 0;
       cc2Vi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc2Vy; else goto cc2Vx;
       cc2Vy: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc2Vx: // global
           I64[Hp - 16] = sat_sc2vJ_info;
           P64[Hp] = R1;
           I64[Sp] = block_cc2Vv_info;
           R2 = Hp - 16;
           call Debug.Trace.putTraceMsg1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Vv() //  []
         { info_tbl: [(cc2Vv,
                       label: block_cc2Vv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Vv: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cc2Vg() args: 0, res: 0, upd: 0;
     }
 },
 _cc2Vg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Vg: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:56.641222642 UTC

[section ""relreadonly" . Sc2we_srt" {
     Sc2we_srt:
         const GHC.IO.Encoding.UTF8.utf8_closure;
         const Debug.Trace.traceEventIO1_closure;
         const Debug.Trace.traceMarkerIO1_closure;
         const Debug.Trace.traceMarker_closure;
         const Debug.Trace.traceEvent_closure;
         const GHC.IO.Encoding.getForeignEncoding_closure;
         const Debug.Trace.putTraceMsg2_closure;
         const Debug.Trace.putTraceMsg1_closure;
         const Debug.Trace.putTraceMsg4_closure;
         const Debug.Trace.trace_closure;
         const Debug.Trace.traceShow_closure;
         const Debug.Trace.traceShowId_closure;
         const Debug.Trace.traceM_closure;
         const Debug.Trace.traceShowM_closure;
         const GHC.Stack.CCS.renderStack_go_closure;
         const GHC.Stack.CCS.$wgo_closure;
         const Debug.Trace.traceStack_closure;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.262181045 UTC

[]


==================== Output Cmm ====================
2018-03-16 16:06:57.263636736 UTC

[section ""data" . Debug.Trace.traceEventIO2_closure" {
     Debug.Trace.traceEventIO2_closure:
         const Debug.Trace.traceEventIO2_info;
 },
 Debug.Trace.traceEventIO2_entry() //  [R2]
         { info_tbl: [(cc2YY,
                       label: Debug.Trace.traceEventIO2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2YY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc2Z2; else goto cc2Z3;
       cc2Z2: // global
           R2 = R2;
           R1 = Debug.Trace.traceEventIO2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2Z3: // global
           I64[Sp - 8] = block_cc2YV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc2Z7; else goto cc2YW;
       uc2Z7: // global
           call _cc2YV(R1) args: 0, res: 0, upd: 0;
       cc2YW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2YV() //  [R1]
         { info_tbl: [(cc2YV,
                       label: block_cc2YV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2YV: // global
           I64[Sp] = block_cc2Z1_info;
           R1 = I64[R1 + 7];
           call stg_traceEvent#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2Z1() //  []
         { info_tbl: [(cc2Z1,
                       label: block_cc2Z1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Z1: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.271319371 UTC

[section ""data" . Debug.Trace.traceEventIO1_closure" {
     Debug.Trace.traceEventIO1_closure:
         const Debug.Trace.traceEventIO1_info;
         const 0;
 },
 Debug.Trace.traceEventIO1_entry() //  [R2]
         { info_tbl: [(cc2Zs,
                       label: Debug.Trace.traceEventIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2Zs: // global
           R4 = Debug.Trace.traceEventIO2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.274529789 UTC

[section ""data" . Debug.Trace.traceEventIO_closure" {
     Debug.Trace.traceEventIO_closure:
         const Debug.Trace.traceEventIO_info;
         const 0;
 },
 Debug.Trace.traceEventIO_entry() //  [R2]
         { info_tbl: [(cc2ZE,
                       label: Debug.Trace.traceEventIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2ZE: // global
           R2 = R2;
           call Debug.Trace.traceEventIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.27803367 UTC

[section ""data" . Debug.Trace.traceMarkerIO2_closure" {
     Debug.Trace.traceMarkerIO2_closure:
         const Debug.Trace.traceMarkerIO2_info;
 },
 Debug.Trace.traceMarkerIO2_entry() //  [R2]
         { info_tbl: [(cc2ZS,
                       label: Debug.Trace.traceMarkerIO2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2ZS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cc2ZW; else goto cc2ZX;
       cc2ZW: // global
           R2 = R2;
           R1 = Debug.Trace.traceMarkerIO2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc2ZX: // global
           I64[Sp - 8] = block_cc2ZP_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc301; else goto cc2ZQ;
       uc301: // global
           call _cc2ZP(R1) args: 0, res: 0, upd: 0;
       cc2ZQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2ZP() //  [R1]
         { info_tbl: [(cc2ZP,
                       label: block_cc2ZP_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2ZP: // global
           I64[Sp] = block_cc2ZV_info;
           R1 = I64[R1 + 7];
           call stg_traceMarker#(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc2ZV() //  []
         { info_tbl: [(cc2ZV,
                       label: block_cc2ZV_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc2ZV: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.284425445 UTC

[section ""data" . Debug.Trace.traceMarkerIO1_closure" {
     Debug.Trace.traceMarkerIO1_closure:
         const Debug.Trace.traceMarkerIO1_info;
         const 0;
 },
 Debug.Trace.traceMarkerIO1_entry() //  [R2]
         { info_tbl: [(cc30m,
                       label: Debug.Trace.traceMarkerIO1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc30m: // global
           R4 = Debug.Trace.traceMarkerIO2_closure+2;
           R3 = R2;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.287696941 UTC

[section ""data" . Debug.Trace.traceMarkerIO_closure" {
     Debug.Trace.traceMarkerIO_closure:
         const Debug.Trace.traceMarkerIO_info;
         const 0;
 },
 Debug.Trace.traceMarkerIO_entry() //  [R2]
         { info_tbl: [(cc30x,
                       label: Debug.Trace.traceMarkerIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc30x: // global
           R2 = R2;
           call Debug.Trace.traceMarkerIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.291088619 UTC

[section ""cstring" . Debug.Trace.$trModule4_bytes" {
     Debug.Trace.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.292682368 UTC

[section ""data" . Debug.Trace.$trModule3_closure" {
     Debug.Trace.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const Debug.Trace.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.294825173 UTC

[section ""cstring" . Debug.Trace.$trModule2_bytes" {
     Debug.Trace.$trModule2_bytes:
         I8[] [68,101,98,117,103,46,84,114,97,99,101]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.296465204 UTC

[section ""data" . Debug.Trace.$trModule1_closure" {
     Debug.Trace.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const Debug.Trace.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.298099386 UTC

[section ""data" . Debug.Trace.$trModule_closure" {
     Debug.Trace.$trModule_closure:
         const GHC.Types.Module_con_info;
         const Debug.Trace.$trModule3_closure+1;
         const Debug.Trace.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.300130252 UTC

[section ""data" . Debug.Trace.traceMarker_closure" {
     Debug.Trace.traceMarker_closure:
         const Debug.Trace.traceMarker_info;
         const 0;
 },
 Debug.Trace.traceMarker_entry() //  [R2, R3]
         { info_tbl: [(cc30S,
                       label: Debug.Trace.traceMarker_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc30S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc30T; else goto cc30U;
       cc30T: // global
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceMarker_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc30U: // global
           I64[Sp - 16] = block_cc30N_info;
           R4 = Debug.Trace.traceMarkerIO2_closure+2;
           _sc2Wy::P64 = R3;
           R3 = R2;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp - 8] = _sc2Wy::P64;
           Sp = Sp - 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc30N() //  []
         { info_tbl: [(cc30N,
                       label: block_cc30N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc30N: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.305830155 UTC

[section ""data" . Debug.Trace.traceEvent_closure" {
     Debug.Trace.traceEvent_closure:
         const Debug.Trace.traceEvent_info;
         const 0;
 },
 Debug.Trace.traceEvent_entry() //  [R2, R3]
         { info_tbl: [(cc31f,
                       label: Debug.Trace.traceEvent_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc31f: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc31g; else goto cc31h;
       cc31g: // global
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceEvent_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc31h: // global
           I64[Sp - 16] = block_cc31a_info;
           R4 = Debug.Trace.traceEventIO2_closure+2;
           _sc2WG::P64 = R3;
           R3 = R2;
           R2 = GHC.IO.Encoding.UTF8.utf8_closure;
           P64[Sp - 8] = _sc2WG::P64;
           Sp = Sp - 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc31a() //  []
         { info_tbl: [(cc31a,
                       label: block_cc31a_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc31a: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.310774355 UTC

[section ""cstring" . Debug.Trace.putTraceMsg5_bytes" {
     Debug.Trace.putTraceMsg5_bytes:
         I8[] [37,115,10]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.312519004 UTC

[section ""data" . Debug.Trace.putTraceMsg4_closure" {
     Debug.Trace.putTraceMsg4_closure:
         const Debug.Trace.putTraceMsg4_info;
         const 0;
         const 0;
         const 0;
 },
 Debug.Trace.putTraceMsg4_entry() //  [R1]
         { info_tbl: [(cc31A,
                       label: Debug.Trace.putTraceMsg4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc31A: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc31B; else goto cc31C;
       cc31B: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc31C: // global
           (_cc31x::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc31x::I64 == 0) goto cc31z; else goto cc31y;
       cc31z: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc31y: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc31x::I64;
           R2 = Debug.Trace.putTraceMsg5_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.316198744 UTC

[section ""cstring" . Debug.Trace.putTraceMsg3_bytes" {
     Debug.Trace.putTraceMsg3_bytes:
         I8[] [87,65,82,78,73,78,71,58,32,112,114,101,118,105,111,117,115,32,116,114,97,99,101,32,109,101,115,115,97,103,101,32,104,97,100,32,110,117,108,108,32,98,121,116,101,115]
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.318067581 UTC

[section ""data" . Debug.Trace.putTraceMsg2_closure" {
     Debug.Trace.putTraceMsg2_closure:
         const Debug.Trace.putTraceMsg2_info;
         const 0;
         const 0;
         const 0;
 },
 Debug.Trace.putTraceMsg2_entry() //  [R1]
         { info_tbl: [(cc31S,
                       label: Debug.Trace.putTraceMsg2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc31S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc31T; else goto cc31U;
       cc31T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc31U: // global
           (_cc31P::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cc31P::I64 == 0) goto cc31R; else goto cc31Q;
       cc31R: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cc31Q: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cc31P::I64;
           R2 = Debug.Trace.putTraceMsg3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.322640354 UTC

[section ""data" . Debug.Trace.$wgo_closure" {
     Debug.Trace.$wgo_closure:
         const Debug.Trace.$wgo_info;
 },
 w2_sc2WT_entry() //  [R1]
         { info_tbl: [(cc32p,
                       label: w2_sc2WT_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc32p: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc32q; else goto cc32r;
       cc32q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc32r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cc32m_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Debug.Trace.$wgo_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc32m() //  [R1, R2]
         { info_tbl: [(cc32m,
                       label: block_cc32m_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc32m: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc32u; else goto cc32t;
       cc32u: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cc32t: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 Debug.Trace.$wgo_entry() //  [R2]
         { info_tbl: [(cc32z,
                       label: Debug.Trace.$wgo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc32z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc32A; else goto cc32B;
       cc32A: // global
           R2 = R2;
           R1 = Debug.Trace.$wgo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc32B: // global
           I64[Sp - 8] = block_cc327_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc32V; else goto cc328;
       uc32V: // global
           call _cc327(R1) args: 0, res: 0, upd: 0;
       cc328: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc327() //  [R1]
         { info_tbl: [(cc327,
                       label: block_cc327_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc327: // global
           if (R1 & 7 == 1) goto cc32w; else goto cc32x;
       cc32w: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cc32x: // global
           I64[Sp - 8] = block_cc32d_info;
           _sc2WQ::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sc2WQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uc32U; else goto cc32e;
       uc32U: // global
           call _cc32d(R1) args: 0, res: 0, upd: 0;
       cc32e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc32d() //  [R1]
         { info_tbl: [(cc32d,
                       label: block_cc32d_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc32d: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cc32H; else goto cc32G;
       cc32H: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc32G: // global
           _sc2WS::I64 = I64[R1 + 7];
           I64[Hp - 88] = w2_sc2WT_info;
           P64[Hp - 72] = P64[Sp + 8];
           _cc32i::P64 = Hp - 88;
           if (_sc2WS::I64 == 0) goto cc32T; else goto cc32O;
       cc32T: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _cc32i::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cc32i::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cc32O: // global
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _cc32i::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _cc32i::P64;
           R2 = Hp - 38;
           R1 = Hp - 16;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.336936369 UTC

[section ""data" . Debug.Trace.putTraceMsg1_closure" {
     Debug.Trace.putTraceMsg1_closure:
         const Debug.Trace.putTraceMsg1_info;
         const 0;
 },
 ds_sc2Xl_entry() //  [R1]
         { info_tbl: [(cc33Q,
                       label: ds_sc2Xl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc33Q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc33R; else goto cc33S;
       cc33R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc33S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cc33N_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call Debug.Trace.$wgo_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc33N() //  [R1, R2]
         { info_tbl: [(cc33N,
                       label: block_cc33N_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc33N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc33V; else goto cc33U;
       cc33V: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cc33U: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc2XH_entry() //  [R1, R2]
         { info_tbl: [(cc34c,
                       label: sat_sc2XH_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc34c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc34g; else goto cc34h;
       cc34g: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc34h: // global
           I64[Sp - 16] = block_cc349_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc34s; else goto cc34a;
       uc34s: // global
           call _cc349(R1) args: 0, res: 0, upd: 0;
       cc34a: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc349() //  [R1]
         { info_tbl: [(cc349,
                       label: block_cc349_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc349: // global
           I64[Sp] = block_cc34f_info;
           _sc2XB::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sc2XB::I64;
           if (R1 & 7 != 0) goto uc34r; else goto cc34j;
       uc34r: // global
           call _cc34f(R1) args: 0, res: 0, upd: 0;
       cc34j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc34f() //  [R1]
         { info_tbl: [(cc34f,
                       label: block_cc34f_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc34f: // global
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] debugBelch2(I64[Sp + 8], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc2Y3_entry() //  [R1, R2]
         { info_tbl: [(cc34Q,
                       label: sat_sc2Y3_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc34Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc34U; else goto cc34V;
       cc34U: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc34V: // global
           I64[Sp - 16] = block_cc34N_info;
           R1 = P64[R1 + 6];
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uc356; else goto cc34O;
       uc356: // global
           call _cc34N(R1) args: 0, res: 0, upd: 0;
       cc34O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc34N() //  [R1]
         { info_tbl: [(cc34N,
                       label: block_cc34N_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc34N: // global
           I64[Sp] = block_cc34T_info;
           _sc2XX::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sc2XX::I64;
           if (R1 & 7 != 0) goto uc355; else goto cc34X;
       uc355: // global
           call _cc34T(R1) args: 0, res: 0, upd: 0;
       cc34X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc34T() //  [R1]
         { info_tbl: [(cc34T,
                       label: block_cc34T_info
                       rep:StackRep [True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc34T: // global
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] debugBelch2(I64[Sp + 8], I64[R1 + 7]);
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sc2Y4_entry() //  [R1, R2]
         { info_tbl: [(cc357,
                       label: sat_sc2Y4_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc357: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc358; else goto cc359;
       cc358: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc359: // global
           I64[Sp - 32] = block_cc342_info;
           _sc2Xl::P64 = P64[R1 + 6];
           _sc2Xp::P64 = P64[R1 + 14];
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 24] = _sc2Xl::P64;
           P64[Sp - 16] = _sc2Xp::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc342() //  [R1]
         { info_tbl: [(cc342,
                       label: block_cc342_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc342: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc35c; else goto cc35b;
       cc35c: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc35b: // global
           I64[Hp - 8] = sat_sc2XH_info;
           P64[Hp] = P64[Sp + 24];
           I64[Sp] = block_cc34t_info;
           R4 = Hp - 6;
           R3 = P64[Sp + 16];
           R2 = R1;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc34t() //  []
         { info_tbl: [(cc34t,
                       label: block_cc34t_info
                       rep:StackRep [False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc34t: // global
           I64[Sp + 16] = block_cc34v_info;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uc35p; else goto cc34w;
       uc35p: // global
           call _cc34v(R1) args: 0, res: 0, upd: 0;
       cc34w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc34v() //  [R1]
         { info_tbl: [(cc34v,
                       label: block_cc34v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc34v: // global
           I64[Sp] = block_cc34A_info;
           R1 = P64[R1 + 7];
           if (R1 & 7 != 0) goto uc35q; else goto cc34B;
       uc35q: // global
           call _cc34A(R1) args: 0, res: 0, upd: 0;
       cc34B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc34A() //  [R1]
         { info_tbl: [(cc34A,
                       label: block_cc34A_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc34A: // global
           if (R1 & 7 == 1) goto cc35i; else goto cc35k;
       cc35i: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cc35k: // global
           I64[Sp] = block_cc34G_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc34G() //  [R1]
         { info_tbl: [(cc34G,
                       label: block_cc34G_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc34G: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cc35n; else goto cc35m;
       cc35n: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc35m: // global
           I64[Hp - 8] = sat_sc2Y3_info;
           P64[Hp] = P64[Sp + 8];
           R4 = Hp - 6;
           R3 = Debug.Trace.putTraceMsg2_closure;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Debug.Trace.putTraceMsg1_entry() //  [R2]
         { info_tbl: [(cc35r,
                       label: Debug.Trace.putTraceMsg1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc35r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc35s; else goto cc35t;
       cc35s: // global
           R2 = R2;
           R1 = Debug.Trace.putTraceMsg1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cc35t: // global
           I64[Sp - 16] = block_cc33H_info;
           R1 = GHC.IO.Encoding.getForeignEncoding_closure;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc33H() //  [R1]
         { info_tbl: [(cc33H,
                       label: block_cc33H_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc33H: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cc35w; else goto cc35v;
       cc35w: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc35v: // global
           I64[Hp - 64] = ds_sc2Xl_info;
           P64[Hp - 48] = P64[Sp + 8];
           I64[Hp - 40] = stg_sel_1_upd_info;
           _cc33J::P64 = Hp - 64;
           P64[Hp - 24] = _cc33J::P64;
           I64[Hp - 16] = sat_sc2Y4_info;
           P64[Hp - 8] = _cc33J::P64;
           P64[Hp] = Hp - 40;
           R4 = Hp - 14;
           R3 = Debug.Trace.putTraceMsg4_closure;
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Foreign.charIsRepresentable3_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.368430258 UTC

[section ""data" . Debug.Trace.traceIO_closure" {
     Debug.Trace.traceIO_closure:
         const Debug.Trace.traceIO_info;
         const 0;
 },
 Debug.Trace.traceIO_entry() //  [R2]
         { info_tbl: [(cc374,
                       label: Debug.Trace.traceIO_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc374: // global
           R2 = R2;
           call Debug.Trace.putTraceMsg1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.371900427 UTC

[section ""data" . Debug.Trace.putTraceMsg_closure" {
     Debug.Trace.putTraceMsg_closure:
         const Debug.Trace.putTraceMsg_info;
         const 0;
 },
 Debug.Trace.putTraceMsg_entry() //  [R2]
         { info_tbl: [(cc37f,
                       label: Debug.Trace.putTraceMsg_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc37f: // global
           R2 = R2;
           call Debug.Trace.putTraceMsg1_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.375123723 UTC

[section ""data" . Debug.Trace.trace_closure" {
     Debug.Trace.trace_closure:
         const Debug.Trace.trace_info;
         const 0;
 },
 Debug.Trace.trace_entry() //  [R2, R3]
         { info_tbl: [(cc37x,
                       label: Debug.Trace.trace_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc37x: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc37y; else goto cc37z;
       cc37y: // global
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.trace_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc37z: // global
           I64[Sp - 24] = block_cc37q_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cc37q() //  []
         { info_tbl: [(cc37q,
                       label: block_cc37q_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc37q: // global
           _sc2Y5::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc37s_info;
           R2 = _sc2Y5::P64;
           Sp = Sp + 8;
           call Debug.Trace.putTraceMsg1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc37s() //  []
         { info_tbl: [(cc37s,
                       label: block_cc37s_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc37s: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.381648411 UTC

[section ""data" . Debug.Trace.traceId_closure" {
     Debug.Trace.traceId_closure:
         const Debug.Trace.traceId_info;
         const 0;
 },
 Debug.Trace.traceId_entry() //  [R2]
         { info_tbl: [(cc37U,
                       label: Debug.Trace.traceId_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc37U: // global
           R3 = R2;
           R2 = R2;
           call Debug.Trace.trace_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.385190709 UTC

[section ""data" . Debug.Trace.traceShow_closure" {
     Debug.Trace.traceShow_closure:
         const Debug.Trace.traceShow_info;
         const 0;
 },
 sat_sc2Yh_entry() //  [R1]
         { info_tbl: [(cc389,
                       label: sat_sc2Yh_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc389: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc38a; else goto cc38b;
       cc38a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc38b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Show.show_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Debug.Trace.traceShow_entry() //  [R2, R3]
         { info_tbl: [(cc38c,
                       label: Debug.Trace.traceShow_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc38c: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc38g; else goto cc38f;
       cc38g: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceShow_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc38f: // global
           I64[Hp - 24] = sat_sc2Yh_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = Debug.Trace.trace_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.39143582 UTC

[section ""data" . Debug.Trace.traceShowId_closure" {
     Debug.Trace.traceShowId_closure:
         const Debug.Trace.traceShowId_info;
         const 0;
 },
 sat_sc2Yk_entry() //  [R1]
         { info_tbl: [(cc38B,
                       label: sat_sc2Yk_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc38B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc38C; else goto cc38D;
       cc38C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc38D: // global
           R2 = P64[R1 + 16];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Show.show_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Debug.Trace.traceShowId_entry() //  [R2, R3]
         { info_tbl: [(cc38E,
                       label: Debug.Trace.traceShowId_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc38E: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cc38I; else goto cc38H;
       cc38I: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceShowId_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc38H: // global
           I64[Hp - 24] = sat_sc2Yk_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = R3;
           R2 = Hp - 24;
           call Debug.Trace.trace_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.396898558 UTC

[section ""data" . Debug.Trace.traceM_closure" {
     Debug.Trace.traceM_closure:
         const Debug.Trace.traceM_info;
         const 0;
 },
 sat_sc2Yn_entry() //  [R1]
         { info_tbl: [(cc392,
                       label: sat_sc2Yn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc392: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc393; else goto cc394;
       cc393: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc394: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 Debug.Trace.traceM_entry() //  [R2, R3]
         { info_tbl: [(cc395,
                       label: Debug.Trace.traceM_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc395: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc399; else goto cc398;
       cc399: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc398: // global
           I64[Hp - 16] = sat_sc2Yn_info;
           P64[Hp] = R2;
           _sc2Ym::P64 = R3;
           R3 = Hp - 16;
           R2 = _sc2Ym::P64;
           call Debug.Trace.trace_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.403262489 UTC

[section ""data" . Debug.Trace.traceShowM_closure" {
     Debug.Trace.traceShowM_closure:
         const Debug.Trace.traceShowM_info;
         const 0;
 },
 sat_sc2Ys_entry() //  [R1]
         { info_tbl: [(cc39v,
                       label: sat_sc2Ys_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc39v: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cc39w; else goto cc39x;
       cc39w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc39x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Tuple.()_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 sat_sc2Yr_entry() //  [R1]
         { info_tbl: [(cc39C,
                       label: sat_sc2Yr_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc39C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cc39D; else goto cc39E;
       cc39D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc39E: // global
           R2 = P64[R1 + 16];
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Show.show_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 Debug.Trace.traceShowM_entry() //  [R2, R3, R4]
         { info_tbl: [(cc39F,
                       label: Debug.Trace.traceShowM_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc39F: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cc39J; else goto cc39I;
       cc39J: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceShowM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cc39I: // global
           I64[Hp - 48] = sat_sc2Ys_info;
           P64[Hp - 32] = R3;
           I64[Hp - 24] = sat_sc2Yr_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R3 = Hp - 48;
           R2 = Hp - 24;
           call Debug.Trace.trace_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.411895313 UTC

[section ""data" . Debug.Trace.traceStack_closure" {
     Debug.Trace.traceStack_closure:
         const Debug.Trace.traceStack_info;
         const 0;
 },
 sat_sc2YJ_entry() //  [R1]
         { info_tbl: [(cc3au,
                       label: sat_sc2YJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc3au: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc3av; else goto cc3aw;
       cc3av: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc3aw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cc3as_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 _cc3as() //  [R1]
         { info_tbl: [(cc3as,
                       label: block_cc3as_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc3as: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Stack.CCS.renderStack_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sc2YK_entry() //  [R1]
         { info_tbl: [(cc3aA,
                       label: sat_sc2YK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc3aA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc3aE; else goto cc3aD;
       cc3aE: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cc3aD: // global
           _sc2YF::P64 = P64[R1 + 16];
           I64[Hp - 16] = sat_sc2YJ_info;
           P64[Hp] = _sc2YF::P64;
           R3 = Hp - 16;
           R2 = GHC.Stack.CCS.renderStack1_bytes;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 Debug.Trace.traceStack_entry() //  [R2, R3]
         { info_tbl: [(cc3aM,
                       label: Debug.Trace.traceStack_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc3aM: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cc3aN; else goto cc3aO;
       cc3aN: // global
           R3 = R3;
           R2 = R2;
           R1 = Debug.Trace.traceStack_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cc3aO: // global
           I64[Sp - 24] = block_cc3a8_info;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_noDuplicate#() args: 8, res: 8, upd: 8;
     }
 },
 _cc3a8() //  []
         { info_tbl: [(cc3a8,
                       label: block_cc3a8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc3a8: // global
           _sc2Yt::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cc3aa_info;
           R2 = _sc2Yt::P64;
           Sp = Sp + 8;
           call Debug.Trace.putTraceMsg1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc3aa() //  []
         { info_tbl: [(cc3aa,
                       label: block_cc3aa_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc3aa: // global
           I64[Sp] = block_cc3ac_info;
           R3 = GHC.Types.[]_closure+1;
           R2 = CCCS;
           call GHC.Stack.CCS.$wgo_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc3ac() //  [R1]
         { info_tbl: [(cc3ac,
                       label: block_cc3ac_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc3ac: // global
           I64[Sp] = block_cc3ae_info;
           R1 = R1;
           if (R1 & 7 != 0) goto uc3b3; else goto cc3af;
       uc3b3: // global
           call _cc3ae(R1) args: 0, res: 0, upd: 0;
       cc3af: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cc3ae() //  [R1]
         { info_tbl: [(cc3ae,
                       label: block_cc3ae_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc3ae: // global
           if (R1 & 7 == 1) goto cc3aG; else goto cc3aH;
       cc3aG: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cc3aF() args: 0, res: 0, upd: 0;
       cc3aH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cc3aX; else goto cc3aW;
       cc3aX: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cc3aW: // global
           I64[Hp - 16] = sat_sc2YK_info;
           P64[Hp] = R1;
           I64[Sp] = block_cc3aU_info;
           R2 = Hp - 16;
           call Debug.Trace.putTraceMsg1_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 _cc3aU() //  []
         { info_tbl: [(cc3aU,
                       label: block_cc3aU_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc3aU: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cc3aF() args: 0, res: 0, upd: 0;
     }
 },
 _cc3aF() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       cc3aF: // global
           R1 = P64[Sp];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 16:06:57.429382033 UTC

[section ""relreadonly" . Sc2Zv_srt" {
     Sc2Zv_srt:
         const GHC.IO.Encoding.UTF8.utf8_closure;
         const Debug.Trace.traceEventIO1_closure;
         const Debug.Trace.traceMarkerIO1_closure;
         const Debug.Trace.traceMarker_closure;
         const Debug.Trace.traceEvent_closure;
         const GHC.IO.Encoding.getForeignEncoding_closure;
         const Debug.Trace.putTraceMsg2_closure;
         const Debug.Trace.putTraceMsg1_closure;
         const Debug.Trace.putTraceMsg4_closure;
         const Debug.Trace.trace_closure;
         const Debug.Trace.traceShow_closure;
         const Debug.Trace.traceShowId_closure;
         const Debug.Trace.traceM_closure;
         const Debug.Trace.traceShowM_closure;
         const GHC.Stack.CCS.renderStack_go_closure;
         const GHC.Stack.CCS.$wgo_closure;
         const Debug.Trace.traceStack_closure;
 }]

