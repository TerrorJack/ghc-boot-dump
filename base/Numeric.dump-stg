
==================== Pre unarise: ====================
2018-03-16 15:58:55.938203215 UTC

Numeric.readInt
  :: forall a.
     GHC.Num.Num a =>
     a
     -> (GHC.Types.Char -> GHC.Types.Bool)
     -> (GHC.Types.Char -> GHC.Types.Int)
     -> Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=4,
 Str=<L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))><L,U><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_s43P3 base_s43P4 isDigit_s43P5 valDigit_s43P6]
        let {
          sat_s43P9 [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42Zn
          [LclId] =
              [$dNum_s43P3 base_s43P4 isDigit_s43P5 valDigit_s43P6] \u []
                  case
                      Text.Read.Lex.$wreadIntP
                          $dNum_s43P3
                          base_s43P4
                          isDigit_s43P5
                          valDigit_s43P6
                          Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                  of
                  { Unit# ww1_s43P8 [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Get [ww1_s43P8];
                  };
        } in  Text.ParserCombinators.ReadP.run sat_s43P9;

Numeric.readOct
  :: forall a.
     (GHC.Classes.Eq a, GHC.Num.Num a) =>
     Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=2,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dEq_s43Pa $dNum_s43Pb]
        let {
          sat_s43Pf [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42Ze
          [LclId] =
              [$dEq_s43Pa $dNum_s43Pb] \u []
                  let {
                    sat_s43Pc [Occ=Once] :: a_a42Ze
                    [LclId] =
                        [$dNum_s43Pb] \u []
                            GHC.Num.fromInteger $dNum_s43Pb Text.Read.Lex.readDecP4;
                  } in 
                    case
                        Text.Read.Lex.$wreadIntP'
                            $dEq_s43Pa
                            $dNum_s43Pb
                            sat_s43Pc
                            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                    of
                    { Unit# ww1_s43Pe [Occ=Once] ->
                          Text.ParserCombinators.ReadP.Get [ww1_s43Pe];
                    };
        } in  Text.ParserCombinators.ReadP.run sat_s43Pf;

Numeric.readDec
  :: forall a.
     (GHC.Classes.Eq a, GHC.Num.Num a) =>
     Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=2,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dEq_s43Pg $dNum_s43Ph]
        let {
          sat_s43Pl [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42Z5
          [LclId] =
              [$dEq_s43Pg $dNum_s43Ph] \u []
                  let {
                    sat_s43Pi [Occ=Once] :: a_a42Z5
                    [LclId] =
                        [$dNum_s43Ph] \u []
                            GHC.Num.fromInteger $dNum_s43Ph Text.Read.Lex.numberToFixed1;
                  } in 
                    case
                        Text.Read.Lex.$wreadIntP'
                            $dEq_s43Pg
                            $dNum_s43Ph
                            sat_s43Pi
                            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                    of
                    { Unit# ww1_s43Pk [Occ=Once] ->
                          Text.ParserCombinators.ReadP.Get [ww1_s43Pk];
                    };
        } in  Text.ParserCombinators.ReadP.run sat_s43Pl;

Numeric.readHex
  :: forall a.
     (GHC.Classes.Eq a, GHC.Num.Num a) =>
     Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=2,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dEq_s43Pm $dNum_s43Pn]
        let {
          sat_s43Pr [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42YW
          [LclId] =
              [$dEq_s43Pm $dNum_s43Pn] \u []
                  let {
                    sat_s43Po [Occ=Once] :: a_a42YW
                    [LclId] =
                        [$dNum_s43Pn] \u []
                            GHC.Num.fromInteger $dNum_s43Pn Text.Read.Lex.readDecP3;
                  } in 
                    case
                        Text.Read.Lex.$wreadIntP'
                            $dEq_s43Pm
                            $dNum_s43Pn
                            sat_s43Po
                            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                    of
                    { Unit# ww1_s43Pq [Occ=Once] ->
                          Text.ParserCombinators.ReadP.Get [ww1_s43Pq];
                    };
        } in  Text.ParserCombinators.ReadP.run sat_s43Pr;

Numeric.readFloat2
  :: forall a. GHC.Base.String -> Text.ParserCombinators.ReadP.P a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [a3_s43Ps]
        case a3_s43Ps of {
          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
        };

Numeric.readFloat1 :: forall a. Text.ParserCombinators.ReadP.P a
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE Text.ParserCombinators.ReadP.Look! [Numeric.readFloat2];

Numeric.readFloat
  :: forall a.
     GHC.Real.RealFrac a =>
     Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=1,
 Str=<L,1*U(A,1*U(A,A,A,C(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_s43Pu]
        let {
          lvl116_s43Pv [Occ=OnceL] :: Text.ParserCombinators.ReadP.P a_a42YP
          [LclId] =
              [$dRealFrac_s43Pu] \u []
                  let {
                    sat_s43PG [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42YP
                    [LclId] =
                        [$dRealFrac_s43Pu] \u []
                            let {
                              $dFractional_s43Pw [Occ=OnceL, Dmd=<L,U(A,A,A,C(U))>]
                                :: GHC.Real.Fractional a_a42YP
                              [LclId] =
                                  [$dRealFrac_s43Pu] \u []
                                      GHC.Real.$p2RealFrac $dRealFrac_s43Pu; } in
                            let {
                              sat_s43PF [Occ=Once]
                                :: Text.Read.Lex.Lexeme -> Text.ParserCombinators.ReadP.P a_a42YP
                              [LclId] =
                                  [$dFractional_s43Pw] \r [a1_s43Px]
                                      case a1_s43Px of {
                                        __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                        Text.Read.Lex.Number n_s43Pz [Occ=Once] ->
                                            let {
                                              sat_s43PE [Occ=Once] :: a_a42YP
                                              [LclId] =
                                                  [$dFractional_s43Pw n_s43Pz] \u []
                                                      let {
                                                        sat_s43PD [Occ=Once] :: GHC.Real.Rational
                                                        [LclId] =
                                                            [n_s43Pz] \u []
                                                                case
                                                                    Text.Read.Lex.$wnumberToRational
                                                                        n_s43Pz
                                                                of
                                                                { (#,#) ww1_s43PB [Occ=Once]
                                                                        ww2_s43PC [Occ=Once] ->
                                                                      GHC.Real.:% [ww1_s43PB
                                                                                   ww2_s43PC];
                                                                };
                                                      } in 
                                                        GHC.Real.fromRational
                                                            $dFractional_s43Pw sat_s43PD;
                                            } in 
                                              Text.ParserCombinators.ReadP.Result [sat_s43PE
                                                                                   Text.ParserCombinators.ReadP.Fail];
                                      };
                            } in  Text.Read.Lex.expect2 sat_s43PF;
                  } in 
                    Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                        Numeric.readFloat1 sat_s43PG; } in
        let {
          k_s43PH [Occ=OnceL, Dmd=<L,C(U)>]
            :: () -> Text.ParserCombinators.ReadP.P a_a42YP
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl116_s43Pv] \r [a3_s43PI] lvl116_s43Pv; } in
        let {
          sat_s43PK [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P a_a42YP
          [LclId] =
              [k_s43PH] \r [a1_s43PJ]
                  Text.ParserCombinators.ReadP.skipSpaces2 a1_s43PJ k_s43PH; } in
        let {
          sat_s43PL [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42YP
          [LclId] =
              CCCS Text.ParserCombinators.ReadP.Look! [sat_s43PK];
        } in  Text.ParserCombinators.ReadP.run sat_s43PL;

Numeric.readSigned
  :: forall a.
     GHC.Real.Real a =>
     Text.ParserCombinators.ReadP.ReadS a
     -> Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=3,
 Str=<L,1*U(1*U(A,A,A,C(U),A,A,A),A,A)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dReal_s43PM eta_s43PN eta1_s43PO]
        let {
          $dNum_s43PP [Occ=OnceL, Dmd=<L,U(A,A,A,C(U),A,A,A)>]
            :: GHC.Num.Num a_a42Xv
          [LclId] =
              [$dReal_s43PM] \u [] GHC.Real.$p1Real $dReal_s43PM; } in
        let {
          go_s43PQ [Occ=LoopBreaker]
            :: [(GHC.Base.String, GHC.Base.String)]
               -> [(a_a42Xv, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [eta_s43PN go_s43PQ] \r [ds_s43PR]
                  case ds_s43PR of {
                    [] -> [] [];
                    : y_s43PT [Occ=Once!] ys_s43PU [Occ=Once] ->
                        case y_s43PT of {
                          (,) str_s43PW [Occ=Once] s_s43PX [Occ=OnceL] ->
                              let {
                                z_s43PY [Occ=OnceL] :: [(a_a42Xv, GHC.Base.String)]
                                [LclId] =
                                    [go_s43PQ ys_s43PU] \u [] go_s43PQ ys_s43PU; } in
                              let {
                                go1_s43PZ [Occ=LoopBreaker]
                                  :: [(a_a42Xv, GHC.Base.String)] -> [(a_a42Xv, GHC.Base.String)]
                                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                    sat-only [s_s43PX z_s43PY go1_s43PZ] \r [ds1_s43Q0]
                                        case ds1_s43Q0 of {
                                          [] -> z_s43PY;
                                          : y1_s43Q2 [Occ=Once!] ys1_s43Q3 [Occ=Once*] ->
                                              case y1_s43Q2 of {
                                                (,) n_s43Q5 [Occ=Once] ds2_s43Q6 [Occ=Once!] ->
                                                    case ds2_s43Q6 of {
                                                      [] ->
                                                          let {
                                                            sat_s43Q9 [Occ=Once]
                                                              :: [(a_a42Xv, GHC.Base.String)]
                                                            [LclId] =
                                                                [go1_s43PZ ys1_s43Q3] \u []
                                                                    go1_s43PZ ys1_s43Q3; } in
                                                          let {
                                                            sat_s43Q8 [Occ=Once]
                                                              :: (a_a42Xv, GHC.Base.String)
                                                            [LclId] =
                                                                CCCS (,)! [n_s43Q5 s_s43PX];
                                                          } in  : [sat_s43Q8 sat_s43Q9];
                                                      : _ [Occ=Dead] _ [Occ=Dead] ->
                                                          go1_s43PZ ys1_s43Q3;
                                                    };
                                              };
                                        };
                              } in 
                                case eta_s43PN str_s43PW of sat_s43Qc {
                                  __DEFAULT -> go1_s43PZ sat_s43Qc;
                                };
                        };
                  }; } in
        let {
          go1_s43Qd [Occ=LoopBreaker]
            :: [(GHC.Base.String, GHC.Base.String)]
               -> [(a_a42Xv, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dNum_s43PP go_s43PQ go1_s43Qd] \r [ds_s43Qe]
                  case ds_s43Qe of {
                    [] -> [] [];
                    : y_s43Qg [Occ=Once!] ys_s43Qh [Occ=Once*] ->
                        case y_s43Qg of {
                          (,) ds1_s43Qj [Occ=Once!] s_s43Qk [Occ=Once] ->
                              case ds1_s43Qj of {
                                [] -> go1_s43Qd ys_s43Qh;
                                : ds2_s43Qm [Occ=Once!] ds3_s43Qn [Occ=Once!] ->
                                    case ds2_s43Qm of {
                                      GHC.Types.C# ds4_s43Qp [Occ=Once!] ->
                                          case ds4_s43Qp of {
                                            __DEFAULT -> go1_s43Qd ys_s43Qh;
                                            '-'# ->
                                                case ds3_s43Qn of {
                                                  [] ->
                                                      let {
                                                        z_s43Qs [Occ=OnceL]
                                                          :: [(a_a42Xv, GHC.Base.String)]
                                                        [LclId] =
                                                            [go1_s43Qd ys_s43Qh] \u []
                                                                go1_s43Qd ys_s43Qh; } in
                                                      let {
                                                        go2_s43Qt [Occ=LoopBreaker]
                                                          :: [(a_a42Xv, GHC.Base.String)]
                                                             -> [(a_a42Xv, GHC.Base.String)]
                                                        [LclId,
                                                         Arity=1,
                                                         Str=<S,1*U>,
                                                         Unf=OtherCon []] =
                                                            sat-only [$dNum_s43PP
                                                                      z_s43Qs
                                                                      go2_s43Qt] \r [ds6_s43Qu]
                                                                case ds6_s43Qu of {
                                                                  [] -> z_s43Qs;
                                                                  : y1_s43Qw [Occ=Once!]
                                                                    ys1_s43Qx [Occ=Once] ->
                                                                      case y1_s43Qw of {
                                                                        (,) x_s43Qz [Occ=Once]
                                                                            t_s43QA [Occ=Once] ->
                                                                            let {
                                                                              sat_s43QD [Occ=Once]
                                                                                :: [(a_a42Xv,
                                                                                     GHC.Base.String)]
                                                                              [LclId] =
                                                                                  [go2_s43Qt
                                                                                   ys1_s43Qx] \u []
                                                                                      go2_s43Qt
                                                                                          ys1_s43Qx; } in
                                                                            let {
                                                                              sat_s43QB [Occ=Once]
                                                                                :: a_a42Xv
                                                                              [LclId] =
                                                                                  [$dNum_s43PP
                                                                                   x_s43Qz] \u []
                                                                                      GHC.Num.negate
                                                                                          $dNum_s43PP
                                                                                          x_s43Qz; } in
                                                                            let {
                                                                              sat_s43QC [Occ=Once]
                                                                                :: (a_a42Xv,
                                                                                    GHC.Base.String)
                                                                              [LclId] =
                                                                                  CCCS (,)! [sat_s43QB
                                                                                             t_s43QA];
                                                                            } in 
                                                                              : [sat_s43QC
                                                                                 sat_s43QD];
                                                                      };
                                                                };
                                                      } in 
                                                        case
                                                            Text.ParserCombinators.ReadP.run
                                                                GHC.Read.lex1 s_s43Qk
                                                        of
                                                        sat_s43QE
                                                        { __DEFAULT ->
                                                              case go_s43PQ sat_s43QE of sat_s43QF {
                                                                __DEFAULT -> go2_s43Qt sat_s43QF;
                                                              };
                                                        };
                                                  : _ [Occ=Dead] _ [Occ=Dead] -> go1_s43Qd ys_s43Qh;
                                                };
                                          };
                                    };
                              };
                        };
                  }; } in
        let {
          sat_s43QN [Occ=Once] :: Text.ParserCombinators.ReadP.ReadS a_a42Xv
          [LclId] =
              [go_s43PQ go1_s43Qd] \r [r_s43QI]
                  let {
                    sat_s43QM [Occ=Once, Dmd=<L,1*U>] :: [(a_a42Xv, GHC.Base.String)]
                    [LclId] =
                        [go1_s43Qd r_s43QI] \s []
                            case
                                Text.ParserCombinators.ReadP.run GHC.Read.lex1 r_s43QI
                            of
                            sat_s43QL
                            { __DEFAULT -> go1_s43Qd sat_s43QL;
                            };
                  } in 
                    case
                        Text.ParserCombinators.ReadP.run GHC.Read.lex1 r_s43QI
                    of
                    sat_s43QJ
                    { __DEFAULT ->
                          case go_s43PQ sat_s43QJ of sat_s43QK {
                            __DEFAULT -> GHC.Base.++ sat_s43QK sat_s43QM;
                          };
                    };
        } in  GHC.Read.readParen GHC.Types.False sat_s43QN eta1_s43PO;

sat_s43QO :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [10#];

sat_s43QP :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s43QO GHC.Types.[]];

Numeric.showInt2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s43QP;

lvl_r43OH :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Numeric.showInt: can't show negative numbers"#;

Numeric.showInt1 :: GHC.Base.String
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_r43OH of sat_s43QQ {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s43QQ;
        };

Numeric.showHFloat16 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Numeric.showInt
  :: forall a. GHC.Real.Integral a => a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLLLC(S)),U(1*U(U(A,A,A,A,A,A,C(U)),U(A,A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s43QR eta_s43QS eta1_s43QT]
        case
            GHC.Real.$p1Integral $dIntegral_s43QR
        of
        $dReal_s43QU [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(U(A,A,A,A,A,A,C(U)),U(A,A,C(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s43QX [Occ=Once] :: a_a42W2
                [LclId] =
                    [$dReal_s43QU] \u []
                        case GHC.Real.$p1Real $dReal_s43QU of sat_s43QW {
                          __DEFAULT -> GHC.Num.fromInteger sat_s43QW Numeric.showHFloat16;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s43QU of sat_s43QV {
                  __DEFAULT ->
                      case GHC.Classes.< sat_s43QV eta_s43QS sat_s43QX of {
                        GHC.Types.False ->
                            let {
                              lvl5_s43QZ :: a_a42W2
                              [LclId] =
                                  [$dReal_s43QU] \u []
                                      case GHC.Real.$p1Real $dReal_s43QU of sat_s43R0 {
                                        __DEFAULT -> GHC.Num.fromInteger sat_s43R0 Numeric.showInt2;
                                      };
                            } in 
                              case
                                  GHC.Real.$p2Real $dReal_s43QU
                              of
                              $dOrd_s43R1 [Dmd=<S(LLC(C(S))LLLLL),U(A,A,C(C1(U)),A,A,A,A,A)>]
                              { __DEFAULT ->
                                    let-no-escape {
                                      exit_s43R2 [Occ=OnceL!T[2], Dmd=<C(C(S)),C(C1(U))>]
                                        :: a_a42W2 -> [GHC.Types.Char] -> GHC.Base.String
                                      [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                          sat-only [$dIntegral_s43QR] \r [n_s43R3 cs_s43R4]
                                              case
                                                  GHC.Real.toInteger $dIntegral_s43QR n_s43R3
                                              of
                                              sat_s43R5
                                              { __DEFAULT ->
                                                    case
                                                        GHC.Integer.Type.integerToInt sat_s43R5
                                                    of
                                                    wild1_s43R6
                                                    { __DEFAULT ->
                                                          case +# [48# wild1_s43R6] of sat_s43R7 {
                                                            __DEFAULT ->
                                                                case chr# [sat_s43R7] of sat_s43R8 {
                                                                  __DEFAULT ->
                                                                      let {
                                                                        sat_s43R9 [Occ=Once]
                                                                          :: GHC.Types.Char
                                                                        [LclId] =
                                                                            CCCS GHC.Types.C#! [sat_s43R8];
                                                                      } in  : [sat_s43R9 cs_s43R4];
                                                                };
                                                          };
                                                    };
                                              };
                                    } in 
                                      let-no-escape {
                                        go_s43Ra [Occ=LoopBreakerT[2]]
                                          :: a_a42W2 -> [GHC.Types.Char] -> GHC.Base.String
                                        [LclId[JoinId(2)],
                                         Arity=2,
                                         Str=<L,U><L,U>,
                                         Unf=OtherCon []] =
                                            sat-only [$dIntegral_s43QR
                                                      lvl5_s43QZ
                                                      $dOrd_s43R1
                                                      exit_s43R2
                                                      go_s43Ra] \r [n_s43Rb cs_s43Rc]
                                                case
                                                    GHC.Classes.< $dOrd_s43R1 n_s43Rb lvl5_s43QZ
                                                of
                                                { GHC.Types.False ->
                                                      let {
                                                        ds_s43Re [Dmd=<L,U(1*U,1*U)>]
                                                          :: (a_a42W2, a_a42W2)
                                                        [LclId] =
                                                            [$dIntegral_s43QR
                                                             lvl5_s43QZ
                                                             n_s43Rb] \u []
                                                                GHC.Real.quotRem
                                                                    $dIntegral_s43QR
                                                                    n_s43Rb
                                                                    lvl5_s43QZ; } in
                                                      let {
                                                        sat_s43Ri [Occ=Once] :: a_a42W2
                                                        [LclId] =
                                                            [ds_s43Re] \u []
                                                                case ds_s43Re of {
                                                                  (,) _ [Occ=Dead]
                                                                      r_s43Rh [Occ=Once] ->
                                                                      r_s43Rh;
                                                                };
                                                      } in 
                                                        case
                                                            GHC.Real.toInteger
                                                                $dIntegral_s43QR sat_s43Ri
                                                        of
                                                        sat_s43Rj
                                                        { __DEFAULT ->
                                                              case
                                                                  GHC.Integer.Type.integerToInt
                                                                      sat_s43Rj
                                                              of
                                                              wild2_s43Rk
                                                              { __DEFAULT ->
                                                                    case
                                                                        +# [48# wild2_s43Rk]
                                                                    of
                                                                    sat_s43Rp
                                                                    { __DEFAULT ->
                                                                          case
                                                                              chr# [sat_s43Rp]
                                                                          of
                                                                          sat_s43Rq
                                                                          { __DEFAULT ->
                                                                                let {
                                                                                  sat_s43Rr [Occ=Once]
                                                                                    :: GHC.Types.Char
                                                                                  [LclId] =
                                                                                      CCCS GHC.Types.C#! [sat_s43Rq]; } in
                                                                                let {
                                                                                  sat_s43Rs [Occ=Once]
                                                                                    :: [GHC.Types.Char]
                                                                                  [LclId] =
                                                                                      CCCS :! [sat_s43Rr
                                                                                               cs_s43Rc]; } in
                                                                                let {
                                                                                  sat_s43Ro [Occ=Once]
                                                                                    :: a_a42W2
                                                                                  [LclId] =
                                                                                      [ds_s43Re] \u []
                                                                                          case
                                                                                              ds_s43Re
                                                                                          of
                                                                                          { (,) q_s43Rm [Occ=Once]
                                                                                                _ [Occ=Dead] ->
                                                                                                q_s43Rm;
                                                                                          };
                                                                                } in 
                                                                                  go_s43Ra
                                                                                      sat_s43Ro
                                                                                      sat_s43Rs;
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  GHC.Types.True -> exit_s43R2 n_s43Rb cs_s43Rc;
                                                };
                                      } in  go_s43Ra eta_s43QS eta1_s43QT;
                              };
                        GHC.Types.True -> Numeric.showInt1;
                      };
                };
        };

Numeric.showFFloatAlt
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Base.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s43Rt d_s43Ru x_s43Rv]
        let {
          sat_s43Rw [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s43Rt d_s43Ru x_s43Rv] \u []
                  GHC.Float.formatRealFloatAlt
                      $dRealFloat_s43Rt GHC.Float.FFFixed d_s43Ru GHC.Types.True x_s43Rv;
        } in  GHC.Base.++ sat_s43Rw;

Numeric.showGFloatAlt
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Base.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s43Rx d_s43Ry x_s43Rz]
        let {
          sat_s43RA [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s43Rx d_s43Ry x_s43Rz] \u []
                  GHC.Float.formatRealFloatAlt
                      $dRealFloat_s43Rx
                      GHC.Float.FFGeneric
                      d_s43Ry
                      GHC.Types.True
                      x_s43Rz;
        } in  GHC.Base.++ sat_s43RA;

lvl1_r43OI :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Numeric.showIntAtBase: applied to negative number "#;

Numeric.$wlvl [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int# -> GHC.Base.String
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [ww_s43RB]
        let {
          sat_s43RF [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [ww_s43RB] \u []
                  case GHC.Show.$wshowSignedInt 0# ww_s43RB GHC.Types.[] of {
                    (#,#) ww5_s43RD [Occ=Once] ww6_s43RE [Occ=Once] ->
                        : [ww5_s43RD ww6_s43RE];
                  };
        } in 
          case
              GHC.CString.unpackAppendCString# lvl1_r43OI sat_s43RF
          of
          sat_s43RG
          { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s43RG;
          };

lvl2_r43OJ :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Numeric.showIntAtBase: applied to unsupported base "#;

Numeric.showIntAtBase2
  :: forall a. GHC.Show.Show a => a -> GHC.Base.String
[GblId, Arity=2, Str=<B,1*U(A,1*C1(U),A)><B,U>x, Unf=OtherCon []] =
    [] \r [$dShow_s43RH eta_s43RI]
        let {
          sat_s43RJ [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s43RH eta_s43RI] \u []
                  GHC.Show.show $dShow_s43RH eta_s43RI;
        } in 
          case
              GHC.CString.unpackAppendCString# lvl1_r43OI sat_s43RJ
          of
          sat_s43RK
          { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s43RK;
          };

Numeric.showIntAtBase1
  :: forall a. GHC.Show.Show a => a -> GHC.Base.String
[GblId, Arity=2, Str=<B,1*U(A,1*C1(U),A)><B,U>x, Unf=OtherCon []] =
    [] \r [$dShow_s43RL eta_s43RM]
        let {
          sat_s43RN [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s43RL eta_s43RM] \u []
                  GHC.Show.show $dShow_s43RL eta_s43RM;
        } in 
          case
              GHC.CString.unpackAppendCString# lvl2_r43OJ sat_s43RN
          of
          sat_s43RO
          { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s43RO;
          };

sat_s43RP :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s43RQ :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s43RP GHC.Types.[]];

Numeric.showIntAtBase3 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s43RQ;

Numeric.showIntAtBase
  :: forall a.
     (GHC.Real.Integral a, GHC.Show.Show a) =>
     a -> (GHC.Types.Int -> GHC.Types.Char) -> a -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))C(C(S))LLLL)L)LLLLLC(C(S))LL),U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(U,U))),A,C(U))><L,1*U(A,1*C1(U),A)><L,U><C(S),C(U(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s43RR
           $dShow_s43RS
           eta_s43RT
           eta1_s43RU
           eta2_s43RV
           eta3_s43RW]
        case
            GHC.Real.$p1Integral $dIntegral_s43RR
        of
        $dReal_s43RX [Dmd=<S(LS(S(C(C(S))L)LC(C(S))C(C(S))LLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s43RY [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_a42NP
                [LclId] =
                    [$dReal_s43RX] \u [] GHC.Real.$p1Real $dReal_s43RX;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s43RX
                of
                $dOrd_s43RZ [Dmd=<S(S(C(C(S))L)LC(C(S))C(C(S))LLLL),U(1*U(C(C1(U)),A),A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s43S0 [Occ=Once] :: a_a42NP
                        [LclId] =
                            [$dNum_s43RY] \u []
                                GHC.Num.fromInteger $dNum_s43RY Numeric.showIntAtBase3;
                      } in 
                        case GHC.Classes.<= $dOrd_s43RZ eta_s43RT sat_s43S0 of {
                          GHC.Types.False ->
                              let {
                                sat_s43S2 [Occ=Once] :: a_a42NP
                                [LclId] =
                                    [$dNum_s43RY] \u []
                                        GHC.Num.fromInteger $dNum_s43RY Numeric.showHFloat16;
                              } in 
                                case GHC.Classes.< $dOrd_s43RZ eta2_s43RV sat_s43S2 of {
                                  GHC.Types.False ->
                                      case
                                          GHC.Real.quotRem $dIntegral_s43RR eta2_s43RV eta_s43RT
                                      of
                                      { (,) ww1_s43S5 [Occ=Once] ww2_s43S6 [Occ=Once] ->
                                            let {
                                              lvl5_s43S7 [Occ=OnceL] :: a_a42NP
                                              [LclId] =
                                                  [$dNum_s43RY] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s43RY Numeric.showHFloat16;
                                            } in 
                                              case
                                                  GHC.Classes.$p1Ord $dOrd_s43RZ
                                              of
                                              $dEq_s43S8 [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                              { __DEFAULT ->
                                                    let-no-escape {
                                                      $wshowIt5_s43S9 [InlPrag=NOUSERINLINE[0],
                                                                       Occ=LoopBreakerT[3]]
                                                        :: a_a42NP
                                                           -> a_a42NP
                                                           -> [GHC.Types.Char]
                                                           -> GHC.Base.String
                                                      [LclId[JoinId(3)],
                                                       Arity=3,
                                                       Str=<L,U><L,U><L,U>,
                                                       Unf=OtherCon []] =
                                                          sat-only [$dIntegral_s43RR
                                                                    eta_s43RT
                                                                    eta1_s43RU
                                                                    lvl5_s43S7
                                                                    $dEq_s43S8
                                                                    $wshowIt5_s43S9] \r [ww3_s43Sa
                                                                                         ww4_s43Sb
                                                                                         w_s43Sc]
                                                              let {
                                                                sat_s43Sf [Occ=Once]
                                                                  :: GHC.Types.Int
                                                                [LclId] =
                                                                    [$dIntegral_s43RR
                                                                     ww4_s43Sb] \u []
                                                                        case
                                                                            GHC.Real.toInteger
                                                                                $dIntegral_s43RR
                                                                                ww4_s43Sb
                                                                        of
                                                                        sat_s43Sd
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  GHC.Integer.Type.integerToInt
                                                                                      sat_s43Sd
                                                                              of
                                                                              wild2_s43Se
                                                                              { __DEFAULT ->
                                                                                    GHC.Types.I# [wild2_s43Se];
                                                                              };
                                                                        };
                                                              } in 
                                                                case
                                                                    eta1_s43RU sat_s43Sf
                                                                of
                                                                v_s43Sg
                                                                { GHC.Types.C# _ [Occ=Dead] ->
                                                                      case
                                                                          GHC.Classes.==
                                                                              $dEq_s43S8
                                                                              ww3_s43Sa
                                                                              lvl5_s43S7
                                                                      of
                                                                      { GHC.Types.False ->
                                                                            case
                                                                                GHC.Real.quotRem
                                                                                    $dIntegral_s43RR
                                                                                    ww3_s43Sa
                                                                                    eta_s43RT
                                                                            of
                                                                            { (,) ww6_s43Sk [Occ=Once]
                                                                                  ww7_s43Sl [Occ=Once] ->
                                                                                  let {
                                                                                    sat_s43Sm [Occ=Once]
                                                                                      :: [GHC.Types.Char]
                                                                                    [LclId] =
                                                                                        CCCS :! [v_s43Sg
                                                                                                 w_s43Sc];
                                                                                  } in 
                                                                                    $wshowIt5_s43S9
                                                                                        ww6_s43Sk
                                                                                        ww7_s43Sl
                                                                                        sat_s43Sm;
                                                                            };
                                                                        GHC.Types.True ->
                                                                            : [v_s43Sg w_s43Sc];
                                                                      };
                                                                };
                                                    } in 
                                                      $wshowIt5_s43S9
                                                          ww1_s43S5 ww2_s43S6 eta3_s43RW;
                                              };
                                      };
                                  GHC.Types.True -> Numeric.showIntAtBase2 $dShow_s43RS eta2_s43RV;
                                };
                          GHC.Types.True -> Numeric.showIntAtBase1 $dShow_s43RS eta_s43RT;
                        };
                };
        };

sat_s43Sn :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [16#];

sat_s43So :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s43Sn GHC.Types.[]];

Numeric.showHex1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s43So;

Numeric.showHex
  :: forall a.
     (GHC.Real.Integral a, GHC.Show.Show a) =>
     a -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(U,U))),A,C(U))><L,U(A,C(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s43Sp $dShow_s43Sq]
        let {
          sat_s43St [Occ=Once] :: a_a42Pa
          [LclId] =
              [$dIntegral_s43Sp] \u []
                  case GHC.Real.$p1Integral $dIntegral_s43Sp of sat_s43Sr {
                    __DEFAULT ->
                        case GHC.Real.$p1Real sat_s43Sr of sat_s43Ss {
                          __DEFAULT -> GHC.Num.fromInteger sat_s43Ss Numeric.showHex1;
                        };
                  };
        } in 
          Numeric.showIntAtBase
              $dIntegral_s43Sp $dShow_s43Sq sat_s43St GHC.Show.intToDigit;

Numeric.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

loc_r43OK :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.$trModule4;

Numeric.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Numeric"#;

loc1_r43OL :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.$trModule2;

loc2_r43OM :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Numeric.hs"#;

loc3_r43ON :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# loc2_r43OM;

loc4_r43OO :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [241#];

loc5_r43OP :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [22#];

loc6_r43OQ :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [75#];

$dIP_r43OR :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "error"#;

$dIP1_r43OS :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# $dIP_r43OR;

$dIP2_r43OT :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [loc_r43OK
                                           loc1_r43OL
                                           loc3_r43ON
                                           loc4_r43OO
                                           loc5_r43OP
                                           loc4_r43OO
                                           loc6_r43OQ];

$dIP3_r43OU :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [$dIP1_r43OS
                                                  $dIP2_r43OT
                                                  GHC.Stack.Types.EmptyCallStack];

lvl3_r43OV :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Impossible happened: showHFloat: "#;

lvl4_r43OW :: [GHC.Types.Char]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [GHC.Show.$fShow(,)2 GHC.Types.[]];

$wlvl2_r43OX
  :: [GHC.Types.Int] -> GHC.Prim.Int# -> [GHC.Types.Char]
[GblId, Arity=2, Str=<B,U><B,U>x, Unf=OtherCon []] =
    sat-only [] \r [ww_s43Su ww1_s43Sv]
        let {
          sat_s43SE [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [ww_s43Su ww1_s43Sv] \u []
                  let {
                    sat_s43SB [Occ=Once] :: GHC.Show.ShowS
                    [LclId] =
                        [ww1_s43Sv] \r [w2_s43Sx]
                            case GHC.Show.$wshowSignedInt 0# ww1_s43Sv w2_s43Sx of {
                              (#,#) ww5_s43Sz [Occ=Once] ww6_s43SA [Occ=Once] ->
                                  : [ww5_s43Sz ww6_s43SA];
                            }; } in
                  let {
                    sat_s43SC [Occ=Once] :: [GHC.Show.ShowS]
                    [LclId] =
                        CCCS :! [sat_s43SB GHC.Types.[]]; } in
                  let {
                    sat_s43Sw [Occ=Once] :: GHC.Show.ShowS
                    [LclId] =
                        [ww_s43Su] \r [eta_B1]
                            GHC.Show.$fShowInt_$cshowList ww_s43Su eta_B1; } in
                  let {
                    sat_s43SD [Occ=Once] :: [GHC.Base.String -> GHC.Base.String]
                    [LclId] =
                        CCCS :! [sat_s43Sw sat_s43SC];
                  } in  GHC.Show.$fShow(,)_go1 sat_s43SD lvl4_r43OW; } in
        let {
          sat_s43SF [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              CCCS :! [GHC.Show.$fShow(,)4 sat_s43SE];
        } in 
          case
              GHC.CString.unpackAppendCString# lvl3_r43OV sat_s43SF
          of
          sat_s43SG
          { __DEFAULT -> GHC.Err.error $dIP3_r43OU sat_s43SG;
          };

Numeric.showHFloat_allZ [Occ=LoopBreaker]
  :: [GHC.Types.Int] -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [xs_s43SH]
        case xs_s43SH of {
          [] -> GHC.Types.True [];
          : x_s43SJ [Occ=Once!] more_s43SK [Occ=Once] ->
              case x_s43SJ of {
                GHC.Types.I# x1_s43SM [Occ=Once!] ->
                    case x1_s43SM of {
                      __DEFAULT -> GHC.Types.False [];
                      0# -> Numeric.showHFloat_allZ more_s43SK;
                    };
              };
        };

$wshowIt1_r43OY
  :: GHC.Prim.Int#
     -> GHC.Types.Int -> [GHC.Types.Char] -> [GHC.Types.Char]
[GblId,
 Arity=3,
 Str=<S,1*U><S(S),1*U(U)><L,U>m2,
 Unf=OtherCon []] =
    sat-only [] \r [ww_s43SO ww1_s43SP w_s43SQ]
        case ww1_s43SP of {
          GHC.Types.I# ww3_s43SS [Occ=Once] ->
              case GHC.Show.$wintToDigit ww3_s43SS of ww4_s43ST {
                __DEFAULT ->
                    case ww_s43SO of wild_s43SU {
                      __DEFAULT ->
                          case quotRemInt# [wild_s43SU 16#] of {
                            (#,#) ipv_s43SW [Occ=Once] ipv1_s43SX [Occ=Once] ->
                                let {
                                  sat_s43SZ [Occ=Once] :: GHC.Types.Char
                                  [LclId] =
                                      CCCS GHC.Types.C#! [ww4_s43ST]; } in
                                let {
                                  sat_s43T0 [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      CCCS :! [sat_s43SZ w_s43SQ]; } in
                                let {
                                  sat_s43SY [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s43SX];
                                } in  $wshowIt1_r43OY ipv_s43SW sat_s43SY sat_s43T0;
                          };
                      0# ->
                          let {
                            sat_s43T1 [Occ=Once] :: GHC.Types.Char
                            [LclId] =
                                CCCS GHC.Types.C#! [ww4_s43ST];
                          } in  : [sat_s43T1 w_s43SQ];
                    };
              };
        };

$wshowIt2_r43OZ
  :: GHC.Prim.Int#
     -> GHC.Types.Int -> [GHC.Types.Char] -> [GHC.Types.Char]
[GblId,
 Arity=3,
 Str=<S,1*U><S(S),1*U(U)><L,U>m2,
 Unf=OtherCon []] =
    sat-only [] \r [ww_s43T2 ww1_s43T3 w_s43T4]
        case ww1_s43T3 of {
          GHC.Types.I# ww3_s43T6 [Occ=Once] ->
              case GHC.Show.$wintToDigit ww3_s43T6 of ww4_s43T7 {
                __DEFAULT ->
                    case ww_s43T2 of wild_s43T8 {
                      __DEFAULT ->
                          case quotRemInt# [wild_s43T8 16#] of {
                            (#,#) ipv_s43Ta [Occ=Once] ipv1_s43Tb [Occ=Once] ->
                                let {
                                  sat_s43Td [Occ=Once] :: GHC.Types.Char
                                  [LclId] =
                                      CCCS GHC.Types.C#! [ww4_s43T7]; } in
                                let {
                                  sat_s43Te [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      CCCS :! [sat_s43Td w_s43T4]; } in
                                let {
                                  sat_s43Tc [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s43Tb];
                                } in  $wshowIt2_r43OZ ipv_s43Ta sat_s43Tc sat_s43Te;
                          };
                      0# ->
                          let {
                            sat_s43Tf [Occ=Once] :: GHC.Types.Char
                            [LclId] =
                                CCCS GHC.Types.C#! [ww4_s43T7];
                          } in  : [sat_s43Tf w_s43T4];
                    };
              };
        };

$wshowIt3_r43P0
  :: GHC.Prim.Int#
     -> GHC.Types.Int -> [GHC.Types.Char] -> [GHC.Types.Char]
[GblId,
 Arity=3,
 Str=<S,1*U><S(S),1*U(U)><L,U>m2,
 Unf=OtherCon []] =
    sat-only [] \r [ww_s43Tg ww1_s43Th w_s43Ti]
        case ww1_s43Th of {
          GHC.Types.I# ww3_s43Tk [Occ=Once] ->
              case GHC.Show.$wintToDigit ww3_s43Tk of ww4_s43Tl {
                __DEFAULT ->
                    case ww_s43Tg of wild_s43Tm {
                      __DEFAULT ->
                          case quotRemInt# [wild_s43Tm 16#] of {
                            (#,#) ipv_s43To [Occ=Once] ipv1_s43Tp [Occ=Once] ->
                                let {
                                  sat_s43Tr [Occ=Once] :: GHC.Types.Char
                                  [LclId] =
                                      CCCS GHC.Types.C#! [ww4_s43Tl]; } in
                                let {
                                  sat_s43Ts [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      CCCS :! [sat_s43Tr w_s43Ti]; } in
                                let {
                                  sat_s43Tq [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s43Tp];
                                } in  $wshowIt3_r43P0 ipv_s43To sat_s43Tq sat_s43Ts;
                          };
                      0# ->
                          let {
                            sat_s43Tt [Occ=Once] :: GHC.Types.Char
                            [LclId] =
                                CCCS GHC.Types.C#! [ww4_s43Tl];
                          } in  : [sat_s43Tt w_s43Ti];
                    };
              };
        };

$wshowIt4_r43P1
  :: GHC.Prim.Int#
     -> GHC.Types.Int -> [GHC.Types.Char] -> [GHC.Types.Char]
[GblId,
 Arity=3,
 Str=<S,1*U><S(S),1*U(U)><L,U>m2,
 Unf=OtherCon []] =
    sat-only [] \r [ww_s43Tu ww1_s43Tv w_s43Tw]
        case ww1_s43Tv of {
          GHC.Types.I# ww3_s43Ty [Occ=Once] ->
              case GHC.Show.$wintToDigit ww3_s43Ty of ww4_s43Tz {
                __DEFAULT ->
                    case ww_s43Tu of wild_s43TA {
                      __DEFAULT ->
                          case quotRemInt# [wild_s43TA 16#] of {
                            (#,#) ipv_s43TC [Occ=Once] ipv1_s43TD [Occ=Once] ->
                                let {
                                  sat_s43TF [Occ=Once] :: GHC.Types.Char
                                  [LclId] =
                                      CCCS GHC.Types.C#! [ww4_s43Tz]; } in
                                let {
                                  sat_s43TG [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      CCCS :! [sat_s43TF w_s43Tw]; } in
                                let {
                                  sat_s43TE [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s43TD];
                                } in  $wshowIt4_r43P1 ipv_s43TC sat_s43TE sat_s43TG;
                          };
                      0# ->
                          let {
                            sat_s43TH [Occ=Once] :: GHC.Types.Char
                            [LclId] =
                                CCCS GHC.Types.C#! [ww4_s43Tz];
                          } in  : [sat_s43TH w_s43Tw];
                    };
              };
        };

Numeric.showHFloat_hex [Occ=LoopBreaker]
  :: [GHC.Types.Int] -> GHC.Base.String
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s43TI]
        case ds_s43TI of {
          [] -> [] [];
          : a_s43TK [Occ=Once*!] ds1_s43TL [Occ=Once!] ->
              case ds1_s43TL of {
                [] ->
                    case a_s43TK of {
                      GHC.Types.I# y_s43TO [Occ=Once] ->
                          case *# [8# y_s43TO] of ww_s43TP [Dmd=<S,U>] {
                            __DEFAULT ->
                                case <# [ww_s43TP 0#] of {
                                  __DEFAULT ->
                                      case quotRemInt# [ww_s43TP 16#] of {
                                        (#,#) ipv_s43TS [Occ=Once] ipv1_s43TT [Occ=Once] ->
                                            let {
                                              sat_s43TU [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv1_s43TT];
                                            } in  $wshowIt4_r43P1 ipv_s43TS sat_s43TU GHC.Types.[];
                                      };
                                  1# -> Numeric.$wlvl ww_s43TP;
                                };
                          };
                    };
                : b_s43TV [Occ=Once*!] ds2_s43TW [Occ=Once!] ->
                    case ds2_s43TW of {
                      [] ->
                          case a_s43TK of {
                            GHC.Types.I# y_s43TZ [Occ=Once] ->
                                case b_s43TV of {
                                  GHC.Types.I# y1_s43U1 [Occ=Once] ->
                                      case *# [4# y1_s43U1] of sat_s43U4 {
                                        __DEFAULT ->
                                            case *# [8# y_s43TZ] of sat_s43U3 {
                                              __DEFAULT ->
                                                  case
                                                      +# [sat_s43U3 sat_s43U4]
                                                  of
                                                  ww_s43U2 [Dmd=<S,U>]
                                                  { __DEFAULT ->
                                                        case <# [ww_s43U2 0#] of {
                                                          __DEFAULT ->
                                                              case quotRemInt# [ww_s43U2 16#] of {
                                                                (#,#) ipv_s43U7 [Occ=Once]
                                                                      ipv1_s43U8 [Occ=Once] ->
                                                                    let {
                                                                      sat_s43U9 [Occ=Once]
                                                                        :: GHC.Types.Int
                                                                      [LclId] =
                                                                          CCCS GHC.Types.I#! [ipv1_s43U8];
                                                                    } in 
                                                                      $wshowIt3_r43P0
                                                                          ipv_s43U7
                                                                          sat_s43U9
                                                                          GHC.Types.[];
                                                              };
                                                          1# -> Numeric.$wlvl ww_s43U2;
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                      : c_s43Ua [Occ=Once*!] ds3_s43Ub [Occ=Once!] ->
                          case ds3_s43Ub of {
                            [] ->
                                case a_s43TK of {
                                  GHC.Types.I# y_s43Ue [Occ=Once] ->
                                      case b_s43TV of {
                                        GHC.Types.I# y1_s43Ug [Occ=Once] ->
                                            case c_s43Ua of {
                                              GHC.Types.I# y2_s43Ui [Occ=Once] ->
                                                  case *# [2# y2_s43Ui] of sat_s43Un {
                                                    __DEFAULT ->
                                                        case *# [4# y1_s43Ug] of sat_s43Ul {
                                                          __DEFAULT ->
                                                              case *# [8# y_s43Ue] of sat_s43Uk {
                                                                __DEFAULT ->
                                                                    case
                                                                        +# [sat_s43Uk sat_s43Ul]
                                                                    of
                                                                    sat_s43Um
                                                                    { __DEFAULT ->
                                                                          case
                                                                              +# [sat_s43Um
                                                                                  sat_s43Un]
                                                                          of
                                                                          ww_s43Uj [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    <# [ww_s43Uj 0#]
                                                                                of
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          quotRemInt# [ww_s43Uj
                                                                                                       16#]
                                                                                      of
                                                                                      { (#,#) ipv_s43Uq [Occ=Once]
                                                                                              ipv1_s43Ur [Occ=Once] ->
                                                                                            let {
                                                                                              sat_s43Us [Occ=Once]
                                                                                                :: GHC.Types.Int
                                                                                              [LclId] =
                                                                                                  CCCS GHC.Types.I#! [ipv1_s43Ur];
                                                                                            } in 
                                                                                              $wshowIt2_r43OZ
                                                                                                  ipv_s43Uq
                                                                                                  sat_s43Us
                                                                                                  GHC.Types.[];
                                                                                      };
                                                                                  1# ->
                                                                                      Numeric.$wlvl
                                                                                          ww_s43Uj;
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                            : d_s43Ut [Occ=Once!] r_s43Uu [Occ=Once] ->
                                case a_s43TK of {
                                  GHC.Types.I# y_s43Uw [Occ=Once] ->
                                      case b_s43TV of {
                                        GHC.Types.I# y1_s43Uy [Occ=Once] ->
                                            case c_s43Ua of {
                                              GHC.Types.I# y2_s43UA [Occ=Once] ->
                                                  case d_s43Ut of {
                                                    GHC.Types.I# y3_s43UC [Occ=Once] ->
                                                        case *# [2# y2_s43UA] of sat_s43UH {
                                                          __DEFAULT ->
                                                              case *# [4# y1_s43Uy] of sat_s43UF {
                                                                __DEFAULT ->
                                                                    case
                                                                        *# [8# y_s43Uw]
                                                                    of
                                                                    sat_s43UE
                                                                    { __DEFAULT ->
                                                                          case
                                                                              +# [sat_s43UE
                                                                                  sat_s43UF]
                                                                          of
                                                                          sat_s43UG
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    +# [sat_s43UG
                                                                                        sat_s43UH]
                                                                                of
                                                                                sat_s43UI
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          +# [sat_s43UI
                                                                                              y3_s43UC]
                                                                                      of
                                                                                      ww_s43UD [Dmd=<S,U>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                <# [ww_s43UD
                                                                                                    0#]
                                                                                            of
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      quotRemInt# [ww_s43UD
                                                                                                                   16#]
                                                                                                  of
                                                                                                  { (#,#) ipv_s43UL [Occ=Once]
                                                                                                          ipv1_s43UM [Occ=Once] ->
                                                                                                        let {
                                                                                                          sat_s43UO [Occ=Once]
                                                                                                            :: [GHC.Types.Char]
                                                                                                          [LclId] =
                                                                                                              [r_s43Uu] \u []
                                                                                                                  Numeric.showHFloat_hex
                                                                                                                      r_s43Uu; } in
                                                                                                        let {
                                                                                                          sat_s43UN [Occ=Once]
                                                                                                            :: GHC.Types.Int
                                                                                                          [LclId] =
                                                                                                              CCCS GHC.Types.I#! [ipv1_s43UM];
                                                                                                        } in 
                                                                                                          $wshowIt1_r43OY
                                                                                                              ipv_s43UL
                                                                                                              sat_s43UN
                                                                                                              sat_s43UO;
                                                                                                  };
                                                                                              1# ->
                                                                                                  Numeric.$wlvl
                                                                                                      ww_s43UD;
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

sat_s43UP :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

sat_s43UQ :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s43UP GHC.Types.[]];

Numeric.showHFloat15 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s43UQ;

Numeric.showHFloat10 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "0x0p+0"#;

Numeric.showHFloat9 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.showHFloat10;

Numeric.showHFloat14 :: GHC.Prim.Int# -> [GHC.Types.Char]
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [ww_s43UR] $wlvl2_r43OX GHC.Types.[] ww_s43UR;

Numeric.showHFloat13 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "0x"#;

Numeric.showHFloat12 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "p"#;

Numeric.showHFloat11 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "."#;

Numeric.showHFloat_cvt
  :: forall a. GHC.Float.RealFloat a => a -> [GHC.Types.Char]
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s43US eta_s43UT]
        case
            GHC.Float.$p1RealFloat $dRealFloat_s43US
        of
        $dRealFrac_s43UU [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_s43UU
              of
              $dReal_s43UV [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    let {
                      sat_s43UZ [Occ=Once] :: a_a42SJ
                      [LclId] =
                          [$dReal_s43UV] \u []
                              case GHC.Real.$p1Real $dReal_s43UV of sat_s43UY {
                                __DEFAULT -> GHC.Num.fromInteger sat_s43UY Numeric.showHFloat16;
                              };
                    } in 
                      case GHC.Real.$p2Real $dReal_s43UV of sat_s43UW {
                        __DEFAULT ->
                            case GHC.Classes.$p1Ord sat_s43UW of sat_s43UX {
                              __DEFAULT ->
                                  case GHC.Classes.== sat_s43UX eta_s43UT sat_s43UZ of {
                                    GHC.Types.False ->
                                        case
                                            GHC.Float.$wfloatToDigits
                                                $dRealFloat_s43US Numeric.showHFloat15 eta_s43UT
                                        of
                                        { (#,#) ww1_s43V2 [Occ=Once!] ww2_s43V3 [Occ=Once*!] ->
                                              case ww1_s43V2 of {
                                                [] ->
                                                    case ww2_s43V3 of {
                                                      GHC.Types.I# ww5_s43V6 [Occ=Once] ->
                                                          Numeric.showHFloat14 ww5_s43V6;
                                                    };
                                                : d_s43V7 [Occ=Once!] ds_s43V8 ->
                                                    let {
                                                      sat_s43Vr [Occ=Once] :: [GHC.Types.Char]
                                                      [LclId] =
                                                          [ww2_s43V3 d_s43V7 ds_s43V8] \u []
                                                              case d_s43V7 of {
                                                                GHC.Types.I# ww3_s43Va [Occ=Once] ->
                                                                    case
                                                                        GHC.Show.$wshowSignedInt
                                                                            0#
                                                                            ww3_s43Va
                                                                            GHC.Types.[]
                                                                    of
                                                                    { (#,#) ww6_s43Vc [Occ=Once]
                                                                            ww7_s43Vd [Occ=Once] ->
                                                                          let {
                                                                            sat_s43Vq [Occ=Once,
                                                                                       Dmd=<L,1*U>]
                                                                              :: [GHC.Types.Char]
                                                                            [LclId] =
                                                                                [ww2_s43V3
                                                                                 ds_s43V8] \s []
                                                                                    let {
                                                                                      n_s43Vf [Occ=Once*,
                                                                                               Dmd=<L,1*U>]
                                                                                        :: [GHC.Types.Char]
                                                                                      [LclId] =
                                                                                          [ww2_s43V3] \s []
                                                                                              let {
                                                                                                sat_s43Vm [Occ=Once]
                                                                                                  :: [GHC.Types.Char]
                                                                                                [LclId] =
                                                                                                    [ww2_s43V3] \u []
                                                                                                        case
                                                                                                            ww2_s43V3
                                                                                                        of
                                                                                                        { GHC.Types.I# x_s43Vh [Occ=Once] ->
                                                                                                              case
                                                                                                                  -# [x_s43Vh
                                                                                                                      1#]
                                                                                                              of
                                                                                                              sat_s43Vi
                                                                                                              { __DEFAULT ->
                                                                                                                    case
                                                                                                                        GHC.Show.$wshowSignedInt
                                                                                                                            0#
                                                                                                                            sat_s43Vi
                                                                                                                            GHC.Types.[]
                                                                                                                    of
                                                                                                                    { (#,#) ww9_s43Vk [Occ=Once]
                                                                                                                            ww10_s43Vl [Occ=Once] ->
                                                                                                                          : [ww9_s43Vk
                                                                                                                             ww10_s43Vl];
                                                                                                                    };
                                                                                                              };
                                                                                                        };
                                                                                              } in 
                                                                                                GHC.CString.unpackAppendCString#
                                                                                                    Numeric.showHFloat12
                                                                                                    sat_s43Vm;
                                                                                    } in 
                                                                                      case
                                                                                          Numeric.showHFloat_allZ
                                                                                              ds_s43V8
                                                                                      of
                                                                                      { GHC.Types.False ->
                                                                                            let {
                                                                                              sat_s43Vp [Occ=Once]
                                                                                                :: [GHC.Types.Char]
                                                                                              [LclId] =
                                                                                                  [ds_s43V8
                                                                                                   n_s43Vf] \u []
                                                                                                      case
                                                                                                          Numeric.showHFloat_hex
                                                                                                              ds_s43V8
                                                                                                      of
                                                                                                      sat_s43Vo
                                                                                                      { __DEFAULT ->
                                                                                                            GHC.Base.++
                                                                                                                sat_s43Vo
                                                                                                                n_s43Vf;
                                                                                                      };
                                                                                            } in 
                                                                                              GHC.CString.unpackAppendCString#
                                                                                                  Numeric.showHFloat11
                                                                                                  sat_s43Vp;
                                                                                        GHC.Types.True ->
                                                                                            n_s43Vf;
                                                                                      }; } in
                                                                          let {
                                                                            sat_s43Ve [Occ=Once]
                                                                              :: [GHC.Types.Char]
                                                                            [LclId] =
                                                                                CCCS :! [ww6_s43Vc
                                                                                         ww7_s43Vd];
                                                                          } in 
                                                                            GHC.Base.++
                                                                                sat_s43Ve sat_s43Vq;
                                                                    };
                                                              };
                                                    } in 
                                                      GHC.CString.unpackAppendCString#
                                                          Numeric.showHFloat13 sat_s43Vr;
                                              };
                                        };
                                    GHC.Types.True -> Numeric.showHFloat9;
                                  };
                            };
                      };
              };
        };

Numeric.showHFloat8 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! ['-'#];

Numeric.showHFloat5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Infinity"#;

Numeric.showHFloat7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "-"#;

Numeric.showHFloat6 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.showHFloat7;

Numeric.showHFloat2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NaN"#;

Numeric.showHFloat1 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.showHFloat2;

Numeric.showHFloat4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.showHFloat5;

Numeric.showHFloat3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.Base.++ Numeric.showHFloat6 Numeric.showHFloat4;

Numeric.showHFloat
  :: forall a. GHC.Float.RealFloat a => a -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Str=<L,U(U(U(U(A,A,A,1*C1(U),A,A,C(U)),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,1*C1(U),1*C1(U),A,1*C1(U),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s43Vs eta_s43Vt]
        let {
          sat_s43VK [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s43Vs eta_s43Vt] \u []
                  case GHC.Float.isNaN $dRealFloat_s43Vs eta_s43Vt of {
                    GHC.Types.False ->
                        case
                            GHC.Float.$p1RealFloat $dRealFloat_s43Vs
                        of
                        $dRealFrac_s43Vv [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),1*U(1*U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A)>]
                        { __DEFAULT ->
                              case
                                  GHC.Real.$p1RealFrac $dRealFrac_s43Vv
                              of
                              $dReal_s43Vw [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
                              { __DEFAULT ->
                                    let {
                                      $dNum_s43Vx [Dmd=<L,U(A,A,A,1*C1(U),A,A,1*C1(U))>]
                                        :: GHC.Num.Num a_a42Pu
                                      [LclId] =
                                          [$dReal_s43Vw] \u [] GHC.Real.$p1Real $dReal_s43Vw;
                                    } in 
                                      case GHC.Float.isInfinite $dRealFloat_s43Vs eta_s43Vt of {
                                        GHC.Types.False ->
                                            let {
                                              sat_s43VA [Occ=Once] :: a_a42Pu
                                              [LclId] =
                                                  [$dNum_s43Vx] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s43Vx Numeric.showHFloat16;
                                            } in 
                                              case GHC.Real.$p2Real $dReal_s43Vw of sat_s43Vz {
                                                __DEFAULT ->
                                                    case
                                                        GHC.Classes.< sat_s43Vz eta_s43Vt sat_s43VA
                                                    of
                                                    { GHC.Types.False ->
                                                          case
                                                              GHC.Float.isNegativeZero
                                                                  $dRealFloat_s43Vs eta_s43Vt
                                                          of
                                                          { GHC.Types.False ->
                                                                Numeric.showHFloat_cvt
                                                                    $dRealFloat_s43Vs eta_s43Vt;
                                                            GHC.Types.True ->
                                                                let {
                                                                  sat_s43VE [Occ=Once]
                                                                    :: [GHC.Types.Char]
                                                                  [LclId] =
                                                                      [$dRealFloat_s43Vs
                                                                       eta_s43Vt
                                                                       $dNum_s43Vx] \u []
                                                                          let {
                                                                            sat_s43VD [Occ=Once]
                                                                              :: a_a42Pu
                                                                            [LclId] =
                                                                                [eta_s43Vt
                                                                                 $dNum_s43Vx] \u []
                                                                                    GHC.Num.negate
                                                                                        $dNum_s43Vx
                                                                                        eta_s43Vt;
                                                                          } in 
                                                                            Numeric.showHFloat_cvt
                                                                                $dRealFloat_s43Vs
                                                                                sat_s43VD;
                                                                } in 
                                                                  : [Numeric.showHFloat8 sat_s43VE];
                                                          };
                                                      GHC.Types.True ->
                                                          let {
                                                            sat_s43VG [Occ=Once] :: [GHC.Types.Char]
                                                            [LclId] =
                                                                [$dRealFloat_s43Vs
                                                                 eta_s43Vt
                                                                 $dNum_s43Vx] \u []
                                                                    let {
                                                                      sat_s43VF [Occ=Once]
                                                                        :: a_a42Pu
                                                                      [LclId] =
                                                                          [eta_s43Vt
                                                                           $dNum_s43Vx] \u []
                                                                              GHC.Num.negate
                                                                                  $dNum_s43Vx
                                                                                  eta_s43Vt;
                                                                    } in 
                                                                      Numeric.showHFloat_cvt
                                                                          $dRealFloat_s43Vs
                                                                          sat_s43VF;
                                                          } in  : [Numeric.showHFloat8 sat_s43VG];
                                                    };
                                              };
                                        GHC.Types.True ->
                                            let {
                                              sat_s43VI [Occ=Once] :: a_a42Pu
                                              [LclId] =
                                                  [$dNum_s43Vx] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s43Vx Numeric.showHFloat16;
                                            } in 
                                              case GHC.Real.$p2Real $dReal_s43Vw of sat_s43VH {
                                                __DEFAULT ->
                                                    case
                                                        GHC.Classes.< sat_s43VH eta_s43Vt sat_s43VI
                                                    of
                                                    { GHC.Types.False -> Numeric.showHFloat4;
                                                      GHC.Types.True -> Numeric.showHFloat3;
                                                    };
                                              };
                                      };
                              };
                        };
                    GHC.Types.True -> Numeric.showHFloat1;
                  };
        } in  GHC.Base.++ sat_s43VK;

sat_s43VL :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [8#];

sat_s43VM :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s43VL GHC.Types.[]];

Numeric.showOct1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s43VM;

Numeric.showOct
  :: forall a.
     (GHC.Real.Integral a, GHC.Show.Show a) =>
     a -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(U,U))),A,C(U))><L,U(A,C(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s43VN $dShow_s43VO]
        let {
          sat_s43VR [Occ=Once] :: a_a42Pk
          [LclId] =
              [$dIntegral_s43VN] \u []
                  case GHC.Real.$p1Integral $dIntegral_s43VN of sat_s43VP {
                    __DEFAULT ->
                        case GHC.Real.$p1Real sat_s43VP of sat_s43VQ {
                          __DEFAULT -> GHC.Num.fromInteger sat_s43VQ Numeric.showOct1;
                        };
                  };
        } in 
          Numeric.showIntAtBase
              $dIntegral_s43VN $dShow_s43VO sat_s43VR GHC.Show.intToDigit;

Numeric.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Numeric.$trModule4];

Numeric.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Numeric.$trModule2];

Numeric.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Numeric.$trModule3
                                     Numeric.$trModule1];

Numeric.showGFloat_$sshowGFloat
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Float -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s43VS x_s43VT]
        let {
          sat_s43VW [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s43VS x_s43VT] \u []
                  case x_s43VT of {
                    GHC.Types.F# ww1_s43VV [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt1
                            GHC.Float.FFGeneric d_s43VS GHC.Types.False ww1_s43VV;
                  };
        } in  GHC.Base.++ sat_s43VW;

Numeric.showFFloat_$sshowFFloat
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Float -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s43VX x_s43VY]
        let {
          sat_s43W1 [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s43VX x_s43VY] \u []
                  case x_s43VY of {
                    GHC.Types.F# ww1_s43W0 [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt1
                            GHC.Float.FFFixed d_s43VX GHC.Types.False ww1_s43W0;
                  };
        } in  GHC.Base.++ sat_s43W1;

Numeric.showEFloat_$sshowEFloat
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Float -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s43W2 x_s43W3]
        let {
          sat_s43W6 [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s43W2 x_s43W3] \u []
                  case x_s43W3 of {
                    GHC.Types.F# ww1_s43W5 [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt1
                            GHC.Float.FFExponent d_s43W2 GHC.Types.False ww1_s43W5;
                  };
        } in  GHC.Base.++ sat_s43W6;

Numeric.showGFloat_$sshowGFloat1
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Double -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s43W7 x_s43W8]
        let {
          sat_s43Wb [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s43W7 x_s43W8] \u []
                  case x_s43W8 of {
                    GHC.Types.D# ww1_s43Wa [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt
                            GHC.Float.FFGeneric d_s43W7 GHC.Types.False ww1_s43Wa;
                  };
        } in  GHC.Base.++ sat_s43Wb;

Numeric.showGFloat
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Base.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s43Wc d_s43Wd x_s43We]
        let {
          sat_s43Wf [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s43Wc d_s43Wd x_s43We] \u []
                  GHC.Float.formatRealFloatAlt
                      $dRealFloat_s43Wc
                      GHC.Float.FFGeneric
                      d_s43Wd
                      GHC.Types.False
                      x_s43We;
        } in  GHC.Base.++ sat_s43Wf;

Numeric.showFFloat_$sshowFFloat1
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Double -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s43Wg x_s43Wh]
        let {
          sat_s43Wk [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s43Wg x_s43Wh] \u []
                  case x_s43Wh of {
                    GHC.Types.D# ww1_s43Wj [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt
                            GHC.Float.FFFixed d_s43Wg GHC.Types.False ww1_s43Wj;
                  };
        } in  GHC.Base.++ sat_s43Wk;

Numeric.showFFloat
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Base.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s43Wl d_s43Wm x_s43Wn]
        let {
          sat_s43Wo [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s43Wl d_s43Wm x_s43Wn] \u []
                  GHC.Float.formatRealFloatAlt
                      $dRealFloat_s43Wl
                      GHC.Float.FFFixed
                      d_s43Wm
                      GHC.Types.False
                      x_s43Wn;
        } in  GHC.Base.++ sat_s43Wo;

Numeric.showEFloat_$sshowEFloat1
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Double -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s43Wp x_s43Wq]
        let {
          sat_s43Wt [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s43Wp x_s43Wq] \u []
                  case x_s43Wq of {
                    GHC.Types.D# ww1_s43Ws [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt
                            GHC.Float.FFExponent d_s43Wp GHC.Types.False ww1_s43Ws;
                  };
        } in  GHC.Base.++ sat_s43Wt;

Numeric.showEFloat
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Base.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s43Wu d_s43Wv x_s43Ww]
        let {
          sat_s43Wx [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s43Wu d_s43Wv x_s43Ww] \u []
                  GHC.Float.formatRealFloatAlt
                      $dRealFloat_s43Wu
                      GHC.Float.FFExponent
                      d_s43Wv
                      GHC.Types.False
                      x_s43Ww;
        } in  GHC.Base.++ sat_s43Wx;


==================== STG syntax: ====================
2018-03-16 15:58:55.974073382 UTC

Numeric.readInt
  :: forall a.
     GHC.Num.Num a =>
     a
     -> (GHC.Types.Char -> GHC.Types.Bool)
     -> (GHC.Types.Char -> GHC.Types.Int)
     -> Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=4,
 Str=<L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))><L,U><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_s43P3 base_s43P4 isDigit_s43P5 valDigit_s43P6]
        let {
          sat_s43P9 [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42Zn
          [LclId] =
              [$dNum_s43P3 base_s43P4 isDigit_s43P5 valDigit_s43P6] \u []
                  case
                      Text.Read.Lex.$wreadIntP
                          $dNum_s43P3
                          base_s43P4
                          isDigit_s43P5
                          valDigit_s43P6
                          Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                  of
                  { Unit# ww1_s43P8 [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Get [ww1_s43P8];
                  };
        } in  Text.ParserCombinators.ReadP.run sat_s43P9;

Numeric.readOct
  :: forall a.
     (GHC.Classes.Eq a, GHC.Num.Num a) =>
     Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=2,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dEq_s43Pa $dNum_s43Pb]
        let {
          sat_s43Pf [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42Ze
          [LclId] =
              [$dEq_s43Pa $dNum_s43Pb] \u []
                  let {
                    sat_s43Pc [Occ=Once] :: a_a42Ze
                    [LclId] =
                        [$dNum_s43Pb] \u []
                            GHC.Num.fromInteger $dNum_s43Pb Text.Read.Lex.readDecP4;
                  } in 
                    case
                        Text.Read.Lex.$wreadIntP'
                            $dEq_s43Pa
                            $dNum_s43Pb
                            sat_s43Pc
                            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                    of
                    { Unit# ww1_s43Pe [Occ=Once] ->
                          Text.ParserCombinators.ReadP.Get [ww1_s43Pe];
                    };
        } in  Text.ParserCombinators.ReadP.run sat_s43Pf;

Numeric.readDec
  :: forall a.
     (GHC.Classes.Eq a, GHC.Num.Num a) =>
     Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=2,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dEq_s43Pg $dNum_s43Ph]
        let {
          sat_s43Pl [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42Z5
          [LclId] =
              [$dEq_s43Pg $dNum_s43Ph] \u []
                  let {
                    sat_s43Pi [Occ=Once] :: a_a42Z5
                    [LclId] =
                        [$dNum_s43Ph] \u []
                            GHC.Num.fromInteger $dNum_s43Ph Text.Read.Lex.numberToFixed1;
                  } in 
                    case
                        Text.Read.Lex.$wreadIntP'
                            $dEq_s43Pg
                            $dNum_s43Ph
                            sat_s43Pi
                            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                    of
                    { Unit# ww1_s43Pk [Occ=Once] ->
                          Text.ParserCombinators.ReadP.Get [ww1_s43Pk];
                    };
        } in  Text.ParserCombinators.ReadP.run sat_s43Pl;

Numeric.readHex
  :: forall a.
     (GHC.Classes.Eq a, GHC.Num.Num a) =>
     Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=2,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dEq_s43Pm $dNum_s43Pn]
        let {
          sat_s43Pr [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42YW
          [LclId] =
              [$dEq_s43Pm $dNum_s43Pn] \u []
                  let {
                    sat_s43Po [Occ=Once] :: a_a42YW
                    [LclId] =
                        [$dNum_s43Pn] \u []
                            GHC.Num.fromInteger $dNum_s43Pn Text.Read.Lex.readDecP3;
                  } in 
                    case
                        Text.Read.Lex.$wreadIntP'
                            $dEq_s43Pm
                            $dNum_s43Pn
                            sat_s43Po
                            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                    of
                    { Unit# ww1_s43Pq [Occ=Once] ->
                          Text.ParserCombinators.ReadP.Get [ww1_s43Pq];
                    };
        } in  Text.ParserCombinators.ReadP.run sat_s43Pr;

Numeric.readFloat2
  :: forall a. GHC.Base.String -> Text.ParserCombinators.ReadP.P a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [a3_s43Ps]
        case a3_s43Ps of {
          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
        };

Numeric.readFloat1 :: forall a. Text.ParserCombinators.ReadP.P a
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE Text.ParserCombinators.ReadP.Look! [Numeric.readFloat2];

Numeric.readFloat
  :: forall a.
     GHC.Real.RealFrac a =>
     Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=1,
 Str=<L,1*U(A,1*U(A,A,A,C(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_s43Pu]
        let {
          lvl116_s43Pv [Occ=OnceL] :: Text.ParserCombinators.ReadP.P a_a42YP
          [LclId] =
              [$dRealFrac_s43Pu] \u []
                  let {
                    sat_s43PG [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42YP
                    [LclId] =
                        [$dRealFrac_s43Pu] \u []
                            let {
                              $dFractional_s43Pw [Occ=OnceL, Dmd=<L,U(A,A,A,C(U))>]
                                :: GHC.Real.Fractional a_a42YP
                              [LclId] =
                                  [$dRealFrac_s43Pu] \u []
                                      GHC.Real.$p2RealFrac $dRealFrac_s43Pu; } in
                            let {
                              sat_s43PF [Occ=Once]
                                :: Text.Read.Lex.Lexeme -> Text.ParserCombinators.ReadP.P a_a42YP
                              [LclId] =
                                  [$dFractional_s43Pw] \r [a1_s43Px]
                                      case a1_s43Px of {
                                        __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                        Text.Read.Lex.Number n_s43Pz [Occ=Once] ->
                                            let {
                                              sat_s43PE [Occ=Once] :: a_a42YP
                                              [LclId] =
                                                  [$dFractional_s43Pw n_s43Pz] \u []
                                                      let {
                                                        sat_s43PD [Occ=Once] :: GHC.Real.Rational
                                                        [LclId] =
                                                            [n_s43Pz] \u []
                                                                case
                                                                    Text.Read.Lex.$wnumberToRational
                                                                        n_s43Pz
                                                                of
                                                                { (#,#) ww1_s43PB [Occ=Once]
                                                                        ww2_s43PC [Occ=Once] ->
                                                                      GHC.Real.:% [ww1_s43PB
                                                                                   ww2_s43PC];
                                                                };
                                                      } in 
                                                        GHC.Real.fromRational
                                                            $dFractional_s43Pw sat_s43PD;
                                            } in 
                                              Text.ParserCombinators.ReadP.Result [sat_s43PE
                                                                                   Text.ParserCombinators.ReadP.Fail];
                                      };
                            } in  Text.Read.Lex.expect2 sat_s43PF;
                  } in 
                    Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                        Numeric.readFloat1 sat_s43PG; } in
        let {
          k_s43PH [Occ=OnceL, Dmd=<L,C(U)>]
            :: () -> Text.ParserCombinators.ReadP.P a_a42YP
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl116_s43Pv] \r [a3_s43PI] lvl116_s43Pv; } in
        let {
          sat_s43PK [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P a_a42YP
          [LclId] =
              [k_s43PH] \r [a1_s43PJ]
                  Text.ParserCombinators.ReadP.skipSpaces2 a1_s43PJ k_s43PH; } in
        let {
          sat_s43PL [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42YP
          [LclId] =
              CCCS Text.ParserCombinators.ReadP.Look! [sat_s43PK];
        } in  Text.ParserCombinators.ReadP.run sat_s43PL;

Numeric.readSigned
  :: forall a.
     GHC.Real.Real a =>
     Text.ParserCombinators.ReadP.ReadS a
     -> Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=3,
 Str=<L,1*U(1*U(A,A,A,C(U),A,A,A),A,A)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dReal_s43PM eta_s43PN eta1_s43PO]
        let {
          $dNum_s43PP [Occ=OnceL, Dmd=<L,U(A,A,A,C(U),A,A,A)>]
            :: GHC.Num.Num a_a42Xv
          [LclId] =
              [$dReal_s43PM] \u [] GHC.Real.$p1Real $dReal_s43PM; } in
        let {
          go_s43PQ [Occ=LoopBreaker]
            :: [(GHC.Base.String, GHC.Base.String)]
               -> [(a_a42Xv, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [eta_s43PN go_s43PQ] \r [ds_s43PR]
                  case ds_s43PR of {
                    [] -> [] [];
                    : y_s43PT [Occ=Once!] ys_s43PU [Occ=Once] ->
                        case y_s43PT of {
                          (,) str_s43PW [Occ=Once] s_s43PX [Occ=OnceL] ->
                              let {
                                z_s43PY [Occ=OnceL] :: [(a_a42Xv, GHC.Base.String)]
                                [LclId] =
                                    [go_s43PQ ys_s43PU] \u [] go_s43PQ ys_s43PU; } in
                              let {
                                go1_s43PZ [Occ=LoopBreaker]
                                  :: [(a_a42Xv, GHC.Base.String)] -> [(a_a42Xv, GHC.Base.String)]
                                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                    sat-only [s_s43PX z_s43PY go1_s43PZ] \r [ds1_s43Q0]
                                        case ds1_s43Q0 of {
                                          [] -> z_s43PY;
                                          : y1_s43Q2 [Occ=Once!] ys1_s43Q3 [Occ=Once*] ->
                                              case y1_s43Q2 of {
                                                (,) n_s43Q5 [Occ=Once] ds2_s43Q6 [Occ=Once!] ->
                                                    case ds2_s43Q6 of {
                                                      [] ->
                                                          let {
                                                            sat_s43Q9 [Occ=Once]
                                                              :: [(a_a42Xv, GHC.Base.String)]
                                                            [LclId] =
                                                                [go1_s43PZ ys1_s43Q3] \u []
                                                                    go1_s43PZ ys1_s43Q3; } in
                                                          let {
                                                            sat_s43Q8 [Occ=Once]
                                                              :: (a_a42Xv, GHC.Base.String)
                                                            [LclId] =
                                                                CCCS (,)! [n_s43Q5 s_s43PX];
                                                          } in  : [sat_s43Q8 sat_s43Q9];
                                                      : _ [Occ=Dead] _ [Occ=Dead] ->
                                                          go1_s43PZ ys1_s43Q3;
                                                    };
                                              };
                                        };
                              } in 
                                case eta_s43PN str_s43PW of sat_s43Qc {
                                  __DEFAULT -> go1_s43PZ sat_s43Qc;
                                };
                        };
                  }; } in
        let {
          go1_s43Qd [Occ=LoopBreaker]
            :: [(GHC.Base.String, GHC.Base.String)]
               -> [(a_a42Xv, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dNum_s43PP go_s43PQ go1_s43Qd] \r [ds_s43Qe]
                  case ds_s43Qe of {
                    [] -> [] [];
                    : y_s43Qg [Occ=Once!] ys_s43Qh [Occ=Once*] ->
                        case y_s43Qg of {
                          (,) ds1_s43Qj [Occ=Once!] s_s43Qk [Occ=Once] ->
                              case ds1_s43Qj of {
                                [] -> go1_s43Qd ys_s43Qh;
                                : ds2_s43Qm [Occ=Once!] ds3_s43Qn [Occ=Once!] ->
                                    case ds2_s43Qm of {
                                      GHC.Types.C# ds4_s43Qp [Occ=Once!] ->
                                          case ds4_s43Qp of {
                                            __DEFAULT -> go1_s43Qd ys_s43Qh;
                                            '-'# ->
                                                case ds3_s43Qn of {
                                                  [] ->
                                                      let {
                                                        z_s43Qs [Occ=OnceL]
                                                          :: [(a_a42Xv, GHC.Base.String)]
                                                        [LclId] =
                                                            [go1_s43Qd ys_s43Qh] \u []
                                                                go1_s43Qd ys_s43Qh; } in
                                                      let {
                                                        go2_s43Qt [Occ=LoopBreaker]
                                                          :: [(a_a42Xv, GHC.Base.String)]
                                                             -> [(a_a42Xv, GHC.Base.String)]
                                                        [LclId,
                                                         Arity=1,
                                                         Str=<S,1*U>,
                                                         Unf=OtherCon []] =
                                                            sat-only [$dNum_s43PP
                                                                      z_s43Qs
                                                                      go2_s43Qt] \r [ds6_s43Qu]
                                                                case ds6_s43Qu of {
                                                                  [] -> z_s43Qs;
                                                                  : y1_s43Qw [Occ=Once!]
                                                                    ys1_s43Qx [Occ=Once] ->
                                                                      case y1_s43Qw of {
                                                                        (,) x_s43Qz [Occ=Once]
                                                                            t_s43QA [Occ=Once] ->
                                                                            let {
                                                                              sat_s43QD [Occ=Once]
                                                                                :: [(a_a42Xv,
                                                                                     GHC.Base.String)]
                                                                              [LclId] =
                                                                                  [go2_s43Qt
                                                                                   ys1_s43Qx] \u []
                                                                                      go2_s43Qt
                                                                                          ys1_s43Qx; } in
                                                                            let {
                                                                              sat_s43QB [Occ=Once]
                                                                                :: a_a42Xv
                                                                              [LclId] =
                                                                                  [$dNum_s43PP
                                                                                   x_s43Qz] \u []
                                                                                      GHC.Num.negate
                                                                                          $dNum_s43PP
                                                                                          x_s43Qz; } in
                                                                            let {
                                                                              sat_s43QC [Occ=Once]
                                                                                :: (a_a42Xv,
                                                                                    GHC.Base.String)
                                                                              [LclId] =
                                                                                  CCCS (,)! [sat_s43QB
                                                                                             t_s43QA];
                                                                            } in 
                                                                              : [sat_s43QC
                                                                                 sat_s43QD];
                                                                      };
                                                                };
                                                      } in 
                                                        case
                                                            Text.ParserCombinators.ReadP.run
                                                                GHC.Read.lex1 s_s43Qk
                                                        of
                                                        sat_s43QE
                                                        { __DEFAULT ->
                                                              case go_s43PQ sat_s43QE of sat_s43QF {
                                                                __DEFAULT -> go2_s43Qt sat_s43QF;
                                                              };
                                                        };
                                                  : _ [Occ=Dead] _ [Occ=Dead] -> go1_s43Qd ys_s43Qh;
                                                };
                                          };
                                    };
                              };
                        };
                  }; } in
        let {
          sat_s43QN [Occ=Once] :: Text.ParserCombinators.ReadP.ReadS a_a42Xv
          [LclId] =
              [go_s43PQ go1_s43Qd] \r [r_s43QI]
                  let {
                    sat_s43QM [Occ=Once, Dmd=<L,1*U>] :: [(a_a42Xv, GHC.Base.String)]
                    [LclId] =
                        [go1_s43Qd r_s43QI] \s []
                            case
                                Text.ParserCombinators.ReadP.run GHC.Read.lex1 r_s43QI
                            of
                            sat_s43QL
                            { __DEFAULT -> go1_s43Qd sat_s43QL;
                            };
                  } in 
                    case
                        Text.ParserCombinators.ReadP.run GHC.Read.lex1 r_s43QI
                    of
                    sat_s43QJ
                    { __DEFAULT ->
                          case go_s43PQ sat_s43QJ of sat_s43QK {
                            __DEFAULT -> GHC.Base.++ sat_s43QK sat_s43QM;
                          };
                    };
        } in  GHC.Read.readParen GHC.Types.False sat_s43QN eta1_s43PO;

sat_s43QO :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [10#];

sat_s43QP :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s43QO GHC.Types.[]];

Numeric.showInt2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s43QP;

lvl_r43OH :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Numeric.showInt: can't show negative numbers"#;

Numeric.showInt1 :: GHC.Base.String
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_r43OH of sat_s43QQ {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s43QQ;
        };

Numeric.showHFloat16 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Numeric.showInt
  :: forall a. GHC.Real.Integral a => a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLLLC(S)),U(1*U(U(A,A,A,A,A,A,C(U)),U(A,A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s43QR eta_s43QS eta1_s43QT]
        case
            GHC.Real.$p1Integral $dIntegral_s43QR
        of
        $dReal_s43QU [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(U(A,A,A,A,A,A,C(U)),U(A,A,C(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s43QX [Occ=Once] :: a_a42W2
                [LclId] =
                    [$dReal_s43QU] \u []
                        case GHC.Real.$p1Real $dReal_s43QU of sat_s43QW {
                          __DEFAULT -> GHC.Num.fromInteger sat_s43QW Numeric.showHFloat16;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s43QU of sat_s43QV {
                  __DEFAULT ->
                      case GHC.Classes.< sat_s43QV eta_s43QS sat_s43QX of {
                        GHC.Types.False ->
                            let {
                              lvl5_s43QZ :: a_a42W2
                              [LclId] =
                                  [$dReal_s43QU] \u []
                                      case GHC.Real.$p1Real $dReal_s43QU of sat_s43R0 {
                                        __DEFAULT -> GHC.Num.fromInteger sat_s43R0 Numeric.showInt2;
                                      };
                            } in 
                              case
                                  GHC.Real.$p2Real $dReal_s43QU
                              of
                              $dOrd_s43R1 [Dmd=<S(LLC(C(S))LLLLL),U(A,A,C(C1(U)),A,A,A,A,A)>]
                              { __DEFAULT ->
                                    let-no-escape {
                                      exit_s43R2 [Occ=OnceL!T[2], Dmd=<C(C(S)),C(C1(U))>]
                                        :: a_a42W2 -> [GHC.Types.Char] -> GHC.Base.String
                                      [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                          sat-only [$dIntegral_s43QR] \r [n_s43R3 cs_s43R4]
                                              case
                                                  GHC.Real.toInteger $dIntegral_s43QR n_s43R3
                                              of
                                              sat_s43R5
                                              { __DEFAULT ->
                                                    case
                                                        GHC.Integer.Type.integerToInt sat_s43R5
                                                    of
                                                    wild1_s43R6
                                                    { __DEFAULT ->
                                                          case +# [48# wild1_s43R6] of sat_s43R7 {
                                                            __DEFAULT ->
                                                                case chr# [sat_s43R7] of sat_s43R8 {
                                                                  __DEFAULT ->
                                                                      let {
                                                                        sat_s43R9 [Occ=Once]
                                                                          :: GHC.Types.Char
                                                                        [LclId] =
                                                                            CCCS GHC.Types.C#! [sat_s43R8];
                                                                      } in  : [sat_s43R9 cs_s43R4];
                                                                };
                                                          };
                                                    };
                                              };
                                    } in 
                                      let-no-escape {
                                        go_s43Ra [Occ=LoopBreakerT[2]]
                                          :: a_a42W2 -> [GHC.Types.Char] -> GHC.Base.String
                                        [LclId[JoinId(2)],
                                         Arity=2,
                                         Str=<L,U><L,U>,
                                         Unf=OtherCon []] =
                                            sat-only [$dIntegral_s43QR
                                                      lvl5_s43QZ
                                                      $dOrd_s43R1
                                                      exit_s43R2
                                                      go_s43Ra] \r [n_s43Rb cs_s43Rc]
                                                case
                                                    GHC.Classes.< $dOrd_s43R1 n_s43Rb lvl5_s43QZ
                                                of
                                                { GHC.Types.False ->
                                                      let {
                                                        ds_s43Re [Dmd=<L,U(1*U,1*U)>]
                                                          :: (a_a42W2, a_a42W2)
                                                        [LclId] =
                                                            [$dIntegral_s43QR
                                                             lvl5_s43QZ
                                                             n_s43Rb] \u []
                                                                GHC.Real.quotRem
                                                                    $dIntegral_s43QR
                                                                    n_s43Rb
                                                                    lvl5_s43QZ; } in
                                                      let {
                                                        sat_s43Ri [Occ=Once] :: a_a42W2
                                                        [LclId] =
                                                            [ds_s43Re] \u []
                                                                case ds_s43Re of {
                                                                  (,) _ [Occ=Dead]
                                                                      r_s43Rh [Occ=Once] ->
                                                                      r_s43Rh;
                                                                };
                                                      } in 
                                                        case
                                                            GHC.Real.toInteger
                                                                $dIntegral_s43QR sat_s43Ri
                                                        of
                                                        sat_s43Rj
                                                        { __DEFAULT ->
                                                              case
                                                                  GHC.Integer.Type.integerToInt
                                                                      sat_s43Rj
                                                              of
                                                              wild2_s43Rk
                                                              { __DEFAULT ->
                                                                    case
                                                                        +# [48# wild2_s43Rk]
                                                                    of
                                                                    sat_s43Rp
                                                                    { __DEFAULT ->
                                                                          case
                                                                              chr# [sat_s43Rp]
                                                                          of
                                                                          sat_s43Rq
                                                                          { __DEFAULT ->
                                                                                let {
                                                                                  sat_s43Rr [Occ=Once]
                                                                                    :: GHC.Types.Char
                                                                                  [LclId] =
                                                                                      CCCS GHC.Types.C#! [sat_s43Rq]; } in
                                                                                let {
                                                                                  sat_s43Rs [Occ=Once]
                                                                                    :: [GHC.Types.Char]
                                                                                  [LclId] =
                                                                                      CCCS :! [sat_s43Rr
                                                                                               cs_s43Rc]; } in
                                                                                let {
                                                                                  sat_s43Ro [Occ=Once]
                                                                                    :: a_a42W2
                                                                                  [LclId] =
                                                                                      [ds_s43Re] \u []
                                                                                          case
                                                                                              ds_s43Re
                                                                                          of
                                                                                          { (,) q_s43Rm [Occ=Once]
                                                                                                _ [Occ=Dead] ->
                                                                                                q_s43Rm;
                                                                                          };
                                                                                } in 
                                                                                  go_s43Ra
                                                                                      sat_s43Ro
                                                                                      sat_s43Rs;
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  GHC.Types.True -> exit_s43R2 n_s43Rb cs_s43Rc;
                                                };
                                      } in  go_s43Ra eta_s43QS eta1_s43QT;
                              };
                        GHC.Types.True -> Numeric.showInt1;
                      };
                };
        };

Numeric.showFFloatAlt
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Base.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s43Rt d_s43Ru x_s43Rv]
        let {
          sat_s43Rw [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s43Rt d_s43Ru x_s43Rv] \u []
                  GHC.Float.formatRealFloatAlt
                      $dRealFloat_s43Rt GHC.Float.FFFixed d_s43Ru GHC.Types.True x_s43Rv;
        } in  GHC.Base.++ sat_s43Rw;

Numeric.showGFloatAlt
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Base.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s43Rx d_s43Ry x_s43Rz]
        let {
          sat_s43RA [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s43Rx d_s43Ry x_s43Rz] \u []
                  GHC.Float.formatRealFloatAlt
                      $dRealFloat_s43Rx
                      GHC.Float.FFGeneric
                      d_s43Ry
                      GHC.Types.True
                      x_s43Rz;
        } in  GHC.Base.++ sat_s43RA;

lvl1_r43OI :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Numeric.showIntAtBase: applied to negative number "#;

Numeric.$wlvl [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int# -> GHC.Base.String
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [ww_s43RB]
        let {
          sat_s43RF [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [ww_s43RB] \u []
                  case GHC.Show.$wshowSignedInt 0# ww_s43RB GHC.Types.[] of {
                    (#,#) ww5_s43RD [Occ=Once] ww6_s43RE [Occ=Once] ->
                        : [ww5_s43RD ww6_s43RE];
                  };
        } in 
          case
              GHC.CString.unpackAppendCString# lvl1_r43OI sat_s43RF
          of
          sat_s43RG
          { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s43RG;
          };

lvl2_r43OJ :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Numeric.showIntAtBase: applied to unsupported base "#;

Numeric.showIntAtBase2
  :: forall a. GHC.Show.Show a => a -> GHC.Base.String
[GblId, Arity=2, Str=<B,1*U(A,1*C1(U),A)><B,U>x, Unf=OtherCon []] =
    [] \r [$dShow_s43RH eta_s43RI]
        let {
          sat_s43RJ [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s43RH eta_s43RI] \u []
                  GHC.Show.show $dShow_s43RH eta_s43RI;
        } in 
          case
              GHC.CString.unpackAppendCString# lvl1_r43OI sat_s43RJ
          of
          sat_s43RK
          { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s43RK;
          };

Numeric.showIntAtBase1
  :: forall a. GHC.Show.Show a => a -> GHC.Base.String
[GblId, Arity=2, Str=<B,1*U(A,1*C1(U),A)><B,U>x, Unf=OtherCon []] =
    [] \r [$dShow_s43RL eta_s43RM]
        let {
          sat_s43RN [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s43RL eta_s43RM] \u []
                  GHC.Show.show $dShow_s43RL eta_s43RM;
        } in 
          case
              GHC.CString.unpackAppendCString# lvl2_r43OJ sat_s43RN
          of
          sat_s43RO
          { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s43RO;
          };

sat_s43RP :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s43RQ :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s43RP GHC.Types.[]];

Numeric.showIntAtBase3 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s43RQ;

Numeric.showIntAtBase
  :: forall a.
     (GHC.Real.Integral a, GHC.Show.Show a) =>
     a -> (GHC.Types.Int -> GHC.Types.Char) -> a -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))C(C(S))LLLL)L)LLLLLC(C(S))LL),U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(U,U))),A,C(U))><L,1*U(A,1*C1(U),A)><L,U><C(S),C(U(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s43RR
           $dShow_s43RS
           eta_s43RT
           eta1_s43RU
           eta2_s43RV
           eta3_s43RW]
        case
            GHC.Real.$p1Integral $dIntegral_s43RR
        of
        $dReal_s43RX [Dmd=<S(LS(S(C(C(S))L)LC(C(S))C(C(S))LLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s43RY [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_a42NP
                [LclId] =
                    [$dReal_s43RX] \u [] GHC.Real.$p1Real $dReal_s43RX;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s43RX
                of
                $dOrd_s43RZ [Dmd=<S(S(C(C(S))L)LC(C(S))C(C(S))LLLL),U(1*U(C(C1(U)),A),A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s43S0 [Occ=Once] :: a_a42NP
                        [LclId] =
                            [$dNum_s43RY] \u []
                                GHC.Num.fromInteger $dNum_s43RY Numeric.showIntAtBase3;
                      } in 
                        case GHC.Classes.<= $dOrd_s43RZ eta_s43RT sat_s43S0 of {
                          GHC.Types.False ->
                              let {
                                sat_s43S2 [Occ=Once] :: a_a42NP
                                [LclId] =
                                    [$dNum_s43RY] \u []
                                        GHC.Num.fromInteger $dNum_s43RY Numeric.showHFloat16;
                              } in 
                                case GHC.Classes.< $dOrd_s43RZ eta2_s43RV sat_s43S2 of {
                                  GHC.Types.False ->
                                      case
                                          GHC.Real.quotRem $dIntegral_s43RR eta2_s43RV eta_s43RT
                                      of
                                      { (,) ww1_s43S5 [Occ=Once] ww2_s43S6 [Occ=Once] ->
                                            let {
                                              lvl5_s43S7 [Occ=OnceL] :: a_a42NP
                                              [LclId] =
                                                  [$dNum_s43RY] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s43RY Numeric.showHFloat16;
                                            } in 
                                              case
                                                  GHC.Classes.$p1Ord $dOrd_s43RZ
                                              of
                                              $dEq_s43S8 [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                              { __DEFAULT ->
                                                    let-no-escape {
                                                      $wshowIt5_s43S9 [InlPrag=NOUSERINLINE[0],
                                                                       Occ=LoopBreakerT[3]]
                                                        :: a_a42NP
                                                           -> a_a42NP
                                                           -> [GHC.Types.Char]
                                                           -> GHC.Base.String
                                                      [LclId[JoinId(3)],
                                                       Arity=3,
                                                       Str=<L,U><L,U><L,U>,
                                                       Unf=OtherCon []] =
                                                          sat-only [$dIntegral_s43RR
                                                                    eta_s43RT
                                                                    eta1_s43RU
                                                                    lvl5_s43S7
                                                                    $dEq_s43S8
                                                                    $wshowIt5_s43S9] \r [ww3_s43Sa
                                                                                         ww4_s43Sb
                                                                                         w_s43Sc]
                                                              let {
                                                                sat_s43Sf [Occ=Once]
                                                                  :: GHC.Types.Int
                                                                [LclId] =
                                                                    [$dIntegral_s43RR
                                                                     ww4_s43Sb] \u []
                                                                        case
                                                                            GHC.Real.toInteger
                                                                                $dIntegral_s43RR
                                                                                ww4_s43Sb
                                                                        of
                                                                        sat_s43Sd
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  GHC.Integer.Type.integerToInt
                                                                                      sat_s43Sd
                                                                              of
                                                                              wild2_s43Se
                                                                              { __DEFAULT ->
                                                                                    GHC.Types.I# [wild2_s43Se];
                                                                              };
                                                                        };
                                                              } in 
                                                                case
                                                                    eta1_s43RU sat_s43Sf
                                                                of
                                                                v_s43Sg
                                                                { GHC.Types.C# _ [Occ=Dead] ->
                                                                      case
                                                                          GHC.Classes.==
                                                                              $dEq_s43S8
                                                                              ww3_s43Sa
                                                                              lvl5_s43S7
                                                                      of
                                                                      { GHC.Types.False ->
                                                                            case
                                                                                GHC.Real.quotRem
                                                                                    $dIntegral_s43RR
                                                                                    ww3_s43Sa
                                                                                    eta_s43RT
                                                                            of
                                                                            { (,) ww6_s43Sk [Occ=Once]
                                                                                  ww7_s43Sl [Occ=Once] ->
                                                                                  let {
                                                                                    sat_s43Sm [Occ=Once]
                                                                                      :: [GHC.Types.Char]
                                                                                    [LclId] =
                                                                                        CCCS :! [v_s43Sg
                                                                                                 w_s43Sc];
                                                                                  } in 
                                                                                    $wshowIt5_s43S9
                                                                                        ww6_s43Sk
                                                                                        ww7_s43Sl
                                                                                        sat_s43Sm;
                                                                            };
                                                                        GHC.Types.True ->
                                                                            : [v_s43Sg w_s43Sc];
                                                                      };
                                                                };
                                                    } in 
                                                      $wshowIt5_s43S9
                                                          ww1_s43S5 ww2_s43S6 eta3_s43RW;
                                              };
                                      };
                                  GHC.Types.True -> Numeric.showIntAtBase2 $dShow_s43RS eta2_s43RV;
                                };
                          GHC.Types.True -> Numeric.showIntAtBase1 $dShow_s43RS eta_s43RT;
                        };
                };
        };

sat_s43Sn :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [16#];

sat_s43So :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s43Sn GHC.Types.[]];

Numeric.showHex1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s43So;

Numeric.showHex
  :: forall a.
     (GHC.Real.Integral a, GHC.Show.Show a) =>
     a -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(U,U))),A,C(U))><L,U(A,C(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s43Sp $dShow_s43Sq]
        let {
          sat_s43St [Occ=Once] :: a_a42Pa
          [LclId] =
              [$dIntegral_s43Sp] \u []
                  case GHC.Real.$p1Integral $dIntegral_s43Sp of sat_s43Sr {
                    __DEFAULT ->
                        case GHC.Real.$p1Real sat_s43Sr of sat_s43Ss {
                          __DEFAULT -> GHC.Num.fromInteger sat_s43Ss Numeric.showHex1;
                        };
                  };
        } in 
          Numeric.showIntAtBase
              $dIntegral_s43Sp $dShow_s43Sq sat_s43St GHC.Show.intToDigit;

Numeric.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

loc_r43OK :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.$trModule4;

Numeric.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Numeric"#;

loc1_r43OL :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.$trModule2;

loc2_r43OM :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Numeric.hs"#;

loc3_r43ON :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# loc2_r43OM;

loc4_r43OO :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [241#];

loc5_r43OP :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [22#];

loc6_r43OQ :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [75#];

$dIP_r43OR :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "error"#;

$dIP1_r43OS :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# $dIP_r43OR;

$dIP2_r43OT :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [loc_r43OK
                                           loc1_r43OL
                                           loc3_r43ON
                                           loc4_r43OO
                                           loc5_r43OP
                                           loc4_r43OO
                                           loc6_r43OQ];

$dIP3_r43OU :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [$dIP1_r43OS
                                                  $dIP2_r43OT
                                                  GHC.Stack.Types.EmptyCallStack];

lvl3_r43OV :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Impossible happened: showHFloat: "#;

lvl4_r43OW :: [GHC.Types.Char]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [GHC.Show.$fShow(,)2 GHC.Types.[]];

$wlvl2_r43OX
  :: [GHC.Types.Int] -> GHC.Prim.Int# -> [GHC.Types.Char]
[GblId, Arity=2, Str=<B,U><B,U>x, Unf=OtherCon []] =
    sat-only [] \r [ww_s43Su ww1_s43Sv]
        let {
          sat_s43SE [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [ww_s43Su ww1_s43Sv] \u []
                  let {
                    sat_s43SB [Occ=Once] :: GHC.Show.ShowS
                    [LclId] =
                        [ww1_s43Sv] \r [w2_s43Sx]
                            case GHC.Show.$wshowSignedInt 0# ww1_s43Sv w2_s43Sx of {
                              (#,#) ww5_s43Sz [Occ=Once] ww6_s43SA [Occ=Once] ->
                                  : [ww5_s43Sz ww6_s43SA];
                            }; } in
                  let {
                    sat_s43SC [Occ=Once] :: [GHC.Show.ShowS]
                    [LclId] =
                        CCCS :! [sat_s43SB GHC.Types.[]]; } in
                  let {
                    sat_s43Sw [Occ=Once] :: GHC.Show.ShowS
                    [LclId] =
                        [ww_s43Su] \r [eta_B1]
                            GHC.Show.$fShowInt_$cshowList ww_s43Su eta_B1; } in
                  let {
                    sat_s43SD [Occ=Once] :: [GHC.Base.String -> GHC.Base.String]
                    [LclId] =
                        CCCS :! [sat_s43Sw sat_s43SC];
                  } in  GHC.Show.$fShow(,)_go1 sat_s43SD lvl4_r43OW; } in
        let {
          sat_s43SF [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              CCCS :! [GHC.Show.$fShow(,)4 sat_s43SE];
        } in 
          case
              GHC.CString.unpackAppendCString# lvl3_r43OV sat_s43SF
          of
          sat_s43SG
          { __DEFAULT -> GHC.Err.error $dIP3_r43OU sat_s43SG;
          };

Numeric.showHFloat_allZ [Occ=LoopBreaker]
  :: [GHC.Types.Int] -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [xs_s43SH]
        case xs_s43SH of {
          [] -> GHC.Types.True [];
          : x_s43SJ [Occ=Once!] more_s43SK [Occ=Once] ->
              case x_s43SJ of {
                GHC.Types.I# x1_s43SM [Occ=Once!] ->
                    case x1_s43SM of {
                      __DEFAULT -> GHC.Types.False [];
                      0# -> Numeric.showHFloat_allZ more_s43SK;
                    };
              };
        };

$wshowIt1_r43OY
  :: GHC.Prim.Int#
     -> GHC.Types.Int -> [GHC.Types.Char] -> [GHC.Types.Char]
[GblId,
 Arity=3,
 Str=<S,1*U><S(S),1*U(U)><L,U>m2,
 Unf=OtherCon []] =
    sat-only [] \r [ww_s43SO ww1_s43SP w_s43SQ]
        case ww1_s43SP of {
          GHC.Types.I# ww3_s43SS [Occ=Once] ->
              case GHC.Show.$wintToDigit ww3_s43SS of ww4_s43ST {
                __DEFAULT ->
                    case ww_s43SO of wild_s43SU {
                      __DEFAULT ->
                          case quotRemInt# [wild_s43SU 16#] of {
                            (#,#) ipv_s43SW [Occ=Once] ipv1_s43SX [Occ=Once] ->
                                let {
                                  sat_s43SZ [Occ=Once] :: GHC.Types.Char
                                  [LclId] =
                                      CCCS GHC.Types.C#! [ww4_s43ST]; } in
                                let {
                                  sat_s43T0 [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      CCCS :! [sat_s43SZ w_s43SQ]; } in
                                let {
                                  sat_s43SY [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s43SX];
                                } in  $wshowIt1_r43OY ipv_s43SW sat_s43SY sat_s43T0;
                          };
                      0# ->
                          let {
                            sat_s43T1 [Occ=Once] :: GHC.Types.Char
                            [LclId] =
                                CCCS GHC.Types.C#! [ww4_s43ST];
                          } in  : [sat_s43T1 w_s43SQ];
                    };
              };
        };

$wshowIt2_r43OZ
  :: GHC.Prim.Int#
     -> GHC.Types.Int -> [GHC.Types.Char] -> [GHC.Types.Char]
[GblId,
 Arity=3,
 Str=<S,1*U><S(S),1*U(U)><L,U>m2,
 Unf=OtherCon []] =
    sat-only [] \r [ww_s43T2 ww1_s43T3 w_s43T4]
        case ww1_s43T3 of {
          GHC.Types.I# ww3_s43T6 [Occ=Once] ->
              case GHC.Show.$wintToDigit ww3_s43T6 of ww4_s43T7 {
                __DEFAULT ->
                    case ww_s43T2 of wild_s43T8 {
                      __DEFAULT ->
                          case quotRemInt# [wild_s43T8 16#] of {
                            (#,#) ipv_s43Ta [Occ=Once] ipv1_s43Tb [Occ=Once] ->
                                let {
                                  sat_s43Td [Occ=Once] :: GHC.Types.Char
                                  [LclId] =
                                      CCCS GHC.Types.C#! [ww4_s43T7]; } in
                                let {
                                  sat_s43Te [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      CCCS :! [sat_s43Td w_s43T4]; } in
                                let {
                                  sat_s43Tc [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s43Tb];
                                } in  $wshowIt2_r43OZ ipv_s43Ta sat_s43Tc sat_s43Te;
                          };
                      0# ->
                          let {
                            sat_s43Tf [Occ=Once] :: GHC.Types.Char
                            [LclId] =
                                CCCS GHC.Types.C#! [ww4_s43T7];
                          } in  : [sat_s43Tf w_s43T4];
                    };
              };
        };

$wshowIt3_r43P0
  :: GHC.Prim.Int#
     -> GHC.Types.Int -> [GHC.Types.Char] -> [GHC.Types.Char]
[GblId,
 Arity=3,
 Str=<S,1*U><S(S),1*U(U)><L,U>m2,
 Unf=OtherCon []] =
    sat-only [] \r [ww_s43Tg ww1_s43Th w_s43Ti]
        case ww1_s43Th of {
          GHC.Types.I# ww3_s43Tk [Occ=Once] ->
              case GHC.Show.$wintToDigit ww3_s43Tk of ww4_s43Tl {
                __DEFAULT ->
                    case ww_s43Tg of wild_s43Tm {
                      __DEFAULT ->
                          case quotRemInt# [wild_s43Tm 16#] of {
                            (#,#) ipv_s43To [Occ=Once] ipv1_s43Tp [Occ=Once] ->
                                let {
                                  sat_s43Tr [Occ=Once] :: GHC.Types.Char
                                  [LclId] =
                                      CCCS GHC.Types.C#! [ww4_s43Tl]; } in
                                let {
                                  sat_s43Ts [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      CCCS :! [sat_s43Tr w_s43Ti]; } in
                                let {
                                  sat_s43Tq [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s43Tp];
                                } in  $wshowIt3_r43P0 ipv_s43To sat_s43Tq sat_s43Ts;
                          };
                      0# ->
                          let {
                            sat_s43Tt [Occ=Once] :: GHC.Types.Char
                            [LclId] =
                                CCCS GHC.Types.C#! [ww4_s43Tl];
                          } in  : [sat_s43Tt w_s43Ti];
                    };
              };
        };

$wshowIt4_r43P1
  :: GHC.Prim.Int#
     -> GHC.Types.Int -> [GHC.Types.Char] -> [GHC.Types.Char]
[GblId,
 Arity=3,
 Str=<S,1*U><S(S),1*U(U)><L,U>m2,
 Unf=OtherCon []] =
    sat-only [] \r [ww_s43Tu ww1_s43Tv w_s43Tw]
        case ww1_s43Tv of {
          GHC.Types.I# ww3_s43Ty [Occ=Once] ->
              case GHC.Show.$wintToDigit ww3_s43Ty of ww4_s43Tz {
                __DEFAULT ->
                    case ww_s43Tu of wild_s43TA {
                      __DEFAULT ->
                          case quotRemInt# [wild_s43TA 16#] of {
                            (#,#) ipv_s43TC [Occ=Once] ipv1_s43TD [Occ=Once] ->
                                let {
                                  sat_s43TF [Occ=Once] :: GHC.Types.Char
                                  [LclId] =
                                      CCCS GHC.Types.C#! [ww4_s43Tz]; } in
                                let {
                                  sat_s43TG [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      CCCS :! [sat_s43TF w_s43Tw]; } in
                                let {
                                  sat_s43TE [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s43TD];
                                } in  $wshowIt4_r43P1 ipv_s43TC sat_s43TE sat_s43TG;
                          };
                      0# ->
                          let {
                            sat_s43TH [Occ=Once] :: GHC.Types.Char
                            [LclId] =
                                CCCS GHC.Types.C#! [ww4_s43Tz];
                          } in  : [sat_s43TH w_s43Tw];
                    };
              };
        };

Numeric.showHFloat_hex [Occ=LoopBreaker]
  :: [GHC.Types.Int] -> GHC.Base.String
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s43TI]
        case ds_s43TI of {
          [] -> [] [];
          : a_s43TK [Occ=Once*!] ds1_s43TL [Occ=Once!] ->
              case ds1_s43TL of {
                [] ->
                    case a_s43TK of {
                      GHC.Types.I# y_s43TO [Occ=Once] ->
                          case *# [8# y_s43TO] of ww_s43TP [Dmd=<S,U>] {
                            __DEFAULT ->
                                case <# [ww_s43TP 0#] of {
                                  __DEFAULT ->
                                      case quotRemInt# [ww_s43TP 16#] of {
                                        (#,#) ipv_s43TS [Occ=Once] ipv1_s43TT [Occ=Once] ->
                                            let {
                                              sat_s43TU [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv1_s43TT];
                                            } in  $wshowIt4_r43P1 ipv_s43TS sat_s43TU GHC.Types.[];
                                      };
                                  1# -> Numeric.$wlvl ww_s43TP;
                                };
                          };
                    };
                : b_s43TV [Occ=Once*!] ds2_s43TW [Occ=Once!] ->
                    case ds2_s43TW of {
                      [] ->
                          case a_s43TK of {
                            GHC.Types.I# y_s43TZ [Occ=Once] ->
                                case b_s43TV of {
                                  GHC.Types.I# y1_s43U1 [Occ=Once] ->
                                      case *# [4# y1_s43U1] of sat_s43U4 {
                                        __DEFAULT ->
                                            case *# [8# y_s43TZ] of sat_s43U3 {
                                              __DEFAULT ->
                                                  case
                                                      +# [sat_s43U3 sat_s43U4]
                                                  of
                                                  ww_s43U2 [Dmd=<S,U>]
                                                  { __DEFAULT ->
                                                        case <# [ww_s43U2 0#] of {
                                                          __DEFAULT ->
                                                              case quotRemInt# [ww_s43U2 16#] of {
                                                                (#,#) ipv_s43U7 [Occ=Once]
                                                                      ipv1_s43U8 [Occ=Once] ->
                                                                    let {
                                                                      sat_s43U9 [Occ=Once]
                                                                        :: GHC.Types.Int
                                                                      [LclId] =
                                                                          CCCS GHC.Types.I#! [ipv1_s43U8];
                                                                    } in 
                                                                      $wshowIt3_r43P0
                                                                          ipv_s43U7
                                                                          sat_s43U9
                                                                          GHC.Types.[];
                                                              };
                                                          1# -> Numeric.$wlvl ww_s43U2;
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                      : c_s43Ua [Occ=Once*!] ds3_s43Ub [Occ=Once!] ->
                          case ds3_s43Ub of {
                            [] ->
                                case a_s43TK of {
                                  GHC.Types.I# y_s43Ue [Occ=Once] ->
                                      case b_s43TV of {
                                        GHC.Types.I# y1_s43Ug [Occ=Once] ->
                                            case c_s43Ua of {
                                              GHC.Types.I# y2_s43Ui [Occ=Once] ->
                                                  case *# [2# y2_s43Ui] of sat_s43Un {
                                                    __DEFAULT ->
                                                        case *# [4# y1_s43Ug] of sat_s43Ul {
                                                          __DEFAULT ->
                                                              case *# [8# y_s43Ue] of sat_s43Uk {
                                                                __DEFAULT ->
                                                                    case
                                                                        +# [sat_s43Uk sat_s43Ul]
                                                                    of
                                                                    sat_s43Um
                                                                    { __DEFAULT ->
                                                                          case
                                                                              +# [sat_s43Um
                                                                                  sat_s43Un]
                                                                          of
                                                                          ww_s43Uj [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    <# [ww_s43Uj 0#]
                                                                                of
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          quotRemInt# [ww_s43Uj
                                                                                                       16#]
                                                                                      of
                                                                                      { (#,#) ipv_s43Uq [Occ=Once]
                                                                                              ipv1_s43Ur [Occ=Once] ->
                                                                                            let {
                                                                                              sat_s43Us [Occ=Once]
                                                                                                :: GHC.Types.Int
                                                                                              [LclId] =
                                                                                                  CCCS GHC.Types.I#! [ipv1_s43Ur];
                                                                                            } in 
                                                                                              $wshowIt2_r43OZ
                                                                                                  ipv_s43Uq
                                                                                                  sat_s43Us
                                                                                                  GHC.Types.[];
                                                                                      };
                                                                                  1# ->
                                                                                      Numeric.$wlvl
                                                                                          ww_s43Uj;
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                            : d_s43Ut [Occ=Once!] r_s43Uu [Occ=Once] ->
                                case a_s43TK of {
                                  GHC.Types.I# y_s43Uw [Occ=Once] ->
                                      case b_s43TV of {
                                        GHC.Types.I# y1_s43Uy [Occ=Once] ->
                                            case c_s43Ua of {
                                              GHC.Types.I# y2_s43UA [Occ=Once] ->
                                                  case d_s43Ut of {
                                                    GHC.Types.I# y3_s43UC [Occ=Once] ->
                                                        case *# [2# y2_s43UA] of sat_s43UH {
                                                          __DEFAULT ->
                                                              case *# [4# y1_s43Uy] of sat_s43UF {
                                                                __DEFAULT ->
                                                                    case
                                                                        *# [8# y_s43Uw]
                                                                    of
                                                                    sat_s43UE
                                                                    { __DEFAULT ->
                                                                          case
                                                                              +# [sat_s43UE
                                                                                  sat_s43UF]
                                                                          of
                                                                          sat_s43UG
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    +# [sat_s43UG
                                                                                        sat_s43UH]
                                                                                of
                                                                                sat_s43UI
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          +# [sat_s43UI
                                                                                              y3_s43UC]
                                                                                      of
                                                                                      ww_s43UD [Dmd=<S,U>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                <# [ww_s43UD
                                                                                                    0#]
                                                                                            of
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      quotRemInt# [ww_s43UD
                                                                                                                   16#]
                                                                                                  of
                                                                                                  { (#,#) ipv_s43UL [Occ=Once]
                                                                                                          ipv1_s43UM [Occ=Once] ->
                                                                                                        let {
                                                                                                          sat_s43UO [Occ=Once]
                                                                                                            :: [GHC.Types.Char]
                                                                                                          [LclId] =
                                                                                                              [r_s43Uu] \u []
                                                                                                                  Numeric.showHFloat_hex
                                                                                                                      r_s43Uu; } in
                                                                                                        let {
                                                                                                          sat_s43UN [Occ=Once]
                                                                                                            :: GHC.Types.Int
                                                                                                          [LclId] =
                                                                                                              CCCS GHC.Types.I#! [ipv1_s43UM];
                                                                                                        } in 
                                                                                                          $wshowIt1_r43OY
                                                                                                              ipv_s43UL
                                                                                                              sat_s43UN
                                                                                                              sat_s43UO;
                                                                                                  };
                                                                                              1# ->
                                                                                                  Numeric.$wlvl
                                                                                                      ww_s43UD;
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

sat_s43UP :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

sat_s43UQ :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s43UP GHC.Types.[]];

Numeric.showHFloat15 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s43UQ;

Numeric.showHFloat10 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "0x0p+0"#;

Numeric.showHFloat9 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.showHFloat10;

Numeric.showHFloat14 :: GHC.Prim.Int# -> [GHC.Types.Char]
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [ww_s43UR] $wlvl2_r43OX GHC.Types.[] ww_s43UR;

Numeric.showHFloat13 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "0x"#;

Numeric.showHFloat12 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "p"#;

Numeric.showHFloat11 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "."#;

Numeric.showHFloat_cvt
  :: forall a. GHC.Float.RealFloat a => a -> [GHC.Types.Char]
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s43US eta_s43UT]
        case
            GHC.Float.$p1RealFloat $dRealFloat_s43US
        of
        $dRealFrac_s43UU [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_s43UU
              of
              $dReal_s43UV [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    let {
                      sat_s43UZ [Occ=Once] :: a_a42SJ
                      [LclId] =
                          [$dReal_s43UV] \u []
                              case GHC.Real.$p1Real $dReal_s43UV of sat_s43UY {
                                __DEFAULT -> GHC.Num.fromInteger sat_s43UY Numeric.showHFloat16;
                              };
                    } in 
                      case GHC.Real.$p2Real $dReal_s43UV of sat_s43UW {
                        __DEFAULT ->
                            case GHC.Classes.$p1Ord sat_s43UW of sat_s43UX {
                              __DEFAULT ->
                                  case GHC.Classes.== sat_s43UX eta_s43UT sat_s43UZ of {
                                    GHC.Types.False ->
                                        case
                                            GHC.Float.$wfloatToDigits
                                                $dRealFloat_s43US Numeric.showHFloat15 eta_s43UT
                                        of
                                        { (#,#) ww1_s43V2 [Occ=Once!] ww2_s43V3 [Occ=Once*!] ->
                                              case ww1_s43V2 of {
                                                [] ->
                                                    case ww2_s43V3 of {
                                                      GHC.Types.I# ww5_s43V6 [Occ=Once] ->
                                                          Numeric.showHFloat14 ww5_s43V6;
                                                    };
                                                : d_s43V7 [Occ=Once!] ds_s43V8 ->
                                                    let {
                                                      sat_s43Vr [Occ=Once] :: [GHC.Types.Char]
                                                      [LclId] =
                                                          [ww2_s43V3 d_s43V7 ds_s43V8] \u []
                                                              case d_s43V7 of {
                                                                GHC.Types.I# ww3_s43Va [Occ=Once] ->
                                                                    case
                                                                        GHC.Show.$wshowSignedInt
                                                                            0#
                                                                            ww3_s43Va
                                                                            GHC.Types.[]
                                                                    of
                                                                    { (#,#) ww6_s43Vc [Occ=Once]
                                                                            ww7_s43Vd [Occ=Once] ->
                                                                          let {
                                                                            sat_s43Vq [Occ=Once,
                                                                                       Dmd=<L,1*U>]
                                                                              :: [GHC.Types.Char]
                                                                            [LclId] =
                                                                                [ww2_s43V3
                                                                                 ds_s43V8] \s []
                                                                                    let {
                                                                                      n_s43Vf [Occ=Once*,
                                                                                               Dmd=<L,1*U>]
                                                                                        :: [GHC.Types.Char]
                                                                                      [LclId] =
                                                                                          [ww2_s43V3] \s []
                                                                                              let {
                                                                                                sat_s43Vm [Occ=Once]
                                                                                                  :: [GHC.Types.Char]
                                                                                                [LclId] =
                                                                                                    [ww2_s43V3] \u []
                                                                                                        case
                                                                                                            ww2_s43V3
                                                                                                        of
                                                                                                        { GHC.Types.I# x_s43Vh [Occ=Once] ->
                                                                                                              case
                                                                                                                  -# [x_s43Vh
                                                                                                                      1#]
                                                                                                              of
                                                                                                              sat_s43Vi
                                                                                                              { __DEFAULT ->
                                                                                                                    case
                                                                                                                        GHC.Show.$wshowSignedInt
                                                                                                                            0#
                                                                                                                            sat_s43Vi
                                                                                                                            GHC.Types.[]
                                                                                                                    of
                                                                                                                    { (#,#) ww9_s43Vk [Occ=Once]
                                                                                                                            ww10_s43Vl [Occ=Once] ->
                                                                                                                          : [ww9_s43Vk
                                                                                                                             ww10_s43Vl];
                                                                                                                    };
                                                                                                              };
                                                                                                        };
                                                                                              } in 
                                                                                                GHC.CString.unpackAppendCString#
                                                                                                    Numeric.showHFloat12
                                                                                                    sat_s43Vm;
                                                                                    } in 
                                                                                      case
                                                                                          Numeric.showHFloat_allZ
                                                                                              ds_s43V8
                                                                                      of
                                                                                      { GHC.Types.False ->
                                                                                            let {
                                                                                              sat_s43Vp [Occ=Once]
                                                                                                :: [GHC.Types.Char]
                                                                                              [LclId] =
                                                                                                  [ds_s43V8
                                                                                                   n_s43Vf] \u []
                                                                                                      case
                                                                                                          Numeric.showHFloat_hex
                                                                                                              ds_s43V8
                                                                                                      of
                                                                                                      sat_s43Vo
                                                                                                      { __DEFAULT ->
                                                                                                            GHC.Base.++
                                                                                                                sat_s43Vo
                                                                                                                n_s43Vf;
                                                                                                      };
                                                                                            } in 
                                                                                              GHC.CString.unpackAppendCString#
                                                                                                  Numeric.showHFloat11
                                                                                                  sat_s43Vp;
                                                                                        GHC.Types.True ->
                                                                                            n_s43Vf;
                                                                                      }; } in
                                                                          let {
                                                                            sat_s43Ve [Occ=Once]
                                                                              :: [GHC.Types.Char]
                                                                            [LclId] =
                                                                                CCCS :! [ww6_s43Vc
                                                                                         ww7_s43Vd];
                                                                          } in 
                                                                            GHC.Base.++
                                                                                sat_s43Ve sat_s43Vq;
                                                                    };
                                                              };
                                                    } in 
                                                      GHC.CString.unpackAppendCString#
                                                          Numeric.showHFloat13 sat_s43Vr;
                                              };
                                        };
                                    GHC.Types.True -> Numeric.showHFloat9;
                                  };
                            };
                      };
              };
        };

Numeric.showHFloat8 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! ['-'#];

Numeric.showHFloat5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Infinity"#;

Numeric.showHFloat7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "-"#;

Numeric.showHFloat6 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.showHFloat7;

Numeric.showHFloat2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NaN"#;

Numeric.showHFloat1 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.showHFloat2;

Numeric.showHFloat4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.showHFloat5;

Numeric.showHFloat3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.Base.++ Numeric.showHFloat6 Numeric.showHFloat4;

Numeric.showHFloat
  :: forall a. GHC.Float.RealFloat a => a -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Str=<L,U(U(U(U(A,A,A,1*C1(U),A,A,C(U)),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,1*C1(U),1*C1(U),A,1*C1(U),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s43Vs eta_s43Vt]
        let {
          sat_s43VK [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s43Vs eta_s43Vt] \u []
                  case GHC.Float.isNaN $dRealFloat_s43Vs eta_s43Vt of {
                    GHC.Types.False ->
                        case
                            GHC.Float.$p1RealFloat $dRealFloat_s43Vs
                        of
                        $dRealFrac_s43Vv [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),1*U(1*U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A)>]
                        { __DEFAULT ->
                              case
                                  GHC.Real.$p1RealFrac $dRealFrac_s43Vv
                              of
                              $dReal_s43Vw [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
                              { __DEFAULT ->
                                    let {
                                      $dNum_s43Vx [Dmd=<L,U(A,A,A,1*C1(U),A,A,1*C1(U))>]
                                        :: GHC.Num.Num a_a42Pu
                                      [LclId] =
                                          [$dReal_s43Vw] \u [] GHC.Real.$p1Real $dReal_s43Vw;
                                    } in 
                                      case GHC.Float.isInfinite $dRealFloat_s43Vs eta_s43Vt of {
                                        GHC.Types.False ->
                                            let {
                                              sat_s43VA [Occ=Once] :: a_a42Pu
                                              [LclId] =
                                                  [$dNum_s43Vx] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s43Vx Numeric.showHFloat16;
                                            } in 
                                              case GHC.Real.$p2Real $dReal_s43Vw of sat_s43Vz {
                                                __DEFAULT ->
                                                    case
                                                        GHC.Classes.< sat_s43Vz eta_s43Vt sat_s43VA
                                                    of
                                                    { GHC.Types.False ->
                                                          case
                                                              GHC.Float.isNegativeZero
                                                                  $dRealFloat_s43Vs eta_s43Vt
                                                          of
                                                          { GHC.Types.False ->
                                                                Numeric.showHFloat_cvt
                                                                    $dRealFloat_s43Vs eta_s43Vt;
                                                            GHC.Types.True ->
                                                                let {
                                                                  sat_s43VE [Occ=Once]
                                                                    :: [GHC.Types.Char]
                                                                  [LclId] =
                                                                      [$dRealFloat_s43Vs
                                                                       eta_s43Vt
                                                                       $dNum_s43Vx] \u []
                                                                          let {
                                                                            sat_s43VD [Occ=Once]
                                                                              :: a_a42Pu
                                                                            [LclId] =
                                                                                [eta_s43Vt
                                                                                 $dNum_s43Vx] \u []
                                                                                    GHC.Num.negate
                                                                                        $dNum_s43Vx
                                                                                        eta_s43Vt;
                                                                          } in 
                                                                            Numeric.showHFloat_cvt
                                                                                $dRealFloat_s43Vs
                                                                                sat_s43VD;
                                                                } in 
                                                                  : [Numeric.showHFloat8 sat_s43VE];
                                                          };
                                                      GHC.Types.True ->
                                                          let {
                                                            sat_s43VG [Occ=Once] :: [GHC.Types.Char]
                                                            [LclId] =
                                                                [$dRealFloat_s43Vs
                                                                 eta_s43Vt
                                                                 $dNum_s43Vx] \u []
                                                                    let {
                                                                      sat_s43VF [Occ=Once]
                                                                        :: a_a42Pu
                                                                      [LclId] =
                                                                          [eta_s43Vt
                                                                           $dNum_s43Vx] \u []
                                                                              GHC.Num.negate
                                                                                  $dNum_s43Vx
                                                                                  eta_s43Vt;
                                                                    } in 
                                                                      Numeric.showHFloat_cvt
                                                                          $dRealFloat_s43Vs
                                                                          sat_s43VF;
                                                          } in  : [Numeric.showHFloat8 sat_s43VG];
                                                    };
                                              };
                                        GHC.Types.True ->
                                            let {
                                              sat_s43VI [Occ=Once] :: a_a42Pu
                                              [LclId] =
                                                  [$dNum_s43Vx] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s43Vx Numeric.showHFloat16;
                                            } in 
                                              case GHC.Real.$p2Real $dReal_s43Vw of sat_s43VH {
                                                __DEFAULT ->
                                                    case
                                                        GHC.Classes.< sat_s43VH eta_s43Vt sat_s43VI
                                                    of
                                                    { GHC.Types.False -> Numeric.showHFloat4;
                                                      GHC.Types.True -> Numeric.showHFloat3;
                                                    };
                                              };
                                      };
                              };
                        };
                    GHC.Types.True -> Numeric.showHFloat1;
                  };
        } in  GHC.Base.++ sat_s43VK;

sat_s43VL :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [8#];

sat_s43VM :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s43VL GHC.Types.[]];

Numeric.showOct1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s43VM;

Numeric.showOct
  :: forall a.
     (GHC.Real.Integral a, GHC.Show.Show a) =>
     a -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(U,U))),A,C(U))><L,U(A,C(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s43VN $dShow_s43VO]
        let {
          sat_s43VR [Occ=Once] :: a_a42Pk
          [LclId] =
              [$dIntegral_s43VN] \u []
                  case GHC.Real.$p1Integral $dIntegral_s43VN of sat_s43VP {
                    __DEFAULT ->
                        case GHC.Real.$p1Real sat_s43VP of sat_s43VQ {
                          __DEFAULT -> GHC.Num.fromInteger sat_s43VQ Numeric.showOct1;
                        };
                  };
        } in 
          Numeric.showIntAtBase
              $dIntegral_s43VN $dShow_s43VO sat_s43VR GHC.Show.intToDigit;

Numeric.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Numeric.$trModule4];

Numeric.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Numeric.$trModule2];

Numeric.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Numeric.$trModule3
                                     Numeric.$trModule1];

Numeric.showGFloat_$sshowGFloat
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Float -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s43VS x_s43VT]
        let {
          sat_s43VW [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s43VS x_s43VT] \u []
                  case x_s43VT of {
                    GHC.Types.F# ww1_s43VV [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt1
                            GHC.Float.FFGeneric d_s43VS GHC.Types.False ww1_s43VV;
                  };
        } in  GHC.Base.++ sat_s43VW;

Numeric.showFFloat_$sshowFFloat
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Float -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s43VX x_s43VY]
        let {
          sat_s43W1 [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s43VX x_s43VY] \u []
                  case x_s43VY of {
                    GHC.Types.F# ww1_s43W0 [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt1
                            GHC.Float.FFFixed d_s43VX GHC.Types.False ww1_s43W0;
                  };
        } in  GHC.Base.++ sat_s43W1;

Numeric.showEFloat_$sshowEFloat
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Float -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s43W2 x_s43W3]
        let {
          sat_s43W6 [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s43W2 x_s43W3] \u []
                  case x_s43W3 of {
                    GHC.Types.F# ww1_s43W5 [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt1
                            GHC.Float.FFExponent d_s43W2 GHC.Types.False ww1_s43W5;
                  };
        } in  GHC.Base.++ sat_s43W6;

Numeric.showGFloat_$sshowGFloat1
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Double -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s43W7 x_s43W8]
        let {
          sat_s43Wb [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s43W7 x_s43W8] \u []
                  case x_s43W8 of {
                    GHC.Types.D# ww1_s43Wa [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt
                            GHC.Float.FFGeneric d_s43W7 GHC.Types.False ww1_s43Wa;
                  };
        } in  GHC.Base.++ sat_s43Wb;

Numeric.showGFloat
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Base.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s43Wc d_s43Wd x_s43We]
        let {
          sat_s43Wf [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s43Wc d_s43Wd x_s43We] \u []
                  GHC.Float.formatRealFloatAlt
                      $dRealFloat_s43Wc
                      GHC.Float.FFGeneric
                      d_s43Wd
                      GHC.Types.False
                      x_s43We;
        } in  GHC.Base.++ sat_s43Wf;

Numeric.showFFloat_$sshowFFloat1
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Double -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s43Wg x_s43Wh]
        let {
          sat_s43Wk [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s43Wg x_s43Wh] \u []
                  case x_s43Wh of {
                    GHC.Types.D# ww1_s43Wj [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt
                            GHC.Float.FFFixed d_s43Wg GHC.Types.False ww1_s43Wj;
                  };
        } in  GHC.Base.++ sat_s43Wk;

Numeric.showFFloat
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Base.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s43Wl d_s43Wm x_s43Wn]
        let {
          sat_s43Wo [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s43Wl d_s43Wm x_s43Wn] \u []
                  GHC.Float.formatRealFloatAlt
                      $dRealFloat_s43Wl
                      GHC.Float.FFFixed
                      d_s43Wm
                      GHC.Types.False
                      x_s43Wn;
        } in  GHC.Base.++ sat_s43Wo;

Numeric.showEFloat_$sshowEFloat1
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Double -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s43Wp x_s43Wq]
        let {
          sat_s43Wt [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s43Wp x_s43Wq] \u []
                  case x_s43Wq of {
                    GHC.Types.D# ww1_s43Ws [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt
                            GHC.Float.FFExponent d_s43Wp GHC.Types.False ww1_s43Ws;
                  };
        } in  GHC.Base.++ sat_s43Wt;

Numeric.showEFloat
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Base.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s43Wu d_s43Wv x_s43Ww]
        let {
          sat_s43Wx [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s43Wu d_s43Wv x_s43Ww] \u []
                  GHC.Float.formatRealFloatAlt
                      $dRealFloat_s43Wu
                      GHC.Float.FFExponent
                      d_s43Wv
                      GHC.Types.False
                      x_s43Ww;
        } in  GHC.Base.++ sat_s43Wx;


==================== Pre unarise: ====================
2018-03-16 15:58:59.106856265 UTC

Numeric.readInt
  :: forall a.
     GHC.Num.Num a =>
     a
     -> (GHC.Types.Char -> GHC.Types.Bool)
     -> (GHC.Types.Char -> GHC.Types.Int)
     -> Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=4,
 Str=<L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))><L,U><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_s45RH base_s45RI isDigit_s45RJ valDigit_s45RK]
        let {
          sat_s45RN [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42Zn
          [LclId] =
              [$dNum_s45RH base_s45RI isDigit_s45RJ valDigit_s45RK] \u []
                  case
                      Text.Read.Lex.$wreadIntP
                          $dNum_s45RH
                          base_s45RI
                          isDigit_s45RJ
                          valDigit_s45RK
                          Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                  of
                  { Unit# ww1_s45RM [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Get [ww1_s45RM];
                  };
        } in  Text.ParserCombinators.ReadP.run sat_s45RN;

Numeric.readOct
  :: forall a.
     (GHC.Classes.Eq a, GHC.Num.Num a) =>
     Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=2,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dEq_s45RO $dNum_s45RP]
        let {
          sat_s45RT [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42Ze
          [LclId] =
              [$dEq_s45RO $dNum_s45RP] \u []
                  let {
                    sat_s45RQ [Occ=Once] :: a_a42Ze
                    [LclId] =
                        [$dNum_s45RP] \u []
                            GHC.Num.fromInteger $dNum_s45RP Text.Read.Lex.readDecP4;
                  } in 
                    case
                        Text.Read.Lex.$wreadIntP'
                            $dEq_s45RO
                            $dNum_s45RP
                            sat_s45RQ
                            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                    of
                    { Unit# ww1_s45RS [Occ=Once] ->
                          Text.ParserCombinators.ReadP.Get [ww1_s45RS];
                    };
        } in  Text.ParserCombinators.ReadP.run sat_s45RT;

Numeric.readDec
  :: forall a.
     (GHC.Classes.Eq a, GHC.Num.Num a) =>
     Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=2,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dEq_s45RU $dNum_s45RV]
        let {
          sat_s45RZ [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42Z5
          [LclId] =
              [$dEq_s45RU $dNum_s45RV] \u []
                  let {
                    sat_s45RW [Occ=Once] :: a_a42Z5
                    [LclId] =
                        [$dNum_s45RV] \u []
                            GHC.Num.fromInteger $dNum_s45RV Text.Read.Lex.numberToFixed1;
                  } in 
                    case
                        Text.Read.Lex.$wreadIntP'
                            $dEq_s45RU
                            $dNum_s45RV
                            sat_s45RW
                            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                    of
                    { Unit# ww1_s45RY [Occ=Once] ->
                          Text.ParserCombinators.ReadP.Get [ww1_s45RY];
                    };
        } in  Text.ParserCombinators.ReadP.run sat_s45RZ;

Numeric.readHex
  :: forall a.
     (GHC.Classes.Eq a, GHC.Num.Num a) =>
     Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=2,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dEq_s45S0 $dNum_s45S1]
        let {
          sat_s45S5 [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42YW
          [LclId] =
              [$dEq_s45S0 $dNum_s45S1] \u []
                  let {
                    sat_s45S2 [Occ=Once] :: a_a42YW
                    [LclId] =
                        [$dNum_s45S1] \u []
                            GHC.Num.fromInteger $dNum_s45S1 Text.Read.Lex.readDecP3;
                  } in 
                    case
                        Text.Read.Lex.$wreadIntP'
                            $dEq_s45S0
                            $dNum_s45S1
                            sat_s45S2
                            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                    of
                    { Unit# ww1_s45S4 [Occ=Once] ->
                          Text.ParserCombinators.ReadP.Get [ww1_s45S4];
                    };
        } in  Text.ParserCombinators.ReadP.run sat_s45S5;

Numeric.readFloat2
  :: forall a. GHC.Base.String -> Text.ParserCombinators.ReadP.P a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [a3_s45S6]
        case a3_s45S6 of {
          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
        };

Numeric.readFloat1 :: forall a. Text.ParserCombinators.ReadP.P a
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE Text.ParserCombinators.ReadP.Look! [Numeric.readFloat2];

Numeric.readFloat
  :: forall a.
     GHC.Real.RealFrac a =>
     Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=1,
 Str=<L,1*U(A,1*U(A,A,A,C(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_s45S8]
        let {
          lvl116_s45S9 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P a_a42YP
          [LclId] =
              [$dRealFrac_s45S8] \u []
                  let {
                    sat_s45Sk [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42YP
                    [LclId] =
                        [$dRealFrac_s45S8] \u []
                            let {
                              $dFractional_s45Sa [Occ=OnceL, Dmd=<L,U(A,A,A,C(U))>]
                                :: GHC.Real.Fractional a_a42YP
                              [LclId] =
                                  [$dRealFrac_s45S8] \u []
                                      GHC.Real.$p2RealFrac $dRealFrac_s45S8; } in
                            let {
                              sat_s45Sj [Occ=Once]
                                :: Text.Read.Lex.Lexeme -> Text.ParserCombinators.ReadP.P a_a42YP
                              [LclId] =
                                  [$dFractional_s45Sa] \r [a1_s45Sb]
                                      case a1_s45Sb of {
                                        __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                        Text.Read.Lex.Number n_s45Sd [Occ=Once] ->
                                            let {
                                              sat_s45Si [Occ=Once] :: a_a42YP
                                              [LclId] =
                                                  [$dFractional_s45Sa n_s45Sd] \u []
                                                      let {
                                                        sat_s45Sh [Occ=Once] :: GHC.Real.Rational
                                                        [LclId] =
                                                            [n_s45Sd] \u []
                                                                case
                                                                    Text.Read.Lex.$wnumberToRational
                                                                        n_s45Sd
                                                                of
                                                                { (#,#) ww1_s45Sf [Occ=Once]
                                                                        ww2_s45Sg [Occ=Once] ->
                                                                      GHC.Real.:% [ww1_s45Sf
                                                                                   ww2_s45Sg];
                                                                };
                                                      } in 
                                                        GHC.Real.fromRational
                                                            $dFractional_s45Sa sat_s45Sh;
                                            } in 
                                              Text.ParserCombinators.ReadP.Result [sat_s45Si
                                                                                   Text.ParserCombinators.ReadP.Fail];
                                      };
                            } in  Text.Read.Lex.expect2 sat_s45Sj;
                  } in 
                    Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                        Numeric.readFloat1 sat_s45Sk; } in
        let {
          k_s45Sl [Occ=OnceL, Dmd=<L,C(U)>]
            :: () -> Text.ParserCombinators.ReadP.P a_a42YP
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl116_s45S9] \r [a3_s45Sm] lvl116_s45S9; } in
        let {
          sat_s45So [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P a_a42YP
          [LclId] =
              [k_s45Sl] \r [a1_s45Sn]
                  Text.ParserCombinators.ReadP.skipSpaces2 a1_s45Sn k_s45Sl; } in
        let {
          sat_s45Sp [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42YP
          [LclId] =
              CCCS Text.ParserCombinators.ReadP.Look! [sat_s45So];
        } in  Text.ParserCombinators.ReadP.run sat_s45Sp;

Numeric.readSigned
  :: forall a.
     GHC.Real.Real a =>
     Text.ParserCombinators.ReadP.ReadS a
     -> Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=3,
 Str=<L,1*U(1*U(A,A,A,C(U),A,A,A),A,A)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dReal_s45Sq eta_s45Sr eta1_s45Ss]
        let {
          $dNum_s45St [Occ=OnceL, Dmd=<L,U(A,A,A,C(U),A,A,A)>]
            :: GHC.Num.Num a_a42Xv
          [LclId] =
              [$dReal_s45Sq] \u [] GHC.Real.$p1Real $dReal_s45Sq; } in
        let {
          go_s45Su [Occ=LoopBreaker]
            :: [(GHC.Base.String, GHC.Base.String)]
               -> [(a_a42Xv, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [eta_s45Sr go_s45Su] \r [ds_s45Sv]
                  case ds_s45Sv of {
                    [] -> [] [];
                    : y_s45Sx [Occ=Once!] ys_s45Sy [Occ=Once] ->
                        case y_s45Sx of {
                          (,) str_s45SA [Occ=Once] s_s45SB [Occ=OnceL] ->
                              let {
                                z_s45SC [Occ=OnceL] :: [(a_a42Xv, GHC.Base.String)]
                                [LclId] =
                                    [go_s45Su ys_s45Sy] \u [] go_s45Su ys_s45Sy; } in
                              let {
                                go1_s45SD [Occ=LoopBreaker]
                                  :: [(a_a42Xv, GHC.Base.String)] -> [(a_a42Xv, GHC.Base.String)]
                                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                    sat-only [s_s45SB z_s45SC go1_s45SD] \r [ds1_s45SE]
                                        case ds1_s45SE of {
                                          [] -> z_s45SC;
                                          : y1_s45SG [Occ=Once!] ys1_s45SH [Occ=Once*] ->
                                              case y1_s45SG of {
                                                (,) n_s45SJ [Occ=Once] ds2_s45SK [Occ=Once!] ->
                                                    case ds2_s45SK of {
                                                      [] ->
                                                          let {
                                                            sat_s45SN [Occ=Once]
                                                              :: [(a_a42Xv, GHC.Base.String)]
                                                            [LclId] =
                                                                [go1_s45SD ys1_s45SH] \u []
                                                                    go1_s45SD ys1_s45SH; } in
                                                          let {
                                                            sat_s45SM [Occ=Once]
                                                              :: (a_a42Xv, GHC.Base.String)
                                                            [LclId] =
                                                                CCCS (,)! [n_s45SJ s_s45SB];
                                                          } in  : [sat_s45SM sat_s45SN];
                                                      : _ [Occ=Dead] _ [Occ=Dead] ->
                                                          go1_s45SD ys1_s45SH;
                                                    };
                                              };
                                        };
                              } in 
                                case eta_s45Sr str_s45SA of sat_s45SQ {
                                  __DEFAULT -> go1_s45SD sat_s45SQ;
                                };
                        };
                  }; } in
        let {
          go1_s45SR [Occ=LoopBreaker]
            :: [(GHC.Base.String, GHC.Base.String)]
               -> [(a_a42Xv, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dNum_s45St go_s45Su go1_s45SR] \r [ds_s45SS]
                  case ds_s45SS of {
                    [] -> [] [];
                    : y_s45SU [Occ=Once!] ys_s45SV [Occ=Once*] ->
                        case y_s45SU of {
                          (,) ds1_s45SX [Occ=Once!] s_s45SY [Occ=Once] ->
                              case ds1_s45SX of {
                                [] -> go1_s45SR ys_s45SV;
                                : ds2_s45T0 [Occ=Once!] ds3_s45T1 [Occ=Once!] ->
                                    case ds2_s45T0 of {
                                      GHC.Types.C# ds4_s45T3 [Occ=Once!] ->
                                          case ds4_s45T3 of {
                                            __DEFAULT -> go1_s45SR ys_s45SV;
                                            '-'# ->
                                                case ds3_s45T1 of {
                                                  [] ->
                                                      let {
                                                        z_s45T6 [Occ=OnceL]
                                                          :: [(a_a42Xv, GHC.Base.String)]
                                                        [LclId] =
                                                            [go1_s45SR ys_s45SV] \u []
                                                                go1_s45SR ys_s45SV; } in
                                                      let {
                                                        go2_s45T7 [Occ=LoopBreaker]
                                                          :: [(a_a42Xv, GHC.Base.String)]
                                                             -> [(a_a42Xv, GHC.Base.String)]
                                                        [LclId,
                                                         Arity=1,
                                                         Str=<S,1*U>,
                                                         Unf=OtherCon []] =
                                                            sat-only [$dNum_s45St
                                                                      z_s45T6
                                                                      go2_s45T7] \r [ds6_s45T8]
                                                                case ds6_s45T8 of {
                                                                  [] -> z_s45T6;
                                                                  : y1_s45Ta [Occ=Once!]
                                                                    ys1_s45Tb [Occ=Once] ->
                                                                      case y1_s45Ta of {
                                                                        (,) x_s45Td [Occ=Once]
                                                                            t_s45Te [Occ=Once] ->
                                                                            let {
                                                                              sat_s45Th [Occ=Once]
                                                                                :: [(a_a42Xv,
                                                                                     GHC.Base.String)]
                                                                              [LclId] =
                                                                                  [go2_s45T7
                                                                                   ys1_s45Tb] \u []
                                                                                      go2_s45T7
                                                                                          ys1_s45Tb; } in
                                                                            let {
                                                                              sat_s45Tf [Occ=Once]
                                                                                :: a_a42Xv
                                                                              [LclId] =
                                                                                  [$dNum_s45St
                                                                                   x_s45Td] \u []
                                                                                      GHC.Num.negate
                                                                                          $dNum_s45St
                                                                                          x_s45Td; } in
                                                                            let {
                                                                              sat_s45Tg [Occ=Once]
                                                                                :: (a_a42Xv,
                                                                                    GHC.Base.String)
                                                                              [LclId] =
                                                                                  CCCS (,)! [sat_s45Tf
                                                                                             t_s45Te];
                                                                            } in 
                                                                              : [sat_s45Tg
                                                                                 sat_s45Th];
                                                                      };
                                                                };
                                                      } in 
                                                        case
                                                            Text.ParserCombinators.ReadP.run
                                                                GHC.Read.lex1 s_s45SY
                                                        of
                                                        sat_s45Ti
                                                        { __DEFAULT ->
                                                              case go_s45Su sat_s45Ti of sat_s45Tj {
                                                                __DEFAULT -> go2_s45T7 sat_s45Tj;
                                                              };
                                                        };
                                                  : _ [Occ=Dead] _ [Occ=Dead] -> go1_s45SR ys_s45SV;
                                                };
                                          };
                                    };
                              };
                        };
                  }; } in
        let {
          sat_s45Tr [Occ=Once] :: Text.ParserCombinators.ReadP.ReadS a_a42Xv
          [LclId] =
              [go_s45Su go1_s45SR] \r [r_s45Tm]
                  let {
                    sat_s45Tq [Occ=Once, Dmd=<L,1*U>] :: [(a_a42Xv, GHC.Base.String)]
                    [LclId] =
                        [go1_s45SR r_s45Tm] \s []
                            case
                                Text.ParserCombinators.ReadP.run GHC.Read.lex1 r_s45Tm
                            of
                            sat_s45Tp
                            { __DEFAULT -> go1_s45SR sat_s45Tp;
                            };
                  } in 
                    case
                        Text.ParserCombinators.ReadP.run GHC.Read.lex1 r_s45Tm
                    of
                    sat_s45Tn
                    { __DEFAULT ->
                          case go_s45Su sat_s45Tn of sat_s45To {
                            __DEFAULT -> GHC.Base.++ sat_s45To sat_s45Tq;
                          };
                    };
        } in  GHC.Read.readParen GHC.Types.False sat_s45Tr eta1_s45Ss;

sat_s45Ts :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [10#];

sat_s45Tt :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s45Ts GHC.Types.[]];

Numeric.showInt2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s45Tt;

lvl_r43OH :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Numeric.showInt: can't show negative numbers"#;

Numeric.showInt1 :: GHC.Base.String
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_r43OH of sat_s45Tu {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s45Tu;
        };

Numeric.showHFloat16 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Numeric.showInt
  :: forall a. GHC.Real.Integral a => a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLLLC(S)),U(1*U(U(A,A,A,A,A,A,C(U)),U(A,A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s45Tv eta_s45Tw eta1_s45Tx]
        case
            GHC.Real.$p1Integral $dIntegral_s45Tv
        of
        $dReal_s45Ty [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(U(A,A,A,A,A,A,C(U)),U(A,A,C(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s45TB [Occ=Once] :: a_a42W2
                [LclId] =
                    [$dReal_s45Ty] \u []
                        case GHC.Real.$p1Real $dReal_s45Ty of sat_s45TA {
                          __DEFAULT -> GHC.Num.fromInteger sat_s45TA Numeric.showHFloat16;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s45Ty of sat_s45Tz {
                  __DEFAULT ->
                      case GHC.Classes.< sat_s45Tz eta_s45Tw sat_s45TB of {
                        GHC.Types.False ->
                            let {
                              lvl5_s45TD :: a_a42W2
                              [LclId] =
                                  [$dReal_s45Ty] \u []
                                      case GHC.Real.$p1Real $dReal_s45Ty of sat_s45TE {
                                        __DEFAULT -> GHC.Num.fromInteger sat_s45TE Numeric.showInt2;
                                      };
                            } in 
                              case
                                  GHC.Real.$p2Real $dReal_s45Ty
                              of
                              $dOrd_s45TF [Dmd=<S(LLC(C(S))LLLLL),U(A,A,C(C1(U)),A,A,A,A,A)>]
                              { __DEFAULT ->
                                    let-no-escape {
                                      exit_s45TG [Occ=OnceL!T[2], Dmd=<C(C(S)),C(C1(U))>]
                                        :: a_a42W2 -> [GHC.Types.Char] -> GHC.Base.String
                                      [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                          sat-only [$dIntegral_s45Tv] \r [n_s45TH cs_s45TI]
                                              case
                                                  GHC.Real.toInteger $dIntegral_s45Tv n_s45TH
                                              of
                                              sat_s45TJ
                                              { __DEFAULT ->
                                                    case
                                                        GHC.Integer.Type.integerToInt sat_s45TJ
                                                    of
                                                    wild1_s45TK
                                                    { __DEFAULT ->
                                                          case +# [48# wild1_s45TK] of sat_s45TL {
                                                            __DEFAULT ->
                                                                case chr# [sat_s45TL] of sat_s45TM {
                                                                  __DEFAULT ->
                                                                      let {
                                                                        sat_s45TN [Occ=Once]
                                                                          :: GHC.Types.Char
                                                                        [LclId] =
                                                                            CCCS GHC.Types.C#! [sat_s45TM];
                                                                      } in  : [sat_s45TN cs_s45TI];
                                                                };
                                                          };
                                                    };
                                              };
                                    } in 
                                      let-no-escape {
                                        go_s45TO [Occ=LoopBreakerT[2]]
                                          :: a_a42W2 -> [GHC.Types.Char] -> GHC.Base.String
                                        [LclId[JoinId(2)],
                                         Arity=2,
                                         Str=<L,U><L,U>,
                                         Unf=OtherCon []] =
                                            sat-only [$dIntegral_s45Tv
                                                      lvl5_s45TD
                                                      $dOrd_s45TF
                                                      exit_s45TG
                                                      go_s45TO] \r [n_s45TP cs_s45TQ]
                                                case
                                                    GHC.Classes.< $dOrd_s45TF n_s45TP lvl5_s45TD
                                                of
                                                { GHC.Types.False ->
                                                      let {
                                                        ds_s45TS [Dmd=<L,U(1*U,1*U)>]
                                                          :: (a_a42W2, a_a42W2)
                                                        [LclId] =
                                                            [$dIntegral_s45Tv
                                                             lvl5_s45TD
                                                             n_s45TP] \u []
                                                                GHC.Real.quotRem
                                                                    $dIntegral_s45Tv
                                                                    n_s45TP
                                                                    lvl5_s45TD; } in
                                                      let {
                                                        sat_s45TW [Occ=Once] :: a_a42W2
                                                        [LclId] =
                                                            [ds_s45TS] \u []
                                                                case ds_s45TS of {
                                                                  (,) _ [Occ=Dead]
                                                                      r_s45TV [Occ=Once] ->
                                                                      r_s45TV;
                                                                };
                                                      } in 
                                                        case
                                                            GHC.Real.toInteger
                                                                $dIntegral_s45Tv sat_s45TW
                                                        of
                                                        sat_s45TX
                                                        { __DEFAULT ->
                                                              case
                                                                  GHC.Integer.Type.integerToInt
                                                                      sat_s45TX
                                                              of
                                                              wild2_s45TY
                                                              { __DEFAULT ->
                                                                    case
                                                                        +# [48# wild2_s45TY]
                                                                    of
                                                                    sat_s45U3
                                                                    { __DEFAULT ->
                                                                          case
                                                                              chr# [sat_s45U3]
                                                                          of
                                                                          sat_s45U4
                                                                          { __DEFAULT ->
                                                                                let {
                                                                                  sat_s45U5 [Occ=Once]
                                                                                    :: GHC.Types.Char
                                                                                  [LclId] =
                                                                                      CCCS GHC.Types.C#! [sat_s45U4]; } in
                                                                                let {
                                                                                  sat_s45U6 [Occ=Once]
                                                                                    :: [GHC.Types.Char]
                                                                                  [LclId] =
                                                                                      CCCS :! [sat_s45U5
                                                                                               cs_s45TQ]; } in
                                                                                let {
                                                                                  sat_s45U2 [Occ=Once]
                                                                                    :: a_a42W2
                                                                                  [LclId] =
                                                                                      [ds_s45TS] \u []
                                                                                          case
                                                                                              ds_s45TS
                                                                                          of
                                                                                          { (,) q_s45U0 [Occ=Once]
                                                                                                _ [Occ=Dead] ->
                                                                                                q_s45U0;
                                                                                          };
                                                                                } in 
                                                                                  go_s45TO
                                                                                      sat_s45U2
                                                                                      sat_s45U6;
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  GHC.Types.True -> exit_s45TG n_s45TP cs_s45TQ;
                                                };
                                      } in  go_s45TO eta_s45Tw eta1_s45Tx;
                              };
                        GHC.Types.True -> Numeric.showInt1;
                      };
                };
        };

Numeric.showFFloatAlt
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Base.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s45U7 d_s45U8 x_s45U9]
        let {
          sat_s45Ua [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s45U7 d_s45U8 x_s45U9] \u []
                  GHC.Float.formatRealFloatAlt
                      $dRealFloat_s45U7 GHC.Float.FFFixed d_s45U8 GHC.Types.True x_s45U9;
        } in  GHC.Base.++ sat_s45Ua;

Numeric.showGFloatAlt
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Base.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s45Ub d_s45Uc x_s45Ud]
        let {
          sat_s45Ue [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s45Ub d_s45Uc x_s45Ud] \u []
                  GHC.Float.formatRealFloatAlt
                      $dRealFloat_s45Ub
                      GHC.Float.FFGeneric
                      d_s45Uc
                      GHC.Types.True
                      x_s45Ud;
        } in  GHC.Base.++ sat_s45Ue;

lvl1_r43OI :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Numeric.showIntAtBase: applied to negative number "#;

Numeric.$wlvl [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int# -> GHC.Base.String
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [ww_s45Uf]
        let {
          sat_s45Uj [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [ww_s45Uf] \u []
                  case GHC.Show.$wshowSignedInt 0# ww_s45Uf GHC.Types.[] of {
                    (#,#) ww5_s45Uh [Occ=Once] ww6_s45Ui [Occ=Once] ->
                        : [ww5_s45Uh ww6_s45Ui];
                  };
        } in 
          case
              GHC.CString.unpackAppendCString# lvl1_r43OI sat_s45Uj
          of
          sat_s45Uk
          { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s45Uk;
          };

lvl2_r43OJ :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Numeric.showIntAtBase: applied to unsupported base "#;

Numeric.showIntAtBase2
  :: forall a. GHC.Show.Show a => a -> GHC.Base.String
[GblId, Arity=2, Str=<B,1*U(A,1*C1(U),A)><B,U>x, Unf=OtherCon []] =
    [] \r [$dShow_s45Ul eta_s45Um]
        let {
          sat_s45Un [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s45Ul eta_s45Um] \u []
                  GHC.Show.show $dShow_s45Ul eta_s45Um;
        } in 
          case
              GHC.CString.unpackAppendCString# lvl1_r43OI sat_s45Un
          of
          sat_s45Uo
          { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s45Uo;
          };

Numeric.showIntAtBase1
  :: forall a. GHC.Show.Show a => a -> GHC.Base.String
[GblId, Arity=2, Str=<B,1*U(A,1*C1(U),A)><B,U>x, Unf=OtherCon []] =
    [] \r [$dShow_s45Up eta_s45Uq]
        let {
          sat_s45Ur [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s45Up eta_s45Uq] \u []
                  GHC.Show.show $dShow_s45Up eta_s45Uq;
        } in 
          case
              GHC.CString.unpackAppendCString# lvl2_r43OJ sat_s45Ur
          of
          sat_s45Us
          { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s45Us;
          };

sat_s45Ut :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s45Uu :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s45Ut GHC.Types.[]];

Numeric.showIntAtBase3 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s45Uu;

Numeric.showIntAtBase
  :: forall a.
     (GHC.Real.Integral a, GHC.Show.Show a) =>
     a -> (GHC.Types.Int -> GHC.Types.Char) -> a -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))C(C(S))LLLL)L)LLLLLC(C(S))LL),U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(U,U))),A,C(U))><L,1*U(A,1*C1(U),A)><L,U><C(S),C(U(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s45Uv
           $dShow_s45Uw
           eta_s45Ux
           eta1_s45Uy
           eta2_s45Uz
           eta3_s45UA]
        case
            GHC.Real.$p1Integral $dIntegral_s45Uv
        of
        $dReal_s45UB [Dmd=<S(LS(S(C(C(S))L)LC(C(S))C(C(S))LLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s45UC [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_a42NP
                [LclId] =
                    [$dReal_s45UB] \u [] GHC.Real.$p1Real $dReal_s45UB;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s45UB
                of
                $dOrd_s45UD [Dmd=<S(S(C(C(S))L)LC(C(S))C(C(S))LLLL),U(1*U(C(C1(U)),A),A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s45UE [Occ=Once] :: a_a42NP
                        [LclId] =
                            [$dNum_s45UC] \u []
                                GHC.Num.fromInteger $dNum_s45UC Numeric.showIntAtBase3;
                      } in 
                        case GHC.Classes.<= $dOrd_s45UD eta_s45Ux sat_s45UE of {
                          GHC.Types.False ->
                              let {
                                sat_s45UG [Occ=Once] :: a_a42NP
                                [LclId] =
                                    [$dNum_s45UC] \u []
                                        GHC.Num.fromInteger $dNum_s45UC Numeric.showHFloat16;
                              } in 
                                case GHC.Classes.< $dOrd_s45UD eta2_s45Uz sat_s45UG of {
                                  GHC.Types.False ->
                                      case
                                          GHC.Real.quotRem $dIntegral_s45Uv eta2_s45Uz eta_s45Ux
                                      of
                                      { (,) ww1_s45UJ [Occ=Once] ww2_s45UK [Occ=Once] ->
                                            let {
                                              lvl5_s45UL [Occ=OnceL] :: a_a42NP
                                              [LclId] =
                                                  [$dNum_s45UC] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s45UC Numeric.showHFloat16;
                                            } in 
                                              case
                                                  GHC.Classes.$p1Ord $dOrd_s45UD
                                              of
                                              $dEq_s45UM [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                              { __DEFAULT ->
                                                    let-no-escape {
                                                      $wshowIt5_s45UN [InlPrag=NOUSERINLINE[0],
                                                                       Occ=LoopBreakerT[3]]
                                                        :: a_a42NP
                                                           -> a_a42NP
                                                           -> [GHC.Types.Char]
                                                           -> GHC.Base.String
                                                      [LclId[JoinId(3)],
                                                       Arity=3,
                                                       Str=<L,U><L,U><L,U>,
                                                       Unf=OtherCon []] =
                                                          sat-only [$dIntegral_s45Uv
                                                                    eta_s45Ux
                                                                    eta1_s45Uy
                                                                    lvl5_s45UL
                                                                    $dEq_s45UM
                                                                    $wshowIt5_s45UN] \r [ww3_s45UO
                                                                                         ww4_s45UP
                                                                                         w_s45UQ]
                                                              let {
                                                                sat_s45UT [Occ=Once]
                                                                  :: GHC.Types.Int
                                                                [LclId] =
                                                                    [$dIntegral_s45Uv
                                                                     ww4_s45UP] \u []
                                                                        case
                                                                            GHC.Real.toInteger
                                                                                $dIntegral_s45Uv
                                                                                ww4_s45UP
                                                                        of
                                                                        sat_s45UR
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  GHC.Integer.Type.integerToInt
                                                                                      sat_s45UR
                                                                              of
                                                                              wild2_s45US
                                                                              { __DEFAULT ->
                                                                                    GHC.Types.I# [wild2_s45US];
                                                                              };
                                                                        };
                                                              } in 
                                                                case
                                                                    eta1_s45Uy sat_s45UT
                                                                of
                                                                v_s45UU
                                                                { GHC.Types.C# _ [Occ=Dead] ->
                                                                      case
                                                                          GHC.Classes.==
                                                                              $dEq_s45UM
                                                                              ww3_s45UO
                                                                              lvl5_s45UL
                                                                      of
                                                                      { GHC.Types.False ->
                                                                            case
                                                                                GHC.Real.quotRem
                                                                                    $dIntegral_s45Uv
                                                                                    ww3_s45UO
                                                                                    eta_s45Ux
                                                                            of
                                                                            { (,) ww6_s45UY [Occ=Once]
                                                                                  ww7_s45UZ [Occ=Once] ->
                                                                                  let {
                                                                                    sat_s45V0 [Occ=Once]
                                                                                      :: [GHC.Types.Char]
                                                                                    [LclId] =
                                                                                        CCCS :! [v_s45UU
                                                                                                 w_s45UQ];
                                                                                  } in 
                                                                                    $wshowIt5_s45UN
                                                                                        ww6_s45UY
                                                                                        ww7_s45UZ
                                                                                        sat_s45V0;
                                                                            };
                                                                        GHC.Types.True ->
                                                                            : [v_s45UU w_s45UQ];
                                                                      };
                                                                };
                                                    } in 
                                                      $wshowIt5_s45UN
                                                          ww1_s45UJ ww2_s45UK eta3_s45UA;
                                              };
                                      };
                                  GHC.Types.True -> Numeric.showIntAtBase2 $dShow_s45Uw eta2_s45Uz;
                                };
                          GHC.Types.True -> Numeric.showIntAtBase1 $dShow_s45Uw eta_s45Ux;
                        };
                };
        };

sat_s45V1 :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [16#];

sat_s45V2 :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s45V1 GHC.Types.[]];

Numeric.showHex1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s45V2;

Numeric.showHex
  :: forall a.
     (GHC.Real.Integral a, GHC.Show.Show a) =>
     a -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(U,U))),A,C(U))><L,U(A,C(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s45V3 $dShow_s45V4]
        let {
          sat_s45V7 [Occ=Once] :: a_a42Pa
          [LclId] =
              [$dIntegral_s45V3] \u []
                  case GHC.Real.$p1Integral $dIntegral_s45V3 of sat_s45V5 {
                    __DEFAULT ->
                        case GHC.Real.$p1Real sat_s45V5 of sat_s45V6 {
                          __DEFAULT -> GHC.Num.fromInteger sat_s45V6 Numeric.showHex1;
                        };
                  };
        } in 
          Numeric.showIntAtBase
              $dIntegral_s45V3 $dShow_s45V4 sat_s45V7 GHC.Show.intToDigit;

Numeric.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

loc_r43OK :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.$trModule4;

Numeric.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Numeric"#;

loc1_r43OL :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.$trModule2;

loc2_r43OM :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Numeric.hs"#;

loc3_r43ON :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# loc2_r43OM;

loc4_r43OO :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [241#];

loc5_r43OP :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [22#];

loc6_r43OQ :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [75#];

$dIP_r43OR :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "error"#;

$dIP1_r43OS :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# $dIP_r43OR;

$dIP2_r43OT :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [loc_r43OK
                                           loc1_r43OL
                                           loc3_r43ON
                                           loc4_r43OO
                                           loc5_r43OP
                                           loc4_r43OO
                                           loc6_r43OQ];

$dIP3_r43OU :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [$dIP1_r43OS
                                                  $dIP2_r43OT
                                                  GHC.Stack.Types.EmptyCallStack];

lvl3_r43OV :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Impossible happened: showHFloat: "#;

lvl4_r43OW :: [GHC.Types.Char]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [GHC.Show.$fShow(,)2 GHC.Types.[]];

$wlvl2_r43OX
  :: [GHC.Types.Int] -> GHC.Prim.Int# -> [GHC.Types.Char]
[GblId, Arity=2, Str=<B,U><B,U>x, Unf=OtherCon []] =
    sat-only [] \r [ww_s45V8 ww1_s45V9]
        let {
          sat_s45Vi [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [ww_s45V8 ww1_s45V9] \u []
                  let {
                    sat_s45Vf [Occ=Once] :: GHC.Show.ShowS
                    [LclId] =
                        [ww1_s45V9] \r [w2_s45Vb]
                            case GHC.Show.$wshowSignedInt 0# ww1_s45V9 w2_s45Vb of {
                              (#,#) ww5_s45Vd [Occ=Once] ww6_s45Ve [Occ=Once] ->
                                  : [ww5_s45Vd ww6_s45Ve];
                            }; } in
                  let {
                    sat_s45Vg [Occ=Once] :: [GHC.Show.ShowS]
                    [LclId] =
                        CCCS :! [sat_s45Vf GHC.Types.[]]; } in
                  let {
                    sat_s45Va [Occ=Once] :: GHC.Show.ShowS
                    [LclId] =
                        [ww_s45V8] \r [eta_B1]
                            GHC.Show.$fShowInt_$cshowList ww_s45V8 eta_B1; } in
                  let {
                    sat_s45Vh [Occ=Once] :: [GHC.Base.String -> GHC.Base.String]
                    [LclId] =
                        CCCS :! [sat_s45Va sat_s45Vg];
                  } in  GHC.Show.$fShow(,)_go1 sat_s45Vh lvl4_r43OW; } in
        let {
          sat_s45Vj [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              CCCS :! [GHC.Show.$fShow(,)4 sat_s45Vi];
        } in 
          case
              GHC.CString.unpackAppendCString# lvl3_r43OV sat_s45Vj
          of
          sat_s45Vk
          { __DEFAULT -> GHC.Err.error $dIP3_r43OU sat_s45Vk;
          };

Numeric.showHFloat_allZ [Occ=LoopBreaker]
  :: [GHC.Types.Int] -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [xs_s45Vl]
        case xs_s45Vl of {
          [] -> GHC.Types.True [];
          : x_s45Vn [Occ=Once!] more_s45Vo [Occ=Once] ->
              case x_s45Vn of {
                GHC.Types.I# x1_s45Vq [Occ=Once!] ->
                    case x1_s45Vq of {
                      __DEFAULT -> GHC.Types.False [];
                      0# -> Numeric.showHFloat_allZ more_s45Vo;
                    };
              };
        };

$wshowIt1_r43OY
  :: GHC.Prim.Int#
     -> GHC.Types.Int -> [GHC.Types.Char] -> [GHC.Types.Char]
[GblId,
 Arity=3,
 Str=<S,1*U><S(S),1*U(U)><L,U>m2,
 Unf=OtherCon []] =
    sat-only [] \r [ww_s45Vs ww1_s45Vt w_s45Vu]
        case ww1_s45Vt of {
          GHC.Types.I# ww3_s45Vw [Occ=Once] ->
              case GHC.Show.$wintToDigit ww3_s45Vw of ww4_s45Vx {
                __DEFAULT ->
                    case ww_s45Vs of wild_s45Vy {
                      __DEFAULT ->
                          case quotRemInt# [wild_s45Vy 16#] of {
                            (#,#) ipv_s45VA [Occ=Once] ipv1_s45VB [Occ=Once] ->
                                let {
                                  sat_s45VD [Occ=Once] :: GHC.Types.Char
                                  [LclId] =
                                      CCCS GHC.Types.C#! [ww4_s45Vx]; } in
                                let {
                                  sat_s45VE [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      CCCS :! [sat_s45VD w_s45Vu]; } in
                                let {
                                  sat_s45VC [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s45VB];
                                } in  $wshowIt1_r43OY ipv_s45VA sat_s45VC sat_s45VE;
                          };
                      0# ->
                          let {
                            sat_s45VF [Occ=Once] :: GHC.Types.Char
                            [LclId] =
                                CCCS GHC.Types.C#! [ww4_s45Vx];
                          } in  : [sat_s45VF w_s45Vu];
                    };
              };
        };

$wshowIt2_r43OZ
  :: GHC.Prim.Int#
     -> GHC.Types.Int -> [GHC.Types.Char] -> [GHC.Types.Char]
[GblId,
 Arity=3,
 Str=<S,1*U><S(S),1*U(U)><L,U>m2,
 Unf=OtherCon []] =
    sat-only [] \r [ww_s45VG ww1_s45VH w_s45VI]
        case ww1_s45VH of {
          GHC.Types.I# ww3_s45VK [Occ=Once] ->
              case GHC.Show.$wintToDigit ww3_s45VK of ww4_s45VL {
                __DEFAULT ->
                    case ww_s45VG of wild_s45VM {
                      __DEFAULT ->
                          case quotRemInt# [wild_s45VM 16#] of {
                            (#,#) ipv_s45VO [Occ=Once] ipv1_s45VP [Occ=Once] ->
                                let {
                                  sat_s45VR [Occ=Once] :: GHC.Types.Char
                                  [LclId] =
                                      CCCS GHC.Types.C#! [ww4_s45VL]; } in
                                let {
                                  sat_s45VS [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      CCCS :! [sat_s45VR w_s45VI]; } in
                                let {
                                  sat_s45VQ [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s45VP];
                                } in  $wshowIt2_r43OZ ipv_s45VO sat_s45VQ sat_s45VS;
                          };
                      0# ->
                          let {
                            sat_s45VT [Occ=Once] :: GHC.Types.Char
                            [LclId] =
                                CCCS GHC.Types.C#! [ww4_s45VL];
                          } in  : [sat_s45VT w_s45VI];
                    };
              };
        };

$wshowIt3_r43P0
  :: GHC.Prim.Int#
     -> GHC.Types.Int -> [GHC.Types.Char] -> [GHC.Types.Char]
[GblId,
 Arity=3,
 Str=<S,1*U><S(S),1*U(U)><L,U>m2,
 Unf=OtherCon []] =
    sat-only [] \r [ww_s45VU ww1_s45VV w_s45VW]
        case ww1_s45VV of {
          GHC.Types.I# ww3_s45VY [Occ=Once] ->
              case GHC.Show.$wintToDigit ww3_s45VY of ww4_s45VZ {
                __DEFAULT ->
                    case ww_s45VU of wild_s45W0 {
                      __DEFAULT ->
                          case quotRemInt# [wild_s45W0 16#] of {
                            (#,#) ipv_s45W2 [Occ=Once] ipv1_s45W3 [Occ=Once] ->
                                let {
                                  sat_s45W5 [Occ=Once] :: GHC.Types.Char
                                  [LclId] =
                                      CCCS GHC.Types.C#! [ww4_s45VZ]; } in
                                let {
                                  sat_s45W6 [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      CCCS :! [sat_s45W5 w_s45VW]; } in
                                let {
                                  sat_s45W4 [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s45W3];
                                } in  $wshowIt3_r43P0 ipv_s45W2 sat_s45W4 sat_s45W6;
                          };
                      0# ->
                          let {
                            sat_s45W7 [Occ=Once] :: GHC.Types.Char
                            [LclId] =
                                CCCS GHC.Types.C#! [ww4_s45VZ];
                          } in  : [sat_s45W7 w_s45VW];
                    };
              };
        };

$wshowIt4_r43P1
  :: GHC.Prim.Int#
     -> GHC.Types.Int -> [GHC.Types.Char] -> [GHC.Types.Char]
[GblId,
 Arity=3,
 Str=<S,1*U><S(S),1*U(U)><L,U>m2,
 Unf=OtherCon []] =
    sat-only [] \r [ww_s45W8 ww1_s45W9 w_s45Wa]
        case ww1_s45W9 of {
          GHC.Types.I# ww3_s45Wc [Occ=Once] ->
              case GHC.Show.$wintToDigit ww3_s45Wc of ww4_s45Wd {
                __DEFAULT ->
                    case ww_s45W8 of wild_s45We {
                      __DEFAULT ->
                          case quotRemInt# [wild_s45We 16#] of {
                            (#,#) ipv_s45Wg [Occ=Once] ipv1_s45Wh [Occ=Once] ->
                                let {
                                  sat_s45Wj [Occ=Once] :: GHC.Types.Char
                                  [LclId] =
                                      CCCS GHC.Types.C#! [ww4_s45Wd]; } in
                                let {
                                  sat_s45Wk [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      CCCS :! [sat_s45Wj w_s45Wa]; } in
                                let {
                                  sat_s45Wi [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s45Wh];
                                } in  $wshowIt4_r43P1 ipv_s45Wg sat_s45Wi sat_s45Wk;
                          };
                      0# ->
                          let {
                            sat_s45Wl [Occ=Once] :: GHC.Types.Char
                            [LclId] =
                                CCCS GHC.Types.C#! [ww4_s45Wd];
                          } in  : [sat_s45Wl w_s45Wa];
                    };
              };
        };

Numeric.showHFloat_hex [Occ=LoopBreaker]
  :: [GHC.Types.Int] -> GHC.Base.String
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s45Wm]
        case ds_s45Wm of {
          [] -> [] [];
          : a_s45Wo [Occ=Once*!] ds1_s45Wp [Occ=Once!] ->
              case ds1_s45Wp of {
                [] ->
                    case a_s45Wo of {
                      GHC.Types.I# y_s45Ws [Occ=Once] ->
                          case *# [8# y_s45Ws] of ww_s45Wt [Dmd=<S,U>] {
                            __DEFAULT ->
                                case <# [ww_s45Wt 0#] of {
                                  __DEFAULT ->
                                      case quotRemInt# [ww_s45Wt 16#] of {
                                        (#,#) ipv_s45Ww [Occ=Once] ipv1_s45Wx [Occ=Once] ->
                                            let {
                                              sat_s45Wy [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv1_s45Wx];
                                            } in  $wshowIt4_r43P1 ipv_s45Ww sat_s45Wy GHC.Types.[];
                                      };
                                  1# -> Numeric.$wlvl ww_s45Wt;
                                };
                          };
                    };
                : b_s45Wz [Occ=Once*!] ds2_s45WA [Occ=Once!] ->
                    case ds2_s45WA of {
                      [] ->
                          case a_s45Wo of {
                            GHC.Types.I# y_s45WD [Occ=Once] ->
                                case b_s45Wz of {
                                  GHC.Types.I# y1_s45WF [Occ=Once] ->
                                      case *# [4# y1_s45WF] of sat_s45WI {
                                        __DEFAULT ->
                                            case *# [8# y_s45WD] of sat_s45WH {
                                              __DEFAULT ->
                                                  case
                                                      +# [sat_s45WH sat_s45WI]
                                                  of
                                                  ww_s45WG [Dmd=<S,U>]
                                                  { __DEFAULT ->
                                                        case <# [ww_s45WG 0#] of {
                                                          __DEFAULT ->
                                                              case quotRemInt# [ww_s45WG 16#] of {
                                                                (#,#) ipv_s45WL [Occ=Once]
                                                                      ipv1_s45WM [Occ=Once] ->
                                                                    let {
                                                                      sat_s45WN [Occ=Once]
                                                                        :: GHC.Types.Int
                                                                      [LclId] =
                                                                          CCCS GHC.Types.I#! [ipv1_s45WM];
                                                                    } in 
                                                                      $wshowIt3_r43P0
                                                                          ipv_s45WL
                                                                          sat_s45WN
                                                                          GHC.Types.[];
                                                              };
                                                          1# -> Numeric.$wlvl ww_s45WG;
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                      : c_s45WO [Occ=Once*!] ds3_s45WP [Occ=Once!] ->
                          case ds3_s45WP of {
                            [] ->
                                case a_s45Wo of {
                                  GHC.Types.I# y_s45WS [Occ=Once] ->
                                      case b_s45Wz of {
                                        GHC.Types.I# y1_s45WU [Occ=Once] ->
                                            case c_s45WO of {
                                              GHC.Types.I# y2_s45WW [Occ=Once] ->
                                                  case *# [2# y2_s45WW] of sat_s45X1 {
                                                    __DEFAULT ->
                                                        case *# [4# y1_s45WU] of sat_s45WZ {
                                                          __DEFAULT ->
                                                              case *# [8# y_s45WS] of sat_s45WY {
                                                                __DEFAULT ->
                                                                    case
                                                                        +# [sat_s45WY sat_s45WZ]
                                                                    of
                                                                    sat_s45X0
                                                                    { __DEFAULT ->
                                                                          case
                                                                              +# [sat_s45X0
                                                                                  sat_s45X1]
                                                                          of
                                                                          ww_s45WX [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    <# [ww_s45WX 0#]
                                                                                of
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          quotRemInt# [ww_s45WX
                                                                                                       16#]
                                                                                      of
                                                                                      { (#,#) ipv_s45X4 [Occ=Once]
                                                                                              ipv1_s45X5 [Occ=Once] ->
                                                                                            let {
                                                                                              sat_s45X6 [Occ=Once]
                                                                                                :: GHC.Types.Int
                                                                                              [LclId] =
                                                                                                  CCCS GHC.Types.I#! [ipv1_s45X5];
                                                                                            } in 
                                                                                              $wshowIt2_r43OZ
                                                                                                  ipv_s45X4
                                                                                                  sat_s45X6
                                                                                                  GHC.Types.[];
                                                                                      };
                                                                                  1# ->
                                                                                      Numeric.$wlvl
                                                                                          ww_s45WX;
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                            : d_s45X7 [Occ=Once!] r_s45X8 [Occ=Once] ->
                                case a_s45Wo of {
                                  GHC.Types.I# y_s45Xa [Occ=Once] ->
                                      case b_s45Wz of {
                                        GHC.Types.I# y1_s45Xc [Occ=Once] ->
                                            case c_s45WO of {
                                              GHC.Types.I# y2_s45Xe [Occ=Once] ->
                                                  case d_s45X7 of {
                                                    GHC.Types.I# y3_s45Xg [Occ=Once] ->
                                                        case *# [2# y2_s45Xe] of sat_s45Xl {
                                                          __DEFAULT ->
                                                              case *# [4# y1_s45Xc] of sat_s45Xj {
                                                                __DEFAULT ->
                                                                    case
                                                                        *# [8# y_s45Xa]
                                                                    of
                                                                    sat_s45Xi
                                                                    { __DEFAULT ->
                                                                          case
                                                                              +# [sat_s45Xi
                                                                                  sat_s45Xj]
                                                                          of
                                                                          sat_s45Xk
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    +# [sat_s45Xk
                                                                                        sat_s45Xl]
                                                                                of
                                                                                sat_s45Xm
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          +# [sat_s45Xm
                                                                                              y3_s45Xg]
                                                                                      of
                                                                                      ww_s45Xh [Dmd=<S,U>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                <# [ww_s45Xh
                                                                                                    0#]
                                                                                            of
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      quotRemInt# [ww_s45Xh
                                                                                                                   16#]
                                                                                                  of
                                                                                                  { (#,#) ipv_s45Xp [Occ=Once]
                                                                                                          ipv1_s45Xq [Occ=Once] ->
                                                                                                        let {
                                                                                                          sat_s45Xs [Occ=Once]
                                                                                                            :: [GHC.Types.Char]
                                                                                                          [LclId] =
                                                                                                              [r_s45X8] \u []
                                                                                                                  Numeric.showHFloat_hex
                                                                                                                      r_s45X8; } in
                                                                                                        let {
                                                                                                          sat_s45Xr [Occ=Once]
                                                                                                            :: GHC.Types.Int
                                                                                                          [LclId] =
                                                                                                              CCCS GHC.Types.I#! [ipv1_s45Xq];
                                                                                                        } in 
                                                                                                          $wshowIt1_r43OY
                                                                                                              ipv_s45Xp
                                                                                                              sat_s45Xr
                                                                                                              sat_s45Xs;
                                                                                                  };
                                                                                              1# ->
                                                                                                  Numeric.$wlvl
                                                                                                      ww_s45Xh;
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

sat_s45Xt :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

sat_s45Xu :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s45Xt GHC.Types.[]];

Numeric.showHFloat15 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s45Xu;

Numeric.showHFloat10 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "0x0p+0"#;

Numeric.showHFloat9 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.showHFloat10;

Numeric.showHFloat14 :: GHC.Prim.Int# -> [GHC.Types.Char]
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [ww_s45Xv] $wlvl2_r43OX GHC.Types.[] ww_s45Xv;

Numeric.showHFloat13 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "0x"#;

Numeric.showHFloat12 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "p"#;

Numeric.showHFloat11 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "."#;

Numeric.showHFloat_cvt
  :: forall a. GHC.Float.RealFloat a => a -> [GHC.Types.Char]
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s45Xw eta_s45Xx]
        case
            GHC.Float.$p1RealFloat $dRealFloat_s45Xw
        of
        $dRealFrac_s45Xy [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_s45Xy
              of
              $dReal_s45Xz [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    let {
                      sat_s45XD [Occ=Once] :: a_a42SJ
                      [LclId] =
                          [$dReal_s45Xz] \u []
                              case GHC.Real.$p1Real $dReal_s45Xz of sat_s45XC {
                                __DEFAULT -> GHC.Num.fromInteger sat_s45XC Numeric.showHFloat16;
                              };
                    } in 
                      case GHC.Real.$p2Real $dReal_s45Xz of sat_s45XA {
                        __DEFAULT ->
                            case GHC.Classes.$p1Ord sat_s45XA of sat_s45XB {
                              __DEFAULT ->
                                  case GHC.Classes.== sat_s45XB eta_s45Xx sat_s45XD of {
                                    GHC.Types.False ->
                                        case
                                            GHC.Float.$wfloatToDigits
                                                $dRealFloat_s45Xw Numeric.showHFloat15 eta_s45Xx
                                        of
                                        { (#,#) ww1_s45XG [Occ=Once!] ww2_s45XH [Occ=Once*!] ->
                                              case ww1_s45XG of {
                                                [] ->
                                                    case ww2_s45XH of {
                                                      GHC.Types.I# ww5_s45XK [Occ=Once] ->
                                                          Numeric.showHFloat14 ww5_s45XK;
                                                    };
                                                : d_s45XL [Occ=Once!] ds_s45XM ->
                                                    let {
                                                      sat_s45Y5 [Occ=Once] :: [GHC.Types.Char]
                                                      [LclId] =
                                                          [ww2_s45XH d_s45XL ds_s45XM] \u []
                                                              case d_s45XL of {
                                                                GHC.Types.I# ww3_s45XO [Occ=Once] ->
                                                                    case
                                                                        GHC.Show.$wshowSignedInt
                                                                            0#
                                                                            ww3_s45XO
                                                                            GHC.Types.[]
                                                                    of
                                                                    { (#,#) ww6_s45XQ [Occ=Once]
                                                                            ww7_s45XR [Occ=Once] ->
                                                                          let {
                                                                            sat_s45Y4 [Occ=Once,
                                                                                       Dmd=<L,1*U>]
                                                                              :: [GHC.Types.Char]
                                                                            [LclId] =
                                                                                [ww2_s45XH
                                                                                 ds_s45XM] \s []
                                                                                    let {
                                                                                      n_s45XT [Occ=Once*,
                                                                                               Dmd=<L,1*U>]
                                                                                        :: [GHC.Types.Char]
                                                                                      [LclId] =
                                                                                          [ww2_s45XH] \s []
                                                                                              let {
                                                                                                sat_s45Y0 [Occ=Once]
                                                                                                  :: [GHC.Types.Char]
                                                                                                [LclId] =
                                                                                                    [ww2_s45XH] \u []
                                                                                                        case
                                                                                                            ww2_s45XH
                                                                                                        of
                                                                                                        { GHC.Types.I# x_s45XV [Occ=Once] ->
                                                                                                              case
                                                                                                                  -# [x_s45XV
                                                                                                                      1#]
                                                                                                              of
                                                                                                              sat_s45XW
                                                                                                              { __DEFAULT ->
                                                                                                                    case
                                                                                                                        GHC.Show.$wshowSignedInt
                                                                                                                            0#
                                                                                                                            sat_s45XW
                                                                                                                            GHC.Types.[]
                                                                                                                    of
                                                                                                                    { (#,#) ww9_s45XY [Occ=Once]
                                                                                                                            ww10_s45XZ [Occ=Once] ->
                                                                                                                          : [ww9_s45XY
                                                                                                                             ww10_s45XZ];
                                                                                                                    };
                                                                                                              };
                                                                                                        };
                                                                                              } in 
                                                                                                GHC.CString.unpackAppendCString#
                                                                                                    Numeric.showHFloat12
                                                                                                    sat_s45Y0;
                                                                                    } in 
                                                                                      case
                                                                                          Numeric.showHFloat_allZ
                                                                                              ds_s45XM
                                                                                      of
                                                                                      { GHC.Types.False ->
                                                                                            let {
                                                                                              sat_s45Y3 [Occ=Once]
                                                                                                :: [GHC.Types.Char]
                                                                                              [LclId] =
                                                                                                  [ds_s45XM
                                                                                                   n_s45XT] \u []
                                                                                                      case
                                                                                                          Numeric.showHFloat_hex
                                                                                                              ds_s45XM
                                                                                                      of
                                                                                                      sat_s45Y2
                                                                                                      { __DEFAULT ->
                                                                                                            GHC.Base.++
                                                                                                                sat_s45Y2
                                                                                                                n_s45XT;
                                                                                                      };
                                                                                            } in 
                                                                                              GHC.CString.unpackAppendCString#
                                                                                                  Numeric.showHFloat11
                                                                                                  sat_s45Y3;
                                                                                        GHC.Types.True ->
                                                                                            n_s45XT;
                                                                                      }; } in
                                                                          let {
                                                                            sat_s45XS [Occ=Once]
                                                                              :: [GHC.Types.Char]
                                                                            [LclId] =
                                                                                CCCS :! [ww6_s45XQ
                                                                                         ww7_s45XR];
                                                                          } in 
                                                                            GHC.Base.++
                                                                                sat_s45XS sat_s45Y4;
                                                                    };
                                                              };
                                                    } in 
                                                      GHC.CString.unpackAppendCString#
                                                          Numeric.showHFloat13 sat_s45Y5;
                                              };
                                        };
                                    GHC.Types.True -> Numeric.showHFloat9;
                                  };
                            };
                      };
              };
        };

Numeric.showHFloat8 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! ['-'#];

Numeric.showHFloat5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Infinity"#;

Numeric.showHFloat7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "-"#;

Numeric.showHFloat6 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.showHFloat7;

Numeric.showHFloat2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NaN"#;

Numeric.showHFloat1 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.showHFloat2;

Numeric.showHFloat4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.showHFloat5;

Numeric.showHFloat3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.Base.++ Numeric.showHFloat6 Numeric.showHFloat4;

Numeric.showHFloat
  :: forall a. GHC.Float.RealFloat a => a -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Str=<L,U(U(U(U(A,A,A,1*C1(U),A,A,C(U)),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,1*C1(U),1*C1(U),A,1*C1(U),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s45Y6 eta_s45Y7]
        let {
          sat_s45Yo [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s45Y6 eta_s45Y7] \u []
                  case GHC.Float.isNaN $dRealFloat_s45Y6 eta_s45Y7 of {
                    GHC.Types.False ->
                        case
                            GHC.Float.$p1RealFloat $dRealFloat_s45Y6
                        of
                        $dRealFrac_s45Y9 [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),1*U(1*U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A)>]
                        { __DEFAULT ->
                              case
                                  GHC.Real.$p1RealFrac $dRealFrac_s45Y9
                              of
                              $dReal_s45Ya [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
                              { __DEFAULT ->
                                    let {
                                      $dNum_s45Yb [Dmd=<L,U(A,A,A,1*C1(U),A,A,1*C1(U))>]
                                        :: GHC.Num.Num a_a42Pu
                                      [LclId] =
                                          [$dReal_s45Ya] \u [] GHC.Real.$p1Real $dReal_s45Ya;
                                    } in 
                                      case GHC.Float.isInfinite $dRealFloat_s45Y6 eta_s45Y7 of {
                                        GHC.Types.False ->
                                            let {
                                              sat_s45Ye [Occ=Once] :: a_a42Pu
                                              [LclId] =
                                                  [$dNum_s45Yb] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s45Yb Numeric.showHFloat16;
                                            } in 
                                              case GHC.Real.$p2Real $dReal_s45Ya of sat_s45Yd {
                                                __DEFAULT ->
                                                    case
                                                        GHC.Classes.< sat_s45Yd eta_s45Y7 sat_s45Ye
                                                    of
                                                    { GHC.Types.False ->
                                                          case
                                                              GHC.Float.isNegativeZero
                                                                  $dRealFloat_s45Y6 eta_s45Y7
                                                          of
                                                          { GHC.Types.False ->
                                                                Numeric.showHFloat_cvt
                                                                    $dRealFloat_s45Y6 eta_s45Y7;
                                                            GHC.Types.True ->
                                                                let {
                                                                  sat_s45Yi [Occ=Once]
                                                                    :: [GHC.Types.Char]
                                                                  [LclId] =
                                                                      [$dRealFloat_s45Y6
                                                                       eta_s45Y7
                                                                       $dNum_s45Yb] \u []
                                                                          let {
                                                                            sat_s45Yh [Occ=Once]
                                                                              :: a_a42Pu
                                                                            [LclId] =
                                                                                [eta_s45Y7
                                                                                 $dNum_s45Yb] \u []
                                                                                    GHC.Num.negate
                                                                                        $dNum_s45Yb
                                                                                        eta_s45Y7;
                                                                          } in 
                                                                            Numeric.showHFloat_cvt
                                                                                $dRealFloat_s45Y6
                                                                                sat_s45Yh;
                                                                } in 
                                                                  : [Numeric.showHFloat8 sat_s45Yi];
                                                          };
                                                      GHC.Types.True ->
                                                          let {
                                                            sat_s45Yk [Occ=Once] :: [GHC.Types.Char]
                                                            [LclId] =
                                                                [$dRealFloat_s45Y6
                                                                 eta_s45Y7
                                                                 $dNum_s45Yb] \u []
                                                                    let {
                                                                      sat_s45Yj [Occ=Once]
                                                                        :: a_a42Pu
                                                                      [LclId] =
                                                                          [eta_s45Y7
                                                                           $dNum_s45Yb] \u []
                                                                              GHC.Num.negate
                                                                                  $dNum_s45Yb
                                                                                  eta_s45Y7;
                                                                    } in 
                                                                      Numeric.showHFloat_cvt
                                                                          $dRealFloat_s45Y6
                                                                          sat_s45Yj;
                                                          } in  : [Numeric.showHFloat8 sat_s45Yk];
                                                    };
                                              };
                                        GHC.Types.True ->
                                            let {
                                              sat_s45Ym [Occ=Once] :: a_a42Pu
                                              [LclId] =
                                                  [$dNum_s45Yb] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s45Yb Numeric.showHFloat16;
                                            } in 
                                              case GHC.Real.$p2Real $dReal_s45Ya of sat_s45Yl {
                                                __DEFAULT ->
                                                    case
                                                        GHC.Classes.< sat_s45Yl eta_s45Y7 sat_s45Ym
                                                    of
                                                    { GHC.Types.False -> Numeric.showHFloat4;
                                                      GHC.Types.True -> Numeric.showHFloat3;
                                                    };
                                              };
                                      };
                              };
                        };
                    GHC.Types.True -> Numeric.showHFloat1;
                  };
        } in  GHC.Base.++ sat_s45Yo;

sat_s45Yp :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [8#];

sat_s45Yq :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s45Yp GHC.Types.[]];

Numeric.showOct1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s45Yq;

Numeric.showOct
  :: forall a.
     (GHC.Real.Integral a, GHC.Show.Show a) =>
     a -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(U,U))),A,C(U))><L,U(A,C(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s45Yr $dShow_s45Ys]
        let {
          sat_s45Yv [Occ=Once] :: a_a42Pk
          [LclId] =
              [$dIntegral_s45Yr] \u []
                  case GHC.Real.$p1Integral $dIntegral_s45Yr of sat_s45Yt {
                    __DEFAULT ->
                        case GHC.Real.$p1Real sat_s45Yt of sat_s45Yu {
                          __DEFAULT -> GHC.Num.fromInteger sat_s45Yu Numeric.showOct1;
                        };
                  };
        } in 
          Numeric.showIntAtBase
              $dIntegral_s45Yr $dShow_s45Ys sat_s45Yv GHC.Show.intToDigit;

Numeric.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Numeric.$trModule4];

Numeric.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Numeric.$trModule2];

Numeric.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Numeric.$trModule3
                                     Numeric.$trModule1];

Numeric.showGFloat_$sshowGFloat
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Float -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s45Yw x_s45Yx]
        let {
          sat_s45YA [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s45Yw x_s45Yx] \u []
                  case x_s45Yx of {
                    GHC.Types.F# ww1_s45Yz [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt1
                            GHC.Float.FFGeneric d_s45Yw GHC.Types.False ww1_s45Yz;
                  };
        } in  GHC.Base.++ sat_s45YA;

Numeric.showFFloat_$sshowFFloat
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Float -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s45YB x_s45YC]
        let {
          sat_s45YF [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s45YB x_s45YC] \u []
                  case x_s45YC of {
                    GHC.Types.F# ww1_s45YE [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt1
                            GHC.Float.FFFixed d_s45YB GHC.Types.False ww1_s45YE;
                  };
        } in  GHC.Base.++ sat_s45YF;

Numeric.showEFloat_$sshowEFloat
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Float -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s45YG x_s45YH]
        let {
          sat_s45YK [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s45YG x_s45YH] \u []
                  case x_s45YH of {
                    GHC.Types.F# ww1_s45YJ [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt1
                            GHC.Float.FFExponent d_s45YG GHC.Types.False ww1_s45YJ;
                  };
        } in  GHC.Base.++ sat_s45YK;

Numeric.showGFloat_$sshowGFloat1
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Double -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s45YL x_s45YM]
        let {
          sat_s45YP [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s45YL x_s45YM] \u []
                  case x_s45YM of {
                    GHC.Types.D# ww1_s45YO [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt
                            GHC.Float.FFGeneric d_s45YL GHC.Types.False ww1_s45YO;
                  };
        } in  GHC.Base.++ sat_s45YP;

Numeric.showGFloat
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Base.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s45YQ d_s45YR x_s45YS]
        let {
          sat_s45YT [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s45YQ d_s45YR x_s45YS] \u []
                  GHC.Float.formatRealFloatAlt
                      $dRealFloat_s45YQ
                      GHC.Float.FFGeneric
                      d_s45YR
                      GHC.Types.False
                      x_s45YS;
        } in  GHC.Base.++ sat_s45YT;

Numeric.showFFloat_$sshowFFloat1
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Double -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s45YU x_s45YV]
        let {
          sat_s45YY [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s45YU x_s45YV] \u []
                  case x_s45YV of {
                    GHC.Types.D# ww1_s45YX [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt
                            GHC.Float.FFFixed d_s45YU GHC.Types.False ww1_s45YX;
                  };
        } in  GHC.Base.++ sat_s45YY;

Numeric.showFFloat
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Base.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s45YZ d_s45Z0 x_s45Z1]
        let {
          sat_s45Z2 [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s45YZ d_s45Z0 x_s45Z1] \u []
                  GHC.Float.formatRealFloatAlt
                      $dRealFloat_s45YZ
                      GHC.Float.FFFixed
                      d_s45Z0
                      GHC.Types.False
                      x_s45Z1;
        } in  GHC.Base.++ sat_s45Z2;

Numeric.showEFloat_$sshowEFloat1
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Double -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s45Z3 x_s45Z4]
        let {
          sat_s45Z7 [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s45Z3 x_s45Z4] \u []
                  case x_s45Z4 of {
                    GHC.Types.D# ww1_s45Z6 [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt
                            GHC.Float.FFExponent d_s45Z3 GHC.Types.False ww1_s45Z6;
                  };
        } in  GHC.Base.++ sat_s45Z7;

Numeric.showEFloat
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Base.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s45Z8 d_s45Z9 x_s45Za]
        let {
          sat_s45Zb [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s45Z8 d_s45Z9 x_s45Za] \u []
                  GHC.Float.formatRealFloatAlt
                      $dRealFloat_s45Z8
                      GHC.Float.FFExponent
                      d_s45Z9
                      GHC.Types.False
                      x_s45Za;
        } in  GHC.Base.++ sat_s45Zb;


==================== STG syntax: ====================
2018-03-16 15:58:59.17097124 UTC

Numeric.readInt
  :: forall a.
     GHC.Num.Num a =>
     a
     -> (GHC.Types.Char -> GHC.Types.Bool)
     -> (GHC.Types.Char -> GHC.Types.Int)
     -> Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=4,
 Str=<L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))><L,U><L,C(U)><L,C(U)>,
 Unf=OtherCon []] =
    [] \r [$dNum_s45RH base_s45RI isDigit_s45RJ valDigit_s45RK]
        let {
          sat_s45RN [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42Zn
          [LclId] =
              [$dNum_s45RH base_s45RI isDigit_s45RJ valDigit_s45RK] \u []
                  case
                      Text.Read.Lex.$wreadIntP
                          $dNum_s45RH
                          base_s45RI
                          isDigit_s45RJ
                          valDigit_s45RK
                          Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                  of
                  { Unit# ww1_s45RM [Occ=Once] ->
                        Text.ParserCombinators.ReadP.Get [ww1_s45RM];
                  };
        } in  Text.ParserCombinators.ReadP.run sat_s45RN;

Numeric.readOct
  :: forall a.
     (GHC.Classes.Eq a, GHC.Num.Num a) =>
     Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=2,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dEq_s45RO $dNum_s45RP]
        let {
          sat_s45RT [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42Ze
          [LclId] =
              [$dEq_s45RO $dNum_s45RP] \u []
                  let {
                    sat_s45RQ [Occ=Once] :: a_a42Ze
                    [LclId] =
                        [$dNum_s45RP] \u []
                            GHC.Num.fromInteger $dNum_s45RP Text.Read.Lex.readDecP4;
                  } in 
                    case
                        Text.Read.Lex.$wreadIntP'
                            $dEq_s45RO
                            $dNum_s45RP
                            sat_s45RQ
                            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                    of
                    { Unit# ww1_s45RS [Occ=Once] ->
                          Text.ParserCombinators.ReadP.Get [ww1_s45RS];
                    };
        } in  Text.ParserCombinators.ReadP.run sat_s45RT;

Numeric.readDec
  :: forall a.
     (GHC.Classes.Eq a, GHC.Num.Num a) =>
     Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=2,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dEq_s45RU $dNum_s45RV]
        let {
          sat_s45RZ [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42Z5
          [LclId] =
              [$dEq_s45RU $dNum_s45RV] \u []
                  let {
                    sat_s45RW [Occ=Once] :: a_a42Z5
                    [LclId] =
                        [$dNum_s45RV] \u []
                            GHC.Num.fromInteger $dNum_s45RV Text.Read.Lex.numberToFixed1;
                  } in 
                    case
                        Text.Read.Lex.$wreadIntP'
                            $dEq_s45RU
                            $dNum_s45RV
                            sat_s45RW
                            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                    of
                    { Unit# ww1_s45RY [Occ=Once] ->
                          Text.ParserCombinators.ReadP.Get [ww1_s45RY];
                    };
        } in  Text.ParserCombinators.ReadP.run sat_s45RZ;

Numeric.readHex
  :: forall a.
     (GHC.Classes.Eq a, GHC.Num.Num a) =>
     Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=2,
 Str=<L,U(C(C1(U)),A)><L,U(C(C1(U)),A,C(C1(U)),A,A,A,C(U))>,
 Unf=OtherCon []] =
    [] \r [$dEq_s45S0 $dNum_s45S1]
        let {
          sat_s45S5 [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42YW
          [LclId] =
              [$dEq_s45S0 $dNum_s45S1] \u []
                  let {
                    sat_s45S2 [Occ=Once] :: a_a42YW
                    [LclId] =
                        [$dNum_s45S1] \u []
                            GHC.Num.fromInteger $dNum_s45S1 Text.Read.Lex.readDecP3;
                  } in 
                    case
                        Text.Read.Lex.$wreadIntP'
                            $dEq_s45S0
                            $dNum_s45S1
                            sat_s45S2
                            Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                    of
                    { Unit# ww1_s45S4 [Occ=Once] ->
                          Text.ParserCombinators.ReadP.Get [ww1_s45S4];
                    };
        } in  Text.ParserCombinators.ReadP.run sat_s45S5;

Numeric.readFloat2
  :: forall a. GHC.Base.String -> Text.ParserCombinators.ReadP.P a
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [a3_s45S6]
        case a3_s45S6 of {
          __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
        };

Numeric.readFloat1 :: forall a. Text.ParserCombinators.ReadP.P a
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE Text.ParserCombinators.ReadP.Look! [Numeric.readFloat2];

Numeric.readFloat
  :: forall a.
     GHC.Real.RealFrac a =>
     Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=1,
 Str=<L,1*U(A,1*U(A,A,A,C(U)),A,A,A,A,A)>,
 Unf=OtherCon []] =
    [] \r [$dRealFrac_s45S8]
        let {
          lvl116_s45S9 [Occ=OnceL] :: Text.ParserCombinators.ReadP.P a_a42YP
          [LclId] =
              [$dRealFrac_s45S8] \u []
                  let {
                    sat_s45Sk [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42YP
                    [LclId] =
                        [$dRealFrac_s45S8] \u []
                            let {
                              $dFractional_s45Sa [Occ=OnceL, Dmd=<L,U(A,A,A,C(U))>]
                                :: GHC.Real.Fractional a_a42YP
                              [LclId] =
                                  [$dRealFrac_s45S8] \u []
                                      GHC.Real.$p2RealFrac $dRealFrac_s45S8; } in
                            let {
                              sat_s45Sj [Occ=Once]
                                :: Text.Read.Lex.Lexeme -> Text.ParserCombinators.ReadP.P a_a42YP
                              [LclId] =
                                  [$dFractional_s45Sa] \r [a1_s45Sb]
                                      case a1_s45Sb of {
                                        __DEFAULT -> Text.ParserCombinators.ReadP.Fail [];
                                        Text.Read.Lex.Number n_s45Sd [Occ=Once] ->
                                            let {
                                              sat_s45Si [Occ=Once] :: a_a42YP
                                              [LclId] =
                                                  [$dFractional_s45Sa n_s45Sd] \u []
                                                      let {
                                                        sat_s45Sh [Occ=Once] :: GHC.Real.Rational
                                                        [LclId] =
                                                            [n_s45Sd] \u []
                                                                case
                                                                    Text.Read.Lex.$wnumberToRational
                                                                        n_s45Sd
                                                                of
                                                                { (#,#) ww1_s45Sf [Occ=Once]
                                                                        ww2_s45Sg [Occ=Once] ->
                                                                      GHC.Real.:% [ww1_s45Sf
                                                                                   ww2_s45Sg];
                                                                };
                                                      } in 
                                                        GHC.Real.fromRational
                                                            $dFractional_s45Sa sat_s45Sh;
                                            } in 
                                              Text.ParserCombinators.ReadP.Result [sat_s45Si
                                                                                   Text.ParserCombinators.ReadP.Fail];
                                      };
                            } in  Text.Read.Lex.expect2 sat_s45Sj;
                  } in 
                    Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                        Numeric.readFloat1 sat_s45Sk; } in
        let {
          k_s45Sl [Occ=OnceL, Dmd=<L,C(U)>]
            :: () -> Text.ParserCombinators.ReadP.P a_a42YP
          [LclId, Arity=1, Str=<L,A>, Unf=OtherCon []] =
              [lvl116_s45S9] \r [a3_s45Sm] lvl116_s45S9; } in
        let {
          sat_s45So [Occ=Once]
            :: GHC.Base.String -> Text.ParserCombinators.ReadP.P a_a42YP
          [LclId] =
              [k_s45Sl] \r [a1_s45Sn]
                  Text.ParserCombinators.ReadP.skipSpaces2 a1_s45Sn k_s45Sl; } in
        let {
          sat_s45Sp [Occ=Once] :: Text.ParserCombinators.ReadP.P a_a42YP
          [LclId] =
              CCCS Text.ParserCombinators.ReadP.Look! [sat_s45So];
        } in  Text.ParserCombinators.ReadP.run sat_s45Sp;

Numeric.readSigned
  :: forall a.
     GHC.Real.Real a =>
     Text.ParserCombinators.ReadP.ReadS a
     -> Text.ParserCombinators.ReadP.ReadS a
[GblId,
 Arity=3,
 Str=<L,1*U(1*U(A,A,A,C(U),A,A,A),A,A)><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dReal_s45Sq eta_s45Sr eta1_s45Ss]
        let {
          $dNum_s45St [Occ=OnceL, Dmd=<L,U(A,A,A,C(U),A,A,A)>]
            :: GHC.Num.Num a_a42Xv
          [LclId] =
              [$dReal_s45Sq] \u [] GHC.Real.$p1Real $dReal_s45Sq; } in
        let {
          go_s45Su [Occ=LoopBreaker]
            :: [(GHC.Base.String, GHC.Base.String)]
               -> [(a_a42Xv, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [eta_s45Sr go_s45Su] \r [ds_s45Sv]
                  case ds_s45Sv of {
                    [] -> [] [];
                    : y_s45Sx [Occ=Once!] ys_s45Sy [Occ=Once] ->
                        case y_s45Sx of {
                          (,) str_s45SA [Occ=Once] s_s45SB [Occ=OnceL] ->
                              let {
                                z_s45SC [Occ=OnceL] :: [(a_a42Xv, GHC.Base.String)]
                                [LclId] =
                                    [go_s45Su ys_s45Sy] \u [] go_s45Su ys_s45Sy; } in
                              let {
                                go1_s45SD [Occ=LoopBreaker]
                                  :: [(a_a42Xv, GHC.Base.String)] -> [(a_a42Xv, GHC.Base.String)]
                                [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                                    sat-only [s_s45SB z_s45SC go1_s45SD] \r [ds1_s45SE]
                                        case ds1_s45SE of {
                                          [] -> z_s45SC;
                                          : y1_s45SG [Occ=Once!] ys1_s45SH [Occ=Once*] ->
                                              case y1_s45SG of {
                                                (,) n_s45SJ [Occ=Once] ds2_s45SK [Occ=Once!] ->
                                                    case ds2_s45SK of {
                                                      [] ->
                                                          let {
                                                            sat_s45SN [Occ=Once]
                                                              :: [(a_a42Xv, GHC.Base.String)]
                                                            [LclId] =
                                                                [go1_s45SD ys1_s45SH] \u []
                                                                    go1_s45SD ys1_s45SH; } in
                                                          let {
                                                            sat_s45SM [Occ=Once]
                                                              :: (a_a42Xv, GHC.Base.String)
                                                            [LclId] =
                                                                CCCS (,)! [n_s45SJ s_s45SB];
                                                          } in  : [sat_s45SM sat_s45SN];
                                                      : _ [Occ=Dead] _ [Occ=Dead] ->
                                                          go1_s45SD ys1_s45SH;
                                                    };
                                              };
                                        };
                              } in 
                                case eta_s45Sr str_s45SA of sat_s45SQ {
                                  __DEFAULT -> go1_s45SD sat_s45SQ;
                                };
                        };
                  }; } in
        let {
          go1_s45SR [Occ=LoopBreaker]
            :: [(GHC.Base.String, GHC.Base.String)]
               -> [(a_a42Xv, GHC.Base.String)]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [$dNum_s45St go_s45Su go1_s45SR] \r [ds_s45SS]
                  case ds_s45SS of {
                    [] -> [] [];
                    : y_s45SU [Occ=Once!] ys_s45SV [Occ=Once*] ->
                        case y_s45SU of {
                          (,) ds1_s45SX [Occ=Once!] s_s45SY [Occ=Once] ->
                              case ds1_s45SX of {
                                [] -> go1_s45SR ys_s45SV;
                                : ds2_s45T0 [Occ=Once!] ds3_s45T1 [Occ=Once!] ->
                                    case ds2_s45T0 of {
                                      GHC.Types.C# ds4_s45T3 [Occ=Once!] ->
                                          case ds4_s45T3 of {
                                            __DEFAULT -> go1_s45SR ys_s45SV;
                                            '-'# ->
                                                case ds3_s45T1 of {
                                                  [] ->
                                                      let {
                                                        z_s45T6 [Occ=OnceL]
                                                          :: [(a_a42Xv, GHC.Base.String)]
                                                        [LclId] =
                                                            [go1_s45SR ys_s45SV] \u []
                                                                go1_s45SR ys_s45SV; } in
                                                      let {
                                                        go2_s45T7 [Occ=LoopBreaker]
                                                          :: [(a_a42Xv, GHC.Base.String)]
                                                             -> [(a_a42Xv, GHC.Base.String)]
                                                        [LclId,
                                                         Arity=1,
                                                         Str=<S,1*U>,
                                                         Unf=OtherCon []] =
                                                            sat-only [$dNum_s45St
                                                                      z_s45T6
                                                                      go2_s45T7] \r [ds6_s45T8]
                                                                case ds6_s45T8 of {
                                                                  [] -> z_s45T6;
                                                                  : y1_s45Ta [Occ=Once!]
                                                                    ys1_s45Tb [Occ=Once] ->
                                                                      case y1_s45Ta of {
                                                                        (,) x_s45Td [Occ=Once]
                                                                            t_s45Te [Occ=Once] ->
                                                                            let {
                                                                              sat_s45Th [Occ=Once]
                                                                                :: [(a_a42Xv,
                                                                                     GHC.Base.String)]
                                                                              [LclId] =
                                                                                  [go2_s45T7
                                                                                   ys1_s45Tb] \u []
                                                                                      go2_s45T7
                                                                                          ys1_s45Tb; } in
                                                                            let {
                                                                              sat_s45Tf [Occ=Once]
                                                                                :: a_a42Xv
                                                                              [LclId] =
                                                                                  [$dNum_s45St
                                                                                   x_s45Td] \u []
                                                                                      GHC.Num.negate
                                                                                          $dNum_s45St
                                                                                          x_s45Td; } in
                                                                            let {
                                                                              sat_s45Tg [Occ=Once]
                                                                                :: (a_a42Xv,
                                                                                    GHC.Base.String)
                                                                              [LclId] =
                                                                                  CCCS (,)! [sat_s45Tf
                                                                                             t_s45Te];
                                                                            } in 
                                                                              : [sat_s45Tg
                                                                                 sat_s45Th];
                                                                      };
                                                                };
                                                      } in 
                                                        case
                                                            Text.ParserCombinators.ReadP.run
                                                                GHC.Read.lex1 s_s45SY
                                                        of
                                                        sat_s45Ti
                                                        { __DEFAULT ->
                                                              case go_s45Su sat_s45Ti of sat_s45Tj {
                                                                __DEFAULT -> go2_s45T7 sat_s45Tj;
                                                              };
                                                        };
                                                  : _ [Occ=Dead] _ [Occ=Dead] -> go1_s45SR ys_s45SV;
                                                };
                                          };
                                    };
                              };
                        };
                  }; } in
        let {
          sat_s45Tr [Occ=Once] :: Text.ParserCombinators.ReadP.ReadS a_a42Xv
          [LclId] =
              [go_s45Su go1_s45SR] \r [r_s45Tm]
                  let {
                    sat_s45Tq [Occ=Once, Dmd=<L,1*U>] :: [(a_a42Xv, GHC.Base.String)]
                    [LclId] =
                        [go1_s45SR r_s45Tm] \s []
                            case
                                Text.ParserCombinators.ReadP.run GHC.Read.lex1 r_s45Tm
                            of
                            sat_s45Tp
                            { __DEFAULT -> go1_s45SR sat_s45Tp;
                            };
                  } in 
                    case
                        Text.ParserCombinators.ReadP.run GHC.Read.lex1 r_s45Tm
                    of
                    sat_s45Tn
                    { __DEFAULT ->
                          case go_s45Su sat_s45Tn of sat_s45To {
                            __DEFAULT -> GHC.Base.++ sat_s45To sat_s45Tq;
                          };
                    };
        } in  GHC.Read.readParen GHC.Types.False sat_s45Tr eta1_s45Ss;

sat_s45Ts :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [10#];

sat_s45Tt :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s45Ts GHC.Types.[]];

Numeric.showInt2 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s45Tt;

lvl_r43OH :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Numeric.showInt: can't show negative numbers"#;

Numeric.showInt1 :: GHC.Base.String
[GblId, Str=x] =
    [] \u []
        case GHC.CString.unpackCString# lvl_r43OH of sat_s45Tu {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s45Tu;
        };

Numeric.showHFloat16 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

Numeric.showInt
  :: forall a. GHC.Real.Integral a => a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLLLC(S)),U(1*U(U(A,A,A,A,A,A,C(U)),U(A,A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,C(C1(U(1*U,1*U))),A,C(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s45Tv eta_s45Tw eta1_s45Tx]
        case
            GHC.Real.$p1Integral $dIntegral_s45Tv
        of
        $dReal_s45Ty [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(U(A,A,A,A,A,A,C(U)),U(A,A,C(C1(U)),A,A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                sat_s45TB [Occ=Once] :: a_a42W2
                [LclId] =
                    [$dReal_s45Ty] \u []
                        case GHC.Real.$p1Real $dReal_s45Ty of sat_s45TA {
                          __DEFAULT -> GHC.Num.fromInteger sat_s45TA Numeric.showHFloat16;
                        };
              } in 
                case GHC.Real.$p2Real $dReal_s45Ty of sat_s45Tz {
                  __DEFAULT ->
                      case GHC.Classes.< sat_s45Tz eta_s45Tw sat_s45TB of {
                        GHC.Types.False ->
                            let {
                              lvl5_s45TD :: a_a42W2
                              [LclId] =
                                  [$dReal_s45Ty] \u []
                                      case GHC.Real.$p1Real $dReal_s45Ty of sat_s45TE {
                                        __DEFAULT -> GHC.Num.fromInteger sat_s45TE Numeric.showInt2;
                                      };
                            } in 
                              case
                                  GHC.Real.$p2Real $dReal_s45Ty
                              of
                              $dOrd_s45TF [Dmd=<S(LLC(C(S))LLLLL),U(A,A,C(C1(U)),A,A,A,A,A)>]
                              { __DEFAULT ->
                                    let-no-escape {
                                      exit_s45TG [Occ=OnceL!T[2], Dmd=<C(C(S)),C(C1(U))>]
                                        :: a_a42W2 -> [GHC.Types.Char] -> GHC.Base.String
                                      [LclId[JoinId(2)], Arity=2, Str=<L,U><L,U>, Unf=OtherCon []] =
                                          sat-only [$dIntegral_s45Tv] \r [n_s45TH cs_s45TI]
                                              case
                                                  GHC.Real.toInteger $dIntegral_s45Tv n_s45TH
                                              of
                                              sat_s45TJ
                                              { __DEFAULT ->
                                                    case
                                                        GHC.Integer.Type.integerToInt sat_s45TJ
                                                    of
                                                    wild1_s45TK
                                                    { __DEFAULT ->
                                                          case +# [48# wild1_s45TK] of sat_s45TL {
                                                            __DEFAULT ->
                                                                case chr# [sat_s45TL] of sat_s45TM {
                                                                  __DEFAULT ->
                                                                      let {
                                                                        sat_s45TN [Occ=Once]
                                                                          :: GHC.Types.Char
                                                                        [LclId] =
                                                                            CCCS GHC.Types.C#! [sat_s45TM];
                                                                      } in  : [sat_s45TN cs_s45TI];
                                                                };
                                                          };
                                                    };
                                              };
                                    } in 
                                      let-no-escape {
                                        go_s45TO [Occ=LoopBreakerT[2]]
                                          :: a_a42W2 -> [GHC.Types.Char] -> GHC.Base.String
                                        [LclId[JoinId(2)],
                                         Arity=2,
                                         Str=<L,U><L,U>,
                                         Unf=OtherCon []] =
                                            sat-only [$dIntegral_s45Tv
                                                      lvl5_s45TD
                                                      $dOrd_s45TF
                                                      exit_s45TG
                                                      go_s45TO] \r [n_s45TP cs_s45TQ]
                                                case
                                                    GHC.Classes.< $dOrd_s45TF n_s45TP lvl5_s45TD
                                                of
                                                { GHC.Types.False ->
                                                      let {
                                                        ds_s45TS [Dmd=<L,U(1*U,1*U)>]
                                                          :: (a_a42W2, a_a42W2)
                                                        [LclId] =
                                                            [$dIntegral_s45Tv
                                                             lvl5_s45TD
                                                             n_s45TP] \u []
                                                                GHC.Real.quotRem
                                                                    $dIntegral_s45Tv
                                                                    n_s45TP
                                                                    lvl5_s45TD; } in
                                                      let {
                                                        sat_s45TW [Occ=Once] :: a_a42W2
                                                        [LclId] =
                                                            [ds_s45TS] \u []
                                                                case ds_s45TS of {
                                                                  (,) _ [Occ=Dead]
                                                                      r_s45TV [Occ=Once] ->
                                                                      r_s45TV;
                                                                };
                                                      } in 
                                                        case
                                                            GHC.Real.toInteger
                                                                $dIntegral_s45Tv sat_s45TW
                                                        of
                                                        sat_s45TX
                                                        { __DEFAULT ->
                                                              case
                                                                  GHC.Integer.Type.integerToInt
                                                                      sat_s45TX
                                                              of
                                                              wild2_s45TY
                                                              { __DEFAULT ->
                                                                    case
                                                                        +# [48# wild2_s45TY]
                                                                    of
                                                                    sat_s45U3
                                                                    { __DEFAULT ->
                                                                          case
                                                                              chr# [sat_s45U3]
                                                                          of
                                                                          sat_s45U4
                                                                          { __DEFAULT ->
                                                                                let {
                                                                                  sat_s45U5 [Occ=Once]
                                                                                    :: GHC.Types.Char
                                                                                  [LclId] =
                                                                                      CCCS GHC.Types.C#! [sat_s45U4]; } in
                                                                                let {
                                                                                  sat_s45U6 [Occ=Once]
                                                                                    :: [GHC.Types.Char]
                                                                                  [LclId] =
                                                                                      CCCS :! [sat_s45U5
                                                                                               cs_s45TQ]; } in
                                                                                let {
                                                                                  sat_s45U2 [Occ=Once]
                                                                                    :: a_a42W2
                                                                                  [LclId] =
                                                                                      [ds_s45TS] \u []
                                                                                          case
                                                                                              ds_s45TS
                                                                                          of
                                                                                          { (,) q_s45U0 [Occ=Once]
                                                                                                _ [Occ=Dead] ->
                                                                                                q_s45U0;
                                                                                          };
                                                                                } in 
                                                                                  go_s45TO
                                                                                      sat_s45U2
                                                                                      sat_s45U6;
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  GHC.Types.True -> exit_s45TG n_s45TP cs_s45TQ;
                                                };
                                      } in  go_s45TO eta_s45Tw eta1_s45Tx;
                              };
                        GHC.Types.True -> Numeric.showInt1;
                      };
                };
        };

Numeric.showFFloatAlt
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Base.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s45U7 d_s45U8 x_s45U9]
        let {
          sat_s45Ua [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s45U7 d_s45U8 x_s45U9] \u []
                  GHC.Float.formatRealFloatAlt
                      $dRealFloat_s45U7 GHC.Float.FFFixed d_s45U8 GHC.Types.True x_s45U9;
        } in  GHC.Base.++ sat_s45Ua;

Numeric.showGFloatAlt
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Base.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s45Ub d_s45Uc x_s45Ud]
        let {
          sat_s45Ue [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s45Ub d_s45Uc x_s45Ud] \u []
                  GHC.Float.formatRealFloatAlt
                      $dRealFloat_s45Ub
                      GHC.Float.FFGeneric
                      d_s45Uc
                      GHC.Types.True
                      x_s45Ud;
        } in  GHC.Base.++ sat_s45Ue;

lvl1_r43OI :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Numeric.showIntAtBase: applied to negative number "#;

Numeric.$wlvl [InlPrag=NOUSERINLINE[0]]
  :: GHC.Prim.Int# -> GHC.Base.String
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [ww_s45Uf]
        let {
          sat_s45Uj [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [ww_s45Uf] \u []
                  case GHC.Show.$wshowSignedInt 0# ww_s45Uf GHC.Types.[] of {
                    (#,#) ww5_s45Uh [Occ=Once] ww6_s45Ui [Occ=Once] ->
                        : [ww5_s45Uh ww6_s45Ui];
                  };
        } in 
          case
              GHC.CString.unpackAppendCString# lvl1_r43OI sat_s45Uj
          of
          sat_s45Uk
          { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s45Uk;
          };

lvl2_r43OJ :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Numeric.showIntAtBase: applied to unsupported base "#;

Numeric.showIntAtBase2
  :: forall a. GHC.Show.Show a => a -> GHC.Base.String
[GblId, Arity=2, Str=<B,1*U(A,1*C1(U),A)><B,U>x, Unf=OtherCon []] =
    [] \r [$dShow_s45Ul eta_s45Um]
        let {
          sat_s45Un [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s45Ul eta_s45Um] \u []
                  GHC.Show.show $dShow_s45Ul eta_s45Um;
        } in 
          case
              GHC.CString.unpackAppendCString# lvl1_r43OI sat_s45Un
          of
          sat_s45Uo
          { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s45Uo;
          };

Numeric.showIntAtBase1
  :: forall a. GHC.Show.Show a => a -> GHC.Base.String
[GblId, Arity=2, Str=<B,1*U(A,1*C1(U),A)><B,U>x, Unf=OtherCon []] =
    [] \r [$dShow_s45Up eta_s45Uq]
        let {
          sat_s45Ur [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dShow_s45Up eta_s45Uq] \u []
                  GHC.Show.show $dShow_s45Up eta_s45Uq;
        } in 
          case
              GHC.CString.unpackAppendCString# lvl2_r43OJ sat_s45Ur
          of
          sat_s45Us
          { __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_s45Us;
          };

sat_s45Ut :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_s45Uu :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s45Ut GHC.Types.[]];

Numeric.showIntAtBase3 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s45Uu;

Numeric.showIntAtBase
  :: forall a.
     (GHC.Real.Integral a, GHC.Show.Show a) =>
     a -> (GHC.Types.Int -> GHC.Types.Char) -> a -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=<S(S(LS(S(C(C(S))L)LC(C(S))C(C(S))LLLL)L)LLLLLC(C(S))LL),U(1*U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(U,U))),A,C(U))><L,1*U(A,1*C1(U),A)><L,U><C(S),C(U(U))><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s45Uv
           $dShow_s45Uw
           eta_s45Ux
           eta1_s45Uy
           eta2_s45Uz
           eta3_s45UA]
        case
            GHC.Real.$p1Integral $dIntegral_s45Uv
        of
        $dReal_s45UB [Dmd=<S(LS(S(C(C(S))L)LC(C(S))C(C(S))LLLL)L),U(1*U(A,A,A,A,A,A,C(U)),1*U(1*U(C(C1(U)),A),A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,A),A)>]
        { __DEFAULT ->
              let {
                $dNum_s45UC [Dmd=<L,U(A,A,A,A,A,A,C(U))>] :: GHC.Num.Num a_a42NP
                [LclId] =
                    [$dReal_s45UB] \u [] GHC.Real.$p1Real $dReal_s45UB;
              } in 
                case
                    GHC.Real.$p2Real $dReal_s45UB
                of
                $dOrd_s45UD [Dmd=<S(S(C(C(S))L)LC(C(S))C(C(S))LLLL),U(1*U(C(C1(U)),A),A,1*C1(C1(U)),1*C1(C1(U)),A,A,A,A)>]
                { __DEFAULT ->
                      let {
                        sat_s45UE [Occ=Once] :: a_a42NP
                        [LclId] =
                            [$dNum_s45UC] \u []
                                GHC.Num.fromInteger $dNum_s45UC Numeric.showIntAtBase3;
                      } in 
                        case GHC.Classes.<= $dOrd_s45UD eta_s45Ux sat_s45UE of {
                          GHC.Types.False ->
                              let {
                                sat_s45UG [Occ=Once] :: a_a42NP
                                [LclId] =
                                    [$dNum_s45UC] \u []
                                        GHC.Num.fromInteger $dNum_s45UC Numeric.showHFloat16;
                              } in 
                                case GHC.Classes.< $dOrd_s45UD eta2_s45Uz sat_s45UG of {
                                  GHC.Types.False ->
                                      case
                                          GHC.Real.quotRem $dIntegral_s45Uv eta2_s45Uz eta_s45Ux
                                      of
                                      { (,) ww1_s45UJ [Occ=Once] ww2_s45UK [Occ=Once] ->
                                            let {
                                              lvl5_s45UL [Occ=OnceL] :: a_a42NP
                                              [LclId] =
                                                  [$dNum_s45UC] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s45UC Numeric.showHFloat16;
                                            } in 
                                              case
                                                  GHC.Classes.$p1Ord $dOrd_s45UD
                                              of
                                              $dEq_s45UM [Dmd=<S(C(C(S))L),U(C(C1(U)),A)>]
                                              { __DEFAULT ->
                                                    let-no-escape {
                                                      $wshowIt5_s45UN [InlPrag=NOUSERINLINE[0],
                                                                       Occ=LoopBreakerT[3]]
                                                        :: a_a42NP
                                                           -> a_a42NP
                                                           -> [GHC.Types.Char]
                                                           -> GHC.Base.String
                                                      [LclId[JoinId(3)],
                                                       Arity=3,
                                                       Str=<L,U><L,U><L,U>,
                                                       Unf=OtherCon []] =
                                                          sat-only [$dIntegral_s45Uv
                                                                    eta_s45Ux
                                                                    eta1_s45Uy
                                                                    lvl5_s45UL
                                                                    $dEq_s45UM
                                                                    $wshowIt5_s45UN] \r [ww3_s45UO
                                                                                         ww4_s45UP
                                                                                         w_s45UQ]
                                                              let {
                                                                sat_s45UT [Occ=Once]
                                                                  :: GHC.Types.Int
                                                                [LclId] =
                                                                    [$dIntegral_s45Uv
                                                                     ww4_s45UP] \u []
                                                                        case
                                                                            GHC.Real.toInteger
                                                                                $dIntegral_s45Uv
                                                                                ww4_s45UP
                                                                        of
                                                                        sat_s45UR
                                                                        { __DEFAULT ->
                                                                              case
                                                                                  GHC.Integer.Type.integerToInt
                                                                                      sat_s45UR
                                                                              of
                                                                              wild2_s45US
                                                                              { __DEFAULT ->
                                                                                    GHC.Types.I# [wild2_s45US];
                                                                              };
                                                                        };
                                                              } in 
                                                                case
                                                                    eta1_s45Uy sat_s45UT
                                                                of
                                                                v_s45UU
                                                                { GHC.Types.C# _ [Occ=Dead] ->
                                                                      case
                                                                          GHC.Classes.==
                                                                              $dEq_s45UM
                                                                              ww3_s45UO
                                                                              lvl5_s45UL
                                                                      of
                                                                      { GHC.Types.False ->
                                                                            case
                                                                                GHC.Real.quotRem
                                                                                    $dIntegral_s45Uv
                                                                                    ww3_s45UO
                                                                                    eta_s45Ux
                                                                            of
                                                                            { (,) ww6_s45UY [Occ=Once]
                                                                                  ww7_s45UZ [Occ=Once] ->
                                                                                  let {
                                                                                    sat_s45V0 [Occ=Once]
                                                                                      :: [GHC.Types.Char]
                                                                                    [LclId] =
                                                                                        CCCS :! [v_s45UU
                                                                                                 w_s45UQ];
                                                                                  } in 
                                                                                    $wshowIt5_s45UN
                                                                                        ww6_s45UY
                                                                                        ww7_s45UZ
                                                                                        sat_s45V0;
                                                                            };
                                                                        GHC.Types.True ->
                                                                            : [v_s45UU w_s45UQ];
                                                                      };
                                                                };
                                                    } in 
                                                      $wshowIt5_s45UN
                                                          ww1_s45UJ ww2_s45UK eta3_s45UA;
                                              };
                                      };
                                  GHC.Types.True -> Numeric.showIntAtBase2 $dShow_s45Uw eta2_s45Uz;
                                };
                          GHC.Types.True -> Numeric.showIntAtBase1 $dShow_s45Uw eta_s45Ux;
                        };
                };
        };

sat_s45V1 :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [16#];

sat_s45V2 :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s45V1 GHC.Types.[]];

Numeric.showHex1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s45V2;

Numeric.showHex
  :: forall a.
     (GHC.Real.Integral a, GHC.Show.Show a) =>
     a -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(U,U))),A,C(U))><L,U(A,C(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s45V3 $dShow_s45V4]
        let {
          sat_s45V7 [Occ=Once] :: a_a42Pa
          [LclId] =
              [$dIntegral_s45V3] \u []
                  case GHC.Real.$p1Integral $dIntegral_s45V3 of sat_s45V5 {
                    __DEFAULT ->
                        case GHC.Real.$p1Real sat_s45V5 of sat_s45V6 {
                          __DEFAULT -> GHC.Num.fromInteger sat_s45V6 Numeric.showHex1;
                        };
                  };
        } in 
          Numeric.showIntAtBase
              $dIntegral_s45V3 $dShow_s45V4 sat_s45V7 GHC.Show.intToDigit;

Numeric.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

loc_r43OK :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.$trModule4;

Numeric.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Numeric"#;

loc1_r43OL :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.$trModule2;

loc2_r43OM :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Numeric.hs"#;

loc3_r43ON :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# loc2_r43OM;

loc4_r43OO :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [241#];

loc5_r43OP :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [22#];

loc6_r43OQ :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.I#! [75#];

$dIP_r43OR :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "error"#;

$dIP1_r43OS :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# $dIP_r43OR;

$dIP2_r43OT :: GHC.Stack.Types.SrcLoc
[GblId, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.SrcLoc! [loc_r43OK
                                           loc1_r43OL
                                           loc3_r43ON
                                           loc4_r43OO
                                           loc5_r43OP
                                           loc4_r43OO
                                           loc6_r43OQ];

$dIP3_r43OU :: GHC.Stack.Types.CallStack
[GblId, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Stack.Types.PushCallStack! [$dIP1_r43OS
                                                  $dIP2_r43OT
                                                  GHC.Stack.Types.EmptyCallStack];

lvl3_r43OV :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Impossible happened: showHFloat: "#;

lvl4_r43OW :: [GHC.Types.Char]
[GblId, Caf=NoCafRefs, Str=m2, Unf=OtherCon []] =
    CCS_DONT_CARE :! [GHC.Show.$fShow(,)2 GHC.Types.[]];

$wlvl2_r43OX
  :: [GHC.Types.Int] -> GHC.Prim.Int# -> [GHC.Types.Char]
[GblId, Arity=2, Str=<B,U><B,U>x, Unf=OtherCon []] =
    sat-only [] \r [ww_s45V8 ww1_s45V9]
        let {
          sat_s45Vi [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [ww_s45V8 ww1_s45V9] \u []
                  let {
                    sat_s45Vf [Occ=Once] :: GHC.Show.ShowS
                    [LclId] =
                        [ww1_s45V9] \r [w2_s45Vb]
                            case GHC.Show.$wshowSignedInt 0# ww1_s45V9 w2_s45Vb of {
                              (#,#) ww5_s45Vd [Occ=Once] ww6_s45Ve [Occ=Once] ->
                                  : [ww5_s45Vd ww6_s45Ve];
                            }; } in
                  let {
                    sat_s45Vg [Occ=Once] :: [GHC.Show.ShowS]
                    [LclId] =
                        CCCS :! [sat_s45Vf GHC.Types.[]]; } in
                  let {
                    sat_s45Va [Occ=Once] :: GHC.Show.ShowS
                    [LclId] =
                        [ww_s45V8] \r [eta_B1]
                            GHC.Show.$fShowInt_$cshowList ww_s45V8 eta_B1; } in
                  let {
                    sat_s45Vh [Occ=Once] :: [GHC.Base.String -> GHC.Base.String]
                    [LclId] =
                        CCCS :! [sat_s45Va sat_s45Vg];
                  } in  GHC.Show.$fShow(,)_go1 sat_s45Vh lvl4_r43OW; } in
        let {
          sat_s45Vj [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              CCCS :! [GHC.Show.$fShow(,)4 sat_s45Vi];
        } in 
          case
              GHC.CString.unpackAppendCString# lvl3_r43OV sat_s45Vj
          of
          sat_s45Vk
          { __DEFAULT -> GHC.Err.error $dIP3_r43OU sat_s45Vk;
          };

Numeric.showHFloat_allZ [Occ=LoopBreaker]
  :: [GHC.Types.Int] -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [xs_s45Vl]
        case xs_s45Vl of {
          [] -> GHC.Types.True [];
          : x_s45Vn [Occ=Once!] more_s45Vo [Occ=Once] ->
              case x_s45Vn of {
                GHC.Types.I# x1_s45Vq [Occ=Once!] ->
                    case x1_s45Vq of {
                      __DEFAULT -> GHC.Types.False [];
                      0# -> Numeric.showHFloat_allZ more_s45Vo;
                    };
              };
        };

$wshowIt1_r43OY
  :: GHC.Prim.Int#
     -> GHC.Types.Int -> [GHC.Types.Char] -> [GHC.Types.Char]
[GblId,
 Arity=3,
 Str=<S,1*U><S(S),1*U(U)><L,U>m2,
 Unf=OtherCon []] =
    sat-only [] \r [ww_s45Vs ww1_s45Vt w_s45Vu]
        case ww1_s45Vt of {
          GHC.Types.I# ww3_s45Vw [Occ=Once] ->
              case GHC.Show.$wintToDigit ww3_s45Vw of ww4_s45Vx {
                __DEFAULT ->
                    case ww_s45Vs of wild_s45Vy {
                      __DEFAULT ->
                          case quotRemInt# [wild_s45Vy 16#] of {
                            (#,#) ipv_s45VA [Occ=Once] ipv1_s45VB [Occ=Once] ->
                                let {
                                  sat_s45VD [Occ=Once] :: GHC.Types.Char
                                  [LclId] =
                                      CCCS GHC.Types.C#! [ww4_s45Vx]; } in
                                let {
                                  sat_s45VE [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      CCCS :! [sat_s45VD w_s45Vu]; } in
                                let {
                                  sat_s45VC [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s45VB];
                                } in  $wshowIt1_r43OY ipv_s45VA sat_s45VC sat_s45VE;
                          };
                      0# ->
                          let {
                            sat_s45VF [Occ=Once] :: GHC.Types.Char
                            [LclId] =
                                CCCS GHC.Types.C#! [ww4_s45Vx];
                          } in  : [sat_s45VF w_s45Vu];
                    };
              };
        };

$wshowIt2_r43OZ
  :: GHC.Prim.Int#
     -> GHC.Types.Int -> [GHC.Types.Char] -> [GHC.Types.Char]
[GblId,
 Arity=3,
 Str=<S,1*U><S(S),1*U(U)><L,U>m2,
 Unf=OtherCon []] =
    sat-only [] \r [ww_s45VG ww1_s45VH w_s45VI]
        case ww1_s45VH of {
          GHC.Types.I# ww3_s45VK [Occ=Once] ->
              case GHC.Show.$wintToDigit ww3_s45VK of ww4_s45VL {
                __DEFAULT ->
                    case ww_s45VG of wild_s45VM {
                      __DEFAULT ->
                          case quotRemInt# [wild_s45VM 16#] of {
                            (#,#) ipv_s45VO [Occ=Once] ipv1_s45VP [Occ=Once] ->
                                let {
                                  sat_s45VR [Occ=Once] :: GHC.Types.Char
                                  [LclId] =
                                      CCCS GHC.Types.C#! [ww4_s45VL]; } in
                                let {
                                  sat_s45VS [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      CCCS :! [sat_s45VR w_s45VI]; } in
                                let {
                                  sat_s45VQ [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s45VP];
                                } in  $wshowIt2_r43OZ ipv_s45VO sat_s45VQ sat_s45VS;
                          };
                      0# ->
                          let {
                            sat_s45VT [Occ=Once] :: GHC.Types.Char
                            [LclId] =
                                CCCS GHC.Types.C#! [ww4_s45VL];
                          } in  : [sat_s45VT w_s45VI];
                    };
              };
        };

$wshowIt3_r43P0
  :: GHC.Prim.Int#
     -> GHC.Types.Int -> [GHC.Types.Char] -> [GHC.Types.Char]
[GblId,
 Arity=3,
 Str=<S,1*U><S(S),1*U(U)><L,U>m2,
 Unf=OtherCon []] =
    sat-only [] \r [ww_s45VU ww1_s45VV w_s45VW]
        case ww1_s45VV of {
          GHC.Types.I# ww3_s45VY [Occ=Once] ->
              case GHC.Show.$wintToDigit ww3_s45VY of ww4_s45VZ {
                __DEFAULT ->
                    case ww_s45VU of wild_s45W0 {
                      __DEFAULT ->
                          case quotRemInt# [wild_s45W0 16#] of {
                            (#,#) ipv_s45W2 [Occ=Once] ipv1_s45W3 [Occ=Once] ->
                                let {
                                  sat_s45W5 [Occ=Once] :: GHC.Types.Char
                                  [LclId] =
                                      CCCS GHC.Types.C#! [ww4_s45VZ]; } in
                                let {
                                  sat_s45W6 [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      CCCS :! [sat_s45W5 w_s45VW]; } in
                                let {
                                  sat_s45W4 [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s45W3];
                                } in  $wshowIt3_r43P0 ipv_s45W2 sat_s45W4 sat_s45W6;
                          };
                      0# ->
                          let {
                            sat_s45W7 [Occ=Once] :: GHC.Types.Char
                            [LclId] =
                                CCCS GHC.Types.C#! [ww4_s45VZ];
                          } in  : [sat_s45W7 w_s45VW];
                    };
              };
        };

$wshowIt4_r43P1
  :: GHC.Prim.Int#
     -> GHC.Types.Int -> [GHC.Types.Char] -> [GHC.Types.Char]
[GblId,
 Arity=3,
 Str=<S,1*U><S(S),1*U(U)><L,U>m2,
 Unf=OtherCon []] =
    sat-only [] \r [ww_s45W8 ww1_s45W9 w_s45Wa]
        case ww1_s45W9 of {
          GHC.Types.I# ww3_s45Wc [Occ=Once] ->
              case GHC.Show.$wintToDigit ww3_s45Wc of ww4_s45Wd {
                __DEFAULT ->
                    case ww_s45W8 of wild_s45We {
                      __DEFAULT ->
                          case quotRemInt# [wild_s45We 16#] of {
                            (#,#) ipv_s45Wg [Occ=Once] ipv1_s45Wh [Occ=Once] ->
                                let {
                                  sat_s45Wj [Occ=Once] :: GHC.Types.Char
                                  [LclId] =
                                      CCCS GHC.Types.C#! [ww4_s45Wd]; } in
                                let {
                                  sat_s45Wk [Occ=Once] :: [GHC.Types.Char]
                                  [LclId] =
                                      CCCS :! [sat_s45Wj w_s45Wa]; } in
                                let {
                                  sat_s45Wi [Occ=Once] :: GHC.Types.Int
                                  [LclId] =
                                      CCCS GHC.Types.I#! [ipv1_s45Wh];
                                } in  $wshowIt4_r43P1 ipv_s45Wg sat_s45Wi sat_s45Wk;
                          };
                      0# ->
                          let {
                            sat_s45Wl [Occ=Once] :: GHC.Types.Char
                            [LclId] =
                                CCCS GHC.Types.C#! [ww4_s45Wd];
                          } in  : [sat_s45Wl w_s45Wa];
                    };
              };
        };

Numeric.showHFloat_hex [Occ=LoopBreaker]
  :: [GHC.Types.Int] -> GHC.Base.String
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_s45Wm]
        case ds_s45Wm of {
          [] -> [] [];
          : a_s45Wo [Occ=Once*!] ds1_s45Wp [Occ=Once!] ->
              case ds1_s45Wp of {
                [] ->
                    case a_s45Wo of {
                      GHC.Types.I# y_s45Ws [Occ=Once] ->
                          case *# [8# y_s45Ws] of ww_s45Wt [Dmd=<S,U>] {
                            __DEFAULT ->
                                case <# [ww_s45Wt 0#] of {
                                  __DEFAULT ->
                                      case quotRemInt# [ww_s45Wt 16#] of {
                                        (#,#) ipv_s45Ww [Occ=Once] ipv1_s45Wx [Occ=Once] ->
                                            let {
                                              sat_s45Wy [Occ=Once] :: GHC.Types.Int
                                              [LclId] =
                                                  CCCS GHC.Types.I#! [ipv1_s45Wx];
                                            } in  $wshowIt4_r43P1 ipv_s45Ww sat_s45Wy GHC.Types.[];
                                      };
                                  1# -> Numeric.$wlvl ww_s45Wt;
                                };
                          };
                    };
                : b_s45Wz [Occ=Once*!] ds2_s45WA [Occ=Once!] ->
                    case ds2_s45WA of {
                      [] ->
                          case a_s45Wo of {
                            GHC.Types.I# y_s45WD [Occ=Once] ->
                                case b_s45Wz of {
                                  GHC.Types.I# y1_s45WF [Occ=Once] ->
                                      case *# [4# y1_s45WF] of sat_s45WI {
                                        __DEFAULT ->
                                            case *# [8# y_s45WD] of sat_s45WH {
                                              __DEFAULT ->
                                                  case
                                                      +# [sat_s45WH sat_s45WI]
                                                  of
                                                  ww_s45WG [Dmd=<S,U>]
                                                  { __DEFAULT ->
                                                        case <# [ww_s45WG 0#] of {
                                                          __DEFAULT ->
                                                              case quotRemInt# [ww_s45WG 16#] of {
                                                                (#,#) ipv_s45WL [Occ=Once]
                                                                      ipv1_s45WM [Occ=Once] ->
                                                                    let {
                                                                      sat_s45WN [Occ=Once]
                                                                        :: GHC.Types.Int
                                                                      [LclId] =
                                                                          CCCS GHC.Types.I#! [ipv1_s45WM];
                                                                    } in 
                                                                      $wshowIt3_r43P0
                                                                          ipv_s45WL
                                                                          sat_s45WN
                                                                          GHC.Types.[];
                                                              };
                                                          1# -> Numeric.$wlvl ww_s45WG;
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                      : c_s45WO [Occ=Once*!] ds3_s45WP [Occ=Once!] ->
                          case ds3_s45WP of {
                            [] ->
                                case a_s45Wo of {
                                  GHC.Types.I# y_s45WS [Occ=Once] ->
                                      case b_s45Wz of {
                                        GHC.Types.I# y1_s45WU [Occ=Once] ->
                                            case c_s45WO of {
                                              GHC.Types.I# y2_s45WW [Occ=Once] ->
                                                  case *# [2# y2_s45WW] of sat_s45X1 {
                                                    __DEFAULT ->
                                                        case *# [4# y1_s45WU] of sat_s45WZ {
                                                          __DEFAULT ->
                                                              case *# [8# y_s45WS] of sat_s45WY {
                                                                __DEFAULT ->
                                                                    case
                                                                        +# [sat_s45WY sat_s45WZ]
                                                                    of
                                                                    sat_s45X0
                                                                    { __DEFAULT ->
                                                                          case
                                                                              +# [sat_s45X0
                                                                                  sat_s45X1]
                                                                          of
                                                                          ww_s45WX [Dmd=<S,U>]
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    <# [ww_s45WX 0#]
                                                                                of
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          quotRemInt# [ww_s45WX
                                                                                                       16#]
                                                                                      of
                                                                                      { (#,#) ipv_s45X4 [Occ=Once]
                                                                                              ipv1_s45X5 [Occ=Once] ->
                                                                                            let {
                                                                                              sat_s45X6 [Occ=Once]
                                                                                                :: GHC.Types.Int
                                                                                              [LclId] =
                                                                                                  CCCS GHC.Types.I#! [ipv1_s45X5];
                                                                                            } in 
                                                                                              $wshowIt2_r43OZ
                                                                                                  ipv_s45X4
                                                                                                  sat_s45X6
                                                                                                  GHC.Types.[];
                                                                                      };
                                                                                  1# ->
                                                                                      Numeric.$wlvl
                                                                                          ww_s45WX;
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                            : d_s45X7 [Occ=Once!] r_s45X8 [Occ=Once] ->
                                case a_s45Wo of {
                                  GHC.Types.I# y_s45Xa [Occ=Once] ->
                                      case b_s45Wz of {
                                        GHC.Types.I# y1_s45Xc [Occ=Once] ->
                                            case c_s45WO of {
                                              GHC.Types.I# y2_s45Xe [Occ=Once] ->
                                                  case d_s45X7 of {
                                                    GHC.Types.I# y3_s45Xg [Occ=Once] ->
                                                        case *# [2# y2_s45Xe] of sat_s45Xl {
                                                          __DEFAULT ->
                                                              case *# [4# y1_s45Xc] of sat_s45Xj {
                                                                __DEFAULT ->
                                                                    case
                                                                        *# [8# y_s45Xa]
                                                                    of
                                                                    sat_s45Xi
                                                                    { __DEFAULT ->
                                                                          case
                                                                              +# [sat_s45Xi
                                                                                  sat_s45Xj]
                                                                          of
                                                                          sat_s45Xk
                                                                          { __DEFAULT ->
                                                                                case
                                                                                    +# [sat_s45Xk
                                                                                        sat_s45Xl]
                                                                                of
                                                                                sat_s45Xm
                                                                                { __DEFAULT ->
                                                                                      case
                                                                                          +# [sat_s45Xm
                                                                                              y3_s45Xg]
                                                                                      of
                                                                                      ww_s45Xh [Dmd=<S,U>]
                                                                                      { __DEFAULT ->
                                                                                            case
                                                                                                <# [ww_s45Xh
                                                                                                    0#]
                                                                                            of
                                                                                            { __DEFAULT ->
                                                                                                  case
                                                                                                      quotRemInt# [ww_s45Xh
                                                                                                                   16#]
                                                                                                  of
                                                                                                  { (#,#) ipv_s45Xp [Occ=Once]
                                                                                                          ipv1_s45Xq [Occ=Once] ->
                                                                                                        let {
                                                                                                          sat_s45Xs [Occ=Once]
                                                                                                            :: [GHC.Types.Char]
                                                                                                          [LclId] =
                                                                                                              [r_s45X8] \u []
                                                                                                                  Numeric.showHFloat_hex
                                                                                                                      r_s45X8; } in
                                                                                                        let {
                                                                                                          sat_s45Xr [Occ=Once]
                                                                                                            :: GHC.Types.Int
                                                                                                          [LclId] =
                                                                                                              CCCS GHC.Types.I#! [ipv1_s45Xq];
                                                                                                        } in 
                                                                                                          $wshowIt1_r43OY
                                                                                                              ipv_s45Xp
                                                                                                              sat_s45Xr
                                                                                                              sat_s45Xs;
                                                                                                  };
                                                                                              1# ->
                                                                                                  Numeric.$wlvl
                                                                                                      ww_s45Xh;
                                                                                            };
                                                                                      };
                                                                                };
                                                                          };
                                                                    };
                                                              };
                                                        };
                                                  };
                                            };
                                      };
                                };
                          };
                    };
              };
        };

sat_s45Xt :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [2#];

sat_s45Xu :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s45Xt GHC.Types.[]];

Numeric.showHFloat15 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s45Xu;

Numeric.showHFloat10 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "0x0p+0"#;

Numeric.showHFloat9 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.showHFloat10;

Numeric.showHFloat14 :: GHC.Prim.Int# -> [GHC.Types.Char]
[GblId, Arity=1, Str=<B,U>x, Unf=OtherCon []] =
    [] \r [ww_s45Xv] $wlvl2_r43OX GHC.Types.[] ww_s45Xv;

Numeric.showHFloat13 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "0x"#;

Numeric.showHFloat12 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "p"#;

Numeric.showHFloat11 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "."#;

Numeric.showHFloat_cvt
  :: forall a. GHC.Float.RealFloat a => a -> [GHC.Types.Char]
[GblId,
 Arity=2,
 Str=<S(S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL)LLLLLLLLLLLLLLL),U(U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,A,A,A,A,A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s45Xw eta_s45Xx]
        case
            GHC.Float.$p1RealFloat $dRealFloat_s45Xw
        of
        $dRealFrac_s45Xy [Dmd=<S(S(LS(S(C(C(S))L)LLLLLLL)L)LLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A),A,A,A,A,A,A)>]
        { __DEFAULT ->
              case
                  GHC.Real.$p1RealFrac $dRealFrac_s45Xy
              of
              $dReal_s45Xz [Dmd=<S(LS(S(C(C(S))L)LLLLLLL)L),U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(1*U(1*C1(C1(U)),A),A,A,A,A,A,A,A),A)>]
              { __DEFAULT ->
                    let {
                      sat_s45XD [Occ=Once] :: a_a42SJ
                      [LclId] =
                          [$dReal_s45Xz] \u []
                              case GHC.Real.$p1Real $dReal_s45Xz of sat_s45XC {
                                __DEFAULT -> GHC.Num.fromInteger sat_s45XC Numeric.showHFloat16;
                              };
                    } in 
                      case GHC.Real.$p2Real $dReal_s45Xz of sat_s45XA {
                        __DEFAULT ->
                            case GHC.Classes.$p1Ord sat_s45XA of sat_s45XB {
                              __DEFAULT ->
                                  case GHC.Classes.== sat_s45XB eta_s45Xx sat_s45XD of {
                                    GHC.Types.False ->
                                        case
                                            GHC.Float.$wfloatToDigits
                                                $dRealFloat_s45Xw Numeric.showHFloat15 eta_s45Xx
                                        of
                                        { (#,#) ww1_s45XG [Occ=Once!] ww2_s45XH [Occ=Once*!] ->
                                              case ww1_s45XG of {
                                                [] ->
                                                    case ww2_s45XH of {
                                                      GHC.Types.I# ww5_s45XK [Occ=Once] ->
                                                          Numeric.showHFloat14 ww5_s45XK;
                                                    };
                                                : d_s45XL [Occ=Once!] ds_s45XM ->
                                                    let {
                                                      sat_s45Y5 [Occ=Once] :: [GHC.Types.Char]
                                                      [LclId] =
                                                          [ww2_s45XH d_s45XL ds_s45XM] \u []
                                                              case d_s45XL of {
                                                                GHC.Types.I# ww3_s45XO [Occ=Once] ->
                                                                    case
                                                                        GHC.Show.$wshowSignedInt
                                                                            0#
                                                                            ww3_s45XO
                                                                            GHC.Types.[]
                                                                    of
                                                                    { (#,#) ww6_s45XQ [Occ=Once]
                                                                            ww7_s45XR [Occ=Once] ->
                                                                          let {
                                                                            sat_s45Y4 [Occ=Once,
                                                                                       Dmd=<L,1*U>]
                                                                              :: [GHC.Types.Char]
                                                                            [LclId] =
                                                                                [ww2_s45XH
                                                                                 ds_s45XM] \s []
                                                                                    let {
                                                                                      n_s45XT [Occ=Once*,
                                                                                               Dmd=<L,1*U>]
                                                                                        :: [GHC.Types.Char]
                                                                                      [LclId] =
                                                                                          [ww2_s45XH] \s []
                                                                                              let {
                                                                                                sat_s45Y0 [Occ=Once]
                                                                                                  :: [GHC.Types.Char]
                                                                                                [LclId] =
                                                                                                    [ww2_s45XH] \u []
                                                                                                        case
                                                                                                            ww2_s45XH
                                                                                                        of
                                                                                                        { GHC.Types.I# x_s45XV [Occ=Once] ->
                                                                                                              case
                                                                                                                  -# [x_s45XV
                                                                                                                      1#]
                                                                                                              of
                                                                                                              sat_s45XW
                                                                                                              { __DEFAULT ->
                                                                                                                    case
                                                                                                                        GHC.Show.$wshowSignedInt
                                                                                                                            0#
                                                                                                                            sat_s45XW
                                                                                                                            GHC.Types.[]
                                                                                                                    of
                                                                                                                    { (#,#) ww9_s45XY [Occ=Once]
                                                                                                                            ww10_s45XZ [Occ=Once] ->
                                                                                                                          : [ww9_s45XY
                                                                                                                             ww10_s45XZ];
                                                                                                                    };
                                                                                                              };
                                                                                                        };
                                                                                              } in 
                                                                                                GHC.CString.unpackAppendCString#
                                                                                                    Numeric.showHFloat12
                                                                                                    sat_s45Y0;
                                                                                    } in 
                                                                                      case
                                                                                          Numeric.showHFloat_allZ
                                                                                              ds_s45XM
                                                                                      of
                                                                                      { GHC.Types.False ->
                                                                                            let {
                                                                                              sat_s45Y3 [Occ=Once]
                                                                                                :: [GHC.Types.Char]
                                                                                              [LclId] =
                                                                                                  [ds_s45XM
                                                                                                   n_s45XT] \u []
                                                                                                      case
                                                                                                          Numeric.showHFloat_hex
                                                                                                              ds_s45XM
                                                                                                      of
                                                                                                      sat_s45Y2
                                                                                                      { __DEFAULT ->
                                                                                                            GHC.Base.++
                                                                                                                sat_s45Y2
                                                                                                                n_s45XT;
                                                                                                      };
                                                                                            } in 
                                                                                              GHC.CString.unpackAppendCString#
                                                                                                  Numeric.showHFloat11
                                                                                                  sat_s45Y3;
                                                                                        GHC.Types.True ->
                                                                                            n_s45XT;
                                                                                      }; } in
                                                                          let {
                                                                            sat_s45XS [Occ=Once]
                                                                              :: [GHC.Types.Char]
                                                                            [LclId] =
                                                                                CCCS :! [ww6_s45XQ
                                                                                         ww7_s45XR];
                                                                          } in 
                                                                            GHC.Base.++
                                                                                sat_s45XS sat_s45Y4;
                                                                    };
                                                              };
                                                    } in 
                                                      GHC.CString.unpackAppendCString#
                                                          Numeric.showHFloat13 sat_s45Y5;
                                              };
                                        };
                                    GHC.Types.True -> Numeric.showHFloat9;
                                  };
                            };
                      };
              };
        };

Numeric.showHFloat8 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.C#! ['-'#];

Numeric.showHFloat5 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Infinity"#;

Numeric.showHFloat7 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "-"#;

Numeric.showHFloat6 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.showHFloat7;

Numeric.showHFloat2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "NaN"#;

Numeric.showHFloat1 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.showHFloat2;

Numeric.showHFloat4 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# Numeric.showHFloat5;

Numeric.showHFloat3 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.Base.++ Numeric.showHFloat6 Numeric.showHFloat4;

Numeric.showHFloat
  :: forall a. GHC.Float.RealFloat a => a -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Str=<L,U(U(U(U(A,A,A,1*C1(U),A,A,C(U)),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,1*C1(U),1*C1(U),A,1*C1(U),A,A)><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s45Y6 eta_s45Y7]
        let {
          sat_s45Yo [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s45Y6 eta_s45Y7] \u []
                  case GHC.Float.isNaN $dRealFloat_s45Y6 eta_s45Y7 of {
                    GHC.Types.False ->
                        case
                            GHC.Float.$p1RealFloat $dRealFloat_s45Y6
                        of
                        $dRealFrac_s45Y9 [Dmd=<S(S(LS(LLC(C(S))LLLLL)L)LLLLLL),1*U(1*U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A)>]
                        { __DEFAULT ->
                              case
                                  GHC.Real.$p1RealFrac $dRealFrac_s45Y9
                              of
                              $dReal_s45Ya [Dmd=<S(LS(LLC(C(S))LLLLL)L),U(1*U(A,A,A,1*C1(U),A,A,1*C1(U)),1*U(A,A,1*C1(C1(U)),A,A,A,A,A),A)>]
                              { __DEFAULT ->
                                    let {
                                      $dNum_s45Yb [Dmd=<L,U(A,A,A,1*C1(U),A,A,1*C1(U))>]
                                        :: GHC.Num.Num a_a42Pu
                                      [LclId] =
                                          [$dReal_s45Ya] \u [] GHC.Real.$p1Real $dReal_s45Ya;
                                    } in 
                                      case GHC.Float.isInfinite $dRealFloat_s45Y6 eta_s45Y7 of {
                                        GHC.Types.False ->
                                            let {
                                              sat_s45Ye [Occ=Once] :: a_a42Pu
                                              [LclId] =
                                                  [$dNum_s45Yb] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s45Yb Numeric.showHFloat16;
                                            } in 
                                              case GHC.Real.$p2Real $dReal_s45Ya of sat_s45Yd {
                                                __DEFAULT ->
                                                    case
                                                        GHC.Classes.< sat_s45Yd eta_s45Y7 sat_s45Ye
                                                    of
                                                    { GHC.Types.False ->
                                                          case
                                                              GHC.Float.isNegativeZero
                                                                  $dRealFloat_s45Y6 eta_s45Y7
                                                          of
                                                          { GHC.Types.False ->
                                                                Numeric.showHFloat_cvt
                                                                    $dRealFloat_s45Y6 eta_s45Y7;
                                                            GHC.Types.True ->
                                                                let {
                                                                  sat_s45Yi [Occ=Once]
                                                                    :: [GHC.Types.Char]
                                                                  [LclId] =
                                                                      [$dRealFloat_s45Y6
                                                                       eta_s45Y7
                                                                       $dNum_s45Yb] \u []
                                                                          let {
                                                                            sat_s45Yh [Occ=Once]
                                                                              :: a_a42Pu
                                                                            [LclId] =
                                                                                [eta_s45Y7
                                                                                 $dNum_s45Yb] \u []
                                                                                    GHC.Num.negate
                                                                                        $dNum_s45Yb
                                                                                        eta_s45Y7;
                                                                          } in 
                                                                            Numeric.showHFloat_cvt
                                                                                $dRealFloat_s45Y6
                                                                                sat_s45Yh;
                                                                } in 
                                                                  : [Numeric.showHFloat8 sat_s45Yi];
                                                          };
                                                      GHC.Types.True ->
                                                          let {
                                                            sat_s45Yk [Occ=Once] :: [GHC.Types.Char]
                                                            [LclId] =
                                                                [$dRealFloat_s45Y6
                                                                 eta_s45Y7
                                                                 $dNum_s45Yb] \u []
                                                                    let {
                                                                      sat_s45Yj [Occ=Once]
                                                                        :: a_a42Pu
                                                                      [LclId] =
                                                                          [eta_s45Y7
                                                                           $dNum_s45Yb] \u []
                                                                              GHC.Num.negate
                                                                                  $dNum_s45Yb
                                                                                  eta_s45Y7;
                                                                    } in 
                                                                      Numeric.showHFloat_cvt
                                                                          $dRealFloat_s45Y6
                                                                          sat_s45Yj;
                                                          } in  : [Numeric.showHFloat8 sat_s45Yk];
                                                    };
                                              };
                                        GHC.Types.True ->
                                            let {
                                              sat_s45Ym [Occ=Once] :: a_a42Pu
                                              [LclId] =
                                                  [$dNum_s45Yb] \u []
                                                      GHC.Num.fromInteger
                                                          $dNum_s45Yb Numeric.showHFloat16;
                                            } in 
                                              case GHC.Real.$p2Real $dReal_s45Ya of sat_s45Yl {
                                                __DEFAULT ->
                                                    case
                                                        GHC.Classes.< sat_s45Yl eta_s45Y7 sat_s45Ym
                                                    of
                                                    { GHC.Types.False -> Numeric.showHFloat4;
                                                      GHC.Types.True -> Numeric.showHFloat3;
                                                    };
                                              };
                                      };
                              };
                        };
                    GHC.Types.True -> Numeric.showHFloat1;
                  };
        } in  GHC.Base.++ sat_s45Yo;

sat_s45Yp :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [8#];

sat_s45Yq :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_s45Yp GHC.Types.[]];

Numeric.showOct1 :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_s45Yq;

Numeric.showOct
  :: forall a.
     (GHC.Real.Integral a, GHC.Show.Show a) =>
     a -> GHC.Show.ShowS
[GblId,
 Arity=2,
 Str=<L,U(U(U(A,A,A,A,A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),C(C1(U)),A,A,A,A),A),A,A,A,A,A,C(C1(U(U,U))),A,C(U))><L,U(A,C(U),A)>,
 Unf=OtherCon []] =
    [] \r [$dIntegral_s45Yr $dShow_s45Ys]
        let {
          sat_s45Yv [Occ=Once] :: a_a42Pk
          [LclId] =
              [$dIntegral_s45Yr] \u []
                  case GHC.Real.$p1Integral $dIntegral_s45Yr of sat_s45Yt {
                    __DEFAULT ->
                        case GHC.Real.$p1Real sat_s45Yt of sat_s45Yu {
                          __DEFAULT -> GHC.Num.fromInteger sat_s45Yu Numeric.showOct1;
                        };
                  };
        } in 
          Numeric.showIntAtBase
              $dIntegral_s45Yr $dShow_s45Ys sat_s45Yv GHC.Show.intToDigit;

Numeric.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Numeric.$trModule4];

Numeric.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [Numeric.$trModule2];

Numeric.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [Numeric.$trModule3
                                     Numeric.$trModule1];

Numeric.showGFloat_$sshowGFloat
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Float -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s45Yw x_s45Yx]
        let {
          sat_s45YA [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s45Yw x_s45Yx] \u []
                  case x_s45Yx of {
                    GHC.Types.F# ww1_s45Yz [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt1
                            GHC.Float.FFGeneric d_s45Yw GHC.Types.False ww1_s45Yz;
                  };
        } in  GHC.Base.++ sat_s45YA;

Numeric.showFFloat_$sshowFFloat
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Float -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s45YB x_s45YC]
        let {
          sat_s45YF [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s45YB x_s45YC] \u []
                  case x_s45YC of {
                    GHC.Types.F# ww1_s45YE [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt1
                            GHC.Float.FFFixed d_s45YB GHC.Types.False ww1_s45YE;
                  };
        } in  GHC.Base.++ sat_s45YF;

Numeric.showEFloat_$sshowEFloat
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Float -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s45YG x_s45YH]
        let {
          sat_s45YK [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s45YG x_s45YH] \u []
                  case x_s45YH of {
                    GHC.Types.F# ww1_s45YJ [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt1
                            GHC.Float.FFExponent d_s45YG GHC.Types.False ww1_s45YJ;
                  };
        } in  GHC.Base.++ sat_s45YK;

Numeric.showGFloat_$sshowGFloat1
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Double -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s45YL x_s45YM]
        let {
          sat_s45YP [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s45YL x_s45YM] \u []
                  case x_s45YM of {
                    GHC.Types.D# ww1_s45YO [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt
                            GHC.Float.FFGeneric d_s45YL GHC.Types.False ww1_s45YO;
                  };
        } in  GHC.Base.++ sat_s45YP;

Numeric.showGFloat
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Base.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s45YQ d_s45YR x_s45YS]
        let {
          sat_s45YT [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s45YQ d_s45YR x_s45YS] \u []
                  GHC.Float.formatRealFloatAlt
                      $dRealFloat_s45YQ
                      GHC.Float.FFGeneric
                      d_s45YR
                      GHC.Types.False
                      x_s45YS;
        } in  GHC.Base.++ sat_s45YT;

Numeric.showFFloat_$sshowFFloat1
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Double -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s45YU x_s45YV]
        let {
          sat_s45YY [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s45YU x_s45YV] \u []
                  case x_s45YV of {
                    GHC.Types.D# ww1_s45YX [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt
                            GHC.Float.FFFixed d_s45YU GHC.Types.False ww1_s45YX;
                  };
        } in  GHC.Base.++ sat_s45YY;

Numeric.showFFloat
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Base.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s45YZ d_s45Z0 x_s45Z1]
        let {
          sat_s45Z2 [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s45YZ d_s45Z0 x_s45Z1] \u []
                  GHC.Float.formatRealFloatAlt
                      $dRealFloat_s45YZ
                      GHC.Float.FFFixed
                      d_s45Z0
                      GHC.Types.False
                      x_s45Z1;
        } in  GHC.Base.++ sat_s45Z2;

Numeric.showEFloat_$sshowEFloat1
  :: GHC.Base.Maybe GHC.Types.Int
     -> GHC.Types.Double -> GHC.Show.ShowS
[GblId, Arity=2, Str=<L,U><L,1*U(U)>, Unf=OtherCon []] =
    [] \r [d_s45Z3 x_s45Z4]
        let {
          sat_s45Z7 [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [d_s45Z3 x_s45Z4] \u []
                  case x_s45Z4 of {
                    GHC.Types.D# ww1_s45Z6 [Occ=Once] ->
                        GHC.Float.$w$sformatRealFloatAlt
                            GHC.Float.FFExponent d_s45Z3 GHC.Types.False ww1_s45Z6;
                  };
        } in  GHC.Base.++ sat_s45Z7;

Numeric.showEFloat
  :: forall a.
     GHC.Float.RealFloat a =>
     GHC.Base.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
[GblId,
 Arity=3,
 Str=<L,U(U(U(U(A,A,A,C(U),A,A,C(U)),U(U(C(C1(U)),A),A,C(C1(U)),A,A,A,A,A),A),A,A,A,A,A,A),A,C(U),C(U(U)),C(U(1*U(U),A)),C(U(U,U(U))),A,A,A,A,C(U),C(U),A,C(U),A,A)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [$dRealFloat_s45Z8 d_s45Z9 x_s45Za]
        let {
          sat_s45Zb [Occ=Once] :: [GHC.Types.Char]
          [LclId] =
              [$dRealFloat_s45Z8 d_s45Z9 x_s45Za] \u []
                  GHC.Float.formatRealFloatAlt
                      $dRealFloat_s45Z8
                      GHC.Float.FFExponent
                      d_s45Z9
                      GHC.Types.False
                      x_s45Za;
        } in  GHC.Base.++ sat_s45Zb;

