
==================== Output Cmm ====================
2018-03-16 15:59:03.969704277 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:03.970603624 UTC

[section ""data" . GHC.Natural.$fNumNatural_$cabs_closure" {
     GHC.Natural.$fNumNatural_$cabs_closure:
         const GHC.Natural.$fNumNatural_$cabs_info;
 },
 GHC.Natural.$fNumNatural_$cabs_entry() //  [R2]
         { info_tbl: [(c4by7,
                       label: GHC.Natural.$fNumNatural_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4by7: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.971425867 UTC

[section ""data" . GHC.Natural.$fRealNatural_$ctoRational_closure" {
     GHC.Natural.$fRealNatural_$ctoRational_closure:
         const GHC.Natural.$fRealNatural_$ctoRational_info;
         const 0;
 },
 GHC.Natural.$fRealNatural_$ctoRational_entry() //  [R2]
         { info_tbl: [(c4bye,
                       label: GHC.Natural.$fRealNatural_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bye: // global
           R2 = R2;
           call GHC.Real.$fFractionalRatio_$s$cfromInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.97225158 UTC

[section ""data" . GHC.Natural.$fEnumNatural_$cfromEnum_closure" {
     GHC.Natural.$fEnumNatural_$cfromEnum_closure:
         const GHC.Natural.$fEnumNatural_$cfromEnum_info;
 },
 GHC.Natural.$fEnumNatural_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4bym,
                       label: GHC.Natural.$fEnumNatural_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bym: // global
           R2 = R2;
           call GHC.Enum.$fEnumInteger_$cfromEnum_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.972909209 UTC

[section ""cstring" . lvl_r4bvC_bytes" {
     lvl_r4bvC_bytes:
         I8[] [78,97,116,117,114,97,108,46,116,111,69,110,117,109,58,32,110,101,103,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.973793642 UTC

[section ""data" . lvl1_r4bvD_closure" {
     lvl1_r4bvD_closure:
         const lvl1_r4bvD_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r4bvD_entry() //  [R1]
         { info_tbl: [(c4byx,
                       label: lvl1_r4bvD_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4byx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4byy; else goto c4byz;
       c4byy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4byz: // global
           (_c4bys::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4bys::I64 == 0) goto c4byu; else goto c4byt;
       c4byu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4byt: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4bys::I64;
           I64[Sp - 24] = block_c4byv_info;
           R2 = lvl_r4bvC_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4byv() //  [R1]
         { info_tbl: [(c4byv,
                       label: block_c4byv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4byv: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.975159578 UTC

[section ""data" . GHC.Natural.$fEnumNatural_$ctoEnum_closure" {
     GHC.Natural.$fEnumNatural_$ctoEnum_closure:
         const GHC.Natural.$fEnumNatural_$ctoEnum_info;
         const 0;
 },
 GHC.Natural.$fEnumNatural_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4byK,
                       label: GHC.Natural.$fEnumNatural_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4byK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4byL; else goto c4byM;
       c4byL: // global
           R2 = R2;
           R1 = GHC.Natural.$fEnumNatural_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4byM: // global
           I64[Sp - 8] = block_c4byH_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4byV; else goto c4byI;
       u4byV: // global
           call _c4byH(R1) args: 0, res: 0, upd: 0;
       c4byI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4byH() //  [R1]
         { info_tbl: [(c4byH,
                       label: block_c4byH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4byH: // global
           _s4bvR::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4bvR::I64, 0)) goto c4byT; else goto c4byU;
       c4byT: // global
           R2 = _s4bvR::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       c4byU: // global
           R1 = lvl1_r4bvD_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.976472299 UTC

[section ""data" . GHC.Natural.$fBitsNatural1_closure" {
     GHC.Natural.$fBitsNatural1_closure:
         const GHC.Natural.$fBitsNatural1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.$fBitsNatural1_entry() //  [R1]
         { info_tbl: [(c4bz2,
                       label: GHC.Natural.$fBitsNatural1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bz2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bz3; else goto c4bz4;
       c4bz3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bz4: // global
           (_c4byZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4byZ::I64 == 0) goto c4bz1; else goto c4bz0;
       c4bz1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4bz0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4byZ::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.978358205 UTC

[section ""cstring" . lvl2_r4bvE_bytes" {
     lvl2_r4bvE_bytes:
         I8[] [78,97,116,117,114,97,108,46,112,114,101,100,58,32,48]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.979131768 UTC

[section ""data" . lvl3_r4bvF_closure" {
     lvl3_r4bvF_closure:
         const lvl3_r4bvF_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r4bvF_entry() //  [R1]
         { info_tbl: [(c4bzd,
                       label: lvl3_r4bvF_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bzd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4bze; else goto c4bzf;
       c4bze: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bzf: // global
           (_c4bz8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4bz8::I64 == 0) goto c4bza; else goto c4bz9;
       c4bza: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4bz9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4bz8::I64;
           I64[Sp - 24] = block_c4bzb_info;
           R2 = lvl2_r4bvE_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4bzb() //  [R1]
         { info_tbl: [(c4bzb,
                       label: block_c4bzb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bzb: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.980351957 UTC

[section ""data" . GHC.Natural.$fEnumNatural_$cpred_closure" {
     GHC.Natural.$fEnumNatural_$cpred_closure:
         const GHC.Natural.$fEnumNatural_$cpred_info;
         const 0;
 },
 GHC.Natural.$fEnumNatural_$cpred_entry() //  [R2]
         { info_tbl: [(c4bzs,
                       label: GHC.Natural.$fEnumNatural_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bzs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bzt; else goto c4bzu;
       c4bzt: // global
           R2 = R2;
           R1 = GHC.Natural.$fEnumNatural_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bzu: // global
           I64[Sp - 16] = block_c4bzn_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           _s4bvU::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s4bvU::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bzn() //  [R1]
         { info_tbl: [(c4bzn,
                       label: block_c4bzn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bzn: // global
           if (R1 == 1) goto c4bzr; else goto c4bzq;
       c4bzr: // global
           R1 = lvl3_r4bvF_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4bzq: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Enum.$fEnumInteger_$cpred_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.981494759 UTC

[section ""data" . GHC.Natural.$fEnumNatural_$csucc_closure" {
     GHC.Natural.$fEnumNatural_$csucc_closure:
         const GHC.Natural.$fEnumNatural_$csucc_info;
         const 0;
 },
 GHC.Natural.$fEnumNatural_$csucc_entry() //  [R2]
         { info_tbl: [(c4bzF,
                       label: GHC.Natural.$fEnumNatural_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bzF: // global
           R2 = R2;
           call GHC.Enum.$fEnumInteger_$csucc_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.982274144 UTC

[section ""data" . $ctoInteger_r4bvG_closure" {
     $ctoInteger_r4bvG_closure:
         const $ctoInteger_r4bvG_info;
 },
 $ctoInteger_r4bvG_entry() //  [R2]
         { info_tbl: [(c4bzM,
                       label: $ctoInteger_r4bvG_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bzM: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.983063327 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$ctoInteger_closure" {
     GHC.Natural.$fIntegralNatural_$ctoInteger_closure:
         const GHC.Natural.$fIntegralNatural_$ctoInteger_info;
 },
 GHC.Natural.$fIntegralNatural_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c4bzT,
                       label: GHC.Natural.$fIntegralNatural_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bzT: // global
           R2 = R2;
           call $ctoInteger_r4bvG_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.98430455 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$cdivMod_closure" {
     GHC.Natural.$fIntegralNatural_$cdivMod_closure:
         const GHC.Natural.$fIntegralNatural_$cdivMod_info;
         const 0;
 },
 ds2_s4bvZ_entry() //  [R1]
         { info_tbl: [(c4bA9,
                       label: ds2_s4bvZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bA9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4bAa; else goto c4bAb;
       c4bAa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bAb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4bA4_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           _s4bvY::P64 = P64[R1 + 24];
           R2 = _s4bvY::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s4bvY::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4bA4() //  [R1]
         { info_tbl: [(c4bA4,
                       label: block_c4bA4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bA4: // global
           if (R1 == 1) goto c4bA8; else goto c4bA7;
       c4bA8: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       c4bA7: // global
           _s4bvY::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4bAe_info;
           R3 = _s4bvY::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4bAe() //  [R1, R2]
         { info_tbl: [(c4bAe,
                       label: block_c4bAe_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bAe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4bAk; else goto c4bAj;
       c4bAk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4bAj: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Natural.$fIntegralNatural_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4bAr,
                       label: GHC.Natural.$fIntegralNatural_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bAr: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c4bAv; else goto c4bAu;
       c4bAv: // global
           HpAlloc = 104;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fIntegralNatural_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4bAu: // global
           I64[Hp - 96] = ds2_s4bvZ_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _c4bA0::P64 = Hp - 96;
           P64[Hp - 48] = _c4bA0::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c4bA0::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.986559669 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$cquotRem_closure" {
     GHC.Natural.$fIntegralNatural_$cquotRem_closure:
         const GHC.Natural.$fIntegralNatural_$cquotRem_info;
         const 0;
 },
 ds2_s4bwe_entry() //  [R1]
         { info_tbl: [(c4bAJ,
                       label: ds2_s4bwe_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bAJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4bAK; else goto c4bAL;
       c4bAK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bAL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4bAE_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           _s4bwd::P64 = P64[R1 + 24];
           R2 = _s4bwd::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s4bwd::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4bAE() //  [R1]
         { info_tbl: [(c4bAE,
                       label: block_c4bAE_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bAE: // global
           if (R1 == 1) goto c4bAI; else goto c4bAH;
       c4bAI: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       c4bAH: // global
           _s4bwd::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4bAO_info;
           R3 = _s4bwd::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4bAO() //  [R1, R2]
         { info_tbl: [(c4bAO,
                       label: block_c4bAO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bAO: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4bAU; else goto c4bAT;
       c4bAU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4bAT: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Natural.$fIntegralNatural_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c4bB1,
                       label: GHC.Natural.$fIntegralNatural_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bB1: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c4bB5; else goto c4bB4;
       c4bB5: // global
           HpAlloc = 104;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fIntegralNatural_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4bB4: // global
           I64[Hp - 96] = ds2_s4bwe_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _c4bAA::P64 = Hp - 96;
           P64[Hp - 48] = _c4bAA::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c4bAA::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.988235903 UTC

[section ""data" . GHC.Natural.$fEqNatural_closure" {
     GHC.Natural.$fEqNatural_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Integer.Type.eqInteger_closure+2;
         const GHC.Integer.Type.neqInteger_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.988777859 UTC

[section ""data" . GHC.Natural.$fOrdNatural_closure" {
     GHC.Natural.$fOrdNatural_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Natural.$fEqNatural_closure+1;
         const GHC.Integer.Type.compareInteger_closure+2;
         const GHC.Integer.Type.ltInteger_closure+2;
         const GHC.Integer.Type.leInteger_closure+2;
         const GHC.Integer.Type.gtInteger_closure+2;
         const GHC.Integer.Type.geInteger_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmax_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.989597403 UTC

[section ""data" . GHC.Natural.underflowError_closure" {
     GHC.Natural.underflowError_closure:
         const GHC.Natural.underflowError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.underflowError_entry() //  [R1]
         { info_tbl: [(c4bBc,
                       label: GHC.Natural.underflowError_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bBc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bBd; else goto c4bBe;
       c4bBd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bBe: // global
           (_c4bB9::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4bB9::I64 == 0) goto c4bBb; else goto c4bBa;
       c4bBb: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4bBa: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4bB9::I64;
           R1 = GHC.Exception.underflowException_closure;
           Sp = Sp - 16;
           call stg_raise#(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.990739168 UTC

[section ""data" . GHC.Natural.$fNumNatural_$cnegate_closure" {
     GHC.Natural.$fNumNatural_$cnegate_closure:
         const GHC.Natural.$fNumNatural_$cnegate_info;
         const 0;
 },
 GHC.Natural.$fNumNatural_$cnegate_entry() //  [R2]
         { info_tbl: [(c4bBl,
                       label: GHC.Natural.$fNumNatural_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bBl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bBm; else goto c4bBn;
       c4bBm: // global
           R2 = R2;
           R1 = GHC.Natural.$fNumNatural_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bBn: // global
           I64[Sp - 8] = block_c4bBj_info;
           R3 = R2;
           R2 = GHC.Natural.$fBitsNatural1_closure;
           Sp = Sp - 8;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bBj() //  [R1]
         { info_tbl: [(c4bBj,
                       label: block_c4bBj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bBj: // global
           I64[Sp - 8] = block_c4bBq_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bBq() //  [R1]
         { info_tbl: [(c4bBq,
                       label: block_c4bBq_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bBq: // global
           if (R1 == 1) goto c4bBB; else goto c4bBx;
       c4bBB: // global
           R1 = GHC.Natural.underflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4bBx: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.992074852 UTC

[section ""data" . GHC.Natural.naturalFromInteger_closure" {
     GHC.Natural.naturalFromInteger_closure:
         const GHC.Natural.naturalFromInteger_info;
         const 0;
 },
 GHC.Natural.naturalFromInteger_entry() //  [R2]
         { info_tbl: [(c4bBL,
                       label: GHC.Natural.naturalFromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bBL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bBM; else goto c4bBN;
       c4bBM: // global
           R2 = R2;
           R1 = GHC.Natural.naturalFromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bBN: // global
           I64[Sp - 16] = block_c4bBG_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           _s4bwu::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s4bwu::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bBG() //  [R1]
         { info_tbl: [(c4bBG,
                       label: block_c4bBG_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bBG: // global
           if (R1 == 1) goto c4bBK; else goto c4bBJ;
       c4bBK: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4bBJ: // global
           R1 = GHC.Natural.underflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.99339035 UTC

[section ""data" . GHC.Natural.$fNumNatural_$c-_closure" {
     GHC.Natural.$fNumNatural_$c-_closure:
         const GHC.Natural.$fNumNatural_$c-_info;
         const 0;
 },
 GHC.Natural.$fNumNatural_$c-_entry() //  [R2, R3]
         { info_tbl: [(c4bC0,
                       label: GHC.Natural.$fNumNatural_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bC0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bC1; else goto c4bC2;
       c4bC1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fNumNatural_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4bC2: // global
           I64[Sp - 8] = block_c4bBY_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bBY() //  [R1]
         { info_tbl: [(c4bBY,
                       label: block_c4bBY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bBY: // global
           I64[Sp - 8] = block_c4bC5_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bC5() //  [R1]
         { info_tbl: [(c4bC5,
                       label: block_c4bC5_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bC5: // global
           if (R1 == 1) goto c4bCg; else goto c4bCc;
       c4bCg: // global
           R1 = GHC.Natural.underflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4bCc: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.994627341 UTC

[section ""data" . GHC.Natural.$fNumNatural_$c+_closure" {
     GHC.Natural.$fNumNatural_$c+_closure:
         const GHC.Natural.$fNumNatural_$c+_info;
         const 0;
 },
 GHC.Natural.$fNumNatural_$c+_entry() //  [R2, R3]
         { info_tbl: [(c4bCl,
                       label: GHC.Natural.$fNumNatural_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bCl: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.995460309 UTC

[section ""data" . GHC.Natural.$fNumNatural_$c*_closure" {
     GHC.Natural.$fNumNatural_$c*_closure:
         const GHC.Natural.$fNumNatural_$c*_info;
         const 0;
 },
 GHC.Natural.$fNumNatural_$c*_entry() //  [R2, R3]
         { info_tbl: [(c4bCs,
                       label: GHC.Natural.$fNumNatural_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bCs: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.996285639 UTC

[section ""data" . GHC.Natural.$fNumNatural_$csignum_closure" {
     GHC.Natural.$fNumNatural_$csignum_closure:
         const GHC.Natural.$fNumNatural_$csignum_info;
 },
 GHC.Natural.$fNumNatural_$csignum_entry() //  [R2]
         { info_tbl: [(c4bCz,
                       label: GHC.Natural.$fNumNatural_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bCz: // global
           R2 = R2;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.996974838 UTC

[section ""data" . GHC.Natural.$fNumNatural_closure" {
     GHC.Natural.$fNumNatural_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Natural.$fNumNatural_$c+_closure+2;
         const GHC.Natural.$fNumNatural_$c-_closure+2;
         const GHC.Natural.$fNumNatural_$c*_closure+2;
         const GHC.Natural.$fNumNatural_$cnegate_closure+1;
         const GHC.Natural.$fNumNatural_$cabs_closure+1;
         const GHC.Natural.$fNumNatural_$csignum_closure+1;
         const GHC.Natural.naturalFromInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.997581406 UTC

[section ""data" . GHC.Natural.$fRealNatural_closure" {
     GHC.Natural.$fRealNatural_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Natural.$fNumNatural_closure+1;
         const GHC.Natural.$fOrdNatural_closure+1;
         const GHC.Natural.$fRealNatural_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.998233673 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$cquot_closure" {
     GHC.Natural.$fIntegralNatural_$cquot_closure:
         const GHC.Natural.$fIntegralNatural_$cquot_info;
         const 0;
 },
 GHC.Natural.$fIntegralNatural_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c4bCG,
                       label: GHC.Natural.$fIntegralNatural_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bCG: // global
           R3 = R3;
           R2 = R2;
           call GHC.Real.$fIntegralInteger_$cquot_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.999074537 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$crem_closure" {
     GHC.Natural.$fIntegralNatural_$crem_closure:
         const GHC.Natural.$fIntegralNatural_$crem_info;
         const 0;
 },
 GHC.Natural.$fIntegralNatural_$crem_entry() //  [R2, R3]
         { info_tbl: [(c4bCN,
                       label: GHC.Natural.$fIntegralNatural_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bCN: // global
           R3 = R3;
           R2 = R2;
           call GHC.Real.$fIntegralInteger_$crem_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:03.999904544 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$cdiv_closure" {
     GHC.Natural.$fIntegralNatural_$cdiv_closure:
         const GHC.Natural.$fIntegralNatural_$cdiv_info;
         const 0;
 },
 GHC.Natural.$fIntegralNatural_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4bCU,
                       label: GHC.Natural.$fIntegralNatural_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bCU: // global
           R3 = R3;
           R2 = R2;
           call GHC.Real.$fIntegralInteger_$cdiv_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.000671141 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$cmod_closure" {
     GHC.Natural.$fIntegralNatural_$cmod_closure:
         const GHC.Natural.$fIntegralNatural_$cmod_info;
         const 0;
 },
 GHC.Natural.$fIntegralNatural_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c4bD1,
                       label: GHC.Natural.$fIntegralNatural_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bD1: // global
           R3 = R3;
           R2 = R2;
           call GHC.Real.$fIntegralInteger_$cmod_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.001653478 UTC

[section ""data" . GHC.Natural.$fEnumNatural_$cenumFromThen_closure" {
     GHC.Natural.$fEnumNatural_$cenumFromThen_closure:
         const GHC.Natural.$fEnumNatural_$cenumFromThen_info;
         const 0;
 },
 GHC.Natural.$fEnumNatural_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4bDd,
                       label: GHC.Natural.$fEnumNatural_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bDd: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4bDe; else goto c4bDf;
       c4bDe: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fEnumNatural_$cenumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4bDf: // global
           I64[Sp - 24] = block_c4bD8_info;
           _s4bwB::P64 = R3;
           R3 = R3;
           _s4bwA::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s4bwA::P64;
           P64[Sp - 8] = _s4bwB::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bD8() //  [R1]
         { info_tbl: [(c4bD8,
                       label: block_c4bD8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bD8: // global
           _s4bwA::P64 = P64[Sp + 8];
           _s4bwB::P64 = P64[Sp + 16];
           if (R1 == 1) goto c4bDc; else goto c4bDb;
       c4bDc: // global
           R3 = _s4bwB::P64;
           R2 = _s4bwA::P64;
           Sp = Sp + 24;
           call GHC.Enum.$fEnumInteger_$cenumFromThen_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
       c4bDb: // global
           I64[Sp] = block_c4bDi_info;
           R3 = _s4bwA::P64;
           R2 = _s4bwB::P64;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bDi() //  [R1]
         { info_tbl: [(c4bDi,
                       label: block_c4bDi_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bDi: // global
           R4 = GHC.Natural.$fBitsNatural1_closure;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Enum.enumDeltaToInteger_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.002870752 UTC

[section ""data" . GHC.Natural.$fEnumNatural_closure" {
     GHC.Natural.$fEnumNatural_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Natural.$fEnumNatural_$csucc_closure+1;
         const GHC.Natural.$fEnumNatural_$cpred_closure+1;
         const GHC.Natural.$fEnumNatural_$ctoEnum_closure+1;
         const GHC.Natural.$fEnumNatural_$cfromEnum_closure+1;
         const GHC.Enum.$fEnumInteger_$cenumFrom_closure+1;
         const GHC.Natural.$fEnumNatural_$cenumFromThen_closure+2;
         const GHC.Enum.$fEnumInteger_$cenumFromTo_closure+2;
         const GHC.Enum.$fEnumInteger_$cenumFromThenTo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.003455133 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_closure" {
     GHC.Natural.$fIntegralNatural_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Natural.$fRealNatural_closure+1;
         const GHC.Natural.$fEnumNatural_closure+1;
         const GHC.Natural.$fIntegralNatural_$cquot_closure+2;
         const GHC.Natural.$fIntegralNatural_$crem_closure+2;
         const GHC.Natural.$fIntegralNatural_$cdiv_closure+2;
         const GHC.Natural.$fIntegralNatural_$cmod_closure+2;
         const GHC.Natural.$fIntegralNatural_$cquotRem_closure+2;
         const GHC.Natural.$fIntegralNatural_$cdivMod_closure+2;
         const GHC.Natural.$fIntegralNatural_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.004075148 UTC

[section ""data" . sat_s4bwE_closure" {
     sat_s4bwE_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.004637999 UTC

[section ""data" . sat_s4bwF_closure" {
     sat_s4bwF_closure:
         const :_con_info;
         const sat_s4bwE_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.005824029 UTC

[section ""data" . GHC.Natural.$seven_n_closure" {
     GHC.Natural.$seven_n_closure:
         const GHC.Natural.$seven_n_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.$seven_n_entry() //  [R1]
         { info_tbl: [(c4bDx,
                       label: GHC.Natural.$seven_n_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bDx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bDy; else goto c4bDz;
       c4bDy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bDz: // global
           (_c4bDu::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4bDu::I64 == 0) goto c4bDw; else goto c4bDv;
       c4bDw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4bDv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4bDu::I64;
           R3 = sat_s4bwF_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.00702147 UTC

[section ""data" . GHC.Natural.$fShowNatural_$cshow_closure" {
     GHC.Natural.$fShowNatural_$cshow_closure:
         const GHC.Natural.$fShowNatural_$cshow_info;
         const 0;
 },
 GHC.Natural.$fShowNatural_$cshow_entry() //  [R2]
         { info_tbl: [(c4bDH,
                       label: GHC.Natural.$fShowNatural_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bDH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4bDI; else goto c4bDJ;
       c4bDI: // global
           R2 = R2;
           R1 = GHC.Natural.$fShowNatural_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bDJ: // global
           I64[Sp - 8] = block_c4bDE_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = R2;
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bDE() //  [R1, R2]
         { info_tbl: [(c4bDE,
                       label: block_c4bDE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bDE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4bDM; else goto c4bDL;
       c4bDM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4bDL: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.008326039 UTC

[section ""data" . GHC.Natural.$fShowNatural1_closure" {
     GHC.Natural.$fShowNatural1_closure:
         const GHC.Natural.$fShowNatural1_info;
         const 0;
 },
 GHC.Natural.$fShowNatural1_entry() //  [R2, R3]
         { info_tbl: [(c4bDU,
                       label: GHC.Natural.$fShowNatural1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bDU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4bDV; else goto c4bDW;
       c4bDV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fShowNatural1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4bDW: // global
           I64[Sp - 8] = block_c4bDR_info;
           R4 = R3;
           R3 = R2;
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bDR() //  [R1, R2]
         { info_tbl: [(c4bDR,
                       label: block_c4bDR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bDR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4bDZ; else goto c4bDY;
       c4bDZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4bDY: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.009630996 UTC

[section ""data" . GHC.Natural.$fShowNatural_$cshowList_closure" {
     GHC.Natural.$fShowNatural_$cshowList_closure:
         const GHC.Natural.$fShowNatural_$cshowList_info;
         const 0;
 },
 GHC.Natural.$fShowNatural_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4bE4,
                       label: GHC.Natural.$fShowNatural_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bE4: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Natural.$fShowNatural1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.011462943 UTC

[section ""data" . GHC.Natural.$fShowNatural_closure" {
     GHC.Natural.$fShowNatural_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Show.$fShowInteger_$cshowsPrec_closure+3;
         const GHC.Natural.$fShowNatural_$cshow_closure+1;
         const GHC.Natural.$fShowNatural_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.012113304 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cpopCount_closure" {
     GHC.Natural.$fBitsNatural_$cpopCount_closure:
         const GHC.Natural.$fBitsNatural_$cpopCount_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cpopCount_entry() //  [R2]
         { info_tbl: [(c4bEb,
                       label: GHC.Natural.$fBitsNatural_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bEb: // global
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cpopCount_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.012916258 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$crotateR_closure" {
     GHC.Natural.$fBitsNatural_$crotateR_closure:
         const GHC.Natural.$fBitsNatural_$crotateR_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c4bEi,
                       label: GHC.Natural.$fBitsNatural_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bEi: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$crotateR_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.013799352 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$crotateL_closure" {
     GHC.Natural.$fBitsNatural_$crotateL_closure:
         const GHC.Natural.$fBitsNatural_$crotateL_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c4bEp,
                       label: GHC.Natural.$fBitsNatural_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bEp: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.014605129 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cshiftR_closure" {
     GHC.Natural.$fBitsNatural_$cshiftR_closure:
         const GHC.Natural.$fBitsNatural_$cshiftR_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c4bEw,
                       label: GHC.Natural.$fBitsNatural_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bEw: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshiftR_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.015414727 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cshiftL_closure" {
     GHC.Natural.$fBitsNatural_$cshiftL_closure:
         const GHC.Natural.$fBitsNatural_$cshiftL_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c4bED,
                       label: GHC.Natural.$fBitsNatural_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bED: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.016215594 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cisSigned_closure" {
     GHC.Natural.$fBitsNatural_$cisSigned_closure:
         const GHC.Natural.$fBitsNatural_$cisSigned_info;
 },
 GHC.Natural.$fBitsNatural_$cisSigned_entry() //  []
         { info_tbl: [(c4bEK,
                       label: GHC.Natural.$fBitsNatural_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bEK: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.016921373 UTC

[section ""cstring" . lvl4_r4bvH_bytes" {
     lvl4_r4bvH_bytes:
         I8[] [78,97,116,117,114,97,108,58,32,98,105,116,83,105,122,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.017730478 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cbitSize_closure" {
     GHC.Natural.$fBitsNatural_$cbitSize_closure:
         const GHC.Natural.$fBitsNatural_$cbitSize_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cbitSize_entry() //  [R1]
         { info_tbl: [(c4bEV,
                       label: GHC.Natural.$fBitsNatural_$cbitSize_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bEV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4bEW; else goto c4bEX;
       c4bEW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bEX: // global
           (_c4bEQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4bEQ::I64 == 0) goto c4bES; else goto c4bER;
       c4bES: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4bER: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4bEQ::I64;
           I64[Sp - 24] = block_c4bET_info;
           R2 = lvl4_r4bvH_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4bET() //  [R1]
         { info_tbl: [(c4bET,
                       label: block_c4bET_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bET: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.018793323 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cbitSizeMaybe_closure" {
     GHC.Natural.$fBitsNatural_$cbitSizeMaybe_closure:
         const GHC.Natural.$fBitsNatural_$cbitSizeMaybe_info;
 },
 GHC.Natural.$fBitsNatural_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c4bF5,
                       label: GHC.Natural.$fBitsNatural_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bF5: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.01958314 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$ctestBit_closure" {
     GHC.Natural.$fBitsNatural_$ctestBit_closure:
         const GHC.Natural.$fBitsNatural_$ctestBit_info;
 },
 GHC.Natural.$fBitsNatural_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c4bFc,
                       label: GHC.Natural.$fBitsNatural_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bFc: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$ctestBit_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.020352295 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$ccomplementBit_closure" {
     GHC.Natural.$fBitsNatural_$ccomplementBit_closure:
         const GHC.Natural.$fBitsNatural_$ccomplementBit_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c4bFj,
                       label: GHC.Natural.$fBitsNatural_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bFj: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$ccomplementBit_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.021149664 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cclearBit_closure" {
     GHC.Natural.$fBitsNatural_$cclearBit_closure:
         const GHC.Natural.$fBitsNatural_$cclearBit_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c4bFq,
                       label: GHC.Natural.$fBitsNatural_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bFq: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cclearBit_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.021971712 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$csetBit_closure" {
     GHC.Natural.$fBitsNatural_$csetBit_closure:
         const GHC.Natural.$fBitsNatural_$csetBit_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c4bFx,
                       label: GHC.Natural.$fBitsNatural_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bFx: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$csetBit_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.022753683 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$crotate_closure" {
     GHC.Natural.$fBitsNatural_$crotate_closure:
         const GHC.Natural.$fBitsNatural_$crotate_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c4bFE,
                       label: GHC.Natural.$fBitsNatural_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bFE: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.023612944 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cshift_closure" {
     GHC.Natural.$fBitsNatural_$cshift_closure:
         const GHC.Natural.$fBitsNatural_$cshift_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c4bFL,
                       label: GHC.Natural.$fBitsNatural_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bFL: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.024317045 UTC

[section ""cstring" . lvl5_r4bvI_bytes" {
     lvl5_r4bvI_bytes:
         I8[] [66,105,116,115,46,99,111,109,112,108,101,109,101,110,116,58,32,78,97,116,117,114,97,108,32,99,111,109,112,108,101,109,101,110,116,32,117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.02498109 UTC

[section ""data" . lvl6_r4bvJ_closure" {
     lvl6_r4bvJ_closure:
         const lvl6_r4bvJ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r4bvJ_entry() //  [R1]
         { info_tbl: [(c4bFU,
                       label: lvl6_r4bvJ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bFU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bFV; else goto c4bFW;
       c4bFV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bFW: // global
           (_c4bFR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4bFR::I64 == 0) goto c4bFT; else goto c4bFS;
       c4bFT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4bFS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4bFR::I64;
           R2 = lvl5_r4bvI_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.025947346 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$ccomplement_closure" {
     GHC.Natural.$fBitsNatural_$ccomplement_closure:
         const GHC.Natural.$fBitsNatural_$ccomplement_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$ccomplement_entry() //  []
         { info_tbl: [(c4bG1,
                       label: GHC.Natural.$fBitsNatural_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bG1: // global
           R2 = lvl6_r4bvJ_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.026768567 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cxor_closure" {
     GHC.Natural.$fBitsNatural_$cxor_closure:
         const GHC.Natural.$fBitsNatural_$cxor_info;
 },
 GHC.Natural.$fBitsNatural_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c4bG8,
                       label: GHC.Natural.$fBitsNatural_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bG8: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.xorInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.027548965 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$c.|._closure" {
     GHC.Natural.$fBitsNatural_$c.|._closure:
         const GHC.Natural.$fBitsNatural_$c.|._info;
 },
 GHC.Natural.$fBitsNatural_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c4bGf,
                       label: GHC.Natural.$fBitsNatural_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bGf: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.orInteger_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.028340719 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$c.&._closure" {
     GHC.Natural.$fBitsNatural_$c.&._closure:
         const GHC.Natural.$fBitsNatural_$c.&._info;
 },
 GHC.Natural.$fBitsNatural_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c4bGm,
                       label: GHC.Natural.$fBitsNatural_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bGm: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.029064516 UTC

[section ""cstring" . GHC.Natural.$trModule4_bytes" {
     GHC.Natural.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.029792993 UTC

[section ""data" . GHC.Natural.$trModule3_closure" {
     GHC.Natural.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Natural.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.030296048 UTC

[section ""cstring" . GHC.Natural.$trModule2_bytes" {
     GHC.Natural.$trModule2_bytes:
         I8[] [71,72,67,46,78,97,116,117,114,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.030816625 UTC

[section ""data" . GHC.Natural.$trModule1_closure" {
     GHC.Natural.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Natural.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.031317534 UTC

[section ""data" . GHC.Natural.$trModule_closure" {
     GHC.Natural.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Natural.$trModule3_closure+1;
         const GHC.Natural.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.031893489 UTC

[section ""data" . $krep_r4bvK_closure" {
     $krep_r4bvK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.032459638 UTC

[section ""cstring" . GHC.Natural.$tcNatural2_bytes" {
     GHC.Natural.$tcNatural2_bytes:
         I8[] [78,97,116,117,114,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.033014732 UTC

[section ""data" . GHC.Natural.$tcNatural1_closure" {
     GHC.Natural.$tcNatural1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Natural.$tcNatural2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.03358439 UTC

[section ""data" . GHC.Natural.$tcNatural_closure" {
     GHC.Natural.$tcNatural_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Natural.$trModule_closure+1;
         const GHC.Natural.$tcNatural1_closure+1;
         const GHC.Types.krep$*_closure;
         const 18275189520134122949;
         const 2097940004095541788;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.034155804 UTC

[section ""data" . $krep1_r4bvL_closure" {
     $krep1_r4bvL_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Natural.$tcNatural_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.034717294 UTC

[section ""data" . GHC.Natural.$tc'Natural1_closure" {
     GHC.Natural.$tc'Natural1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4bvK_closure+1;
         const $krep1_r4bvL_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.035255193 UTC

[section ""cstring" . GHC.Natural.$tc'Natural3_bytes" {
     GHC.Natural.$tc'Natural3_bytes:
         I8[] [39,78,97,116,117,114,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.0358477 UTC

[section ""data" . GHC.Natural.$tc'Natural2_closure" {
     GHC.Natural.$tc'Natural2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Natural.$tc'Natural3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.036400239 UTC

[section ""data" . GHC.Natural.$tc'Natural_closure" {
     GHC.Natural.$tc'Natural_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Natural.$trModule_closure+1;
         const GHC.Natural.$tc'Natural2_closure+1;
         const GHC.Natural.$tc'Natural1_closure+4;
         const 11998593531750078056;
         const 1104420550366228074;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.037217893 UTC

[section ""data" . GHC.Natural.wordToNatural_closure" {
     GHC.Natural.wordToNatural_closure:
         const GHC.Natural.wordToNatural_info;
 },
 GHC.Natural.wordToNatural_entry() //  [R2]
         { info_tbl: [(c4bGt,
                       label: GHC.Natural.wordToNatural_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bGt: // global
           R2 = R2;
           call GHC.Real.$fIntegralWord_$ctoInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.037959113 UTC

[section ""data" . sat_s4bwX_closure" {
     sat_s4bwX_closure:
         const GHC.Types.I#_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.038535946 UTC

[section ""data" . sat_s4bwY_closure" {
     sat_s4bwY_closure:
         const :_con_info;
         const sat_s4bwX_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.039120277 UTC

[section ""data" . sat_s4bwW_closure" {
     sat_s4bwW_closure:
         const GHC.Types.I#_con_info;
         const 2147483647;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.039711265 UTC

[section ""data" . sat_s4bwZ_closure" {
     sat_s4bwZ_closure:
         const :_con_info;
         const sat_s4bwW_closure+1;
         const sat_s4bwY_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.040316051 UTC

[section ""data" . sat_s4bwV_closure" {
     sat_s4bwV_closure:
         const GHC.Types.I#_con_info;
         const 2147483647;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.041832197 UTC

[section ""data" . sat_s4bx0_closure" {
     sat_s4bx0_closure:
         const :_con_info;
         const sat_s4bwV_closure+1;
         const sat_s4bwZ_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.042625768 UTC

[section ""data" . GHC.Natural.naturalToWordMaybe1_closure" {
     GHC.Natural.naturalToWordMaybe1_closure:
         const GHC.Natural.naturalToWordMaybe1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.naturalToWordMaybe1_entry() //  [R1]
         { info_tbl: [(c4bGC,
                       label: GHC.Natural.naturalToWordMaybe1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bGC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bGD; else goto c4bGE;
       c4bGD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bGE: // global
           (_c4bGz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4bGz::I64 == 0) goto c4bGB; else goto c4bGA;
       c4bGB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4bGA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4bGz::I64;
           R3 = sat_s4bx0_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.044117053 UTC

[section ""data" . GHC.Natural.naturalToWordMaybe_closure" {
     GHC.Natural.naturalToWordMaybe_closure:
         const GHC.Natural.naturalToWordMaybe_info;
         const 0;
 },
 sat_s4bx4_entry() //  [R1]
         { info_tbl: [(c4bGU,
                       label: sat_s4bx4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bGU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4bGY; else goto c4bGZ;
       c4bGY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bGZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4bGS_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4bGS() //  [R1]
         { info_tbl: [(c4bGS,
                       label: block_c4bGS_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bGS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4bH2; else goto c4bH1;
       c4bH2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c4bH1: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Natural.naturalToWordMaybe_entry() //  [R2]
         { info_tbl: [(c4bH6,
                       label: GHC.Natural.naturalToWordMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bH6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bH7; else goto c4bH8;
       c4bH7: // global
           R2 = R2;
           R1 = GHC.Natural.naturalToWordMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bH8: // global
           I64[Sp - 16] = block_c4bGJ_info;
           R3 = GHC.Natural.naturalToWordMaybe1_closure;
           _s4bx1::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s4bx1::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bGJ() //  [R1]
         { info_tbl: [(c4bGJ,
                       label: block_c4bGJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bGJ: // global
           if (R1 == 1) goto c4bH5; else goto c4bH4;
       c4bH5: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4bHe; else goto c4bHd;
       c4bHe: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4bHd: // global
           I64[Hp - 32] = sat_s4bx4_info;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4bH4: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.047021617 UTC

[section ""data" . GHC.Natural.$fReadNatural_go_closure" {
     GHC.Natural.$fReadNatural_go_closure:
         const GHC.Natural.$fReadNatural_go_info;
         const 0;
 },
 sat_s4bxe_entry() //  [R1]
         { info_tbl: [(c4bHD,
                       label: sat_s4bxe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bHD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bHE; else goto c4bHF;
       c4bHE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bHF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Natural.$fReadNatural_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u4bI6_srtd" {
     u4bI6_srtd:
         const S4byh_srt+40;
         const 40;
         const 549755813889;
 },
 GHC.Natural.$fReadNatural_go_entry() //  [R2]
         { info_tbl: [(c4bHK,
                       label: GHC.Natural.$fReadNatural_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bHK: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4bHL; else goto u4bI0;
       c4bHL: // global
           R2 = R2;
           R1 = GHC.Natural.$fReadNatural_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u4bI0: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c4bHg() args: 0, res: 0, upd: 0;
     }
 },
 _c4bHg() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bHg: // global
           _s4bx5::P64 = P64[Sp];
           I64[Sp] = block_c4bHj_info;
           R1 = _s4bx5::P64;
           if (R1 & 7 != 0) goto u4bI2; else goto c4bHk;
       u4bI2: // global
           call _c4bHj(R1) args: 0, res: 0, upd: 0;
       c4bHk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bI7_srtd" {
     u4bI7_srtd:
         const S4byh_srt+40;
         const 40;
         const 549755813889;
 },
 _c4bHj() //  [R1]
         { info_tbl: [(c4bHj,
                       label: block_c4bHj_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bHj: // global
           if (R1 & 7 == 1) goto c4bHH; else goto c4bHI;
       c4bHH: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4bHI: // global
           I64[Sp - 8] = block_c4bHp_info;
           _s4bx8::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4bx8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4bI3; else goto c4bHq;
       u4bI3: // global
           call _c4bHp(R1) args: 0, res: 0, upd: 0;
       c4bHq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bI8_srtd" {
     u4bI8_srtd:
         const S4byh_srt+40;
         const 40;
         const 549755813889;
 },
 _c4bHp() //  [R1]
         { info_tbl: [(c4bHp,
                       label: block_c4bHp_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bHp: // global
           I64[Sp - 8] = block_c4bHu_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = P64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bI9_srtd" {
     u4bI9_srtd:
         const S4byh_srt+40;
         const 40;
         const 549755813889;
 },
 _c4bHu() //  [R1]
         { info_tbl: [(c4bHu,
                       label: block_c4bHu_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bHu: // global
           _s4bx8::P64 = P64[Sp + 16];
           if (R1 == 1) goto c4bHW; else goto c4bHU;
       c4bHW: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4bHZ; else goto c4bHY;
       c4bHZ: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4bHY: // global
           I64[Hp - 40] = sat_s4bxe_info;
           P64[Hp - 24] = _s4bx8::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4bHU: // global
           P64[Sp + 16] = _s4bx8::P64;
           Sp = Sp + 16;
           call _c4bHg() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.049596225 UTC

[section ""data" . GHC.Natural.$fReadNatural_$creadsPrec_closure" {
     GHC.Natural.$fReadNatural_$creadsPrec_closure:
         const GHC.Natural.$fReadNatural_$creadsPrec_info;
         const 0;
 },
 g_s4bxg_entry() //  [R1]
         { info_tbl: [(c4bIi,
                       label: g_s4bxg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bIi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bIj; else goto c4bIk;
       c4bIj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bIk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.Read.$fReadInteger2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.$fReadInteger_$sreadNumber_entry(R4,
                                                          R3,
                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4bxj_entry() //  [R1, R2]
         { info_tbl: [(c4bIs,
                       label: sat_s4bxj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bIs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4bIt; else goto c4bIu;
       c4bIt: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bIu: // global
           I64[Sp - 8] = block_c4bIq_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bIq() //  [R1]
         { info_tbl: [(c4bIq,
                       label: block_c4bIq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bIq: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Natural.$fReadNatural_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Natural.$fReadNatural_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c4bIy,
                       label: GHC.Natural.$fReadNatural_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bIy: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4bIC; else goto c4bIB;
       c4bIC: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Natural.$fReadNatural_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bIB: // global
           I64[Hp - 32] = g_s4bxg_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s4bxj_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.051676529 UTC

[section ""data" . GHC.Natural.$fReadNatural4_closure" {
     GHC.Natural.$fReadNatural4_closure:
         const GHC.Natural.$fReadNatural4_info;
         const 0;
 },
 g_s4bxl_entry() //  [R1]
         { info_tbl: [(c4bIL,
                       label: g_s4bxl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bIL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bIM; else goto c4bIN;
       c4bIM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bIN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.Read.$fReadInteger2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.$fReadInteger_$sreadNumber_entry(R4,
                                                          R3,
                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 w_s4bxm_entry() //  [R1, R2]
         { info_tbl: [(c4bIV,
                       label: w_s4bxm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bIV: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4bIW; else goto c4bIX;
       c4bIW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bIX: // global
           I64[Sp - 8] = block_c4bIT_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bIT() //  [R1]
         { info_tbl: [(c4bIT,
                       label: block_c4bIT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bIT: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Natural.$fReadNatural_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4bxs_entry() //  [R1, R2]
         { info_tbl: [(c4bJ9,
                       label: sat_s4bxs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bJ9: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4bJa; else goto c4bJb;
       c4bJa: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bJb: // global
           I64[Sp - 8] = block_c4bJ6_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bJ6() //  [R1]
         { info_tbl: [(c4bJ6,
                       label: block_c4bJ6_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bJ6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4bJe; else goto c4bJd;
       c4bJe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4bJd: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Natural.$fReadNatural4_entry() //  [R2]
         { info_tbl: [(c4bJf,
                       label: GHC.Natural.$fReadNatural4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bJf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4bJj; else goto c4bJi;
       c4bJj: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.Natural.$fReadNatural4_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bJi: // global
           I64[Hp - 48] = g_s4bxl_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = w_s4bxm_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s4bxs_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.053986469 UTC

[section ""data" . GHC.Natural.$fReadNatural3_closure" {
     GHC.Natural.$fReadNatural3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.054691245 UTC

[section ""data" . GHC.Natural.$fReadNatural2_closure" {
     GHC.Natural.$fReadNatural2_closure:
         const GHC.Natural.$fReadNatural2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.$fReadNatural2_entry() //  [R1]
         { info_tbl: [(c4bJq,
                       label: GHC.Natural.$fReadNatural2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bJq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4bJr; else goto c4bJs;
       c4bJr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bJs: // global
           (_c4bJn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4bJn::I64 == 0) goto c4bJp; else goto c4bJo;
       c4bJp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4bJo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4bJn::I64;
           R2 = GHC.Natural.$fReadNatural4_closure+1;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Natural.$fReadNatural3_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.055736797 UTC

[section ""data" . GHC.Natural.$fReadNatural_$creadList_closure" {
     GHC.Natural.$fReadNatural_$creadList_closure:
         const GHC.Natural.$fReadNatural_$creadList_info;
         const 0;
 },
 GHC.Natural.$fReadNatural_$creadList_entry() //  [R2]
         { info_tbl: [(c4bJx,
                       label: GHC.Natural.$fReadNatural_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bJx: // global
           R3 = R2;
           R2 = GHC.Natural.$fReadNatural2_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.056686812 UTC

[section ""data" . GHC.Natural.$fReadNatural1_closure" {
     GHC.Natural.$fReadNatural1_closure:
         const GHC.Natural.$fReadNatural1_info;
         const 0;
 },
 GHC.Natural.$fReadNatural1_entry() //  [R2, R3]
         { info_tbl: [(c4bJH,
                       label: GHC.Natural.$fReadNatural1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bJH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4bJI; else goto c4bJJ;
       c4bJI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fReadNatural1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4bJJ: // global
           I64[Sp - 8] = block_c4bJE_info;
           R3 = R3;
           R2 = GHC.Natural.$fReadNatural_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bJE() //  [R1]
         { info_tbl: [(c4bJE,
                       label: block_c4bJE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bJE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4bJM; else goto c4bJL;
       c4bJM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4bJL: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.057800256 UTC

[section ""data" . GHC.Natural.$fReadNatural_closure" {
     GHC.Natural.$fReadNatural_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Natural.$fReadNatural_$creadsPrec_closure+1;
         const GHC.Natural.$fReadNatural_$creadList_closure+1;
         const GHC.Natural.$fReadNatural4_closure+1;
         const GHC.Natural.$fReadNatural1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.058536703 UTC

[section ""data" . GHC.Natural.isValidNatural_closure" {
     GHC.Natural.isValidNatural_closure:
         const GHC.Natural.isValidNatural_info;
         const 0;
 },
 GHC.Natural.isValidNatural_entry() //  [R2]
         { info_tbl: [(c4bJT,
                       label: GHC.Natural.isValidNatural_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bJT: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4bJU; else goto c4bJV;
       c4bJU: // global
           R2 = R2;
           R1 = GHC.Natural.isValidNatural_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bJV: // global
           I64[Sp - 8] = block_c4bJR_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bJR() //  [R1]
         { info_tbl: [(c4bJR,
                       label: block_c4bJR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bJR: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.059881584 UTC

[section ""data" . GHC.Natural.minusNaturalMaybe_closure" {
     GHC.Natural.minusNaturalMaybe_closure:
         const GHC.Natural.minusNaturalMaybe_info;
         const 0;
 },
 sat_s4bxC_entry() //  [R1]
         { info_tbl: [(c4bKc,
                       label: sat_s4bxC_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bKc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bKd; else goto c4bKe;
       c4bKd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bKe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Natural.$fNumNatural_$c-_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Natural.minusNaturalMaybe_entry() //  [R2, R3]
         { info_tbl: [(c4bKi,
                       label: GHC.Natural.minusNaturalMaybe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bKi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4bKj; else goto c4bKk;
       c4bKj: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.minusNaturalMaybe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4bKk: // global
           I64[Sp - 24] = block_c4bK3_info;
           _s4bxA::P64 = R3;
           R3 = R3;
           _s4bxz::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s4bxz::P64;
           P64[Sp - 8] = _s4bxA::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bK3() //  [R1]
         { info_tbl: [(c4bK3,
                       label: block_c4bK3_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bK3: // global
           if (R1 == 1) goto c4bKh; else goto c4bKg;
       c4bKh: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4bKq; else goto c4bKp;
       c4bKq: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4bKp: // global
           I64[Hp - 40] = sat_s4bxC_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4bKg: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.061342683 UTC

[section ""data" . GHC.Natural.$fIxNatural_closure" {
     GHC.Natural.$fIxNatural_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Natural.$fOrdNatural_closure+1;
         const GHC.Arr.$fIxInteger_$crange_closure+1;
         const GHC.Arr.$fIxInteger_$cindex_closure+2;
         const GHC.Arr.$fIxInteger_$cunsafeIndex_closure+2;
         const GHC.Arr.$fIxInteger_$cinRange_closure+2;
         const GHC.Arr.$fIxInteger_$crangeSize_closure+1;
         const GHC.Arr.$fIxInteger_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.062061904 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cunsafeShiftL_closure" {
     GHC.Natural.$fBitsNatural_$cunsafeShiftL_closure:
         const GHC.Natural.$fBitsNatural_$cunsafeShiftL_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c4bKv,
                       label: GHC.Natural.$fBitsNatural_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bKv: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.062860988 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cunsafeShiftR_closure" {
     GHC.Natural.$fBitsNatural_$cunsafeShiftR_closure:
         const GHC.Natural.$fBitsNatural_$cunsafeShiftR_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c4bKC,
                       label: GHC.Natural.$fBitsNatural_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bKC: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshiftR_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.063625671 UTC

[section ""data" . GHC.Natural.$fBitsNatural_closure" {
     GHC.Natural.$fBitsNatural_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Natural.$fEqNatural_closure+1;
         const GHC.Natural.$fBitsNatural_$c.&._closure+2;
         const GHC.Natural.$fBitsNatural_$c.|._closure+2;
         const GHC.Natural.$fBitsNatural_$cxor_closure+2;
         const GHC.Natural.$fBitsNatural_$ccomplement_closure+1;
         const GHC.Natural.$fBitsNatural_$cshift_closure+2;
         const GHC.Natural.$fBitsNatural_$crotate_closure+2;
         const GHC.Natural.$fBitsNatural1_closure;
         const Data.Bits.$fBitsInteger_$cbit_closure+1;
         const GHC.Natural.$fBitsNatural_$csetBit_closure+2;
         const GHC.Natural.$fBitsNatural_$cclearBit_closure+2;
         const GHC.Natural.$fBitsNatural_$ccomplementBit_closure+2;
         const GHC.Natural.$fBitsNatural_$ctestBit_closure+2;
         const GHC.Natural.$fBitsNatural_$cbitSizeMaybe_closure+1;
         const GHC.Natural.$fBitsNatural_$cbitSize_closure;
         const GHC.Natural.$fBitsNatural_$cisSigned_closure+1;
         const GHC.Natural.$fBitsNatural_$cshiftL_closure+2;
         const GHC.Natural.$fBitsNatural_$cunsafeShiftL_closure+2;
         const GHC.Natural.$fBitsNatural_$cshiftR_closure+2;
         const GHC.Natural.$fBitsNatural_$cunsafeShiftR_closure+2;
         const GHC.Natural.$fBitsNatural_$crotateL_closure+2;
         const GHC.Natural.$fBitsNatural_$crotateR_closure+2;
         const GHC.Natural.$fBitsNatural_$cpopCount_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.064378324 UTC

[section ""data" . sat_s4bxD_closure" {
     sat_s4bxD_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.064944559 UTC

[section ""data" . sat_s4bxE_closure" {
     sat_s4bxE_closure:
         const :_con_info;
         const sat_s4bxD_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.065746314 UTC

[section ""data" . GHC.Natural.powModNatural1_closure" {
     GHC.Natural.powModNatural1_closure:
         const GHC.Natural.powModNatural1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.powModNatural1_entry() //  [R1]
         { info_tbl: [(c4bKL,
                       label: GHC.Natural.powModNatural1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bKL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bKM; else goto c4bKN;
       c4bKM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bKN: // global
           (_c4bKI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4bKI::I64 == 0) goto c4bKK; else goto c4bKJ;
       c4bKK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4bKJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4bKI::I64;
           R3 = sat_s4bxE_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.068142999 UTC

[section ""data" . GHC.Natural.powModNatural_closure" {
     GHC.Natural.powModNatural_closure:
         const GHC.Natural.powModNatural_info;
         const 0;
 },
 section ""relreadonly" . u4bNk_srtd" {
     u4bNk_srtd:
         const S4byh_srt+80;
         const 53;
         const 8743316464075777;
 },
 GHC.Natural.powModNatural_entry() //  [R2, R3, R4]
         { info_tbl: [(c4bKX,
                       label: GHC.Natural.powModNatural_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bKX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4bKY; else goto c4bKZ;
       c4bKY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.powModNatural_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4bKZ: // global
           I64[Sp - 32] = block_c4bKS_info;
           _s4bxG::P64 = R3;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           _s4bxF::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _s4bxF::P64;
           P64[Sp - 16] = _s4bxG::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bNl_srtd" {
     u4bNl_srtd:
         const S4byh_srt+80;
         const 53;
         const 7617416557233153;
 },
 _c4bKS() //  [R1]
         { info_tbl: [(c4bKS,
                       label: block_c4bKS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bKS: // global
           if (R1 == 1) goto c4bKW; else goto c4bKV;
       c4bKW: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4bKV: // global
           I64[Sp] = block_c4bL2_info;
           R3 = GHC.Natural.powModNatural1_closure;
           R2 = P64[Sp + 24];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bNm_srtd" {
     u4bNm_srtd:
         const S4byh_srt+160;
         const 43;
         const 7438883356673;
 },
 _c4bL2() //  [R1]
         { info_tbl: [(c4bL2,
                       label: block_c4bL2_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bL2: // global
           if (R1 == 1) goto u4bN5; else goto c4bLa;
       u4bN5: // global
           Sp = Sp + 32;
           call _c4bN1() args: 0, res: 0, upd: 0;
       c4bLa: // global
           I64[Sp] = block_c4bL7_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bNn_srtd" {
     u4bNn_srtd:
         const S4byh_srt+160;
         const 43;
         const 7438883356673;
 },
 _c4bL7() //  [R1]
         { info_tbl: [(c4bL7,
                       label: block_c4bL7_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bL7: // global
           if (R1 == 1) goto u4bN6; else goto c4bLh;
       u4bN6: // global
           Sp = Sp + 32;
           call _c4bMX() args: 0, res: 0, upd: 0;
       c4bLh: // global
           I64[Sp] = block_c4bLe_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bNo_srtd" {
     u4bNo_srtd:
         const S4byh_srt+160;
         const 43;
         const 7438883356673;
 },
 _c4bLe() //  [R1]
         { info_tbl: [(c4bLe,
                       label: block_c4bLe_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bLe: // global
           if (R1 == 1) goto u4bN7; else goto c4bLo;
       u4bN7: // global
           Sp = Sp + 32;
           call _c4bN1() args: 0, res: 0, upd: 0;
       c4bLo: // global
           I64[Sp] = block_c4bLl_info;
           R3 = GHC.Natural.powModNatural1_closure;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bN1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bN1: // global
           R1 = GHC.Natural.$fBitsNatural1_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u4bNp_srtd" {
     u4bNp_srtd:
         const S4byh_srt+160;
         const 43;
         const 7438883356673;
 },
 _c4bLl() //  [R1]
         { info_tbl: [(c4bLl,
                       label: block_c4bLl_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bLl: // global
           if (R1 == 1) goto u4bN8; else goto c4bML;
       u4bN8: // global
           Sp = Sp + 32;
           call _c4bMX() args: 0, res: 0, upd: 0;
       c4bML: // global
           P64[Sp] = GHC.Natural.powModNatural1_closure;
           _s4bxO::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s4bxO::P64;
           call _c4bLw() args: 0, res: 0, upd: 0;
     }
 },
 _c4bMX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bMX: // global
           R1 = GHC.Natural.powModNatural1_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4bLw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bLw: // global
           I64[Sp - 8] = block_c4bLy_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4bNh; else goto c4bLz;
       u4bNh: // global
           call _c4bLy(R1) args: 0, res: 0, upd: 0;
       c4bLz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bNq_srtd" {
     u4bNq_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4bLy() //  [R1]
         { info_tbl: [(c4bLy,
                       label: block_c4bLy_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bLy: // global
           I64[Sp] = block_c4bLD_info;
           R3 = GHC.Natural.$seven_n_closure;
           R2 = P64[Sp + 16];
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.remInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bNr_srtd" {
     u4bNr_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4bLD() //  [R1]
         { info_tbl: [(c4bLD,
                       label: block_c4bLD_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bLD: // global
           I64[Sp] = block_c4bLJ_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = R1;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bNs_srtd" {
     u4bNs_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4bLJ() //  [R1]
         { info_tbl: [(c4bLJ,
                       label: block_c4bLJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bLJ: // global
           if (R1 == 1) goto c4bMk; else goto c4bM7;
       c4bMk: // global
           I64[Sp] = block_c4bMi_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       c4bM7: // global
           _s4bxQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4bLO_info;
           R3 = P64[Sp + 24];
           R2 = _s4bxQ::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bNt_srtd" {
     u4bNt_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4bMi() //  [R1]
         { info_tbl: [(c4bMi,
                       label: block_c4bMi_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bMi: // global
           if (R1 == 1) goto c4bMJ; else goto c4bMz;
       c4bMJ: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4bMz: // global
           I64[Sp] = block_c4bMo_info;
           R3 = 1;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bNu_srtd" {
     u4bNu_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4bMo() //  [R1]
         { info_tbl: [(c4bMo,
                       label: block_c4bMo_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bMo: // global
           I64[Sp] = block_c4bMs_info;
           _s4bxR::P64 = P64[Sp + 24];
           R3 = _s4bxR::P64;
           R2 = _s4bxR::P64;
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bNv_srtd" {
     u4bNv_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4bMs() //  [R1]
         { info_tbl: [(c4bMs,
                       label: block_c4bMs_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bMs: // global
           I64[Sp] = block_c4bMw_info;
           R3 = P64[Sp + 32];
           R2 = R1;
           call GHC.Integer.Type.modInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bNw_srtd" {
     u4bNw_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4bMw() //  [R1]
         { info_tbl: [(c4bMw,
                       label: block_c4bMw_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bMw: // global
           _s4bxP::P64 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           P64[Sp + 16] = _s4bxP::P64;
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c4bLw() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . u4bNx_srtd" {
     u4bNx_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4bLO() //  [R1]
         { info_tbl: [(c4bLO,
                       label: block_c4bLO_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bLO: // global
           I64[Sp] = block_c4bLS_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Integer.Type.modInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bNy_srtd" {
     u4bNy_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4bLS() //  [R1]
         { info_tbl: [(c4bLS,
                       label: block_c4bLS_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bLS: // global
           I64[Sp] = block_c4bLW_info;
           R3 = 1;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bNz_srtd" {
     u4bNz_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4bLW() //  [R1]
         { info_tbl: [(c4bLW,
                       label: block_c4bLW_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bLW: // global
           I64[Sp] = block_c4bM0_info;
           _s4bxR::P64 = P64[Sp + 16];
           R3 = _s4bxR::P64;
           R2 = _s4bxR::P64;
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bNA_srtd" {
     u4bNA_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4bM0() //  [R1]
         { info_tbl: [(c4bM0,
                       label: block_c4bM0_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bM0: // global
           I64[Sp] = block_c4bM4_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Integer.Type.modInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bNB_srtd" {
     u4bNB_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4bM4() //  [R1]
         { info_tbl: [(c4bM4,
                       label: block_c4bM4_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bM4: // global
           _s4bxP::P64 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           _s4bxQ::P64 = P64[Sp + 8];
           P64[Sp + 8] = _s4bxP::P64;
           P64[Sp] = _s4bxQ::P64;
           call _c4bLw() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.07307712 UTC

[section ""relreadonly" . S4byh_srt" {
     S4byh_srt:
         const GHC.Real.$fFractionalRatio_$s$cfromInteger_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Natural.$fEnumNatural_$ctoEnum_closure;
         const lvl1_r4bvD_closure;
         const GHC.Enum.$fEnumInteger_$cpred_closure;
         const GHC.Natural.$fBitsNatural1_closure;
         const GHC.Natural.$fEnumNatural_$cpred_closure;
         const lvl3_r4bvF_closure;
         const GHC.Enum.$fEnumInteger_$csucc_closure;
         const GHC.Integer.Type.divModInteger_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Natural.$fIntegralNatural_$cdivMod_closure;
         const GHC.Natural.$fIntegralNatural_$cquotRem_closure;
         const GHC.Exception.underflowException_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.Natural.underflowError_closure;
         const GHC.Natural.$fNumNatural_$cnegate_closure;
         const GHC.Natural.naturalFromInteger_closure;
         const GHC.Natural.$fNumNatural_$c-_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$fIntegralInteger_$cquot_closure;
         const GHC.Real.$fIntegralInteger_$crem_closure;
         const GHC.Real.$fIntegralInteger_$cdiv_closure;
         const GHC.Real.$fIntegralInteger_$cmod_closure;
         const GHC.Enum.enumDeltaToInteger_closure;
         const GHC.Enum.$fEnumInteger_$cenumFromThen_closure;
         const GHC.Natural.$fEnumNatural_$cenumFromThen_closure;
         const sat_s4bwF_closure;
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Natural.$fShowNatural_$cshow_closure;
         const GHC.Natural.$fShowNatural1_closure;
         const Data.Bits.$fBitsInteger_$cpopCount_closure;
         const Data.Bits.$fBitsInteger_$crotateR_closure;
         const Data.Bits.$fBitsInteger_$cshift_closure;
         const Data.Bits.$fBitsInteger_$cshiftR_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Bits.$fBitsInteger_$ccomplementBit_closure;
         const Data.Bits.$fBitsInteger_$cclearBit_closure;
         const Data.Bits.$fBitsInteger_$csetBit_closure;
         const lvl6_r4bvJ_closure;
         const sat_s4bx0_closure;
         const GHC.Natural.naturalToWordMaybe_closure;
         const GHC.Natural.naturalToWordMaybe1_closure;
         const GHC.Natural.$fReadNatural_go_closure;
         const GHC.Read.$fReadInteger2_closure;
         const GHC.Read.$fReadInteger_$sreadNumber_closure;
         const GHC.Natural.$fReadNatural_$creadsPrec_closure;
         const GHC.Natural.$fReadNatural4_closure;
         const GHC.Read.list_closure;
         const GHC.Natural.$fReadNatural2_closure;
         const GHC.Natural.$fReadNatural1_closure;
         const GHC.Natural.$fReadNatural_$creadList_closure;
         const GHC.Natural.isValidNatural_closure;
         const GHC.Natural.$fBitsNatural1_closure;
         const GHC.Natural.$fNumNatural_$c-_closure;
         const GHC.Natural.minusNaturalMaybe_closure;
         const sat_s4bxE_closure;
         const GHC.Integer.Type.modInteger_closure;
         const GHC.Integer.Type.shiftRInteger_closure;
         const GHC.Natural.powModNatural_closure;
         const GHC.Natural.$seven_n_closure;
         const GHC.Natural.powModNatural1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.074118272 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:04.075825295 UTC

[section ""data" . GHC.Natural.$fNumNatural_$cabs_closure" {
     GHC.Natural.$fNumNatural_$cabs_closure:
         const GHC.Natural.$fNumNatural_$cabs_info;
 },
 GHC.Natural.$fNumNatural_$cabs_entry() //  [R2]
         { info_tbl: [(c4bNG,
                       label: GHC.Natural.$fNumNatural_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bNG: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.076649151 UTC

[section ""data" . GHC.Natural.$fRealNatural_$ctoRational_closure" {
     GHC.Natural.$fRealNatural_$ctoRational_closure:
         const GHC.Natural.$fRealNatural_$ctoRational_info;
         const 0;
 },
 GHC.Natural.$fRealNatural_$ctoRational_entry() //  [R2]
         { info_tbl: [(c4bNN,
                       label: GHC.Natural.$fRealNatural_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bNN: // global
           R2 = R2;
           call GHC.Real.$fFractionalRatio_$s$cfromInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.077445667 UTC

[section ""data" . GHC.Natural.$fEnumNatural_$cfromEnum_closure" {
     GHC.Natural.$fEnumNatural_$cfromEnum_closure:
         const GHC.Natural.$fEnumNatural_$cfromEnum_info;
 },
 GHC.Natural.$fEnumNatural_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4bNU,
                       label: GHC.Natural.$fEnumNatural_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bNU: // global
           R2 = R2;
           call GHC.Enum.$fEnumInteger_$cfromEnum_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.078132631 UTC

[section ""cstring" . lvl_r4bvC_bytes" {
     lvl_r4bvC_bytes:
         I8[] [78,97,116,117,114,97,108,46,116,111,69,110,117,109,58,32,110,101,103,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.078918821 UTC

[section ""data" . lvl1_r4bvD_closure" {
     lvl1_r4bvD_closure:
         const lvl1_r4bvD_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r4bvD_entry() //  [R1]
         { info_tbl: [(c4bO5,
                       label: lvl1_r4bvD_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bO5: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4bO6; else goto c4bO7;
       c4bO6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bO7: // global
           (_c4bO0::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4bO0::I64 == 0) goto c4bO2; else goto c4bO1;
       c4bO2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4bO1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4bO0::I64;
           I64[Sp - 24] = block_c4bO3_info;
           R2 = lvl_r4bvC_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4bO3() //  [R1]
         { info_tbl: [(c4bO3,
                       label: block_c4bO3_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bO3: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.080198157 UTC

[section ""data" . GHC.Natural.$fEnumNatural_$ctoEnum_closure" {
     GHC.Natural.$fEnumNatural_$ctoEnum_closure:
         const GHC.Natural.$fEnumNatural_$ctoEnum_info;
         const 0;
 },
 GHC.Natural.$fEnumNatural_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4bOi,
                       label: GHC.Natural.$fEnumNatural_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bOi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4bOj; else goto c4bOk;
       c4bOj: // global
           R2 = R2;
           R1 = GHC.Natural.$fEnumNatural_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bOk: // global
           I64[Sp - 8] = block_c4bOf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4bOt; else goto c4bOg;
       u4bOt: // global
           call _c4bOf(R1) args: 0, res: 0, upd: 0;
       c4bOg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4bOf() //  [R1]
         { info_tbl: [(c4bOf,
                       label: block_c4bOf_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bOf: // global
           _s4bvR::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4bvR::I64, 0)) goto c4bOr; else goto c4bOs;
       c4bOr: // global
           R2 = _s4bvR::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       c4bOs: // global
           R1 = lvl1_r4bvD_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.081461878 UTC

[section ""data" . GHC.Natural.$fBitsNatural1_closure" {
     GHC.Natural.$fBitsNatural1_closure:
         const GHC.Natural.$fBitsNatural1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.$fBitsNatural1_entry() //  [R1]
         { info_tbl: [(c4bOA,
                       label: GHC.Natural.$fBitsNatural1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bOA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bOB; else goto c4bOC;
       c4bOB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bOC: // global
           (_c4bOx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4bOx::I64 == 0) goto c4bOz; else goto c4bOy;
       c4bOz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4bOy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4bOx::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.082364395 UTC

[section ""cstring" . lvl2_r4bvE_bytes" {
     lvl2_r4bvE_bytes:
         I8[] [78,97,116,117,114,97,108,46,112,114,101,100,58,32,48]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.083096691 UTC

[section ""data" . lvl3_r4bvF_closure" {
     lvl3_r4bvF_closure:
         const lvl3_r4bvF_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r4bvF_entry() //  [R1]
         { info_tbl: [(c4bOL,
                       label: lvl3_r4bvF_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bOL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4bOM; else goto c4bON;
       c4bOM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bON: // global
           (_c4bOG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4bOG::I64 == 0) goto c4bOI; else goto c4bOH;
       c4bOI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4bOH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4bOG::I64;
           I64[Sp - 24] = block_c4bOJ_info;
           R2 = lvl2_r4bvE_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4bOJ() //  [R1]
         { info_tbl: [(c4bOJ,
                       label: block_c4bOJ_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bOJ: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.084326395 UTC

[section ""data" . GHC.Natural.$fEnumNatural_$cpred_closure" {
     GHC.Natural.$fEnumNatural_$cpred_closure:
         const GHC.Natural.$fEnumNatural_$cpred_info;
         const 0;
 },
 GHC.Natural.$fEnumNatural_$cpred_entry() //  [R2]
         { info_tbl: [(c4bP0,
                       label: GHC.Natural.$fEnumNatural_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bP0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bP1; else goto c4bP2;
       c4bP1: // global
           R2 = R2;
           R1 = GHC.Natural.$fEnumNatural_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bP2: // global
           I64[Sp - 16] = block_c4bOV_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           _s4bvU::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s4bvU::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bOV() //  [R1]
         { info_tbl: [(c4bOV,
                       label: block_c4bOV_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bOV: // global
           if (R1 == 1) goto c4bOZ; else goto c4bOY;
       c4bOZ: // global
           R1 = lvl3_r4bvF_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4bOY: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Enum.$fEnumInteger_$cpred_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.085520544 UTC

[section ""data" . GHC.Natural.$fEnumNatural_$csucc_closure" {
     GHC.Natural.$fEnumNatural_$csucc_closure:
         const GHC.Natural.$fEnumNatural_$csucc_info;
         const 0;
 },
 GHC.Natural.$fEnumNatural_$csucc_entry() //  [R2]
         { info_tbl: [(c4bPd,
                       label: GHC.Natural.$fEnumNatural_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bPd: // global
           R2 = R2;
           call GHC.Enum.$fEnumInteger_$csucc_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.08634106 UTC

[section ""data" . $ctoInteger_r4bvG_closure" {
     $ctoInteger_r4bvG_closure:
         const $ctoInteger_r4bvG_info;
 },
 $ctoInteger_r4bvG_entry() //  [R2]
         { info_tbl: [(c4bPk,
                       label: $ctoInteger_r4bvG_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bPk: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.087104335 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$ctoInteger_closure" {
     GHC.Natural.$fIntegralNatural_$ctoInteger_closure:
         const GHC.Natural.$fIntegralNatural_$ctoInteger_info;
 },
 GHC.Natural.$fIntegralNatural_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c4bPr,
                       label: GHC.Natural.$fIntegralNatural_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bPr: // global
           R2 = R2;
           call $ctoInteger_r4bvG_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.088362988 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$cdivMod_closure" {
     GHC.Natural.$fIntegralNatural_$cdivMod_closure:
         const GHC.Natural.$fIntegralNatural_$cdivMod_info;
         const 0;
 },
 ds2_s4bvZ_entry() //  [R1]
         { info_tbl: [(c4bPH,
                       label: ds2_s4bvZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bPH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4bPI; else goto c4bPJ;
       c4bPI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bPJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4bPC_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           _s4bvY::P64 = P64[R1 + 24];
           R2 = _s4bvY::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s4bvY::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4bPC() //  [R1]
         { info_tbl: [(c4bPC,
                       label: block_c4bPC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bPC: // global
           if (R1 == 1) goto c4bPG; else goto c4bPF;
       c4bPG: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       c4bPF: // global
           _s4bvY::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4bPM_info;
           R3 = _s4bvY::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4bPM() //  [R1, R2]
         { info_tbl: [(c4bPM,
                       label: block_c4bPM_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bPM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4bPS; else goto c4bPR;
       c4bPS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4bPR: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Natural.$fIntegralNatural_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4bPZ,
                       label: GHC.Natural.$fIntegralNatural_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bPZ: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c4bQ3; else goto c4bQ2;
       c4bQ3: // global
           HpAlloc = 104;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fIntegralNatural_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4bQ2: // global
           I64[Hp - 96] = ds2_s4bvZ_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _c4bPy::P64 = Hp - 96;
           P64[Hp - 48] = _c4bPy::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c4bPy::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.090922094 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$cquotRem_closure" {
     GHC.Natural.$fIntegralNatural_$cquotRem_closure:
         const GHC.Natural.$fIntegralNatural_$cquotRem_info;
         const 0;
 },
 ds2_s4bwe_entry() //  [R1]
         { info_tbl: [(c4bQh,
                       label: ds2_s4bwe_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bQh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4bQi; else goto c4bQj;
       c4bQi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bQj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4bQc_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           _s4bwd::P64 = P64[R1 + 24];
           R2 = _s4bwd::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s4bwd::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4bQc() //  [R1]
         { info_tbl: [(c4bQc,
                       label: block_c4bQc_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bQc: // global
           if (R1 == 1) goto c4bQg; else goto c4bQf;
       c4bQg: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       c4bQf: // global
           _s4bwd::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4bQm_info;
           R3 = _s4bwd::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4bQm() //  [R1, R2]
         { info_tbl: [(c4bQm,
                       label: block_c4bQm_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bQm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4bQs; else goto c4bQr;
       c4bQs: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4bQr: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Natural.$fIntegralNatural_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c4bQz,
                       label: GHC.Natural.$fIntegralNatural_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bQz: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c4bQD; else goto c4bQC;
       c4bQD: // global
           HpAlloc = 104;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fIntegralNatural_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4bQC: // global
           I64[Hp - 96] = ds2_s4bwe_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _c4bQ8::P64 = Hp - 96;
           P64[Hp - 48] = _c4bQ8::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c4bQ8::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.092526082 UTC

[section ""data" . GHC.Natural.$fEqNatural_closure" {
     GHC.Natural.$fEqNatural_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Integer.Type.eqInteger_closure+2;
         const GHC.Integer.Type.neqInteger_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.093113836 UTC

[section ""data" . GHC.Natural.$fOrdNatural_closure" {
     GHC.Natural.$fOrdNatural_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Natural.$fEqNatural_closure+1;
         const GHC.Integer.Type.compareInteger_closure+2;
         const GHC.Integer.Type.ltInteger_closure+2;
         const GHC.Integer.Type.leInteger_closure+2;
         const GHC.Integer.Type.gtInteger_closure+2;
         const GHC.Integer.Type.geInteger_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmax_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.093953178 UTC

[section ""data" . GHC.Natural.underflowError_closure" {
     GHC.Natural.underflowError_closure:
         const GHC.Natural.underflowError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.underflowError_entry() //  [R1]
         { info_tbl: [(c4bQK,
                       label: GHC.Natural.underflowError_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bQK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bQL; else goto c4bQM;
       c4bQL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bQM: // global
           (_c4bQH::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4bQH::I64 == 0) goto c4bQJ; else goto c4bQI;
       c4bQJ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4bQI: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4bQH::I64;
           R1 = GHC.Exception.underflowException_closure;
           Sp = Sp - 16;
           call stg_raise#(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.095137836 UTC

[section ""data" . GHC.Natural.$fNumNatural_$cnegate_closure" {
     GHC.Natural.$fNumNatural_$cnegate_closure:
         const GHC.Natural.$fNumNatural_$cnegate_info;
         const 0;
 },
 GHC.Natural.$fNumNatural_$cnegate_entry() //  [R2]
         { info_tbl: [(c4bQT,
                       label: GHC.Natural.$fNumNatural_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bQT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bQU; else goto c4bQV;
       c4bQU: // global
           R2 = R2;
           R1 = GHC.Natural.$fNumNatural_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bQV: // global
           I64[Sp - 8] = block_c4bQR_info;
           R3 = R2;
           R2 = GHC.Natural.$fBitsNatural1_closure;
           Sp = Sp - 8;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bQR() //  [R1]
         { info_tbl: [(c4bQR,
                       label: block_c4bQR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bQR: // global
           I64[Sp - 8] = block_c4bQY_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bQY() //  [R1]
         { info_tbl: [(c4bQY,
                       label: block_c4bQY_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bQY: // global
           if (R1 == 1) goto c4bR9; else goto c4bR5;
       c4bR9: // global
           R1 = GHC.Natural.underflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4bR5: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.096521861 UTC

[section ""data" . GHC.Natural.naturalFromInteger_closure" {
     GHC.Natural.naturalFromInteger_closure:
         const GHC.Natural.naturalFromInteger_info;
         const 0;
 },
 GHC.Natural.naturalFromInteger_entry() //  [R2]
         { info_tbl: [(c4bRj,
                       label: GHC.Natural.naturalFromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bRj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bRk; else goto c4bRl;
       c4bRk: // global
           R2 = R2;
           R1 = GHC.Natural.naturalFromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bRl: // global
           I64[Sp - 16] = block_c4bRe_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           _s4bwu::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s4bwu::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bRe() //  [R1]
         { info_tbl: [(c4bRe,
                       label: block_c4bRe_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bRe: // global
           if (R1 == 1) goto c4bRi; else goto c4bRh;
       c4bRi: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4bRh: // global
           R1 = GHC.Natural.underflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.097873723 UTC

[section ""data" . GHC.Natural.$fNumNatural_$c-_closure" {
     GHC.Natural.$fNumNatural_$c-_closure:
         const GHC.Natural.$fNumNatural_$c-_info;
         const 0;
 },
 GHC.Natural.$fNumNatural_$c-_entry() //  [R2, R3]
         { info_tbl: [(c4bRy,
                       label: GHC.Natural.$fNumNatural_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bRy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bRz; else goto c4bRA;
       c4bRz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fNumNatural_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4bRA: // global
           I64[Sp - 8] = block_c4bRw_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bRw() //  [R1]
         { info_tbl: [(c4bRw,
                       label: block_c4bRw_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bRw: // global
           I64[Sp - 8] = block_c4bRD_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bRD() //  [R1]
         { info_tbl: [(c4bRD,
                       label: block_c4bRD_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bRD: // global
           if (R1 == 1) goto c4bRO; else goto c4bRK;
       c4bRO: // global
           R1 = GHC.Natural.underflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4bRK: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.099178034 UTC

[section ""data" . GHC.Natural.$fNumNatural_$c+_closure" {
     GHC.Natural.$fNumNatural_$c+_closure:
         const GHC.Natural.$fNumNatural_$c+_info;
         const 0;
 },
 GHC.Natural.$fNumNatural_$c+_entry() //  [R2, R3]
         { info_tbl: [(c4bRT,
                       label: GHC.Natural.$fNumNatural_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bRT: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.100006129 UTC

[section ""data" . GHC.Natural.$fNumNatural_$c*_closure" {
     GHC.Natural.$fNumNatural_$c*_closure:
         const GHC.Natural.$fNumNatural_$c*_info;
         const 0;
 },
 GHC.Natural.$fNumNatural_$c*_entry() //  [R2, R3]
         { info_tbl: [(c4bS0,
                       label: GHC.Natural.$fNumNatural_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bS0: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.100819835 UTC

[section ""data" . GHC.Natural.$fNumNatural_$csignum_closure" {
     GHC.Natural.$fNumNatural_$csignum_closure:
         const GHC.Natural.$fNumNatural_$csignum_info;
 },
 GHC.Natural.$fNumNatural_$csignum_entry() //  [R2]
         { info_tbl: [(c4bS7,
                       label: GHC.Natural.$fNumNatural_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bS7: // global
           R2 = R2;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.10155707 UTC

[section ""data" . GHC.Natural.$fNumNatural_closure" {
     GHC.Natural.$fNumNatural_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Natural.$fNumNatural_$c+_closure+2;
         const GHC.Natural.$fNumNatural_$c-_closure+2;
         const GHC.Natural.$fNumNatural_$c*_closure+2;
         const GHC.Natural.$fNumNatural_$cnegate_closure+1;
         const GHC.Natural.$fNumNatural_$cabs_closure+1;
         const GHC.Natural.$fNumNatural_$csignum_closure+1;
         const GHC.Natural.naturalFromInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.102196123 UTC

[section ""data" . GHC.Natural.$fRealNatural_closure" {
     GHC.Natural.$fRealNatural_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Natural.$fNumNatural_closure+1;
         const GHC.Natural.$fOrdNatural_closure+1;
         const GHC.Natural.$fRealNatural_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.102930221 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$cquot_closure" {
     GHC.Natural.$fIntegralNatural_$cquot_closure:
         const GHC.Natural.$fIntegralNatural_$cquot_info;
         const 0;
 },
 GHC.Natural.$fIntegralNatural_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c4bSe,
                       label: GHC.Natural.$fIntegralNatural_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bSe: // global
           R3 = R3;
           R2 = R2;
           call GHC.Real.$fIntegralInteger_$cquot_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.103762314 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$crem_closure" {
     GHC.Natural.$fIntegralNatural_$crem_closure:
         const GHC.Natural.$fIntegralNatural_$crem_info;
         const 0;
 },
 GHC.Natural.$fIntegralNatural_$crem_entry() //  [R2, R3]
         { info_tbl: [(c4bSl,
                       label: GHC.Natural.$fIntegralNatural_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bSl: // global
           R3 = R3;
           R2 = R2;
           call GHC.Real.$fIntegralInteger_$crem_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.104637814 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$cdiv_closure" {
     GHC.Natural.$fIntegralNatural_$cdiv_closure:
         const GHC.Natural.$fIntegralNatural_$cdiv_info;
         const 0;
 },
 GHC.Natural.$fIntegralNatural_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4bSs,
                       label: GHC.Natural.$fIntegralNatural_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bSs: // global
           R3 = R3;
           R2 = R2;
           call GHC.Real.$fIntegralInteger_$cdiv_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.105595738 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$cmod_closure" {
     GHC.Natural.$fIntegralNatural_$cmod_closure:
         const GHC.Natural.$fIntegralNatural_$cmod_info;
         const 0;
 },
 GHC.Natural.$fIntegralNatural_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c4bSz,
                       label: GHC.Natural.$fIntegralNatural_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bSz: // global
           R3 = R3;
           R2 = R2;
           call GHC.Real.$fIntegralInteger_$cmod_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.106727274 UTC

[section ""data" . GHC.Natural.$fEnumNatural_$cenumFromThen_closure" {
     GHC.Natural.$fEnumNatural_$cenumFromThen_closure:
         const GHC.Natural.$fEnumNatural_$cenumFromThen_info;
         const 0;
 },
 GHC.Natural.$fEnumNatural_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4bSL,
                       label: GHC.Natural.$fEnumNatural_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bSL: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4bSM; else goto c4bSN;
       c4bSM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fEnumNatural_$cenumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4bSN: // global
           I64[Sp - 24] = block_c4bSG_info;
           _s4bwB::P64 = R3;
           R3 = R3;
           _s4bwA::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s4bwA::P64;
           P64[Sp - 8] = _s4bwB::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bSG() //  [R1]
         { info_tbl: [(c4bSG,
                       label: block_c4bSG_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bSG: // global
           _s4bwA::P64 = P64[Sp + 8];
           _s4bwB::P64 = P64[Sp + 16];
           if (R1 == 1) goto c4bSK; else goto c4bSJ;
       c4bSK: // global
           R3 = _s4bwB::P64;
           R2 = _s4bwA::P64;
           Sp = Sp + 24;
           call GHC.Enum.$fEnumInteger_$cenumFromThen_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
       c4bSJ: // global
           I64[Sp] = block_c4bSQ_info;
           R3 = _s4bwA::P64;
           R2 = _s4bwB::P64;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bSQ() //  [R1]
         { info_tbl: [(c4bSQ,
                       label: block_c4bSQ_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bSQ: // global
           R4 = GHC.Natural.$fBitsNatural1_closure;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Enum.enumDeltaToInteger_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.109197431 UTC

[section ""data" . GHC.Natural.$fEnumNatural_closure" {
     GHC.Natural.$fEnumNatural_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Natural.$fEnumNatural_$csucc_closure+1;
         const GHC.Natural.$fEnumNatural_$cpred_closure+1;
         const GHC.Natural.$fEnumNatural_$ctoEnum_closure+1;
         const GHC.Natural.$fEnumNatural_$cfromEnum_closure+1;
         const GHC.Enum.$fEnumInteger_$cenumFrom_closure+1;
         const GHC.Natural.$fEnumNatural_$cenumFromThen_closure+2;
         const GHC.Enum.$fEnumInteger_$cenumFromTo_closure+2;
         const GHC.Enum.$fEnumInteger_$cenumFromThenTo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.110141365 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_closure" {
     GHC.Natural.$fIntegralNatural_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Natural.$fRealNatural_closure+1;
         const GHC.Natural.$fEnumNatural_closure+1;
         const GHC.Natural.$fIntegralNatural_$cquot_closure+2;
         const GHC.Natural.$fIntegralNatural_$crem_closure+2;
         const GHC.Natural.$fIntegralNatural_$cdiv_closure+2;
         const GHC.Natural.$fIntegralNatural_$cmod_closure+2;
         const GHC.Natural.$fIntegralNatural_$cquotRem_closure+2;
         const GHC.Natural.$fIntegralNatural_$cdivMod_closure+2;
         const GHC.Natural.$fIntegralNatural_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.110747407 UTC

[section ""data" . sat_s4bwE_closure" {
     sat_s4bwE_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.111295406 UTC

[section ""data" . sat_s4bwF_closure" {
     sat_s4bwF_closure:
         const :_con_info;
         const sat_s4bwE_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.112051215 UTC

[section ""data" . GHC.Natural.$seven_n_closure" {
     GHC.Natural.$seven_n_closure:
         const GHC.Natural.$seven_n_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.$seven_n_entry() //  [R1]
         { info_tbl: [(c4bT5,
                       label: GHC.Natural.$seven_n_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bT5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bT6; else goto c4bT7;
       c4bT6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bT7: // global
           (_c4bT2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4bT2::I64 == 0) goto c4bT4; else goto c4bT3;
       c4bT4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4bT3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4bT2::I64;
           R3 = sat_s4bwF_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.113236575 UTC

[section ""data" . GHC.Natural.$fShowNatural_$cshow_closure" {
     GHC.Natural.$fShowNatural_$cshow_closure:
         const GHC.Natural.$fShowNatural_$cshow_info;
         const 0;
 },
 GHC.Natural.$fShowNatural_$cshow_entry() //  [R2]
         { info_tbl: [(c4bTf,
                       label: GHC.Natural.$fShowNatural_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bTf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4bTg; else goto c4bTh;
       c4bTg: // global
           R2 = R2;
           R1 = GHC.Natural.$fShowNatural_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bTh: // global
           I64[Sp - 8] = block_c4bTc_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = R2;
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bTc() //  [R1, R2]
         { info_tbl: [(c4bTc,
                       label: block_c4bTc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bTc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4bTk; else goto c4bTj;
       c4bTk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4bTj: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.114574399 UTC

[section ""data" . GHC.Natural.$fShowNatural1_closure" {
     GHC.Natural.$fShowNatural1_closure:
         const GHC.Natural.$fShowNatural1_info;
         const 0;
 },
 GHC.Natural.$fShowNatural1_entry() //  [R2, R3]
         { info_tbl: [(c4bTs,
                       label: GHC.Natural.$fShowNatural1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bTs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4bTt; else goto c4bTu;
       c4bTt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fShowNatural1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4bTu: // global
           I64[Sp - 8] = block_c4bTp_info;
           R4 = R3;
           R3 = R2;
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bTp() //  [R1, R2]
         { info_tbl: [(c4bTp,
                       label: block_c4bTp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bTp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4bTx; else goto c4bTw;
       c4bTx: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4bTw: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.115793789 UTC

[section ""data" . GHC.Natural.$fShowNatural_$cshowList_closure" {
     GHC.Natural.$fShowNatural_$cshowList_closure:
         const GHC.Natural.$fShowNatural_$cshowList_info;
         const 0;
 },
 GHC.Natural.$fShowNatural_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4bTC,
                       label: GHC.Natural.$fShowNatural_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bTC: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Natural.$fShowNatural1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.116557909 UTC

[section ""data" . GHC.Natural.$fShowNatural_closure" {
     GHC.Natural.$fShowNatural_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Show.$fShowInteger_$cshowsPrec_closure+3;
         const GHC.Natural.$fShowNatural_$cshow_closure+1;
         const GHC.Natural.$fShowNatural_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.117316119 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cpopCount_closure" {
     GHC.Natural.$fBitsNatural_$cpopCount_closure:
         const GHC.Natural.$fBitsNatural_$cpopCount_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cpopCount_entry() //  [R2]
         { info_tbl: [(c4bTJ,
                       label: GHC.Natural.$fBitsNatural_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bTJ: // global
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cpopCount_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.118172449 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$crotateR_closure" {
     GHC.Natural.$fBitsNatural_$crotateR_closure:
         const GHC.Natural.$fBitsNatural_$crotateR_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c4bTQ,
                       label: GHC.Natural.$fBitsNatural_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bTQ: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$crotateR_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.118962463 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$crotateL_closure" {
     GHC.Natural.$fBitsNatural_$crotateL_closure:
         const GHC.Natural.$fBitsNatural_$crotateL_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c4bTX,
                       label: GHC.Natural.$fBitsNatural_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bTX: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.119797657 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cshiftR_closure" {
     GHC.Natural.$fBitsNatural_$cshiftR_closure:
         const GHC.Natural.$fBitsNatural_$cshiftR_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c4bU4,
                       label: GHC.Natural.$fBitsNatural_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bU4: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshiftR_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.120651224 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cshiftL_closure" {
     GHC.Natural.$fBitsNatural_$cshiftL_closure:
         const GHC.Natural.$fBitsNatural_$cshiftL_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c4bUb,
                       label: GHC.Natural.$fBitsNatural_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bUb: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.121588556 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cisSigned_closure" {
     GHC.Natural.$fBitsNatural_$cisSigned_closure:
         const GHC.Natural.$fBitsNatural_$cisSigned_info;
 },
 GHC.Natural.$fBitsNatural_$cisSigned_entry() //  []
         { info_tbl: [(c4bUi,
                       label: GHC.Natural.$fBitsNatural_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bUi: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.122258874 UTC

[section ""cstring" . lvl4_r4bvH_bytes" {
     lvl4_r4bvH_bytes:
         I8[] [78,97,116,117,114,97,108,58,32,98,105,116,83,105,122,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.123041159 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cbitSize_closure" {
     GHC.Natural.$fBitsNatural_$cbitSize_closure:
         const GHC.Natural.$fBitsNatural_$cbitSize_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cbitSize_entry() //  [R1]
         { info_tbl: [(c4bUt,
                       label: GHC.Natural.$fBitsNatural_$cbitSize_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bUt: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4bUu; else goto c4bUv;
       c4bUu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bUv: // global
           (_c4bUo::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4bUo::I64 == 0) goto c4bUq; else goto c4bUp;
       c4bUq: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4bUp: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4bUo::I64;
           I64[Sp - 24] = block_c4bUr_info;
           R2 = lvl4_r4bvH_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4bUr() //  [R1]
         { info_tbl: [(c4bUr,
                       label: block_c4bUr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bUr: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.12417551 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cbitSizeMaybe_closure" {
     GHC.Natural.$fBitsNatural_$cbitSizeMaybe_closure:
         const GHC.Natural.$fBitsNatural_$cbitSizeMaybe_info;
 },
 GHC.Natural.$fBitsNatural_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c4bUD,
                       label: GHC.Natural.$fBitsNatural_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bUD: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.124948934 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$ctestBit_closure" {
     GHC.Natural.$fBitsNatural_$ctestBit_closure:
         const GHC.Natural.$fBitsNatural_$ctestBit_info;
 },
 GHC.Natural.$fBitsNatural_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c4bUK,
                       label: GHC.Natural.$fBitsNatural_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bUK: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$ctestBit_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.125788769 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$ccomplementBit_closure" {
     GHC.Natural.$fBitsNatural_$ccomplementBit_closure:
         const GHC.Natural.$fBitsNatural_$ccomplementBit_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c4bUR,
                       label: GHC.Natural.$fBitsNatural_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bUR: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$ccomplementBit_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.126641818 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cclearBit_closure" {
     GHC.Natural.$fBitsNatural_$cclearBit_closure:
         const GHC.Natural.$fBitsNatural_$cclearBit_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c4bUY,
                       label: GHC.Natural.$fBitsNatural_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bUY: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cclearBit_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.127497556 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$csetBit_closure" {
     GHC.Natural.$fBitsNatural_$csetBit_closure:
         const GHC.Natural.$fBitsNatural_$csetBit_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c4bV5,
                       label: GHC.Natural.$fBitsNatural_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bV5: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$csetBit_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.128345794 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$crotate_closure" {
     GHC.Natural.$fBitsNatural_$crotate_closure:
         const GHC.Natural.$fBitsNatural_$crotate_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c4bVc,
                       label: GHC.Natural.$fBitsNatural_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bVc: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.129210537 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cshift_closure" {
     GHC.Natural.$fBitsNatural_$cshift_closure:
         const GHC.Natural.$fBitsNatural_$cshift_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c4bVj,
                       label: GHC.Natural.$fBitsNatural_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bVj: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.12999908 UTC

[section ""cstring" . lvl5_r4bvI_bytes" {
     lvl5_r4bvI_bytes:
         I8[] [66,105,116,115,46,99,111,109,112,108,101,109,101,110,116,58,32,78,97,116,117,114,97,108,32,99,111,109,112,108,101,109,101,110,116,32,117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.130703021 UTC

[section ""data" . lvl6_r4bvJ_closure" {
     lvl6_r4bvJ_closure:
         const lvl6_r4bvJ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r4bvJ_entry() //  [R1]
         { info_tbl: [(c4bVs,
                       label: lvl6_r4bvJ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bVs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bVt; else goto c4bVu;
       c4bVt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bVu: // global
           (_c4bVp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4bVp::I64 == 0) goto c4bVr; else goto c4bVq;
       c4bVr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4bVq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4bVp::I64;
           R2 = lvl5_r4bvI_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.1316906 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$ccomplement_closure" {
     GHC.Natural.$fBitsNatural_$ccomplement_closure:
         const GHC.Natural.$fBitsNatural_$ccomplement_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$ccomplement_entry() //  []
         { info_tbl: [(c4bVz,
                       label: GHC.Natural.$fBitsNatural_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bVz: // global
           R2 = lvl6_r4bvJ_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.132478981 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cxor_closure" {
     GHC.Natural.$fBitsNatural_$cxor_closure:
         const GHC.Natural.$fBitsNatural_$cxor_info;
 },
 GHC.Natural.$fBitsNatural_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c4bVG,
                       label: GHC.Natural.$fBitsNatural_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bVG: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.xorInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.133625412 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$c.|._closure" {
     GHC.Natural.$fBitsNatural_$c.|._closure:
         const GHC.Natural.$fBitsNatural_$c.|._info;
 },
 GHC.Natural.$fBitsNatural_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c4bVN,
                       label: GHC.Natural.$fBitsNatural_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bVN: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.orInteger_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.134426188 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$c.&._closure" {
     GHC.Natural.$fBitsNatural_$c.&._closure:
         const GHC.Natural.$fBitsNatural_$c.&._info;
 },
 GHC.Natural.$fBitsNatural_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c4bVU,
                       label: GHC.Natural.$fBitsNatural_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bVU: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.135116739 UTC

[section ""cstring" . GHC.Natural.$trModule4_bytes" {
     GHC.Natural.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.135662593 UTC

[section ""data" . GHC.Natural.$trModule3_closure" {
     GHC.Natural.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Natural.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.136217575 UTC

[section ""cstring" . GHC.Natural.$trModule2_bytes" {
     GHC.Natural.$trModule2_bytes:
         I8[] [71,72,67,46,78,97,116,117,114,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.136760556 UTC

[section ""data" . GHC.Natural.$trModule1_closure" {
     GHC.Natural.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Natural.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.137421901 UTC

[section ""data" . GHC.Natural.$trModule_closure" {
     GHC.Natural.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Natural.$trModule3_closure+1;
         const GHC.Natural.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.138061244 UTC

[section ""data" . $krep_r4bvK_closure" {
     $krep_r4bvK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.139617696 UTC

[section ""cstring" . GHC.Natural.$tcNatural2_bytes" {
     GHC.Natural.$tcNatural2_bytes:
         I8[] [78,97,116,117,114,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.140137708 UTC

[section ""data" . GHC.Natural.$tcNatural1_closure" {
     GHC.Natural.$tcNatural1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Natural.$tcNatural2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.140688305 UTC

[section ""data" . GHC.Natural.$tcNatural_closure" {
     GHC.Natural.$tcNatural_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Natural.$trModule_closure+1;
         const GHC.Natural.$tcNatural1_closure+1;
         const GHC.Types.krep$*_closure;
         const 18275189520134122949;
         const 2097940004095541788;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.141292911 UTC

[section ""data" . $krep1_r4bvL_closure" {
     $krep1_r4bvL_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Natural.$tcNatural_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.14188 UTC

[section ""data" . GHC.Natural.$tc'Natural1_closure" {
     GHC.Natural.$tc'Natural1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4bvK_closure+1;
         const $krep1_r4bvL_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.142365084 UTC

[section ""cstring" . GHC.Natural.$tc'Natural3_bytes" {
     GHC.Natural.$tc'Natural3_bytes:
         I8[] [39,78,97,116,117,114,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.14285116 UTC

[section ""data" . GHC.Natural.$tc'Natural2_closure" {
     GHC.Natural.$tc'Natural2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Natural.$tc'Natural3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.143360785 UTC

[section ""data" . GHC.Natural.$tc'Natural_closure" {
     GHC.Natural.$tc'Natural_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Natural.$trModule_closure+1;
         const GHC.Natural.$tc'Natural2_closure+1;
         const GHC.Natural.$tc'Natural1_closure+4;
         const 11998593531750078056;
         const 1104420550366228074;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.144136238 UTC

[section ""data" . GHC.Natural.wordToNatural_closure" {
     GHC.Natural.wordToNatural_closure:
         const GHC.Natural.wordToNatural_info;
 },
 GHC.Natural.wordToNatural_entry() //  [R2]
         { info_tbl: [(c4bW1,
                       label: GHC.Natural.wordToNatural_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bW1: // global
           R2 = R2;
           call GHC.Real.$fIntegralWord_$ctoInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.144848821 UTC

[section ""data" . sat_s4bwX_closure" {
     sat_s4bwX_closure:
         const GHC.Types.I#_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.145472571 UTC

[section ""data" . sat_s4bwY_closure" {
     sat_s4bwY_closure:
         const :_con_info;
         const sat_s4bwX_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.146006829 UTC

[section ""data" . sat_s4bwW_closure" {
     sat_s4bwW_closure:
         const GHC.Types.I#_con_info;
         const 2147483647;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.146601514 UTC

[section ""data" . sat_s4bwZ_closure" {
     sat_s4bwZ_closure:
         const :_con_info;
         const sat_s4bwW_closure+1;
         const sat_s4bwY_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.147156559 UTC

[section ""data" . sat_s4bwV_closure" {
     sat_s4bwV_closure:
         const GHC.Types.I#_con_info;
         const 2147483647;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.147714602 UTC

[section ""data" . sat_s4bx0_closure" {
     sat_s4bx0_closure:
         const :_con_info;
         const sat_s4bwV_closure+1;
         const sat_s4bwZ_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.148477886 UTC

[section ""data" . GHC.Natural.naturalToWordMaybe1_closure" {
     GHC.Natural.naturalToWordMaybe1_closure:
         const GHC.Natural.naturalToWordMaybe1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.naturalToWordMaybe1_entry() //  [R1]
         { info_tbl: [(c4bWa,
                       label: GHC.Natural.naturalToWordMaybe1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bWa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bWb; else goto c4bWc;
       c4bWb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bWc: // global
           (_c4bW7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4bW7::I64 == 0) goto c4bW9; else goto c4bW8;
       c4bW9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4bW8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4bW7::I64;
           R3 = sat_s4bx0_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.150365785 UTC

[section ""data" . GHC.Natural.naturalToWordMaybe_closure" {
     GHC.Natural.naturalToWordMaybe_closure:
         const GHC.Natural.naturalToWordMaybe_info;
         const 0;
 },
 sat_s4bx4_entry() //  [R1]
         { info_tbl: [(c4bWs,
                       label: sat_s4bx4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bWs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4bWw; else goto c4bWx;
       c4bWw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bWx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4bWq_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4bWq() //  [R1]
         { info_tbl: [(c4bWq,
                       label: block_c4bWq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bWq: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4bWA; else goto c4bWz;
       c4bWA: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c4bWz: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Natural.naturalToWordMaybe_entry() //  [R2]
         { info_tbl: [(c4bWE,
                       label: GHC.Natural.naturalToWordMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bWE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bWF; else goto c4bWG;
       c4bWF: // global
           R2 = R2;
           R1 = GHC.Natural.naturalToWordMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bWG: // global
           I64[Sp - 16] = block_c4bWh_info;
           R3 = GHC.Natural.naturalToWordMaybe1_closure;
           _s4bx1::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s4bx1::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bWh() //  [R1]
         { info_tbl: [(c4bWh,
                       label: block_c4bWh_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bWh: // global
           if (R1 == 1) goto c4bWD; else goto c4bWC;
       c4bWD: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4bWM; else goto c4bWL;
       c4bWM: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4bWL: // global
           I64[Hp - 32] = sat_s4bx4_info;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4bWC: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.152596005 UTC

[section ""data" . GHC.Natural.$fReadNatural_go_closure" {
     GHC.Natural.$fReadNatural_go_closure:
         const GHC.Natural.$fReadNatural_go_info;
         const 0;
 },
 sat_s4bxe_entry() //  [R1]
         { info_tbl: [(c4bXb,
                       label: sat_s4bxe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bXb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bXc; else goto c4bXd;
       c4bXc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bXd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Natural.$fReadNatural_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u4bXE_srtd" {
     u4bXE_srtd:
         const S4byh_srt+40;
         const 40;
         const 549755813889;
 },
 GHC.Natural.$fReadNatural_go_entry() //  [R2]
         { info_tbl: [(c4bXi,
                       label: GHC.Natural.$fReadNatural_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bXi: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4bXj; else goto u4bXy;
       c4bXj: // global
           R2 = R2;
           R1 = GHC.Natural.$fReadNatural_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u4bXy: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c4bWO() args: 0, res: 0, upd: 0;
     }
 },
 _c4bWO() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bWO: // global
           _s4bx5::P64 = P64[Sp];
           I64[Sp] = block_c4bWR_info;
           R1 = _s4bx5::P64;
           if (R1 & 7 != 0) goto u4bXA; else goto c4bWS;
       u4bXA: // global
           call _c4bWR(R1) args: 0, res: 0, upd: 0;
       c4bWS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bXF_srtd" {
     u4bXF_srtd:
         const S4byh_srt+40;
         const 40;
         const 549755813889;
 },
 _c4bWR() //  [R1]
         { info_tbl: [(c4bWR,
                       label: block_c4bWR_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bWR: // global
           if (R1 & 7 == 1) goto c4bXf; else goto c4bXg;
       c4bXf: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4bXg: // global
           I64[Sp - 8] = block_c4bWX_info;
           _s4bx8::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4bx8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4bXB; else goto c4bWY;
       u4bXB: // global
           call _c4bWX(R1) args: 0, res: 0, upd: 0;
       c4bWY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bXG_srtd" {
     u4bXG_srtd:
         const S4byh_srt+40;
         const 40;
         const 549755813889;
 },
 _c4bWX() //  [R1]
         { info_tbl: [(c4bWX,
                       label: block_c4bWX_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bWX: // global
           I64[Sp - 8] = block_c4bX2_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = P64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4bXH_srtd" {
     u4bXH_srtd:
         const S4byh_srt+40;
         const 40;
         const 549755813889;
 },
 _c4bX2() //  [R1]
         { info_tbl: [(c4bX2,
                       label: block_c4bX2_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bX2: // global
           _s4bx8::P64 = P64[Sp + 16];
           if (R1 == 1) goto c4bXu; else goto c4bXs;
       c4bXu: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4bXx; else goto c4bXw;
       c4bXx: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4bXw: // global
           I64[Hp - 40] = sat_s4bxe_info;
           P64[Hp - 24] = _s4bx8::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4bXs: // global
           P64[Sp + 16] = _s4bx8::P64;
           Sp = Sp + 16;
           call _c4bWO() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.155193662 UTC

[section ""data" . GHC.Natural.$fReadNatural_$creadsPrec_closure" {
     GHC.Natural.$fReadNatural_$creadsPrec_closure:
         const GHC.Natural.$fReadNatural_$creadsPrec_info;
         const 0;
 },
 g_s4bxg_entry() //  [R1]
         { info_tbl: [(c4bXQ,
                       label: g_s4bxg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bXQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bXR; else goto c4bXS;
       c4bXR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bXS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.Read.$fReadInteger2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.$fReadInteger_$sreadNumber_entry(R4,
                                                          R3,
                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4bxj_entry() //  [R1, R2]
         { info_tbl: [(c4bY0,
                       label: sat_s4bxj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bY0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4bY1; else goto c4bY2;
       c4bY1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bY2: // global
           I64[Sp - 8] = block_c4bXY_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bXY() //  [R1]
         { info_tbl: [(c4bXY,
                       label: block_c4bXY_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bXY: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Natural.$fReadNatural_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Natural.$fReadNatural_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c4bY6,
                       label: GHC.Natural.$fReadNatural_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bY6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4bYa; else goto c4bY9;
       c4bYa: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Natural.$fReadNatural_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bY9: // global
           I64[Hp - 32] = g_s4bxg_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s4bxj_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.157645947 UTC

[section ""data" . GHC.Natural.$fReadNatural4_closure" {
     GHC.Natural.$fReadNatural4_closure:
         const GHC.Natural.$fReadNatural4_info;
         const 0;
 },
 g_s4bxl_entry() //  [R1]
         { info_tbl: [(c4bYj,
                       label: g_s4bxl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bYj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bYk; else goto c4bYl;
       c4bYk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bYl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.Read.$fReadInteger2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.$fReadInteger_$sreadNumber_entry(R4,
                                                          R3,
                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 w_s4bxm_entry() //  [R1, R2]
         { info_tbl: [(c4bYt,
                       label: w_s4bxm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bYt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4bYu; else goto c4bYv;
       c4bYu: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bYv: // global
           I64[Sp - 8] = block_c4bYr_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bYr() //  [R1]
         { info_tbl: [(c4bYr,
                       label: block_c4bYr_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bYr: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Natural.$fReadNatural_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4bxs_entry() //  [R1, R2]
         { info_tbl: [(c4bYH,
                       label: sat_s4bxs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bYH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4bYI; else goto c4bYJ;
       c4bYI: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bYJ: // global
           I64[Sp - 8] = block_c4bYE_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bYE() //  [R1]
         { info_tbl: [(c4bYE,
                       label: block_c4bYE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bYE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4bYM; else goto c4bYL;
       c4bYM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4bYL: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Natural.$fReadNatural4_entry() //  [R2]
         { info_tbl: [(c4bYN,
                       label: GHC.Natural.$fReadNatural4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bYN: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4bYR; else goto c4bYQ;
       c4bYR: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.Natural.$fReadNatural4_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bYQ: // global
           I64[Hp - 48] = g_s4bxl_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = w_s4bxm_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s4bxs_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.159534624 UTC

[section ""data" . GHC.Natural.$fReadNatural3_closure" {
     GHC.Natural.$fReadNatural3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.160282513 UTC

[section ""data" . GHC.Natural.$fReadNatural2_closure" {
     GHC.Natural.$fReadNatural2_closure:
         const GHC.Natural.$fReadNatural2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.$fReadNatural2_entry() //  [R1]
         { info_tbl: [(c4bYY,
                       label: GHC.Natural.$fReadNatural2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bYY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4bYZ; else goto c4bZ0;
       c4bYZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bZ0: // global
           (_c4bYV::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4bYV::I64 == 0) goto c4bYX; else goto c4bYW;
       c4bYX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4bYW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4bYV::I64;
           R2 = GHC.Natural.$fReadNatural4_closure+1;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Natural.$fReadNatural3_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.161354193 UTC

[section ""data" . GHC.Natural.$fReadNatural_$creadList_closure" {
     GHC.Natural.$fReadNatural_$creadList_closure:
         const GHC.Natural.$fReadNatural_$creadList_info;
         const 0;
 },
 GHC.Natural.$fReadNatural_$creadList_entry() //  [R2]
         { info_tbl: [(c4bZ5,
                       label: GHC.Natural.$fReadNatural_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bZ5: // global
           R3 = R2;
           R2 = GHC.Natural.$fReadNatural2_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.162290546 UTC

[section ""data" . GHC.Natural.$fReadNatural1_closure" {
     GHC.Natural.$fReadNatural1_closure:
         const GHC.Natural.$fReadNatural1_info;
         const 0;
 },
 GHC.Natural.$fReadNatural1_entry() //  [R2, R3]
         { info_tbl: [(c4bZf,
                       label: GHC.Natural.$fReadNatural1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bZf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4bZg; else goto c4bZh;
       c4bZg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fReadNatural1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4bZh: // global
           I64[Sp - 8] = block_c4bZc_info;
           R3 = R3;
           R2 = GHC.Natural.$fReadNatural_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bZc() //  [R1]
         { info_tbl: [(c4bZc,
                       label: block_c4bZc_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bZc: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4bZk; else goto c4bZj;
       c4bZk: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4bZj: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.163371103 UTC

[section ""data" . GHC.Natural.$fReadNatural_closure" {
     GHC.Natural.$fReadNatural_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Natural.$fReadNatural_$creadsPrec_closure+1;
         const GHC.Natural.$fReadNatural_$creadList_closure+1;
         const GHC.Natural.$fReadNatural4_closure+1;
         const GHC.Natural.$fReadNatural1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.164141538 UTC

[section ""data" . GHC.Natural.isValidNatural_closure" {
     GHC.Natural.isValidNatural_closure:
         const GHC.Natural.isValidNatural_info;
         const 0;
 },
 GHC.Natural.isValidNatural_entry() //  [R2]
         { info_tbl: [(c4bZr,
                       label: GHC.Natural.isValidNatural_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bZr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4bZs; else goto c4bZt;
       c4bZs: // global
           R2 = R2;
           R1 = GHC.Natural.isValidNatural_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4bZt: // global
           I64[Sp - 8] = block_c4bZp_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bZp() //  [R1]
         { info_tbl: [(c4bZp,
                       label: block_c4bZp_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bZp: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.165596799 UTC

[section ""data" . GHC.Natural.minusNaturalMaybe_closure" {
     GHC.Natural.minusNaturalMaybe_closure:
         const GHC.Natural.minusNaturalMaybe_info;
         const 0;
 },
 sat_s4bxC_entry() //  [R1]
         { info_tbl: [(c4bZK,
                       label: sat_s4bxC_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bZK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4bZL; else goto c4bZM;
       c4bZL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4bZM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Natural.$fNumNatural_$c-_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Natural.minusNaturalMaybe_entry() //  [R2, R3]
         { info_tbl: [(c4bZQ,
                       label: GHC.Natural.minusNaturalMaybe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bZQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4bZR; else goto c4bZS;
       c4bZR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.minusNaturalMaybe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4bZS: // global
           I64[Sp - 24] = block_c4bZB_info;
           _s4bxA::P64 = R3;
           R3 = R3;
           _s4bxz::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s4bxz::P64;
           P64[Sp - 8] = _s4bxA::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4bZB() //  [R1]
         { info_tbl: [(c4bZB,
                       label: block_c4bZB_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4bZB: // global
           if (R1 == 1) goto c4bZP; else goto c4bZO;
       c4bZP: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4bZY; else goto c4bZX;
       c4bZY: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4bZX: // global
           I64[Hp - 40] = sat_s4bxC_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4bZO: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.167069116 UTC

[section ""data" . GHC.Natural.$fIxNatural_closure" {
     GHC.Natural.$fIxNatural_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Natural.$fOrdNatural_closure+1;
         const GHC.Arr.$fIxInteger_$crange_closure+1;
         const GHC.Arr.$fIxInteger_$cindex_closure+2;
         const GHC.Arr.$fIxInteger_$cunsafeIndex_closure+2;
         const GHC.Arr.$fIxInteger_$cinRange_closure+2;
         const GHC.Arr.$fIxInteger_$crangeSize_closure+1;
         const GHC.Arr.$fIxInteger_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.167823882 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cunsafeShiftL_closure" {
     GHC.Natural.$fBitsNatural_$cunsafeShiftL_closure:
         const GHC.Natural.$fBitsNatural_$cunsafeShiftL_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c4c03,
                       label: GHC.Natural.$fBitsNatural_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c03: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.168662274 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cunsafeShiftR_closure" {
     GHC.Natural.$fBitsNatural_$cunsafeShiftR_closure:
         const GHC.Natural.$fBitsNatural_$cunsafeShiftR_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c4c0a,
                       label: GHC.Natural.$fBitsNatural_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c0a: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshiftR_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.169638042 UTC

[section ""data" . GHC.Natural.$fBitsNatural_closure" {
     GHC.Natural.$fBitsNatural_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Natural.$fEqNatural_closure+1;
         const GHC.Natural.$fBitsNatural_$c.&._closure+2;
         const GHC.Natural.$fBitsNatural_$c.|._closure+2;
         const GHC.Natural.$fBitsNatural_$cxor_closure+2;
         const GHC.Natural.$fBitsNatural_$ccomplement_closure+1;
         const GHC.Natural.$fBitsNatural_$cshift_closure+2;
         const GHC.Natural.$fBitsNatural_$crotate_closure+2;
         const GHC.Natural.$fBitsNatural1_closure;
         const Data.Bits.$fBitsInteger_$cbit_closure+1;
         const GHC.Natural.$fBitsNatural_$csetBit_closure+2;
         const GHC.Natural.$fBitsNatural_$cclearBit_closure+2;
         const GHC.Natural.$fBitsNatural_$ccomplementBit_closure+2;
         const GHC.Natural.$fBitsNatural_$ctestBit_closure+2;
         const GHC.Natural.$fBitsNatural_$cbitSizeMaybe_closure+1;
         const GHC.Natural.$fBitsNatural_$cbitSize_closure;
         const GHC.Natural.$fBitsNatural_$cisSigned_closure+1;
         const GHC.Natural.$fBitsNatural_$cshiftL_closure+2;
         const GHC.Natural.$fBitsNatural_$cunsafeShiftL_closure+2;
         const GHC.Natural.$fBitsNatural_$cshiftR_closure+2;
         const GHC.Natural.$fBitsNatural_$cunsafeShiftR_closure+2;
         const GHC.Natural.$fBitsNatural_$crotateL_closure+2;
         const GHC.Natural.$fBitsNatural_$crotateR_closure+2;
         const GHC.Natural.$fBitsNatural_$cpopCount_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.170415095 UTC

[section ""data" . sat_s4bxD_closure" {
     sat_s4bxD_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.171996776 UTC

[section ""data" . sat_s4bxE_closure" {
     sat_s4bxE_closure:
         const :_con_info;
         const sat_s4bxD_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.172769562 UTC

[section ""data" . GHC.Natural.powModNatural1_closure" {
     GHC.Natural.powModNatural1_closure:
         const GHC.Natural.powModNatural1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.powModNatural1_entry() //  [R1]
         { info_tbl: [(c4c0j,
                       label: GHC.Natural.powModNatural1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c0j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4c0k; else goto c4c0l;
       c4c0k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4c0l: // global
           (_c4c0g::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4c0g::I64 == 0) goto c4c0i; else goto c4c0h;
       c4c0i: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4c0h: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4c0g::I64;
           R3 = sat_s4bxE_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.175233145 UTC

[section ""data" . GHC.Natural.powModNatural_closure" {
     GHC.Natural.powModNatural_closure:
         const GHC.Natural.powModNatural_info;
         const 0;
 },
 section ""relreadonly" . u4c2S_srtd" {
     u4c2S_srtd:
         const S4byh_srt+80;
         const 53;
         const 8743316464075777;
 },
 GHC.Natural.powModNatural_entry() //  [R2, R3, R4]
         { info_tbl: [(c4c0v,
                       label: GHC.Natural.powModNatural_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c0v: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4c0w; else goto c4c0x;
       c4c0w: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.powModNatural_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4c0x: // global
           I64[Sp - 32] = block_c4c0q_info;
           _s4bxG::P64 = R3;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           _s4bxF::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _s4bxF::P64;
           P64[Sp - 16] = _s4bxG::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4c2T_srtd" {
     u4c2T_srtd:
         const S4byh_srt+80;
         const 53;
         const 7617416557233153;
 },
 _c4c0q() //  [R1]
         { info_tbl: [(c4c0q,
                       label: block_c4c0q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c0q: // global
           if (R1 == 1) goto c4c0u; else goto c4c0t;
       c4c0u: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4c0t: // global
           I64[Sp] = block_c4c0A_info;
           R3 = GHC.Natural.powModNatural1_closure;
           R2 = P64[Sp + 24];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4c2U_srtd" {
     u4c2U_srtd:
         const S4byh_srt+160;
         const 43;
         const 7438883356673;
 },
 _c4c0A() //  [R1]
         { info_tbl: [(c4c0A,
                       label: block_c4c0A_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c0A: // global
           if (R1 == 1) goto u4c2D; else goto c4c0I;
       u4c2D: // global
           Sp = Sp + 32;
           call _c4c2z() args: 0, res: 0, upd: 0;
       c4c0I: // global
           I64[Sp] = block_c4c0F_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4c2V_srtd" {
     u4c2V_srtd:
         const S4byh_srt+160;
         const 43;
         const 7438883356673;
 },
 _c4c0F() //  [R1]
         { info_tbl: [(c4c0F,
                       label: block_c4c0F_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c0F: // global
           if (R1 == 1) goto u4c2E; else goto c4c0P;
       u4c2E: // global
           Sp = Sp + 32;
           call _c4c2v() args: 0, res: 0, upd: 0;
       c4c0P: // global
           I64[Sp] = block_c4c0M_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4c2W_srtd" {
     u4c2W_srtd:
         const S4byh_srt+160;
         const 43;
         const 7438883356673;
 },
 _c4c0M() //  [R1]
         { info_tbl: [(c4c0M,
                       label: block_c4c0M_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c0M: // global
           if (R1 == 1) goto u4c2F; else goto c4c0W;
       u4c2F: // global
           Sp = Sp + 32;
           call _c4c2z() args: 0, res: 0, upd: 0;
       c4c0W: // global
           I64[Sp] = block_c4c0T_info;
           R3 = GHC.Natural.powModNatural1_closure;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4c2z() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c2z: // global
           R1 = GHC.Natural.$fBitsNatural1_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u4c2X_srtd" {
     u4c2X_srtd:
         const S4byh_srt+160;
         const 43;
         const 7438883356673;
 },
 _c4c0T() //  [R1]
         { info_tbl: [(c4c0T,
                       label: block_c4c0T_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c0T: // global
           if (R1 == 1) goto u4c2G; else goto c4c2j;
       u4c2G: // global
           Sp = Sp + 32;
           call _c4c2v() args: 0, res: 0, upd: 0;
       c4c2j: // global
           P64[Sp] = GHC.Natural.powModNatural1_closure;
           _s4bxO::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s4bxO::P64;
           call _c4c14() args: 0, res: 0, upd: 0;
     }
 },
 _c4c2v() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c2v: // global
           R1 = GHC.Natural.powModNatural1_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4c14() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c14: // global
           I64[Sp - 8] = block_c4c16_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4c2P; else goto c4c17;
       u4c2P: // global
           call _c4c16(R1) args: 0, res: 0, upd: 0;
       c4c17: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4c2Y_srtd" {
     u4c2Y_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4c16() //  [R1]
         { info_tbl: [(c4c16,
                       label: block_c4c16_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c16: // global
           I64[Sp] = block_c4c1b_info;
           R3 = GHC.Natural.$seven_n_closure;
           R2 = P64[Sp + 16];
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.remInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4c2Z_srtd" {
     u4c2Z_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4c1b() //  [R1]
         { info_tbl: [(c4c1b,
                       label: block_c4c1b_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c1b: // global
           I64[Sp] = block_c4c1h_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = R1;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4c30_srtd" {
     u4c30_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4c1h() //  [R1]
         { info_tbl: [(c4c1h,
                       label: block_c4c1h_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c1h: // global
           if (R1 == 1) goto c4c1S; else goto c4c1F;
       c4c1S: // global
           I64[Sp] = block_c4c1Q_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       c4c1F: // global
           _s4bxQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4c1m_info;
           R3 = P64[Sp + 24];
           R2 = _s4bxQ::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4c31_srtd" {
     u4c31_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4c1Q() //  [R1]
         { info_tbl: [(c4c1Q,
                       label: block_c4c1Q_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c1Q: // global
           if (R1 == 1) goto c4c2h; else goto c4c27;
       c4c2h: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4c27: // global
           I64[Sp] = block_c4c1W_info;
           R3 = 1;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4c32_srtd" {
     u4c32_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4c1W() //  [R1]
         { info_tbl: [(c4c1W,
                       label: block_c4c1W_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c1W: // global
           I64[Sp] = block_c4c20_info;
           _s4bxR::P64 = P64[Sp + 24];
           R3 = _s4bxR::P64;
           R2 = _s4bxR::P64;
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4c33_srtd" {
     u4c33_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4c20() //  [R1]
         { info_tbl: [(c4c20,
                       label: block_c4c20_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c20: // global
           I64[Sp] = block_c4c24_info;
           R3 = P64[Sp + 32];
           R2 = R1;
           call GHC.Integer.Type.modInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4c34_srtd" {
     u4c34_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4c24() //  [R1]
         { info_tbl: [(c4c24,
                       label: block_c4c24_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c24: // global
           _s4bxP::P64 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           P64[Sp + 16] = _s4bxP::P64;
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c4c14() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . u4c35_srtd" {
     u4c35_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4c1m() //  [R1]
         { info_tbl: [(c4c1m,
                       label: block_c4c1m_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c1m: // global
           I64[Sp] = block_c4c1q_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Integer.Type.modInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4c36_srtd" {
     u4c36_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4c1q() //  [R1]
         { info_tbl: [(c4c1q,
                       label: block_c4c1q_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c1q: // global
           I64[Sp] = block_c4c1u_info;
           R3 = 1;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4c37_srtd" {
     u4c37_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4c1u() //  [R1]
         { info_tbl: [(c4c1u,
                       label: block_c4c1u_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c1u: // global
           I64[Sp] = block_c4c1y_info;
           _s4bxR::P64 = P64[Sp + 16];
           R3 = _s4bxR::P64;
           R2 = _s4bxR::P64;
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4c38_srtd" {
     u4c38_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4c1y() //  [R1]
         { info_tbl: [(c4c1y,
                       label: block_c4c1y_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c1y: // global
           I64[Sp] = block_c4c1C_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Integer.Type.modInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4c39_srtd" {
     u4c39_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4c1C() //  [R1]
         { info_tbl: [(c4c1C,
                       label: block_c4c1C_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c1C: // global
           _s4bxP::P64 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           _s4bxQ::P64 = P64[Sp + 8];
           P64[Sp + 8] = _s4bxP::P64;
           P64[Sp] = _s4bxQ::P64;
           call _c4c14() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.180044276 UTC

[section ""relreadonly" . S4byh_srt" {
     S4byh_srt:
         const GHC.Real.$fFractionalRatio_$s$cfromInteger_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Natural.$fEnumNatural_$ctoEnum_closure;
         const lvl1_r4bvD_closure;
         const GHC.Enum.$fEnumInteger_$cpred_closure;
         const GHC.Natural.$fBitsNatural1_closure;
         const GHC.Natural.$fEnumNatural_$cpred_closure;
         const lvl3_r4bvF_closure;
         const GHC.Enum.$fEnumInteger_$csucc_closure;
         const GHC.Integer.Type.divModInteger_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Natural.$fIntegralNatural_$cdivMod_closure;
         const GHC.Natural.$fIntegralNatural_$cquotRem_closure;
         const GHC.Exception.underflowException_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.Natural.underflowError_closure;
         const GHC.Natural.$fNumNatural_$cnegate_closure;
         const GHC.Natural.naturalFromInteger_closure;
         const GHC.Natural.$fNumNatural_$c-_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$fIntegralInteger_$cquot_closure;
         const GHC.Real.$fIntegralInteger_$crem_closure;
         const GHC.Real.$fIntegralInteger_$cdiv_closure;
         const GHC.Real.$fIntegralInteger_$cmod_closure;
         const GHC.Enum.enumDeltaToInteger_closure;
         const GHC.Enum.$fEnumInteger_$cenumFromThen_closure;
         const GHC.Natural.$fEnumNatural_$cenumFromThen_closure;
         const sat_s4bwF_closure;
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Natural.$fShowNatural_$cshow_closure;
         const GHC.Natural.$fShowNatural1_closure;
         const Data.Bits.$fBitsInteger_$cpopCount_closure;
         const Data.Bits.$fBitsInteger_$crotateR_closure;
         const Data.Bits.$fBitsInteger_$cshift_closure;
         const Data.Bits.$fBitsInteger_$cshiftR_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Bits.$fBitsInteger_$ccomplementBit_closure;
         const Data.Bits.$fBitsInteger_$cclearBit_closure;
         const Data.Bits.$fBitsInteger_$csetBit_closure;
         const lvl6_r4bvJ_closure;
         const sat_s4bx0_closure;
         const GHC.Natural.naturalToWordMaybe_closure;
         const GHC.Natural.naturalToWordMaybe1_closure;
         const GHC.Natural.$fReadNatural_go_closure;
         const GHC.Read.$fReadInteger2_closure;
         const GHC.Read.$fReadInteger_$sreadNumber_closure;
         const GHC.Natural.$fReadNatural_$creadsPrec_closure;
         const GHC.Natural.$fReadNatural4_closure;
         const GHC.Read.list_closure;
         const GHC.Natural.$fReadNatural2_closure;
         const GHC.Natural.$fReadNatural1_closure;
         const GHC.Natural.$fReadNatural_$creadList_closure;
         const GHC.Natural.isValidNatural_closure;
         const GHC.Natural.$fBitsNatural1_closure;
         const GHC.Natural.$fNumNatural_$c-_closure;
         const GHC.Natural.minusNaturalMaybe_closure;
         const sat_s4bxE_closure;
         const GHC.Integer.Type.modInteger_closure;
         const GHC.Integer.Type.shiftRInteger_closure;
         const GHC.Natural.powModNatural_closure;
         const GHC.Natural.$seven_n_closure;
         const GHC.Natural.powModNatural1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.181217812 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:04.182644026 UTC

[section ""data" . GHC.Natural.$fNumNatural_$cabs_closure" {
     GHC.Natural.$fNumNatural_$cabs_closure:
         const GHC.Natural.$fNumNatural_$cabs_info;
 },
 GHC.Natural.$fNumNatural_$cabs_entry() //  [R2]
         { info_tbl: [(c4c3e,
                       label: GHC.Natural.$fNumNatural_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c3e: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.186174659 UTC

[section ""data" . GHC.Natural.$fRealNatural_$ctoRational_closure" {
     GHC.Natural.$fRealNatural_$ctoRational_closure:
         const GHC.Natural.$fRealNatural_$ctoRational_info;
         const 0;
 },
 GHC.Natural.$fRealNatural_$ctoRational_entry() //  [R2]
         { info_tbl: [(c4c3r,
                       label: GHC.Natural.$fRealNatural_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c3r: // global
           R2 = R2;
           call GHC.Real.$fFractionalRatio_$s$cfromInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.189505158 UTC

[section ""data" . GHC.Natural.$fEnumNatural_$cfromEnum_closure" {
     GHC.Natural.$fEnumNatural_$cfromEnum_closure:
         const GHC.Natural.$fEnumNatural_$cfromEnum_info;
 },
 GHC.Natural.$fEnumNatural_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4c3C,
                       label: GHC.Natural.$fEnumNatural_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c3C: // global
           R2 = R2;
           call GHC.Enum.$fEnumInteger_$cfromEnum_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.192569291 UTC

[section ""cstring" . lvl_r4bvC_bytes" {
     lvl_r4bvC_bytes:
         I8[] [78,97,116,117,114,97,108,46,116,111,69,110,117,109,58,32,110,101,103,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.194500871 UTC

[section ""data" . lvl1_r4bvD_closure" {
     lvl1_r4bvD_closure:
         const lvl1_r4bvD_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r4bvD_entry() //  [R1]
         { info_tbl: [(c4c3S,
                       label: lvl1_r4bvD_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c3S: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4c3T; else goto c4c3U;
       c4c3T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4c3U: // global
           (_c4c3N::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4c3N::I64 == 0) goto c4c3P; else goto c4c3O;
       c4c3P: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4c3O: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4c3N::I64;
           I64[Sp - 24] = block_c4c3Q_info;
           R2 = lvl_r4bvC_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4c3Q() //  [R1]
         { info_tbl: [(c4c3Q,
                       label: block_c4c3Q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c3Q: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.200360439 UTC

[section ""data" . GHC.Natural.$fEnumNatural_$ctoEnum_closure" {
     GHC.Natural.$fEnumNatural_$ctoEnum_closure:
         const GHC.Natural.$fEnumNatural_$ctoEnum_info;
         const 0;
 },
 GHC.Natural.$fEnumNatural_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4c4f,
                       label: GHC.Natural.$fEnumNatural_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c4f: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4c4g; else goto c4c4h;
       c4c4g: // global
           R2 = R2;
           R1 = GHC.Natural.$fEnumNatural_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4c4h: // global
           I64[Sp - 8] = block_c4c4c_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4c4q; else goto c4c4d;
       u4c4q: // global
           call _c4c4c(R1) args: 0, res: 0, upd: 0;
       c4c4d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4c4c() //  [R1]
         { info_tbl: [(c4c4c,
                       label: block_c4c4c_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c4c: // global
           _s4bvR::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4bvR::I64, 0)) goto c4c4o; else goto c4c4p;
       c4c4o: // global
           R2 = _s4bvR::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       c4c4p: // global
           R1 = lvl1_r4bvD_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.207505074 UTC

[section ""data" . GHC.Natural.$fBitsNatural1_closure" {
     GHC.Natural.$fBitsNatural1_closure:
         const GHC.Natural.$fBitsNatural1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.$fBitsNatural1_entry() //  [R1]
         { info_tbl: [(c4c4H,
                       label: GHC.Natural.$fBitsNatural1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c4H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4c4I; else goto c4c4J;
       c4c4I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4c4J: // global
           (_c4c4E::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4c4E::I64 == 0) goto c4c4G; else goto c4c4F;
       c4c4G: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4c4F: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4c4E::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.211374517 UTC

[section ""cstring" . lvl2_r4bvE_bytes" {
     lvl2_r4bvE_bytes:
         I8[] [78,97,116,117,114,97,108,46,112,114,101,100,58,32,48]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.213300338 UTC

[section ""data" . lvl3_r4bvF_closure" {
     lvl3_r4bvF_closure:
         const lvl3_r4bvF_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r4bvF_entry() //  [R1]
         { info_tbl: [(c4c50,
                       label: lvl3_r4bvF_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c50: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4c51; else goto c4c52;
       c4c51: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4c52: // global
           (_c4c4V::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4c4V::I64 == 0) goto c4c4X; else goto c4c4W;
       c4c4X: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4c4W: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4c4V::I64;
           I64[Sp - 24] = block_c4c4Y_info;
           R2 = lvl2_r4bvE_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4c4Y() //  [R1]
         { info_tbl: [(c4c4Y,
                       label: block_c4c4Y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c4Y: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.218930984 UTC

[section ""data" . GHC.Natural.$fEnumNatural_$cpred_closure" {
     GHC.Natural.$fEnumNatural_$cpred_closure:
         const GHC.Natural.$fEnumNatural_$cpred_info;
         const 0;
 },
 GHC.Natural.$fEnumNatural_$cpred_entry() //  [R2]
         { info_tbl: [(c4c5p,
                       label: GHC.Natural.$fEnumNatural_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c5p: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4c5q; else goto c4c5r;
       c4c5q: // global
           R2 = R2;
           R1 = GHC.Natural.$fEnumNatural_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4c5r: // global
           I64[Sp - 16] = block_c4c5k_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           _s4bvU::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s4bvU::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4c5k() //  [R1]
         { info_tbl: [(c4c5k,
                       label: block_c4c5k_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c5k: // global
           if (R1 == 1) goto c4c5o; else goto c4c5n;
       c4c5o: // global
           R1 = lvl3_r4bvF_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4c5n: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Enum.$fEnumInteger_$cpred_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.224514906 UTC

[section ""data" . GHC.Natural.$fEnumNatural_$csucc_closure" {
     GHC.Natural.$fEnumNatural_$csucc_closure:
         const GHC.Natural.$fEnumNatural_$csucc_info;
         const 0;
 },
 GHC.Natural.$fEnumNatural_$csucc_entry() //  [R2]
         { info_tbl: [(c4c5L,
                       label: GHC.Natural.$fEnumNatural_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c5L: // global
           R2 = R2;
           call GHC.Enum.$fEnumInteger_$csucc_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.227810753 UTC

[section ""data" . $ctoInteger_r4bvG_closure" {
     $ctoInteger_r4bvG_closure:
         const $ctoInteger_r4bvG_info;
 },
 $ctoInteger_r4bvG_entry() //  [R2]
         { info_tbl: [(c4c5W,
                       label: $ctoInteger_r4bvG_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c5W: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.231460117 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$ctoInteger_closure" {
     GHC.Natural.$fIntegralNatural_$ctoInteger_closure:
         const GHC.Natural.$fIntegralNatural_$ctoInteger_info;
 },
 GHC.Natural.$fIntegralNatural_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c4c69,
                       label: GHC.Natural.$fIntegralNatural_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c69: // global
           R2 = R2;
           call $ctoInteger_r4bvG_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.235995762 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$cdivMod_closure" {
     GHC.Natural.$fIntegralNatural_$cdivMod_closure:
         const GHC.Natural.$fIntegralNatural_$cdivMod_info;
         const 0;
 },
 ds2_s4bvZ_entry() //  [R1]
         { info_tbl: [(c4c6t,
                       label: ds2_s4bvZ_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c6t: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4c6u; else goto c4c6v;
       c4c6u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4c6v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4c6o_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           _s4bvY::P64 = P64[R1 + 24];
           R2 = _s4bvY::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s4bvY::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4c6o() //  [R1]
         { info_tbl: [(c4c6o,
                       label: block_c4c6o_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c6o: // global
           if (R1 == 1) goto c4c6s; else goto c4c6r;
       c4c6s: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       c4c6r: // global
           _s4bvY::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4c6y_info;
           R3 = _s4bvY::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4c6y() //  [R1, R2]
         { info_tbl: [(c4c6y,
                       label: block_c4c6y_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c6y: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4c6E; else goto c4c6D;
       c4c6E: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4c6D: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Natural.$fIntegralNatural_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4c6L,
                       label: GHC.Natural.$fIntegralNatural_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c6L: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c4c6P; else goto c4c6O;
       c4c6P: // global
           HpAlloc = 104;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fIntegralNatural_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4c6O: // global
           I64[Hp - 96] = ds2_s4bvZ_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _c4c6k::P64 = Hp - 96;
           P64[Hp - 48] = _c4c6k::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c4c6k::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.246315117 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$cquotRem_closure" {
     GHC.Natural.$fIntegralNatural_$cquotRem_closure:
         const GHC.Natural.$fIntegralNatural_$cquotRem_info;
         const 0;
 },
 ds2_s4bwe_entry() //  [R1]
         { info_tbl: [(c4c7m,
                       label: ds2_s4bwe_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c7m: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4c7n; else goto c4c7o;
       c4c7n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4c7o: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4c7h_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           _s4bwd::P64 = P64[R1 + 24];
           R2 = _s4bwd::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s4bwd::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4c7h() //  [R1]
         { info_tbl: [(c4c7h,
                       label: block_c4c7h_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c7h: // global
           if (R1 == 1) goto c4c7l; else goto c4c7k;
       c4c7l: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       c4c7k: // global
           _s4bwd::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4c7r_info;
           R3 = _s4bwd::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4c7r() //  [R1, R2]
         { info_tbl: [(c4c7r,
                       label: block_c4c7r_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c7r: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4c7x; else goto c4c7w;
       c4c7x: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4c7w: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Natural.$fIntegralNatural_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c4c7E,
                       label: GHC.Natural.$fIntegralNatural_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c7E: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c4c7I; else goto c4c7H;
       c4c7I: // global
           HpAlloc = 104;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fIntegralNatural_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4c7H: // global
           I64[Hp - 96] = ds2_s4bwe_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _c4c7d::P64 = Hp - 96;
           P64[Hp - 48] = _c4c7d::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c4c7d::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.256231276 UTC

[section ""data" . GHC.Natural.$fEqNatural_closure" {
     GHC.Natural.$fEqNatural_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Integer.Type.eqInteger_closure+2;
         const GHC.Integer.Type.neqInteger_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.258045846 UTC

[section ""data" . GHC.Natural.$fOrdNatural_closure" {
     GHC.Natural.$fOrdNatural_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Natural.$fEqNatural_closure+1;
         const GHC.Integer.Type.compareInteger_closure+2;
         const GHC.Integer.Type.ltInteger_closure+2;
         const GHC.Integer.Type.leInteger_closure+2;
         const GHC.Integer.Type.gtInteger_closure+2;
         const GHC.Integer.Type.geInteger_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmax_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.260190521 UTC

[section ""data" . GHC.Natural.underflowError_closure" {
     GHC.Natural.underflowError_closure:
         const GHC.Natural.underflowError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.underflowError_entry() //  [R1]
         { info_tbl: [(c4c8a,
                       label: GHC.Natural.underflowError_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c8a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4c8b; else goto c4c8c;
       c4c8b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4c8c: // global
           (_c4c87::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4c87::I64 == 0) goto c4c89; else goto c4c88;
       c4c89: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4c88: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4c87::I64;
           R1 = GHC.Exception.underflowException_closure;
           Sp = Sp - 16;
           call stg_raise#(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.268784127 UTC

[section ""data" . GHC.Natural.$fNumNatural_$cnegate_closure" {
     GHC.Natural.$fNumNatural_$cnegate_closure:
         const GHC.Natural.$fNumNatural_$cnegate_info;
         const 0;
 },
 GHC.Natural.$fNumNatural_$cnegate_entry() //  [R2]
         { info_tbl: [(c4c8q,
                       label: GHC.Natural.$fNumNatural_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c8q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4c8r; else goto c4c8s;
       c4c8r: // global
           R2 = R2;
           R1 = GHC.Natural.$fNumNatural_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4c8s: // global
           I64[Sp - 8] = block_c4c8o_info;
           R3 = R2;
           R2 = GHC.Natural.$fBitsNatural1_closure;
           Sp = Sp - 8;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4c8o() //  [R1]
         { info_tbl: [(c4c8o,
                       label: block_c4c8o_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c8o: // global
           I64[Sp - 8] = block_c4c8v_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4c8v() //  [R1]
         { info_tbl: [(c4c8v,
                       label: block_c4c8v_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c8v: // global
           if (R1 == 1) goto c4c8G; else goto c4c8C;
       c4c8G: // global
           R1 = GHC.Natural.underflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4c8C: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.281923114 UTC

[section ""data" . GHC.Natural.naturalFromInteger_closure" {
     GHC.Natural.naturalFromInteger_closure:
         const GHC.Natural.naturalFromInteger_info;
         const 0;
 },
 GHC.Natural.naturalFromInteger_entry() //  [R2]
         { info_tbl: [(c4c93,
                       label: GHC.Natural.naturalFromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c93: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4c94; else goto c4c95;
       c4c94: // global
           R2 = R2;
           R1 = GHC.Natural.naturalFromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4c95: // global
           I64[Sp - 16] = block_c4c8Y_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           _s4bwu::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s4bwu::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4c8Y() //  [R1]
         { info_tbl: [(c4c8Y,
                       label: block_c4c8Y_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c8Y: // global
           if (R1 == 1) goto c4c92; else goto c4c91;
       c4c92: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4c91: // global
           R1 = GHC.Natural.underflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.295194859 UTC

[section ""data" . GHC.Natural.$fNumNatural_$c-_closure" {
     GHC.Natural.$fNumNatural_$c-_closure:
         const GHC.Natural.$fNumNatural_$c-_info;
         const 0;
 },
 GHC.Natural.$fNumNatural_$c-_entry() //  [R2, R3]
         { info_tbl: [(c4c9s,
                       label: GHC.Natural.$fNumNatural_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c9s: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4c9t; else goto c4c9u;
       c4c9t: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fNumNatural_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4c9u: // global
           I64[Sp - 8] = block_c4c9q_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4c9q() //  [R1]
         { info_tbl: [(c4c9q,
                       label: block_c4c9q_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c9q: // global
           I64[Sp - 8] = block_c4c9x_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4c9x() //  [R1]
         { info_tbl: [(c4c9x,
                       label: block_c4c9x_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4c9x: // global
           if (R1 == 1) goto c4c9I; else goto c4c9E;
       c4c9I: // global
           R1 = GHC.Natural.underflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4c9E: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.308666308 UTC

[section ""data" . GHC.Natural.$fNumNatural_$c+_closure" {
     GHC.Natural.$fNumNatural_$c+_closure:
         const GHC.Natural.$fNumNatural_$c+_info;
         const 0;
 },
 GHC.Natural.$fNumNatural_$c+_entry() //  [R2, R3]
         { info_tbl: [(c4ca0,
                       label: GHC.Natural.$fNumNatural_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ca0: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.312890712 UTC

[section ""data" . GHC.Natural.$fNumNatural_$c*_closure" {
     GHC.Natural.$fNumNatural_$c*_closure:
         const GHC.Natural.$fNumNatural_$c*_info;
         const 0;
 },
 GHC.Natural.$fNumNatural_$c*_entry() //  [R2, R3]
         { info_tbl: [(c4cab,
                       label: GHC.Natural.$fNumNatural_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cab: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.317149592 UTC

[section ""data" . GHC.Natural.$fNumNatural_$csignum_closure" {
     GHC.Natural.$fNumNatural_$csignum_closure:
         const GHC.Natural.$fNumNatural_$csignum_info;
 },
 GHC.Natural.$fNumNatural_$csignum_entry() //  [R2]
         { info_tbl: [(c4cam,
                       label: GHC.Natural.$fNumNatural_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cam: // global
           R2 = R2;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.321954265 UTC

[section ""data" . GHC.Natural.$fNumNatural_closure" {
     GHC.Natural.$fNumNatural_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Natural.$fNumNatural_$c+_closure+2;
         const GHC.Natural.$fNumNatural_$c-_closure+2;
         const GHC.Natural.$fNumNatural_$c*_closure+2;
         const GHC.Natural.$fNumNatural_$cnegate_closure+1;
         const GHC.Natural.$fNumNatural_$cabs_closure+1;
         const GHC.Natural.$fNumNatural_$csignum_closure+1;
         const GHC.Natural.naturalFromInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.32410346 UTC

[section ""data" . GHC.Natural.$fRealNatural_closure" {
     GHC.Natural.$fRealNatural_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Natural.$fNumNatural_closure+1;
         const GHC.Natural.$fOrdNatural_closure+1;
         const GHC.Natural.$fRealNatural_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.326216418 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$cquot_closure" {
     GHC.Natural.$fIntegralNatural_$cquot_closure:
         const GHC.Natural.$fIntegralNatural_$cquot_info;
         const 0;
 },
 GHC.Natural.$fIntegralNatural_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c4caz,
                       label: GHC.Natural.$fIntegralNatural_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4caz: // global
           R3 = R3;
           R2 = R2;
           call GHC.Real.$fIntegralInteger_$cquot_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.330030901 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$crem_closure" {
     GHC.Natural.$fIntegralNatural_$crem_closure:
         const GHC.Natural.$fIntegralNatural_$crem_info;
         const 0;
 },
 GHC.Natural.$fIntegralNatural_$crem_entry() //  [R2, R3]
         { info_tbl: [(c4caK,
                       label: GHC.Natural.$fIntegralNatural_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4caK: // global
           R3 = R3;
           R2 = R2;
           call GHC.Real.$fIntegralInteger_$crem_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.333512974 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$cdiv_closure" {
     GHC.Natural.$fIntegralNatural_$cdiv_closure:
         const GHC.Natural.$fIntegralNatural_$cdiv_info;
         const 0;
 },
 GHC.Natural.$fIntegralNatural_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4caV,
                       label: GHC.Natural.$fIntegralNatural_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4caV: // global
           R3 = R3;
           R2 = R2;
           call GHC.Real.$fIntegralInteger_$cdiv_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.336770173 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$cmod_closure" {
     GHC.Natural.$fIntegralNatural_$cmod_closure:
         const GHC.Natural.$fIntegralNatural_$cmod_info;
         const 0;
 },
 GHC.Natural.$fIntegralNatural_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c4cb6,
                       label: GHC.Natural.$fIntegralNatural_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cb6: // global
           R3 = R3;
           R2 = R2;
           call GHC.Real.$fIntegralInteger_$cmod_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.340422169 UTC

[section ""data" . GHC.Natural.$fEnumNatural_$cenumFromThen_closure" {
     GHC.Natural.$fEnumNatural_$cenumFromThen_closure:
         const GHC.Natural.$fEnumNatural_$cenumFromThen_info;
         const 0;
 },
 GHC.Natural.$fEnumNatural_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4cbm,
                       label: GHC.Natural.$fEnumNatural_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cbm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4cbn; else goto c4cbo;
       c4cbn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fEnumNatural_$cenumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4cbo: // global
           I64[Sp - 24] = block_c4cbh_info;
           _s4bwB::P64 = R3;
           R3 = R3;
           _s4bwA::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s4bwA::P64;
           P64[Sp - 8] = _s4bwB::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cbh() //  [R1]
         { info_tbl: [(c4cbh,
                       label: block_c4cbh_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cbh: // global
           _s4bwA::P64 = P64[Sp + 8];
           _s4bwB::P64 = P64[Sp + 16];
           if (R1 == 1) goto c4cbl; else goto c4cbk;
       c4cbl: // global
           R3 = _s4bwB::P64;
           R2 = _s4bwA::P64;
           Sp = Sp + 24;
           call GHC.Enum.$fEnumInteger_$cenumFromThen_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
       c4cbk: // global
           I64[Sp] = block_c4cbr_info;
           R3 = _s4bwA::P64;
           R2 = _s4bwB::P64;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cbr() //  [R1]
         { info_tbl: [(c4cbr,
                       label: block_c4cbr_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cbr: // global
           R4 = GHC.Natural.$fBitsNatural1_closure;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Enum.enumDeltaToInteger_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.34780882 UTC

[section ""data" . GHC.Natural.$fEnumNatural_closure" {
     GHC.Natural.$fEnumNatural_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Natural.$fEnumNatural_$csucc_closure+1;
         const GHC.Natural.$fEnumNatural_$cpred_closure+1;
         const GHC.Natural.$fEnumNatural_$ctoEnum_closure+1;
         const GHC.Natural.$fEnumNatural_$cfromEnum_closure+1;
         const GHC.Enum.$fEnumInteger_$cenumFrom_closure+1;
         const GHC.Natural.$fEnumNatural_$cenumFromThen_closure+2;
         const GHC.Enum.$fEnumInteger_$cenumFromTo_closure+2;
         const GHC.Enum.$fEnumInteger_$cenumFromThenTo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.35025326 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_closure" {
     GHC.Natural.$fIntegralNatural_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Natural.$fRealNatural_closure+1;
         const GHC.Natural.$fEnumNatural_closure+1;
         const GHC.Natural.$fIntegralNatural_$cquot_closure+2;
         const GHC.Natural.$fIntegralNatural_$crem_closure+2;
         const GHC.Natural.$fIntegralNatural_$cdiv_closure+2;
         const GHC.Natural.$fIntegralNatural_$cmod_closure+2;
         const GHC.Natural.$fIntegralNatural_$cquotRem_closure+2;
         const GHC.Natural.$fIntegralNatural_$cdivMod_closure+2;
         const GHC.Natural.$fIntegralNatural_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.352150002 UTC

[section ""data" . sat_s4bwE_closure" {
     sat_s4bwE_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.354329784 UTC

[section ""data" . sat_s4bwF_closure" {
     sat_s4bwF_closure:
         const :_con_info;
         const sat_s4bwE_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.356252795 UTC

[section ""data" . GHC.Natural.$seven_n_closure" {
     GHC.Natural.$seven_n_closure:
         const GHC.Natural.$seven_n_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.$seven_n_entry() //  [R1]
         { info_tbl: [(c4cbV,
                       label: GHC.Natural.$seven_n_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cbV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4cbW; else goto c4cbX;
       c4cbW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cbX: // global
           (_c4cbS::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4cbS::I64 == 0) goto c4cbU; else goto c4cbT;
       c4cbU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4cbT: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4cbS::I64;
           R3 = sat_s4bwF_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.36061311 UTC

[section ""data" . GHC.Natural.$fShowNatural_$cshow_closure" {
     GHC.Natural.$fShowNatural_$cshow_closure:
         const GHC.Natural.$fShowNatural_$cshow_info;
         const 0;
 },
 GHC.Natural.$fShowNatural_$cshow_entry() //  [R2]
         { info_tbl: [(c4ccc,
                       label: GHC.Natural.$fShowNatural_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ccc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ccd; else goto c4cce;
       c4ccd: // global
           R2 = R2;
           R1 = GHC.Natural.$fShowNatural_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4cce: // global
           I64[Sp - 8] = block_c4cc9_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = R2;
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cc9() //  [R1, R2]
         { info_tbl: [(c4cc9,
                       label: block_c4cc9_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cc9: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4cch; else goto c4ccg;
       c4cch: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4ccg: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.366479377 UTC

[section ""data" . GHC.Natural.$fShowNatural1_closure" {
     GHC.Natural.$fShowNatural1_closure:
         const GHC.Natural.$fShowNatural1_info;
         const 0;
 },
 GHC.Natural.$fShowNatural1_entry() //  [R2, R3]
         { info_tbl: [(c4ccy,
                       label: GHC.Natural.$fShowNatural1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ccy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ccz; else goto c4ccA;
       c4ccz: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fShowNatural1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4ccA: // global
           I64[Sp - 8] = block_c4ccv_info;
           R4 = R3;
           R3 = R2;
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ccv() //  [R1, R2]
         { info_tbl: [(c4ccv,
                       label: block_c4ccv_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ccv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4ccD; else goto c4ccC;
       c4ccD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4ccC: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.372222975 UTC

[section ""data" . GHC.Natural.$fShowNatural_$cshowList_closure" {
     GHC.Natural.$fShowNatural_$cshowList_closure:
         const GHC.Natural.$fShowNatural_$cshowList_info;
         const 0;
 },
 GHC.Natural.$fShowNatural_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4ccR,
                       label: GHC.Natural.$fShowNatural_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ccR: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Natural.$fShowNatural1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.3757167 UTC

[section ""data" . GHC.Natural.$fShowNatural_closure" {
     GHC.Natural.$fShowNatural_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Show.$fShowInteger_$cshowsPrec_closure+3;
         const GHC.Natural.$fShowNatural_$cshow_closure+1;
         const GHC.Natural.$fShowNatural_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.377714971 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cpopCount_closure" {
     GHC.Natural.$fBitsNatural_$cpopCount_closure:
         const GHC.Natural.$fBitsNatural_$cpopCount_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cpopCount_entry() //  [R2]
         { info_tbl: [(c4cd3,
                       label: GHC.Natural.$fBitsNatural_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cd3: // global
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cpopCount_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.382062772 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$crotateR_closure" {
     GHC.Natural.$fBitsNatural_$crotateR_closure:
         const GHC.Natural.$fBitsNatural_$crotateR_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c4cde,
                       label: GHC.Natural.$fBitsNatural_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cde: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$crotateR_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.385687288 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$crotateL_closure" {
     GHC.Natural.$fBitsNatural_$crotateL_closure:
         const GHC.Natural.$fBitsNatural_$crotateL_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c4cdp,
                       label: GHC.Natural.$fBitsNatural_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cdp: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.389029151 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cshiftR_closure" {
     GHC.Natural.$fBitsNatural_$cshiftR_closure:
         const GHC.Natural.$fBitsNatural_$cshiftR_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c4cdA,
                       label: GHC.Natural.$fBitsNatural_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cdA: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshiftR_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.392423158 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cshiftL_closure" {
     GHC.Natural.$fBitsNatural_$cshiftL_closure:
         const GHC.Natural.$fBitsNatural_$cshiftL_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c4cdL,
                       label: GHC.Natural.$fBitsNatural_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cdL: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.39587094 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cisSigned_closure" {
     GHC.Natural.$fBitsNatural_$cisSigned_closure:
         const GHC.Natural.$fBitsNatural_$cisSigned_info;
 },
 GHC.Natural.$fBitsNatural_$cisSigned_entry() //  []
         { info_tbl: [(c4cdW,
                       label: GHC.Natural.$fBitsNatural_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cdW: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.399161393 UTC

[section ""cstring" . lvl4_r4bvH_bytes" {
     lvl4_r4bvH_bytes:
         I8[] [78,97,116,117,114,97,108,58,32,98,105,116,83,105,122,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.401148531 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cbitSize_closure" {
     GHC.Natural.$fBitsNatural_$cbitSize_closure:
         const GHC.Natural.$fBitsNatural_$cbitSize_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cbitSize_entry() //  [R1]
         { info_tbl: [(c4ced,
                       label: GHC.Natural.$fBitsNatural_$cbitSize_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ced: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4cee; else goto c4cef;
       c4cee: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cef: // global
           (_c4ce8::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4ce8::I64 == 0) goto c4cea; else goto c4ce9;
       c4cea: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4ce9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4ce8::I64;
           I64[Sp - 24] = block_c4ceb_info;
           R2 = lvl4_r4bvH_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4ceb() //  [R1]
         { info_tbl: [(c4ceb,
                       label: block_c4ceb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ceb: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.407778456 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cbitSizeMaybe_closure" {
     GHC.Natural.$fBitsNatural_$cbitSizeMaybe_closure:
         const GHC.Natural.$fBitsNatural_$cbitSizeMaybe_info;
 },
 GHC.Natural.$fBitsNatural_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c4cex,
                       label: GHC.Natural.$fBitsNatural_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cex: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.411829298 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$ctestBit_closure" {
     GHC.Natural.$fBitsNatural_$ctestBit_closure:
         const GHC.Natural.$fBitsNatural_$ctestBit_info;
 },
 GHC.Natural.$fBitsNatural_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c4ceJ,
                       label: GHC.Natural.$fBitsNatural_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ceJ: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$ctestBit_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.415680869 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$ccomplementBit_closure" {
     GHC.Natural.$fBitsNatural_$ccomplementBit_closure:
         const GHC.Natural.$fBitsNatural_$ccomplementBit_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c4ceU,
                       label: GHC.Natural.$fBitsNatural_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ceU: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$ccomplementBit_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.419223373 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cclearBit_closure" {
     GHC.Natural.$fBitsNatural_$cclearBit_closure:
         const GHC.Natural.$fBitsNatural_$cclearBit_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c4cf5,
                       label: GHC.Natural.$fBitsNatural_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cf5: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cclearBit_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.422699245 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$csetBit_closure" {
     GHC.Natural.$fBitsNatural_$csetBit_closure:
         const GHC.Natural.$fBitsNatural_$csetBit_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c4cfg,
                       label: GHC.Natural.$fBitsNatural_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cfg: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$csetBit_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.426366756 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$crotate_closure" {
     GHC.Natural.$fBitsNatural_$crotate_closure:
         const GHC.Natural.$fBitsNatural_$crotate_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c4cfr,
                       label: GHC.Natural.$fBitsNatural_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cfr: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.429781594 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cshift_closure" {
     GHC.Natural.$fBitsNatural_$cshift_closure:
         const GHC.Natural.$fBitsNatural_$cshift_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c4cfC,
                       label: GHC.Natural.$fBitsNatural_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cfC: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.433001992 UTC

[section ""cstring" . lvl5_r4bvI_bytes" {
     lvl5_r4bvI_bytes:
         I8[] [66,105,116,115,46,99,111,109,112,108,101,109,101,110,116,58,32,78,97,116,117,114,97,108,32,99,111,109,112,108,101,109,101,110,116,32,117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.434975915 UTC

[section ""data" . lvl6_r4bvJ_closure" {
     lvl6_r4bvJ_closure:
         const lvl6_r4bvJ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r4bvJ_entry() //  [R1]
         { info_tbl: [(c4cfQ,
                       label: lvl6_r4bvJ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cfQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4cfR; else goto c4cfS;
       c4cfR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cfS: // global
           (_c4cfN::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4cfN::I64 == 0) goto c4cfP; else goto c4cfO;
       c4cfP: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4cfO: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4cfN::I64;
           R2 = lvl5_r4bvI_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.439944538 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$ccomplement_closure" {
     GHC.Natural.$fBitsNatural_$ccomplement_closure:
         const GHC.Natural.$fBitsNatural_$ccomplement_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$ccomplement_entry() //  []
         { info_tbl: [(c4cg4,
                       label: GHC.Natural.$fBitsNatural_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cg4: // global
           R2 = lvl6_r4bvJ_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.443329796 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cxor_closure" {
     GHC.Natural.$fBitsNatural_$cxor_closure:
         const GHC.Natural.$fBitsNatural_$cxor_info;
 },
 GHC.Natural.$fBitsNatural_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c4cgf,
                       label: GHC.Natural.$fBitsNatural_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cgf: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.xorInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.446601034 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$c.|._closure" {
     GHC.Natural.$fBitsNatural_$c.|._closure:
         const GHC.Natural.$fBitsNatural_$c.|._info;
 },
 GHC.Natural.$fBitsNatural_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c4cgq,
                       label: GHC.Natural.$fBitsNatural_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cgq: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.orInteger_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.450185957 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$c.&._closure" {
     GHC.Natural.$fBitsNatural_$c.&._closure:
         const GHC.Natural.$fBitsNatural_$c.&._info;
 },
 GHC.Natural.$fBitsNatural_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c4cgB,
                       label: GHC.Natural.$fBitsNatural_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cgB: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.453420771 UTC

[section ""cstring" . GHC.Natural.$trModule4_bytes" {
     GHC.Natural.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.455121803 UTC

[section ""data" . GHC.Natural.$trModule3_closure" {
     GHC.Natural.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Natural.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.456761286 UTC

[section ""cstring" . GHC.Natural.$trModule2_bytes" {
     GHC.Natural.$trModule2_bytes:
         I8[] [71,72,67,46,78,97,116,117,114,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.458482911 UTC

[section ""data" . GHC.Natural.$trModule1_closure" {
     GHC.Natural.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Natural.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.460211405 UTC

[section ""data" . GHC.Natural.$trModule_closure" {
     GHC.Natural.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Natural.$trModule3_closure+1;
         const GHC.Natural.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.462265259 UTC

[section ""data" . $krep_r4bvK_closure" {
     $krep_r4bvK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.463951349 UTC

[section ""cstring" . GHC.Natural.$tcNatural2_bytes" {
     GHC.Natural.$tcNatural2_bytes:
         I8[] [78,97,116,117,114,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.466228067 UTC

[section ""data" . GHC.Natural.$tcNatural1_closure" {
     GHC.Natural.$tcNatural1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Natural.$tcNatural2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.467965058 UTC

[section ""data" . GHC.Natural.$tcNatural_closure" {
     GHC.Natural.$tcNatural_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Natural.$trModule_closure+1;
         const GHC.Natural.$tcNatural1_closure+1;
         const GHC.Types.krep$*_closure;
         const 18275189520134122949;
         const 2097940004095541788;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.469791842 UTC

[section ""data" . $krep1_r4bvL_closure" {
     $krep1_r4bvL_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Natural.$tcNatural_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.47144479 UTC

[section ""data" . GHC.Natural.$tc'Natural1_closure" {
     GHC.Natural.$tc'Natural1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4bvK_closure+1;
         const $krep1_r4bvL_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.473155202 UTC

[section ""cstring" . GHC.Natural.$tc'Natural3_bytes" {
     GHC.Natural.$tc'Natural3_bytes:
         I8[] [39,78,97,116,117,114,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.474797271 UTC

[section ""data" . GHC.Natural.$tc'Natural2_closure" {
     GHC.Natural.$tc'Natural2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Natural.$tc'Natural3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.476479556 UTC

[section ""data" . GHC.Natural.$tc'Natural_closure" {
     GHC.Natural.$tc'Natural_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Natural.$trModule_closure+1;
         const GHC.Natural.$tc'Natural2_closure+1;
         const GHC.Natural.$tc'Natural1_closure+4;
         const 11998593531750078056;
         const 1104420550366228074;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.47904745 UTC

[section ""data" . GHC.Natural.wordToNatural_closure" {
     GHC.Natural.wordToNatural_closure:
         const GHC.Natural.wordToNatural_info;
 },
 GHC.Natural.wordToNatural_entry() //  [R2]
         { info_tbl: [(c4ch0,
                       label: GHC.Natural.wordToNatural_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ch0: // global
           R2 = R2;
           call GHC.Real.$fIntegralWord_$ctoInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.482286319 UTC

[section ""data" . sat_s4bwX_closure" {
     sat_s4bwX_closure:
         const GHC.Types.I#_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.484087675 UTC

[section ""data" . sat_s4bwY_closure" {
     sat_s4bwY_closure:
         const :_con_info;
         const sat_s4bwX_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.485844285 UTC

[section ""data" . sat_s4bwW_closure" {
     sat_s4bwW_closure:
         const GHC.Types.I#_con_info;
         const 2147483647;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.487532361 UTC

[section ""data" . sat_s4bwZ_closure" {
     sat_s4bwZ_closure:
         const :_con_info;
         const sat_s4bwW_closure+1;
         const sat_s4bwY_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.489328204 UTC

[section ""data" . sat_s4bwV_closure" {
     sat_s4bwV_closure:
         const GHC.Types.I#_con_info;
         const 2147483647;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.491053498 UTC

[section ""data" . sat_s4bx0_closure" {
     sat_s4bx0_closure:
         const :_con_info;
         const sat_s4bwV_closure+1;
         const sat_s4bwZ_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.493849915 UTC

[section ""data" . GHC.Natural.naturalToWordMaybe1_closure" {
     GHC.Natural.naturalToWordMaybe1_closure:
         const GHC.Natural.naturalToWordMaybe1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.naturalToWordMaybe1_entry() //  [R1]
         { info_tbl: [(c4chj,
                       label: GHC.Natural.naturalToWordMaybe1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4chj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4chk; else goto c4chl;
       c4chk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4chl: // global
           (_c4chg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4chg::I64 == 0) goto c4chi; else goto c4chh;
       c4chi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4chh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4chg::I64;
           R3 = sat_s4bx0_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.498523768 UTC

[section ""data" . GHC.Natural.naturalToWordMaybe_closure" {
     GHC.Natural.naturalToWordMaybe_closure:
         const GHC.Natural.naturalToWordMaybe_info;
         const 0;
 },
 sat_s4bx4_entry() //  [R1]
         { info_tbl: [(c4chI,
                       label: sat_s4bx4_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4chI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4chM; else goto c4chN;
       c4chM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4chN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4chG_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4chG() //  [R1]
         { info_tbl: [(c4chG,
                       label: block_c4chG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4chG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4chQ; else goto c4chP;
       c4chQ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c4chP: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Natural.naturalToWordMaybe_entry() //  [R2]
         { info_tbl: [(c4chU,
                       label: GHC.Natural.naturalToWordMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4chU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4chV; else goto c4chW;
       c4chV: // global
           R2 = R2;
           R1 = GHC.Natural.naturalToWordMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4chW: // global
           I64[Sp - 16] = block_c4chx_info;
           R3 = GHC.Natural.naturalToWordMaybe1_closure;
           _s4bx1::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s4bx1::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4chx() //  [R1]
         { info_tbl: [(c4chx,
                       label: block_c4chx_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4chx: // global
           if (R1 == 1) goto c4chT; else goto c4chS;
       c4chT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4ci2; else goto c4ci1;
       c4ci2: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4ci1: // global
           I64[Hp - 32] = sat_s4bx4_info;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4chS: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.509063991 UTC

[section ""data" . GHC.Natural.$fReadNatural_go_closure" {
     GHC.Natural.$fReadNatural_go_closure:
         const GHC.Natural.$fReadNatural_go_info;
         const 0;
 },
 sat_s4bxe_entry() //  [R1]
         { info_tbl: [(c4ciL,
                       label: sat_s4bxe_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ciL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ciM; else goto c4ciN;
       c4ciM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ciN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Natural.$fReadNatural_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u4cje_srtd" {
     u4cje_srtd:
         const S4byh_srt+40;
         const 40;
         const 549755813889;
 },
 GHC.Natural.$fReadNatural_go_entry() //  [R2]
         { info_tbl: [(c4ciS,
                       label: GHC.Natural.$fReadNatural_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ciS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4ciT; else goto u4cj8;
       c4ciT: // global
           R2 = R2;
           R1 = GHC.Natural.$fReadNatural_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u4cj8: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c4cio() args: 0, res: 0, upd: 0;
     }
 },
 _c4cio() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cio: // global
           _s4bx5::P64 = P64[Sp];
           I64[Sp] = block_c4cir_info;
           R1 = _s4bx5::P64;
           if (R1 & 7 != 0) goto u4cja; else goto c4cis;
       u4cja: // global
           call _c4cir(R1) args: 0, res: 0, upd: 0;
       c4cis: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cjf_srtd" {
     u4cjf_srtd:
         const S4byh_srt+40;
         const 40;
         const 549755813889;
 },
 _c4cir() //  [R1]
         { info_tbl: [(c4cir,
                       label: block_c4cir_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cir: // global
           if (R1 & 7 == 1) goto c4ciP; else goto c4ciQ;
       c4ciP: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4ciQ: // global
           I64[Sp - 8] = block_c4cix_info;
           _s4bx8::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4bx8::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4cjb; else goto c4ciy;
       u4cjb: // global
           call _c4cix(R1) args: 0, res: 0, upd: 0;
       c4ciy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cjg_srtd" {
     u4cjg_srtd:
         const S4byh_srt+40;
         const 40;
         const 549755813889;
 },
 _c4cix() //  [R1]
         { info_tbl: [(c4cix,
                       label: block_c4cix_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cix: // global
           I64[Sp - 8] = block_c4ciC_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = P64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cjh_srtd" {
     u4cjh_srtd:
         const S4byh_srt+40;
         const 40;
         const 549755813889;
 },
 _c4ciC() //  [R1]
         { info_tbl: [(c4ciC,
                       label: block_c4ciC_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ciC: // global
           _s4bx8::P64 = P64[Sp + 16];
           if (R1 == 1) goto c4cj4; else goto c4cj2;
       c4cj4: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4cj7; else goto c4cj6;
       c4cj7: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4cj6: // global
           I64[Hp - 40] = sat_s4bxe_info;
           P64[Hp - 24] = _s4bx8::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4cj2: // global
           P64[Sp + 16] = _s4bx8::P64;
           Sp = Sp + 16;
           call _c4cio() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.525183124 UTC

[section ""data" . GHC.Natural.$fReadNatural_$creadsPrec_closure" {
     GHC.Natural.$fReadNatural_$creadsPrec_closure:
         const GHC.Natural.$fReadNatural_$creadsPrec_info;
         const 0;
 },
 g_s4bxg_entry() //  [R1]
         { info_tbl: [(c4cjW,
                       label: g_s4bxg_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cjW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4cjX; else goto c4cjY;
       c4cjX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cjY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.Read.$fReadInteger2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.$fReadInteger_$sreadNumber_entry(R4,
                                                          R3,
                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4bxj_entry() //  [R1, R2]
         { info_tbl: [(c4ck6,
                       label: sat_s4bxj_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ck6: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ck7; else goto c4ck8;
       c4ck7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ck8: // global
           I64[Sp - 8] = block_c4ck4_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ck4() //  [R1]
         { info_tbl: [(c4ck4,
                       label: block_c4ck4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ck4: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Natural.$fReadNatural_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Natural.$fReadNatural_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c4ckc,
                       label: GHC.Natural.$fReadNatural_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ckc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4ckg; else goto c4ckf;
       c4ckg: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Natural.$fReadNatural_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ckf: // global
           I64[Hp - 32] = g_s4bxg_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s4bxj_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.53567614 UTC

[section ""data" . GHC.Natural.$fReadNatural4_closure" {
     GHC.Natural.$fReadNatural4_closure:
         const GHC.Natural.$fReadNatural4_info;
         const 0;
 },
 g_s4bxl_entry() //  [R1]
         { info_tbl: [(c4ckG,
                       label: g_s4bxl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ckG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4ckH; else goto c4ckI;
       c4ckH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4ckI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.Read.$fReadInteger2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.$fReadInteger_$sreadNumber_entry(R4,
                                                          R3,
                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 w_s4bxm_entry() //  [R1, R2]
         { info_tbl: [(c4ckQ,
                       label: w_s4bxm_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ckQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4ckR; else goto c4ckS;
       c4ckR: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4ckS: // global
           I64[Sp - 8] = block_c4ckO_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4ckO() //  [R1]
         { info_tbl: [(c4ckO,
                       label: block_c4ckO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4ckO: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Natural.$fReadNatural_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4bxs_entry() //  [R1, R2]
         { info_tbl: [(c4cl4,
                       label: sat_s4bxs_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cl4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4cl5; else goto c4cl6;
       c4cl5: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4cl6: // global
           I64[Sp - 8] = block_c4cl1_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cl1() //  [R1]
         { info_tbl: [(c4cl1,
                       label: block_c4cl1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cl1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4cl9; else goto c4cl8;
       c4cl9: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4cl8: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Natural.$fReadNatural4_entry() //  [R2]
         { info_tbl: [(c4cla,
                       label: GHC.Natural.$fReadNatural4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cla: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4cle; else goto c4cld;
       c4cle: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.Natural.$fReadNatural4_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4cld: // global
           I64[Hp - 48] = g_s4bxl_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = w_s4bxm_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s4bxs_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.548552796 UTC

[section ""data" . GHC.Natural.$fReadNatural3_closure" {
     GHC.Natural.$fReadNatural3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.550722699 UTC

[section ""data" . GHC.Natural.$fReadNatural2_closure" {
     GHC.Natural.$fReadNatural2_closure:
         const GHC.Natural.$fReadNatural2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.$fReadNatural2_entry() //  [R1]
         { info_tbl: [(c4clM,
                       label: GHC.Natural.$fReadNatural2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4clM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4clN; else goto c4clO;
       c4clN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4clO: // global
           (_c4clJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4clJ::I64 == 0) goto c4clL; else goto c4clK;
       c4clL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4clK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4clJ::I64;
           R2 = GHC.Natural.$fReadNatural4_closure+1;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Natural.$fReadNatural3_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.555515224 UTC

[section ""data" . GHC.Natural.$fReadNatural_$creadList_closure" {
     GHC.Natural.$fReadNatural_$creadList_closure:
         const GHC.Natural.$fReadNatural_$creadList_info;
         const 0;
 },
 GHC.Natural.$fReadNatural_$creadList_entry() //  [R2]
         { info_tbl: [(c4cm0,
                       label: GHC.Natural.$fReadNatural_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cm0: // global
           R3 = R2;
           R2 = GHC.Natural.$fReadNatural2_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.559636588 UTC

[section ""data" . GHC.Natural.$fReadNatural1_closure" {
     GHC.Natural.$fReadNatural1_closure:
         const GHC.Natural.$fReadNatural1_info;
         const 0;
 },
 GHC.Natural.$fReadNatural1_entry() //  [R2, R3]
         { info_tbl: [(c4cme,
                       label: GHC.Natural.$fReadNatural1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cme: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4cmf; else goto c4cmg;
       c4cmf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fReadNatural1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4cmg: // global
           I64[Sp - 8] = block_c4cmb_info;
           R3 = R3;
           R2 = GHC.Natural.$fReadNatural_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cmb() //  [R1]
         { info_tbl: [(c4cmb,
                       label: block_c4cmb_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cmb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4cmj; else goto c4cmi;
       c4cmj: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4cmi: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.564999702 UTC

[section ""data" . GHC.Natural.$fReadNatural_closure" {
     GHC.Natural.$fReadNatural_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Natural.$fReadNatural_$creadsPrec_closure+1;
         const GHC.Natural.$fReadNatural_$creadList_closure+1;
         const GHC.Natural.$fReadNatural4_closure+1;
         const GHC.Natural.$fReadNatural1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.567347105 UTC

[section ""data" . GHC.Natural.isValidNatural_closure" {
     GHC.Natural.isValidNatural_closure:
         const GHC.Natural.isValidNatural_info;
         const 0;
 },
 GHC.Natural.isValidNatural_entry() //  [R2]
         { info_tbl: [(c4cmA,
                       label: GHC.Natural.isValidNatural_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cmA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4cmB; else goto c4cmC;
       c4cmB: // global
           R2 = R2;
           R1 = GHC.Natural.isValidNatural_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4cmC: // global
           I64[Sp - 8] = block_c4cmy_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cmy() //  [R1]
         { info_tbl: [(c4cmy,
                       label: block_c4cmy_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cmy: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.572981739 UTC

[section ""data" . GHC.Natural.minusNaturalMaybe_closure" {
     GHC.Natural.minusNaturalMaybe_closure:
         const GHC.Natural.minusNaturalMaybe_info;
         const 0;
 },
 sat_s4bxC_entry() //  [R1]
         { info_tbl: [(c4cn3,
                       label: sat_s4bxC_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cn3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4cn4; else goto c4cn5;
       c4cn4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cn5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Natural.$fNumNatural_$c-_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Natural.minusNaturalMaybe_entry() //  [R2, R3]
         { info_tbl: [(c4cn9,
                       label: GHC.Natural.minusNaturalMaybe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cn9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4cna; else goto c4cnb;
       c4cna: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.minusNaturalMaybe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4cnb: // global
           I64[Sp - 24] = block_c4cmU_info;
           _s4bxA::P64 = R3;
           R3 = R3;
           _s4bxz::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s4bxz::P64;
           P64[Sp - 8] = _s4bxA::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cmU() //  [R1]
         { info_tbl: [(c4cmU,
                       label: block_c4cmU_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cmU: // global
           if (R1 == 1) goto c4cn8; else goto c4cn7;
       c4cn8: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4cnh; else goto c4cng;
       c4cnh: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4cng: // global
           I64[Hp - 40] = sat_s4bxC_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4cn7: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.581196775 UTC

[section ""data" . GHC.Natural.$fIxNatural_closure" {
     GHC.Natural.$fIxNatural_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Natural.$fOrdNatural_closure+1;
         const GHC.Arr.$fIxInteger_$crange_closure+1;
         const GHC.Arr.$fIxInteger_$cindex_closure+2;
         const GHC.Arr.$fIxInteger_$cunsafeIndex_closure+2;
         const GHC.Arr.$fIxInteger_$cinRange_closure+2;
         const GHC.Arr.$fIxInteger_$crangeSize_closure+1;
         const GHC.Arr.$fIxInteger_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.583345655 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cunsafeShiftL_closure" {
     GHC.Natural.$fBitsNatural_$cunsafeShiftL_closure:
         const GHC.Natural.$fBitsNatural_$cunsafeShiftL_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c4cnE,
                       label: GHC.Natural.$fBitsNatural_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cnE: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.587415189 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cunsafeShiftR_closure" {
     GHC.Natural.$fBitsNatural_$cunsafeShiftR_closure:
         const GHC.Natural.$fBitsNatural_$cunsafeShiftR_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c4cnP,
                       label: GHC.Natural.$fBitsNatural_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cnP: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshiftR_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.591121661 UTC

[section ""data" . GHC.Natural.$fBitsNatural_closure" {
     GHC.Natural.$fBitsNatural_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Natural.$fEqNatural_closure+1;
         const GHC.Natural.$fBitsNatural_$c.&._closure+2;
         const GHC.Natural.$fBitsNatural_$c.|._closure+2;
         const GHC.Natural.$fBitsNatural_$cxor_closure+2;
         const GHC.Natural.$fBitsNatural_$ccomplement_closure+1;
         const GHC.Natural.$fBitsNatural_$cshift_closure+2;
         const GHC.Natural.$fBitsNatural_$crotate_closure+2;
         const GHC.Natural.$fBitsNatural1_closure;
         const Data.Bits.$fBitsInteger_$cbit_closure+1;
         const GHC.Natural.$fBitsNatural_$csetBit_closure+2;
         const GHC.Natural.$fBitsNatural_$cclearBit_closure+2;
         const GHC.Natural.$fBitsNatural_$ccomplementBit_closure+2;
         const GHC.Natural.$fBitsNatural_$ctestBit_closure+2;
         const GHC.Natural.$fBitsNatural_$cbitSizeMaybe_closure+1;
         const GHC.Natural.$fBitsNatural_$cbitSize_closure;
         const GHC.Natural.$fBitsNatural_$cisSigned_closure+1;
         const GHC.Natural.$fBitsNatural_$cshiftL_closure+2;
         const GHC.Natural.$fBitsNatural_$cunsafeShiftL_closure+2;
         const GHC.Natural.$fBitsNatural_$cshiftR_closure+2;
         const GHC.Natural.$fBitsNatural_$cunsafeShiftR_closure+2;
         const GHC.Natural.$fBitsNatural_$crotateL_closure+2;
         const GHC.Natural.$fBitsNatural_$crotateR_closure+2;
         const GHC.Natural.$fBitsNatural_$cpopCount_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.593221546 UTC

[section ""data" . sat_s4bxD_closure" {
     sat_s4bxD_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.594905302 UTC

[section ""data" . sat_s4bxE_closure" {
     sat_s4bxE_closure:
         const :_con_info;
         const sat_s4bxD_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.596929617 UTC

[section ""data" . GHC.Natural.powModNatural1_closure" {
     GHC.Natural.powModNatural1_closure:
         const GHC.Natural.powModNatural1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.powModNatural1_entry() //  [R1]
         { info_tbl: [(c4co5,
                       label: GHC.Natural.powModNatural1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4co5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4co6; else goto c4co7;
       c4co6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4co7: // global
           (_c4co2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4co2::I64 == 0) goto c4co4; else goto c4co3;
       c4co4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4co3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4co2::I64;
           R3 = sat_s4bxE_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.602880973 UTC

[section ""data" . GHC.Natural.powModNatural_closure" {
     GHC.Natural.powModNatural_closure:
         const GHC.Natural.powModNatural_info;
         const 0;
 },
 section ""relreadonly" . u4cqL_srtd" {
     u4cqL_srtd:
         const S4byh_srt+80;
         const 53;
         const 8743316464075777;
 },
 GHC.Natural.powModNatural_entry() //  [R2, R3, R4]
         { info_tbl: [(c4coo,
                       label: GHC.Natural.powModNatural_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4coo: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4cop; else goto c4coq;
       c4cop: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.powModNatural_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4coq: // global
           I64[Sp - 32] = block_c4coj_info;
           _s4bxG::P64 = R3;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           _s4bxF::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _s4bxF::P64;
           P64[Sp - 16] = _s4bxG::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cqM_srtd" {
     u4cqM_srtd:
         const S4byh_srt+80;
         const 53;
         const 7617416557233153;
 },
 _c4coj() //  [R1]
         { info_tbl: [(c4coj,
                       label: block_c4coj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4coj: // global
           if (R1 == 1) goto c4con; else goto c4com;
       c4con: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4com: // global
           I64[Sp] = block_c4cot_info;
           R3 = GHC.Natural.powModNatural1_closure;
           R2 = P64[Sp + 24];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cqN_srtd" {
     u4cqN_srtd:
         const S4byh_srt+160;
         const 43;
         const 7438883356673;
 },
 _c4cot() //  [R1]
         { info_tbl: [(c4cot,
                       label: block_c4cot_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cot: // global
           if (R1 == 1) goto u4cqw; else goto c4coB;
       u4cqw: // global
           Sp = Sp + 32;
           call _c4cqs() args: 0, res: 0, upd: 0;
       c4coB: // global
           I64[Sp] = block_c4coy_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cqO_srtd" {
     u4cqO_srtd:
         const S4byh_srt+160;
         const 43;
         const 7438883356673;
 },
 _c4coy() //  [R1]
         { info_tbl: [(c4coy,
                       label: block_c4coy_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4coy: // global
           if (R1 == 1) goto u4cqx; else goto c4coI;
       u4cqx: // global
           Sp = Sp + 32;
           call _c4cqo() args: 0, res: 0, upd: 0;
       c4coI: // global
           I64[Sp] = block_c4coF_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cqP_srtd" {
     u4cqP_srtd:
         const S4byh_srt+160;
         const 43;
         const 7438883356673;
 },
 _c4coF() //  [R1]
         { info_tbl: [(c4coF,
                       label: block_c4coF_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4coF: // global
           if (R1 == 1) goto u4cqy; else goto c4coP;
       u4cqy: // global
           Sp = Sp + 32;
           call _c4cqs() args: 0, res: 0, upd: 0;
       c4coP: // global
           I64[Sp] = block_c4coM_info;
           R3 = GHC.Natural.powModNatural1_closure;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cqs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cqs: // global
           R1 = GHC.Natural.$fBitsNatural1_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u4cqQ_srtd" {
     u4cqQ_srtd:
         const S4byh_srt+160;
         const 43;
         const 7438883356673;
 },
 _c4coM() //  [R1]
         { info_tbl: [(c4coM,
                       label: block_c4coM_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4coM: // global
           if (R1 == 1) goto u4cqz; else goto c4cqc;
       u4cqz: // global
           Sp = Sp + 32;
           call _c4cqo() args: 0, res: 0, upd: 0;
       c4cqc: // global
           P64[Sp] = GHC.Natural.powModNatural1_closure;
           _s4bxO::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s4bxO::P64;
           call _c4coX() args: 0, res: 0, upd: 0;
     }
 },
 _c4cqo() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cqo: // global
           R1 = GHC.Natural.powModNatural1_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4coX() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4coX: // global
           I64[Sp - 8] = block_c4coZ_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4cqI; else goto c4cp0;
       u4cqI: // global
           call _c4coZ(R1) args: 0, res: 0, upd: 0;
       c4cp0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cqR_srtd" {
     u4cqR_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4coZ() //  [R1]
         { info_tbl: [(c4coZ,
                       label: block_c4coZ_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4coZ: // global
           I64[Sp] = block_c4cp4_info;
           R3 = GHC.Natural.$seven_n_closure;
           R2 = P64[Sp + 16];
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.remInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cqS_srtd" {
     u4cqS_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cp4() //  [R1]
         { info_tbl: [(c4cp4,
                       label: block_c4cp4_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cp4: // global
           I64[Sp] = block_c4cpa_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = R1;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cqT_srtd" {
     u4cqT_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cpa() //  [R1]
         { info_tbl: [(c4cpa,
                       label: block_c4cpa_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cpa: // global
           if (R1 == 1) goto c4cpL; else goto c4cpy;
       c4cpL: // global
           I64[Sp] = block_c4cpJ_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       c4cpy: // global
           _s4bxQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4cpf_info;
           R3 = P64[Sp + 24];
           R2 = _s4bxQ::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cqU_srtd" {
     u4cqU_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cpJ() //  [R1]
         { info_tbl: [(c4cpJ,
                       label: block_c4cpJ_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cpJ: // global
           if (R1 == 1) goto c4cqa; else goto c4cq0;
       c4cqa: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4cq0: // global
           I64[Sp] = block_c4cpP_info;
           R3 = 1;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cqV_srtd" {
     u4cqV_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cpP() //  [R1]
         { info_tbl: [(c4cpP,
                       label: block_c4cpP_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cpP: // global
           I64[Sp] = block_c4cpT_info;
           _s4bxR::P64 = P64[Sp + 24];
           R3 = _s4bxR::P64;
           R2 = _s4bxR::P64;
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cqW_srtd" {
     u4cqW_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cpT() //  [R1]
         { info_tbl: [(c4cpT,
                       label: block_c4cpT_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cpT: // global
           I64[Sp] = block_c4cpX_info;
           R3 = P64[Sp + 32];
           R2 = R1;
           call GHC.Integer.Type.modInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cqX_srtd" {
     u4cqX_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cpX() //  [R1]
         { info_tbl: [(c4cpX,
                       label: block_c4cpX_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cpX: // global
           _s4bxP::P64 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           P64[Sp + 16] = _s4bxP::P64;
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c4coX() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . u4cqY_srtd" {
     u4cqY_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cpf() //  [R1]
         { info_tbl: [(c4cpf,
                       label: block_c4cpf_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cpf: // global
           I64[Sp] = block_c4cpj_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Integer.Type.modInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cqZ_srtd" {
     u4cqZ_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cpj() //  [R1]
         { info_tbl: [(c4cpj,
                       label: block_c4cpj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cpj: // global
           I64[Sp] = block_c4cpn_info;
           R3 = 1;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cr0_srtd" {
     u4cr0_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cpn() //  [R1]
         { info_tbl: [(c4cpn,
                       label: block_c4cpn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cpn: // global
           I64[Sp] = block_c4cpr_info;
           _s4bxR::P64 = P64[Sp + 16];
           R3 = _s4bxR::P64;
           R2 = _s4bxR::P64;
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cr1_srtd" {
     u4cr1_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cpr() //  [R1]
         { info_tbl: [(c4cpr,
                       label: block_c4cpr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cpr: // global
           I64[Sp] = block_c4cpv_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Integer.Type.modInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cr2_srtd" {
     u4cr2_srtd:
         const S4byh_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cpv() //  [R1]
         { info_tbl: [(c4cpv,
                       label: block_c4cpv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cpv: // global
           _s4bxP::P64 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           _s4bxQ::P64 = P64[Sp + 8];
           P64[Sp + 8] = _s4bxP::P64;
           P64[Sp] = _s4bxQ::P64;
           call _c4coX() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:04.651067758 UTC

[section ""relreadonly" . S4byh_srt" {
     S4byh_srt:
         const GHC.Real.$fFractionalRatio_$s$cfromInteger_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Natural.$fEnumNatural_$ctoEnum_closure;
         const lvl1_r4bvD_closure;
         const GHC.Enum.$fEnumInteger_$cpred_closure;
         const GHC.Natural.$fBitsNatural1_closure;
         const GHC.Natural.$fEnumNatural_$cpred_closure;
         const lvl3_r4bvF_closure;
         const GHC.Enum.$fEnumInteger_$csucc_closure;
         const GHC.Integer.Type.divModInteger_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Natural.$fIntegralNatural_$cdivMod_closure;
         const GHC.Natural.$fIntegralNatural_$cquotRem_closure;
         const GHC.Exception.underflowException_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.Natural.underflowError_closure;
         const GHC.Natural.$fNumNatural_$cnegate_closure;
         const GHC.Natural.naturalFromInteger_closure;
         const GHC.Natural.$fNumNatural_$c-_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$fIntegralInteger_$cquot_closure;
         const GHC.Real.$fIntegralInteger_$crem_closure;
         const GHC.Real.$fIntegralInteger_$cdiv_closure;
         const GHC.Real.$fIntegralInteger_$cmod_closure;
         const GHC.Enum.enumDeltaToInteger_closure;
         const GHC.Enum.$fEnumInteger_$cenumFromThen_closure;
         const GHC.Natural.$fEnumNatural_$cenumFromThen_closure;
         const sat_s4bwF_closure;
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Natural.$fShowNatural_$cshow_closure;
         const GHC.Natural.$fShowNatural1_closure;
         const Data.Bits.$fBitsInteger_$cpopCount_closure;
         const Data.Bits.$fBitsInteger_$crotateR_closure;
         const Data.Bits.$fBitsInteger_$cshift_closure;
         const Data.Bits.$fBitsInteger_$cshiftR_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Bits.$fBitsInteger_$ccomplementBit_closure;
         const Data.Bits.$fBitsInteger_$cclearBit_closure;
         const Data.Bits.$fBitsInteger_$csetBit_closure;
         const lvl6_r4bvJ_closure;
         const sat_s4bx0_closure;
         const GHC.Natural.naturalToWordMaybe_closure;
         const GHC.Natural.naturalToWordMaybe1_closure;
         const GHC.Natural.$fReadNatural_go_closure;
         const GHC.Read.$fReadInteger2_closure;
         const GHC.Read.$fReadInteger_$sreadNumber_closure;
         const GHC.Natural.$fReadNatural_$creadsPrec_closure;
         const GHC.Natural.$fReadNatural4_closure;
         const GHC.Read.list_closure;
         const GHC.Natural.$fReadNatural2_closure;
         const GHC.Natural.$fReadNatural1_closure;
         const GHC.Natural.$fReadNatural_$creadList_closure;
         const GHC.Natural.isValidNatural_closure;
         const GHC.Natural.$fBitsNatural1_closure;
         const GHC.Natural.$fNumNatural_$c-_closure;
         const GHC.Natural.minusNaturalMaybe_closure;
         const sat_s4bxE_closure;
         const GHC.Integer.Type.modInteger_closure;
         const GHC.Integer.Type.shiftRInteger_closure;
         const GHC.Natural.powModNatural_closure;
         const GHC.Natural.$seven_n_closure;
         const GHC.Natural.powModNatural1_closure;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.579112691 UTC

[]


==================== Output Cmm ====================
2018-03-16 15:59:05.580489253 UTC

[section ""data" . GHC.Natural.$fNumNatural_$cabs_closure" {
     GHC.Natural.$fNumNatural_$cabs_closure:
         const GHC.Natural.$fNumNatural_$cabs_info;
 },
 GHC.Natural.$fNumNatural_$cabs_entry() //  [R2]
         { info_tbl: [(c4cuN,
                       label: GHC.Natural.$fNumNatural_$cabs_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cuN: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.586824784 UTC

[section ""data" . GHC.Natural.$fRealNatural_$ctoRational_closure" {
     GHC.Natural.$fRealNatural_$ctoRational_closure:
         const GHC.Natural.$fRealNatural_$ctoRational_info;
         const 0;
 },
 GHC.Natural.$fRealNatural_$ctoRational_entry() //  [R2]
         { info_tbl: [(c4cv0,
                       label: GHC.Natural.$fRealNatural_$ctoRational_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cv0: // global
           R2 = R2;
           call GHC.Real.$fFractionalRatio_$s$cfromInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.590798489 UTC

[section ""data" . GHC.Natural.$fEnumNatural_$cfromEnum_closure" {
     GHC.Natural.$fEnumNatural_$cfromEnum_closure:
         const GHC.Natural.$fEnumNatural_$cfromEnum_info;
 },
 GHC.Natural.$fEnumNatural_$cfromEnum_entry() //  [R2]
         { info_tbl: [(c4cvc,
                       label: GHC.Natural.$fEnumNatural_$cfromEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cvc: // global
           R2 = R2;
           call GHC.Enum.$fEnumInteger_$cfromEnum_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.594661601 UTC

[section ""cstring" . lvl_r4bvC_bytes" {
     lvl_r4bvC_bytes:
         I8[] [78,97,116,117,114,97,108,46,116,111,69,110,117,109,58,32,110,101,103,97,116,105,118,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.596725648 UTC

[section ""data" . lvl1_r4bvD_closure" {
     lvl1_r4bvD_closure:
         const lvl1_r4bvD_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_r4bvD_entry() //  [R1]
         { info_tbl: [(c4cvs,
                       label: lvl1_r4bvD_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cvs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4cvt; else goto c4cvu;
       c4cvt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cvu: // global
           (_c4cvn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4cvn::I64 == 0) goto c4cvp; else goto c4cvo;
       c4cvp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4cvo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4cvn::I64;
           I64[Sp - 24] = block_c4cvq_info;
           R2 = lvl_r4bvC_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4cvq() //  [R1]
         { info_tbl: [(c4cvq,
                       label: block_c4cvq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cvq: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.604603 UTC

[section ""data" . GHC.Natural.$fEnumNatural_$ctoEnum_closure" {
     GHC.Natural.$fEnumNatural_$ctoEnum_closure:
         const GHC.Natural.$fEnumNatural_$ctoEnum_info;
         const 0;
 },
 GHC.Natural.$fEnumNatural_$ctoEnum_entry() //  [R2]
         { info_tbl: [(c4cvR,
                       label: GHC.Natural.$fEnumNatural_$ctoEnum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cvR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4cvS; else goto c4cvT;
       c4cvS: // global
           R2 = R2;
           R1 = GHC.Natural.$fEnumNatural_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4cvT: // global
           I64[Sp - 8] = block_c4cvO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4cw2; else goto c4cvP;
       u4cw2: // global
           call _c4cvO(R1) args: 0, res: 0, upd: 0;
       c4cvP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _c4cvO() //  [R1]
         { info_tbl: [(c4cvO,
                       label: block_c4cvO_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cvO: // global
           _s4csx::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(_s4csx::I64, 0)) goto c4cw0; else goto c4cw1;
       c4cw0: // global
           R2 = _s4csx::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       c4cw1: // global
           R1 = lvl1_r4bvD_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.610722552 UTC

[section ""data" . GHC.Natural.$fBitsNatural1_closure" {
     GHC.Natural.$fBitsNatural1_closure:
         const GHC.Natural.$fBitsNatural1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.$fBitsNatural1_entry() //  [R1]
         { info_tbl: [(c4cwk,
                       label: GHC.Natural.$fBitsNatural1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cwk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4cwl; else goto c4cwm;
       c4cwl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cwm: // global
           (_c4cwh::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4cwh::I64 == 0) goto c4cwj; else goto c4cwi;
       c4cwj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4cwi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4cwh::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.618536315 UTC

[section ""cstring" . lvl2_r4bvE_bytes" {
     lvl2_r4bvE_bytes:
         I8[] [78,97,116,117,114,97,108,46,112,114,101,100,58,32,48]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.621757612 UTC

[section ""data" . lvl3_r4bvF_closure" {
     lvl3_r4bvF_closure:
         const lvl3_r4bvF_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_r4bvF_entry() //  [R1]
         { info_tbl: [(c4cwG,
                       label: lvl3_r4bvF_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cwG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4cwH; else goto c4cwI;
       c4cwH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cwI: // global
           (_c4cwB::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4cwB::I64 == 0) goto c4cwD; else goto c4cwC;
       c4cwD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4cwC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4cwB::I64;
           I64[Sp - 24] = block_c4cwE_info;
           R2 = lvl2_r4bvE_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4cwE() //  [R1]
         { info_tbl: [(c4cwE,
                       label: block_c4cwE_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cwE: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.631326222 UTC

[section ""data" . GHC.Natural.$fEnumNatural_$cpred_closure" {
     GHC.Natural.$fEnumNatural_$cpred_closure:
         const GHC.Natural.$fEnumNatural_$cpred_info;
         const 0;
 },
 GHC.Natural.$fEnumNatural_$cpred_entry() //  [R2]
         { info_tbl: [(c4cx7,
                       label: GHC.Natural.$fEnumNatural_$cpred_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cx7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4cx8; else goto c4cx9;
       c4cx8: // global
           R2 = R2;
           R1 = GHC.Natural.$fEnumNatural_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4cx9: // global
           I64[Sp - 16] = block_c4cx2_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           _s4csA::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s4csA::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cx2() //  [R1]
         { info_tbl: [(c4cx2,
                       label: block_c4cx2_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cx2: // global
           if (R1 == 1) goto c4cx6; else goto c4cx5;
       c4cx6: // global
           R1 = lvl3_r4bvF_closure;
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4cx5: // global
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Enum.$fEnumInteger_$cpred_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.639299063 UTC

[section ""data" . GHC.Natural.$fEnumNatural_$csucc_closure" {
     GHC.Natural.$fEnumNatural_$csucc_closure:
         const GHC.Natural.$fEnumNatural_$csucc_info;
         const 0;
 },
 GHC.Natural.$fEnumNatural_$csucc_entry() //  [R2]
         { info_tbl: [(c4cxu,
                       label: GHC.Natural.$fEnumNatural_$csucc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cxu: // global
           R2 = R2;
           call GHC.Enum.$fEnumInteger_$csucc_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.643909796 UTC

[section ""data" . $ctoInteger_r4bvG_closure" {
     $ctoInteger_r4bvG_closure:
         const $ctoInteger_r4bvG_info;
 },
 $ctoInteger_r4bvG_entry() //  [R2]
         { info_tbl: [(c4cxF,
                       label: $ctoInteger_r4bvG_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cxF: // global
           R1 = R2 & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.648577084 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$ctoInteger_closure" {
     GHC.Natural.$fIntegralNatural_$ctoInteger_closure:
         const GHC.Natural.$fIntegralNatural_$ctoInteger_info;
 },
 GHC.Natural.$fIntegralNatural_$ctoInteger_entry() //  [R2]
         { info_tbl: [(c4cxS,
                       label: GHC.Natural.$fIntegralNatural_$ctoInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cxS: // global
           R2 = R2;
           call $ctoInteger_r4bvG_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.653964697 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$cdivMod_closure" {
     GHC.Natural.$fIntegralNatural_$cdivMod_closure:
         const GHC.Natural.$fIntegralNatural_$cdivMod_info;
         const 0;
 },
 ds2_s4csF_entry() //  [R1]
         { info_tbl: [(c4cyc,
                       label: ds2_s4csF_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cyc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4cyd; else goto c4cye;
       c4cyd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cye: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4cy7_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           _s4csE::P64 = P64[R1 + 24];
           R2 = _s4csE::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s4csE::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4cy7() //  [R1]
         { info_tbl: [(c4cy7,
                       label: block_c4cy7_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cy7: // global
           if (R1 == 1) goto c4cyb; else goto c4cya;
       c4cyb: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       c4cya: // global
           _s4csE::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4cyh_info;
           R3 = _s4csE::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.divModInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4cyh() //  [R1, R2]
         { info_tbl: [(c4cyh,
                       label: block_c4cyh_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cyh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4cyn; else goto c4cym;
       c4cyn: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4cym: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Natural.$fIntegralNatural_$cdivMod_entry() //  [R2, R3]
         { info_tbl: [(c4cyu,
                       label: GHC.Natural.$fIntegralNatural_$cdivMod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cyu: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c4cyy; else goto c4cyx;
       c4cyy: // global
           HpAlloc = 104;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fIntegralNatural_$cdivMod_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4cyx: // global
           I64[Hp - 96] = ds2_s4csF_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _c4cy3::P64 = Hp - 96;
           P64[Hp - 48] = _c4cy3::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c4cy3::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.667210474 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$cquotRem_closure" {
     GHC.Natural.$fIntegralNatural_$cquotRem_closure:
         const GHC.Natural.$fIntegralNatural_$cquotRem_info;
         const 0;
 },
 ds2_s4csU_entry() //  [R1]
         { info_tbl: [(c4czd,
                       label: ds2_s4csU_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4czd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4cze; else goto c4czf;
       c4cze: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4czf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_c4cz8_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           _s4csT::P64 = P64[R1 + 24];
           R2 = _s4csT::P64;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = _s4csT::P64;
           Sp = Sp - 40;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4cz8() //  [R1]
         { info_tbl: [(c4cz8,
                       label: block_c4cz8_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cz8: // global
           if (R1 == 1) goto c4czc; else goto c4czb;
       c4czc: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 24, res: 0, upd: 24;
       c4czb: // global
           _s4csT::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_c4czi_info;
           R3 = _s4csT::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Integer.Type.quotRemInteger_entry(R3,
                                                      R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4czi() //  [R1, R2]
         { info_tbl: [(c4czi,
                       label: block_c4czi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4czi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4czo; else goto c4czn;
       c4czo: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       c4czn: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Natural.$fIntegralNatural_$cquotRem_entry() //  [R2, R3]
         { info_tbl: [(c4czv,
                       label: GHC.Natural.$fIntegralNatural_$cquotRem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4czv: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto c4czz; else goto c4czy;
       c4czz: // global
           HpAlloc = 104;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fIntegralNatural_$cquotRem_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4czy: // global
           I64[Hp - 96] = ds2_s4csU_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _c4cz4::P64 = Hp - 96;
           P64[Hp - 48] = _c4cz4::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _c4cz4::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.677921081 UTC

[section ""data" . GHC.Natural.$fEqNatural_closure" {
     GHC.Natural.$fEqNatural_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.Integer.Type.eqInteger_closure+2;
         const GHC.Integer.Type.neqInteger_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.679747486 UTC

[section ""data" . GHC.Natural.$fOrdNatural_closure" {
     GHC.Natural.$fOrdNatural_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.Natural.$fEqNatural_closure+1;
         const GHC.Integer.Type.compareInteger_closure+2;
         const GHC.Integer.Type.ltInteger_closure+2;
         const GHC.Integer.Type.leInteger_closure+2;
         const GHC.Integer.Type.gtInteger_closure+2;
         const GHC.Integer.Type.geInteger_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmax_closure+2;
         const GHC.Integer.Type.$fOrdInteger_$cmin_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.681955484 UTC

[section ""data" . GHC.Natural.underflowError_closure" {
     GHC.Natural.underflowError_closure:
         const GHC.Natural.underflowError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.underflowError_entry() //  [R1]
         { info_tbl: [(c4cA9,
                       label: GHC.Natural.underflowError_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cA9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4cAa; else goto c4cAb;
       c4cAa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cAb: // global
           (_c4cA6::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4cA6::I64 == 0) goto c4cA8; else goto c4cA7;
       c4cA8: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4cA7: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4cA6::I64;
           R1 = GHC.Exception.underflowException_closure;
           Sp = Sp - 16;
           call stg_raise#(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.686403231 UTC

[section ""data" . GHC.Natural.$fNumNatural_$cnegate_closure" {
     GHC.Natural.$fNumNatural_$cnegate_closure:
         const GHC.Natural.$fNumNatural_$cnegate_info;
         const 0;
 },
 GHC.Natural.$fNumNatural_$cnegate_entry() //  [R2]
         { info_tbl: [(c4cAq,
                       label: GHC.Natural.$fNumNatural_$cnegate_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cAq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4cAr; else goto c4cAs;
       c4cAr: // global
           R2 = R2;
           R1 = GHC.Natural.$fNumNatural_$cnegate_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4cAs: // global
           I64[Sp - 8] = block_c4cAo_info;
           R3 = R2;
           R2 = GHC.Natural.$fBitsNatural1_closure;
           Sp = Sp - 8;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cAo() //  [R1]
         { info_tbl: [(c4cAo,
                       label: block_c4cAo_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cAo: // global
           I64[Sp - 8] = block_c4cAv_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cAv() //  [R1]
         { info_tbl: [(c4cAv,
                       label: block_c4cAv_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cAv: // global
           if (R1 == 1) goto c4cAG; else goto c4cAC;
       c4cAG: // global
           R1 = GHC.Natural.underflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4cAC: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.694472889 UTC

[section ""data" . GHC.Natural.naturalFromInteger_closure" {
     GHC.Natural.naturalFromInteger_closure:
         const GHC.Natural.naturalFromInteger_info;
         const 0;
 },
 GHC.Natural.naturalFromInteger_entry() //  [R2]
         { info_tbl: [(c4cB5,
                       label: GHC.Natural.naturalFromInteger_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cB5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4cB6; else goto c4cB7;
       c4cB6: // global
           R2 = R2;
           R1 = GHC.Natural.naturalFromInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4cB7: // global
           I64[Sp - 16] = block_c4cB0_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           _s4cta::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s4cta::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cB0() //  [R1]
         { info_tbl: [(c4cB0,
                       label: block_c4cB0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cB0: // global
           if (R1 == 1) goto c4cB4; else goto c4cB3;
       c4cB4: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4cB3: // global
           R1 = GHC.Natural.underflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.700593052 UTC

[section ""data" . GHC.Natural.$fNumNatural_$c-_closure" {
     GHC.Natural.$fNumNatural_$c-_closure:
         const GHC.Natural.$fNumNatural_$c-_info;
         const 0;
 },
 GHC.Natural.$fNumNatural_$c-_entry() //  [R2, R3]
         { info_tbl: [(c4cBv,
                       label: GHC.Natural.$fNumNatural_$c-_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cBv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4cBw; else goto c4cBx;
       c4cBw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fNumNatural_$c-_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4cBx: // global
           I64[Sp - 8] = block_c4cBt_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cBt() //  [R1]
         { info_tbl: [(c4cBt,
                       label: block_c4cBt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cBt: // global
           I64[Sp - 8] = block_c4cBA_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = R1;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cBA() //  [R1]
         { info_tbl: [(c4cBA,
                       label: block_c4cBA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cBA: // global
           if (R1 == 1) goto c4cBL; else goto c4cBH;
       c4cBL: // global
           R1 = GHC.Natural.underflowError_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4cBH: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.709185409 UTC

[section ""data" . GHC.Natural.$fNumNatural_$c+_closure" {
     GHC.Natural.$fNumNatural_$c+_closure:
         const GHC.Natural.$fNumNatural_$c+_info;
         const 0;
 },
 GHC.Natural.$fNumNatural_$c+_entry() //  [R2, R3]
         { info_tbl: [(c4cC5,
                       label: GHC.Natural.$fNumNatural_$c+_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cC5: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.plusInteger_entry(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.712578667 UTC

[section ""data" . GHC.Natural.$fNumNatural_$c*_closure" {
     GHC.Natural.$fNumNatural_$c*_closure:
         const GHC.Natural.$fNumNatural_$c*_info;
         const 0;
 },
 GHC.Natural.$fNumNatural_$c*_entry() //  [R2, R3]
         { info_tbl: [(c4cCg,
                       label: GHC.Natural.$fNumNatural_$c*_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cCg: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.71588685 UTC

[section ""data" . GHC.Natural.$fNumNatural_$csignum_closure" {
     GHC.Natural.$fNumNatural_$csignum_closure:
         const GHC.Natural.$fNumNatural_$csignum_info;
 },
 GHC.Natural.$fNumNatural_$csignum_entry() //  [R2]
         { info_tbl: [(c4cCr,
                       label: GHC.Natural.$fNumNatural_$csignum_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cCr: // global
           R2 = R2;
           call GHC.Integer.Type.signumInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.719121957 UTC

[section ""data" . GHC.Natural.$fNumNatural_closure" {
     GHC.Natural.$fNumNatural_closure:
         const GHC.Num.C:Num_con_info;
         const GHC.Natural.$fNumNatural_$c+_closure+2;
         const GHC.Natural.$fNumNatural_$c-_closure+2;
         const GHC.Natural.$fNumNatural_$c*_closure+2;
         const GHC.Natural.$fNumNatural_$cnegate_closure+1;
         const GHC.Natural.$fNumNatural_$cabs_closure+1;
         const GHC.Natural.$fNumNatural_$csignum_closure+1;
         const GHC.Natural.naturalFromInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.721015727 UTC

[section ""data" . GHC.Natural.$fRealNatural_closure" {
     GHC.Natural.$fRealNatural_closure:
         const GHC.Real.C:Real_con_info;
         const GHC.Natural.$fNumNatural_closure+1;
         const GHC.Natural.$fOrdNatural_closure+1;
         const GHC.Natural.$fRealNatural_$ctoRational_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.723003494 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$cquot_closure" {
     GHC.Natural.$fIntegralNatural_$cquot_closure:
         const GHC.Natural.$fIntegralNatural_$cquot_info;
         const 0;
 },
 GHC.Natural.$fIntegralNatural_$cquot_entry() //  [R2, R3]
         { info_tbl: [(c4cCE,
                       label: GHC.Natural.$fIntegralNatural_$cquot_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cCE: // global
           R3 = R3;
           R2 = R2;
           call GHC.Real.$fIntegralInteger_$cquot_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.726780083 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$crem_closure" {
     GHC.Natural.$fIntegralNatural_$crem_closure:
         const GHC.Natural.$fIntegralNatural_$crem_info;
         const 0;
 },
 GHC.Natural.$fIntegralNatural_$crem_entry() //  [R2, R3]
         { info_tbl: [(c4cCP,
                       label: GHC.Natural.$fIntegralNatural_$crem_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cCP: // global
           R3 = R3;
           R2 = R2;
           call GHC.Real.$fIntegralInteger_$crem_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.730306065 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$cdiv_closure" {
     GHC.Natural.$fIntegralNatural_$cdiv_closure:
         const GHC.Natural.$fIntegralNatural_$cdiv_info;
         const 0;
 },
 GHC.Natural.$fIntegralNatural_$cdiv_entry() //  [R2, R3]
         { info_tbl: [(c4cD0,
                       label: GHC.Natural.$fIntegralNatural_$cdiv_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cD0: // global
           R3 = R3;
           R2 = R2;
           call GHC.Real.$fIntegralInteger_$cdiv_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.735072315 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_$cmod_closure" {
     GHC.Natural.$fIntegralNatural_$cmod_closure:
         const GHC.Natural.$fIntegralNatural_$cmod_info;
         const 0;
 },
 GHC.Natural.$fIntegralNatural_$cmod_entry() //  [R2, R3]
         { info_tbl: [(c4cDb,
                       label: GHC.Natural.$fIntegralNatural_$cmod_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cDb: // global
           R3 = R3;
           R2 = R2;
           call GHC.Real.$fIntegralInteger_$cmod_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.739654032 UTC

[section ""data" . GHC.Natural.$fEnumNatural_$cenumFromThen_closure" {
     GHC.Natural.$fEnumNatural_$cenumFromThen_closure:
         const GHC.Natural.$fEnumNatural_$cenumFromThen_info;
         const 0;
 },
 GHC.Natural.$fEnumNatural_$cenumFromThen_entry() //  [R2, R3]
         { info_tbl: [(c4cDr,
                       label: GHC.Natural.$fEnumNatural_$cenumFromThen_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cDr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4cDs; else goto c4cDt;
       c4cDs: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fEnumNatural_$cenumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4cDt: // global
           I64[Sp - 24] = block_c4cDm_info;
           _s4cth::P64 = R3;
           R3 = R3;
           _s4ctg::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s4ctg::P64;
           P64[Sp - 8] = _s4cth::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cDm() //  [R1]
         { info_tbl: [(c4cDm,
                       label: block_c4cDm_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cDm: // global
           _s4ctg::P64 = P64[Sp + 8];
           _s4cth::P64 = P64[Sp + 16];
           if (R1 == 1) goto c4cDq; else goto c4cDp;
       c4cDq: // global
           R3 = _s4cth::P64;
           R2 = _s4ctg::P64;
           Sp = Sp + 24;
           call GHC.Enum.$fEnumInteger_$cenumFromThen_entry(R3,
                                                            R2) args: 8, res: 0, upd: 8;
       c4cDp: // global
           I64[Sp] = block_c4cDw_info;
           R3 = _s4ctg::P64;
           R2 = _s4cth::P64;
           call GHC.Integer.Type.minusInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cDw() //  [R1]
         { info_tbl: [(c4cDw,
                       label: block_c4cDw_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cDw: // global
           R4 = GHC.Natural.$fBitsNatural1_closure;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Enum.enumDeltaToInteger_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.747753019 UTC

[section ""data" . GHC.Natural.$fEnumNatural_closure" {
     GHC.Natural.$fEnumNatural_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.Natural.$fEnumNatural_$csucc_closure+1;
         const GHC.Natural.$fEnumNatural_$cpred_closure+1;
         const GHC.Natural.$fEnumNatural_$ctoEnum_closure+1;
         const GHC.Natural.$fEnumNatural_$cfromEnum_closure+1;
         const GHC.Enum.$fEnumInteger_$cenumFrom_closure+1;
         const GHC.Natural.$fEnumNatural_$cenumFromThen_closure+2;
         const GHC.Enum.$fEnumInteger_$cenumFromTo_closure+2;
         const GHC.Enum.$fEnumInteger_$cenumFromThenTo_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.749665584 UTC

[section ""data" . GHC.Natural.$fIntegralNatural_closure" {
     GHC.Natural.$fIntegralNatural_closure:
         const GHC.Real.C:Integral_con_info;
         const GHC.Natural.$fRealNatural_closure+1;
         const GHC.Natural.$fEnumNatural_closure+1;
         const GHC.Natural.$fIntegralNatural_$cquot_closure+2;
         const GHC.Natural.$fIntegralNatural_$crem_closure+2;
         const GHC.Natural.$fIntegralNatural_$cdiv_closure+2;
         const GHC.Natural.$fIntegralNatural_$cmod_closure+2;
         const GHC.Natural.$fIntegralNatural_$cquotRem_closure+2;
         const GHC.Natural.$fIntegralNatural_$cdivMod_closure+2;
         const GHC.Natural.$fIntegralNatural_$ctoInteger_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.75162039 UTC

[section ""data" . sat_s4ctk_closure" {
     sat_s4ctk_closure:
         const GHC.Types.I#_con_info;
         const 2;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.753306934 UTC

[section ""data" . sat_s4ctl_closure" {
     sat_s4ctl_closure:
         const :_con_info;
         const sat_s4ctk_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.755416097 UTC

[section ""data" . GHC.Natural.$seven_n_closure" {
     GHC.Natural.$seven_n_closure:
         const GHC.Natural.$seven_n_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.$seven_n_entry() //  [R1]
         { info_tbl: [(c4cE2,
                       label: GHC.Natural.$seven_n_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cE2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4cE3; else goto c4cE4;
       c4cE3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cE4: // global
           (_c4cDZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4cDZ::I64 == 0) goto c4cE1; else goto c4cE0;
       c4cE1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4cE0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4cDZ::I64;
           R3 = sat_s4ctl_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.75998625 UTC

[section ""data" . GHC.Natural.$fShowNatural_$cshow_closure" {
     GHC.Natural.$fShowNatural_$cshow_closure:
         const GHC.Natural.$fShowNatural_$cshow_info;
         const 0;
 },
 GHC.Natural.$fShowNatural_$cshow_entry() //  [R2]
         { info_tbl: [(c4cEl,
                       label: GHC.Natural.$fShowNatural_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cEl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4cEm; else goto c4cEn;
       c4cEm: // global
           R2 = R2;
           R1 = GHC.Natural.$fShowNatural_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4cEn: // global
           I64[Sp - 8] = block_c4cEi_info;
           R4 = GHC.Types.[]_closure+1;
           R3 = R2;
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cEi() //  [R1, R2]
         { info_tbl: [(c4cEi,
                       label: block_c4cEi_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cEi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4cEq; else goto c4cEp;
       c4cEq: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4cEp: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.768178433 UTC

[section ""data" . GHC.Natural.$fShowNatural1_closure" {
     GHC.Natural.$fShowNatural1_closure:
         const GHC.Natural.$fShowNatural1_info;
         const 0;
 },
 GHC.Natural.$fShowNatural1_entry() //  [R2, R3]
         { info_tbl: [(c4cEK,
                       label: GHC.Natural.$fShowNatural1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cEK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4cEL; else goto c4cEM;
       c4cEL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fShowNatural1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4cEM: // global
           I64[Sp - 8] = block_c4cEH_info;
           R4 = R3;
           R3 = R2;
           R2 = 0;
           Sp = Sp - 8;
           call GHC.Show.$w$cshowsPrec4_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cEH() //  [R1, R2]
         { info_tbl: [(c4cEH,
                       label: block_c4cEH_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cEH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto c4cEP; else goto c4cEO;
       c4cEP: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       c4cEO: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.77712763 UTC

[section ""data" . GHC.Natural.$fShowNatural_$cshowList_closure" {
     GHC.Natural.$fShowNatural_$cshowList_closure:
         const GHC.Natural.$fShowNatural_$cshowList_info;
         const 0;
 },
 GHC.Natural.$fShowNatural_$cshowList_entry() //  [R2, R3]
         { info_tbl: [(c4cF5,
                       label: GHC.Natural.$fShowNatural_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cF5: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Natural.$fShowNatural1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.780769341 UTC

[section ""data" . GHC.Natural.$fShowNatural_closure" {
     GHC.Natural.$fShowNatural_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.Show.$fShowInteger_$cshowsPrec_closure+3;
         const GHC.Natural.$fShowNatural_$cshow_closure+1;
         const GHC.Natural.$fShowNatural_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.782870338 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cpopCount_closure" {
     GHC.Natural.$fBitsNatural_$cpopCount_closure:
         const GHC.Natural.$fBitsNatural_$cpopCount_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cpopCount_entry() //  [R2]
         { info_tbl: [(c4cFh,
                       label: GHC.Natural.$fBitsNatural_$cpopCount_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cFh: // global
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cpopCount_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.786881898 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$crotateR_closure" {
     GHC.Natural.$fBitsNatural_$crotateR_closure:
         const GHC.Natural.$fBitsNatural_$crotateR_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$crotateR_entry() //  [R2, R3]
         { info_tbl: [(c4cFs,
                       label: GHC.Natural.$fBitsNatural_$crotateR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cFs: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$crotateR_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.790565218 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$crotateL_closure" {
     GHC.Natural.$fBitsNatural_$crotateL_closure:
         const GHC.Natural.$fBitsNatural_$crotateL_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$crotateL_entry() //  [R2, R3]
         { info_tbl: [(c4cFD,
                       label: GHC.Natural.$fBitsNatural_$crotateL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cFD: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.794274729 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cshiftR_closure" {
     GHC.Natural.$fBitsNatural_$cshiftR_closure:
         const GHC.Natural.$fBitsNatural_$cshiftR_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cshiftR_entry() //  [R2, R3]
         { info_tbl: [(c4cFO,
                       label: GHC.Natural.$fBitsNatural_$cshiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cFO: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshiftR_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.797798698 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cshiftL_closure" {
     GHC.Natural.$fBitsNatural_$cshiftL_closure:
         const GHC.Natural.$fBitsNatural_$cshiftL_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cshiftL_entry() //  [R2, R3]
         { info_tbl: [(c4cFZ,
                       label: GHC.Natural.$fBitsNatural_$cshiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cFZ: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.80197943 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cisSigned_closure" {
     GHC.Natural.$fBitsNatural_$cisSigned_closure:
         const GHC.Natural.$fBitsNatural_$cisSigned_info;
 },
 GHC.Natural.$fBitsNatural_$cisSigned_entry() //  []
         { info_tbl: [(c4cGa,
                       label: GHC.Natural.$fBitsNatural_$cisSigned_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cGa: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.805453921 UTC

[section ""cstring" . lvl4_r4bvH_bytes" {
     lvl4_r4bvH_bytes:
         I8[] [78,97,116,117,114,97,108,58,32,98,105,116,83,105,122,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.807523988 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cbitSize_closure" {
     GHC.Natural.$fBitsNatural_$cbitSize_closure:
         const GHC.Natural.$fBitsNatural_$cbitSize_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cbitSize_entry() //  [R1]
         { info_tbl: [(c4cGs,
                       label: GHC.Natural.$fBitsNatural_$cbitSize_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cGs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4cGt; else goto c4cGu;
       c4cGt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cGu: // global
           (_c4cGn::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4cGn::I64 == 0) goto c4cGp; else goto c4cGo;
       c4cGp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4cGo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4cGn::I64;
           I64[Sp - 24] = block_c4cGq_info;
           R2 = lvl4_r4bvH_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4cGq() //  [R1]
         { info_tbl: [(c4cGq,
                       label: block_c4cGq_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cGq: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.813837932 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cbitSizeMaybe_closure" {
     GHC.Natural.$fBitsNatural_$cbitSizeMaybe_closure:
         const GHC.Natural.$fBitsNatural_$cbitSizeMaybe_info;
 },
 GHC.Natural.$fBitsNatural_$cbitSizeMaybe_entry() //  []
         { info_tbl: [(c4cGO,
                       label: GHC.Natural.$fBitsNatural_$cbitSizeMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cGO: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.817234518 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$ctestBit_closure" {
     GHC.Natural.$fBitsNatural_$ctestBit_closure:
         const GHC.Natural.$fBitsNatural_$ctestBit_info;
 },
 GHC.Natural.$fBitsNatural_$ctestBit_entry() //  [R2, R3]
         { info_tbl: [(c4cH1,
                       label: GHC.Natural.$fBitsNatural_$ctestBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cH1: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$ctestBit_entry(R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.820555003 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$ccomplementBit_closure" {
     GHC.Natural.$fBitsNatural_$ccomplementBit_closure:
         const GHC.Natural.$fBitsNatural_$ccomplementBit_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$ccomplementBit_entry() //  [R2, R3]
         { info_tbl: [(c4cHc,
                       label: GHC.Natural.$fBitsNatural_$ccomplementBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cHc: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$ccomplementBit_entry(R3,
                                                              R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.823972388 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cclearBit_closure" {
     GHC.Natural.$fBitsNatural_$cclearBit_closure:
         const GHC.Natural.$fBitsNatural_$cclearBit_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cclearBit_entry() //  [R2, R3]
         { info_tbl: [(c4cHn,
                       label: GHC.Natural.$fBitsNatural_$cclearBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cHn: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cclearBit_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.827613822 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$csetBit_closure" {
     GHC.Natural.$fBitsNatural_$csetBit_closure:
         const GHC.Natural.$fBitsNatural_$csetBit_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$csetBit_entry() //  [R2, R3]
         { info_tbl: [(c4cHy,
                       label: GHC.Natural.$fBitsNatural_$csetBit_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cHy: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$csetBit_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.831277148 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$crotate_closure" {
     GHC.Natural.$fBitsNatural_$crotate_closure:
         const GHC.Natural.$fBitsNatural_$crotate_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$crotate_entry() //  [R2, R3]
         { info_tbl: [(c4cHJ,
                       label: GHC.Natural.$fBitsNatural_$crotate_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cHJ: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.835493756 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cshift_closure" {
     GHC.Natural.$fBitsNatural_$cshift_closure:
         const GHC.Natural.$fBitsNatural_$cshift_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cshift_entry() //  [R2, R3]
         { info_tbl: [(c4cHU,
                       label: GHC.Natural.$fBitsNatural_$cshift_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cHU: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.839100546 UTC

[section ""cstring" . lvl5_r4bvI_bytes" {
     lvl5_r4bvI_bytes:
         I8[] [66,105,116,115,46,99,111,109,112,108,101,109,101,110,116,58,32,78,97,116,117,114,97,108,32,99,111,109,112,108,101,109,101,110,116,32,117,110,100,101,102,105,110,101,100]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.841731997 UTC

[section ""data" . lvl6_r4bvJ_closure" {
     lvl6_r4bvJ_closure:
         const lvl6_r4bvJ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl6_r4bvJ_entry() //  [R1]
         { info_tbl: [(c4cI8,
                       label: lvl6_r4bvJ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cI8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4cI9; else goto c4cIa;
       c4cI9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cIa: // global
           (_c4cI5::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4cI5::I64 == 0) goto c4cI7; else goto c4cI6;
       c4cI7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4cI6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4cI5::I64;
           R2 = lvl5_r4bvI_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.846295141 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$ccomplement_closure" {
     GHC.Natural.$fBitsNatural_$ccomplement_closure:
         const GHC.Natural.$fBitsNatural_$ccomplement_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$ccomplement_entry() //  []
         { info_tbl: [(c4cIn,
                       label: GHC.Natural.$fBitsNatural_$ccomplement_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cIn: // global
           R2 = lvl6_r4bvJ_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.850002068 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cxor_closure" {
     GHC.Natural.$fBitsNatural_$cxor_closure:
         const GHC.Natural.$fBitsNatural_$cxor_info;
 },
 GHC.Natural.$fBitsNatural_$cxor_entry() //  [R2, R3]
         { info_tbl: [(c4cIy,
                       label: GHC.Natural.$fBitsNatural_$cxor_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cIy: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.xorInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.853373057 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$c.|._closure" {
     GHC.Natural.$fBitsNatural_$c.|._closure:
         const GHC.Natural.$fBitsNatural_$c.|._info;
 },
 GHC.Natural.$fBitsNatural_$c.|._entry() //  [R2, R3]
         { info_tbl: [(c4cIJ,
                       label: GHC.Natural.$fBitsNatural_$c.|._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cIJ: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.orInteger_entry(R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.856776922 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$c.&._closure" {
     GHC.Natural.$fBitsNatural_$c.&._closure:
         const GHC.Natural.$fBitsNatural_$c.&._info;
 },
 GHC.Natural.$fBitsNatural_$c.&._entry() //  [R2, R3]
         { info_tbl: [(c4cIU,
                       label: GHC.Natural.$fBitsNatural_$c.&._info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cIU: // global
           R3 = R3;
           R2 = R2;
           call GHC.Integer.Type.andInteger_entry(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.859994683 UTC

[section ""cstring" . GHC.Natural.$trModule4_bytes" {
     GHC.Natural.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.862136101 UTC

[section ""data" . GHC.Natural.$trModule3_closure" {
     GHC.Natural.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Natural.$trModule4_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.863770531 UTC

[section ""cstring" . GHC.Natural.$trModule2_bytes" {
     GHC.Natural.$trModule2_bytes:
         I8[] [71,72,67,46,78,97,116,117,114,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.86568873 UTC

[section ""data" . GHC.Natural.$trModule1_closure" {
     GHC.Natural.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Natural.$trModule2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.867512376 UTC

[section ""data" . GHC.Natural.$trModule_closure" {
     GHC.Natural.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Natural.$trModule3_closure+1;
         const GHC.Natural.$trModule1_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.869320369 UTC

[section ""data" . $krep_r4bvK_closure" {
     $krep_r4bvK_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Integer.Type.$tcInteger_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.871803466 UTC

[section ""cstring" . GHC.Natural.$tcNatural2_bytes" {
     GHC.Natural.$tcNatural2_bytes:
         I8[] [78,97,116,117,114,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.873607711 UTC

[section ""data" . GHC.Natural.$tcNatural1_closure" {
     GHC.Natural.$tcNatural1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Natural.$tcNatural2_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.875323593 UTC

[section ""data" . GHC.Natural.$tcNatural_closure" {
     GHC.Natural.$tcNatural_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Natural.$trModule_closure+1;
         const GHC.Natural.$tcNatural1_closure+1;
         const GHC.Types.krep$*_closure;
         const 18275189520134122949;
         const 2097940004095541788;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.877674711 UTC

[section ""data" . $krep1_r4bvL_closure" {
     $krep1_r4bvL_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Natural.$tcNatural_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.879404911 UTC

[section ""data" . GHC.Natural.$tc'Natural1_closure" {
     GHC.Natural.$tc'Natural1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r4bvK_closure+1;
         const $krep1_r4bvL_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.881127866 UTC

[section ""cstring" . GHC.Natural.$tc'Natural3_bytes" {
     GHC.Natural.$tc'Natural3_bytes:
         I8[] [39,78,97,116,117,114,97,108]
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.882813448 UTC

[section ""data" . GHC.Natural.$tc'Natural2_closure" {
     GHC.Natural.$tc'Natural2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Natural.$tc'Natural3_bytes;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.884526004 UTC

[section ""data" . GHC.Natural.$tc'Natural_closure" {
     GHC.Natural.$tc'Natural_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Natural.$trModule_closure+1;
         const GHC.Natural.$tc'Natural2_closure+1;
         const GHC.Natural.$tc'Natural1_closure+4;
         const 11998593531750078056;
         const 1104420550366228074;
         const 0;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.886720801 UTC

[section ""data" . GHC.Natural.wordToNatural_closure" {
     GHC.Natural.wordToNatural_closure:
         const GHC.Natural.wordToNatural_info;
 },
 GHC.Natural.wordToNatural_entry() //  [R2]
         { info_tbl: [(c4cJj,
                       label: GHC.Natural.wordToNatural_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cJj: // global
           R2 = R2;
           call GHC.Real.$fIntegralWord_$ctoInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.890037854 UTC

[section ""data" . sat_s4ctD_closure" {
     sat_s4ctD_closure:
         const GHC.Types.I#_con_info;
         const 3;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.891854596 UTC

[section ""data" . sat_s4ctE_closure" {
     sat_s4ctE_closure:
         const :_con_info;
         const sat_s4ctD_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.894094962 UTC

[section ""data" . sat_s4ctC_closure" {
     sat_s4ctC_closure:
         const GHC.Types.I#_con_info;
         const 2147483647;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.89593615 UTC

[section ""data" . sat_s4ctF_closure" {
     sat_s4ctF_closure:
         const :_con_info;
         const sat_s4ctC_closure+1;
         const sat_s4ctE_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.898325739 UTC

[section ""data" . sat_s4ctB_closure" {
     sat_s4ctB_closure:
         const GHC.Types.I#_con_info;
         const 2147483647;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.900221706 UTC

[section ""data" . sat_s4ctG_closure" {
     sat_s4ctG_closure:
         const :_con_info;
         const sat_s4ctB_closure+1;
         const sat_s4ctF_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.902171754 UTC

[section ""data" . GHC.Natural.naturalToWordMaybe1_closure" {
     GHC.Natural.naturalToWordMaybe1_closure:
         const GHC.Natural.naturalToWordMaybe1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.naturalToWordMaybe1_entry() //  [R1]
         { info_tbl: [(c4cJC,
                       label: GHC.Natural.naturalToWordMaybe1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cJC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4cJD; else goto c4cJE;
       c4cJD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cJE: // global
           (_c4cJz::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4cJz::I64 == 0) goto c4cJB; else goto c4cJA;
       c4cJB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4cJA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4cJz::I64;
           R3 = sat_s4ctG_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.907452364 UTC

[section ""data" . GHC.Natural.naturalToWordMaybe_closure" {
     GHC.Natural.naturalToWordMaybe_closure:
         const GHC.Natural.naturalToWordMaybe_info;
         const 0;
 },
 sat_s4ctK_entry() //  [R1]
         { info_tbl: [(c4cK3,
                       label: sat_s4ctK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cK3: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4cK7; else goto c4cK8;
       c4cK7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cK8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_c4cK1_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.Integer.Type.integerToWord_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 _c4cK1() //  [R1]
         { info_tbl: [(c4cK1,
                       label: block_c4cK1_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cK1: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4cKb; else goto c4cKa;
       c4cKb: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 24;
       c4cKa: // global
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Natural.naturalToWordMaybe_entry() //  [R2]
         { info_tbl: [(c4cKf,
                       label: GHC.Natural.naturalToWordMaybe_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cKf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4cKg; else goto c4cKh;
       c4cKg: // global
           R2 = R2;
           R1 = GHC.Natural.naturalToWordMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4cKh: // global
           I64[Sp - 16] = block_c4cJS_info;
           R3 = GHC.Natural.naturalToWordMaybe1_closure;
           _s4ctH::P64 = R2;
           R2 = R2;
           P64[Sp - 8] = _s4ctH::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cJS() //  [R1]
         { info_tbl: [(c4cJS,
                       label: block_c4cJS_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cJS: // global
           if (R1 == 1) goto c4cKe; else goto c4cKd;
       c4cKe: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4cKn; else goto c4cKm;
       c4cKn: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4cKm: // global
           I64[Hp - 32] = sat_s4ctK_info;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4cKd: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.918423471 UTC

[section ""data" . GHC.Natural.$fReadNatural_go_closure" {
     GHC.Natural.$fReadNatural_go_closure:
         const GHC.Natural.$fReadNatural_go_info;
         const 0;
 },
 sat_s4ctU_entry() //  [R1]
         { info_tbl: [(c4cLd,
                       label: sat_s4ctU_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cLd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4cLe; else goto c4cLf;
       c4cLe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cLf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Natural.$fReadNatural_go_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . u4cLG_srtd" {
     u4cLG_srtd:
         const S4cv3_srt+40;
         const 40;
         const 549755813889;
 },
 GHC.Natural.$fReadNatural_go_entry() //  [R2]
         { info_tbl: [(c4cLk,
                       label: GHC.Natural.$fReadNatural_go_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cLk: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4cLl; else goto u4cLA;
       c4cLl: // global
           R2 = R2;
           R1 = GHC.Natural.$fReadNatural_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       u4cLA: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _c4cKQ() args: 0, res: 0, upd: 0;
     }
 },
 _c4cKQ() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cKQ: // global
           _s4ctL::P64 = P64[Sp];
           I64[Sp] = block_c4cKT_info;
           R1 = _s4ctL::P64;
           if (R1 & 7 != 0) goto u4cLC; else goto c4cKU;
       u4cLC: // global
           call _c4cKT(R1) args: 0, res: 0, upd: 0;
       c4cKU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cLH_srtd" {
     u4cLH_srtd:
         const S4cv3_srt+40;
         const 40;
         const 549755813889;
 },
 _c4cKT() //  [R1]
         { info_tbl: [(c4cKT,
                       label: block_c4cKT_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cKT: // global
           if (R1 & 7 == 1) goto c4cLh; else goto c4cLi;
       c4cLh: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4cLi: // global
           I64[Sp - 8] = block_c4cKZ_info;
           _s4ctO::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s4ctO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4cLD; else goto c4cL0;
       u4cLD: // global
           call _c4cKZ(R1) args: 0, res: 0, upd: 0;
       c4cL0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cLI_srtd" {
     u4cLI_srtd:
         const S4cv3_srt+40;
         const 40;
         const 549755813889;
 },
 _c4cKZ() //  [R1]
         { info_tbl: [(c4cKZ,
                       label: block_c4cKZ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cKZ: // global
           I64[Sp - 8] = block_c4cL4_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = P64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cLJ_srtd" {
     u4cLJ_srtd:
         const S4cv3_srt+40;
         const 40;
         const 549755813889;
 },
 _c4cL4() //  [R1]
         { info_tbl: [(c4cL4,
                       label: block_c4cL4_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cL4: // global
           _s4ctO::P64 = P64[Sp + 16];
           if (R1 == 1) goto c4cLw; else goto c4cLu;
       c4cLw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4cLz; else goto c4cLy;
       c4cLz: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4cLy: // global
           I64[Hp - 40] = sat_s4ctU_info;
           P64[Hp - 24] = _s4ctO::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4cLu: // global
           P64[Sp + 16] = _s4ctO::P64;
           Sp = Sp + 16;
           call _c4cKQ() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.936114191 UTC

[section ""data" . GHC.Natural.$fReadNatural_$creadsPrec_closure" {
     GHC.Natural.$fReadNatural_$creadsPrec_closure:
         const GHC.Natural.$fReadNatural_$creadsPrec_info;
         const 0;
 },
 g_s4ctW_entry() //  [R1]
         { info_tbl: [(c4cMv,
                       label: g_s4ctW_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cMv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4cMw; else goto c4cMx;
       c4cMw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cMx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.Read.$fReadInteger2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.$fReadInteger_$sreadNumber_entry(R4,
                                                          R3,
                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_s4ctZ_entry() //  [R1, R2]
         { info_tbl: [(c4cMF,
                       label: sat_s4ctZ_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cMF: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4cMG; else goto c4cMH;
       c4cMG: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4cMH: // global
           I64[Sp - 8] = block_c4cMD_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cMD() //  [R1]
         { info_tbl: [(c4cMD,
                       label: block_c4cMD_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cMD: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Natural.$fReadNatural_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Natural.$fReadNatural_$creadsPrec_entry() //  [R2]
         { info_tbl: [(c4cML,
                       label: GHC.Natural.$fReadNatural_$creadsPrec_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cML: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto c4cMP; else goto c4cMO;
       c4cMP: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = GHC.Natural.$fReadNatural_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4cMO: // global
           I64[Hp - 32] = g_s4ctW_info;
           P64[Hp - 16] = R2;
           I64[Hp - 8] = sat_s4ctZ_info;
           P64[Hp] = Hp - 32;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.946460513 UTC

[section ""data" . GHC.Natural.$fReadNatural4_closure" {
     GHC.Natural.$fReadNatural4_closure:
         const GHC.Natural.$fReadNatural4_info;
         const 0;
 },
 g_s4cu1_entry() //  [R1]
         { info_tbl: [(c4cNl,
                       label: g_s4cu1_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cNl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4cNm; else goto c4cNn;
       c4cNm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cNn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.Read.$fReadInteger2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.$fReadInteger_$sreadNumber_entry(R4,
                                                          R3,
                                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 w_s4cu2_entry() //  [R1, R2]
         { info_tbl: [(c4cNv,
                       label: w_s4cu2_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cNv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4cNw; else goto c4cNx;
       c4cNw: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4cNx: // global
           I64[Sp - 8] = block_c4cNt_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cNt() //  [R1]
         { info_tbl: [(c4cNt,
                       label: block_c4cNt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cNt: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Natural.$fReadNatural_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_s4cu8_entry() //  [R1, R2]
         { info_tbl: [(c4cNJ,
                       label: sat_s4cu8_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cNJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4cNK; else goto c4cNL;
       c4cNK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4cNL: // global
           I64[Sp - 8] = block_c4cNG_info;
           R3 = R2;
           R2 = P64[R1 + 7];
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cNG() //  [R1]
         { info_tbl: [(c4cNG,
                       label: block_c4cNG_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cNG: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4cNO; else goto c4cNN;
       c4cNO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4cNN: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.Natural.$fReadNatural4_entry() //  [R2]
         { info_tbl: [(c4cNP,
                       label: GHC.Natural.$fReadNatural4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cNP: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto c4cNT; else goto c4cNS;
       c4cNT: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.Natural.$fReadNatural4_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4cNS: // global
           I64[Hp - 48] = g_s4cu1_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = w_s4cu2_info;
           P64[Hp - 16] = Hp - 48;
           I64[Hp - 8] = sat_s4cu8_info;
           P64[Hp] = Hp - 23;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.959476549 UTC

[section ""data" . GHC.Natural.$fReadNatural3_closure" {
     GHC.Natural.$fReadNatural3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.96175434 UTC

[section ""data" . GHC.Natural.$fReadNatural2_closure" {
     GHC.Natural.$fReadNatural2_closure:
         const GHC.Natural.$fReadNatural2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.$fReadNatural2_entry() //  [R1]
         { info_tbl: [(c4cOA,
                       label: GHC.Natural.$fReadNatural2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cOA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4cOB; else goto c4cOC;
       c4cOB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cOC: // global
           (_c4cOx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4cOx::I64 == 0) goto c4cOz; else goto c4cOy;
       c4cOz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4cOy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4cOx::I64;
           R2 = GHC.Natural.$fReadNatural4_closure+1;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = GHC.Natural.$fReadNatural3_closure+1;
           P64[Sp - 24] = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           Sp = Sp - 40;
           call GHC.Read.list_entry(R2) args: 48, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.966237581 UTC

[section ""data" . GHC.Natural.$fReadNatural_$creadList_closure" {
     GHC.Natural.$fReadNatural_$creadList_closure:
         const GHC.Natural.$fReadNatural_$creadList_info;
         const 0;
 },
 GHC.Natural.$fReadNatural_$creadList_entry() //  [R2]
         { info_tbl: [(c4cOT,
                       label: GHC.Natural.$fReadNatural_$creadList_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cOT: // global
           R3 = R2;
           R2 = GHC.Natural.$fReadNatural2_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.969967535 UTC

[section ""data" . GHC.Natural.$fReadNatural1_closure" {
     GHC.Natural.$fReadNatural1_closure:
         const GHC.Natural.$fReadNatural1_info;
         const 0;
 },
 GHC.Natural.$fReadNatural1_entry() //  [R2, R3]
         { info_tbl: [(c4cP7,
                       label: GHC.Natural.$fReadNatural1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cP7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4cP8; else goto c4cP9;
       c4cP8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.$fReadNatural1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4cP9: // global
           I64[Sp - 8] = block_c4cP4_info;
           R3 = R3;
           R2 = GHC.Natural.$fReadNatural_$creadList_closure+1;
           Sp = Sp - 8;
           call Text.ParserCombinators.ReadP.$wreadS_to_P_entry(R3,
                                                                R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cP4() //  [R1]
         { info_tbl: [(c4cP4,
                       label: block_c4cP4_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cP4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto c4cPc; else goto c4cPb;
       c4cPc: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       c4cPb: // global
           I64[Hp - 8] = Text.ParserCombinators.ReadP.Look_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.975976956 UTC

[section ""data" . GHC.Natural.$fReadNatural_closure" {
     GHC.Natural.$fReadNatural_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.Natural.$fReadNatural_$creadsPrec_closure+1;
         const GHC.Natural.$fReadNatural_$creadList_closure+1;
         const GHC.Natural.$fReadNatural4_closure+1;
         const GHC.Natural.$fReadNatural1_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.978463896 UTC

[section ""data" . GHC.Natural.isValidNatural_closure" {
     GHC.Natural.isValidNatural_closure:
         const GHC.Natural.isValidNatural_info;
         const 0;
 },
 GHC.Natural.isValidNatural_entry() //  [R2]
         { info_tbl: [(c4cPv,
                       label: GHC.Natural.isValidNatural_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cPv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto c4cPw; else goto c4cPx;
       c4cPw: // global
           R2 = R2;
           R1 = GHC.Natural.isValidNatural_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       c4cPx: // global
           I64[Sp - 8] = block_c4cPt_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cPt() //  [R1]
         { info_tbl: [(c4cPt,
                       label: block_c4cPt_info
                       rep:StackRep [])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cPt: // global
           R1 = I64[(R1 << 3) + GHC.Types.Bool_closure_tbl];
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.984177048 UTC

[section ""data" . GHC.Natural.minusNaturalMaybe_closure" {
     GHC.Natural.minusNaturalMaybe_closure:
         const GHC.Natural.minusNaturalMaybe_info;
         const 0;
 },
 sat_s4cui_entry() //  [R1]
         { info_tbl: [(c4cQ0,
                       label: sat_s4cui_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cQ0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4cQ1; else goto c4cQ2;
       c4cQ1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cQ2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Natural.$fNumNatural_$c-_entry(R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Natural.minusNaturalMaybe_entry() //  [R2, R3]
         { info_tbl: [(c4cQ6,
                       label: GHC.Natural.minusNaturalMaybe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cQ6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto c4cQ7; else goto c4cQ8;
       c4cQ7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.minusNaturalMaybe_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       c4cQ8: // global
           I64[Sp - 24] = block_c4cPR_info;
           _s4cug::P64 = R3;
           R3 = R3;
           _s4cuf::P64 = R2;
           R2 = R2;
           P64[Sp - 16] = _s4cuf::P64;
           P64[Sp - 8] = _s4cug::P64;
           Sp = Sp - 24;
           call GHC.Integer.Type.geInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cPR() //  [R1]
         { info_tbl: [(c4cPR,
                       label: block_c4cPR_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cPR: // global
           if (R1 == 1) goto c4cQ5; else goto c4cQ4;
       c4cQ5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto c4cQe; else goto c4cQd;
       c4cQe: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       c4cQd: // global
           I64[Hp - 40] = sat_s4cui_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       c4cQ4: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.991979709 UTC

[section ""data" . GHC.Natural.$fIxNatural_closure" {
     GHC.Natural.$fIxNatural_closure:
         const GHC.Arr.C:Ix_con_info;
         const GHC.Natural.$fOrdNatural_closure+1;
         const GHC.Arr.$fIxInteger_$crange_closure+1;
         const GHC.Arr.$fIxInteger_$cindex_closure+2;
         const GHC.Arr.$fIxInteger_$cunsafeIndex_closure+2;
         const GHC.Arr.$fIxInteger_$cinRange_closure+2;
         const GHC.Arr.$fIxInteger_$crangeSize_closure+1;
         const GHC.Arr.$fIxInteger_$cunsafeRangeSize_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.994375494 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cunsafeShiftL_closure" {
     GHC.Natural.$fBitsNatural_$cunsafeShiftL_closure:
         const GHC.Natural.$fBitsNatural_$cunsafeShiftL_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cunsafeShiftL_entry() //  [R2, R3]
         { info_tbl: [(c4cQG,
                       label: GHC.Natural.$fBitsNatural_$cunsafeShiftL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cQG: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshift_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:05.997960862 UTC

[section ""data" . GHC.Natural.$fBitsNatural_$cunsafeShiftR_closure" {
     GHC.Natural.$fBitsNatural_$cunsafeShiftR_closure:
         const GHC.Natural.$fBitsNatural_$cunsafeShiftR_info;
         const 0;
 },
 GHC.Natural.$fBitsNatural_$cunsafeShiftR_entry() //  [R2, R3]
         { info_tbl: [(c4cQR,
                       label: GHC.Natural.$fBitsNatural_$cunsafeShiftR_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cQR: // global
           R3 = R3;
           R2 = R2;
           call Data.Bits.$fBitsInteger_$cshiftR_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:06.001086403 UTC

[section ""data" . GHC.Natural.$fBitsNatural_closure" {
     GHC.Natural.$fBitsNatural_closure:
         const Data.Bits.C:Bits_con_info;
         const GHC.Natural.$fEqNatural_closure+1;
         const GHC.Natural.$fBitsNatural_$c.&._closure+2;
         const GHC.Natural.$fBitsNatural_$c.|._closure+2;
         const GHC.Natural.$fBitsNatural_$cxor_closure+2;
         const GHC.Natural.$fBitsNatural_$ccomplement_closure+1;
         const GHC.Natural.$fBitsNatural_$cshift_closure+2;
         const GHC.Natural.$fBitsNatural_$crotate_closure+2;
         const GHC.Natural.$fBitsNatural1_closure;
         const Data.Bits.$fBitsInteger_$cbit_closure+1;
         const GHC.Natural.$fBitsNatural_$csetBit_closure+2;
         const GHC.Natural.$fBitsNatural_$cclearBit_closure+2;
         const GHC.Natural.$fBitsNatural_$ccomplementBit_closure+2;
         const GHC.Natural.$fBitsNatural_$ctestBit_closure+2;
         const GHC.Natural.$fBitsNatural_$cbitSizeMaybe_closure+1;
         const GHC.Natural.$fBitsNatural_$cbitSize_closure;
         const GHC.Natural.$fBitsNatural_$cisSigned_closure+1;
         const GHC.Natural.$fBitsNatural_$cshiftL_closure+2;
         const GHC.Natural.$fBitsNatural_$cunsafeShiftL_closure+2;
         const GHC.Natural.$fBitsNatural_$cshiftR_closure+2;
         const GHC.Natural.$fBitsNatural_$cunsafeShiftR_closure+2;
         const GHC.Natural.$fBitsNatural_$crotateL_closure+2;
         const GHC.Natural.$fBitsNatural_$crotateR_closure+2;
         const GHC.Natural.$fBitsNatural_$cpopCount_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:06.003292857 UTC

[section ""data" . sat_s4cuj_closure" {
     sat_s4cuj_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:06.005857773 UTC

[section ""data" . sat_s4cuk_closure" {
     sat_s4cuk_closure:
         const :_con_info;
         const sat_s4cuj_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2018-03-16 15:59:06.007738871 UTC

[section ""data" . GHC.Natural.powModNatural1_closure" {
     GHC.Natural.powModNatural1_closure:
         const GHC.Natural.powModNatural1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Natural.powModNatural1_entry() //  [R1]
         { info_tbl: [(c4cR7,
                       label: GHC.Natural.powModNatural1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cR7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto c4cR8; else goto c4cR9;
       c4cR8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       c4cR9: // global
           (_c4cR4::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_c4cR4::I64 == 0) goto c4cR6; else goto c4cR5;
       c4cR6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       c4cR5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _c4cR4::I64;
           R3 = sat_s4cuk_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:06.013465248 UTC

[section ""data" . GHC.Natural.powModNatural_closure" {
     GHC.Natural.powModNatural_closure:
         const GHC.Natural.powModNatural_info;
         const 0;
 },
 section ""relreadonly" . u4cTP_srtd" {
     u4cTP_srtd:
         const S4cv3_srt+80;
         const 53;
         const 8743316464075777;
 },
 GHC.Natural.powModNatural_entry() //  [R2, R3, R4]
         { info_tbl: [(c4cRs,
                       label: GHC.Natural.powModNatural_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cRs: // global
           if ((Sp + -40) < SpLim) (likely: False) goto c4cRt; else goto c4cRu;
       c4cRt: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Natural.powModNatural_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       c4cRu: // global
           I64[Sp - 32] = block_c4cRn_info;
           _s4cum::P64 = R3;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           _s4cul::P64 = R2;
           R2 = R4;
           P64[Sp - 24] = _s4cul::P64;
           P64[Sp - 16] = _s4cum::P64;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cTQ_srtd" {
     u4cTQ_srtd:
         const S4cv3_srt+80;
         const 53;
         const 7617416557233153;
 },
 _c4cRn() //  [R1]
         { info_tbl: [(c4cRn,
                       label: block_c4cRn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cRn: // global
           if (R1 == 1) goto c4cRr; else goto c4cRq;
       c4cRr: // global
           R1 = GHC.Real.divZeroError_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       c4cRq: // global
           I64[Sp] = block_c4cRx_info;
           R3 = GHC.Natural.powModNatural1_closure;
           R2 = P64[Sp + 24];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cTR_srtd" {
     u4cTR_srtd:
         const S4cv3_srt+160;
         const 43;
         const 7438883356673;
 },
 _c4cRx() //  [R1]
         { info_tbl: [(c4cRx,
                       label: block_c4cRx_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cRx: // global
           if (R1 == 1) goto u4cTA; else goto c4cRF;
       u4cTA: // global
           Sp = Sp + 32;
           call _c4cTw() args: 0, res: 0, upd: 0;
       c4cRF: // global
           I64[Sp] = block_c4cRC_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cTS_srtd" {
     u4cTS_srtd:
         const S4cv3_srt+160;
         const 43;
         const 7438883356673;
 },
 _c4cRC() //  [R1]
         { info_tbl: [(c4cRC,
                       label: block_c4cRC_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cRC: // global
           if (R1 == 1) goto u4cTB; else goto c4cRM;
       u4cTB: // global
           Sp = Sp + 32;
           call _c4cTs() args: 0, res: 0, upd: 0;
       c4cRM: // global
           I64[Sp] = block_c4cRJ_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cTT_srtd" {
     u4cTT_srtd:
         const S4cv3_srt+160;
         const 43;
         const 7438883356673;
 },
 _c4cRJ() //  [R1]
         { info_tbl: [(c4cRJ,
                       label: block_c4cRJ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cRJ: // global
           if (R1 == 1) goto u4cTC; else goto c4cRT;
       u4cTC: // global
           Sp = Sp + 32;
           call _c4cTw() args: 0, res: 0, upd: 0;
       c4cRT: // global
           I64[Sp] = block_c4cRQ_info;
           R3 = GHC.Natural.powModNatural1_closure;
           R2 = P64[Sp + 8];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 _c4cTw() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cTw: // global
           R1 = GHC.Natural.$fBitsNatural1_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . u4cTU_srtd" {
     u4cTU_srtd:
         const S4cv3_srt+160;
         const 43;
         const 7438883356673;
 },
 _c4cRQ() //  [R1]
         { info_tbl: [(c4cRQ,
                       label: block_c4cRQ_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cRQ: // global
           if (R1 == 1) goto u4cTD; else goto c4cTg;
       u4cTD: // global
           Sp = Sp + 32;
           call _c4cTs() args: 0, res: 0, upd: 0;
       c4cTg: // global
           P64[Sp] = GHC.Natural.powModNatural1_closure;
           _s4cuu::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s4cuu::P64;
           call _c4cS1() args: 0, res: 0, upd: 0;
     }
 },
 _c4cTs() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cTs: // global
           R1 = GHC.Natural.powModNatural1_closure;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _c4cS1() //  []
         { info_tbl: []
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cS1: // global
           I64[Sp - 8] = block_c4cS3_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto u4cTM; else goto c4cS4;
       u4cTM: // global
           call _c4cS3(R1) args: 0, res: 0, upd: 0;
       c4cS4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cTV_srtd" {
     u4cTV_srtd:
         const S4cv3_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cS3() //  [R1]
         { info_tbl: [(c4cS3,
                       label: block_c4cS3_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cS3: // global
           I64[Sp] = block_c4cS8_info;
           R3 = GHC.Natural.$seven_n_closure;
           R2 = P64[Sp + 16];
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.remInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cTW_srtd" {
     u4cTW_srtd:
         const S4cv3_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cS8() //  [R1]
         { info_tbl: [(c4cS8,
                       label: block_c4cS8_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cS8: // global
           I64[Sp] = block_c4cSe_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = R1;
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cTX_srtd" {
     u4cTX_srtd:
         const S4cv3_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cSe() //  [R1]
         { info_tbl: [(c4cSe,
                       label: block_c4cSe_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cSe: // global
           if (R1 == 1) goto c4cSP; else goto c4cSC;
       c4cSP: // global
           I64[Sp] = block_c4cSN_info;
           R3 = GHC.Natural.$fBitsNatural1_closure;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.eqInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       c4cSC: // global
           _s4cuw::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_c4cSj_info;
           R3 = P64[Sp + 24];
           R2 = _s4cuw::P64;
           Sp = Sp + 8;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cTY_srtd" {
     u4cTY_srtd:
         const S4cv3_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cSN() //  [R1]
         { info_tbl: [(c4cSN,
                       label: block_c4cSN_info
                       rep:StackRep [False, False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cSN: // global
           if (R1 == 1) goto c4cTe; else goto c4cT4;
       c4cTe: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       c4cT4: // global
           I64[Sp] = block_c4cST_info;
           R3 = 1;
           R2 = P64[Sp + 16];
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cTZ_srtd" {
     u4cTZ_srtd:
         const S4cv3_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cST() //  [R1]
         { info_tbl: [(c4cST,
                       label: block_c4cST_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cST: // global
           I64[Sp] = block_c4cSX_info;
           _s4cux::P64 = P64[Sp + 24];
           R3 = _s4cux::P64;
           R2 = _s4cux::P64;
           P64[Sp + 24] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cU0_srtd" {
     u4cU0_srtd:
         const S4cv3_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cSX() //  [R1]
         { info_tbl: [(c4cSX,
                       label: block_c4cSX_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cSX: // global
           I64[Sp] = block_c4cT1_info;
           R3 = P64[Sp + 32];
           R2 = R1;
           call GHC.Integer.Type.modInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cU1_srtd" {
     u4cU1_srtd:
         const S4cv3_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cT1() //  [R1]
         { info_tbl: [(c4cT1,
                       label: block_c4cT1_info
                       rep:StackRep [False, True, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cT1: // global
           _s4cuv::P64 = P64[Sp + 24];
           P64[Sp + 24] = R1;
           P64[Sp + 16] = _s4cuv::P64;
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _c4cS1() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . u4cU2_srtd" {
     u4cU2_srtd:
         const S4cv3_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cSj() //  [R1]
         { info_tbl: [(c4cSj,
                       label: block_c4cSj_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cSj: // global
           I64[Sp] = block_c4cSn_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Integer.Type.modInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cU3_srtd" {
     u4cU3_srtd:
         const S4cv3_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cSn() //  [R1]
         { info_tbl: [(c4cSn,
                       label: block_c4cSn_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cSn: // global
           I64[Sp] = block_c4cSr_info;
           R3 = 1;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call GHC.Integer.Type.shiftRInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cU4_srtd" {
     u4cU4_srtd:
         const S4cv3_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cSr() //  [R1]
         { info_tbl: [(c4cSr,
                       label: block_c4cSr_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cSr: // global
           I64[Sp] = block_c4cSv_info;
           _s4cux::P64 = P64[Sp + 16];
           R3 = _s4cux::P64;
           R2 = _s4cux::P64;
           P64[Sp + 16] = R1;
           call GHC.Integer.Type.timesInteger_entry(R3,
                                                    R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cU5_srtd" {
     u4cU5_srtd:
         const S4cv3_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cSv() //  [R1]
         { info_tbl: [(c4cSv,
                       label: block_c4cSv_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cSv: // global
           I64[Sp] = block_c4cSz_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           call GHC.Integer.Type.modInteger_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . u4cU6_srtd" {
     u4cU6_srtd:
         const S4cv3_srt+160;
         const 42;
         const 3040836845569;
 },
 _c4cSz() //  [R1]
         { info_tbl: [(c4cSz,
                       label: block_c4cSz_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 0 updfr_space: Nothing
         }
     {offset
       c4cSz: // global
           _s4cuv::P64 = P64[Sp + 16];
           P64[Sp + 16] = R1;
           _s4cuw::P64 = P64[Sp + 8];
           P64[Sp + 8] = _s4cuv::P64;
           P64[Sp] = _s4cuw::P64;
           call _c4cS1() args: 0, res: 0, upd: 0;
     }
 }]


==================== Output Cmm ====================
2018-03-16 15:59:06.060781919 UTC

[section ""relreadonly" . S4cv3_srt" {
     S4cv3_srt:
         const GHC.Real.$fFractionalRatio_$s$cfromInteger_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.Natural.$fEnumNatural_$ctoEnum_closure;
         const lvl1_r4bvD_closure;
         const GHC.Enum.$fEnumInteger_$cpred_closure;
         const GHC.Natural.$fBitsNatural1_closure;
         const GHC.Natural.$fEnumNatural_$cpred_closure;
         const lvl3_r4bvF_closure;
         const GHC.Enum.$fEnumInteger_$csucc_closure;
         const GHC.Integer.Type.divModInteger_closure;
         const GHC.Real.divZeroError_closure;
         const GHC.Natural.$fIntegralNatural_$cdivMod_closure;
         const GHC.Natural.$fIntegralNatural_$cquotRem_closure;
         const GHC.Exception.underflowException_closure;
         const GHC.Integer.Type.minusInteger_closure;
         const GHC.Natural.underflowError_closure;
         const GHC.Natural.$fNumNatural_$cnegate_closure;
         const GHC.Natural.naturalFromInteger_closure;
         const GHC.Natural.$fNumNatural_$c-_closure;
         const GHC.Integer.Type.plusInteger_closure;
         const GHC.Integer.Type.timesInteger_closure;
         const GHC.Real.$fIntegralInteger_$cquot_closure;
         const GHC.Real.$fIntegralInteger_$crem_closure;
         const GHC.Real.$fIntegralInteger_$cdiv_closure;
         const GHC.Real.$fIntegralInteger_$cmod_closure;
         const GHC.Enum.enumDeltaToInteger_closure;
         const GHC.Enum.$fEnumInteger_$cenumFromThen_closure;
         const GHC.Natural.$fEnumNatural_$cenumFromThen_closure;
         const sat_s4ctl_closure;
         const GHC.Show.$w$cshowsPrec4_closure;
         const GHC.Natural.$fShowNatural_$cshow_closure;
         const GHC.Natural.$fShowNatural1_closure;
         const Data.Bits.$fBitsInteger_$cpopCount_closure;
         const Data.Bits.$fBitsInteger_$crotateR_closure;
         const Data.Bits.$fBitsInteger_$cshift_closure;
         const Data.Bits.$fBitsInteger_$cshiftR_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const Data.Bits.$fBitsInteger_$ccomplementBit_closure;
         const Data.Bits.$fBitsInteger_$cclearBit_closure;
         const Data.Bits.$fBitsInteger_$csetBit_closure;
         const lvl6_r4bvJ_closure;
         const sat_s4ctG_closure;
         const GHC.Natural.naturalToWordMaybe_closure;
         const GHC.Natural.naturalToWordMaybe1_closure;
         const GHC.Natural.$fReadNatural_go_closure;
         const GHC.Read.$fReadInteger2_closure;
         const GHC.Read.$fReadInteger_$sreadNumber_closure;
         const GHC.Natural.$fReadNatural_$creadsPrec_closure;
         const GHC.Natural.$fReadNatural4_closure;
         const GHC.Read.list_closure;
         const GHC.Natural.$fReadNatural2_closure;
         const GHC.Natural.$fReadNatural1_closure;
         const GHC.Natural.$fReadNatural_$creadList_closure;
         const GHC.Natural.isValidNatural_closure;
         const GHC.Natural.$fBitsNatural1_closure;
         const GHC.Natural.$fNumNatural_$c-_closure;
         const GHC.Natural.minusNaturalMaybe_closure;
         const sat_s4cuk_closure;
         const GHC.Integer.Type.modInteger_closure;
         const GHC.Integer.Type.shiftRInteger_closure;
         const GHC.Natural.powModNatural_closure;
         const GHC.Natural.$seven_n_closure;
         const GHC.Natural.powModNatural1_closure;
 }]

