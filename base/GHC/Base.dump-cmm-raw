
==================== Raw Cmm ====================
2018-03-16 15:54:44.160609639 UTC

[]


==================== Raw Cmm ====================
2018-03-16 15:54:44.162507496 UTC

[section ""data" . GHC.Base.$p1Monad_closure" {
     GHC.Base.$p1Monad_closure:
         const GHC.Base.$p1Monad_info;
 },
 GHC.Base.$p1Monad_entry() //  [R2]
         { []
         }
     {offset
       cd0u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd0v; else goto cd0w;
       cd0v: // global
           R2 = R2;
           R1 = GHC.Base.$p1Monad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd0w: // global
           I64[Sp - 8] = block_cd0r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud0A; else goto cd0s;
       ud0A: // global
           call _cd0r(R1) args: 0, res: 0, upd: 0;
       cd0s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$p1Monad_info" {
     GHC.Base.$p1Monad_info:
         const GHC.Base.$p1Monad_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd0r() //  [R1]
         { []
         }
     {offset
       cd0r: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd0r_info" {
     block_cd0r_info:
         const _cd0r;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.168014248 UTC

[section ""data" . GHC.Base.>>=_closure" {
     GHC.Base.>>=_closure:
         const GHC.Base.>>=_info;
 },
 GHC.Base.>>=_entry() //  [R2]
         { []
         }
     {offset
       cd0T: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd0U; else goto cd0V;
       cd0U: // global
           R2 = R2;
           R1 = GHC.Base.>>=_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd0V: // global
           I64[Sp - 8] = block_cd0Q_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud0Z; else goto cd0R;
       ud0Z: // global
           call _cd0Q(R1) args: 0, res: 0, upd: 0;
       cd0R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.>>=_info" {
     GHC.Base.>>=_info:
         const GHC.Base.>>=_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd0Q() //  [R1]
         { []
         }
     {offset
       cd0Q: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd0Q_info" {
     block_cd0Q_info:
         const _cd0Q;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.173992975 UTC

[section ""data" . GHC.Base.>>_closure" {
     GHC.Base.>>_closure:
         const GHC.Base.>>_info;
 },
 GHC.Base.>>_entry() //  [R2]
         { []
         }
     {offset
       cd1g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd1h; else goto cd1i;
       cd1h: // global
           R2 = R2;
           R1 = GHC.Base.>>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd1i: // global
           I64[Sp - 8] = block_cd1d_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud1m; else goto cd1e;
       ud1m: // global
           call _cd1d(R1) args: 0, res: 0, upd: 0;
       cd1e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.>>_info" {
     GHC.Base.>>_info:
         const GHC.Base.>>_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd1d() //  [R1]
         { []
         }
     {offset
       cd1d: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd1d_info" {
     block_cd1d_info:
         const _cd1d;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.179289559 UTC

[section ""data" . GHC.Base.return_closure" {
     GHC.Base.return_closure:
         const GHC.Base.return_info;
 },
 GHC.Base.return_entry() //  [R2]
         { []
         }
     {offset
       cd1D: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd1E; else goto cd1F;
       cd1E: // global
           R2 = R2;
           R1 = GHC.Base.return_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd1F: // global
           I64[Sp - 8] = block_cd1A_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud1J; else goto cd1B;
       ud1J: // global
           call _cd1A(R1) args: 0, res: 0, upd: 0;
       cd1B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.return_info" {
     GHC.Base.return_info:
         const GHC.Base.return_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd1A() //  [R1]
         { []
         }
     {offset
       cd1A: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd1A_info" {
     block_cd1A_info:
         const _cd1A;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.185315394 UTC

[section ""data" . GHC.Base.fail_closure" {
     GHC.Base.fail_closure:
         const GHC.Base.fail_info;
 },
 GHC.Base.fail_entry() //  [R2]
         { []
         }
     {offset
       cd20: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd21; else goto cd22;
       cd21: // global
           R2 = R2;
           R1 = GHC.Base.fail_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd22: // global
           I64[Sp - 8] = block_cd1X_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud26; else goto cd1Y;
       ud26: // global
           call _cd1X(R1) args: 0, res: 0, upd: 0;
       cd1Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.fail_info" {
     GHC.Base.fail_info:
         const GHC.Base.fail_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd1X() //  [R1]
         { []
         }
     {offset
       cd1X: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd1X_info" {
     block_cd1X_info:
         const _cd1X;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.190625582 UTC

[section ""data" . GHC.Base.fmap_closure" {
     GHC.Base.fmap_closure:
         const GHC.Base.fmap_info;
 },
 GHC.Base.fmap_entry() //  [R2]
         { []
         }
     {offset
       cd2n: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd2o; else goto cd2p;
       cd2o: // global
           R2 = R2;
           R1 = GHC.Base.fmap_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd2p: // global
           I64[Sp - 8] = block_cd2k_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud2t; else goto cd2l;
       ud2t: // global
           call _cd2k(R1) args: 0, res: 0, upd: 0;
       cd2l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.fmap_info" {
     GHC.Base.fmap_info:
         const GHC.Base.fmap_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd2k() //  [R1]
         { []
         }
     {offset
       cd2k: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd2k_info" {
     block_cd2k_info:
         const _cd2k;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.195860899 UTC

[section ""data" . GHC.Base.<$_closure" {
     GHC.Base.<$_closure:
         const GHC.Base.<$_info;
 },
 GHC.Base.<$_entry() //  [R2]
         { []
         }
     {offset
       cd2K: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd2L; else goto cd2M;
       cd2L: // global
           R2 = R2;
           R1 = GHC.Base.<$_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd2M: // global
           I64[Sp - 8] = block_cd2H_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud2Q; else goto cd2I;
       ud2Q: // global
           call _cd2H(R1) args: 0, res: 0, upd: 0;
       cd2I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.<$_info" {
     GHC.Base.<$_info:
         const GHC.Base.<$_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd2H() //  [R1]
         { []
         }
     {offset
       cd2H: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd2H_info" {
     block_cd2H_info:
         const _cd2H;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.201493388 UTC

[section ""data" . GHC.Base.$p1Applicative_closure" {
     GHC.Base.$p1Applicative_closure:
         const GHC.Base.$p1Applicative_info;
 },
 GHC.Base.$p1Applicative_entry() //  [R2]
         { []
         }
     {offset
       cd37: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd38; else goto cd39;
       cd38: // global
           R2 = R2;
           R1 = GHC.Base.$p1Applicative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd39: // global
           I64[Sp - 8] = block_cd34_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud3d; else goto cd35;
       ud3d: // global
           call _cd34(R1) args: 0, res: 0, upd: 0;
       cd35: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$p1Applicative_info" {
     GHC.Base.$p1Applicative_info:
         const GHC.Base.$p1Applicative_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd34() //  [R1]
         { []
         }
     {offset
       cd34: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd34_info" {
     block_cd34_info:
         const _cd34;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.206679528 UTC

[section ""data" . GHC.Base.pure_closure" {
     GHC.Base.pure_closure:
         const GHC.Base.pure_info;
 },
 GHC.Base.pure_entry() //  [R2]
         { []
         }
     {offset
       cd3w: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd3x; else goto cd3y;
       cd3x: // global
           R2 = R2;
           R1 = GHC.Base.pure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd3y: // global
           I64[Sp - 8] = block_cd3t_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud3C; else goto cd3u;
       ud3C: // global
           call _cd3t(R1) args: 0, res: 0, upd: 0;
       cd3u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.pure_info" {
     GHC.Base.pure_info:
         const GHC.Base.pure_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd3t() //  [R1]
         { []
         }
     {offset
       cd3t: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd3t_info" {
     block_cd3t_info:
         const _cd3t;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.211962743 UTC

[section ""data" . GHC.Base.<*>_closure" {
     GHC.Base.<*>_closure:
         const GHC.Base.<*>_info;
 },
 GHC.Base.<*>_entry() //  [R2]
         { []
         }
     {offset
       cd3T: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd3U; else goto cd3V;
       cd3U: // global
           R2 = R2;
           R1 = GHC.Base.<*>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd3V: // global
           I64[Sp - 8] = block_cd3Q_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud3Z; else goto cd3R;
       ud3Z: // global
           call _cd3Q(R1) args: 0, res: 0, upd: 0;
       cd3R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.<*>_info" {
     GHC.Base.<*>_info:
         const GHC.Base.<*>_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd3Q() //  [R1]
         { []
         }
     {offset
       cd3Q: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd3Q_info" {
     block_cd3Q_info:
         const _cd3Q;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.217952825 UTC

[section ""data" . GHC.Base.liftA2_closure" {
     GHC.Base.liftA2_closure:
         const GHC.Base.liftA2_info;
 },
 GHC.Base.liftA2_entry() //  [R2]
         { []
         }
     {offset
       cd4g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd4h; else goto cd4i;
       cd4h: // global
           R2 = R2;
           R1 = GHC.Base.liftA2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd4i: // global
           I64[Sp - 8] = block_cd4d_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud4m; else goto cd4e;
       ud4m: // global
           call _cd4d(R1) args: 0, res: 0, upd: 0;
       cd4e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftA2_info" {
     GHC.Base.liftA2_info:
         const GHC.Base.liftA2_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd4d() //  [R1]
         { []
         }
     {offset
       cd4d: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd4d_info" {
     block_cd4d_info:
         const _cd4d;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.223093828 UTC

[section ""data" . GHC.Base.*>_closure" {
     GHC.Base.*>_closure:
         const GHC.Base.*>_info;
 },
 GHC.Base.*>_entry() //  [R2]
         { []
         }
     {offset
       cd4D: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd4E; else goto cd4F;
       cd4E: // global
           R2 = R2;
           R1 = GHC.Base.*>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd4F: // global
           I64[Sp - 8] = block_cd4A_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud4J; else goto cd4B;
       ud4J: // global
           call _cd4A(R1) args: 0, res: 0, upd: 0;
       cd4B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.*>_info" {
     GHC.Base.*>_info:
         const GHC.Base.*>_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd4A() //  [R1]
         { []
         }
     {offset
       cd4A: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd4A_info" {
     block_cd4A_info:
         const _cd4A;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.228795248 UTC

[section ""data" . GHC.Base.<*_closure" {
     GHC.Base.<*_closure:
         const GHC.Base.<*_info;
 },
 GHC.Base.<*_entry() //  [R2]
         { []
         }
     {offset
       cd50: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd51; else goto cd52;
       cd51: // global
           R2 = R2;
           R1 = GHC.Base.<*_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd52: // global
           I64[Sp - 8] = block_cd4X_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud56; else goto cd4Y;
       ud56: // global
           call _cd4X(R1) args: 0, res: 0, upd: 0;
       cd4Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.<*_info" {
     GHC.Base.<*_info:
         const GHC.Base.<*_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd4X() //  [R1]
         { []
         }
     {offset
       cd4X: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd4X_info" {
     block_cd4X_info:
         const _cd4X;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.234774669 UTC

[section ""data" . GHC.Base.<>_closure" {
     GHC.Base.<>_closure:
         const GHC.Base.<>_info;
 },
 GHC.Base.<>_entry() //  [R2]
         { []
         }
     {offset
       cd5n: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd5o; else goto cd5p;
       cd5o: // global
           R2 = R2;
           R1 = GHC.Base.<>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd5p: // global
           I64[Sp - 8] = block_cd5k_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud5t; else goto cd5l;
       ud5t: // global
           call _cd5k(R1) args: 0, res: 0, upd: 0;
       cd5l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.<>_info" {
     GHC.Base.<>_info:
         const GHC.Base.<>_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd5k() //  [R1]
         { []
         }
     {offset
       cd5k: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd5k_info" {
     block_cd5k_info:
         const _cd5k;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.240874987 UTC

[section ""data" . GHC.Base.sconcat_closure" {
     GHC.Base.sconcat_closure:
         const GHC.Base.sconcat_info;
 },
 GHC.Base.sconcat_entry() //  [R2]
         { []
         }
     {offset
       cd5K: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd5L; else goto cd5M;
       cd5L: // global
           R2 = R2;
           R1 = GHC.Base.sconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd5M: // global
           I64[Sp - 8] = block_cd5H_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud5Q; else goto cd5I;
       ud5Q: // global
           call _cd5H(R1) args: 0, res: 0, upd: 0;
       cd5I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.sconcat_info" {
     GHC.Base.sconcat_info:
         const GHC.Base.sconcat_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd5H() //  [R1]
         { []
         }
     {offset
       cd5H: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd5H_info" {
     block_cd5H_info:
         const _cd5H;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.246503839 UTC

[section ""data" . GHC.Base.stimes_closure" {
     GHC.Base.stimes_closure:
         const GHC.Base.stimes_info;
 },
 GHC.Base.stimes_entry() //  [R2]
         { []
         }
     {offset
       cd67: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd68; else goto cd69;
       cd68: // global
           R2 = R2;
           R1 = GHC.Base.stimes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd69: // global
           I64[Sp - 8] = block_cd64_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud6d; else goto cd65;
       ud6d: // global
           call _cd64(R1) args: 0, res: 0, upd: 0;
       cd65: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.stimes_info" {
     GHC.Base.stimes_info:
         const GHC.Base.stimes_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd64() //  [R1]
         { []
         }
     {offset
       cd64: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd64_info" {
     block_cd64_info:
         const _cd64;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.251656421 UTC

[section ""data" . GHC.Base.$p1Monoid_closure" {
     GHC.Base.$p1Monoid_closure:
         const GHC.Base.$p1Monoid_info;
 },
 GHC.Base.$p1Monoid_entry() //  [R2]
         { []
         }
     {offset
       cd6u: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd6v; else goto cd6w;
       cd6v: // global
           R2 = R2;
           R1 = GHC.Base.$p1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd6w: // global
           I64[Sp - 8] = block_cd6r_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud6A; else goto cd6s;
       ud6A: // global
           call _cd6r(R1) args: 0, res: 0, upd: 0;
       cd6s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$p1Monoid_info" {
     GHC.Base.$p1Monoid_info:
         const GHC.Base.$p1Monoid_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd6r() //  [R1]
         { []
         }
     {offset
       cd6r: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd6r_info" {
     block_cd6r_info:
         const _cd6r;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.257010393 UTC

[section ""data" . GHC.Base.mempty_closure" {
     GHC.Base.mempty_closure:
         const GHC.Base.mempty_info;
 },
 GHC.Base.mempty_entry() //  [R2]
         { []
         }
     {offset
       cd6T: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd6U; else goto cd6V;
       cd6U: // global
           R2 = R2;
           R1 = GHC.Base.mempty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd6V: // global
           I64[Sp - 8] = block_cd6Q_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud6Z; else goto cd6R;
       ud6Z: // global
           call _cd6Q(R1) args: 0, res: 0, upd: 0;
       cd6R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.mempty_info" {
     GHC.Base.mempty_info:
         const GHC.Base.mempty_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd6Q() //  [R1]
         { []
         }
     {offset
       cd6Q: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd6Q_info" {
     block_cd6Q_info:
         const _cd6Q;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.262603149 UTC

[section ""data" . GHC.Base.mappend_closure" {
     GHC.Base.mappend_closure:
         const GHC.Base.mappend_info;
 },
 GHC.Base.mappend_entry() //  [R2]
         { []
         }
     {offset
       cd7g: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd7h; else goto cd7i;
       cd7h: // global
           R2 = R2;
           R1 = GHC.Base.mappend_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd7i: // global
           I64[Sp - 8] = block_cd7d_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud7m; else goto cd7e;
       ud7m: // global
           call _cd7d(R1) args: 0, res: 0, upd: 0;
       cd7e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.mappend_info" {
     GHC.Base.mappend_info:
         const GHC.Base.mappend_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd7d() //  [R1]
         { []
         }
     {offset
       cd7d: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd7d_info" {
     block_cd7d_info:
         const _cd7d;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.267855989 UTC

[section ""data" . GHC.Base.mconcat_closure" {
     GHC.Base.mconcat_closure:
         const GHC.Base.mconcat_info;
 },
 GHC.Base.mconcat_entry() //  [R2]
         { []
         }
     {offset
       cd7D: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd7E; else goto cd7F;
       cd7E: // global
           R2 = R2;
           R1 = GHC.Base.mconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd7F: // global
           I64[Sp - 8] = block_cd7A_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud7J; else goto cd7B;
       ud7J: // global
           call _cd7A(R1) args: 0, res: 0, upd: 0;
       cd7B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.mconcat_info" {
     GHC.Base.mconcat_info:
         const GHC.Base.mconcat_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd7A() //  [R1]
         { []
         }
     {offset
       cd7A: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd7A_info" {
     block_cd7A_info:
         const _cd7A;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.273515828 UTC

[section ""data" . GHC.Base.$p1MonadPlus_closure" {
     GHC.Base.$p1MonadPlus_closure:
         const GHC.Base.$p1MonadPlus_info;
 },
 GHC.Base.$p1MonadPlus_entry() //  [R2]
         { []
         }
     {offset
       cd80: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd81; else goto cd82;
       cd81: // global
           R2 = R2;
           R1 = GHC.Base.$p1MonadPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd82: // global
           I64[Sp - 8] = block_cd7X_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud86; else goto cd7Y;
       ud86: // global
           call _cd7X(R1) args: 0, res: 0, upd: 0;
       cd7Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$p1MonadPlus_info" {
     GHC.Base.$p1MonadPlus_info:
         const GHC.Base.$p1MonadPlus_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd7X() //  [R1]
         { []
         }
     {offset
       cd7X: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd7X_info" {
     block_cd7X_info:
         const _cd7X;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.278798281 UTC

[section ""data" . GHC.Base.$p2MonadPlus_closure" {
     GHC.Base.$p2MonadPlus_closure:
         const GHC.Base.$p2MonadPlus_info;
 },
 GHC.Base.$p2MonadPlus_entry() //  [R2]
         { []
         }
     {offset
       cd8p: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd8q; else goto cd8r;
       cd8q: // global
           R2 = R2;
           R1 = GHC.Base.$p2MonadPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd8r: // global
           I64[Sp - 8] = block_cd8m_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud8v; else goto cd8n;
       ud8v: // global
           call _cd8m(R1) args: 0, res: 0, upd: 0;
       cd8n: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$p2MonadPlus_info" {
     GHC.Base.$p2MonadPlus_info:
         const GHC.Base.$p2MonadPlus_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd8m() //  [R1]
         { []
         }
     {offset
       cd8m: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd8m_info" {
     block_cd8m_info:
         const _cd8m;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.284477134 UTC

[section ""data" . GHC.Base.mzero_closure" {
     GHC.Base.mzero_closure:
         const GHC.Base.mzero_info;
 },
 GHC.Base.mzero_entry() //  [R2]
         { []
         }
     {offset
       cd8O: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd8P; else goto cd8Q;
       cd8P: // global
           R2 = R2;
           R1 = GHC.Base.mzero_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd8Q: // global
           I64[Sp - 8] = block_cd8L_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud8U; else goto cd8M;
       ud8U: // global
           call _cd8L(R1) args: 0, res: 0, upd: 0;
       cd8M: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.mzero_info" {
     GHC.Base.mzero_info:
         const GHC.Base.mzero_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd8L() //  [R1]
         { []
         }
     {offset
       cd8L: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd8L_info" {
     block_cd8L_info:
         const _cd8L;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.290152638 UTC

[section ""data" . GHC.Base.mplus_closure" {
     GHC.Base.mplus_closure:
         const GHC.Base.mplus_info;
 },
 GHC.Base.mplus_entry() //  [R2]
         { []
         }
     {offset
       cd9b: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd9c; else goto cd9d;
       cd9c: // global
           R2 = R2;
           R1 = GHC.Base.mplus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd9d: // global
           I64[Sp - 8] = block_cd98_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud9h; else goto cd99;
       ud9h: // global
           call _cd98(R1) args: 0, res: 0, upd: 0;
       cd99: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.mplus_info" {
     GHC.Base.mplus_info:
         const GHC.Base.mplus_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd98() //  [R1]
         { []
         }
     {offset
       cd98: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd98_info" {
     block_cd98_info:
         const _cd98;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.295286169 UTC

[section ""data" . GHC.Base.$p1Alternative_closure" {
     GHC.Base.$p1Alternative_closure:
         const GHC.Base.$p1Alternative_info;
 },
 GHC.Base.$p1Alternative_entry() //  [R2]
         { []
         }
     {offset
       cd9y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd9z; else goto cd9A;
       cd9z: // global
           R2 = R2;
           R1 = GHC.Base.$p1Alternative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd9A: // global
           I64[Sp - 8] = block_cd9v_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ud9E; else goto cd9w;
       ud9E: // global
           call _cd9v(R1) args: 0, res: 0, upd: 0;
       cd9w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$p1Alternative_info" {
     GHC.Base.$p1Alternative_info:
         const GHC.Base.$p1Alternative_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd9v() //  [R1]
         { []
         }
     {offset
       cd9v: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd9v_info" {
     block_cd9v_info:
         const _cd9v;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.302081604 UTC

[section ""data" . GHC.Base.empty_closure" {
     GHC.Base.empty_closure:
         const GHC.Base.empty_info;
 },
 GHC.Base.empty_entry() //  [R2]
         { []
         }
     {offset
       cd9X: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cd9Y; else goto cd9Z;
       cd9Y: // global
           R2 = R2;
           R1 = GHC.Base.empty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cd9Z: // global
           I64[Sp - 8] = block_cd9U_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uda3; else goto cd9V;
       uda3: // global
           call _cd9U(R1) args: 0, res: 0, upd: 0;
       cd9V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.empty_info" {
     GHC.Base.empty_info:
         const GHC.Base.empty_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cd9U() //  [R1]
         { []
         }
     {offset
       cd9U: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cd9U_info" {
     block_cd9U_info:
         const _cd9U;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.307430951 UTC

[section ""data" . GHC.Base.<|>_closure" {
     GHC.Base.<|>_closure:
         const GHC.Base.<|>_info;
 },
 GHC.Base.<|>_entry() //  [R2]
         { []
         }
     {offset
       cdak: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdal; else goto cdam;
       cdal: // global
           R2 = R2;
           R1 = GHC.Base.<|>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdam: // global
           I64[Sp - 8] = block_cdah_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udaq; else goto cdai;
       udaq: // global
           call _cdah(R1) args: 0, res: 0, upd: 0;
       cdai: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.<|>_info" {
     GHC.Base.<|>_info:
         const GHC.Base.<|>_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cdah() //  [R1]
         { []
         }
     {offset
       cdah: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdah_info" {
     block_cdah_info:
         const _cdah;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.312660607 UTC

[section ""data" . GHC.Base.some_closure" {
     GHC.Base.some_closure:
         const GHC.Base.some_info;
 },
 GHC.Base.some_entry() //  [R2]
         { []
         }
     {offset
       cdaH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdaI; else goto cdaJ;
       cdaI: // global
           R2 = R2;
           R1 = GHC.Base.some_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdaJ: // global
           I64[Sp - 8] = block_cdaE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udaN; else goto cdaF;
       udaN: // global
           call _cdaE(R1) args: 0, res: 0, upd: 0;
       cdaF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.some_info" {
     GHC.Base.some_info:
         const GHC.Base.some_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cdaE() //  [R1]
         { []
         }
     {offset
       cdaE: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdaE_info" {
     block_cdaE_info:
         const _cdaE;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.318417355 UTC

[section ""data" . GHC.Base.many_closure" {
     GHC.Base.many_closure:
         const GHC.Base.many_info;
 },
 GHC.Base.many_entry() //  [R2]
         { []
         }
     {offset
       cdb4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdb5; else goto cdb6;
       cdb5: // global
           R2 = R2;
           R1 = GHC.Base.many_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdb6: // global
           I64[Sp - 8] = block_cdb1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udba; else goto cdb2;
       udba: // global
           call _cdb1(R1) args: 0, res: 0, upd: 0;
       cdb2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.many_info" {
     GHC.Base.many_info:
         const GHC.Base.many_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cdb1() //  [R1]
         { []
         }
     {offset
       cdb1: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdb1_info" {
     block_cdb1_info:
         const _cdb1;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.325859337 UTC

[section ""data" . GHC.Base.eqString_closure" {
     GHC.Base.eqString_closure:
         const GHC.Base.eqString_info;
 },
 GHC.Base.eqString_entry() //  [R2, R3]
         { []
         }
     {offset
       cdbv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdbw; else goto udcl;
       cdbw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.eqString_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       udcl: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cdbl() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Base.eqString_info" {
     GHC.Base.eqString_info:
         const GHC.Base.eqString_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdbl() //  []
         { []
         }
     {offset
       cdbl: // global
           _s7SQ::P64 = P64[Sp];
           I64[Sp] = block_cdbo_info;
           R1 = _s7SQ::P64;
           if (R1 & 7 != 0) goto udcq; else goto cdbp;
       udcq: // global
           call _cdbo(R1) args: 0, res: 0, upd: 0;
       cdbp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdbo() //  [R1]
         { []
         }
     {offset
       cdbo: // global
           _s7SR::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdbs; else goto cdbt;
       cdbs: // global
           I64[Sp + 8] = block_cdbA_info;
           R1 = _s7SR::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto udcr; else goto cdbC;
       udcr: // global
           call _cdbA(R1) args: 0, res: 0, upd: 0;
       cdbC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cdbt: // global
           I64[Sp - 8] = block_cdbP_info;
           _s7SW::P64 = P64[R1 + 6];
           _s7SX::P64 = P64[R1 + 14];
           R1 = _s7SR::P64;
           P64[Sp] = _s7SX::P64;
           P64[Sp + 8] = _s7SW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udcs; else goto cdbR;
       udcs: // global
           call _cdbP(R1) args: 0, res: 0, upd: 0;
       cdbR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdbo_info" {
     block_cdbo_info:
         const _cdbo;
         const 1;
         const 30;
 },
 _cdbA() //  [R1]
         { []
         }
     {offset
       cdbA: // global
           if (R1 & 7 == 1) goto cdbI; else goto udcp;
       cdbI: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       udcp: // global
           Sp = Sp + 8;
           call _cdch() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cdbA_info" {
     block_cdbA_info:
         const _cdbA;
         const 0;
         const 30;
 },
 _cdbP() //  [R1]
         { []
         }
     {offset
       cdbP: // global
           if (R1 & 7 == 1) goto udcm; else goto cdc7;
       udcm: // global
           Sp = Sp + 24;
           call _cdch() args: 0, res: 0, upd: 0;
       cdc7: // global
           I64[Sp - 8] = block_cdc0_info;
           _s7SZ::P64 = P64[R1 + 6];
           _s7T0::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _s7T0::P64;
           P64[Sp + 16] = _s7SZ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udcv; else goto cdc1;
       udcv: // global
           call _cdc0(R1) args: 0, res: 0, upd: 0;
       cdc1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdbP_info" {
     block_cdbP_info:
         const _cdbP;
         const 2;
         const 30;
 },
 _cdc0() //  [R1]
         { []
         }
     {offset
       cdc0: // global
           I64[Sp] = block_cdc5_info;
           _s7T2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _s7T2::I64;
           if (R1 & 7 != 0) goto udcx; else goto cdc9;
       udcx: // global
           call _cdc5(R1) args: 0, res: 0, upd: 0;
       cdc9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdc0_info" {
     block_cdc0_info:
         const _cdc0;
         const 3;
         const 30;
 },
 _cdc5() //  [R1]
         { []
         }
     {offset
       cdc5: // global
           if (I64[Sp + 24] == I64[R1 + 7]) goto cdci; else goto udcn;
       cdci: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cdbl() args: 0, res: 0, upd: 0;
       udcn: // global
           Sp = Sp + 32;
           call _cdch() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cdc5_info" {
     block_cdc5_info:
         const _cdc5;
         const 259;
         const 30;
 },
 _cdch() //  []
         { []
         }
     {offset
       cdch: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.33997499 UTC

[section ""data" . GHC.Base.when2_closure" {
     GHC.Base.when2_closure:
         const GHC.Base.when2_info;
 },
 GHC.Base.when2_entry() //  [R2, R3]
         { []
         }
     {offset
       cddp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cddq; else goto cddr;
       cddq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.when2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cddr: // global
           I64[Sp - 16] = block_cddi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uddy; else goto cddj;
       uddy: // global
           call _cddi(R1) args: 0, res: 0, upd: 0;
       cddj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.when2_info" {
     GHC.Base.when2_info:
         const GHC.Base.when2_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cddi() //  [R1]
         { []
         }
     {offset
       cddi: // global
           if (R1 & 7 == 1) goto cddm; else goto cddn;
       cddm: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cddn: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cddi_info" {
     block_cddi_info:
         const _cddi;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.345189996 UTC

[section ""data" . GHC.Base.when_$swhen1_closure" {
     GHC.Base.when_$swhen1_closure:
         const GHC.Base.when_$swhen1_info;
 },
 GHC.Base.when_$swhen1_entry() //  [R2, R3]
         { []
         }
     {offset
       cddP: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.when2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.when_$swhen1_info" {
     GHC.Base.when_$swhen1_info:
         const GHC.Base.when_$swhen1_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.349225072 UTC

[section ""data" . GHC.Base.$fFunctorIO2_closure" {
     GHC.Base.$fFunctorIO2_closure:
         const GHC.Base.$fFunctorIO2_info;
 },
 GHC.Base.$fFunctorIO2_entry() //  [R2, R3]
         { []
         }
     {offset
       cde3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cde4; else goto cde5;
       cde4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorIO2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cde5: // global
           I64[Sp - 16] = block_cde0_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fFunctorIO2_info" {
     GHC.Base.$fFunctorIO2_info:
         const GHC.Base.$fFunctorIO2_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cde0() //  [R1]
         { []
         }
     {offset
       cde0: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cde8; else goto cde7;
       cde8: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cde7: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cde0_info" {
     block_cde0_info:
         const _cde0;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.354941009 UTC

[section ""data" . GHC.Base.$fFunctorIO1_closure" {
     GHC.Base.$fFunctorIO1_closure:
         const GHC.Base.$fFunctorIO1_info;
 },
 GHC.Base.$fFunctorIO1_entry() //  [R2, R3]
         { []
         }
     {offset
       cdep: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdeq; else goto cder;
       cdeq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cder: // global
           I64[Sp - 16] = block_cden_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fFunctorIO1_info" {
     GHC.Base.$fFunctorIO1_info:
         const GHC.Base.$fFunctorIO1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cden() //  []
         { []
         }
     {offset
       cden: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cden_info" {
     block_cden_info:
         const _cden;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.359581334 UTC

[section ""data" . GHC.Base.$fFunctorIO_closure" {
     GHC.Base.$fFunctorIO_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fFunctorIO2_closure+3;
         const GHC.Base.$fFunctorIO1_closure+3;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.361691223 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe1_closure" {
     GHC.Base.$fAlternativeMaybe1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.365419122 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_$cmany_closure" {
     GHC.Base.$fAlternativeMaybe_$cmany_closure:
         const GHC.Base.$fAlternativeMaybe_$cmany_info;
 },
 many_v_s7To_entry() //  [R1]
         { []
         }
     {offset
       cdeT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdeU; else goto cdeV;
       cdeU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdeV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdeM_info;
           _s7To::P64 = R1;
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s7To::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udfn; else goto cdeN;
       udfn: // global
           call _cdeM(R1) args: 0, res: 0, upd: 0;
       cdeN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . many_v_s7To_info" {
     many_v_s7To_info:
         const many_v_s7To_entry;
         const 1;
         const 16;
 },
 _cdeM() //  [R1]
         { []
         }
     {offset
       cdeM: // global
           if (R1 & 7 == 1) goto udfj; else goto cdeR;
       udfj: // global
           Sp = Sp + 16;
           call _cdf9() args: 0, res: 0, upd: 0;
       cdeR: // global
           I64[Sp] = block_cdf1_info;
           _s7Tq::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7Tq::P64;
           if (R1 & 7 != 0) goto udfl; else goto cdf3;
       udfl: // global
           call _cdf1(R1) args: 0, res: 0, upd: 0;
       cdf3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cdeM_info" {
     block_cdeM_info:
         const _cdeM;
         const 1;
         const 30;
 },
 _cdf1() //  [R1]
         { []
         }
     {offset
       cdf1: // global
           if (R1 & 7 == 1) goto udfk; else goto cdfe;
       udfk: // global
           Sp = Sp + 16;
           call _cdf9() args: 0, res: 0, upd: 0;
       cdfe: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdfh; else goto cdfg;
       cdfh: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdfg: // global
           _s7Ts::P64 = P64[R1 + 6];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s7Ts::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdf1_info" {
     block_cdf1_info:
         const _cdf1;
         const 1;
         const 30;
 },
 _cdf9() //  []
         { []
         }
     {offset
       cdf9: // global
           R1 = GHC.Base.$fAlternativeMaybe1_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternativeMaybe_$cmany_entry() //  [R2]
         { []
         }
     {offset
       cdfp: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdft; else goto cdfs;
       cdft: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeMaybe_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdfs: // global
           I64[Hp - 16] = many_v_s7To_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fAlternativeMaybe_$cmany_info" {
     GHC.Base.$fAlternativeMaybe_$cmany_info:
         const GHC.Base.$fAlternativeMaybe_$cmany_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.377527908 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_$csome_closure" {
     GHC.Base.$fAlternativeMaybe_$csome_closure:
         const GHC.Base.$fAlternativeMaybe_$csome_info;
 },
 some_v_s7Tv_entry() //  [R1]
         { []
         }
     {offset
       cdgb: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdgc; else goto cdgd;
       cdgc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdgd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cdg4_info;
           _s7Tv::P64 = R1;
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s7Tv::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udgG; else goto cdg5;
       udgG: // global
           call _cdg4(R1) args: 0, res: 0, upd: 0;
       cdg5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . some_v_s7Tv_info" {
     some_v_s7Tv_info:
         const some_v_s7Tv_entry;
         const 1;
         const 16;
 },
 _cdg4() //  [R1]
         { []
         }
     {offset
       cdg4: // global
           if (R1 & 7 == 1) goto cdg8; else goto cdg9;
       cdg8: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdg9: // global
           I64[Sp] = block_cdgj_info;
           _s7Tx::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7Tx::P64;
           if (R1 & 7 != 0) goto udgF; else goto cdgl;
       udgF: // global
           call _cdgj(R1) args: 0, res: 0, upd: 0;
       cdgl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cdg4_info" {
     block_cdg4_info:
         const _cdg4;
         const 1;
         const 30;
 },
 _cdgj() //  [R1]
         { []
         }
     {offset
       cdgj: // global
           _s7Tx::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdgs; else goto cdgA;
       cdgs: // global
           Hp = Hp + 40;
           _s7Ty::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cdgD; else goto cdgu;
       cdgu: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = _s7Tx::P64;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cdgA: // global
           Hp = Hp + 40;
           _s7Ty::P64 = R1;
           if (Hp > HpLim) (likely: False) goto cdgD; else goto cdgC;
       cdgD: // global
           HpAlloc = 40;
           R1 = _s7Ty::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cdgC: // global
           _s7TA::P64 = P64[_s7Ty::P64 + 6];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = _s7Tx::P64;
           P64[Hp - 16] = _s7TA::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdgj_info" {
     block_cdgj_info:
         const _cdgj;
         const 1;
         const 30;
 },
 GHC.Base.$fAlternativeMaybe_$csome_entry() //  [R2]
         { []
         }
     {offset
       cdgH: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdgL; else goto cdgK;
       cdgL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeMaybe_$csome_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdgK: // global
           I64[Hp - 16] = some_v_s7Tv_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fAlternativeMaybe_$csome_info" {
     GHC.Base.$fAlternativeMaybe_$csome_info:
         const GHC.Base.$fAlternativeMaybe_$csome_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.388244503 UTC

[section ""data" . GHC.Base.ap_$sap_closure" {
     GHC.Base.ap_$sap_closure:
         const GHC.Base.ap_$sap_info;
 },
 GHC.Base.ap_$sap_entry() //  [R2, R3]
         { []
         }
     {offset
       cdho: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdhp; else goto cdhq;
       cdhp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.ap_$sap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdhq: // global
           I64[Sp - 16] = block_cdhh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udhS; else goto cdhi;
       udhS: // global
           call _cdhh(R1) args: 0, res: 0, upd: 0;
       cdhi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.ap_$sap_info" {
     GHC.Base.ap_$sap_info:
         const GHC.Base.ap_$sap_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdhh() //  [R1]
         { []
         }
     {offset
       cdhh: // global
           if (R1 & 7 == 1) goto udhO; else goto cdhm;
       udhO: // global
           Sp = Sp + 16;
           call _cdhE() args: 0, res: 0, upd: 0;
       cdhm: // global
           I64[Sp] = block_cdhw_info;
           _s7TF::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7TF::P64;
           if (R1 & 7 != 0) goto udhQ; else goto cdhy;
       udhQ: // global
           call _cdhw(R1) args: 0, res: 0, upd: 0;
       cdhy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdhh_info" {
     block_cdhh_info:
         const _cdhh;
         const 1;
         const 30;
 },
 _cdhw() //  [R1]
         { []
         }
     {offset
       cdhw: // global
           if (R1 & 7 == 1) goto udhP; else goto cdhJ;
       udhP: // global
           Sp = Sp + 16;
           call _cdhE() args: 0, res: 0, upd: 0;
       cdhJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdhM; else goto cdhL;
       cdhM: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdhL: // global
           _s7TH::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s7TH::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdhw_info" {
     block_cdhw_info:
         const _cdhw;
         const 1;
         const 30;
 },
 _cdhE() //  []
         { []
         }
     {offset
       cdhE: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.399534618 UTC

[section ""data" . GHC.Base.liftM5_$sliftM5_closure" {
     GHC.Base.liftM5_$sliftM5_closure:
         const GHC.Base.liftM5_$sliftM5_info;
 },
 GHC.Base.liftM5_$sliftM5_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cdis: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdit; else goto cdiu;
       cdit: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM5_$sliftM5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdiu: // global
           I64[Sp - 40] = block_cdil_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udjC; else goto cdim;
       udjC: // global
           call _cdil(R1) args: 0, res: 0, upd: 0;
       cdim: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM5_$sliftM5_info" {
     GHC.Base.liftM5_$sliftM5_info:
         const GHC.Base.liftM5_$sliftM5_entry;
         const 0;
         const 14;
         const 25769803802;
 },
 _cdil() //  [R1]
         { []
         }
     {offset
       cdil: // global
           if (R1 & 7 == 1) goto udjv; else goto cdiq;
       udjv: // global
           Sp = Sp + 48;
           call _cdji() args: 0, res: 0, upd: 0;
       cdiq: // global
           I64[Sp] = block_cdiA_info;
           _s7TQ::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7TQ::P64;
           if (R1 & 7 != 0) goto udjA; else goto cdiC;
       udjA: // global
           call _cdiA(R1) args: 0, res: 0, upd: 0;
       cdiC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdil_info" {
     block_cdil_info:
         const _cdil;
         const 5;
         const 30;
 },
 _cdiA() //  [R1]
         { []
         }
     {offset
       cdiA: // global
           if (R1 & 7 == 1) goto udjw; else goto cdiN;
       udjw: // global
           Sp = Sp + 48;
           call _cdji() args: 0, res: 0, upd: 0;
       cdiN: // global
           I64[Sp] = block_cdiL_info;
           _s7TS::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7TS::P64;
           if (R1 & 7 != 0) goto udjD; else goto cdiO;
       udjD: // global
           call _cdiL(R1) args: 0, res: 0, upd: 0;
       cdiO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdiA_info" {
     block_cdiA_info:
         const _cdiA;
         const 5;
         const 30;
 },
 _cdiL() //  [R1]
         { []
         }
     {offset
       cdiL: // global
           if (R1 & 7 == 1) goto udjx; else goto cdiZ;
       udjx: // global
           Sp = Sp + 48;
           call _cdji() args: 0, res: 0, upd: 0;
       cdiZ: // global
           I64[Sp] = block_cdiX_info;
           _s7TU::P64 = P64[R1 + 6];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _s7TU::P64;
           if (R1 & 7 != 0) goto udjF; else goto cdj0;
       udjF: // global
           call _cdiX(R1) args: 0, res: 0, upd: 0;
       cdj0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdiL_info" {
     block_cdiL_info:
         const _cdiL;
         const 5;
         const 30;
 },
 _cdiX() //  [R1]
         { []
         }
     {offset
       cdiX: // global
           if (R1 & 7 == 1) goto udjy; else goto cdjb;
       udjy: // global
           Sp = Sp + 48;
           call _cdji() args: 0, res: 0, upd: 0;
       cdjb: // global
           I64[Sp] = block_cdj9_info;
           _s7TW::P64 = P64[R1 + 6];
           R1 = P64[Sp + 40];
           P64[Sp + 40] = _s7TW::P64;
           if (R1 & 7 != 0) goto udjH; else goto cdjc;
       udjH: // global
           call _cdj9(R1) args: 0, res: 0, upd: 0;
       cdjc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdiX_info" {
     block_cdiX_info:
         const _cdiX;
         const 5;
         const 30;
 },
 _cdj9() //  [R1]
         { []
         }
     {offset
       cdj9: // global
           if (R1 & 7 == 1) goto udjz; else goto cdjn;
       udjz: // global
           Sp = Sp + 48;
           call _cdji() args: 0, res: 0, upd: 0;
       cdjn: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdjq; else goto cdjp;
       cdjq: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdjp: // global
           _s7TY::P64 = P64[R1 + 6];
           I64[Hp - 72] = stg_ap_6_upd_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = _s7TY::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 72;
           R1 = Hp - 6;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdj9_info" {
     block_cdj9_info:
         const _cdj9;
         const 5;
         const 30;
 },
 _cdji() //  []
         { []
         }
     {offset
       cdji: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.415251538 UTC

[section ""data" . GHC.Base.liftM4_$sliftM4_closure" {
     GHC.Base.liftM4_$sliftM4_closure:
         const GHC.Base.liftM4_$sliftM4_info;
 },
 GHC.Base.liftM4_$sliftM4_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cdkE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdkF; else goto cdkG;
       cdkF: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM4_$sliftM4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdkG: // global
           I64[Sp - 40] = block_cdkx_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto udlA; else goto cdky;
       udlA: // global
           call _cdkx(R1) args: 0, res: 0, upd: 0;
       cdky: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM4_$sliftM4_info" {
     GHC.Base.liftM4_$sliftM4_info:
         const GHC.Base.liftM4_$sliftM4_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cdkx() //  [R1]
         { []
         }
     {offset
       cdkx: // global
           if (R1 & 7 == 1) goto udlu; else goto cdkC;
       udlu: // global
           Sp = Sp + 40;
           call _cdli() args: 0, res: 0, upd: 0;
       cdkC: // global
           I64[Sp] = block_cdkM_info;
           _s7U6::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7U6::P64;
           if (R1 & 7 != 0) goto udly; else goto cdkO;
       udly: // global
           call _cdkM(R1) args: 0, res: 0, upd: 0;
       cdkO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdkx_info" {
     block_cdkx_info:
         const _cdkx;
         const 4;
         const 30;
 },
 _cdkM() //  [R1]
         { []
         }
     {offset
       cdkM: // global
           if (R1 & 7 == 1) goto udlv; else goto cdkZ;
       udlv: // global
           Sp = Sp + 40;
           call _cdli() args: 0, res: 0, upd: 0;
       cdkZ: // global
           I64[Sp] = block_cdkX_info;
           _s7U8::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7U8::P64;
           if (R1 & 7 != 0) goto udlB; else goto cdl0;
       udlB: // global
           call _cdkX(R1) args: 0, res: 0, upd: 0;
       cdl0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdkM_info" {
     block_cdkM_info:
         const _cdkM;
         const 4;
         const 30;
 },
 _cdkX() //  [R1]
         { []
         }
     {offset
       cdkX: // global
           if (R1 & 7 == 1) goto udlw; else goto cdlb;
       udlw: // global
           Sp = Sp + 40;
           call _cdli() args: 0, res: 0, upd: 0;
       cdlb: // global
           I64[Sp] = block_cdl9_info;
           _s7Ua::P64 = P64[R1 + 6];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _s7Ua::P64;
           if (R1 & 7 != 0) goto udlD; else goto cdlc;
       udlD: // global
           call _cdl9(R1) args: 0, res: 0, upd: 0;
       cdlc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdkX_info" {
     block_cdkX_info:
         const _cdkX;
         const 4;
         const 30;
 },
 _cdl9() //  [R1]
         { []
         }
     {offset
       cdl9: // global
           if (R1 & 7 == 1) goto udlx; else goto cdln;
       udlx: // global
           Sp = Sp + 40;
           call _cdli() args: 0, res: 0, upd: 0;
       cdln: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cdlq; else goto cdlp;
       cdlq: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdlp: // global
           _s7Uc::P64 = P64[R1 + 6];
           I64[Hp - 64] = stg_ap_5_upd_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = _s7Uc::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdl9_info" {
     block_cdl9_info:
         const _cdl9;
         const 4;
         const 30;
 },
 _cdli() //  []
         { []
         }
     {offset
       cdli: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.429020032 UTC

[section ""data" . GHC.Base.liftM3_$sliftM3_closure" {
     GHC.Base.liftM3_$sliftM3_closure:
         const GHC.Base.liftM3_$sliftM3_info;
 },
 GHC.Base.liftM3_$sliftM3_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cdmt: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdmu; else goto cdmv;
       cdmu: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM3_$sliftM3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdmv: // global
           I64[Sp - 32] = block_cdmm_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udnb; else goto cdmn;
       udnb: // global
           call _cdmm(R1) args: 0, res: 0, upd: 0;
       cdmn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM3_$sliftM3_info" {
     GHC.Base.liftM3_$sliftM3_info:
         const GHC.Base.liftM3_$sliftM3_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _cdmm() //  [R1]
         { []
         }
     {offset
       cdmm: // global
           if (R1 & 7 == 1) goto udn6; else goto cdmr;
       udn6: // global
           Sp = Sp + 32;
           call _cdmV() args: 0, res: 0, upd: 0;
       cdmr: // global
           I64[Sp] = block_cdmB_info;
           _s7Uj::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7Uj::P64;
           if (R1 & 7 != 0) goto udn9; else goto cdmD;
       udn9: // global
           call _cdmB(R1) args: 0, res: 0, upd: 0;
       cdmD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdmm_info" {
     block_cdmm_info:
         const _cdmm;
         const 3;
         const 30;
 },
 _cdmB() //  [R1]
         { []
         }
     {offset
       cdmB: // global
           if (R1 & 7 == 1) goto udn7; else goto cdmO;
       udn7: // global
           Sp = Sp + 32;
           call _cdmV() args: 0, res: 0, upd: 0;
       cdmO: // global
           I64[Sp] = block_cdmM_info;
           _s7Ul::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7Ul::P64;
           if (R1 & 7 != 0) goto udnc; else goto cdmP;
       udnc: // global
           call _cdmM(R1) args: 0, res: 0, upd: 0;
       cdmP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdmB_info" {
     block_cdmB_info:
         const _cdmB;
         const 3;
         const 30;
 },
 _cdmM() //  [R1]
         { []
         }
     {offset
       cdmM: // global
           if (R1 & 7 == 1) goto udn8; else goto cdn0;
       udn8: // global
           Sp = Sp + 32;
           call _cdmV() args: 0, res: 0, upd: 0;
       cdn0: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdn3; else goto cdn2;
       cdn3: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdn2: // global
           _s7Un::P64 = P64[R1 + 6];
           I64[Hp - 56] = stg_ap_4_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _s7Un::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdmM_info" {
     block_cdmM_info:
         const _cdmM;
         const 3;
         const 30;
 },
 _cdmV() //  []
         { []
         }
     {offset
       cdmV: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.440983424 UTC

[section ""data" . GHC.Base.liftM2_$sliftM2_closure" {
     GHC.Base.liftM2_$sliftM2_closure:
         const GHC.Base.liftM2_$sliftM2_info;
 },
 GHC.Base.liftM2_$sliftM2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdnV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdnW; else goto cdnX;
       cdnW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM2_$sliftM2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdnX: // global
           I64[Sp - 24] = block_cdnO_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udop; else goto cdnP;
       udop: // global
           call _cdnO(R1) args: 0, res: 0, upd: 0;
       cdnP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM2_$sliftM2_info" {
     GHC.Base.liftM2_$sliftM2_info:
         const GHC.Base.liftM2_$sliftM2_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cdnO() //  [R1]
         { []
         }
     {offset
       cdnO: // global
           if (R1 & 7 == 1) goto udol; else goto cdnT;
       udol: // global
           Sp = Sp + 24;
           call _cdob() args: 0, res: 0, upd: 0;
       cdnT: // global
           I64[Sp] = block_cdo3_info;
           _s7Ut::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7Ut::P64;
           if (R1 & 7 != 0) goto udon; else goto cdo5;
       udon: // global
           call _cdo3(R1) args: 0, res: 0, upd: 0;
       cdo5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdnO_info" {
     block_cdnO_info:
         const _cdnO;
         const 2;
         const 30;
 },
 _cdo3() //  [R1]
         { []
         }
     {offset
       cdo3: // global
           if (R1 & 7 == 1) goto udom; else goto cdog;
       udom: // global
           Sp = Sp + 24;
           call _cdob() args: 0, res: 0, upd: 0;
       cdog: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdoj; else goto cdoi;
       cdoj: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdoi: // global
           _s7Uv::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _s7Uv::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdo3_info" {
     block_cdo3_info:
         const _cdo3;
         const 2;
         const 30;
 },
 _cdob() //  []
         { []
         }
     {offset
       cdob: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.449881232 UTC

[section ""data" . GHC.Base.liftM_$sliftM_closure" {
     GHC.Base.liftM_$sliftM_closure:
         const GHC.Base.liftM_$sliftM_info;
 },
 GHC.Base.liftM_$sliftM_entry() //  [R2, R3]
         { []
         }
     {offset
       cdp0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdp1; else goto cdp2;
       cdp1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM_$sliftM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdp2: // global
           I64[Sp - 16] = block_cdoT_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udpd; else goto cdoU;
       udpd: // global
           call _cdoT(R1) args: 0, res: 0, upd: 0;
       cdoU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM_$sliftM_info" {
     GHC.Base.liftM_$sliftM_info:
         const GHC.Base.liftM_$sliftM_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdoT() //  [R1]
         { []
         }
     {offset
       cdoT: // global
           if (R1 & 7 == 1) goto cdoX; else goto cdoY;
       cdoX: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdoY: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdpc; else goto cdpb;
       cdpc: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdpb: // global
           _s7UA::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s7UA::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdoT_info" {
     block_cdoT_info:
         const _cdoT;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.455437921 UTC

[section ""data" . GHC.Base.when1_closure" {
     GHC.Base.when1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Tuple.()_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.458034855 UTC

[section ""data" . GHC.Base.when_$swhen_closure" {
     GHC.Base.when_$swhen_closure:
         const GHC.Base.when_$swhen_info;
 },
 GHC.Base.when_$swhen_entry() //  [R2, R3]
         { []
         }
     {offset
       cdpF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdpG; else goto cdpH;
       cdpG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.when_$swhen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdpH: // global
           I64[Sp - 16] = block_cdpy_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udpO; else goto cdpz;
       udpO: // global
           call _cdpy(R1) args: 0, res: 0, upd: 0;
       cdpz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.when_$swhen_info" {
     GHC.Base.when_$swhen_info:
         const GHC.Base.when_$swhen_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdpy() //  [R1]
         { []
         }
     {offset
       cdpy: // global
           if (R1 & 7 == 1) goto cdpC; else goto cdpD;
       cdpC: // global
           R1 = GHC.Base.when1_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdpD: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdpy_info" {
     block_cdpy_info:
         const _cdpy;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.464028955 UTC

[section ""data" . GHC.Base.when_closure" {
     GHC.Base.when_closure:
         const GHC.Base.when_info;
 },
 GHC.Base.when_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdqe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdqf; else goto cdqg;
       cdqf: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.when_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqg: // global
           I64[Sp - 24] = block_cdq7_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udqn; else goto cdq8;
       udqn: // global
           call _cdq7(R1) args: 0, res: 0, upd: 0;
       cdq8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.when_info" {
     GHC.Base.when_info:
         const GHC.Base.when_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cdq7() //  [R1]
         { []
         }
     {offset
       cdq7: // global
           if (R1 & 7 == 1) goto cdqb; else goto cdqc;
       cdqb: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       cdqc: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdq7_info" {
     block_cdq7_info:
         const _cdq7;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.471062445 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$c<*_closure" {
     GHC.Base.$fApplicativeMaybe_$c<*_closure:
         const GHC.Base.$fApplicativeMaybe_$c<*_info;
 },
 GHC.Base.$fApplicativeMaybe_$c<*_entry() //  [R2, R3]
         { []
         }
     {offset
       cdqK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdqL; else goto cdqM;
       cdqL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$c<*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdqM: // global
           I64[Sp - 16] = block_cdqD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udra; else goto cdqE;
       udra: // global
           call _cdqD(R1) args: 0, res: 0, upd: 0;
       cdqE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeMaybe_$c<*_info" {
     GHC.Base.$fApplicativeMaybe_$c<*_info:
         const GHC.Base.$fApplicativeMaybe_$c<*_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdqD() //  [R1]
         { []
         }
     {offset
       cdqD: // global
           if (R1 & 7 == 1) goto udr6; else goto cdqI;
       udr6: // global
           Sp = Sp + 16;
           call _cdr0() args: 0, res: 0, upd: 0;
       cdqI: // global
           I64[Sp] = block_cdqS_info;
           _s7UL::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7UL::P64;
           if (R1 & 7 != 0) goto udr8; else goto cdqU;
       udr8: // global
           call _cdqS(R1) args: 0, res: 0, upd: 0;
       cdqU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdqD_info" {
     block_cdqD_info:
         const _cdqD;
         const 1;
         const 30;
 },
 _cdqS() //  [R1]
         { []
         }
     {offset
       cdqS: // global
           if (R1 & 7 == 1) goto udr7; else goto cdr4;
       udr7: // global
           Sp = Sp + 16;
           call _cdr0() args: 0, res: 0, upd: 0;
       cdr4: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdqS_info" {
     block_cdqS_info:
         const _cdqS;
         const 1;
         const 30;
 },
 _cdr0() //  []
         { []
         }
     {offset
       cdr0: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.478410891 UTC

[section ""cstring" . GHC.Base.$tc'O3_bytes" {
     GHC.Base.$tc'O3_bytes:
         I8[] [39,79]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.480167822 UTC

[section ""data" . GHC.Base.$tc'O2_closure" {
     GHC.Base.$tc'O2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'O3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.482257636 UTC

[section ""cstring" . GHC.Base.$tcOpaque2_bytes" {
     GHC.Base.$tcOpaque2_bytes:
         I8[] [79,112,97,113,117,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.483881866 UTC

[section ""data" . GHC.Base.$tcOpaque1_closure" {
     GHC.Base.$tcOpaque1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcOpaque2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.485512714 UTC

[section ""cstring" . GHC.Base.$tcMonadPlus2_bytes" {
     GHC.Base.$tcMonadPlus2_bytes:
         I8[] [77,111,110,97,100,80,108,117,115]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.487245632 UTC

[section ""data" . GHC.Base.$tcMonadPlus1_closure" {
     GHC.Base.$tcMonadPlus1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMonadPlus2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.488850363 UTC

[section ""cstring" . GHC.Base.$tcMonad2_bytes" {
     GHC.Base.$tcMonad2_bytes:
         I8[] [77,111,110,97,100]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.490817865 UTC

[section ""data" . GHC.Base.$tcMonad1_closure" {
     GHC.Base.$tcMonad1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMonad2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.492471743 UTC

[section ""cstring" . GHC.Base.$tc'C:Monoid3_bytes" {
     GHC.Base.$tc'C:Monoid3_bytes:
         I8[] [39,67,58,77,111,110,111,105,100]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.494587944 UTC

[section ""data" . GHC.Base.$tc'C:Monoid2_closure" {
     GHC.Base.$tc'C:Monoid2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'C:Monoid3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.496164587 UTC

[section ""cstring" . GHC.Base.$tcMonoid3_bytes" {
     GHC.Base.$tcMonoid3_bytes:
         I8[] [77,111,110,111,105,100]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.497875461 UTC

[section ""data" . GHC.Base.$tcMonoid2_closure" {
     GHC.Base.$tcMonoid2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMonoid3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.49947604 UTC

[section ""cstring" . GHC.Base.$tcSemigroup2_bytes" {
     GHC.Base.$tcSemigroup2_bytes:
         I8[] [83,101,109,105,103,114,111,117,112]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.500995247 UTC

[section ""data" . GHC.Base.$tcSemigroup1_closure" {
     GHC.Base.$tcSemigroup1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcSemigroup2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.502751953 UTC

[section ""cstring" . GHC.Base.$tc':|3_bytes" {
     GHC.Base.$tc':|3_bytes:
         I8[] [39,58,124]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.50442729 UTC

[section ""data" . GHC.Base.$tc':|2_closure" {
     GHC.Base.$tc':|2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc':|3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.506161617 UTC

[section ""cstring" . GHC.Base.$tcNonEmpty2_bytes" {
     GHC.Base.$tcNonEmpty2_bytes:
         I8[] [78,111,110,69,109,112,116,121]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.508174337 UTC

[section ""data" . GHC.Base.$tcNonEmpty1_closure" {
     GHC.Base.$tcNonEmpty1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcNonEmpty2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.51017951 UTC

[section ""cstring" . GHC.Base.$tcAlternative3_bytes" {
     GHC.Base.$tcAlternative3_bytes:
         I8[] [65,108,116,101,114,110,97,116,105,118,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.511807117 UTC

[section ""data" . GHC.Base.$tcAlternative2_closure" {
     GHC.Base.$tcAlternative2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcAlternative3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.513525617 UTC

[section ""cstring" . GHC.Base.$tcApplicative2_bytes" {
     GHC.Base.$tcApplicative2_bytes:
         I8[] [65,112,112,108,105,99,97,116,105,118,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.515163716 UTC

[section ""data" . GHC.Base.$tcApplicative1_closure" {
     GHC.Base.$tcApplicative1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcApplicative2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.516767457 UTC

[section ""cstring" . GHC.Base.$tcFunctor2_bytes" {
     GHC.Base.$tcFunctor2_bytes:
         I8[] [70,117,110,99,116,111,114]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.518494805 UTC

[section ""data" . GHC.Base.$tcFunctor1_closure" {
     GHC.Base.$tcFunctor1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcFunctor2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.520542298 UTC

[section ""cstring" . GHC.Base.$tc'Just3_bytes" {
     GHC.Base.$tc'Just3_bytes:
         I8[] [39,74,117,115,116]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.522199842 UTC

[section ""data" . GHC.Base.$tc'Just2_closure" {
     GHC.Base.$tc'Just2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'Just3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.523830134 UTC

[section ""cstring" . GHC.Base.$tc'Nothing3_bytes" {
     GHC.Base.$tc'Nothing3_bytes:
         I8[] [39,78,111,116,104,105,110,103]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.525535844 UTC

[section ""data" . GHC.Base.$tc'Nothing2_closure" {
     GHC.Base.$tc'Nothing2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'Nothing3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.527145586 UTC

[section ""cstring" . GHC.Base.$tcMaybe2_bytes" {
     GHC.Base.$tcMaybe2_bytes:
         I8[] [77,97,121,98,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.528798133 UTC

[section ""data" . GHC.Base.$tcMaybe1_closure" {
     GHC.Base.$tcMaybe1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMaybe2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.530917727 UTC

[section ""data" . $krep_r7Pr_closure" {
     $krep_r7Pr_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.532680371 UTC

[section ""data" . $krep1_r7Ps_closure" {
     $krep1_r7Ps_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep_r7Pr_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.534752907 UTC

[section ""data" . $krep2_r7Pt_closure" {
     $krep2_r7Pt_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep1_r7Ps_closure+4;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.53643175 UTC

[section ""data" . $krep3_r7Pu_closure" {
     $krep3_r7Pu_closure:
         const :_con_info;
         const $krep_r7Pr_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.538167663 UTC

[section ""data" . $krep4_r7Pv_closure" {
     $krep4_r7Pv_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.539868413 UTC

[section ""data" . $krep5_r7Pw_closure" {
     $krep5_r7Pw_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r7Pv_closure+1;
         const $krep_r7Pr_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.541591098 UTC

[section ""data" . $krep6_r7Px_closure" {
     $krep6_r7Px_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.543362624 UTC

[section ""data" . GHC.Base.$tcMonoid1_closure" {
     GHC.Base.$tcMonoid1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep6_r7Px_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.545036181 UTC

[section ""data" . GHC.Base.$tcAlternative1_closure" {
     GHC.Base.$tcAlternative1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep6_r7Px_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.547142122 UTC

[section ""cstring" . GHC.Base.$trModule2_bytes" {
     GHC.Base.$trModule2_bytes:
         I8[] [71,72,67,46,66,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.548839339 UTC

[section ""data" . GHC.Base.$trModule1_closure" {
     GHC.Base.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.550620374 UTC

[section ""cstring" . GHC.Base.$trModule4_bytes" {
     GHC.Base.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.552355061 UTC

[section ""data" . GHC.Base.$trModule3_closure" {
     GHC.Base.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.554602599 UTC

[section ""data" . GHC.Base.$trModule_closure" {
     GHC.Base.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Base.$trModule3_closure+1;
         const GHC.Base.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.556340427 UTC

[section ""data" . GHC.Base.$tcMaybe_closure" {
     GHC.Base.$tcMaybe_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMaybe1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 625655543500963593;
         const 6391758309165051762;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.558250224 UTC

[section ""data" . GHC.Base.$tc'Nothing1_closure" {
     GHC.Base.$tc'Nothing1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.560313199 UTC

[section ""data" . GHC.Base.$tc'Just1_closure" {
     GHC.Base.$tc'Just1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const GHC.Base.$tc'Nothing1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.562686574 UTC

[section ""data" . GHC.Base.$tc'Nothing_closure" {
     GHC.Base.$tc'Nothing_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'Nothing2_closure+1;
         const GHC.Base.$tc'Nothing1_closure+1;
         const 14633289528184412192;
         const 12773126156421542470;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.564521132 UTC

[section ""data" . GHC.Base.$tc'Just_closure" {
     GHC.Base.$tc'Just_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'Just2_closure+1;
         const GHC.Base.$tc'Just1_closure+4;
         const 5794512144280699493;
         const 9434423460978218117;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.566338836 UTC

[section ""data" . GHC.Base.$tcFunctor_closure" {
     GHC.Base.$tcFunctor_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcFunctor1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 211182333006544237;
         const 5556320544348084514;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.568150936 UTC

[section ""data" . GHC.Base.$tcApplicative_closure" {
     GHC.Base.$tcApplicative_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcApplicative1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 12705055220831243597;
         const 2963353171490466073;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.569962697 UTC

[section ""data" . GHC.Base.$tcAlternative_closure" {
     GHC.Base.$tcAlternative_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcAlternative2_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 1073491102990665358;
         const 14320772755704808948;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.571791446 UTC

[section ""data" . GHC.Base.$tcNonEmpty_closure" {
     GHC.Base.$tcNonEmpty_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcNonEmpty1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 13207016872645468285;
         const 3455542966739695982;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.57462476 UTC

[section ""data" . $krep7_r7Py_closure" {
     $krep7_r7Py_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcNonEmpty_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.57631323 UTC

[section ""data" . $krep8_r7Pz_closure" {
     $krep8_r7Pz_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r7Pv_closure+1;
         const $krep7_r7Py_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.577991849 UTC

[section ""data" . GHC.Base.$tc':|1_closure" {
     GHC.Base.$tc':|1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep8_r7Pz_closure+4;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.579726928 UTC

[section ""data" . GHC.Base.$tc':|_closure" {
     GHC.Base.$tc':|_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc':|2_closure+1;
         const GHC.Base.$tc':|1_closure+4;
         const 9440832435183810765;
         const 3053237465234607583;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.581579599 UTC

[section ""data" . GHC.Base.$tcSemigroup_closure" {
     GHC.Base.$tcSemigroup_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcSemigroup1_closure+1;
         const GHC.Base.$tcMonoid1_closure+4;
         const 16195352186364298277;
         const 3285685594139281062;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.583309452 UTC

[section ""data" . $krep9_r7PA_closure" {
     $krep9_r7PA_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcSemigroup_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.585088257 UTC

[section ""data" . GHC.Base.$tcMonoid_closure" {
     GHC.Base.$tcMonoid_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMonoid2_closure+1;
         const GHC.Base.$tcMonoid1_closure+4;
         const 13838560045895743776;
         const 1291018260833769143;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.587295102 UTC

[section ""data" . $krep10_r7PB_closure" {
     $krep10_r7PB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMonoid_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.589038131 UTC

[section ""data" . $krep11_r7PC_closure" {
     $krep11_r7PC_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r7Pw_closure+4;
         const $krep10_r7PB_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.590917301 UTC

[section ""data" . $krep12_r7PD_closure" {
     $krep12_r7PD_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r7Pt_closure+4;
         const $krep11_r7PC_closure+4;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.592577371 UTC

[section ""data" . $krep13_r7PE_closure" {
     $krep13_r7PE_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep12_r7PD_closure+4;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.594258175 UTC

[section ""data" . GHC.Base.$tc'C:Monoid1_closure" {
     GHC.Base.$tc'C:Monoid1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r7PA_closure+1;
         const $krep13_r7PE_closure+4;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.595947315 UTC

[section ""data" . GHC.Base.$tc'C:Monoid_closure" {
     GHC.Base.$tc'C:Monoid_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'C:Monoid2_closure+1;
         const GHC.Base.$tc'C:Monoid1_closure+4;
         const 16099296089107510343;
         const 5895832073319104984;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.597764945 UTC

[section ""data" . GHC.Base.$tcMonad_closure" {
     GHC.Base.$tcMonad_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMonad1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 3168880480603756299;
         const 8398240611646296094;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.599993567 UTC

[section ""data" . GHC.Base.$tcMonadPlus_closure" {
     GHC.Base.$tcMonadPlus_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMonadPlus1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 14115673251620372550;
         const 14155357326069389390;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.601893504 UTC

[section ""data" . GHC.Base.$tcOpaque_closure" {
     GHC.Base.$tcOpaque_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcOpaque1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9339725405829241186;
         const 15550233501624900571;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.603639554 UTC

[section ""data" . $krep14_r7PF_closure" {
     $krep14_r7PF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcOpaque_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.605770608 UTC

[section ""data" . GHC.Base.$tc'O1_closure" {
     GHC.Base.$tc'O1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep14_r7PF_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.607532391 UTC

[section ""data" . GHC.Base.$tc'O_closure" {
     GHC.Base.$tc'O_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'O2_closure+1;
         const GHC.Base.$tc'O1_closure+4;
         const 12551274612394834805;
         const 13000664474148134329;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.610890272 UTC

[section ""data" . GHC.Base.quotRemInt_closure" {
     GHC.Base.quotRemInt_closure:
         const GHC.Base.quotRemInt_info;
 },
 GHC.Base.quotRemInt_entry() //  [R2, R3]
         { []
         }
     {offset
       cdsP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdt0; else goto cdt1;
       cdt0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.quotRemInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdt1: // global
           I64[Sp - 16] = block_cdsM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udt7; else goto cdsN;
       udt7: // global
           call _cdsM(R1) args: 0, res: 0, upd: 0;
       cdsN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.quotRemInt_info" {
     GHC.Base.quotRemInt_info:
         const GHC.Base.quotRemInt_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdsM() //  [R1]
         { []
         }
     {offset
       cdsM: // global
           I64[Sp] = block_cdsS_info;
           _s7US::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7US::I64;
           if (R1 & 7 != 0) goto udt6; else goto cdsT;
       udt6: // global
           call _cdsS(R1) args: 0, res: 0, upd: 0;
       cdsT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdsM_info" {
     block_cdsM_info:
         const _cdsM;
         const 1;
         const 30;
 },
 _cdsS() //  [R1]
         { []
         }
     {offset
       cdsS: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdt5; else goto cdt4;
       cdt5: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdt4: // global
           (_s7UW::I64, _s7UX::I64) = call MO_S_QuotRem W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s7UX::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s7UW::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdsS_info" {
     block_cdsS_info:
         const _cdsS;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.619854449 UTC

[section ""data" . GHC.Base.modInt_closure" {
     GHC.Base.modInt_closure:
         const GHC.Base.modInt_info;
 },
 GHC.Base.modInt_entry() //  [R2, R3]
         { []
         }
     {offset
       cdtv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdtI; else goto cdtJ;
       cdtI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.modInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdtJ: // global
           I64[Sp - 16] = block_cdts_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udtQ; else goto cdtt;
       udtQ: // global
           call _cdts(R1) args: 0, res: 0, upd: 0;
       cdtt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.modInt_info" {
     GHC.Base.modInt_info:
         const GHC.Base.modInt_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdts() //  [R1]
         { []
         }
     {offset
       cdts: // global
           I64[Sp] = block_cdty_info;
           _s7V3::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7V3::I64;
           if (R1 & 7 != 0) goto udtP; else goto cdtz;
       udtP: // global
           call _cdty(R1) args: 0, res: 0, upd: 0;
       cdtz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdts_info" {
     block_cdts_info:
         const _cdts;
         const 1;
         const 30;
 },
 _cdty() //  [R1]
         { []
         }
     {offset
       cdty: // global
           _s7V3::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cdtD_info;
           R3 = I64[R1 + 7];
           R2 = _s7V3::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdty_info" {
     block_cdty_info:
         const _cdty;
         const 65;
         const 30;
 },
 _cdtD() //  [R1]
         { []
         }
     {offset
       cdtD: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdtO; else goto cdtN;
       cdtO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdtN: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdtD_info" {
     block_cdtD_info:
         const _cdtD;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.630021695 UTC

[section ""data" . GHC.Base.divInt_closure" {
     GHC.Base.divInt_closure:
         const GHC.Base.divInt_info;
 },
 GHC.Base.divInt_entry() //  [R2, R3]
         { []
         }
     {offset
       cduf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdus; else goto cdut;
       cdus: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.divInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdut: // global
           I64[Sp - 16] = block_cduc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uduA; else goto cdud;
       uduA: // global
           call _cduc(R1) args: 0, res: 0, upd: 0;
       cdud: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.divInt_info" {
     GHC.Base.divInt_info:
         const GHC.Base.divInt_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cduc() //  [R1]
         { []
         }
     {offset
       cduc: // global
           I64[Sp] = block_cdui_info;
           _s7Va::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7Va::I64;
           if (R1 & 7 != 0) goto uduz; else goto cduj;
       uduz: // global
           call _cdui(R1) args: 0, res: 0, upd: 0;
       cduj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cduc_info" {
     block_cduc_info:
         const _cduc;
         const 1;
         const 30;
 },
 _cdui() //  [R1]
         { []
         }
     {offset
       cdui: // global
           _s7Va::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cdun_info;
           R3 = I64[R1 + 7];
           R2 = _s7Va::I64;
           Sp = Sp + 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdui_info" {
     block_cdui_info:
         const _cdui;
         const 65;
         const 30;
 },
 _cdun() //  [R1]
         { []
         }
     {offset
       cdun: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cduy; else goto cdux;
       cduy: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cdux: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdun_info" {
     block_cdun_info:
         const _cdun;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.639086201 UTC

[section ""data" . GHC.Base.remInt_closure" {
     GHC.Base.remInt_closure:
         const GHC.Base.remInt_info;
 },
 GHC.Base.remInt_entry() //  [R2, R3]
         { []
         }
     {offset
       cduZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvb; else goto cdvc;
       cdvb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.remInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvc: // global
           I64[Sp - 16] = block_cduW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udvi; else goto cduX;
       udvi: // global
           call _cduW(R1) args: 0, res: 0, upd: 0;
       cduX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.remInt_info" {
     GHC.Base.remInt_info:
         const GHC.Base.remInt_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cduW() //  [R1]
         { []
         }
     {offset
       cduW: // global
           I64[Sp] = block_cdv2_info;
           _s7Vh::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7Vh::I64;
           if (R1 & 7 != 0) goto udvh; else goto cdv3;
       udvh: // global
           call _cdv2(R1) args: 0, res: 0, upd: 0;
       cdv3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cduW_info" {
     block_cduW_info:
         const _cduW;
         const 1;
         const 30;
 },
 _cdv2() //  [R1]
         { []
         }
     {offset
       cdv2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvg; else goto cdvf;
       cdvg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdvf: // global
           _s7Vk::I64 = %MO_S_Rem_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7Vk::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdv2_info" {
     block_cdv2_info:
         const _cdv2;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.647676041 UTC

[section ""data" . GHC.Base.quotInt_closure" {
     GHC.Base.quotInt_closure:
         const GHC.Base.quotInt_info;
 },
 GHC.Base.quotInt_entry() //  [R2, R3]
         { []
         }
     {offset
       cdvE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdvQ; else goto cdvR;
       cdvQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.quotInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdvR: // global
           I64[Sp - 16] = block_cdvB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udvX; else goto cdvC;
       udvX: // global
           call _cdvB(R1) args: 0, res: 0, upd: 0;
       cdvC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.quotInt_info" {
     GHC.Base.quotInt_info:
         const GHC.Base.quotInt_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdvB() //  [R1]
         { []
         }
     {offset
       cdvB: // global
           I64[Sp] = block_cdvH_info;
           _s7Vo::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s7Vo::I64;
           if (R1 & 7 != 0) goto udvW; else goto cdvI;
       udvW: // global
           call _cdvH(R1) args: 0, res: 0, upd: 0;
       cdvI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvB_info" {
     block_cdvB_info:
         const _cdvB;
         const 1;
         const 30;
 },
 _cdvH() //  [R1]
         { []
         }
     {offset
       cdvH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdvV; else goto cdvU;
       cdvV: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdvU: // global
           _s7Vr::I64 = %MO_S_Quot_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s7Vr::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdvH_info" {
     block_cdvH_info:
         const _cdvH;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.655018326 UTC

[section ""data" . GHC.Base.getTag_closure" {
     GHC.Base.getTag_closure:
         const GHC.Base.getTag_info;
 },
 GHC.Base.getTag_entry() //  [R2]
         { []
         }
     {offset
       cdwj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdwk; else goto cdwl;
       cdwk: // global
           R2 = R2;
           R1 = GHC.Base.getTag_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdwl: // global
           I64[Sp - 8] = block_cdwg_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.getTag_info" {
     GHC.Base.getTag_info:
         const GHC.Base.getTag_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cdwg() //  [R1]
         { []
         }
     {offset
       cdwg: // global
           R1 = %MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdwg_info" {
     block_cdwg_info:
         const _cdwg;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.660731337 UTC

[section ""data" . GHC.Base.$fMonadIO1_closure" {
     GHC.Base.$fMonadIO1_closure:
         const GHC.Base.$fMonadIO1_info;
 },
 GHC.Base.$fMonadIO1_entry() //  [R2, R3]
         { []
         }
     {offset
       cdwF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdwG; else goto cdwH;
       cdwG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonadIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdwH: // global
           I64[Sp - 16] = block_cdwD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonadIO1_info" {
     GHC.Base.$fMonadIO1_info:
         const GHC.Base.$fMonadIO1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cdwD() //  [R1]
         { []
         }
     {offset
       cdwD: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdwD_info" {
     block_cdwD_info:
         const _cdwD;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.666098547 UTC

[section ""data" . GHC.Base.bindIO_closure" {
     GHC.Base.bindIO_closure:
         const GHC.Base.bindIO_info;
 },
 GHC.Base.bindIO_entry() //  [R2, R3]
         { []
         }
     {offset
       cdwV: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fMonadIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.bindIO_info" {
     GHC.Base.bindIO_info:
         const GHC.Base.bindIO_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.669644833 UTC

[section ""data" . GHC.Base.$fApplicativeIO2_closure" {
     GHC.Base.$fApplicativeIO2_closure:
         const GHC.Base.$fApplicativeIO2_info;
 },
 GHC.Base.$fApplicativeIO2_entry() //  [R2, R3]
         { []
         }
     {offset
       cdx8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdx9; else goto cdxa;
       cdx9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeIO2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdxa: // global
           I64[Sp - 16] = block_cdx6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeIO2_info" {
     GHC.Base.$fApplicativeIO2_info:
         const GHC.Base.$fApplicativeIO2_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cdx6() //  []
         { []
         }
     {offset
       cdx6: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdx6_info" {
     block_cdx6_info:
         const _cdx6;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.675052865 UTC

[section ""data" . GHC.Base.thenIO_closure" {
     GHC.Base.thenIO_closure:
         const GHC.Base.thenIO_info;
 },
 GHC.Base.thenIO_entry() //  [R2, R3]
         { []
         }
     {offset
       cdxo: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fApplicativeIO2_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.thenIO_info" {
     GHC.Base.thenIO_info:
         const GHC.Base.thenIO_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.678229722 UTC

[section ""data" . GHC.Base.unIO1_closure" {
     GHC.Base.unIO1_closure:
         const GHC.Base.unIO1_info;
 },
 GHC.Base.unIO1_entry() //  [R2]
         { []
         }
     {offset
       cdxz: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.unIO1_info" {
     GHC.Base.unIO1_info:
         const GHC.Base.unIO1_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.681395623 UTC

[section ""data" . GHC.Base.unIO_closure" {
     GHC.Base.unIO_closure:
         const GHC.Base.unIO_info;
 },
 GHC.Base.unIO_entry() //  [R2]
         { []
         }
     {offset
       cdxK: // global
           R2 = R2;
           call GHC.Base.unIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.unIO_info" {
     GHC.Base.unIO_info:
         const GHC.Base.unIO_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.684589148 UTC

[section ""data" . GHC.Base.$fApplicativeIO4_closure" {
     GHC.Base.$fApplicativeIO4_closure:
         const GHC.Base.$fApplicativeIO4_info;
 },
 GHC.Base.$fApplicativeIO4_entry() //  [R2]
         { []
         }
     {offset
       cdxV: // global
           R1 = R2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeIO4_info" {
     GHC.Base.$fApplicativeIO4_info:
         const GHC.Base.$fApplicativeIO4_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.688338382 UTC

[section ""data" . GHC.Base.returnIO_closure" {
     GHC.Base.returnIO_closure:
         const GHC.Base.returnIO_info;
 },
 GHC.Base.returnIO_entry() //  [R2]
         { []
         }
     {offset
       cdy7: // global
           R2 = R2;
           call GHC.Base.$fApplicativeIO4_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.returnIO_info" {
     GHC.Base.returnIO_info:
         const GHC.Base.returnIO_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.692552544 UTC

[section ""data" . GHC.Base.$fApplicativeIO3_closure" {
     GHC.Base.$fApplicativeIO3_closure:
         const GHC.Base.$fApplicativeIO3_info;
 },
 GHC.Base.$fApplicativeIO3_entry() //  [R2, R3]
         { []
         }
     {offset
       cdyn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdyo; else goto cdyp;
       cdyo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeIO3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdyp: // global
           I64[Sp - 16] = block_cdyi_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeIO3_info" {
     GHC.Base.$fApplicativeIO3_info:
         const GHC.Base.$fApplicativeIO3_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cdyi() //  [R1]
         { []
         }
     {offset
       cdyi: // global
           I64[Sp] = block_cdyk_info;
           _s7VN::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7VN::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdyi_info" {
     block_cdyi_info:
         const _cdyi;
         const 1;
         const 30;
 },
 _cdyk() //  [R1]
         { []
         }
     {offset
       cdyk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdyt; else goto cdys;
       cdyt: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdys: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdyk_info" {
     block_cdyk_info:
         const _cdyk;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.69915843 UTC

[section ""data" . GHC.Base.liftA_$sliftA1_closure" {
     GHC.Base.liftA_$sliftA1_closure:
         const GHC.Base.liftA_$sliftA1_info;
 },
 GHC.Base.liftA_$sliftA1_entry() //  [R2, R3]
         { []
         }
     {offset
       cdyL: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fFunctorIO2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftA_$sliftA1_info" {
     GHC.Base.liftA_$sliftA1_info:
         const GHC.Base.liftA_$sliftA1_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.703553559 UTC

[section ""data" . GHC.Base.ap1_closure" {
     GHC.Base.ap1_closure:
         const GHC.Base.ap1_info;
 },
 GHC.Base.ap1_entry() //  [R2, R3]
         { []
         }
     {offset
       cdz1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdz2; else goto cdz3;
       cdz2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.ap1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdz3: // global
           I64[Sp - 16] = block_cdyW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.ap1_info" {
     GHC.Base.ap1_info:
         const GHC.Base.ap1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cdyW() //  [R1]
         { []
         }
     {offset
       cdyW: // global
           I64[Sp] = block_cdyY_info;
           _s7VX::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7VX::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdyW_info" {
     block_cdyW_info:
         const _cdyW;
         const 1;
         const 30;
 },
 _cdyY() //  [R1]
         { []
         }
     {offset
       cdyY: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdz7; else goto cdz6;
       cdz7: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdz6: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdyY_info" {
     block_cdyY_info:
         const _cdyY;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.710339385 UTC

[section ""data" . GHC.Base.ap_$sap1_closure" {
     GHC.Base.ap_$sap1_closure:
         const GHC.Base.ap_$sap1_info;
 },
 GHC.Base.ap_$sap1_entry() //  [R2, R3]
         { []
         }
     {offset
       cdzp: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.ap1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.ap_$sap1_info" {
     GHC.Base.ap_$sap1_info:
         const GHC.Base.ap_$sap1_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.71540815 UTC

[section ""data" . GHC.Base.ap_closure" {
     GHC.Base.ap_closure:
         const GHC.Base.ap_info;
 },
 sat_s7W8_entry() //  [R1, R2]
         { []
         }
     {offset
       cdzL: // global
           _s7W6::P64 = R2;
           _s7W8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdzM; else goto cdzN;
       cdzN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdzP; else goto cdzO;
       cdzP: // global
           HpAlloc = 32;
           goto cdzM;
       cdzM: // global
           R2 = _s7W6::P64;
           R1 = _s7W8::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzO: // global
           _s7W2::P64 = P64[_s7W8::P64 + 7];
           _s7W5::P64 = P64[_s7W8::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s7W5::P64;
           P64[Hp] = _s7W6::P64;
           R2 = _s7W2::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7W8_info" {
     sat_s7W8_info:
         const sat_s7W8_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 sat_s7W9_entry() //  [R1, R2]
         { []
         }
     {offset
       cdzQ: // global
           _s7W5::P64 = R2;
           _s7W9::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdzR; else goto cdzS;
       cdzS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzU; else goto cdzT;
       cdzU: // global
           HpAlloc = 24;
           goto cdzR;
       cdzR: // global
           R2 = _s7W5::P64;
           R1 = _s7W9::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdzT: // global
           _s7W2::P64 = P64[_s7W9::P64 + 7];
           _s7W4::P64 = P64[_s7W9::P64 + 15];
           I64[Hp - 16] = sat_s7W8_info;
           P64[Hp - 8] = _s7W2::P64;
           P64[Hp] = _s7W5::P64;
           R2 = _s7W2::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7W4::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7W9_info" {
     sat_s7W9_info:
         const sat_s7W9_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 GHC.Base.ap_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdzV: // global
           _s7W4::P64 = R4;
           _s7W3::P64 = R3;
           _s7W2::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdzW; else goto cdzX;
       cdzX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdzZ; else goto cdzY;
       cdzZ: // global
           HpAlloc = 24;
           goto cdzW;
       cdzW: // global
           R4 = _s7W4::P64;
           R3 = _s7W3::P64;
           R2 = _s7W2::P64;
           R1 = GHC.Base.ap_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdzY: // global
           I64[Hp - 16] = sat_s7W9_info;
           P64[Hp - 8] = _s7W2::P64;
           P64[Hp] = _s7W4::P64;
           R2 = _s7W2::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7W3::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.ap_info" {
     GHC.Base.ap_info:
         const GHC.Base.ap_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.724535627 UTC

[section ""data" . GHC.Base.liftM1_closure" {
     GHC.Base.liftM1_closure:
         const GHC.Base.liftM1_info;
 },
 GHC.Base.liftM1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdAp: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdAq; else goto cdAr;
       cdAq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdAr: // global
           I64[Sp - 24] = block_cdAk_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM1_info" {
     GHC.Base.liftM1_info:
         const GHC.Base.liftM1_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _cdAk() //  [R1]
         { []
         }
     {offset
       cdAk: // global
           I64[Sp] = block_cdAm_info;
           _s7Wg::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7Wg::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdAk_info" {
     block_cdAk_info:
         const _cdAk;
         const 2;
         const 30;
 },
 _cdAm() //  [R1]
         { []
         }
     {offset
       cdAm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdAv; else goto cdAu;
       cdAv: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdAu: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdAm_info" {
     block_cdAm_info:
         const _cdAm;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.73162155 UTC

[section ""data" . GHC.Base.liftM2_$sliftM1_closure" {
     GHC.Base.liftM2_$sliftM1_closure:
         const GHC.Base.liftM2_$sliftM1_info;
 },
 GHC.Base.liftM2_$sliftM1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdAO: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftM1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM2_$sliftM1_info" {
     GHC.Base.liftM2_$sliftM1_info:
         const GHC.Base.liftM2_$sliftM1_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.736807243 UTC

[section ""data" . GHC.Base.liftM2_closure" {
     GHC.Base.liftM2_closure:
         const GHC.Base.liftM2_info;
 },
 sat_s7Ws_entry() //  [R1, R2]
         { []
         }
     {offset
       cdBa: // global
           _s7Wq::P64 = R2;
           _s7Ws::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdBb; else goto cdBc;
       cdBc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdBe; else goto cdBd;
       cdBe: // global
           HpAlloc = 40;
           goto cdBb;
       cdBb: // global
           R2 = _s7Wq::P64;
           R1 = _s7Ws::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBd: // global
           _s7Wl::P64 = P64[_s7Ws::P64 + 7];
           _s7Wm::P64 = P64[_s7Ws::P64 + 15];
           _s7Wp::P64 = P64[_s7Ws::P64 + 23];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _s7Wm::P64;
           P64[Hp - 8] = _s7Wp::P64;
           P64[Hp] = _s7Wq::P64;
           R2 = _s7Wl::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7Ws_info" {
     sat_s7Ws_info:
         const sat_s7Ws_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 sat_s7Wt_entry() //  [R1, R2]
         { []
         }
     {offset
       cdBf: // global
           _s7Wp::P64 = R2;
           _s7Wt::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdBg; else goto cdBh;
       cdBh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBj; else goto cdBi;
       cdBj: // global
           HpAlloc = 32;
           goto cdBg;
       cdBg: // global
           R2 = _s7Wp::P64;
           R1 = _s7Wt::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdBi: // global
           _s7Wl::P64 = P64[_s7Wt::P64 + 7];
           _s7Wm::P64 = P64[_s7Wt::P64 + 15];
           _s7Wo::P64 = P64[_s7Wt::P64 + 23];
           I64[Hp - 24] = sat_s7Ws_info;
           P64[Hp - 16] = _s7Wl::P64;
           P64[Hp - 8] = _s7Wm::P64;
           P64[Hp] = _s7Wp::P64;
           R2 = _s7Wl::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Wo::P64;
           P64[Sp - 8] = Hp - 23;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7Wt_info" {
     sat_s7Wt_info:
         const sat_s7Wt_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 GHC.Base.liftM2_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cdBk: // global
           _s7Wo::P64 = R5;
           _s7Wn::P64 = R4;
           _s7Wm::P64 = R3;
           _s7Wl::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdBl; else goto cdBm;
       cdBm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdBo; else goto cdBn;
       cdBo: // global
           HpAlloc = 32;
           goto cdBl;
       cdBl: // global
           R5 = _s7Wo::P64;
           R4 = _s7Wn::P64;
           R3 = _s7Wm::P64;
           R2 = _s7Wl::P64;
           R1 = GHC.Base.liftM2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBn: // global
           I64[Hp - 24] = sat_s7Wt_info;
           P64[Hp - 16] = _s7Wl::P64;
           P64[Hp - 8] = _s7Wm::P64;
           P64[Hp] = _s7Wo::P64;
           R2 = _s7Wl::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Wn::P64;
           P64[Sp - 8] = Hp - 23;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM2_info" {
     GHC.Base.liftM2_info:
         const GHC.Base.liftM2_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.745677537 UTC

[section ""data" . $cliftA2_r7PG_closure" {
     $cliftA2_r7PG_closure:
         const $cliftA2_r7PG_info;
 },
 $cliftA2_r7PG_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdBO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdBP; else goto cdBQ;
       cdBP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $cliftA2_r7PG_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdBQ: // global
           I64[Sp - 24] = block_cdBJ_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . $cliftA2_r7PG_info" {
     $cliftA2_r7PG_info:
         const $cliftA2_r7PG_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _cdBJ() //  [R1]
         { []
         }
     {offset
       cdBJ: // global
           I64[Sp] = block_cdBL_info;
           _s7WA::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7WA::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdBJ_info" {
     block_cdBJ_info:
         const _cdBJ;
         const 2;
         const 30;
 },
 _cdBL() //  [R1]
         { []
         }
     {offset
       cdBL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdBU; else goto cdBT;
       cdBU: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdBT: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdBL_info" {
     block_cdBL_info:
         const _cdBL;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.752115901 UTC

[section ""data" . GHC.Base.$fApplicativeIO_$cliftA2_closure" {
     GHC.Base.$fApplicativeIO_$cliftA2_closure:
         const GHC.Base.$fApplicativeIO_$cliftA2_info;
 },
 GHC.Base.$fApplicativeIO_$cliftA2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdCd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $cliftA2_r7PG_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeIO_$cliftA2_info" {
     GHC.Base.$fApplicativeIO_$cliftA2_info:
         const GHC.Base.$fApplicativeIO_$cliftA2_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.756323791 UTC

[section ""data" . GHC.Base.liftA1_closure" {
     GHC.Base.liftA1_closure:
         const GHC.Base.liftA1_info;
 },
 GHC.Base.liftA1_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cdCv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdCw; else goto cdCx;
       cdCw: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftA1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdCx: // global
           I64[Sp - 32] = block_cdCo_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftA1_info" {
     GHC.Base.liftA1_info:
         const GHC.Base.liftA1_entry;
         const 0;
         const 14;
         const 21474836504;
 },
 _cdCo() //  [R1]
         { []
         }
     {offset
       cdCo: // global
           I64[Sp] = block_cdCq_info;
           _s7WM::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7WM::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdCo_info" {
     block_cdCo_info:
         const _cdCo;
         const 3;
         const 30;
 },
 _cdCq() //  [R1]
         { []
         }
     {offset
       cdCq: // global
           I64[Sp] = block_cdCs_info;
           _s7WP::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7WP::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdCq_info" {
     block_cdCq_info:
         const _cdCq;
         const 3;
         const 30;
 },
 _cdCs() //  [R1]
         { []
         }
     {offset
       cdCs: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdCC; else goto cdCB;
       cdCC: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdCB: // global
           I64[Hp - 40] = stg_ap_4_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R1 = Hp - 40;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdCs_info" {
     block_cdCs_info:
         const _cdCs;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.765108975 UTC

[section ""data" . GHC.Base.liftA3_$sliftA1_closure" {
     GHC.Base.liftA3_$sliftA1_closure:
         const GHC.Base.liftA3_$sliftA1_info;
 },
 GHC.Base.liftA3_$sliftA1_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cdCZ: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftA1_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftA3_$sliftA1_info" {
     GHC.Base.liftA3_$sliftA1_info:
         const GHC.Base.liftA3_$sliftA1_entry;
         const 0;
         const 14;
         const 21474836504;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.770017448 UTC

[section ""data" . GHC.Base.$fSemigroupIO2_closure" {
     GHC.Base.$fSemigroupIO2_closure:
         const GHC.Base.$fSemigroupIO2_info;
 },
 sat_s7X4_entry() //  [R1]
         { []
         }
     {offset
       cdDi: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdDj; else goto cdDk;
       cdDj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdDk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s7X4_info" {
     sat_s7X4_info:
         const sat_s7X4_entry;
         const 3;
         const 15;
 },
 GHC.Base.$fSemigroupIO2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdDl: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdDm; else goto cdDn;
       cdDm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdDn: // global
           I64[Sp - 24] = block_cdDa_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupIO2_info" {
     GHC.Base.$fSemigroupIO2_info:
         const GHC.Base.$fSemigroupIO2_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _cdDa() //  [R1]
         { []
         }
     {offset
       cdDa: // global
           I64[Sp] = block_cdDc_info;
           _s7X0::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7X0::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdDa_info" {
     block_cdDa_info:
         const _cdDa;
         const 2;
         const 30;
 },
 _cdDc() //  [R1]
         { []
         }
     {offset
       cdDc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdDr; else goto cdDq;
       cdDr: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdDq: // global
           I64[Hp - 32] = sat_s7X4_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdDc_info" {
     block_cdDc_info:
         const _cdDc;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.780710443 UTC

[section ""data" . GHC.Base.$w$csconcat4_closure" {
     GHC.Base.$w$csconcat4_closure:
         const GHC.Base.$w$csconcat4_info;
 },
 sat_s7Xm_entry() //  [R1]
         { []
         }
     {offset
       cdE9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdEa; else goto cdEb;
       cdEa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdEb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s7Xm_info" {
     sat_s7Xm_info:
         const sat_s7Xm_entry;
         const 3;
         const 15;
 },
 go_s7X9_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cdEg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdEh; else goto cdEi;
       cdEh: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdEi: // global
           I64[Sp - 32] = block_cdDV_info;
           _s7X9::P64 = R1;
           _s7X5::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 24] = _s7X5::P64;
           P64[Sp - 16] = _s7X9::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udEq; else goto cdDW;
       udEq: // global
           call _cdDV(R1) args: 0, res: 0, upd: 0;
       cdDW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_s7X9_info" {
     go_s7X9_info:
         const go_s7X9_entry;
         const 1;
         const 9;
         const 12884901903;
 },
 _cdDV() //  [R1]
         { []
         }
     {offset
       cdDV: // global
           _s7Xa::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cdEd; else goto cdEe;
       cdEd: // global
           R1 = _s7Xa::P64;
           Sp = Sp + 32;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       cdEe: // global
           I64[Sp - 8] = block_cdE1_info;
           _s7Xe::P64 = P64[R1 + 6];
           _s7Xf::P64 = P64[R1 + 14];
           R1 = _s7Xa::P64;
           P64[Sp] = _s7Xf::P64;
           P64[Sp + 24] = _s7Xe::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdDV_info" {
     block_cdDV_info:
         const _cdDV;
         const 3;
         const 30;
 },
 _cdE1() //  [R1]
         { []
         }
     {offset
       cdE1: // global
           _s7Xf::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cdE3_info;
           R3 = _s7Xf::P64;
           R2 = P64[Sp + 32];
           _s7Xi::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 32] = _s7Xi::P64;
           Sp = Sp + 8;
           call go_s7X9_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdE1_info" {
     block_cdE1_info:
         const _cdE1;
         const 4;
         const 30;
 },
 _cdE3() //  [R1]
         { []
         }
     {offset
       cdE3: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdEp; else goto cdEo;
       cdEp: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdEo: // global
           I64[Hp - 32] = sat_s7Xm_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdE3_info" {
     block_cdE3_info:
         const _cdE3;
         const 131;
         const 30;
 },
 GHC.Base.$w$csconcat4_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdEr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdEv; else goto cdEu;
       cdEv: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdEu: // global
           I64[Hp - 8] = go_s7X9_info;
           P64[Hp] = R2;
           _s7X6::P64 = R3;
           R3 = R4;
           R2 = _s7X6::P64;
           R1 = Hp - 5;
           call go_s7X9_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$csconcat4_info" {
     GHC.Base.$w$csconcat4_info:
         const GHC.Base.$w$csconcat4_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.793964761 UTC

[section ""data" . GHC.Base.$fSemigroupIO1_closure" {
     GHC.Base.$fSemigroupIO1_closure:
         const GHC.Base.$fSemigroupIO1_info;
 },
 GHC.Base.$fSemigroupIO1_entry() //  [R2, R3]
         { []
         }
     {offset
       cdF6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdF7; else goto cdF8;
       cdF7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdF8: // global
           I64[Sp - 16] = block_cdF3_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udFc; else goto cdF4;
       udFc: // global
           call _cdF3(R1) args: 0, res: 0, upd: 0;
       cdF4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupIO1_info" {
     GHC.Base.$fSemigroupIO1_info:
         const GHC.Base.$fSemigroupIO1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cdF3() //  [R1]
         { []
         }
     {offset
       cdF3: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat4_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdF3_info" {
     block_cdF3_info:
         const _cdF3;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.801429699 UTC

[section ""data" . GHC.Base.$fSemigroupIO_closure" {
     GHC.Base.$fSemigroupIO_closure:
         const GHC.Base.$fSemigroupIO_info;
         const 0;
 },
 sat_s7Xw_entry() //  [R1, R2]
         { []
         }
     {offset
       cdFv: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroupIO_$cstimes_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7Xw_info" {
     sat_s7Xw_info:
         const sat_s7Xw_entry;
         const 1;
         const 4294967305;
         const 4294967301;
         const S8R0_srt;
 },
 sat_s7Xv_entry() //  [R1, R2]
         { []
         }
     {offset
       cdFD: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fSemigroupIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7Xv_info" {
     sat_s7Xv_info:
         const sat_s7Xv_entry;
         const 1;
         const 9;
         const 8589934597;
 },
 sat_s7Xu_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cdFL: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroupIO2_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7Xu_info" {
     sat_s7Xu_info:
         const sat_s7Xu_entry;
         const 1;
         const 9;
         const 12884901903;
 },
 GHC.Base.$fSemigroupIO_entry() //  [R2]
         { []
         }
     {offset
       cdFP: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cdFT; else goto cdFS;
       cdFT: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdFS: // global
           I64[Hp - 72] = sat_s7Xw_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s7Xv_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s7Xu_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 37;
           P64[Hp - 8] = Hp - 54;
           P64[Hp] = Hp - 71;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupIO_info" {
     GHC.Base.$fSemigroupIO_info:
         const GHC.Base.$fSemigroupIO_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S8R0_srt;
 },
 section ""data" . GHC.Base.$fSemigroupIO_$cstimes_closure" {
     GHC.Base.$fSemigroupIO_$cstimes_closure:
         const GHC.Base.$fSemigroupIO_$cstimes_info;
         const 0;
 },
 sat_s7Xz_entry() //  [R1]
         { []
         }
     {offset
       cdG2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdG3; else goto cdG4;
       cdG3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdG4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fSemigroupIO_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s7Xz_info" {
     sat_s7Xz_info:
         const sat_s7Xz_entry;
         const 1;
         const 4294967312;
         const S8R0_srt+8;
 },
 GHC.Base.$fSemigroupIO_$cstimes_entry() //  [R2, R3]
         { []
         }
     {offset
       cdG5: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdG9; else goto cdG8;
       cdG9: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO_$cstimes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdG8: // global
           I64[Hp - 16] = sat_s7Xz_info;
           P64[Hp] = R2;
           _s7Xy::P64 = R3;
           R3 = Hp - 16;
           R2 = _s7Xy::P64;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupIO_$cstimes_info" {
     GHC.Base.$fSemigroupIO_$cstimes_info:
         const GHC.Base.$fSemigroupIO_$cstimes_entry;
         const 0;
         const 30064771086;
         const 8589934607;
         const S8R0_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.814912989 UTC

[section ""data" . GHC.Base.$fMonoidIO_$cp1Monoid_closure" {
     GHC.Base.$fMonoidIO_$cp1Monoid_closure:
         const GHC.Base.$fMonoidIO_$cp1Monoid_info;
         const 0;
 },
 sat_s7XB_entry() //  [R1]
         { []
         }
     {offset
       cdGH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdGI; else goto cdGJ;
       cdGI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdGJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s7XB_info" {
     sat_s7XB_info:
         const sat_s7XB_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fMonoidIO_$cp1Monoid_entry() //  [R2]
         { []
         }
     {offset
       cdGK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdGO; else goto cdGN;
       cdGO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fMonoidIO_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdGN: // global
           I64[Hp - 16] = sat_s7XB_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroupIO_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoidIO_$cp1Monoid_info" {
     GHC.Base.$fMonoidIO_$cp1Monoid_info:
         const GHC.Base.$fMonoidIO_$cp1Monoid_entry;
         const 0;
         const 21474836494;
         const 4294967301;
         const S8R0_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.822140907 UTC

[section ""data" . $cmappend_r7PH_closure" {
     $cmappend_r7PH_closure:
         const $cmappend_r7PH_info;
 },
 sat_s7XN_entry() //  [R1]
         { []
         }
     {offset
       cdHb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdHc; else goto cdHd;
       cdHc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdHd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdH9_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s7XN_info" {
     sat_s7XN_info:
         const sat_s7XN_entry;
         const 3;
         const 15;
 },
 _cdH9() //  [R1]
         { []
         }
     {offset
       cdH9: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdH9_info" {
     block_cdH9_info:
         const _cdH9;
         const 2;
         const 30;
 },
 $cmappend_r7PH_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdHh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdHi; else goto cdHj;
       cdHi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $cmappend_r7PH_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdHj: // global
           I64[Sp - 24] = block_cdH1_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . $cmappend_r7PH_info" {
     $cmappend_r7PH_info:
         const $cmappend_r7PH_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _cdH1() //  [R1]
         { []
         }
     {offset
       cdH1: // global
           I64[Sp] = block_cdH3_info;
           _s7XI::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7XI::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdH1_info" {
     block_cdH1_info:
         const _cdH1;
         const 2;
         const 30;
 },
 _cdH3() //  [R1]
         { []
         }
     {offset
       cdH3: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdHn; else goto cdHm;
       cdHn: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdHm: // global
           I64[Hp - 32] = sat_s7XN_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdH3_info" {
     block_cdH3_info:
         const _cdH3;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.8320831 UTC

[section ""data" . GHC.Base.$fMonoidIO_$cmappend_closure" {
     GHC.Base.$fMonoidIO_$cmappend_closure:
         const GHC.Base.$fMonoidIO_$cmappend_info;
 },
 GHC.Base.$fMonoidIO_$cmappend_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdHP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $cmappend_r7PH_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoidIO_$cmappend_info" {
     GHC.Base.$fMonoidIO_$cmappend_info:
         const GHC.Base.$fMonoidIO_$cmappend_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.835743326 UTC

[section ""data" . GHC.Base.$fAlternativeIO1_closure" {
     GHC.Base.$fAlternativeIO1_closure:
         const GHC.Base.$fAlternativeIO1_info;
 },
 GHC.Base.$fAlternativeIO1_entry() //  []
         { []
         }
     {offset
       cdI0: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fAlternativeIO1_info" {
     GHC.Base.$fAlternativeIO1_info:
         const GHC.Base.$fAlternativeIO1_entry;
         const 0;
         const 14;
         const 4294967299;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.840345404 UTC

[section ""data" . GHC.Base.$fAlternativeIO2_closure" {
     GHC.Base.$fAlternativeIO2_closure:
         const GHC.Base.$fAlternativeIO2_info;
         const 0;
 },
 some_v_s7XR_entry() //  [R1]
         { []
         }
     {offset
       cdIm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdIn; else goto cdIo;
       cdIn: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdIo: // global
           I64[Sp - 16] = block_cdIh_info;
           _s7XR::P64 = R1;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _s7XR::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . some_v_s7XR_info" {
     some_v_s7XR_info:
         const some_v_s7XR_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const S8R0_srt+32;
 },
 _cdIh() //  [R1]
         { []
         }
     {offset
       cdIh: // global
           I64[Sp] = block_cdIj_info;
           R3 = GHC.Base.$fAlternativeIO1_closure+1;
           R2 = P64[Sp + 8];
           _s7XV::P64 = R1;
           R1 = GHC.IO.mplusIO_closure;
           P64[Sp + 8] = _s7XV::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdIh_info" {
     block_cdIh_info:
         const _cdIh;
         const 1;
         const 4294967326;
         const S8R0_srt+32;
 },
 _cdIj() //  [R1]
         { []
         }
     {offset
       cdIj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdIs; else goto cdIr;
       cdIs: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdIr: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdIj_info" {
     block_cdIj_info:
         const _cdIj;
         const 1;
         const 30;
 },
 GHC.Base.$fAlternativeIO2_entry() //  [R2]
         { []
         }
     {offset
       cdIt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdIx; else goto cdIw;
       cdIx: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeIO2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdIw: // global
           I64[Hp - 8] = some_v_s7XR_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call some_v_s7XR_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fAlternativeIO2_info" {
     GHC.Base.$fAlternativeIO2_info:
         const GHC.Base.$fAlternativeIO2_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const S8R0_srt+32;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.850738305 UTC

[section ""data" . GHC.Base.$fAlternativeIO_$cmany_closure" {
     GHC.Base.$fAlternativeIO_$cmany_closure:
         const GHC.Base.$fAlternativeIO_$cmany_info;
         const 0;
 },
 sat_s7Ya_entry() //  [R1]
         { []
         }
     {offset
       cdJ6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdJ7; else goto cdJ8;
       cdJ7: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cdJ8: // global
           I64[Sp - 16] = block_cdJ1_info;
           _s7Y1::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _s7Y1::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7Ya_info" {
     sat_s7Ya_info:
         const sat_s7Ya_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _cdJ1() //  [R1]
         { []
         }
     {offset
       cdJ1: // global
           I64[Sp] = block_cdJ3_info;
           _s7Y5::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s7Y5::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdJ1_info" {
     block_cdJ1_info:
         const _cdJ1;
         const 1;
         const 30;
 },
 _cdJ3() //  [R1]
         { []
         }
     {offset
       cdJ3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdJc; else goto cdJb;
       cdJc: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdJb: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdJ3_info" {
     block_cdJ3_info:
         const _cdJ3;
         const 1;
         const 30;
 },
 many_v_s7Y1_entry() //  [R1]
         { []
         }
     {offset
       cdJd: // global
           _s7Y1::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdJe; else goto cdJf;
       cdJf: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdJh; else goto cdJg;
       cdJh: // global
           HpAlloc = 24;
           goto cdJe;
       cdJe: // global
           R1 = _s7Y1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdJg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s7Y1::P64;
           _s7Y0::P64 = P64[_s7Y1::P64 + 16];
           I64[Hp - 16] = sat_s7Ya_info;
           P64[Hp - 8] = _s7Y0::P64;
           P64[Hp] = _s7Y1::P64;
           R3 = GHC.Base.$fAlternativeIO1_closure+1;
           R2 = Hp - 15;
           R1 = GHC.IO.mplusIO_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . many_v_s7Y1_info" {
     many_v_s7Y1_info:
         const many_v_s7Y1_entry;
         const 1;
         const 4294967312;
         const S8R0_srt+32;
 },
 GHC.Base.$fAlternativeIO_$cmany_entry() //  [R2]
         { []
         }
     {offset
       cdJi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdJm; else goto cdJl;
       cdJm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeIO_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdJl: // global
           I64[Hp - 16] = many_v_s7Y1_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fAlternativeIO_$cmany_info" {
     GHC.Base.$fAlternativeIO_$cmany_info:
         const GHC.Base.$fAlternativeIO_$cmany_entry;
         const 0;
         const 21474836494;
         const 4294967301;
         const S8R0_srt+32;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.862858893 UTC

[section ""data" . GHC.Base.liftM9_closure" {
     GHC.Base.liftM9_closure:
         const GHC.Base.liftM9_info;
 },
 GHC.Base.liftM9_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cdJW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdJX; else goto cdJY;
       cdJX: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM9_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdJY: // global
           I64[Sp - 40] = block_cdJL_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM9_info" {
     GHC.Base.liftM9_info:
         const GHC.Base.liftM9_entry;
         const 0;
         const 14;
         const 30064771098;
 },
 _cdJL() //  [R1]
         { []
         }
     {offset
       cdJL: // global
           I64[Sp] = block_cdJN_info;
           _s7Yk::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7Yk::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdJL_info" {
     block_cdJL_info:
         const _cdJL;
         const 5;
         const 30;
 },
 _cdJN() //  [R1]
         { []
         }
     {offset
       cdJN: // global
           I64[Sp] = block_cdJP_info;
           _s7Yn::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7Yn::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdJN_info" {
     block_cdJN_info:
         const _cdJN;
         const 5;
         const 30;
 },
 _cdJP() //  [R1]
         { []
         }
     {offset
       cdJP: // global
           I64[Sp] = block_cdJR_info;
           _s7Yq::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _s7Yq::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdJP_info" {
     block_cdJP_info:
         const _cdJP;
         const 5;
         const 30;
 },
 _cdJR() //  [R1]
         { []
         }
     {offset
       cdJR: // global
           I64[Sp] = block_cdJT_info;
           _s7Yt::P64 = R1;
           R1 = P64[Sp + 40];
           P64[Sp + 40] = _s7Yt::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdJR_info" {
     block_cdJR_info:
         const _cdJR;
         const 5;
         const 30;
 },
 _cdJT() //  [R1]
         { []
         }
     {offset
       cdJT: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdK5; else goto cdK4;
       cdK5: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdK4: // global
           I64[Hp - 56] = stg_ap_6_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R1 = Hp - 56;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdJT_info" {
     block_cdJT_info:
         const _cdJT;
         const 5;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.874581617 UTC

[section ""data" . GHC.Base.liftM5_$sliftM1_closure" {
     GHC.Base.liftM5_$sliftM1_closure:
         const GHC.Base.liftM5_$sliftM1_info;
 },
 GHC.Base.liftM5_$sliftM1_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cdKA: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftM9_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM5_$sliftM1_info" {
     GHC.Base.liftM5_$sliftM1_info:
         const GHC.Base.liftM5_$sliftM1_entry;
         const 0;
         const 14;
         const 30064771098;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.882832471 UTC

[section ""data" . GHC.Base.liftM5_closure" {
     GHC.Base.liftM5_closure:
         const GHC.Base.liftM5_info;
 },
 GHC.Base.liftM5_slow() //  [R1]
         { []
         }
     {offset
       cdKI: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.liftM5_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2,
                                      R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s7YL_entry() //  [R1, R2]
         { []
         }
     {offset
       cdLc: // global
           _s7YJ::P64 = R2;
           _s7YL::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdLd; else goto cdLe;
       cdLe: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdLg; else goto cdLf;
       cdLg: // global
           HpAlloc = 64;
           goto cdLd;
       cdLd: // global
           R2 = _s7YJ::P64;
           R1 = _s7YL::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLf: // global
           _s7Yy::P64 = P64[_s7YL::P64 + 7];
           _s7Yz::P64 = P64[_s7YL::P64 + 15];
           _s7YF::P64 = P64[_s7YL::P64 + 23];
           _s7YG::P64 = P64[_s7YL::P64 + 31];
           _s7YH::P64 = P64[_s7YL::P64 + 39];
           _s7YI::P64 = P64[_s7YL::P64 + 47];
           I64[Hp - 56] = stg_ap_6_upd_info;
           P64[Hp - 40] = _s7Yz::P64;
           P64[Hp - 32] = _s7YF::P64;
           P64[Hp - 24] = _s7YG::P64;
           P64[Hp - 16] = _s7YH::P64;
           P64[Hp - 8] = _s7YI::P64;
           P64[Hp] = _s7YJ::P64;
           R2 = _s7Yy::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7YL_info" {
     sat_s7YL_info:
         const sat_s7YL_entry;
         const 6;
         const 8;
         const 4294967301;
 },
 sat_s7YM_entry() //  [R1, R2]
         { []
         }
     {offset
       cdLh: // global
           _s7YI::P64 = R2;
           _s7YM::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLi; else goto cdLj;
       cdLj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdLl; else goto cdLk;
       cdLl: // global
           HpAlloc = 56;
           goto cdLi;
       cdLi: // global
           R2 = _s7YI::P64;
           R1 = _s7YM::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLk: // global
           _s7Yy::P64 = P64[_s7YM::P64 + 7];
           _s7Yz::P64 = P64[_s7YM::P64 + 15];
           _s7YE::P64 = P64[_s7YM::P64 + 23];
           _s7YF::P64 = P64[_s7YM::P64 + 31];
           _s7YG::P64 = P64[_s7YM::P64 + 39];
           _s7YH::P64 = P64[_s7YM::P64 + 47];
           I64[Hp - 48] = sat_s7YL_info;
           P64[Hp - 40] = _s7Yy::P64;
           P64[Hp - 32] = _s7Yz::P64;
           P64[Hp - 24] = _s7YF::P64;
           P64[Hp - 16] = _s7YG::P64;
           P64[Hp - 8] = _s7YH::P64;
           P64[Hp] = _s7YI::P64;
           R2 = _s7Yy::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7YE::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7YM_info" {
     sat_s7YM_info:
         const sat_s7YM_entry;
         const 6;
         const 8;
         const 4294967301;
 },
 sat_s7YN_entry() //  [R1, R2]
         { []
         }
     {offset
       cdLm: // global
           _s7YH::P64 = R2;
           _s7YN::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLn; else goto cdLo;
       cdLo: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdLq; else goto cdLp;
       cdLq: // global
           HpAlloc = 56;
           goto cdLn;
       cdLn: // global
           R2 = _s7YH::P64;
           R1 = _s7YN::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLp: // global
           _s7Yy::P64 = P64[_s7YN::P64 + 7];
           _s7Yz::P64 = P64[_s7YN::P64 + 15];
           _s7YD::P64 = P64[_s7YN::P64 + 23];
           _s7YE::P64 = P64[_s7YN::P64 + 31];
           _s7YF::P64 = P64[_s7YN::P64 + 39];
           _s7YG::P64 = P64[_s7YN::P64 + 47];
           I64[Hp - 48] = sat_s7YM_info;
           P64[Hp - 40] = _s7Yy::P64;
           P64[Hp - 32] = _s7Yz::P64;
           P64[Hp - 24] = _s7YE::P64;
           P64[Hp - 16] = _s7YF::P64;
           P64[Hp - 8] = _s7YG::P64;
           P64[Hp] = _s7YH::P64;
           R2 = _s7Yy::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7YD::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7YN_info" {
     sat_s7YN_info:
         const sat_s7YN_entry;
         const 6;
         const 8;
         const 4294967301;
 },
 sat_s7YO_entry() //  [R1, R2]
         { []
         }
     {offset
       cdLr: // global
           _s7YG::P64 = R2;
           _s7YO::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLs; else goto cdLt;
       cdLt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdLv; else goto cdLu;
       cdLv: // global
           HpAlloc = 56;
           goto cdLs;
       cdLs: // global
           R2 = _s7YG::P64;
           R1 = _s7YO::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLu: // global
           _s7Yy::P64 = P64[_s7YO::P64 + 7];
           _s7Yz::P64 = P64[_s7YO::P64 + 15];
           _s7YC::P64 = P64[_s7YO::P64 + 23];
           _s7YD::P64 = P64[_s7YO::P64 + 31];
           _s7YE::P64 = P64[_s7YO::P64 + 39];
           _s7YF::P64 = P64[_s7YO::P64 + 47];
           I64[Hp - 48] = sat_s7YN_info;
           P64[Hp - 40] = _s7Yy::P64;
           P64[Hp - 32] = _s7Yz::P64;
           P64[Hp - 24] = _s7YD::P64;
           P64[Hp - 16] = _s7YE::P64;
           P64[Hp - 8] = _s7YF::P64;
           P64[Hp] = _s7YG::P64;
           R2 = _s7Yy::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7YC::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7YO_info" {
     sat_s7YO_info:
         const sat_s7YO_entry;
         const 6;
         const 8;
         const 4294967301;
 },
 sat_s7YP_entry() //  [R1, R2]
         { []
         }
     {offset
       cdLw: // global
           _s7YF::P64 = R2;
           _s7YP::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdLx; else goto cdLy;
       cdLy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdLA; else goto cdLz;
       cdLA: // global
           HpAlloc = 56;
           goto cdLx;
       cdLx: // global
           R2 = _s7YF::P64;
           R1 = _s7YP::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdLz: // global
           _s7Yy::P64 = P64[_s7YP::P64 + 7];
           _s7Yz::P64 = P64[_s7YP::P64 + 15];
           _s7YB::P64 = P64[_s7YP::P64 + 23];
           _s7YC::P64 = P64[_s7YP::P64 + 31];
           _s7YD::P64 = P64[_s7YP::P64 + 39];
           _s7YE::P64 = P64[_s7YP::P64 + 47];
           I64[Hp - 48] = sat_s7YO_info;
           P64[Hp - 40] = _s7Yy::P64;
           P64[Hp - 32] = _s7Yz::P64;
           P64[Hp - 24] = _s7YC::P64;
           P64[Hp - 16] = _s7YD::P64;
           P64[Hp - 8] = _s7YE::P64;
           P64[Hp] = _s7YF::P64;
           R2 = _s7Yy::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7YB::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7YP_info" {
     sat_s7YP_info:
         const sat_s7YP_entry;
         const 6;
         const 8;
         const 4294967301;
 },
 GHC.Base.liftM5_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cdLB: // global
           _s7YC::P64 = R6;
           _s7YB::P64 = R5;
           _s7YA::P64 = R4;
           _s7Yz::P64 = R3;
           _s7Yy::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cdLC; else goto cdLD;
       cdLD: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdLF; else goto cdLE;
       cdLF: // global
           HpAlloc = 56;
           goto cdLC;
       cdLC: // global
           R1 = GHC.Base.liftM5_closure;
           P64[Sp - 40] = _s7Yy::P64;
           P64[Sp - 32] = _s7Yz::P64;
           P64[Sp - 24] = _s7YA::P64;
           P64[Sp - 16] = _s7YB::P64;
           P64[Sp - 8] = _s7YC::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cdLE: // global
           I64[Hp - 48] = sat_s7YP_info;
           P64[Hp - 40] = _s7Yy::P64;
           P64[Hp - 32] = _s7Yz::P64;
           P64[Hp - 24] = _s7YB::P64;
           P64[Hp - 16] = _s7YC::P64;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = P64[Sp + 8];
           R2 = _s7Yy::P64;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s7YA::P64;
           P64[Sp + 8] = Hp - 47;
           Sp = Sp - 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM5_info" {
     GHC.Base.liftM5_info:
         const GHC.Base.liftM5_entry;
         const 0;
         const 14;
         const 30064771072;
         const 0;
         const 7;
         const GHC.Base.liftM5_slow;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.899821884 UTC

[section ""data" . GHC.Base.liftM8_closure" {
     GHC.Base.liftM8_closure:
         const GHC.Base.liftM8_info;
 },
 GHC.Base.liftM8_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cdMs: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdMt; else goto cdMu;
       cdMt: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM8_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdMu: // global
           I64[Sp - 40] = block_cdMj_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM8_info" {
     GHC.Base.liftM8_info:
         const GHC.Base.liftM8_entry;
         const 0;
         const 14;
         const 25769803801;
 },
 _cdMj() //  [R1]
         { []
         }
     {offset
       cdMj: // global
           I64[Sp] = block_cdMl_info;
           _s7YY::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7YY::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdMj_info" {
     block_cdMj_info:
         const _cdMj;
         const 4;
         const 30;
 },
 _cdMl() //  [R1]
         { []
         }
     {offset
       cdMl: // global
           I64[Sp] = block_cdMn_info;
           _s7Z1::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s7Z1::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdMl_info" {
     block_cdMl_info:
         const _cdMl;
         const 4;
         const 30;
 },
 _cdMn() //  [R1]
         { []
         }
     {offset
       cdMn: // global
           I64[Sp] = block_cdMp_info;
           _s7Z4::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _s7Z4::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdMn_info" {
     block_cdMn_info:
         const _cdMn;
         const 4;
         const 30;
 },
 _cdMp() //  [R1]
         { []
         }
     {offset
       cdMp: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdMA; else goto cdMz;
       cdMA: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdMz: // global
           I64[Hp - 48] = stg_ap_5_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R1 = Hp - 48;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdMp_info" {
     block_cdMp_info:
         const _cdMp;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.909973087 UTC

[section ""data" . GHC.Base.liftM4_$sliftM1_closure" {
     GHC.Base.liftM4_$sliftM1_closure:
         const GHC.Base.liftM4_$sliftM1_info;
 },
 GHC.Base.liftM4_$sliftM1_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cdN1: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftM8_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM4_$sliftM1_info" {
     GHC.Base.liftM4_$sliftM1_info:
         const GHC.Base.liftM4_$sliftM1_entry;
         const 0;
         const 14;
         const 25769803801;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.916533748 UTC

[section ""data" . GHC.Base.liftM4_closure" {
     GHC.Base.liftM4_closure:
         const GHC.Base.liftM4_info;
 },
 sat_s7Zk_entry() //  [R1, R2]
         { []
         }
     {offset
       cdNx: // global
           _s7Zi::P64 = R2;
           _s7Zk::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNy; else goto cdNz;
       cdNz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cdNB; else goto cdNA;
       cdNB: // global
           HpAlloc = 56;
           goto cdNy;
       cdNy: // global
           R2 = _s7Zi::P64;
           R1 = _s7Zk::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNA: // global
           _s7Z9::P64 = P64[_s7Zk::P64 + 7];
           _s7Za::P64 = P64[_s7Zk::P64 + 15];
           _s7Zf::P64 = P64[_s7Zk::P64 + 23];
           _s7Zg::P64 = P64[_s7Zk::P64 + 31];
           _s7Zh::P64 = P64[_s7Zk::P64 + 39];
           I64[Hp - 48] = stg_ap_5_upd_info;
           P64[Hp - 32] = _s7Za::P64;
           P64[Hp - 24] = _s7Zf::P64;
           P64[Hp - 16] = _s7Zg::P64;
           P64[Hp - 8] = _s7Zh::P64;
           P64[Hp] = _s7Zi::P64;
           R2 = _s7Z9::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7Zk_info" {
     sat_s7Zk_info:
         const sat_s7Zk_entry;
         const 5;
         const 8;
         const 4294967301;
 },
 sat_s7Zl_entry() //  [R1, R2]
         { []
         }
     {offset
       cdNC: // global
           _s7Zh::P64 = R2;
           _s7Zl::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdND; else goto cdNE;
       cdNE: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdNG; else goto cdNF;
       cdNG: // global
           HpAlloc = 48;
           goto cdND;
       cdND: // global
           R2 = _s7Zh::P64;
           R1 = _s7Zl::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNF: // global
           _s7Z9::P64 = P64[_s7Zl::P64 + 7];
           _s7Za::P64 = P64[_s7Zl::P64 + 15];
           _s7Ze::P64 = P64[_s7Zl::P64 + 23];
           _s7Zf::P64 = P64[_s7Zl::P64 + 31];
           _s7Zg::P64 = P64[_s7Zl::P64 + 39];
           I64[Hp - 40] = sat_s7Zk_info;
           P64[Hp - 32] = _s7Z9::P64;
           P64[Hp - 24] = _s7Za::P64;
           P64[Hp - 16] = _s7Zf::P64;
           P64[Hp - 8] = _s7Zg::P64;
           P64[Hp] = _s7Zh::P64;
           R2 = _s7Z9::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Ze::P64;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7Zl_info" {
     sat_s7Zl_info:
         const sat_s7Zl_entry;
         const 5;
         const 8;
         const 4294967301;
 },
 sat_s7Zm_entry() //  [R1, R2]
         { []
         }
     {offset
       cdNH: // global
           _s7Zg::P64 = R2;
           _s7Zm::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdNI; else goto cdNJ;
       cdNJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdNL; else goto cdNK;
       cdNL: // global
           HpAlloc = 48;
           goto cdNI;
       cdNI: // global
           R2 = _s7Zg::P64;
           R1 = _s7Zm::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNK: // global
           _s7Z9::P64 = P64[_s7Zm::P64 + 7];
           _s7Za::P64 = P64[_s7Zm::P64 + 15];
           _s7Zd::P64 = P64[_s7Zm::P64 + 23];
           _s7Ze::P64 = P64[_s7Zm::P64 + 31];
           _s7Zf::P64 = P64[_s7Zm::P64 + 39];
           I64[Hp - 40] = sat_s7Zl_info;
           P64[Hp - 32] = _s7Z9::P64;
           P64[Hp - 24] = _s7Za::P64;
           P64[Hp - 16] = _s7Ze::P64;
           P64[Hp - 8] = _s7Zf::P64;
           P64[Hp] = _s7Zg::P64;
           R2 = _s7Z9::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Zd::P64;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7Zm_info" {
     sat_s7Zm_info:
         const sat_s7Zm_entry;
         const 5;
         const 8;
         const 4294967301;
 },
 sat_s7Zn_entry() //  [R1, R2]
         { []
         }
     {offset
       cdNM: // global
           _s7Zf::P64 = R2;
           _s7Zn::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdNN; else goto cdNO;
       cdNO: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdNQ; else goto cdNP;
       cdNQ: // global
           HpAlloc = 48;
           goto cdNN;
       cdNN: // global
           R2 = _s7Zf::P64;
           R1 = _s7Zn::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdNP: // global
           _s7Z9::P64 = P64[_s7Zn::P64 + 7];
           _s7Za::P64 = P64[_s7Zn::P64 + 15];
           _s7Zc::P64 = P64[_s7Zn::P64 + 23];
           _s7Zd::P64 = P64[_s7Zn::P64 + 31];
           _s7Ze::P64 = P64[_s7Zn::P64 + 39];
           I64[Hp - 40] = sat_s7Zm_info;
           P64[Hp - 32] = _s7Z9::P64;
           P64[Hp - 24] = _s7Za::P64;
           P64[Hp - 16] = _s7Zd::P64;
           P64[Hp - 8] = _s7Ze::P64;
           P64[Hp] = _s7Zf::P64;
           R2 = _s7Z9::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Zc::P64;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7Zn_info" {
     sat_s7Zn_info:
         const sat_s7Zn_entry;
         const 5;
         const 8;
         const 4294967301;
 },
 GHC.Base.liftM4_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cdNR: // global
           _s7Zd::P64 = R6;
           _s7Zc::P64 = R5;
           _s7Zb::P64 = R4;
           _s7Za::P64 = R3;
           _s7Z9::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cdNS; else goto cdNT;
       cdNT: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdNV; else goto cdNU;
       cdNV: // global
           HpAlloc = 48;
           goto cdNS;
       cdNS: // global
           R6 = _s7Zd::P64;
           R5 = _s7Zc::P64;
           R4 = _s7Zb::P64;
           R3 = _s7Za::P64;
           R2 = _s7Z9::P64;
           R1 = GHC.Base.liftM4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cdNU: // global
           I64[Hp - 40] = sat_s7Zn_info;
           P64[Hp - 32] = _s7Z9::P64;
           P64[Hp - 24] = _s7Za::P64;
           P64[Hp - 16] = _s7Zc::P64;
           P64[Hp - 8] = _s7Zd::P64;
           P64[Hp] = P64[Sp];
           R2 = _s7Z9::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _s7Zb::P64;
           P64[Sp] = Hp - 39;
           Sp = Sp - 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM4_info" {
     GHC.Base.liftM4_info:
         const GHC.Base.liftM4_entry;
         const 0;
         const 14;
         const 25769803802;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.928958941 UTC

[section ""data" . GHC.Base.liftM3_$sliftM1_closure" {
     GHC.Base.liftM3_$sliftM1_closure:
         const GHC.Base.liftM3_$sliftM1_info;
 },
 GHC.Base.liftM3_$sliftM1_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cdOr: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftA1_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM3_$sliftM1_info" {
     GHC.Base.liftM3_$sliftM1_info:
         const GHC.Base.liftM3_$sliftM1_entry;
         const 0;
         const 14;
         const 21474836504;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.93453741 UTC

[section ""data" . GHC.Base.liftM3_closure" {
     GHC.Base.liftM3_closure:
         const GHC.Base.liftM3_info;
 },
 sat_s7Zx_entry() //  [R1, R2]
         { []
         }
     {offset
       cdOS: // global
           _s7Zv::P64 = R2;
           _s7Zx::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdOT; else goto cdOU;
       cdOU: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cdOW; else goto cdOV;
       cdOW: // global
           HpAlloc = 48;
           goto cdOT;
       cdOT: // global
           R2 = _s7Zv::P64;
           R1 = _s7Zx::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdOV: // global
           _s7Zo::P64 = P64[_s7Zx::P64 + 7];
           _s7Zp::P64 = P64[_s7Zx::P64 + 15];
           _s7Zt::P64 = P64[_s7Zx::P64 + 23];
           _s7Zu::P64 = P64[_s7Zx::P64 + 31];
           I64[Hp - 40] = stg_ap_4_upd_info;
           P64[Hp - 24] = _s7Zp::P64;
           P64[Hp - 16] = _s7Zt::P64;
           P64[Hp - 8] = _s7Zu::P64;
           P64[Hp] = _s7Zv::P64;
           R2 = _s7Zo::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7Zx_info" {
     sat_s7Zx_info:
         const sat_s7Zx_entry;
         const 4;
         const 8;
         const 4294967301;
 },
 sat_s7Zy_entry() //  [R1, R2]
         { []
         }
     {offset
       cdOX: // global
           _s7Zu::P64 = R2;
           _s7Zy::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdOY; else goto cdOZ;
       cdOZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdP1; else goto cdP0;
       cdP1: // global
           HpAlloc = 40;
           goto cdOY;
       cdOY: // global
           R2 = _s7Zu::P64;
           R1 = _s7Zy::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdP0: // global
           _s7Zo::P64 = P64[_s7Zy::P64 + 7];
           _s7Zp::P64 = P64[_s7Zy::P64 + 15];
           _s7Zs::P64 = P64[_s7Zy::P64 + 23];
           _s7Zt::P64 = P64[_s7Zy::P64 + 31];
           I64[Hp - 32] = sat_s7Zx_info;
           P64[Hp - 24] = _s7Zo::P64;
           P64[Hp - 16] = _s7Zp::P64;
           P64[Hp - 8] = _s7Zt::P64;
           P64[Hp] = _s7Zu::P64;
           R2 = _s7Zo::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Zs::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7Zy_info" {
     sat_s7Zy_info:
         const sat_s7Zy_entry;
         const 4;
         const 8;
         const 4294967301;
 },
 sat_s7Zz_entry() //  [R1, R2]
         { []
         }
     {offset
       cdP2: // global
           _s7Zt::P64 = R2;
           _s7Zz::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cdP3; else goto cdP4;
       cdP4: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdP6; else goto cdP5;
       cdP6: // global
           HpAlloc = 40;
           goto cdP3;
       cdP3: // global
           R2 = _s7Zt::P64;
           R1 = _s7Zz::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdP5: // global
           _s7Zo::P64 = P64[_s7Zz::P64 + 7];
           _s7Zp::P64 = P64[_s7Zz::P64 + 15];
           _s7Zr::P64 = P64[_s7Zz::P64 + 23];
           _s7Zs::P64 = P64[_s7Zz::P64 + 31];
           I64[Hp - 32] = sat_s7Zy_info;
           P64[Hp - 24] = _s7Zo::P64;
           P64[Hp - 16] = _s7Zp::P64;
           P64[Hp - 8] = _s7Zs::P64;
           P64[Hp] = _s7Zt::P64;
           R2 = _s7Zo::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Zr::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7Zz_info" {
     sat_s7Zz_info:
         const sat_s7Zz_entry;
         const 4;
         const 8;
         const 4294967301;
 },
 GHC.Base.liftM3_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cdP7: // global
           _s7Zs::P64 = R6;
           _s7Zr::P64 = R5;
           _s7Zq::P64 = R4;
           _s7Zp::P64 = R3;
           _s7Zo::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdP8; else goto cdP9;
       cdP9: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cdPb; else goto cdPa;
       cdPb: // global
           HpAlloc = 40;
           goto cdP8;
       cdP8: // global
           R6 = _s7Zs::P64;
           R5 = _s7Zr::P64;
           R4 = _s7Zq::P64;
           R3 = _s7Zp::P64;
           R2 = _s7Zo::P64;
           R1 = GHC.Base.liftM3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdPa: // global
           I64[Hp - 32] = sat_s7Zz_info;
           P64[Hp - 24] = _s7Zo::P64;
           P64[Hp - 16] = _s7Zp::P64;
           P64[Hp - 8] = _s7Zr::P64;
           P64[Hp] = _s7Zs::P64;
           R2 = _s7Zo::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7Zq::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM3_info" {
     GHC.Base.liftM3_info:
         const GHC.Base.liftM3_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.945111311 UTC

[section ""data" . GHC.Base.liftM_$sliftM1_closure" {
     GHC.Base.liftM_$sliftM1_closure:
         const GHC.Base.liftM_$sliftM1_info;
 },
 GHC.Base.liftM_$sliftM1_entry() //  [R2, R3]
         { []
         }
     {offset
       cdPB: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fFunctorIO2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM_$sliftM1_info" {
     GHC.Base.liftM_$sliftM1_info:
         const GHC.Base.liftM_$sliftM1_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.949305177 UTC

[section ""data" . GHC.Base.liftM_closure" {
     GHC.Base.liftM_closure:
         const GHC.Base.liftM_info;
 },
 sat_s7ZF_entry() //  [R1, R2]
         { []
         }
     {offset
       cdPS: // global
           _s7ZD::P64 = R2;
           _s7ZF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cdPT; else goto cdPU;
       cdPU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdPW; else goto cdPV;
       cdPW: // global
           HpAlloc = 32;
           goto cdPT;
       cdPT: // global
           R2 = _s7ZD::P64;
           R1 = _s7ZF::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdPV: // global
           _s7ZA::P64 = P64[_s7ZF::P64 + 7];
           _s7ZB::P64 = P64[_s7ZF::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s7ZB::P64;
           P64[Hp] = _s7ZD::P64;
           R2 = _s7ZA::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s7ZF_info" {
     sat_s7ZF_info:
         const sat_s7ZF_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 GHC.Base.liftM_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdPX: // global
           _s7ZC::P64 = R4;
           _s7ZB::P64 = R3;
           _s7ZA::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdPY; else goto cdPZ;
       cdPZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdQ1; else goto cdQ0;
       cdQ1: // global
           HpAlloc = 24;
           goto cdPY;
       cdPY: // global
           R4 = _s7ZC::P64;
           R3 = _s7ZB::P64;
           R2 = _s7ZA::P64;
           R1 = GHC.Base.liftM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdQ0: // global
           I64[Hp - 16] = sat_s7ZF_info;
           P64[Hp - 8] = _s7ZA::P64;
           P64[Hp] = _s7ZB::P64;
           R2 = _s7ZA::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s7ZC::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM_info" {
     GHC.Base.liftM_info:
         const GHC.Base.liftM_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.955944852 UTC

[section ""data" . GHC.Base.$!_closure" {
     GHC.Base.$!_closure:
         const GHC.Base.$!_info;
 },
 GHC.Base.$!_entry() //  [R2, R3]
         { []
         }
     {offset
       cdQj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdQk; else goto cdQl;
       cdQk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$!_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdQl: // global
           I64[Sp - 16] = block_cdQh_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$!_info" {
     GHC.Base.$!_info:
         const GHC.Base.$!_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdQh() //  [R1]
         { []
         }
     {offset
       cdQh: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdQh_info" {
     block_cdQh_info:
         const _cdQh;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.960820953 UTC

[section ""data" . GHC.Base.$_closure" {
     GHC.Base.$_closure:
         const GHC.Base.$_info;
 },
 GHC.Base.$_entry() //  [R2, R3]
         { []
         }
     {offset
       cdQz: // global
           _s7ZJ::P64 = R2;
           R2 = R3;
           R1 = _s7ZJ::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$_info" {
     GHC.Base.$_info:
         const GHC.Base.$_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.964182991 UTC

[section ""data" . GHC.Base.flip_closure" {
     GHC.Base.flip_closure:
         const GHC.Base.flip_info;
 },
 GHC.Base.flip_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdQK: // global
           R3 = R3;
           _s7ZL::P64 = R2;
           R2 = R4;
           R1 = _s7ZL::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.flip_info" {
     GHC.Base.flip_info:
         const GHC.Base.flip_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.968007075 UTC

[section ""data" . GHC.Base.$fMonad(->)_$c>>_closure" {
     GHC.Base.$fMonad(->)_$c>>_closure:
         const GHC.Base.$fMonad(->)_$c>>_info;
 },
 GHC.Base.$fMonad(->)_$c>>_entry() //  [R3, R4]
         { []
         }
     {offset
       cdQV: // global
           R2 = R4;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonad(->)_$c>>_info" {
     GHC.Base.$fMonad(->)_$c>>_info:
         const GHC.Base.$fMonad(->)_$c>>_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.971266035 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$c<*_closure" {
     GHC.Base.$fApplicative(->)_$c<*_closure:
         const GHC.Base.$fApplicative(->)_$c<*_info;
 },
 GHC.Base.$fApplicative(->)_$c<*_entry() //  [R2, R4]
         { []
         }
     {offset
       cdR6: // global
           _s7ZR::P64 = R2;
           R2 = R4;
           R1 = _s7ZR::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative(->)_$c<*_info" {
     GHC.Base.$fApplicative(->)_$c<*_info:
         const GHC.Base.$fApplicative(->)_$c<*_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.976546497 UTC

[section ""data" . GHC.Base.$fMonad(,)_$c>>_closure" {
     GHC.Base.$fMonad(,)_$c>>_closure:
         const GHC.Base.$fMonad(,)_$c>>_info;
 },
 sat_s804_entry() //  [R1]
         { []
         }
     {offset
       cdRx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdRy; else goto cdRz;
       cdRy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdRz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdRv_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s804_info" {
     sat_s804_info:
         const sat_s804_entry;
         const 3;
         const 15;
 },
 _cdRv() //  [R1]
         { []
         }
     {offset
       cdRv: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdRv_info" {
     block_cdRv_info:
         const _cdRv;
         const 2;
         const 30;
 },
 GHC.Base.$fMonad(,)_$c>>_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdRD: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdRF; else goto cdRG;
       cdRF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad(,)_$c>>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdRG: // global
           I64[Sp - 24] = block_cdRh_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udRM; else goto cdRi;
       udRM: // global
           call _cdRh(R1) args: 0, res: 0, upd: 0;
       cdRi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonad(,)_$c>>_info" {
     GHC.Base.$fMonad(,)_$c>>_info:
         const GHC.Base.$fMonad(,)_$c>>_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cdRh() //  [R1]
         { []
         }
     {offset
       cdRh: // global
           I64[Sp] = block_cdRm_info;
           _s7ZY::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s7ZY::P64;
           if (R1 & 7 != 0) goto udRL; else goto cdRn;
       udRL: // global
           call _cdRm(R1) args: 0, res: 0, upd: 0;
       cdRn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdRh_info" {
     block_cdRh_info:
         const _cdRh;
         const 2;
         const 30;
 },
 _cdRm() //  [R1]
         { []
         }
     {offset
       cdRm: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdRK; else goto cdRJ;
       cdRK: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdRJ: // global
           _s801::P64 = P64[R1 + 7];
           _s802::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_s804_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s801::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = _s802::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdRm_info" {
     block_cdRm_info:
         const _cdRm;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:44.988706361 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$c<*_closure" {
     GHC.Base.$fApplicative(,)_$c<*_closure:
         const GHC.Base.$fApplicative(,)_$c<*_info;
 },
 sat_s80f_entry() //  [R1]
         { []
         }
     {offset
       cdSx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdSy; else goto cdSz;
       cdSy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdSz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdSv_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s80f_info" {
     sat_s80f_info:
         const sat_s80f_entry;
         const 3;
         const 15;
 },
 _cdSv() //  [R1]
         { []
         }
     {offset
       cdSv: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdSv_info" {
     block_cdSv_info:
         const _cdSv;
         const 2;
         const 30;
 },
 GHC.Base.$fApplicative(,)_$c<*_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdSD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cdSF; else goto cdSG;
       cdSF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$c<*_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdSG: // global
           I64[Sp - 24] = block_cdSh_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto udSM; else goto cdSi;
       udSM: // global
           call _cdSh(R1) args: 0, res: 0, upd: 0;
       cdSi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative(,)_$c<*_info" {
     GHC.Base.$fApplicative(,)_$c<*_info:
         const GHC.Base.$fApplicative(,)_$c<*_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cdSh() //  [R1]
         { []
         }
     {offset
       cdSh: // global
           I64[Sp - 8] = block_cdSm_info;
           _s809::P64 = P64[R1 + 7];
           _s80a::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s80a::P64;
           P64[Sp + 16] = _s809::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udSL; else goto cdSn;
       udSL: // global
           call _cdSm(R1) args: 0, res: 0, upd: 0;
       cdSn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdSh_info" {
     block_cdSh_info:
         const _cdSh;
         const 2;
         const 30;
 },
 _cdSm() //  [R1]
         { []
         }
     {offset
       cdSm: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdSK; else goto cdSJ;
       cdSK: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdSJ: // global
           _s80c::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_s80f_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _s80c::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdSm_info" {
     block_cdSm_info:
         const _cdSm;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.000023598 UTC

[section ""data" . GHC.Base.$fFunctor(,)_$c<$_closure" {
     GHC.Base.$fFunctor(,)_$c<$_closure:
         const GHC.Base.$fFunctor(,)_$c<$_info;
 },
 GHC.Base.$fFunctor(,)_$c<$_entry() //  [R2, R3]
         { []
         }
     {offset
       cdTl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdTp; else goto cdTq;
       cdTp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctor(,)_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdTq: // global
           I64[Sp - 16] = block_cdTi_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udTu; else goto cdTj;
       udTu: // global
           call _cdTi(R1) args: 0, res: 0, upd: 0;
       cdTj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fFunctor(,)_$c<$_info" {
     GHC.Base.$fFunctor(,)_$c<$_info:
         const GHC.Base.$fFunctor(,)_$c<$_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdTi() //  [R1]
         { []
         }
     {offset
       cdTi: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cdTt; else goto cdTs;
       cdTt: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdTs: // global
           _s80j::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _s80j::P64;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdTi_info" {
     block_cdTi_info:
         const _cdTi;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.00604277 UTC

[section ""data" . GHC.Base.$fFunctorMaybe_$c<$_closure" {
     GHC.Base.$fFunctorMaybe_$c<$_closure:
         const GHC.Base.$fFunctorMaybe_$c<$_info;
 },
 GHC.Base.$fFunctorMaybe_$c<$_entry() //  [R2, R3]
         { []
         }
     {offset
       cdTR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdTS; else goto cdTT;
       cdTS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorMaybe_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdTT: // global
           I64[Sp - 16] = block_cdTK_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto udU3; else goto cdTL;
       udU3: // global
           call _cdTK(R1) args: 0, res: 0, upd: 0;
       cdTL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fFunctorMaybe_$c<$_info" {
     GHC.Base.$fFunctorMaybe_$c<$_info:
         const GHC.Base.$fFunctorMaybe_$c<$_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdTK() //  [R1]
         { []
         }
     {offset
       cdTK: // global
           if (R1 & 7 == 1) goto cdTO; else goto cdTP;
       cdTO: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdTP: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdU2; else goto cdU1;
       cdU2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdU1: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdTK_info" {
     block_cdTK_info:
         const _cdTK;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.011899031 UTC

[section ""data" . GHC.Base.$dm<$_closure" {
     GHC.Base.$dm<$_closure:
         const GHC.Base.$dm<$_info;
 },
 sat_s80s_entry() //  [R1]
         { []
         }
     {offset
       cdUr: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s80s_info" {
     sat_s80s_info:
         const sat_s80s_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 GHC.Base.$dm<$_entry() //  [R2, R3]
         { []
         }
     {offset
       cdUu: // global
           _s80q::P64 = R3;
           _s80p::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cdUv; else goto cdUw;
       cdUw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cdUy; else goto cdUx;
       cdUy: // global
           HpAlloc = 16;
           goto cdUv;
       cdUv: // global
           R3 = _s80q::P64;
           R2 = _s80p::P64;
           R1 = GHC.Base.$dm<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdUx: // global
           I64[Hp - 8] = sat_s80s_info;
           P64[Hp] = _s80q::P64;
           R2 = _s80p::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call GHC.Base.fmap_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dm<$_info" {
     GHC.Base.$dm<$_info:
         const GHC.Base.$dm<$_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.017938025 UTC

[section ""data" . GHC.Base.$fMonoid(->)_$cmappend_closure" {
     GHC.Base.$fMonoid(->)_$cmappend_closure:
         const GHC.Base.$fMonoid(->)_$cmappend_info;
 },
 GHC.Base.$fMonoid(->)_$cmappend_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cdUQ: // global
           _s80w::P64 = R5;
           _s80v::P64 = R4;
           _s80u::P64 = R3;
           _s80t::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cdUR; else goto cdUS;
       cdUS: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cdUU; else goto cdUT;
       cdUU: // global
           HpAlloc = 64;
           goto cdUR;
       cdUR: // global
           R5 = _s80w::P64;
           R4 = _s80v::P64;
           R3 = _s80u::P64;
           R2 = _s80t::P64;
           R1 = GHC.Base.$fMonoid(->)_$cmappend_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdUT: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _s80v::P64;
           P64[Hp - 32] = _s80w::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s80u::P64;
           P64[Hp] = _s80w::P64;
           I64[Sp - 24] = block_cdUO_info;
           R2 = _s80t::P64;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(->)_$cmappend_info" {
     GHC.Base.$fMonoid(->)_$cmappend_info:
         const GHC.Base.$fMonoid(->)_$cmappend_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _cdUO() //  [R1]
         { []
         }
     {offset
       cdUO: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cdUM::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cdUM::P64;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdUO_info" {
     block_cdUO_info:
         const _cdUO;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.025391366 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,)_$cmappend_info;
 },
 sat_s80N_entry() //  [R1]
         { []
         }
     {offset
       cdVt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdVu; else goto cdVv;
       cdVu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdVv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdVr_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s80N_info" {
     sat_s80N_info:
         const sat_s80N_entry;
         const 3;
         const 15;
 },
 _cdVr() //  [R1]
         { []
         }
     {offset
       cdVr: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdVr_info" {
     block_cdVr_info:
         const _cdVr;
         const 2;
         const 30;
 },
 sat_s80L_entry() //  [R1]
         { []
         }
     {offset
       cdVF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdVG; else goto cdVH;
       cdVG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cdVH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cdVD_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s80L_info" {
     sat_s80L_info:
         const sat_s80L_entry;
         const 3;
         const 15;
 },
 _cdVD() //  [R1]
         { []
         }
     {offset
       cdVD: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cdVD_info" {
     block_cdVD_info:
         const _cdVD;
         const 2;
         const 30;
 },
 GHC.Base.$fMonoid(,)_$cmappend_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cdVL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cdVN; else goto cdVO;
       cdVN: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cmappend_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdVO: // global
           I64[Sp - 32] = block_cdVd_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto udVU; else goto cdVe;
       udVU: // global
           call _cdVd(R1) args: 0, res: 0, upd: 0;
       cdVe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,)_$cmappend_info" {
     GHC.Base.$fMonoid(,)_$cmappend_info:
         const GHC.Base.$fMonoid(,)_$cmappend_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _cdVd() //  [R1]
         { []
         }
     {offset
       cdVd: // global
           I64[Sp - 8] = block_cdVi_info;
           _s80F::P64 = P64[R1 + 7];
           _s80G::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s80G::P64;
           P64[Sp + 24] = _s80F::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udVT; else goto cdVj;
       udVT: // global
           call _cdVi(R1) args: 0, res: 0, upd: 0;
       cdVj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdVd_info" {
     block_cdVd_info:
         const _cdVd;
         const 3;
         const 30;
 },
 _cdVi() //  [R1]
         { []
         }
     {offset
       cdVi: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cdVS; else goto cdVR;
       cdVS: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cdVR: // global
           _s80I::P64 = P64[R1 + 7];
           _s80J::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_s80N_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _s80J::P64;
           I64[Hp - 56] = sat_s80L_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _s80I::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdVi_info" {
     block_cdVi_info:
         const _cdVi;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.040105137 UTC

[section ""data" . GHC.Base.$fSemigroupOrdering_go_closure" {
     GHC.Base.$fSemigroupOrdering_go_closure:
         const GHC.Base.$fSemigroupOrdering_go_info;
 },
 GHC.Base.$fSemigroupOrdering_go_entry() //  [R2, R3]
         { []
         }
     {offset
       cdWI: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cdWJ; else goto udX9;
       cdWJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupOrdering_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       udX9: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cdWy() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupOrdering_go_info" {
     GHC.Base.$fSemigroupOrdering_go_info:
         const GHC.Base.$fSemigroupOrdering_go_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cdWy() //  []
         { []
         }
     {offset
       cdWy: // global
           I64[Sp - 8] = block_cdWB_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udXb; else goto cdWC;
       udXb: // global
           call _cdWB(R1) args: 0, res: 0, upd: 0;
       cdWC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cdWB() //  [R1]
         { []
         }
     {offset
       cdWB: // global
           _s80O::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cdWF; else goto cdWG;
       cdWF: // global
           R1 = _s80O::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cdWG: // global
           I64[Sp] = block_cdWQ_info;
           _s80R::P64 = P64[R1 + 6];
           _s80S::P64 = P64[R1 + 14];
           R1 = _s80O::P64;
           P64[Sp + 8] = _s80S::P64;
           P64[Sp + 16] = _s80R::P64;
           if (R1 & 7 != 0) goto udXc; else goto cdWS;
       udXc: // global
           call _cdWQ(R1) args: 0, res: 0, upd: 0;
       cdWS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdWB_info" {
     block_cdWB_info:
         const _cdWB;
         const 130;
         const 30;
 },
 _cdWQ() //  [R1]
         { []
         }
     {offset
       cdWQ: // global
           _cdX7::P64 = R1 & 7;
           if (_cdX7::P64 < 3) goto udX8; else goto cdX6;
       udX8: // global
           if (_cdX7::P64 < 2) goto cdWY; else goto cdX2;
       cdWY: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cdX2: // global
           _s80P::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _s80P::P64;
           Sp = Sp + 8;
           call _cdWy() args: 0, res: 0, upd: 0;
       cdX6: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdWQ_info" {
     block_cdWQ_info:
         const _cdWQ;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.049064149 UTC

[section ""data" . GHC.Base.$fSemigroupOrdering_$csconcat_closure" {
     GHC.Base.$fSemigroupOrdering_$csconcat_closure:
         const GHC.Base.$fSemigroupOrdering_$csconcat_info;
 },
 GHC.Base.$fSemigroupOrdering_$csconcat_entry() //  [R2]
         { []
         }
     {offset
       cdXJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cdXK; else goto cdXL;
       cdXK: // global
           R2 = R2;
           R1 = GHC.Base.$fSemigroupOrdering_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdXL: // global
           I64[Sp - 8] = block_cdXG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto udXP; else goto cdXH;
       udXP: // global
           call _cdXG(R1) args: 0, res: 0, upd: 0;
       cdXH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupOrdering_$csconcat_info" {
     GHC.Base.$fSemigroupOrdering_$csconcat_info:
         const GHC.Base.$fSemigroupOrdering_$csconcat_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cdXG() //  [R1]
         { []
         }
     {offset
       cdXG: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$fSemigroupOrdering_go_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdXG_info" {
     block_cdXG_info:
         const _cdXG;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.054375 UTC

[section ""data" . GHC.Base.._closure" {
     GHC.Base.._closure:
         const GHC.Base.._info;
 },
 GHC.Base.._entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cdY4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdY8; else goto cdY7;
       cdY8: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.._closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdY7: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           _s80Y::P64 = R2;
           R2 = Hp - 24;
           R1 = _s80Y::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.._info" {
     GHC.Base.._info:
         const GHC.Base.._entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.058558793 UTC

[section ""data" . GHC.Base.mapFB_closure" {
     GHC.Base.mapFB_closure:
         const GHC.Base.mapFB_info;
 },
 GHC.Base.mapFB_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cdYi: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cdYm; else goto cdYl;
       cdYm: // global
           HpAlloc = 32;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.mapFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cdYl: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = R5;
           _s812::P64 = R2;
           R2 = Hp - 24;
           R1 = _s812::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.mapFB_info" {
     GHC.Base.mapFB_info:
         const GHC.Base.mapFB_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.062152884 UTC

[section ""data" . GHC.Base.$fFunctor(->)_$c<$_closure" {
     GHC.Base.$fFunctor(->)_$c<$_closure:
         const GHC.Base.$fFunctor(->)_$c<$_info;
 },
 GHC.Base.$fFunctor(->)_$c<$_entry() //  [R2]
         { []
         }
     {offset
       cdYv: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fFunctor(->)_$c<$_info" {
     GHC.Base.$fFunctor(->)_$c<$_info:
         const GHC.Base.$fFunctor(->)_$c<$_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.064914014 UTC

[section ""data" . GHC.Base.$fFunctor(->)_closure" {
     GHC.Base.$fFunctor(->)_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.._closure+3;
         const GHC.Base.$fFunctor(->)_$c<$_closure+3;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.06684618 UTC

[section ""data" . GHC.Base.const_closure" {
     GHC.Base.const_closure:
         const GHC.Base.const_info;
 },
 GHC.Base.const_entry() //  [R2]
         { []
         }
     {offset
       cdYH: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.const_info" {
     GHC.Base.const_info:
         const GHC.Base.const_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.069963327 UTC

[section ""data" . GHC.Base.asTypeOf_closure" {
     GHC.Base.asTypeOf_closure:
         const GHC.Base.asTypeOf_info;
 },
 GHC.Base.asTypeOf_entry() //  [R2, R3]
         { []
         }
     {offset
       cdYS: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.const_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.asTypeOf_info" {
     GHC.Base.asTypeOf_info:
         const GHC.Base.asTypeOf_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.073755509 UTC

[section ""data" . GHC.Base.$dm<*_closure" {
     GHC.Base.$dm<*_closure:
         const GHC.Base.$dm<*_info;
 },
 GHC.Base.$dm<*_entry() //  [R2]
         { []
         }
     {offset
       cdZ3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdZ4; else goto cdZ5;
       cdZ4: // global
           R2 = R2;
           R1 = GHC.Base.$dm<*_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cdZ5: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.const_closure+2;
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dm<*_info" {
     GHC.Base.$dm<*_info:
         const GHC.Base.$dm<*_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.077779573 UTC

[section ""data" . GHC.Base.$fApplicativeIO1_closure" {
     GHC.Base.$fApplicativeIO1_closure:
         const GHC.Base.$fApplicativeIO1_info;
 },
 GHC.Base.$fApplicativeIO1_entry() //  [R2, R3]
         { []
         }
     {offset
       cdZj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cdZk; else goto cdZl;
       cdZk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cdZl: // global
           I64[Sp - 16] = block_cdZf_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeIO1_info" {
     GHC.Base.$fApplicativeIO1_info:
         const GHC.Base.$fApplicativeIO1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cdZf() //  [R1]
         { []
         }
     {offset
       cdZf: // global
           I64[Sp] = block_cdZh_info;
           _s81i::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s81i::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cdZf_info" {
     block_cdZf_info:
         const _cdZf;
         const 1;
         const 30;
 },
 _cdZh() //  []
         { []
         }
     {offset
       cdZh: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cdZh_info" {
     block_cdZh_info:
         const _cdZh;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.08367381 UTC

[section ""data" . GHC.Base.$fApplicativeIO_closure" {
     GHC.Base.$fApplicativeIO_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctorIO_closure+1;
         const GHC.Base.$fApplicativeIO4_closure+2;
         const GHC.Base.$fApplicativeIO3_closure+3;
         const GHC.Base.$fApplicativeIO_$cliftA2_closure+4;
         const GHC.Base.$fApplicativeIO2_closure+3;
         const GHC.Base.$fApplicativeIO1_closure+3;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.086180444 UTC

[section ""data" . GHC.Base.breakpointCond_closure" {
     GHC.Base.breakpointCond_closure:
         const GHC.Base.breakpointCond_info;
 },
 GHC.Base.breakpointCond_entry() //  [R3]
         { []
         }
     {offset
       cdZF: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.breakpointCond_info" {
     GHC.Base.breakpointCond_info:
         const GHC.Base.breakpointCond_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.089441152 UTC

[section ""data" . GHC.Base.breakpoint_closure" {
     GHC.Base.breakpoint_closure:
         const GHC.Base.breakpoint_info;
 },
 GHC.Base.breakpoint_entry() //  [R2]
         { []
         }
     {offset
       cdZQ: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.breakpoint_info" {
     GHC.Base.breakpoint_info:
         const GHC.Base.breakpoint_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.092607987 UTC

[section ""data" . GHC.Base.assert_closure" {
     GHC.Base.assert_closure:
         const GHC.Base.assert_info;
 },
 GHC.Base.assert_entry() //  [R2, R3]
         { []
         }
     {offset
       ce01: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.breakpointCond_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.assert_info" {
     GHC.Base.assert_info:
         const GHC.Base.assert_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.095853116 UTC

[section ""data" . GHC.Base.id_closure" {
     GHC.Base.id_closure:
         const GHC.Base.id_info;
 },
 GHC.Base.id_entry() //  [R2]
         { []
         }
     {offset
       ce0c: // global
           R2 = R2;
           call GHC.Base.breakpoint_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.id_info" {
     GHC.Base.id_info:
         const GHC.Base.id_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.099280728 UTC

[section ""data" . GHC.Base.join_closure" {
     GHC.Base.join_closure:
         const GHC.Base.join_info;
 },
 GHC.Base.join_entry() //  [R2, R3]
         { []
         }
     {offset
       ce0n: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ce0o; else goto ce0p;
       ce0o: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.join_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ce0p: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.join_info" {
     GHC.Base.join_info:
         const GHC.Base.join_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.103214825 UTC

[section ""data" . GHC.Base.$dm<*>_closure" {
     GHC.Base.$dm<*>_closure:
         const GHC.Base.$dm<*>_info;
 },
 GHC.Base.$dm<*>_entry() //  [R2]
         { []
         }
     {offset
       ce0z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ce0A; else goto ce0B;
       ce0A: // global
           R2 = R2;
           R1 = GHC.Base.$dm<*>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ce0B: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dm<*>_info" {
     GHC.Base.$dm<*>_info:
         const GHC.Base.$dm<*>_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.108996719 UTC

[section ""data" . GHC.Base.$dm*>_closure" {
     GHC.Base.$dm*>_closure:
         const GHC.Base.$dm*>_info;
 },
 sat_s81w_entry() //  [R1]
         { []
         }
     {offset
       ce0R: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ce0S; else goto ce0T;
       ce0S: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ce0T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ce0P_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s81w_info" {
     sat_s81w_info:
         const sat_s81w_entry;
         const 2;
         const 18;
 },
 _ce0P() //  [R1]
         { []
         }
     {offset
       ce0P: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 8;
           call GHC.Base.<$_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ce0P_info" {
     block_ce0P_info:
         const _ce0P;
         const 1;
         const 30;
 },
 GHC.Base.$dm*>_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ce0X: // global
           _s81u::P64 = R4;
           _s81t::P64 = R3;
           _s81s::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto ce0Y; else goto ce0Z;
       ce0Z: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ce11; else goto ce10;
       ce11: // global
           HpAlloc = 32;
           goto ce0Y;
       ce0Y: // global
           R4 = _s81u::P64;
           R3 = _s81t::P64;
           R2 = _s81s::P64;
           R1 = GHC.Base.$dm*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ce10: // global
           I64[Hp - 24] = sat_s81w_info;
           P64[Hp - 8] = _s81s::P64;
           P64[Hp] = _s81t::P64;
           R2 = _s81s::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _s81u::P64;
           Sp = Sp - 24;
           call GHC.Base.<*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dm*>_info" {
     GHC.Base.$dm*>_info:
         const GHC.Base.$dm*>_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.116080075 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$c*>_closure" {
     GHC.Base.$fApplicative(->)_$c*>_closure:
         const GHC.Base.$fApplicative(->)_$c*>_info;
 },
 GHC.Base.$fApplicative(->)_$c*>_entry() //  [R3, R4]
         { []
         }
     {offset
       ce1k: // global
           R2 = R4;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative(->)_$c*>_info" {
     GHC.Base.$fApplicative(->)_$c*>_info:
         const GHC.Base.$fApplicative(->)_$c*>_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.11901664 UTC

[section ""data" . GHC.Base.maxInt_closure" {
     GHC.Base.maxInt_closure:
         const GHC.Types.I#_con_info;
         const 9223372036854775807;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.120569693 UTC

[section ""data" . GHC.Base.minInt_closure" {
     GHC.Base.minInt_closure:
         const GHC.Types.I#_con_info;
         const (-9223372036854775808);
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.123506451 UTC

[section ""data" . GHC.Base.ord_closure" {
     GHC.Base.ord_closure:
         const GHC.Base.ord_info;
 },
 GHC.Base.ord_entry() //  [R2]
         { []
         }
     {offset
       ce1A: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ce1H; else goto ce1I;
       ce1H: // global
           R2 = R2;
           R1 = GHC.Base.ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ce1I: // global
           I64[Sp - 8] = block_ce1x_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ue1M; else goto ce1y;
       ue1M: // global
           call _ce1x(R1) args: 0, res: 0, upd: 0;
       ce1y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.ord_info" {
     GHC.Base.ord_info:
         const GHC.Base.ord_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _ce1x() //  [R1]
         { []
         }
     {offset
       ce1x: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ce1L; else goto ce1K;
       ce1L: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ce1K: // global
           _s81D::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _s81D::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ce1x_info" {
     block_ce1x_info:
         const _ce1x;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.129221016 UTC

[section ""data" . GHC.Base.unsafeChr_closure" {
     GHC.Base.unsafeChr_closure:
         const GHC.Base.unsafeChr_info;
 },
 GHC.Base.unsafeChr_entry() //  [R2]
         { []
         }
     {offset
       ce24: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ce2b; else goto ce2c;
       ce2b: // global
           R2 = R2;
           R1 = GHC.Base.unsafeChr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ce2c: // global
           I64[Sp - 8] = block_ce21_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ue2g; else goto ce22;
       ue2g: // global
           call _ce21(R1) args: 0, res: 0, upd: 0;
       ce22: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.unsafeChr_info" {
     GHC.Base.unsafeChr_info:
         const GHC.Base.unsafeChr_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _ce21() //  [R1]
         { []
         }
     {offset
       ce21: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ce2f; else goto ce2e;
       ce2f: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ce2e: // global
           _s81H::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _s81H::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ce21_info" {
     block_ce21_info:
         const _ce21;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.134482543 UTC

[section ""data" . GHC.Base.otherwise_closure" {
     GHC.Base.otherwise_closure:
         const GHC.Types.True_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.13750598 UTC

[section ""data" . GHC.Base.until_closure" {
     GHC.Base.until_closure:
         const GHC.Base.until_info;
 },
 GHC.Base.until_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ce2y: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ce2z; else goto ce2A;
       ce2z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.until_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ce2A: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _ce2C() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Base.until_info" {
     GHC.Base.until_info:
         const GHC.Base.until_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ce2C() //  []
         { []
         }
     {offset
       ce2C: // global
           I64[Sp - 8] = block_ce2E_info;
           R2 = P64[Sp + 16];
           R1 = P64[Sp];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _ce2E() //  [R1]
         { []
         }
     {offset
       ce2E: // global
           _s81M::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ce2I; else goto ce2R;
       ce2I: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ce2N; else goto ce2M;
       ce2N: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ce2M: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s81M::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call _ce2C() args: 0, res: 0, upd: 0;
       ce2R: // global
           R1 = _s81M::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ce2E_info" {
     block_ce2E_info:
         const _ce2E;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.145392646 UTC

[section ""data" . GHC.Base.divModInt#_closure" {
     GHC.Base.divModInt#_closure:
         const GHC.Base.divModInt#_info;
 },
 GHC.Base.divModInt#_entry() //  [R2, R3]
         { []
         }
     {offset
       ce3l: // global
           if (%MO_S_Le_W64(R2, 0)) goto ce3j; else goto ce3k;
       ce3j: // global
           if (%MO_S_Ge_W64(R2, 0)) goto ce3v; else goto ce3F;
       ce3v: // global
           _s81Q::I64 = R3;
           (_ce3s::I64, _ce3t::I64) = call MO_S_QuotRem W64(R2, _s81Q::I64);
           R2 = _ce3t::I64;
           R1 = _ce3s::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ce3F: // global
           if (%MO_S_Le_W64(R3, 0)) goto ce3D; else goto ce3E;
       ce3D: // global
           _s81Q::I64 = R3;
           (_ce3A::I64, _ce3B::I64) = call MO_S_QuotRem W64(R2, _s81Q::I64);
           R2 = _ce3B::I64;
           R1 = _ce3A::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ce3E: // global
           _s81Q::I64 = R3;
           (_s81W::I64, _s81X::I64) = call MO_S_QuotRem W64(R2 + 1, _s81Q::I64);
           R2 = _s81X::I64 + _s81Q::I64 - 1;
           R1 = _s81W::I64 - 1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ce3k: // global
           if (%MO_S_Ge_W64(R3, 0)) goto ce42; else goto ce43;
       ce42: // global
           if (%MO_S_Ge_W64(R2, 0)) goto ce3Q; else goto ce40;
       ce3Q: // global
           _s81Q::I64 = R3;
           (_ce3N::I64, _ce3O::I64) = call MO_S_QuotRem W64(R2, _s81Q::I64);
           R2 = _ce3O::I64;
           R1 = _ce3N::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ce40: // global
           if (%MO_S_Le_W64(R3, 0)) goto ce3Y; else goto ce3Z;
       ce3Y: // global
           _s81Q::I64 = R3;
           (_ce3V::I64, _ce3W::I64) = call MO_S_QuotRem W64(R2, _s81Q::I64);
           R2 = _ce3W::I64;
           R1 = _ce3V::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ce3Z: // global
           _s81Q::I64 = R3;
           (_s826::I64, _s827::I64) = call MO_S_QuotRem W64(R2 + 1, _s81Q::I64);
           R2 = _s827::I64 + _s81Q::I64 - 1;
           R1 = _s826::I64 - 1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ce43: // global
           _s81Q::I64 = R3;
           (_s82d::I64, _s82e::I64) = call MO_S_QuotRem W64(R2 - 1, _s81Q::I64);
           R2 = _s82e::I64 + _s81Q::I64 + 1;
           R1 = _s82d::I64 - 1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.divModInt#_info" {
     GHC.Base.divModInt#_info:
         const GHC.Base.divModInt#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.153423573 UTC

[section ""data" . GHC.Base.divModInt_closure" {
     GHC.Base.divModInt_closure:
         const GHC.Base.divModInt_info;
 },
 GHC.Base.divModInt_entry() //  [R2, R3]
         { []
         }
     {offset
       ce4Z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ce53; else goto ce54;
       ce53: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.divModInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ce54: // global
           I64[Sp - 16] = block_ce4W_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ue6P; else goto ce4X;
       ue6P: // global
           call _ce4W(R1) args: 0, res: 0, upd: 0;
       ce4X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.divModInt_info" {
     GHC.Base.divModInt_info:
         const GHC.Base.divModInt_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ce4W() //  [R1]
         { []
         }
     {offset
       ce4W: // global
           I64[Sp] = block_ce52_info;
           _s82l::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _s82l::I64;
           if (R1 & 7 != 0) goto ue6O; else goto ce56;
       ue6O: // global
           call _ce52(R1) args: 0, res: 0, upd: 0;
       ce56: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ce4W_info" {
     block_ce4W_info:
         const _ce4W;
         const 1;
         const 30;
 },
 _ce52() //  [R1]
         { []
         }
     {offset
       ce52: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ce5c; else goto ce5b;
       ce5c: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ce5b: // global
           _s82l::I64 = I64[Sp + 8];
           _s82n::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_s82l::I64, 0)) goto ce5Q; else goto ce6N;
       ce5Q: // global
           if (%MO_S_Ge_W64(_s82l::I64, 0)) goto ce5n; else goto ce5O;
       ce5n: // global
           (_s82r::I64, _s82s::I64) = call MO_S_QuotRem W64(_s82l::I64, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s82s::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82r::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce5O: // global
           if (%MO_S_Le_W64(_s82n::I64, 0)) goto ce5w; else goto ce5N;
       ce5w: // global
           (_s82x::I64, _s82y::I64) = call MO_S_QuotRem W64(_s82l::I64, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s82y::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82x::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce5N: // global
           (_s82D::I64, _s82E::I64) = call MO_S_QuotRem W64(_s82l::I64 + 1, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s82E::I64 + _s82n::I64 - 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82D::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce6N: // global
           if (%MO_S_Ge_W64(_s82n::I64, 0)) goto ce6v; else goto ce6M;
       ce6v: // global
           if (%MO_S_Ge_W64(_s82l::I64, 0)) goto ce62; else goto ce6t;
       ce62: // global
           (_s82N::I64, _s82O::I64) = call MO_S_QuotRem W64(_s82l::I64, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s82O::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82N::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce6t: // global
           if (%MO_S_Le_W64(_s82n::I64, 0)) goto ce6b; else goto ce6s;
       ce6b: // global
           (_s82T::I64, _s82U::I64) = call MO_S_QuotRem W64(_s82l::I64, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s82U::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82T::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce6s: // global
           (_s82Z::I64, _s830::I64) = call MO_S_QuotRem W64(_s82l::I64 + 1, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s830::I64 + _s82n::I64 - 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s82Z::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce6M: // global
           (_s838::I64, _s839::I64) = call MO_S_QuotRem W64(_s82l::I64 - 1, _s82n::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _s839::I64 + _s82n::I64 + 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _s838::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ce52_info" {
     block_ce52_info:
         const _ce52;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.163414025 UTC

[section ""data" . GHC.Base.shiftL#_closure" {
     GHC.Base.shiftL#_closure:
         const GHC.Base.shiftL#_info;
 },
 GHC.Base.shiftL#_entry() //  [R2, R3]
         { []
         }
     {offset
       ce7J: // global
           if (%MO_S_Lt_W64(R3, 64)) goto ce7H; else goto ce7I;
       ce7H: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce7I: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.shiftL#_info" {
     GHC.Base.shiftL#_info:
         const GHC.Base.shiftL#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.167206269 UTC

[section ""data" . GHC.Base.shiftRL#_closure" {
     GHC.Base.shiftRL#_closure:
         const GHC.Base.shiftRL#_info;
 },
 GHC.Base.shiftRL#_entry() //  [R2, R3]
         { []
         }
     {offset
       ce84: // global
           if (%MO_S_Lt_W64(R3, 64)) goto ce82; else goto ce83;
       ce82: // global
           R1 = R2 >> R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce83: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.shiftRL#_info" {
     GHC.Base.shiftRL#_info:
         const GHC.Base.shiftRL#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.170710966 UTC

[section ""data" . GHC.Base.iShiftL#_closure" {
     GHC.Base.iShiftL#_closure:
         const GHC.Base.iShiftL#_info;
 },
 GHC.Base.iShiftL#_entry() //  [R2, R3]
         { []
         }
     {offset
       ce8p: // global
           if (%MO_S_Lt_W64(R3, 64)) goto ce8n; else goto ce8o;
       ce8n: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce8o: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.iShiftL#_info" {
     GHC.Base.iShiftL#_info:
         const GHC.Base.iShiftL#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.174920068 UTC

[section ""data" . GHC.Base.iShiftRA#_closure" {
     GHC.Base.iShiftRA#_closure:
         const GHC.Base.iShiftRA#_info;
 },
 GHC.Base.iShiftRA#_entry() //  [R2, R3]
         { []
         }
     {offset
       ce8K: // global
           if (%MO_S_Lt_W64(R3, 64)) goto ce8I; else goto ce8J;
       ce8I: // global
           R1 = %MO_S_Shr_W64(R2, R3);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce8J: // global
           if (%MO_S_Ge_W64(R2, 0)) goto ce8T; else goto ce8U;
       ce8T: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce8U: // global
           R1 = (-1);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.iShiftRA#_info" {
     GHC.Base.iShiftRA#_info:
         const GHC.Base.iShiftRA#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.17901879 UTC

[section ""data" . GHC.Base.iShiftRL#_closure" {
     GHC.Base.iShiftRL#_closure:
         const GHC.Base.iShiftRL#_info;
 },
 GHC.Base.iShiftRL#_entry() //  [R2, R3]
         { []
         }
     {offset
       ce9c: // global
           if (%MO_S_Lt_W64(R3, 64)) goto ce9a; else goto ce9b;
       ce9a: // global
           R1 = R2 >> R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ce9b: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.iShiftRL#_info" {
     GHC.Base.iShiftRL#_info:
         const GHC.Base.iShiftRL#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.182439439 UTC

[section ""data" . GHC.Base.build_closure" {
     GHC.Base.build_closure:
         const GHC.Base.build_info;
 },
 GHC.Base.build_entry() //  [R2]
         { []
         }
     {offset
       ce9s: // global
           R3 = GHC.Types.[]_closure+1;
           _s83v::P64 = R2;
           R2 = GHC.Types.:_closure+2;
           R1 = _s83v::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.build_info" {
     GHC.Base.build_info:
         const GHC.Base.build_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.185956908 UTC

[section ""data" . GHC.Base.$fApplicative[]_$cpure_closure" {
     GHC.Base.$fApplicative[]_$cpure_closure:
         const GHC.Base.$fApplicative[]_$cpure_info;
 },
 GHC.Base.$fApplicative[]_$cpure_entry() //  [R2]
         { []
         }
     {offset
       ce9E: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ce9I; else goto ce9H;
       ce9I: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$cpure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ce9H: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative[]_$cpure_info" {
     GHC.Base.$fApplicative[]_$cpure_info:
         const GHC.Base.$fApplicative[]_$cpure_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.19002888 UTC

[section ""data" . GHC.Base.augment_closure" {
     GHC.Base.augment_closure:
         const GHC.Base.augment_info;
 },
 GHC.Base.augment_entry() //  [R2, R3]
         { []
         }
     {offset
       ce9S: // global
           R3 = R3;
           _s83x::P64 = R2;
           R2 = GHC.Types.:_closure+2;
           R1 = _s83x::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.augment_info" {
     GHC.Base.augment_info:
         const GHC.Base.augment_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.197639852 UTC

[section ""data" . GHC.Base.++_closure" {
     GHC.Base.++_closure:
         const GHC.Base.++_info;
 },
 sat_s83E_entry() //  [R1]
         { []
         }
     {offset
       cead: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceae; else goto ceaf;
       ceae: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceaf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s83E_info" {
     sat_s83E_info:
         const sat_s83E_entry;
         const 2;
         const 18;
 },
 GHC.Base.++_entry() //  [R2, R3]
         { []
         }
     {offset
       ceak: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceal; else goto ceam;
       ceal: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.++_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceam: // global
           I64[Sp - 16] = block_cea3_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ueat; else goto cea4;
       ueat: // global
           call _cea3(R1) args: 0, res: 0, upd: 0;
       cea4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.++_info" {
     GHC.Base.++_info:
         const GHC.Base.++_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cea3() //  [R1]
         { []
         }
     {offset
       cea3: // global
           _s83A::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ceah; else goto ceai;
       ceah: // global
           R1 = _s83A::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ceai: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ceas; else goto cear;
       ceas: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cear: // global
           _s83C::P64 = P64[R1 + 6];
           _s83D::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_s83E_info;
           P64[Hp - 32] = _s83A::P64;
           P64[Hp - 24] = _s83D::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s83C::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cea3_info" {
     block_cea3_info:
         const _cea3;
         const 1;
         const 30;
 },
 section ""data" . GHC.Base.foldr_closure" {
     GHC.Base.foldr_closure:
         const GHC.Base.foldr_info;
 },
 go_s83I_entry() //  [R1, R2]
         { []
         }
     {offset
       ceaK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceaL; else goto ceaM;
       ceaL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceaM: // global
           I64[Sp - 32] = block_ceaD_info;
           _s83I::P64 = R1;
           _s83F::P64 = P64[R1 + 7];
           _s83G::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s83F::P64;
           P64[Sp - 16] = _s83G::P64;
           P64[Sp - 8] = _s83I::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ueaW; else goto ceaE;
       ueaW: // global
           call _ceaD(R1) args: 0, res: 0, upd: 0;
       ceaE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_s83I_info" {
     go_s83I_info:
         const go_s83I_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _ceaD() //  [R1]
         { []
         }
     {offset
       ceaD: // global
           if (R1 & 7 == 1) goto ceaH; else goto ceaI;
       ceaH: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ceaI: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ceaV; else goto ceaU;
       ceaV: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ceaU: // global
           _s83L::P64 = P64[R1 + 6];
           _s83M::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s83M::P64;
           R3 = Hp - 24;
           R2 = _s83L::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceaD_info" {
     block_ceaD_info:
         const _ceaD;
         const 3;
         const 30;
 },
 GHC.Base.foldr_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ceaX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ceb1; else goto ceb0;
       ceb1: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.foldr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceb0: // global
           I64[Hp - 16] = go_s83I_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = R4;
           R1 = Hp - 15;
           call go_s83I_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.foldr_info" {
     GHC.Base.foldr_info:
         const GHC.Base.foldr_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 section ""data" . GHC.Base.map_closure" {
     GHC.Base.map_closure:
         const GHC.Base.map_info;
 },
 sat_s83U_entry() //  [R1]
         { []
         }
     {offset
       cebg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cebh; else goto cebi;
       cebh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cebi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s83U_info" {
     sat_s83U_info:
         const sat_s83U_entry;
         const 2;
         const 18;
 },
 GHC.Base.map_entry() //  [R2, R3]
         { []
         }
     {offset
       cebn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cebo; else goto cebp;
       cebo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.map_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cebp: // global
           I64[Sp - 16] = block_ceb6_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uebx; else goto ceb7;
       uebx: // global
           call _ceb6(R1) args: 0, res: 0, upd: 0;
       ceb7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.map_info" {
     GHC.Base.map_info:
         const GHC.Base.map_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ceb6() //  [R1]
         { []
         }
     {offset
       ceb6: // global
           if (R1 & 7 == 1) goto cebk; else goto cebl;
       cebk: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cebl: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cebw; else goto cebv;
       cebw: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cebv: // global
           _s83R::P64 = P64[R1 + 6];
           _s83S::P64 = P64[R1 + 14];
           I64[Hp - 80] = sat_s83U_info;
           _s83O::P64 = P64[Sp + 8];
           P64[Hp - 64] = _s83O::P64;
           P64[Hp - 56] = _s83S::P64;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _s83O::P64;
           P64[Hp - 24] = _s83R::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceb6_info" {
     block_ceb6_info:
         const _ceb6;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.218920848 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty_$c<>_closure" {
     GHC.Base.$fSemigroupNonEmpty_$c<>_closure:
         const GHC.Base.$fSemigroupNonEmpty_$c<>_info;
 },
 sat_s849_entry() //  [R1]
         { []
         }
     {offset
       cecF: // global
           _s849::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cecG; else goto cecH;
       cecH: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cecJ; else goto cecI;
       cecJ: // global
           HpAlloc = 72;
           goto cecG;
       cecG: // global
           R1 = _s849::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cecI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s849::P64;
           _s83W::P64 = P64[_s849::P64 + 16];
           _s83Z::P64 = P64[_s849::P64 + 24];
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _s83W::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _s83W::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = _s83Z::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s849_info" {
     sat_s849_info:
         const sat_s849_entry;
         const 2;
         const 18;
 },
 GHC.Base.$fSemigroupNonEmpty_$c<>_entry() //  [R2, R3]
         { []
         }
     {offset
       cecK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cecM; else goto cecN;
       cecM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupNonEmpty_$c<>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cecN: // global
           I64[Sp - 16] = block_cect_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uecR; else goto cecu;
       uecR: // global
           call _cect(R1) args: 0, res: 0, upd: 0;
       cecu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupNonEmpty_$c<>_info" {
     GHC.Base.$fSemigroupNonEmpty_$c<>_info:
         const GHC.Base.$fSemigroupNonEmpty_$c<>_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cect() //  [R1]
         { []
         }
     {offset
       cect: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cecQ; else goto cecP;
       cecQ: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cecP: // global
           _s83Y::P64 = P64[R1 + 7];
           _s83Z::P64 = P64[R1 + 15];
           I64[Hp - 48] = sat_s849_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s83Z::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _s83Y::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cect_info" {
     block_cect_info:
         const _cect;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.228924748 UTC

[section ""data" . GHC.Base.$wpoly_go_closure" {
     GHC.Base.$wpoly_go_closure:
         const GHC.Base.$wpoly_go_info;
 },
 ds_s84g_entry() //  [R1]
         { []
         }
     {offset
       cedv: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cedB; else goto cedC;
       cedB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cedC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ceds_info;
           _s84f::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _s84f::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uedH; else goto cedt;
       uedH: // global
           call _ceds(R1) args: 0, res: 0, upd: 0;
       cedt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ds_s84g_info" {
     ds_s84g_info:
         const ds_s84g_entry;
         const 2;
         const 18;
 },
 _ceds() //  [R1]
         { []
         }
     {offset
       ceds: // global
           _s84f::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cedy_info;
           R4 = _s84f::P64;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$wpoly_go_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_ceds_info" {
     block_ceds_info:
         const _ceds;
         const 1;
         const 30;
 },
 _cedy() //  [R1, R2]
         { []
         }
     {offset
       cedy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cedG; else goto cedF;
       cedG: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cedF: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cedy_info" {
     block_cedy_info:
         const _cedy;
         const 0;
         const 30;
 },
 sat_s84w_entry() //  [R1]
         { []
         }
     {offset
       cedL: // global
           _s84w::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cedM; else goto cedN;
       cedN: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cedP; else goto cedO;
       cedP: // global
           HpAlloc = 104;
           goto cedM;
       cedM: // global
           R1 = _s84w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cedO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s84w::P64;
           _s84b::P64 = P64[_s84w::P64 + 16];
           _s84e::P64 = P64[_s84w::P64 + 24];
           _s84f::P64 = P64[_s84w::P64 + 32];
           I64[Hp - 96] = ds_s84g_info;
           P64[Hp - 80] = _s84e::P64;
           P64[Hp - 72] = _s84f::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cedo::P64 = Hp - 96;
           P64[Hp - 48] = _cedo::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cedo::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = _s84b::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s84w_info" {
     sat_s84w_info:
         const sat_s84w_entry;
         const 3;
         const 15;
 },
 GHC.Base.$wpoly_go_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cedU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cedV; else goto cedW;
       cedV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$wpoly_go_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cedW: // global
           I64[Sp - 24] = block_cede_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uee2; else goto cedf;
       uee2: // global
           call _cede(R1) args: 0, res: 0, upd: 0;
       cedf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$wpoly_go_info" {
     GHC.Base.$wpoly_go_info:
         const GHC.Base.$wpoly_go_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cede() //  [R1]
         { []
         }
     {offset
       cede: // global
           _s84a::P64 = P64[Sp + 8];
           _s84b::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cedR; else goto cedS;
       cedR: // global
           R2 = _s84b::P64;
           R1 = _s84a::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cedS: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cee1; else goto cee0;
       cee1: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cee0: // global
           _s84e::P64 = P64[R1 + 6];
           _s84f::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_s84w_info;
           P64[Hp - 16] = _s84b::P64;
           P64[Hp - 8] = _s84e::P64;
           P64[Hp] = _s84f::P64;
           R2 = Hp - 32;
           R1 = _s84a::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cede_info" {
     block_cede_info:
         const _cede;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.242661375 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty1_closure" {
     GHC.Base.$fSemigroupNonEmpty1_closure:
         const GHC.Base.$fSemigroupNonEmpty1_info;
 },
 GHC.Base.$fSemigroupNonEmpty1_entry() //  [R2, R3]
         { []
         }
     {offset
       ceeF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceeL; else goto ceeM;
       ceeL: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupNonEmpty1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceeM: // global
           I64[Sp - 16] = block_ceeC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ueeR; else goto ceeD;
       ueeR: // global
           call _ceeC(R1) args: 0, res: 0, upd: 0;
       ceeD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupNonEmpty1_info" {
     GHC.Base.$fSemigroupNonEmpty1_info:
         const GHC.Base.$fSemigroupNonEmpty1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ceeC() //  [R1]
         { []
         }
     {offset
       ceeC: // global
           _s84y::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ceeI_info;
           R4 = _s84y::P64;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$wpoly_go_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ceeC_info" {
     block_ceeC_info:
         const _ceeC;
         const 1;
         const 30;
 },
 _ceeI() //  [R1, R2]
         { []
         }
     {offset
       ceeI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ceeQ; else goto ceeP;
       ceeQ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ceeP: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceeI_info" {
     block_ceeI_info:
         const _ceeI;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.250096152 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty_$csconcat_closure" {
     GHC.Base.$fSemigroupNonEmpty_$csconcat_closure:
         const GHC.Base.$fSemigroupNonEmpty_$csconcat_info;
 },
 GHC.Base.$fSemigroupNonEmpty_$csconcat_entry() //  [R2]
         { []
         }
     {offset
       cefc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cefd; else goto cefe;
       cefd: // global
           R2 = R2;
           R1 = GHC.Base.$fSemigroupNonEmpty_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cefe: // global
           I64[Sp - 8] = block_cef9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uefi; else goto cefa;
       uefi: // global
           call _cef9(R1) args: 0, res: 0, upd: 0;
       cefa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupNonEmpty_$csconcat_info" {
     GHC.Base.$fSemigroupNonEmpty_$csconcat_info:
         const GHC.Base.$fSemigroupNonEmpty_$csconcat_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cef9() //  [R1]
         { []
         }
     {offset
       cef9: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$fSemigroupNonEmpty1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cef9_info" {
     block_cef9_info:
         const _cef9;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.255037679 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty_closure" {
     GHC.Base.$fSemigroupNonEmpty_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.$fSemigroupNonEmpty_$c<>_closure+2;
         const GHC.Base.$fSemigroupNonEmpty_$csconcat_closure+1;
         const GHC.Base.$fSemigroupNonEmpty_$cstimes_closure+1;
         const 0;
 },
 section ""data" . GHC.Base.$fSemigroupNonEmpty_$cstimes_closure" {
     GHC.Base.$fSemigroupNonEmpty_$cstimes_closure:
         const GHC.Base.$fSemigroupNonEmpty_$cstimes_info;
         const 0;
 },
 GHC.Base.$fSemigroupNonEmpty_$cstimes_entry() //  [R2]
         { []
         }
     {offset
       cefw: // global
           R3 = GHC.Base.$fSemigroupNonEmpty_closure+1;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupNonEmpty_$cstimes_info" {
     GHC.Base.$fSemigroupNonEmpty_$cstimes_info:
         const GHC.Base.$fSemigroupNonEmpty_$cstimes_entry;
         const 0;
         const 141733920782;
         const 4294967301;
         const S8R0_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.260310253 UTC

[section ""data" . GHC.Base.$fSemigroup[]1_closure" {
     GHC.Base.$fSemigroup[]1_closure:
         const GHC.Base.$fSemigroup[]1_info;
 },
 sat_s84P_entry() //  [R1]
         { []
         }
     {offset
       cefS: // global
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call GHC.Base.$fSemigroup[]1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s84P_info" {
     sat_s84P_info:
         const sat_s84P_entry;
         const 2;
         const 18;
 },
 GHC.Base.$fSemigroup[]1_entry() //  [R2, R3]
         { []
         }
     {offset
       cefZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceg0; else goto ceg1;
       ceg0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup[]1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceg1: // global
           I64[Sp - 16] = block_cefI_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ueg7; else goto cefJ;
       ueg7: // global
           call _cefI(R1) args: 0, res: 0, upd: 0;
       cefJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup[]1_info" {
     GHC.Base.$fSemigroup[]1_info:
         const GHC.Base.$fSemigroup[]1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cefI() //  [R1]
         { []
         }
     {offset
       cefI: // global
           _s84K::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cefW; else goto cefX;
       cefW: // global
           R1 = _s84K::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cefX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ceg6; else goto ceg5;
       ceg6: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ceg5: // global
           _s84N::P64 = P64[R1 + 6];
           _s84O::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s84P_info;
           P64[Hp - 8] = _s84N::P64;
           P64[Hp] = _s84O::P64;
           R3 = Hp - 24;
           R2 = _s84K::P64;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cefI_info" {
     block_cefI_info:
         const _cefI;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.26818187 UTC

[section ""data" . GHC.Base.$fSemigroup[]_$csconcat_closure" {
     GHC.Base.$fSemigroup[]_$csconcat_closure:
         const GHC.Base.$fSemigroup[]_$csconcat_info;
 },
 GHC.Base.$fSemigroup[]_$csconcat_entry() //  [R2]
         { []
         }
     {offset
       cegv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cegw; else goto cegx;
       cegw: // global
           R2 = R2;
           R1 = GHC.Base.$fSemigroup[]_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cegx: // global
           I64[Sp - 8] = block_cegs_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uegB; else goto cegt;
       uegB: // global
           call _cegs(R1) args: 0, res: 0, upd: 0;
       cegt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup[]_$csconcat_info" {
     GHC.Base.$fSemigroup[]_$csconcat_info:
         const GHC.Base.$fSemigroup[]_$csconcat_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cegs() //  [R1]
         { []
         }
     {offset
       cegs: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$fSemigroup[]1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cegs_info" {
     block_cegs_info:
         const _cegs;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.276106632 UTC

[section ""data" . GHC.Base.mapM_closure" {
     GHC.Base.mapM_closure:
         const GHC.Base.mapM_info;
 },
 z_s84X_entry() //  [R1]
         { []
         }
     {offset
       cegT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cegU; else goto cegV;
       cegU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cegV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z_s84X_info" {
     z_s84X_info:
         const z_s84X_entry;
         const 1;
         const 16;
 },
 sat_s858_entry() //  [R1, R2]
         { []
         }
     {offset
       cehj: // global
           _s856::P64 = R2;
           _s858::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cehk; else goto cehl;
       cehl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cehn; else goto cehm;
       cehn: // global
           HpAlloc = 24;
           goto cehk;
       cehk: // global
           R2 = _s856::P64;
           R1 = _s858::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cehm: // global
           _s84U::P64 = P64[_s858::P64 + 7];
           _s855::P64 = P64[_s858::P64 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _s855::P64;
           P64[Hp] = _s856::P64;
           R2 = _s84U::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s858_info" {
     sat_s858_info:
         const sat_s858_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 sat_s859_entry() //  [R1, R2]
         { []
         }
     {offset
       ceho: // global
           _s855::P64 = R2;
           _s859::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cehp; else goto cehq;
       cehq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cehs; else goto cehr;
       cehs: // global
           HpAlloc = 24;
           goto cehp;
       cehp: // global
           R2 = _s855::P64;
           R1 = _s859::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cehr: // global
           _s84U::P64 = P64[_s859::P64 + 7];
           _s853::P64 = P64[_s859::P64 + 15];
           I64[Hp - 16] = sat_s858_info;
           P64[Hp - 8] = _s84U::P64;
           P64[Hp] = _s855::P64;
           R2 = _s84U::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s853::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s859_info" {
     sat_s859_info:
         const sat_s859_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 go_s84Y_entry() //  [R1, R2]
         { []
         }
     {offset
       cehx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cehy; else goto cehz;
       cehy: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cehz: // global
           I64[Sp - 40] = block_ceh1_info;
           _s84Y::P64 = R1;
           _s84U::P64 = P64[R1 + 7];
           _s84V::P64 = P64[R1 + 15];
           _s84X::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _s84U::P64;
           P64[Sp - 24] = _s84V::P64;
           P64[Sp - 16] = _s84X::P64;
           P64[Sp - 8] = _s84Y::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uehG; else goto ceh2;
       uehG: // global
           call _ceh1(R1) args: 0, res: 0, upd: 0;
       ceh2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_s84Y_info" {
     go_s84Y_info:
         const go_s84Y_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 _ceh1() //  [R1]
         { []
         }
     {offset
       ceh1: // global
           if (R1 & 7 == 1) goto cehu; else goto cehv;
       cehu: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cehv: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cehE; else goto cehD;
       cehE: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cehD: // global
           _s851::P64 = P64[R1 + 6];
           _s852::P64 = P64[R1 + 14];
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = _s852::P64;
           I64[Hp - 48] = sat_s859_info;
           _s84U::P64 = P64[Sp + 8];
           P64[Hp - 40] = _s84U::P64;
           P64[Hp - 32] = Hp - 80;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s851::P64;
           R2 = _s84U::P64;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 47;
           Sp = Sp + 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceh1_info" {
     block_ceh1_info:
         const _ceh1;
         const 4;
         const 30;
 },
 GHC.Base.mapM_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cehH: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cehL; else goto cehK;
       cehL: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.mapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cehK: // global
           I64[Hp - 48] = z_s84X_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go_s84Y_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R2 = R4;
           R1 = Hp - 23;
           call go_s84Y_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.mapM_info" {
     GHC.Base.mapM_info:
         const GHC.Base.mapM_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.28942793 UTC

[section ""data" . GHC.Base.sequence_closure" {
     GHC.Base.sequence_closure:
         const GHC.Base.sequence_info;
 },
 GHC.Base.sequence_entry() //  [R2, R3]
         { []
         }
     {offset
       ceio: // global
           R4 = R3;
           R3 = GHC.Base.breakpoint_closure+1;
           R2 = R2;
           call GHC.Base.mapM_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.sequence_info" {
     GHC.Base.sequence_info:
         const GHC.Base.sequence_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.29503544 UTC

[section ""data" . GHC.Base.$dmmconcat_closure" {
     GHC.Base.$dmmconcat_closure:
         const GHC.Base.$dmmconcat_info;
 },
 z_s85d_entry() //  [R1]
         { []
         }
     {offset
       ceiD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceiE; else goto ceiF;
       ceiE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceiF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z_s85d_info" {
     z_s85d_info:
         const z_s85d_entry;
         const 1;
         const 16;
 },
 go_s85e_entry() //  [R1, R2]
         { []
         }
     {offset
       ceiS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceiT; else goto ceiU;
       ceiT: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceiU: // global
           I64[Sp - 32] = block_ceiL_info;
           _s85e::P64 = R1;
           _s85b::P64 = P64[R1 + 7];
           _s85d::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s85b::P64;
           P64[Sp - 16] = _s85d::P64;
           P64[Sp - 8] = _s85e::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uej4; else goto ceiM;
       uej4: // global
           call _ceiL(R1) args: 0, res: 0, upd: 0;
       ceiM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_s85e_info" {
     go_s85e_info:
         const go_s85e_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _ceiL() //  [R1]
         { []
         }
     {offset
       ceiL: // global
           if (R1 & 7 == 1) goto ceiP; else goto ceiQ;
       ceiP: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ceiQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cej2; else goto cej1;
       cej2: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cej1: // global
           _s85h::P64 = P64[R1 + 6];
           _s85i::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s85i::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s85h::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceiL_info" {
     block_ceiL_info:
         const _ceiL;
         const 3;
         const 30;
 },
 GHC.Base.$dmmconcat_entry() //  [R2, R3]
         { []
         }
     {offset
       cej5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cej9; else goto cej8;
       cej9: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cej8: // global
           I64[Hp - 40] = z_s85d_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s85e_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R2 = R3;
           R1 = Hp - 15;
           call go_s85e_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmmconcat_info" {
     GHC.Base.$dmmconcat_info:
         const GHC.Base.$dmmconcat_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.306377098 UTC

[section ""data" . GHC.Base.$fMonoid(->)_$cmconcat_closure" {
     GHC.Base.$fMonoid(->)_$cmconcat_closure:
         const GHC.Base.$fMonoid(->)_$cmconcat_info;
 },
 lvl3_s85n_entry() //  [R1]
         { []
         }
     {offset
       cejD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cejE; else goto cejF;
       cejE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cejF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl3_s85n_info" {
     lvl3_s85n_info:
         const lvl3_s85n_entry;
         const 1;
         const 16;
 },
 $dSemigroup_s85o_entry() //  [R1]
         { []
         }
     {offset
       cejK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cejL; else goto cejM;
       cejL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cejM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dSemigroup_s85o_info" {
     $dSemigroup_s85o_info:
         const $dSemigroup_s85o_entry;
         const 1;
         const 16;
 },
 go_s85p_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cejZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cek0; else goto cek1;
       cek0: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cek1: // global
           I64[Sp - 40] = block_cejS_info;
           _s85p::P64 = R1;
           _s85n::P64 = P64[R1 + 6];
           _s85o::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 32] = _s85n::P64;
           P64[Sp - 24] = _s85o::P64;
           P64[Sp - 16] = _s85p::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uekc; else goto cejT;
       uekc: // global
           call _cejS(R1) args: 0, res: 0, upd: 0;
       cejT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_s85p_info" {
     go_s85p_info:
         const go_s85p_entry;
         const 2;
         const 11;
         const 8589934607;
 },
 _cejS() //  [R1]
         { []
         }
     {offset
       cejS: // global
           if (R1 & 7 == 1) goto cejW; else goto cejX;
       cejW: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cejX: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cek9; else goto cek8;
       cek9: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cek8: // global
           _s85t::P64 = P64[R1 + 6];
           _s85u::P64 = P64[R1 + 14];
           I64[Hp - 64] = stg_ap_3_upd_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = _s85u::P64;
           _s85r::P64 = P64[Sp + 32];
           P64[Hp - 32] = _s85r::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s85t::P64;
           P64[Hp] = _s85r::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 64;
           Sp = Sp + 16;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cejS_info" {
     block_cejS_info:
         const _cejS;
         const 4;
         const 30;
 },
 GHC.Base.$fMonoid(->)_$cmconcat_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cekd: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cekh; else goto cekg;
       cekh: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(->)_$cmconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cekg: // global
           I64[Hp - 64] = lvl3_s85n_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = $dSemigroup_s85o_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s85p_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           _s85l::P64 = R3;
           R3 = R4;
           R2 = _s85l::P64;
           R1 = Hp - 14;
           call go_s85p_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(->)_$cmconcat_info" {
     GHC.Base.$fMonoid(->)_$cmconcat_info:
         const GHC.Base.$fMonoid(->)_$cmconcat_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.319988365 UTC

[section ""data" . GHC.Base.$fMonoidIO1_closure" {
     GHC.Base.$fMonoidIO1_closure:
         const GHC.Base.$fMonoidIO1_info;
 },
 $dSemigroup_s85A_entry() //  [R1]
         { []
         }
     {offset
       cekR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cekS; else goto cekT;
       cekS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cekT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dSemigroup_s85A_info" {
     $dSemigroup_s85A_info:
         const $dSemigroup_s85A_entry;
         const 1;
         const 16;
 },
 lvl3_s85B_entry() //  [R1]
         { []
         }
     {offset
       cekY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cekZ; else goto cel0;
       cekZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cel0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl3_s85B_info" {
     lvl3_s85B_info:
         const lvl3_s85B_entry;
         const 1;
         const 16;
 },
 sat_s85O_entry() //  [R1]
         { []
         }
     {offset
       celk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cell; else goto celm;
       cell: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       celm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s85O_info" {
     sat_s85O_info:
         const sat_s85O_entry;
         const 3;
         const 15;
 },
 go_s85C_entry() //  [R1, R2]
         { []
         }
     {offset
       celr: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cels; else goto celt;
       cels: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       celt: // global
           I64[Sp - 32] = block_cel6_info;
           _s85C::P64 = R1;
           _s85A::P64 = P64[R1 + 6];
           _s85B::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 24] = _s85A::P64;
           P64[Sp - 16] = _s85B::P64;
           P64[Sp - 8] = _s85C::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uelB; else goto cel7;
       uelB: // global
           call _cel6(R1) args: 0, res: 0, upd: 0;
       cel7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_s85C_info" {
     go_s85C_info:
         const go_s85C_entry;
         const 2;
         const 11;
         const 8589934597;
 },
 _cel6() //  [R1]
         { []
         }
     {offset
       cel6: // global
           if (R1 & 7 == 1) goto celo; else goto celp;
       celo: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       celp: // global
           I64[Sp] = block_celc_info;
           _s85H::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _s85H::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cel6_info" {
     block_cel6_info:
         const _cel6;
         const 3;
         const 30;
 },
 _celc() //  [R1]
         { []
         }
     {offset
       celc: // global
           I64[Sp] = block_cele_info;
           R2 = P64[Sp + 16];
           _s85K::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s85K::P64;
           call go_s85C_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_celc_info" {
     block_celc_info:
         const _celc;
         const 3;
         const 30;
 },
 _cele() //  [R1]
         { []
         }
     {offset
       cele: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto celA; else goto celz;
       celA: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       celz: // global
           I64[Hp - 32] = sat_s85O_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cele_info" {
     block_cele_info:
         const _cele;
         const 131;
         const 30;
 },
 GHC.Base.$fMonoidIO1_entry() //  [R2, R3]
         { []
         }
     {offset
       celC: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto celG; else goto celF;
       celG: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       celF: // global
           I64[Hp - 64] = $dSemigroup_s85A_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = lvl3_s85B_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_s85C_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R2 = R3;
           R1 = Hp - 14;
           call go_s85C_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoidIO1_info" {
     GHC.Base.$fMonoidIO1_info:
         const GHC.Base.$fMonoidIO1_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.337506943 UTC

[section ""data" . GHC.Base.$fMonoidIO_closure" {
     GHC.Base.$fMonoidIO_closure:
         const GHC.Base.$fMonoidIO_info;
         const 0;
 },
 sat_s85V_entry() //  [R1, R2]
         { []
         }
     {offset
       cemu: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoidIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s85V_info" {
     sat_s85V_info:
         const sat_s85V_entry;
         const 1;
         const 9;
         const 8589934597;
 },
 sat_s85U_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cemC: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fMonoidIO_$cmappend_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s85U_info" {
     sat_s85U_info:
         const sat_s85U_entry;
         const 1;
         const 9;
         const 12884901903;
 },
 sat_s85S_entry() //  [R1]
         { []
         }
     {offset
       cemO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cemP; else goto cemQ;
       cemP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cemQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s85S_info" {
     sat_s85S_info:
         const sat_s85S_entry;
         const 1;
         const 16;
 },
 sat_s85T_entry() //  [R1]
         { []
         }
     {offset
       cemR: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cemV; else goto cemU;
       cemV: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cemU: // global
           _s85P::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_s85S_info;
           P64[Hp] = _s85P::P64;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s85T_info" {
     sat_s85T_info:
         const sat_s85T_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_s85Q_entry() //  [R1]
         { []
         }
     {offset
       cen0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cen1; else goto cen2;
       cen1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cen2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoidIO_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s85Q_info" {
     sat_s85Q_info:
         const sat_s85Q_entry;
         const 1;
         const 4294967312;
         const S8R0_srt+24;
 },
 GHC.Base.$fMonoidIO_entry() //  [R2]
         { []
         }
     {offset
       cen4: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto cen8; else goto cen7;
       cen8: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = GHC.Base.$fMonoidIO_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cen7: // global
           I64[Hp - 104] = sat_s85V_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s85U_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s85T_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s85Q_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 71;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoidIO_info" {
     GHC.Base.$fMonoidIO_info:
         const GHC.Base.$fMonoidIO_entry;
         const 0;
         const 141733920782;
         const 4294967301;
         const S8R0_srt+24;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.349056042 UTC

[section ""data" . GHC.Base.$fFunctor[]_$c<$_closure" {
     GHC.Base.$fFunctor[]_$c<$_closure:
         const GHC.Base.$fFunctor[]_$c<$_info;
 },
 sat_s85Z_entry() //  [R1]
         { []
         }
     {offset
       cenJ: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s85Z_info" {
     sat_s85Z_info:
         const sat_s85Z_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 GHC.Base.$fFunctor[]_$c<$_entry() //  [R2, R3]
         { []
         }
     {offset
       cenM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cenQ; else goto cenP;
       cenQ: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctor[]_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cenP: // global
           I64[Hp - 8] = sat_s85Z_info;
           P64[Hp] = R2;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fFunctor[]_$c<$_info" {
     GHC.Base.$fFunctor[]_$c<$_info:
         const GHC.Base.$fFunctor[]_$c<$_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.355525755 UTC

[section ""data" . GHC.Base.$fFunctorNonEmpty_$c<$_closure" {
     GHC.Base.$fFunctorNonEmpty_$c<$_closure:
         const GHC.Base.$fFunctorNonEmpty_$c<$_info;
 },
 sat_s866_entry() //  [R1]
         { []
         }
     {offset
       ceog: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s866_info" {
     sat_s866_info:
         const sat_s866_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_s867_entry() //  [R1]
         { []
         }
     {offset
       ceoj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceok; else goto ceol;
       ceok: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceol: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ceo6_info;
           _s860::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s860::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ueop; else goto ceo7;
       ueop: // global
           call _ceo6(R1) args: 0, res: 0, upd: 0;
       ceo7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s867_info" {
     sat_s867_info:
         const sat_s867_entry;
         const 2;
         const 18;
 },
 _ceo6() //  [R1]
         { []
         }
     {offset
       ceo6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ceoo; else goto ceon;
       ceoo: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ceon: // global
           _s864::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_s866_info;
           P64[Hp] = P64[Sp + 8];
           R3 = _s864::P64;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ceo6_info" {
     block_ceo6_info:
         const _ceo6;
         const 1;
         const 30;
 },
 GHC.Base.$fFunctorNonEmpty_$c<$_entry() //  [R2, R3]
         { []
         }
     {offset
       ceor: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ceov; else goto ceou;
       ceov: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorNonEmpty_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceou: // global
           I64[Hp - 48] = sat_s867_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fFunctorNonEmpty_$c<$_info" {
     GHC.Base.$fFunctorNonEmpty_$c<$_info:
         const GHC.Base.$fFunctorNonEmpty_$c<$_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.364173041 UTC

[section ""data" . GHC.Base.$fFunctor[]_closure" {
     GHC.Base.$fFunctor[]_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.map_closure+2;
         const GHC.Base.$fFunctor[]_$c<$_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.368029279 UTC

[section ""data" . GHC.Base.$fMonad[]_$c>>=_closure" {
     GHC.Base.$fMonad[]_$c>>=_closure:
         const GHC.Base.$fMonad[]_$c>>=_info;
 },
 sat_s86g_entry() //  [R1]
         { []
         }
     {offset
       cep8: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_s86a_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s86g_info" {
     sat_s86g_info:
         const sat_s86g_entry;
         const 2;
         const 18;
 },
 go_s86a_entry() //  [R1, R2]
         { []
         }
     {offset
       cepf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cepg; else goto ceph;
       cepg: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceph: // global
           I64[Sp - 24] = block_ceoY_info;
           _s86a::P64 = R1;
           _s869::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s869::P64;
           P64[Sp - 8] = _s86a::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ueps; else goto ceoZ;
       ueps: // global
           call _ceoY(R1) args: 0, res: 0, upd: 0;
       ceoZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_s86a_info" {
     go_s86a_info:
         const go_s86a_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _ceoY() //  [R1]
         { []
         }
     {offset
       ceoY: // global
           if (R1 & 7 == 1) goto cepc; else goto cepd;
       cepc: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cepd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cepn; else goto cepm;
       cepn: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cepm: // global
           _s86d::P64 = P64[R1 + 6];
           _s86e::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s86g_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s86e::P64;
           _s869::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cepk_info;
           R2 = _s86d::P64;
           R1 = _s869::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ceoY_info" {
     block_ceoY_info:
         const _ceoY;
         const 2;
         const 30;
 },
 _cepk() //  [R1]
         { []
         }
     {offset
       cepk: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cepk_info" {
     block_cepk_info:
         const _cepk;
         const 1;
         const 30;
 },
 GHC.Base.$fMonad[]_$c>>=_entry() //  [R2, R3]
         { []
         }
     {offset
       cept: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cepx; else goto cepw;
       cepx: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad[]_$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cepw: // global
           I64[Hp - 8] = go_s86a_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s86a_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonad[]_$c>>=_info" {
     GHC.Base.$fMonad[]_$c>>=_info:
         const GHC.Base.$fMonad[]_$c>>=_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.378526452 UTC

[section ""data" . GHC.Base.=<<_$s=<<_closure" {
     GHC.Base.=<<_$s=<<_closure:
         const GHC.Base.=<<_$s=<<_info;
 },
 GHC.Base.=<<_$s=<<_entry() //  [R2, R3]
         { []
         }
     {offset
       cepZ: // global
           _s86i::P64 = R3;
           R3 = R2;
           R2 = _s86i::P64;
           call GHC.Base.$fMonad[]_$c>>=_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.=<<_$s=<<_info" {
     GHC.Base.=<<_$s=<<_info:
         const GHC.Base.=<<_$s=<<_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.382123291 UTC

[section ""data" . GHC.Base.=<<_closure" {
     GHC.Base.=<<_closure:
         const GHC.Base.=<<_info;
 },
 GHC.Base.=<<_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ceqa: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ceqb; else goto ceqc;
       ceqb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.=<<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceqc: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.=<<_info" {
     GHC.Base.=<<_info:
         const GHC.Base.=<<_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.386777354 UTC

[section ""data" . poly_go_r7PI_closure" {
     poly_go_r7PI_closure:
         const poly_go_r7PI_info;
 },
 sat_s86q_entry() //  [R1]
         { []
         }
     {offset
       ceqw: // global
           R2 = P64[R1 + 16];
           call poly_go_r7PI_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s86q_info" {
     sat_s86q_info:
         const sat_s86q_entry;
         const 1;
         const 16;
 },
 poly_go_r7PI_entry() //  [R2]
         { []
         }
     {offset
       ceqD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ceqE; else goto ceqF;
       ceqE: // global
           R2 = R2;
           R1 = poly_go_r7PI_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceqF: // global
           I64[Sp - 8] = block_ceqm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ueqL; else goto ceqn;
       ueqL: // global
           call _ceqm(R1) args: 0, res: 0, upd: 0;
       ceqn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . poly_go_r7PI_info" {
     poly_go_r7PI_info:
         const poly_go_r7PI_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _ceqm() //  [R1]
         { []
         }
     {offset
       ceqm: // global
           if (R1 & 7 == 1) goto ceqA; else goto ceqB;
       ceqA: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ceqB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ceqK; else goto ceqJ;
       ceqK: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ceqJ: // global
           _s86o::P64 = P64[R1 + 6];
           _s86p::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_s86q_info;
           P64[Hp] = _s86p::P64;
           R3 = Hp - 16;
           R2 = _s86o::P64;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceqm_info" {
     block_ceqm_info:
         const _ceqm;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.394328463 UTC

[section ""data" . GHC.Base.$fMonoid[]_$cmconcat_closure" {
     GHC.Base.$fMonoid[]_$cmconcat_closure:
         const GHC.Base.$fMonoid[]_$cmconcat_info;
 },
 GHC.Base.$fMonoid[]_$cmconcat_entry() //  [R2]
         { []
         }
     {offset
       cer5: // global
           R2 = R2;
           call poly_go_r7PI_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid[]_$cmconcat_info" {
     GHC.Base.$fMonoid[]_$cmconcat_info:
         const GHC.Base.$fMonoid[]_$cmconcat_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.4003372 UTC

[section ""data" . GHC.Base.$fApplicative[]_$c<*>_closure" {
     GHC.Base.$fApplicative[]_$c<*>_closure:
         const GHC.Base.$fApplicative[]_$c<*>_info;
 },
 go1_s86A_entry() //  [R1, R2]
         { []
         }
     {offset
       cerE: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cerF; else goto cerG;
       cerF: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cerG: // global
           I64[Sp - 32] = block_cerx_info;
           _s86A::P64 = R1;
           _s86x::P64 = P64[R1 + 7];
           _s86z::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s86x::P64;
           P64[Sp - 16] = _s86z::P64;
           P64[Sp - 8] = _s86A::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uerS; else goto cery;
       uerS: // global
           call _cerx(R1) args: 0, res: 0, upd: 0;
       cery: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go1_s86A_info" {
     go1_s86A_info:
         const go1_s86A_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _cerx() //  [R1]
         { []
         }
     {offset
       cerx: // global
           if (R1 & 7 == 1) goto cerB; else goto cerC;
       cerB: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cerC: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cerR; else goto cerQ;
       cerR: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cerQ: // global
           _s86D::P64 = P64[R1 + 6];
           _s86E::P64 = P64[R1 + 14];
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = P64[Sp + 24];
           P64[Hp - 56] = _s86E::P64;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s86D::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cerx_info" {
     block_cerx_info:
         const _cerx;
         const 3;
         const 30;
 },
 go_s86u_entry() //  [R1, R2]
         { []
         }
     {offset
       cerX: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cerY; else goto cerZ;
       cerY: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cerZ: // global
           I64[Sp - 24] = block_cerl_info;
           _s86u::P64 = R1;
           _s86t::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s86t::P64;
           P64[Sp - 8] = _s86u::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ues5; else goto cerm;
       ues5: // global
           call _cerl(R1) args: 0, res: 0, upd: 0;
       cerm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_s86u_info" {
     go_s86u_info:
         const go_s86u_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _cerl() //  [R1]
         { []
         }
     {offset
       cerl: // global
           if (R1 & 7 == 1) goto cerU; else goto cerV;
       cerU: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cerV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ces4; else goto ces3;
       ces4: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ces3: // global
           _s86x::P64 = P64[R1 + 6];
           _s86y::P64 = P64[R1 + 14];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s86y::P64;
           I64[Hp - 16] = go1_s86A_info;
           P64[Hp - 8] = _s86x::P64;
           P64[Hp] = Hp - 48;
           R2 = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call go1_s86A_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cerl_info" {
     block_cerl_info:
         const _cerl;
         const 2;
         const 30;
 },
 GHC.Base.$fApplicative[]_$c<*>_entry() //  [R2, R3]
         { []
         }
     {offset
       ces6: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cesa; else goto ces9;
       cesa: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ces9: // global
           I64[Hp - 8] = go_s86u_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s86u_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative[]_$c<*>_info" {
     GHC.Base.$fApplicative[]_$c<*>_info:
         const GHC.Base.$fApplicative[]_$c<*>_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.414697357 UTC

[section ""data" . GHC.Base.$fApplicative[]_$cliftA2_closure" {
     GHC.Base.$fApplicative[]_$cliftA2_closure:
         const GHC.Base.$fApplicative[]_$cliftA2_info;
 },
 go1_s86Q_entry() //  [R1, R2]
         { []
         }
     {offset
       cetb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cetc; else goto cetd;
       cetc: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cetd: // global
           I64[Sp - 40] = block_cet4_info;
           _s86Q::P64 = R1;
           _s86H::P64 = P64[R1 + 7];
           _s86N::P64 = P64[R1 + 15];
           _s86P::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _s86H::P64;
           P64[Sp - 24] = _s86N::P64;
           P64[Sp - 16] = _s86P::P64;
           P64[Sp - 8] = _s86Q::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uetp; else goto cet5;
       uetp: // global
           call _cet4(R1) args: 0, res: 0, upd: 0;
       cet5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go1_s86Q_info" {
     go1_s86Q_info:
         const go1_s86Q_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 _cet4() //  [R1]
         { []
         }
     {offset
       cet4: // global
           if (R1 & 7 == 1) goto cet8; else goto cet9;
       cet8: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cet9: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ceto; else goto cetn;
       ceto: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cetn: // global
           _s86T::P64 = P64[R1 + 6];
           _s86U::P64 = P64[R1 + 14];
           I64[Hp - 88] = stg_ap_2_upd_info;
           P64[Hp - 72] = P64[Sp + 32];
           P64[Hp - 64] = _s86U::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s86T::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cet4_info" {
     block_cet4_info:
         const _cet4;
         const 4;
         const 30;
 },
 go_s86K_entry() //  [R1, R2]
         { []
         }
     {offset
       cetu: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cetv; else goto cetw;
       cetv: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cetw: // global
           I64[Sp - 32] = block_cesS_info;
           _s86K::P64 = R1;
           _s86H::P64 = P64[R1 + 7];
           _s86J::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s86H::P64;
           P64[Sp - 16] = _s86J::P64;
           P64[Sp - 8] = _s86K::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uetC; else goto cesT;
       uetC: // global
           call _cesS(R1) args: 0, res: 0, upd: 0;
       cesT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_s86K_info" {
     go_s86K_info:
         const go_s86K_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _cesS() //  [R1]
         { []
         }
     {offset
       cesS: // global
           if (R1 & 7 == 1) goto cetr; else goto cets;
       cetr: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cets: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cetB; else goto cetA;
       cetB: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cetA: // global
           _s86N::P64 = P64[R1 + 6];
           _s86O::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = _s86O::P64;
           I64[Hp - 24] = go1_s86Q_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _s86N::P64;
           P64[Hp] = Hp - 56;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call go1_s86Q_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cesS_info" {
     block_cesS_info:
         const _cesS;
         const 3;
         const 30;
 },
 GHC.Base.$fApplicative[]_$cliftA2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cetD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cetH; else goto cetG;
       cetH: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cetG: // global
           I64[Hp - 16] = go_s86K_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = R3;
           R1 = Hp - 15;
           call go_s86K_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative[]_$cliftA2_info" {
     GHC.Base.$fApplicative[]_$cliftA2_info:
         const GHC.Base.$fApplicative[]_$cliftA2_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.426506298 UTC

[section ""data" . GHC.Base.$fApplicative[]_$c<*_closure" {
     GHC.Base.$fApplicative[]_$c<*_closure:
         const GHC.Base.$fApplicative[]_$c<*_info;
 },
 GHC.Base.$fApplicative[]_$c<*_entry() //  [R2, R3]
         { []
         }
     {offset
       ceum: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Base.const_closure+2;
           call GHC.Base.$fApplicative[]_$cliftA2_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative[]_$c<*_info" {
     GHC.Base.$fApplicative[]_$c<*_info:
         const GHC.Base.$fApplicative[]_$c<*_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.431268217 UTC

[section ""data" . GHC.Base.$fApplicative[]_$c*>_closure" {
     GHC.Base.$fApplicative[]_$c*>_closure:
         const GHC.Base.$fApplicative[]_$c*>_info;
 },
 sat_s874_entry() //  [R1]
         { []
         }
     {offset
       ceuM: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_s86Z_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s874_info" {
     sat_s874_info:
         const sat_s874_entry;
         const 2;
         const 18;
 },
 go_s86Z_entry() //  [R1, R2]
         { []
         }
     {offset
       ceuT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ceuU; else goto ceuV;
       ceuU: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceuV: // global
           I64[Sp - 24] = block_ceuC_info;
           _s86Z::P64 = R1;
           _s86Y::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s86Y::P64;
           P64[Sp - 8] = _s86Z::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uev1; else goto ceuD;
       uev1: // global
           call _ceuC(R1) args: 0, res: 0, upd: 0;
       ceuD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_s86Z_info" {
     go_s86Z_info:
         const go_s86Z_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _ceuC() //  [R1]
         { []
         }
     {offset
       ceuC: // global
           if (R1 & 7 == 1) goto ceuQ; else goto ceuR;
       ceuQ: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ceuR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cev0; else goto ceuZ;
       cev0: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ceuZ: // global
           _s873::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_s874_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _s873::P64;
           R3 = Hp - 24;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceuC_info" {
     block_ceuC_info:
         const _ceuC;
         const 2;
         const 30;
 },
 GHC.Base.$fApplicative[]_$c*>_entry() //  [R2, R3]
         { []
         }
     {offset
       cev2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cev6; else goto cev5;
       cev6: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$c*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cev5: // global
           I64[Hp - 8] = go_s86Z_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_s86Z_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative[]_$c*>_info" {
     GHC.Base.$fApplicative[]_$c*>_info:
         const GHC.Base.$fApplicative[]_$c*>_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.43981722 UTC

[section ""data" . GHC.Base.$fApplicative[]_closure" {
     GHC.Base.$fApplicative[]_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctor[]_closure+1;
         const GHC.Base.$fApplicative[]_$cpure_closure+1;
         const GHC.Base.$fApplicative[]_$c<*>_closure+2;
         const GHC.Base.$fApplicative[]_$cliftA2_closure+3;
         const GHC.Base.$fApplicative[]_$c*>_closure+2;
         const GHC.Base.$fApplicative[]_$c<*_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.443417976 UTC

[section ""data" . GHC.Base.$fFunctorNonEmpty_$cfmap_closure" {
     GHC.Base.$fFunctorNonEmpty_$cfmap_closure:
         const GHC.Base.$fFunctorNonEmpty_$cfmap_info;
 },
 sat_s87f_entry() //  [R1]
         { []
         }
     {offset
       cevC: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cevD; else goto cevE;
       cevD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cevE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cevz_info;
           _s875::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _s875::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uevI; else goto cevA;
       uevI: // global
           call _cevz(R1) args: 0, res: 0, upd: 0;
       cevA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s87f_info" {
     sat_s87f_info:
         const sat_s87f_entry;
         const 2;
         const 18;
 },
 _cevz() //  [R1]
         { []
         }
     {offset
       cevz: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cevz_info" {
     block_cevz_info:
         const _cevz;
         const 1;
         const 30;
 },
 sat_s87b_entry() //  [R1]
         { []
         }
     {offset
       cevO: // global
           _s87b::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cevP; else goto cevQ;
       cevQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cevS; else goto cevR;
       cevS: // global
           HpAlloc = 24;
           goto cevP;
       cevP: // global
           R1 = _s87b::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cevR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s87b::P64;
           _s875::P64 = P64[_s87b::P64 + 16];
           _s876::P64 = P64[_s87b::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s876::P64;
           R2 = Hp - 16;
           R1 = _s875::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s87b_info" {
     sat_s87b_info:
         const sat_s87b_entry;
         const 2;
         const 18;
 },
 GHC.Base.$fFunctorNonEmpty_$cfmap_entry() //  [R2, R3]
         { []
         }
     {offset
       cevU: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cevY; else goto cevX;
       cevY: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorNonEmpty_$cfmap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cevX: // global
           I64[Hp - 80] = sat_s87f_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_s87b_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fFunctorNonEmpty_$cfmap_info" {
     GHC.Base.$fFunctorNonEmpty_$cfmap_info:
         const GHC.Base.$fFunctorNonEmpty_$cfmap_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.452268473 UTC

[section ""data" . GHC.Base.$fFunctorNonEmpty_closure" {
     GHC.Base.$fFunctorNonEmpty_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fFunctorNonEmpty_$cfmap_closure+2;
         const GHC.Base.$fFunctorNonEmpty_$c<$_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.453865154 UTC

[section ""data" . GHC.Base.$fAlternative[]1_closure" {
     GHC.Base.$fAlternative[]1_closure:
         const :_con_info;
         const GHC.Types.[]_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.459069914 UTC

[section ""data" . GHC.Base.$fAlternative[]_$csome_closure" {
     GHC.Base.$fAlternative[]_$csome_closure:
         const GHC.Base.$fAlternative[]_$csome_info;
 },
 ys_s87i_entry() //  [R1]
         { []
         }
     {offset
       ceww: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cewx; else goto cewy;
       cewx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cewy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.Base.$fAlternative[]1_closure+2;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ys_s87i_info" {
     ys_s87i_info:
         const ys_s87i_entry;
         const 1;
         const 16;
 },
 go1_s87p_entry() //  [R1, R2]
         { []
         }
     {offset
       cewX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cewY; else goto cewZ;
       cewY: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cewZ: // global
           I64[Sp - 32] = block_cewQ_info;
           _s87p::P64 = R1;
           _s87m::P64 = P64[R1 + 7];
           _s87o::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s87m::P64;
           P64[Sp - 16] = _s87o::P64;
           P64[Sp - 8] = _s87p::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uexb; else goto cewR;
       uexb: // global
           call _cewQ(R1) args: 0, res: 0, upd: 0;
       cewR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go1_s87p_info" {
     go1_s87p_info:
         const go1_s87p_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _cewQ() //  [R1]
         { []
         }
     {offset
       cewQ: // global
           if (R1 & 7 == 1) goto cewU; else goto cewV;
       cewU: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cewV: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cexa; else goto cex9;
       cexa: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cex9: // global
           _s87s::P64 = P64[R1 + 6];
           _s87t::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _s87t::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s87s::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cewQ_info" {
     block_cewQ_info:
         const _cewQ;
         const 3;
         const 30;
 },
 go_s87j_entry() //  [R1, R2]
         { []
         }
     {offset
       cexg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cexh; else goto cexi;
       cexh: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cexi: // global
           I64[Sp - 24] = block_cewE_info;
           _s87j::P64 = R1;
           _s87i::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s87i::P64;
           P64[Sp - 8] = _s87j::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uexo; else goto cewF;
       uexo: // global
           call _cewE(R1) args: 0, res: 0, upd: 0;
       cewF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_s87j_info" {
     go_s87j_info:
         const go_s87j_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _cewE() //  [R1]
         { []
         }
     {offset
       cewE: // global
           if (R1 & 7 == 1) goto cexd; else goto cexe;
       cexd: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cexe: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cexn; else goto cexm;
       cexn: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cexm: // global
           _s87m::P64 = P64[R1 + 6];
           _s87n::P64 = P64[R1 + 14];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s87n::P64;
           I64[Hp - 16] = go1_s87p_info;
           P64[Hp - 8] = _s87m::P64;
           P64[Hp] = Hp - 48;
           R2 = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call go1_s87p_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cewE_info" {
     block_cewE_info:
         const _cewE;
         const 2;
         const 30;
 },
 some_v_s87h_entry() //  [R1]
         { []
         }
     {offset
       cexp: // global
           _s87h::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cexq; else goto cexr;
       cexr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cext; else goto cexs;
       cext: // global
           HpAlloc = 40;
           goto cexq;
       cexq: // global
           R1 = _s87h::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cexs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s87h::P64;
           _s87g::P64 = P64[_s87h::P64 + 16];
           I64[Hp - 32] = ys_s87i_info;
           P64[Hp - 16] = _s87h::P64;
           I64[Hp - 8] = go_s87j_info;
           P64[Hp] = Hp - 32;
           R2 = _s87g::P64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call go_s87j_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . some_v_s87h_info" {
     some_v_s87h_info:
         const some_v_s87h_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fAlternative[]_$csome_entry() //  [R2]
         { []
         }
     {offset
       cexu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cexy; else goto cexx;
       cexy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternative[]_$csome_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cexx: // global
           I64[Hp - 16] = some_v_s87h_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fAlternative[]_$csome_info" {
     GHC.Base.$fAlternative[]_$csome_info:
         const GHC.Base.$fAlternative[]_$csome_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.476636528 UTC

[section ""data" . GHC.Base.$fAlternative[]_$cmany_closure" {
     GHC.Base.$fAlternative[]_$cmany_closure:
         const GHC.Base.$fAlternative[]_$cmany_info;
 },
 go1_s87E_entry() //  [R1, R2]
         { []
         }
     {offset
       ceyO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceyP; else goto ceyQ;
       ceyP: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceyQ: // global
           I64[Sp - 32] = block_ceyH_info;
           _s87E::P64 = R1;
           _s87B::P64 = P64[R1 + 7];
           _s87D::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s87B::P64;
           P64[Sp - 16] = _s87D::P64;
           P64[Sp - 8] = _s87E::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uez2; else goto ceyI;
       uez2: // global
           call _ceyH(R1) args: 0, res: 0, upd: 0;
       ceyI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go1_s87E_info" {
     go1_s87E_info:
         const go1_s87E_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _ceyH() //  [R1]
         { []
         }
     {offset
       ceyH: // global
           if (R1 & 7 == 1) goto ceyL; else goto ceyM;
       ceyL: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ceyM: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cez1; else goto cez0;
       cez1: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cez0: // global
           _s87H::P64 = P64[R1 + 6];
           _s87I::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _s87I::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s87H::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceyH_info" {
     block_ceyH_info:
         const _ceyH;
         const 3;
         const 30;
 },
 go_s87y_entry() //  [R1, R2]
         { []
         }
     {offset
       cez7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cez8; else goto cez9;
       cez8: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cez9: // global
           I64[Sp - 24] = block_ceyv_info;
           _s87y::P64 = R1;
           _s87x::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s87x::P64;
           P64[Sp - 8] = _s87y::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uezf; else goto ceyw;
       uezf: // global
           call _ceyv(R1) args: 0, res: 0, upd: 0;
       ceyw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_s87y_info" {
     go_s87y_info:
         const go_s87y_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _ceyv() //  [R1]
         { []
         }
     {offset
       ceyv: // global
           if (R1 & 7 == 1) goto cez4; else goto cez5;
       cez4: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cez5: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ceze; else goto cezd;
       ceze: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cezd: // global
           _s87B::P64 = P64[R1 + 6];
           _s87C::P64 = P64[R1 + 14];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s87C::P64;
           I64[Hp - 16] = go1_s87E_info;
           P64[Hp - 8] = _s87B::P64;
           P64[Hp] = Hp - 48;
           R2 = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call go1_s87E_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceyv_info" {
     block_ceyv_info:
         const _ceyv;
         const 2;
         const 30;
 },
 many_v_s87x_entry() //  [R1]
         { []
         }
     {offset
       cezi: // global
           _s87x::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cezj; else goto cezk;
       cezk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cezm; else goto cezl;
       cezm: // global
           HpAlloc = 16;
           goto cezj;
       cezj: // global
           R1 = _s87x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cezl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s87x::P64;
           _s87w::P64 = P64[_s87x::P64 + 16];
           I64[Hp - 8] = go_s87y_info;
           P64[Hp] = _s87x::P64;
           I64[Sp - 24] = block_cezg_info;
           R2 = _s87w::P64;
           R1 = Hp - 7;
           Sp = Sp - 24;
           call go_s87y_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . many_v_s87x_info" {
     many_v_s87x_info:
         const many_v_s87x_entry;
         const 1;
         const 16;
 },
 _cezg() //  [R1]
         { []
         }
     {offset
       cezg: // global
           R3 = GHC.Base.$fAlternative[]1_closure+2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cezg_info" {
     block_cezg_info:
         const _cezg;
         const 0;
         const 30;
 },
 GHC.Base.$fAlternative[]_$cmany_entry() //  [R2]
         { []
         }
     {offset
       cezq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cezu; else goto cezt;
       cezu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternative[]_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cezt: // global
           I64[Hp - 16] = many_v_s87x_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fAlternative[]_$cmany_info" {
     GHC.Base.$fAlternative[]_$cmany_info:
         const GHC.Base.$fAlternative[]_$cmany_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.491243239 UTC

[section ""data" . GHC.Base.$fAlternative[]_closure" {
     GHC.Base.$fAlternative[]_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Base.$fApplicative[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.++_closure+2;
         const GHC.Base.$fAlternative[]_$csome_closure+1;
         const GHC.Base.$fAlternative[]_$cmany_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.497661447 UTC

[section ""data" . GHC.Base.$w$c>>=_closure" {
     GHC.Base.$w$c>>=_closure:
         const GHC.Base.$w$c>>=_info;
 },
 ds_s87O_entry() //  [R1]
         { []
         }
     {offset
       ceAm: // global
           _s87O::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ceAn; else goto ceAo;
       ceAo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ceAq; else goto ceAp;
       ceAq: // global
           HpAlloc = 24;
           goto ceAn;
       ceAn: // global
           R1 = _s87O::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceAp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s87O::P64;
           _s87M::P64 = P64[_s87O::P64 + 16];
           _s87N::P64 = P64[_s87O::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _s87M::P64;
           R2 = Hp - 16;
           R1 = _s87N::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ds_s87O_info" {
     ds_s87O_info:
         const ds_s87O_entry;
         const 2;
         const 18;
 },
 sat_s88i_entry() //  [R1]
         { []
         }
     {offset
       ceAZ: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_s883_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s88i_info" {
     sat_s88i_info:
         const sat_s88i_entry;
         const 2;
         const 18;
 },
 go_s883_entry() //  [R1, R2]
         { []
         }
     {offset
       ceB6: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ceB7; else goto ceB8;
       ceB7: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceB8: // global
           I64[Sp - 24] = block_ceAO_info;
           _s883::P64 = R1;
           _s87N::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _s87N::P64;
           P64[Sp - 8] = _s883::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ueBh; else goto ceAP;
       ueBh: // global
           call _ceAO(R1) args: 0, res: 0, upd: 0;
       ceAP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_s883_info" {
     go_s883_info:
         const go_s883_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _ceAO() //  [R1]
         { []
         }
     {offset
       ceAO: // global
           if (R1 & 7 == 1) goto ceB3; else goto ceB4;
       ceB3: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ceB4: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto ceBg; else goto ceBf;
       ceBg: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ceBf: // global
           _s886::P64 = P64[R1 + 6];
           _s887::P64 = P64[R1 + 14];
           I64[Hp - 128] = stg_ap_2_upd_info;
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = _s886::P64;
           I64[Hp - 96] = sat_s88i_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _s887::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _ceAU::P64 = Hp - 128;
           P64[Hp - 48] = _ceAU::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _ceAU::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 96;
           R2 = Hp - 14;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceAO_info" {
     block_ceAO_info:
         const _ceAO;
         const 2;
         const 30;
 },
 sat_s88j_entry() //  [R1]
         { []
         }
     {offset
       ceBi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceBj; else goto ceBk;
       ceBj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceBk: // global
           I64[Sp - 16] = block_ceAE_info;
           _s87N::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _s87N::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ueBo; else goto ceAF;
       ueBo: // global
           call _ceAE(R1) args: 0, res: 0, upd: 0;
       ceAF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s88j_info" {
     sat_s88j_info:
         const sat_s88j_entry;
         const 2;
         const 18;
 },
 _ceAE() //  [R1]
         { []
         }
     {offset
       ceAE: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ceBn; else goto ceBm;
       ceBn: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ceBm: // global
           _s882::P64 = P64[R1 + 15];
           I64[Hp - 8] = go_s883_info;
           P64[Hp] = P64[Sp + 8];
           R2 = _s882::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call go_s883_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceAE_info" {
     block_ceAE_info:
         const _ceAE;
         const 1;
         const 30;
 },
 sat_s88k_entry() //  [R1]
         { []
         }
     {offset
       ceBp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ceBq; else goto ceBr;
       ceBq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceBr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ceAv_info;
           _s87M::P64 = P64[R1 + 16];
           _s87N::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _s87M::P64;
           P64[Sp - 24] = _s87N::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ueBv; else goto ceAw;
       ueBv: // global
           call _ceAv(R1) args: 0, res: 0, upd: 0;
       ceAw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s88k_info" {
     sat_s88k_info:
         const sat_s88k_entry;
         const 3;
         const 15;
 },
 _ceAv() //  [R1]
         { []
         }
     {offset
       ceAv: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ceBu; else goto ceBt;
       ceBu: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ceBt: // global
           _s87Z::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_s88j_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R3 = Hp - 24;
           R2 = _s87Z::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ceAv_info" {
     block_ceAv_info:
         const _ceAv;
         const 2;
         const 30;
 },
 GHC.Base.$w$c>>=_entry() //  [R2, R3]
         { []
         }
     {offset
       ceBx: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ceBB; else goto ceBA;
       ceBB: // global
           HpAlloc = 96;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceBA: // global
           I64[Hp - 88] = ds_s87O_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_s88k_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           _ceAh::P64 = Hp - 88;
           P64[Hp - 24] = _ceAh::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _ceAh::P64;
           R2 = Hp - 56;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$c>>=_info" {
     GHC.Base.$w$c>>=_info:
         const GHC.Base.$w$c>>=_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.515892868 UTC

[section ""data" . GHC.Base.$fMonadNonEmpty_$c>>=_closure" {
     GHC.Base.$fMonadNonEmpty_$c>>=_closure:
         const GHC.Base.$fMonadNonEmpty_$c>>=_info;
 },
 GHC.Base.$fMonadNonEmpty_$c>>=_entry() //  [R2, R3]
         { []
         }
     {offset
       ceCt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ceCu; else goto ceCv;
       ceCu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonadNonEmpty_$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceCv: // global
           I64[Sp - 8] = block_ceCq_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonadNonEmpty_$c>>=_info" {
     GHC.Base.$fMonadNonEmpty_$c>>=_info:
         const GHC.Base.$fMonadNonEmpty_$c>>=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ceCq() //  [R1, R2]
         { []
         }
     {offset
       ceCq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ceCy; else goto ceCx;
       ceCy: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ceCx: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceCq_info" {
     block_ceCq_info:
         const _ceCq;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.522368259 UTC

[section ""data" . GHC.Base.$fMonadNonEmpty_$c>>_closure" {
     GHC.Base.$fMonadNonEmpty_$c>>_closure:
         const GHC.Base.$fMonadNonEmpty_$c>>_info;
 },
 sat_s88t_entry() //  [R1]
         { []
         }
     {offset
       ceCR: // global
           R1 = P64[R1 + 7] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s88t_info" {
     sat_s88t_info:
         const sat_s88t_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 GHC.Base.$fMonadNonEmpty_$c>>_entry() //  [R2, R3]
         { []
         }
     {offset
       ceCX: // global
           _s88r::P64 = R3;
           _s88q::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ceCY; else goto ceCZ;
       ceCZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ceD1; else goto ceD0;
       ceD1: // global
           HpAlloc = 16;
           goto ceCY;
       ceCY: // global
           R3 = _s88r::P64;
           R2 = _s88q::P64;
           R1 = GHC.Base.$fMonadNonEmpty_$c>>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceD0: // global
           I64[Hp - 8] = sat_s88t_info;
           P64[Hp] = _s88r::P64;
           I64[Sp - 8] = block_ceCU_info;
           R3 = Hp - 7;
           R2 = _s88q::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonadNonEmpty_$c>>_info" {
     GHC.Base.$fMonadNonEmpty_$c>>_info:
         const GHC.Base.$fMonadNonEmpty_$c>>_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ceCU() //  [R1, R2]
         { []
         }
     {offset
       ceCU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ceD4; else goto ceD3;
       ceD4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ceD3: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceCU_info" {
     block_ceCU_info:
         const _ceCU;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.528939718 UTC

[section ""data" . GHC.Base.<**>1_closure" {
     GHC.Base.<**>1_closure:
         const GHC.Base.<**>1_info;
 },
 GHC.Base.<**>1_entry() //  [R2, R3]
         { []
         }
     {offset
       ceDn: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.<**>1_info" {
     GHC.Base.<**>1_info:
         const GHC.Base.<**>1_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.532363326 UTC

[section ""data" . GHC.Base.<**>_closure" {
     GHC.Base.<**>_closure:
         const GHC.Base.<**>_info;
 },
 GHC.Base.<**>_entry() //  [R2]
         { []
         }
     {offset
       ceDy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceDz; else goto ceDA;
       ceDz: // global
           R2 = R2;
           R1 = GHC.Base.<**>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceDA: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.<**>1_closure+2;
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.<**>_info" {
     GHC.Base.<**>_info:
         const GHC.Base.<**>_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.537291619 UTC

[section ""data" . GHC.Base.$dmliftA2_closure" {
     GHC.Base.$dmliftA2_closure:
         const GHC.Base.$dmliftA2_info;
 },
 sat_s88E_entry() //  [R1]
         { []
         }
     {offset
       ceDQ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ceDR; else goto ceDS;
       ceDR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceDS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ceDO_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s88E_info" {
     sat_s88E_info:
         const sat_s88E_entry;
         const 3;
         const 15;
 },
 _ceDO() //  [R1]
         { []
         }
     {offset
       ceDO: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ceDO_info" {
     block_ceDO_info:
         const _ceDO;
         const 2;
         const 30;
 },
 GHC.Base.$dmliftA2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ceDW: // global
           _s88C::P64 = R4;
           _s88B::P64 = R3;
           _s88A::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto ceDX; else goto ceDY;
       ceDY: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ceE0; else goto ceDZ;
       ceE0: // global
           HpAlloc = 40;
           goto ceDX;
       ceDX: // global
           R4 = _s88C::P64;
           R3 = _s88B::P64;
           R2 = _s88A::P64;
           R1 = GHC.Base.$dmliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceDZ: // global
           I64[Hp - 32] = sat_s88E_info;
           P64[Hp - 16] = _s88A::P64;
           P64[Hp - 8] = _s88B::P64;
           P64[Hp] = _s88C::P64;
           R2 = _s88A::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.<*>_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmliftA2_info" {
     GHC.Base.$dmliftA2_info:
         const GHC.Base.$dmliftA2_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.546437848 UTC

[section ""data" . GHC.Base.$dmsome_closure" {
     GHC.Base.$dmsome_closure:
         const GHC.Base.$dmsome_info;
 },
 sat_s88J_entry() //  [R1]
         { []
         }
     {offset
       ceEA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceEB; else goto ceEC;
       ceEB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceEC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s88J_info" {
     sat_s88J_info:
         const sat_s88J_entry;
         const 1;
         const 16;
 },
 sat_s88K_entry() //  [R1]
         { []
         }
     {offset
       ceED: // global
           _s88K::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto ceEE; else goto ceEF;
       ceEF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ceEH; else goto ceEG;
       ceEH: // global
           HpAlloc = 24;
           goto ceEE;
       ceEE: // global
           R1 = _s88K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceEG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s88K::P64;
           _s88F::P64 = P64[_s88K::P64 + 16];
           _s88H::P64 = P64[_s88K::P64 + 24];
           _s88I::P64 = P64[_s88K::P64 + 32];
           I64[Hp - 16] = sat_s88J_info;
           P64[Hp] = _s88I::P64;
           R2 = _s88F::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _s88H::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s88K_info" {
     sat_s88K_info:
         const sat_s88K_entry;
         const 3;
         const 15;
 },
 some_v_s88H_entry() //  [R1]
         { []
         }
     {offset
       ceEI: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ceEJ; else goto ceEK;
       ceEJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceEK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_ceEo_info;
           _s88F::P64 = P64[R1 + 16];
           R2 = _s88F::P64;
           P64[Sp - 40] = _s88F::P64;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = R1;
           Sp = Sp - 48;
           call GHC.Base.$p1Alternative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . some_v_s88H_info" {
     some_v_s88H_info:
         const some_v_s88H_entry;
         const 2;
         const 18;
 },
 _ceEo() //  [R1]
         { []
         }
     {offset
       ceEo: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ceEN; else goto ceEM;
       ceEN: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ceEM: // global
           I64[Hp - 32] = sat_s88K_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 32;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ceEo_info" {
     block_ceEo_info:
         const _ceEo;
         const 3;
         const 30;
 },
 GHC.Base.$dmsome_entry() //  [R2, R3]
         { []
         }
     {offset
       ceEO: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ceES; else goto ceER;
       ceES: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmsome_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceER: // global
           I64[Hp - 24] = some_v_s88H_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmsome_info" {
     GHC.Base.$dmsome_info:
         const GHC.Base.$dmsome_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.559358496 UTC

[section ""data" . GHC.Base.$dmmany_closure" {
     GHC.Base.$dmmany_closure:
         const GHC.Base.$dmmany_info;
 },
 $dApplicative_s88O_entry() //  [R1]
         { []
         }
     {offset
       ceFt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceFu; else goto ceFv;
       ceFu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceFv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dApplicative_s88O_info" {
     $dApplicative_s88O_info:
         const $dApplicative_s88O_entry;
         const 1;
         const 16;
 },
 sat_s88Q_entry() //  [R1]
         { []
         }
     {offset
       ceFA: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceFB; else goto ceFC;
       ceFB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceFC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s88Q_info" {
     sat_s88Q_info:
         const sat_s88Q_entry;
         const 1;
         const 16;
 },
 sat_s88P_entry() //  [R1]
         { []
         }
     {offset
       ceFH: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ceFI; else goto ceFJ;
       ceFI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceFJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Types.:_closure+2;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s88P_info" {
     sat_s88P_info:
         const sat_s88P_entry;
         const 3;
         const 15;
 },
 many_v_s88N_entry() //  [R1]
         { []
         }
     {offset
       ceFK: // global
           _s88N::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto ceFL; else goto ceFM;
       ceFM: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ceFO; else goto ceFN;
       ceFO: // global
           HpAlloc = 88;
           goto ceFL;
       ceFL: // global
           R1 = _s88N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceFN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _s88N::P64;
           _s88L::P64 = P64[_s88N::P64 + 16];
           _s88M::P64 = P64[_s88N::P64 + 24];
           I64[Hp - 80] = $dApplicative_s88O_info;
           P64[Hp - 64] = _s88L::P64;
           I64[Hp - 56] = sat_s88Q_info;
           _ceFp::P64 = Hp - 80;
           P64[Hp - 40] = _ceFp::P64;
           I64[Hp - 32] = sat_s88P_info;
           P64[Hp - 16] = _s88M::P64;
           P64[Hp - 8] = _s88N::P64;
           P64[Hp] = _ceFp::P64;
           R2 = _s88L::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . many_v_s88N_info" {
     many_v_s88N_info:
         const many_v_s88N_entry;
         const 2;
         const 18;
 },
 GHC.Base.$dmmany_entry() //  [R2, R3]
         { []
         }
     {offset
       ceFP: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ceFT; else goto ceFS;
       ceFT: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmmany_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceFS: // global
           I64[Hp - 24] = many_v_s88N_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmmany_info" {
     GHC.Base.$dmmany_info:
         const GHC.Base.$dmmany_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.572441278 UTC

[section ""data" . GHC.Base.$w$csconcat3_closure" {
     GHC.Base.$w$csconcat3_closure:
         const GHC.Base.$w$csconcat3_info;
 },
 sat_s894_entry() //  [R1, R2]
         { []
         }
     {offset
       ceGF: // global
           _s891::P64 = R2;
           _s894::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ceGG; else goto ceGH;
       ceGH: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ceGJ; else goto ceGI;
       ceGJ: // global
           HpAlloc = 64;
           goto ceGG;
       ceGG: // global
           R2 = _s891::P64;
           R1 = _s894::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceGI: // global
           _s88R::P64 = P64[_s894::P64 + 7];
           _s88V::P64 = P64[_s894::P64 + 15];
           _s890::P64 = P64[_s894::P64 + 23];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _s890::P64;
           P64[Hp - 32] = _s891::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s88V::P64;
           P64[Hp] = _s891::P64;
           R2 = _s88R::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s894_info" {
     sat_s894_info:
         const sat_s894_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 go_s88U_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       ceGO: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceGP; else goto ceGQ;
       ceGP: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceGQ: // global
           I64[Sp - 32] = block_ceGr_info;
           _s88U::P64 = R1;
           _s88R::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s88R::P64;
           P64[Sp - 16] = _s88U::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ueGW; else goto ceGs;
       ueGW: // global
           call _ceGr(R1) args: 0, res: 0, upd: 0;
       ceGs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_s88U_info" {
     go_s88U_info:
         const go_s88U_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 _ceGr() //  [R1]
         { []
         }
     {offset
       ceGr: // global
           _s88V::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ceGL; else goto ceGM;
       ceGL: // global
           R1 = _s88V::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ceGM: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ceGV; else goto ceGU;
       ceGV: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ceGU: // global
           _s88Y::P64 = P64[R1 + 6];
           _s88Z::P64 = P64[R1 + 14];
           I64[Hp - 64] = stg_ap_3_upd_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = _s88Y::P64;
           P64[Hp - 32] = _s88Z::P64;
           I64[Hp - 24] = sat_s894_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _s88V::P64;
           P64[Hp] = Hp - 64;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceGr_info" {
     block_ceGr_info:
         const _ceGr;
         const 3;
         const 30;
 },
 GHC.Base.$w$csconcat3_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ceGX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ceH1; else goto ceH0;
       ceH1: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceH0: // global
           I64[Hp - 8] = go_s88U_info;
           P64[Hp] = R2;
           _s88S::P64 = R3;
           R3 = R4;
           R2 = _s88S::P64;
           R1 = Hp - 6;
           call go_s88U_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$csconcat3_info" {
     GHC.Base.$w$csconcat3_info:
         const GHC.Base.$w$csconcat3_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.582744167 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_$csconcat_closure" {
     GHC.Base.$fSemigroup(->)_$csconcat_closure:
         const GHC.Base.$fSemigroup(->)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(->)_$csconcat_entry() //  [R2, R3]
         { []
         }
     {offset
       ceHx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceHy; else goto ceHz;
       ceHy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(->)_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceHz: // global
           I64[Sp - 16] = block_ceHu_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ueHD; else goto ceHv;
       ueHD: // global
           call _ceHu(R1) args: 0, res: 0, upd: 0;
       ceHv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(->)_$csconcat_info" {
     GHC.Base.$fSemigroup(->)_$csconcat_info:
         const GHC.Base.$fSemigroup(->)_$csconcat_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ceHu() //  [R1]
         { []
         }
     {offset
       ceHu: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat3_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceHu_info" {
     block_ceHu_info:
         const _ceHu;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.590722049 UTC

[section ""data" . GHC.Base.$w$csconcat_closure" {
     GHC.Base.$w$csconcat_closure:
         const GHC.Base.$w$csconcat_info;
 },
 sat_s89t_entry() //  [R1]
         { []
         }
     {offset
       ceId: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ceIe; else goto ceIf;
       ceIe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceIf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s89t_info" {
     sat_s89t_info:
         const sat_s89t_entry;
         const 3;
         const 15;
 },
 sat_s89s_entry() //  [R1]
         { []
         }
     {offset
       ceIk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ceIl; else goto ceIm;
       ceIl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceIm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s89s_info" {
     sat_s89s_info:
         const sat_s89s_entry;
         const 3;
         const 15;
 },
 $wgo_s89f_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       ceIr: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ceIs; else goto ceIt;
       ceIs: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceIt: // global
           I64[Sp - 48] = block_ceHW_info;
           _s89f::P64 = R1;
           _s89a::P64 = P64[R1 + 5];
           _s89b::P64 = P64[R1 + 13];
           R1 = R4;
           P64[Sp - 40] = _s89a::P64;
           P64[Sp - 32] = _s89b::P64;
           P64[Sp - 24] = _s89f::P64;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ueIC; else goto ceHX;
       ueIC: // global
           call _ceHW(R1) args: 0, res: 0, upd: 0;
       ceHX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . $wgo_s89f_info" {
     $wgo_s89f_info:
         const $wgo_s89f_entry;
         const 2;
         const 11;
         const 12884901911;
 },
 _ceHW() //  [R1]
         { []
         }
     {offset
       ceHW: // global
           if (R1 & 7 == 1) goto ceIo; else goto ceIp;
       ceIo: // global
           R2 = P64[Sp + 40];
           R1 = P64[Sp + 32];
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ceIp: // global
           I64[Sp - 8] = block_ceI2_info;
           _s89l::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s89l::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ueIB; else goto ceI3;
       ueIB: // global
           call _ceI2(R1) args: 0, res: 0, upd: 0;
       ceI3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ceHW_info" {
     block_ceHW_info:
         const _ceHW;
         const 5;
         const 30;
 },
 _ceI2() //  [R1]
         { []
         }
     {offset
       ceI2: // global
           _s89l::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ceI7_info;
           R4 = _s89l::P64;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 32];
           Sp = Sp + 8;
           call $wgo_s89f_entry(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ceI2_info" {
     block_ceI2_info:
         const _ceI2;
         const 6;
         const 30;
 },
 _ceI7() //  [R1, R2]
         { []
         }
     {offset
       ceI7: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ceIA; else goto ceIz;
       ceIA: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ceIz: // global
           I64[Hp - 72] = sat_s89t_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s89s_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceI7_info" {
     block_ceI7_info:
         const _ceI7;
         const 261;
         const 30;
 },
 GHC.Base.$w$csconcat_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ceID: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ceIH; else goto ceIG;
       ceIH: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceIG: // global
           I64[Hp - 16] = $wgo_s89f_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _s89c::P64 = R4;
           R4 = R6;
           R3 = R5;
           R2 = _s89c::P64;
           R1 = Hp - 13;
           call $wgo_s89f_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$csconcat_info" {
     GHC.Base.$w$csconcat_info:
         const GHC.Base.$w$csconcat_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.611986588 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_$csconcat_closure" {
     GHC.Base.$fSemigroup(,)_$csconcat_closure:
         const GHC.Base.$fSemigroup(,)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(,)_$csconcat_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ceJs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceJD; else goto ceJE;
       ceJD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_$csconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceJE: // global
           I64[Sp - 24] = block_ceJp_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ueJL; else goto ceJq;
       ueJL: // global
           call _ceJp(R1) args: 0, res: 0, upd: 0;
       ceJq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,)_$csconcat_info" {
     GHC.Base.$fSemigroup(,)_$csconcat_info:
         const GHC.Base.$fSemigroup(,)_$csconcat_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ceJp() //  [R1]
         { []
         }
     {offset
       ceJp: // global
           I64[Sp - 8] = block_ceJv_info;
           _s89z::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s89z::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ueJK; else goto ceJw;
       ueJK: // global
           call _ceJv(R1) args: 0, res: 0, upd: 0;
       ceJw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ceJp_info" {
     block_ceJp_info:
         const _ceJp;
         const 2;
         const 30;
 },
 _ceJv() //  [R1]
         { []
         }
     {offset
       ceJv: // global
           _s89v::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_ceJA_info;
           R6 = P64[Sp + 8];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _s89v::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Base.$w$csconcat_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ceJv_info" {
     block_ceJv_info:
         const _ceJv;
         const 3;
         const 30;
 },
 _ceJA() //  [R1, R2]
         { []
         }
     {offset
       ceJA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ceJJ; else goto ceJI;
       ceJJ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ceJI: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceJA_info" {
     block_ceJA_info:
         const _ceJA;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.625576551 UTC

[section ""data" . GHC.Base.$dmsconcat_closure" {
     GHC.Base.$dmsconcat_closure:
         const GHC.Base.$dmsconcat_info;
 },
 go_s89L_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       ceKo: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceKp; else goto ceKq;
       ceKp: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceKq: // global
           I64[Sp - 32] = block_ceKh_info;
           _s89L::P64 = R1;
           _s89G::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _s89G::P64;
           P64[Sp - 16] = _s89L::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ueKA; else goto ceKi;
       ueKA: // global
           call _ceKh(R1) args: 0, res: 0, upd: 0;
       ceKi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_s89L_info" {
     go_s89L_info:
         const go_s89L_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 _ceKh() //  [R1]
         { []
         }
     {offset
       ceKh: // global
           _s89M::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ceKl; else goto ceKm;
       ceKl: // global
           R1 = _s89M::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ceKm: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ceKy; else goto ceKx;
       ceKy: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ceKx: // global
           _s89P::P64 = P64[R1 + 6];
           _s89Q::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _s89P::P64;
           P64[Hp] = _s89Q::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _s89M::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceKh_info" {
     block_ceKh_info:
         const _ceKh;
         const 3;
         const 30;
 },
 GHC.Base.$dmsconcat_entry() //  [R2, R3]
         { []
         }
     {offset
       ceKB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceKC; else goto ceKD;
       ceKC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmsconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ceKD: // global
           I64[Sp - 16] = block_ceK7_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ueKH; else goto ceK8;
       ueKH: // global
           call _ceK7(R1) args: 0, res: 0, upd: 0;
       ceK8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmsconcat_info" {
     GHC.Base.$dmsconcat_info:
         const GHC.Base.$dmsconcat_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ceK7() //  [R1]
         { []
         }
     {offset
       ceK7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ceKG; else goto ceKF;
       ceKG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ceKF: // global
           _s89J::P64 = P64[R1 + 7];
           _s89K::P64 = P64[R1 + 15];
           I64[Hp - 8] = go_s89L_info;
           P64[Hp] = P64[Sp + 8];
           R3 = _s89K::P64;
           R2 = _s89J::P64;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call go_s89L_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceK7_info" {
     block_ceK7_info:
         const _ceK7;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.635273239 UTC

[section ""data" . GHC.Base.$dmstimes_closure" {
     GHC.Base.$dmstimes_closure:
         const GHC.Base.$dmstimes_info;
         const 0;
 },
 GHC.Base.$dmstimes_entry() //  [R2, R3]
         { []
         }
     {offset
       ceL8: // global
           _s89T::P64 = R3;
           R3 = R2;
           R2 = _s89T::P64;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmstimes_info" {
     GHC.Base.$dmstimes_info:
         const GHC.Base.$dmstimes_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S8R0_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.638954047 UTC

[section ""data" . GHC.Base.$dmmappend_closure" {
     GHC.Base.$dmmappend_closure:
         const GHC.Base.$dmmappend_info;
 },
 GHC.Base.$dmmappend_entry() //  [R2]
         { []
         }
     {offset
       ceLl: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ceLm; else goto ceLn;
       ceLm: // global
           R2 = R2;
           R1 = GHC.Base.$dmmappend_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceLn: // global
           I64[Sp - 8] = block_ceLj_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmmappend_info" {
     GHC.Base.$dmmappend_info:
         const GHC.Base.$dmmappend_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _ceLj() //  [R1]
         { []
         }
     {offset
       ceLj: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.<>_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceLj_info" {
     block_ceLj_info:
         const _ceLj;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.644792865 UTC

[section ""data" . GHC.Base.$dm>>_closure" {
     GHC.Base.$dm>>_closure:
         const GHC.Base.$dm>>_info;
 },
 sat_s8a0_entry() //  [R1]
         { []
         }
     {offset
       ceLI: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8a0_info" {
     sat_s8a0_info:
         const sat_s8a0_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 GHC.Base.$dm>>_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ceLL: // global
           _s89Y::P64 = R4;
           _s89X::P64 = R3;
           _s89W::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto ceLM; else goto ceLN;
       ceLN: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ceLP; else goto ceLO;
       ceLP: // global
           HpAlloc = 16;
           goto ceLM;
       ceLM: // global
           R4 = _s89Y::P64;
           R3 = _s89X::P64;
           R2 = _s89W::P64;
           R1 = GHC.Base.$dm>>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceLO: // global
           I64[Hp - 8] = sat_s8a0_info;
           P64[Hp] = _s89Y::P64;
           R2 = _s89W::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _s89X::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dm>>_info" {
     GHC.Base.$dm>>_info:
         const GHC.Base.$dm>>_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.650450387 UTC

[section ""data" . GHC.Base.$dmreturn_closure" {
     GHC.Base.$dmreturn_closure:
         const GHC.Base.$dmreturn_info;
 },
 GHC.Base.$dmreturn_entry() //  [R2]
         { []
         }
     {offset
       ceM5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ceM6; else goto ceM7;
       ceM6: // global
           R2 = R2;
           R1 = GHC.Base.$dmreturn_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceM7: // global
           I64[Sp - 8] = block_ceM3_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmreturn_info" {
     GHC.Base.$dmreturn_info:
         const GHC.Base.$dmreturn_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _ceM3() //  [R1]
         { []
         }
     {offset
       ceM3: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceM3_info" {
     block_ceM3_info:
         const _ceM3;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.655241886 UTC

[section ""data" . GHC.Base.$dmfail_closure" {
     GHC.Base.$dmfail_closure:
         const GHC.Base.$dmfail_info;
         const 0;
 },
 GHC.Base.$dmfail_entry() //  [R3]
         { []
         }
     {offset
       ceMn: // global
           R2 = R3;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmfail_info" {
     GHC.Base.$dmfail_info:
         const GHC.Base.$dmfail_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const S8R0_srt+72;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.659354317 UTC

[section ""data" . GHC.Base.$dmmzero_closure" {
     GHC.Base.$dmmzero_closure:
         const GHC.Base.$dmmzero_info;
 },
 GHC.Base.$dmmzero_entry() //  [R2]
         { []
         }
     {offset
       ceMA: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ceMB; else goto ceMC;
       ceMB: // global
           R2 = R2;
           R1 = GHC.Base.$dmmzero_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceMC: // global
           I64[Sp - 8] = block_ceMy_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmmzero_info" {
     GHC.Base.$dmmzero_info:
         const GHC.Base.$dmmzero_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _ceMy() //  [R1]
         { []
         }
     {offset
       ceMy: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.empty_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceMy_info" {
     block_ceMy_info:
         const _ceMy;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.664530662 UTC

[section ""data" . GHC.Base.$dmmplus_closure" {
     GHC.Base.$dmmplus_closure:
         const GHC.Base.$dmmplus_info;
 },
 GHC.Base.$dmmplus_entry() //  [R2]
         { []
         }
     {offset
       ceMU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ceMV; else goto ceMW;
       ceMV: // global
           R2 = R2;
           R1 = GHC.Base.$dmmplus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceMW: // global
           I64[Sp - 8] = block_ceMS_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmmplus_info" {
     GHC.Base.$dmmplus_info:
         const GHC.Base.$dmmplus_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _ceMS() //  [R1]
         { []
         }
     {offset
       ceMS: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.<|>_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceMS_info" {
     block_ceMS_info:
         const _ceMS;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.670862471 UTC

[section ""data" . GHC.Base.$fEqMaybe_$c==_closure" {
     GHC.Base.$fEqMaybe_$c==_closure:
         const GHC.Base.$fEqMaybe_$c==_info;
 },
 GHC.Base.$fEqMaybe_$c==_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ceNj: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ceNk; else goto ceNl;
       ceNk: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqMaybe_$c==_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceNl: // global
           I64[Sp - 24] = block_ceNc_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ueNW; else goto ceNd;
       ueNW: // global
           call _ceNc(R1) args: 0, res: 0, upd: 0;
       ceNd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fEqMaybe_$c==_info" {
     GHC.Base.$fEqMaybe_$c==_info:
         const GHC.Base.$fEqMaybe_$c==_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ceNc() //  [R1]
         { []
         }
     {offset
       ceNc: // global
           _s8ab::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ceNg; else goto ceNh;
       ceNg: // global
           I64[Sp + 16] = block_ceNo_info;
           R1 = _s8ab::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ueNU; else goto ceNq;
       ueNU: // global
           call _ceNo(R1) args: 0, res: 0, upd: 0;
       ceNq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ceNh: // global
           I64[Sp] = block_ceND_info;
           _s8af::P64 = P64[R1 + 6];
           R1 = _s8ab::P64;
           P64[Sp + 16] = _s8af::P64;
           if (R1 & 7 != 0) goto ueNV; else goto ceNF;
       ueNV: // global
           call _ceND(R1) args: 0, res: 0, upd: 0;
       ceNF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ceNc_info" {
     block_ceNc_info:
         const _ceNc;
         const 2;
         const 30;
 },
 _ceNo() //  [R1]
         { []
         }
     {offset
       ceNo: // global
           if (R1 & 7 == 1) goto ceNw; else goto ueNT;
       ceNw: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ueNT: // global
           Sp = Sp + 8;
           call _ceNL() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ceNo_info" {
     block_ceNo_info:
         const _ceNo;
         const 0;
         const 30;
 },
 _ceND() //  [R1]
         { []
         }
     {offset
       ceND: // global
           if (R1 & 7 == 1) goto ueNS; else goto ceNP;
       ueNS: // global
           Sp = Sp + 24;
           call _ceNL() args: 0, res: 0, upd: 0;
       ceNP: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceND_info" {
     block_ceND_info:
         const _ceND;
         const 2;
         const 30;
 },
 _ceNL() //  []
         { []
         }
     {offset
       ceNL: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.68238099 UTC

[section ""data" . GHC.Base.$fEqMaybe_$c/=_closure" {
     GHC.Base.$fEqMaybe_$c/=_closure:
         const GHC.Base.$fEqMaybe_$c/=_info;
 },
 GHC.Base.$fEqMaybe_$c/=_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ceOD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceOE; else goto ceOF;
       ceOE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqMaybe_$c/=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceOF: // global
           I64[Sp - 24] = block_ceOw_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uePv; else goto ceOx;
       uePv: // global
           call _ceOw(R1) args: 0, res: 0, upd: 0;
       ceOx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fEqMaybe_$c/=_info" {
     GHC.Base.$fEqMaybe_$c/=_info:
         const GHC.Base.$fEqMaybe_$c/=_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ceOw() //  [R1]
         { []
         }
     {offset
       ceOw: // global
           _s8ak::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ceOA; else goto ceOB;
       ceOA: // global
           I64[Sp + 16] = block_ceOI_info;
           R1 = _s8ak::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto uePt; else goto ceOK;
       uePt: // global
           call _ceOI(R1) args: 0, res: 0, upd: 0;
       ceOK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ceOB: // global
           I64[Sp] = block_ceOX_info;
           _s8ao::P64 = P64[R1 + 6];
           R1 = _s8ak::P64;
           P64[Sp + 16] = _s8ao::P64;
           if (R1 & 7 != 0) goto uePu; else goto ceOZ;
       uePu: // global
           call _ceOX(R1) args: 0, res: 0, upd: 0;
       ceOZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ceOw_info" {
     block_ceOw_info:
         const _ceOw;
         const 2;
         const 30;
 },
 _ceOI() //  [R1]
         { []
         }
     {offset
       ceOI: // global
           if (R1 & 7 == 1) goto uePr; else goto uePs;
       uePr: // global
           Sp = Sp + 8;
           call _cePk() args: 0, res: 0, upd: 0;
       uePs: // global
           Sp = Sp + 8;
           call _cePg() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ceOI_info" {
     block_ceOI_info:
         const _ceOI;
         const 0;
         const 30;
 },
 _ceOX() //  [R1]
         { []
         }
     {offset
       ceOX: // global
           if (R1 & 7 == 1) goto uePo; else goto cePa;
       uePo: // global
           Sp = Sp + 24;
           call _cePg() args: 0, res: 0, upd: 0;
       cePa: // global
           _s8ao::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ceP8_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s8ao::P64;
           P64[Sp + 8] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ceOX_info" {
     block_ceOX_info:
         const _ceOX;
         const 2;
         const 30;
 },
 _ceP8() //  [R1]
         { []
         }
     {offset
       ceP8: // global
           if (R1 & 7 == 1) goto uePp; else goto uePq;
       uePp: // global
           Sp = Sp + 8;
           call _cePg() args: 0, res: 0, upd: 0;
       uePq: // global
           Sp = Sp + 8;
           call _cePk() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ceP8_info" {
     block_ceP8_info:
         const _ceP8;
         const 0;
         const 30;
 },
 _cePg() //  []
         { []
         }
     {offset
       cePg: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cePk() //  []
         { []
         }
     {offset
       cePk: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.694961418 UTC

[section ""data" . GHC.Base.$fEqMaybe_closure" {
     GHC.Base.$fEqMaybe_closure:
         const GHC.Base.$fEqMaybe_info;
 },
 sat_s8au_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       ceQj: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8au_info" {
     sat_s8au_info:
         const sat_s8au_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8at_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       ceQr: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8at_info" {
     sat_s8at_info:
         const sat_s8at_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 GHC.Base.$fEqMaybe_entry() //  [R2]
         { []
         }
     {offset
       ceQv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ceQz; else goto ceQy;
       ceQz: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.Base.$fEqMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceQy: // global
           I64[Hp - 48] = sat_s8au_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s8at_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fEqMaybe_info" {
     GHC.Base.$fEqMaybe_info:
         const GHC.Base.$fEqMaybe_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.702249703 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$cp1Ord_closure" {
     GHC.Base.$fOrdMaybe_$cp1Ord_closure:
         const GHC.Base.$fOrdMaybe_$cp1Ord_info;
 },
 sat_s8aw_entry() //  [R1]
         { []
         }
     {offset
       ceQV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ceQW; else goto ceQX;
       ceQW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ceQX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8aw_info" {
     sat_s8aw_info:
         const sat_s8aw_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fOrdMaybe_$cp1Ord_entry() //  [R2]
         { []
         }
     {offset
       ceQY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ceR2; else goto ceR1;
       ceR2: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ceR1: // global
           I64[Hp - 16] = sat_s8aw_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fEqMaybe_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdMaybe_$cp1Ord_info" {
     GHC.Base.$fOrdMaybe_$cp1Ord_info:
         const GHC.Base.$fOrdMaybe_$cp1Ord_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.708918878 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$ccompare_closure" {
     GHC.Base.$fOrdMaybe_$ccompare_closure:
         const GHC.Base.$fOrdMaybe_$ccompare_info;
 },
 GHC.Base.$fOrdMaybe_$ccompare_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ceRm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ceRn; else goto ceRo;
       ceRn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$ccompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceRo: // global
           I64[Sp - 24] = block_ceRf_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ueRX; else goto ceRg;
       ueRX: // global
           call _ceRf(R1) args: 0, res: 0, upd: 0;
       ceRg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdMaybe_$ccompare_info" {
     GHC.Base.$fOrdMaybe_$ccompare_info:
         const GHC.Base.$fOrdMaybe_$ccompare_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ceRf() //  [R1]
         { []
         }
     {offset
       ceRf: // global
           _s8az::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ceRj; else goto ceRk;
       ceRj: // global
           I64[Sp + 16] = block_ceRr_info;
           R1 = _s8az::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ueRV; else goto ceRt;
       ueRV: // global
           call _ceRr(R1) args: 0, res: 0, upd: 0;
       ceRt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ceRk: // global
           I64[Sp] = block_ceRG_info;
           _s8aD::P64 = P64[R1 + 6];
           R1 = _s8az::P64;
           P64[Sp + 16] = _s8aD::P64;
           if (R1 & 7 != 0) goto ueRW; else goto ceRI;
       ueRW: // global
           call _ceRG(R1) args: 0, res: 0, upd: 0;
       ceRI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ceRf_info" {
     block_ceRf_info:
         const _ceRf;
         const 2;
         const 30;
 },
 _ceRr() //  [R1]
         { []
         }
     {offset
       ceRr: // global
           if (R1 & 7 == 1) goto ceRz; else goto ceRD;
       ceRz: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ceRD: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceRr_info" {
     block_ceRr_info:
         const _ceRr;
         const 0;
         const 30;
 },
 _ceRG() //  [R1]
         { []
         }
     {offset
       ceRG: // global
           if (R1 & 7 == 1) goto ceRO; else goto ceRS;
       ceRO: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ceRS: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.Classes.compare_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceRG_info" {
     block_ceRG_info:
         const _ceRG;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.719415693 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$c<_closure" {
     GHC.Base.$fOrdMaybe_$c<_closure:
         const GHC.Base.$fOrdMaybe_$c<_info;
 },
 GHC.Base.$fOrdMaybe_$c<_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ceSB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ceSC; else goto ceSD;
       ceSC: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$c<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceSD: // global
           I64[Sp - 24] = block_ceSu_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ueTe; else goto ceSv;
       ueTe: // global
           call _ceSu(R1) args: 0, res: 0, upd: 0;
       ceSv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdMaybe_$c<_info" {
     GHC.Base.$fOrdMaybe_$c<_info:
         const GHC.Base.$fOrdMaybe_$c<_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ceSu() //  [R1]
         { []
         }
     {offset
       ceSu: // global
           _s8aI::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ceSy; else goto ceSz;
       ceSy: // global
           I64[Sp + 16] = block_ceSG_info;
           R1 = _s8aI::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ueTc; else goto ceSI;
       ueTc: // global
           call _ceSG(R1) args: 0, res: 0, upd: 0;
       ceSI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ceSz: // global
           I64[Sp] = block_ceSV_info;
           _s8aM::P64 = P64[R1 + 6];
           R1 = _s8aI::P64;
           P64[Sp + 16] = _s8aM::P64;
           if (R1 & 7 != 0) goto ueTd; else goto ceSX;
       ueTd: // global
           call _ceSV(R1) args: 0, res: 0, upd: 0;
       ceSX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ceSu_info" {
     block_ceSu_info:
         const _ceSu;
         const 2;
         const 30;
 },
 _ceSG() //  [R1]
         { []
         }
     {offset
       ceSG: // global
           if (R1 & 7 == 1) goto ueTb; else goto ceSS;
       ueTb: // global
           Sp = Sp + 8;
           call _ceT3() args: 0, res: 0, upd: 0;
       ceSS: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceSG_info" {
     block_ceSG_info:
         const _ceSG;
         const 0;
         const 30;
 },
 _ceSV() //  [R1]
         { []
         }
     {offset
       ceSV: // global
           if (R1 & 7 == 1) goto ueTa; else goto ceT7;
       ueTa: // global
           Sp = Sp + 24;
           call _ceT3() args: 0, res: 0, upd: 0;
       ceT7: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.Classes.<_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceSV_info" {
     block_ceSV_info:
         const _ceSV;
         const 2;
         const 30;
 },
 _ceT3() //  []
         { []
         }
     {offset
       ceT3: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.732189632 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$c<=_closure" {
     GHC.Base.$fOrdMaybe_$c<=_closure:
         const GHC.Base.$fOrdMaybe_$c<=_info;
 },
 GHC.Base.$fOrdMaybe_$c<=_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ceTV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceTW; else goto ceTX;
       ceTW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$c<=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceTX: // global
           I64[Sp - 24] = block_ceTO_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ueUN; else goto ceTP;
       ueUN: // global
           call _ceTO(R1) args: 0, res: 0, upd: 0;
       ceTP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdMaybe_$c<=_info" {
     GHC.Base.$fOrdMaybe_$c<=_info:
         const GHC.Base.$fOrdMaybe_$c<=_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ceTO() //  [R1]
         { []
         }
     {offset
       ceTO: // global
           _s8aQ::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ceTS; else goto ceTT;
       ceTS: // global
           I64[Sp + 16] = block_ceU0_info;
           R1 = _s8aQ::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ueUL; else goto ceU2;
       ueUL: // global
           call _ceU0(R1) args: 0, res: 0, upd: 0;
       ceU2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ceTT: // global
           I64[Sp] = block_ceUf_info;
           _s8aV::P64 = P64[R1 + 6];
           R1 = _s8aQ::P64;
           P64[Sp + 16] = _s8aV::P64;
           if (R1 & 7 != 0) goto ueUM; else goto ceUh;
       ueUM: // global
           call _ceUf(R1) args: 0, res: 0, upd: 0;
       ceUh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ceTO_info" {
     block_ceTO_info:
         const _ceTO;
         const 2;
         const 30;
 },
 _ceU0() //  [R1]
         { []
         }
     {offset
       ceU0: // global
           if (R1 & 7 == 1) goto ueUJ; else goto ueUK;
       ueUJ: // global
           Sp = Sp + 8;
           call _ceUy() args: 0, res: 0, upd: 0;
       ueUK: // global
           Sp = Sp + 8;
           call _ceUC() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ceU0_info" {
     block_ceU0_info:
         const _ceU0;
         const 0;
         const 30;
 },
 _ceUf() //  [R1]
         { []
         }
     {offset
       ceUf: // global
           if (R1 & 7 == 1) goto ueUG; else goto ceUs;
       ueUG: // global
           Sp = Sp + 24;
           call _ceUy() args: 0, res: 0, upd: 0;
       ceUs: // global
           _s8aV::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ceUq_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s8aV::P64;
           P64[Sp + 8] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ceUf_info" {
     block_ceUf_info:
         const _ceUf;
         const 2;
         const 30;
 },
 _ceUq() //  [R1]
         { []
         }
     {offset
       ceUq: // global
           if (R1 & 7 == 1) goto ueUH; else goto ueUI;
       ueUH: // global
           Sp = Sp + 8;
           call _ceUy() args: 0, res: 0, upd: 0;
       ueUI: // global
           Sp = Sp + 8;
           call _ceUC() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ceUq_info" {
     block_ceUq_info:
         const _ceUq;
         const 0;
         const 30;
 },
 _ceUy() //  []
         { []
         }
     {offset
       ceUy: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ceUC() //  []
         { []
         }
     {offset
       ceUC: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.745881692 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$cmax_closure" {
     GHC.Base.$fOrdMaybe_$cmax_closure:
         const GHC.Base.$fOrdMaybe_$cmax_info;
 },
 GHC.Base.$fOrdMaybe_$cmax_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ceVD: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ceVE; else goto ceVF;
       ceVE: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$cmax_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceVF: // global
           I64[Sp - 24] = block_ceVw_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ueWe; else goto ceVx;
       ueWe: // global
           call _ceVw(R1) args: 0, res: 0, upd: 0;
       ceVx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdMaybe_$cmax_info" {
     GHC.Base.$fOrdMaybe_$cmax_info:
         const GHC.Base.$fOrdMaybe_$cmax_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ceVw() //  [R1]
         { []
         }
     {offset
       ceVw: // global
           _s8b0::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ceVA; else goto ceVB;
       ceVA: // global
           R1 = _s8b0::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ceVB: // global
           I64[Sp - 8] = block_ceVL_info;
           _s8b2::P64 = R1;
           _s8b3::P64 = P64[R1 + 6];
           R1 = _s8b0::P64;
           P64[Sp] = _s8b3::P64;
           P64[Sp + 16] = _s8b2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ueWd; else goto ceVN;
       ueWd: // global
           call _ceVL(R1) args: 0, res: 0, upd: 0;
       ceVN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ceVw_info" {
     block_ceVw_info:
         const _ceVw;
         const 2;
         const 30;
 },
 _ceVL() //  [R1]
         { []
         }
     {offset
       ceVL: // global
           if (R1 & 7 == 1) goto ueWb; else goto ceVY;
       ueWb: // global
           Sp = Sp + 24;
           call _ceW4() args: 0, res: 0, upd: 0;
       ceVY: // global
           _s8b3::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ceVW_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _s8b3::P64;
           P64[Sp] = P64[R1 + 6];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ceVL_info" {
     block_ceVL_info:
         const _ceVL;
         const 3;
         const 30;
 },
 _ceVW() //  [R1]
         { []
         }
     {offset
       ceVW: // global
           if (R1 & 7 == 1) goto ueWc; else goto ceW8;
       ueWc: // global
           Sp = Sp + 16;
           call _ceW4() args: 0, res: 0, upd: 0;
       ceW8: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceVW_info" {
     block_ceVW_info:
         const _ceVW;
         const 2;
         const 30;
 },
 _ceW4() //  []
         { []
         }
     {offset
       ceW4: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.756724137 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$cmin_closure" {
     GHC.Base.$fOrdMaybe_$cmin_closure:
         const GHC.Base.$fOrdMaybe_$cmin_info;
 },
 GHC.Base.$fOrdMaybe_$cmin_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ceWX: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ceWY; else goto ceWZ;
       ceWY: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$cmin_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceWZ: // global
           I64[Sp - 24] = block_ceWQ_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ueXD; else goto ceWR;
       ueXD: // global
           call _ceWQ(R1) args: 0, res: 0, upd: 0;
       ceWR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdMaybe_$cmin_info" {
     GHC.Base.$fOrdMaybe_$cmin_info:
         const GHC.Base.$fOrdMaybe_$cmin_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ceWQ() //  [R1]
         { []
         }
     {offset
       ceWQ: // global
           _s8b8::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ceWU; else goto ceWV;
       ceWU: // global
           I64[Sp + 16] = block_ceX2_info;
           R1 = _s8b8::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ueXB; else goto ceX4;
       ueXB: // global
           call _ceX2() args: 0, res: 0, upd: 0;
       ceX4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ceWV: // global
           I64[Sp - 8] = block_ceXb_info;
           _s8ba::P64 = R1;
           _s8bc::P64 = P64[R1 + 6];
           R1 = _s8b8::P64;
           P64[Sp] = _s8bc::P64;
           P64[Sp + 16] = _s8ba::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ueXC; else goto ceXd;
       ueXC: // global
           call _ceXb(R1) args: 0, res: 0, upd: 0;
       ceXd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ceWQ_info" {
     block_ceWQ_info:
         const _ceWQ;
         const 2;
         const 30;
 },
 _ceX2() //  []
         { []
         }
     {offset
       ceX2: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceX2_info" {
     block_ceX2_info:
         const _ceX2;
         const 0;
         const 30;
 },
 _ceXb() //  [R1]
         { []
         }
     {offset
       ceXb: // global
           if (R1 & 7 == 1) goto ceXj; else goto ceXo;
       ceXj: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ceXo: // global
           _s8bc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ceXm_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _s8bc::P64;
           P64[Sp] = P64[R1 + 6];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ceXb_info" {
     block_ceXb_info:
         const _ceXb;
         const 3;
         const 30;
 },
 _ceXm() //  [R1]
         { []
         }
     {offset
       ceXm: // global
           if (R1 & 7 == 1) goto ceXu; else goto ceXy;
       ceXu: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ceXy: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ceXm_info" {
     block_ceXm_info:
         const _ceXm;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.76943177 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$c>=_closure" {
     GHC.Base.$fOrdMaybe_$c>=_closure:
         const GHC.Base.$fOrdMaybe_$c>=_info;
 },
 GHC.Base.$fOrdMaybe_$c>=_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ceYm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ceYn; else goto ceYo;
       ceYn: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$c>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ceYo: // global
           I64[Sp - 24] = block_ceYf_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ueZe; else goto ceYg;
       ueZe: // global
           call _ceYf(R1) args: 0, res: 0, upd: 0;
       ceYg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdMaybe_$c>=_info" {
     GHC.Base.$fOrdMaybe_$c>=_info:
         const GHC.Base.$fOrdMaybe_$c>=_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ceYf() //  [R1]
         { []
         }
     {offset
       ceYf: // global
           _s8bi::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ceYj; else goto ceYk;
       ceYj: // global
           I64[Sp + 16] = block_ceYr_info;
           R1 = _s8bi::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ueZc; else goto ceYt;
       ueZc: // global
           call _ceYr(R1) args: 0, res: 0, upd: 0;
       ceYt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ceYk: // global
           I64[Sp] = block_ceYG_info;
           _s8bm::P64 = P64[R1 + 6];
           R1 = _s8bi::P64;
           P64[Sp + 16] = _s8bm::P64;
           if (R1 & 7 != 0) goto ueZd; else goto ceYI;
       ueZd: // global
           call _ceYG(R1) args: 0, res: 0, upd: 0;
       ceYI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ceYf_info" {
     block_ceYf_info:
         const _ceYf;
         const 2;
         const 30;
 },
 _ceYr() //  [R1]
         { []
         }
     {offset
       ceYr: // global
           if (R1 & 7 == 1) goto ueZa; else goto ueZb;
       ueZa: // global
           Sp = Sp + 8;
           call _ceYZ() args: 0, res: 0, upd: 0;
       ueZb: // global
           Sp = Sp + 8;
           call _ceZ3() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ceYr_info" {
     block_ceYr_info:
         const _ceYr;
         const 0;
         const 30;
 },
 _ceYG() //  [R1]
         { []
         }
     {offset
       ceYG: // global
           if (R1 & 7 == 1) goto ueZ7; else goto ceYT;
       ueZ7: // global
           Sp = Sp + 24;
           call _ceYZ() args: 0, res: 0, upd: 0;
       ceYT: // global
           _s8bm::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_ceYR_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _s8bm::P64;
           P64[Sp + 8] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ceYG_info" {
     block_ceYG_info:
         const _ceYG;
         const 2;
         const 30;
 },
 _ceYR() //  [R1]
         { []
         }
     {offset
       ceYR: // global
           if (R1 & 7 == 1) goto ueZ8; else goto ueZ9;
       ueZ8: // global
           Sp = Sp + 8;
           call _ceYZ() args: 0, res: 0, upd: 0;
       ueZ9: // global
           Sp = Sp + 8;
           call _ceZ3() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ceYR_info" {
     block_ceYR_info:
         const _ceYR;
         const 0;
         const 30;
 },
 _ceYZ() //  []
         { []
         }
     {offset
       ceYZ: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ceZ3() //  []
         { []
         }
     {offset
       ceZ3: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.78419091 UTC

[section ""data" . GHC.Base.$fOrdMaybe_closure" {
     GHC.Base.$fOrdMaybe_closure:
         const GHC.Base.$fOrdMaybe_info;
 },
 sat_s8bA_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cf02: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8bA_info" {
     sat_s8bA_info:
         const sat_s8bA_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8bz_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cf0a: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8bz_info" {
     sat_s8bz_info:
         const sat_s8bz_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8by_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cf0i: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8by_info" {
     sat_s8by_info:
         const sat_s8by_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8bx_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cf0q: // global
           R4 = R2;
           R3 = R3;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8bx_info" {
     sat_s8bx_info:
         const sat_s8bx_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8bu_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cf0y: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8bu_info" {
     sat_s8bu_info:
         const sat_s8bu_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8bt_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cf0G: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8bt_info" {
     sat_s8bt_info:
         const sat_s8bt_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8bs_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cf0O: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8bs_info" {
     sat_s8bs_info:
         const sat_s8bs_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8br_entry() //  [R1]
         { []
         }
     {offset
       cf0V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cf0W; else goto cf0X;
       cf0W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cf0X: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fOrdMaybe_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8br_info" {
     sat_s8br_info:
         const sat_s8br_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fOrdMaybe_entry() //  [R2]
         { []
         }
     {offset
       cf0Z: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cf13; else goto cf12;
       cf13: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cf12: // global
           I64[Hp - 200] = sat_s8bA_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s8bz_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s8by_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s8bx_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s8bu_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s8bt_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s8bs_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s8br_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdMaybe_info" {
     GHC.Base.$fOrdMaybe_info:
         const GHC.Base.$fOrdMaybe_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.802252155 UTC

[section ""data" . GHC.Base.$fEqNonEmpty_$c/=_closure" {
     GHC.Base.$fEqNonEmpty_$c/=_closure:
         const GHC.Base.$fEqNonEmpty_$c/=_info;
 },
 GHC.Base.$fEqNonEmpty_$c/=_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cf1N: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cf1R; else goto cf1S;
       cf1R: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqNonEmpty_$c/=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cf1S: // global
           I64[Sp - 24] = block_cf1K_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uf2q; else goto cf1L;
       uf2q: // global
           call _cf1K(R1) args: 0, res: 0, upd: 0;
       cf1L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fEqNonEmpty_$c/=_info" {
     GHC.Base.$fEqNonEmpty_$c/=_info:
         const GHC.Base.$fEqNonEmpty_$c/=_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cf1K() //  [R1]
         { []
         }
     {offset
       cf1K: // global
           I64[Sp - 8] = block_cf1Q_info;
           _s8bF::P64 = P64[R1 + 7];
           _s8bG::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8bG::P64;
           P64[Sp + 16] = _s8bF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uf2p; else goto cf1U;
       uf2p: // global
           call _cf1Q(R1) args: 0, res: 0, upd: 0;
       cf1U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cf1K_info" {
     block_cf1K_info:
         const _cf1K;
         const 2;
         const 30;
 },
 _cf1Q() //  [R1]
         { []
         }
     {offset
       cf1Q: // global
           I64[Sp] = block_cf1Y_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cf1Q_info" {
     block_cf1Q_info:
         const _cf1Q;
         const 3;
         const 30;
 },
 _cf1Y() //  [R1]
         { []
         }
     {offset
       cf1Y: // global
           if (R1 & 7 == 1) goto uf2n; else goto cf2a;
       uf2n: // global
           Sp = Sp + 32;
           call _cf2g() args: 0, res: 0, upd: 0;
       cf2a: // global
           _s8bJ::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cf28_info;
           R4 = _s8bJ::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Classes.$fEq[]_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cf1Y_info" {
     block_cf1Y_info:
         const _cf1Y;
         const 3;
         const 30;
 },
 _cf28() //  [R1]
         { []
         }
     {offset
       cf28: // global
           if (R1 & 7 == 1) goto uf2o; else goto cf2k;
       uf2o: // global
           Sp = Sp + 8;
           call _cf2g() args: 0, res: 0, upd: 0;
       cf2k: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cf28_info" {
     block_cf28_info:
         const _cf28;
         const 0;
         const 30;
 },
 _cf2g() //  []
         { []
         }
     {offset
       cf2g: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.813707012 UTC

[section ""data" . GHC.Base.$w$c==_closure" {
     GHC.Base.$w$c==_closure:
         const GHC.Base.$w$c==_info;
 },
 GHC.Base.$w$c==_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cf37: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cf38; else goto cf39;
       cf38: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c==_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cf39: // global
           I64[Sp - 32] = block_cf31_info;
           _s8bM::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _s8bM::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$c==_info" {
     GHC.Base.$w$c==_info:
         const GHC.Base.$w$c==_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cf31() //  [R1]
         { []
         }
     {offset
       cf31: // global
           if (R1 & 7 == 1) goto cf34; else goto cf35;
       cf34: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cf35: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Classes.$fEq[]_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cf31_info" {
     block_cf31_info:
         const _cf31;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.820054714 UTC

[section ""data" . GHC.Base.$fEqNonEmpty_$c==_closure" {
     GHC.Base.$fEqNonEmpty_$c==_closure:
         const GHC.Base.$fEqNonEmpty_$c==_info;
 },
 GHC.Base.$fEqNonEmpty_$c==_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cf3y: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cf3C; else goto cf3D;
       cf3C: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqNonEmpty_$c==_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cf3D: // global
           I64[Sp - 24] = block_cf3v_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uf3L; else goto cf3w;
       uf3L: // global
           call _cf3v(R1) args: 0, res: 0, upd: 0;
       cf3w: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fEqNonEmpty_$c==_info" {
     GHC.Base.$fEqNonEmpty_$c==_info:
         const GHC.Base.$fEqNonEmpty_$c==_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cf3v() //  [R1]
         { []
         }
     {offset
       cf3v: // global
           I64[Sp - 8] = block_cf3B_info;
           _s8bW::P64 = P64[R1 + 7];
           _s8bX::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8bX::P64;
           P64[Sp + 16] = _s8bW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uf3K; else goto cf3F;
       uf3K: // global
           call _cf3B(R1) args: 0, res: 0, upd: 0;
       cf3F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cf3v_info" {
     block_cf3v_info:
         const _cf3v;
         const 2;
         const 30;
 },
 _cf3B() //  [R1]
         { []
         }
     {offset
       cf3B: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c==_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cf3B_info" {
     block_cf3B_info:
         const _cf3B;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.827855966 UTC

[section ""data" . GHC.Base.$fEqNonEmpty_closure" {
     GHC.Base.$fEqNonEmpty_closure:
         const GHC.Base.$fEqNonEmpty_info;
 },
 sat_s8c3_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cf48: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqNonEmpty_$c/=_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8c3_info" {
     sat_s8c3_info:
         const sat_s8c3_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8c2_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cf4g: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqNonEmpty_$c==_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8c2_info" {
     sat_s8c2_info:
         const sat_s8c2_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 GHC.Base.$fEqNonEmpty_entry() //  [R2]
         { []
         }
     {offset
       cf4k: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cf4o; else goto cf4n;
       cf4o: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.Base.$fEqNonEmpty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cf4n: // global
           I64[Hp - 48] = sat_s8c3_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s8c2_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fEqNonEmpty_info" {
     GHC.Base.$fEqNonEmpty_info:
         const GHC.Base.$fEqNonEmpty_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.83521694 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$cp1Ord_closure" {
     GHC.Base.$fOrdNonEmpty_$cp1Ord_closure:
         const GHC.Base.$fOrdNonEmpty_$cp1Ord_info;
 },
 sat_s8c5_entry() //  [R1]
         { []
         }
     {offset
       cf4K: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cf4L; else goto cf4M;
       cf4L: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cf4M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8c5_info" {
     sat_s8c5_info:
         const sat_s8c5_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fOrdNonEmpty_$cp1Ord_entry() //  [R2]
         { []
         }
     {offset
       cf4N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cf4R; else goto cf4Q;
       cf4R: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cf4Q: // global
           I64[Hp - 16] = sat_s8c5_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fEqNonEmpty_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdNonEmpty_$cp1Ord_info" {
     GHC.Base.$fOrdNonEmpty_$cp1Ord_info:
         const GHC.Base.$fOrdNonEmpty_$cp1Ord_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.84144075 UTC

[section ""data" . GHC.Base.$w$ccompare_closure" {
     GHC.Base.$w$ccompare_closure:
         const GHC.Base.$w$ccompare_info;
 },
 GHC.Base.$w$ccompare_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cf5b: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cf5c; else goto cf5d;
       cf5c: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cf5d: // global
           I64[Sp - 32] = block_cf54_info;
           _s8c6::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _s8c6::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$ccompare_info" {
     GHC.Base.$w$ccompare_info:
         const GHC.Base.$w$ccompare_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cf54() //  [R1]
         { []
         }
     {offset
       cf54: // global
           _cf5a::P64 = R1 & 7;
           if (_cf5a::P64 < 3) goto uf5n; else goto cf59;
       uf5n: // global
           if (_cf5a::P64 < 2) goto cf57; else goto cf58;
       cf57: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cf58: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
       cf59: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cf54_info" {
     block_cf54_info:
         const _cf54;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.848133849 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$ccompare_closure" {
     GHC.Base.$fOrdNonEmpty_$ccompare_closure:
         const GHC.Base.$fOrdNonEmpty_$ccompare_info;
 },
 GHC.Base.$fOrdNonEmpty_$ccompare_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cf5G: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cf5K; else goto cf5L;
       cf5K: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$ccompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cf5L: // global
           I64[Sp - 24] = block_cf5D_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uf5T; else goto cf5E;
       uf5T: // global
           call _cf5D(R1) args: 0, res: 0, upd: 0;
       cf5E: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdNonEmpty_$ccompare_info" {
     GHC.Base.$fOrdNonEmpty_$ccompare_info:
         const GHC.Base.$fOrdNonEmpty_$ccompare_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cf5D() //  [R1]
         { []
         }
     {offset
       cf5D: // global
           I64[Sp - 8] = block_cf5J_info;
           _s8cg::P64 = P64[R1 + 7];
           _s8ch::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8ch::P64;
           P64[Sp + 16] = _s8cg::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uf5S; else goto cf5N;
       uf5S: // global
           call _cf5J(R1) args: 0, res: 0, upd: 0;
       cf5N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cf5D_info" {
     block_cf5D_info:
         const _cf5D;
         const 2;
         const 30;
 },
 _cf5J() //  [R1]
         { []
         }
     {offset
       cf5J: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cf5J_info" {
     block_cf5J_info:
         const _cf5J;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.855778581 UTC

[section ""data" . GHC.Base.$w$c<_closure" {
     GHC.Base.$w$c<_closure:
         const GHC.Base.$w$c<_info;
 },
 GHC.Base.$w$c<_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cf6i: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cf6j; else goto cf6k;
       cf6j: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cf6k: // global
           I64[Sp - 32] = block_cf6b_info;
           _s8cl::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _s8cl::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$c<_info" {
     GHC.Base.$w$c<_info:
         const GHC.Base.$w$c<_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cf6b() //  [R1]
         { []
         }
     {offset
       cf6b: // global
           _cf6h::P64 = R1 & 7;
           if (_cf6h::P64 < 3) goto uf6u; else goto cf6g;
       uf6u: // global
           if (_cf6h::P64 < 2) goto cf6e; else goto cf6f;
       cf6e: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cf6f: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Classes.$fOrd[]_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
       cf6g: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cf6b_info" {
     block_cf6b_info:
         const _cf6b;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.863307455 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$c<_closure" {
     GHC.Base.$fOrdNonEmpty_$c<_closure:
         const GHC.Base.$fOrdNonEmpty_$c<_info;
 },
 GHC.Base.$fOrdNonEmpty_$c<_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cf6N: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cf6R; else goto cf6S;
       cf6R: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$c<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cf6S: // global
           I64[Sp - 24] = block_cf6K_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uf70; else goto cf6L;
       uf70: // global
           call _cf6K(R1) args: 0, res: 0, upd: 0;
       cf6L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdNonEmpty_$c<_info" {
     GHC.Base.$fOrdNonEmpty_$c<_info:
         const GHC.Base.$fOrdNonEmpty_$c<_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cf6K() //  [R1]
         { []
         }
     {offset
       cf6K: // global
           I64[Sp - 8] = block_cf6Q_info;
           _s8cv::P64 = P64[R1 + 7];
           _s8cw::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8cw::P64;
           P64[Sp + 16] = _s8cv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uf6Z; else goto cf6U;
       uf6Z: // global
           call _cf6Q(R1) args: 0, res: 0, upd: 0;
       cf6U: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cf6K_info" {
     block_cf6K_info:
         const _cf6K;
         const 2;
         const 30;
 },
 _cf6Q() //  [R1]
         { []
         }
     {offset
       cf6Q: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c<_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cf6Q_info" {
     block_cf6Q_info:
         const _cf6Q;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.871338722 UTC

[section ""data" . GHC.Base.$w$c<=_closure" {
     GHC.Base.$w$c<=_closure:
         const GHC.Base.$w$c<=_info;
 },
 GHC.Base.$w$c<=_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cf7p: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cf7q; else goto cf7r;
       cf7q: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cf7r: // global
           I64[Sp - 32] = block_cf7i_info;
           _s8cA::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R5;
           P64[Sp - 40] = R3;
           P64[Sp - 24] = _s8cA::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$c<=_info" {
     GHC.Base.$w$c<=_info:
         const GHC.Base.$w$c<=_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cf7i() //  [R1]
         { []
         }
     {offset
       cf7i: // global
           _cf7o::P64 = R1 & 7;
           if (_cf7o::P64 < 3) goto uf7N; else goto uf7O;
       uf7N: // global
           if (_cf7o::P64 < 2) goto uf7P; else goto cf7m;
       uf7P: // global
           Sp = Sp + 32;
           call _cf7I() args: 0, res: 0, upd: 0;
       cf7m: // global
           _s8cE::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cf7x_info;
           R4 = P64[Sp + 16];
           R3 = _s8cE::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       uf7O: // global
           Sp = Sp + 32;
           call _cf7n() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cf7i_info" {
     block_cf7i_info:
         const _cf7i;
         const 3;
         const 30;
 },
 _cf7x() //  [R1]
         { []
         }
     {offset
       cf7x: // global
           if (R1 & 7 == 1) goto uf7Q; else goto uf7R;
       uf7Q: // global
           Sp = Sp + 8;
           call _cf7I() args: 0, res: 0, upd: 0;
       uf7R: // global
           Sp = Sp + 8;
           call _cf7n() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cf7x_info" {
     block_cf7x_info:
         const _cf7x;
         const 0;
         const 30;
 },
 _cf7I() //  []
         { []
         }
     {offset
       cf7I: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cf7n() //  []
         { []
         }
     {offset
       cf7n: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.881114935 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$c<=_closure" {
     GHC.Base.$fOrdNonEmpty_$c<=_closure:
         const GHC.Base.$fOrdNonEmpty_$c<=_info;
 },
 GHC.Base.$fOrdNonEmpty_$c<=_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cf8n: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cf8r; else goto cf8s;
       cf8r: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$c<=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cf8s: // global
           I64[Sp - 24] = block_cf8k_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uf8A; else goto cf8l;
       uf8A: // global
           call _cf8k(R1) args: 0, res: 0, upd: 0;
       cf8l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdNonEmpty_$c<=_info" {
     GHC.Base.$fOrdNonEmpty_$c<=_info:
         const GHC.Base.$fOrdNonEmpty_$c<=_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cf8k() //  [R1]
         { []
         }
     {offset
       cf8k: // global
           I64[Sp - 8] = block_cf8q_info;
           _s8cL::P64 = P64[R1 + 7];
           _s8cM::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8cM::P64;
           P64[Sp + 16] = _s8cL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uf8z; else goto cf8u;
       uf8z: // global
           call _cf8q(R1) args: 0, res: 0, upd: 0;
       cf8u: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cf8k_info" {
     block_cf8k_info:
         const _cf8k;
         const 2;
         const 30;
 },
 _cf8q() //  [R1]
         { []
         }
     {offset
       cf8q: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cf8q_info" {
     block_cf8q_info:
         const _cf8q;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.890359178 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$cmax_closure" {
     GHC.Base.$fOrdNonEmpty_$cmax_closure:
         const GHC.Base.$fOrdNonEmpty_$cmax_info;
 },
 GHC.Base.$fOrdNonEmpty_$cmax_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cf8V: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cf8Z; else goto cf90;
       cf8Z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$cmax_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cf90: // global
           I64[Sp - 24] = block_cf8S_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uf9F; else goto cf8T;
       uf9F: // global
           call _cf8S(R1) args: 0, res: 0, upd: 0;
       cf8T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdNonEmpty_$cmax_info" {
     GHC.Base.$fOrdNonEmpty_$cmax_info:
         const GHC.Base.$fOrdNonEmpty_$cmax_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cf8S() //  [R1]
         { []
         }
     {offset
       cf8S: // global
           I64[Sp - 16] = block_cf8Y_info;
           _s8cT::P64 = R1;
           _s8cU::P64 = P64[R1 + 7];
           _s8cV::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s8cV::P64;
           P64[Sp] = _s8cU::P64;
           P64[Sp + 16] = _s8cT::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uf9E; else goto cf92;
       uf9E: // global
           call _cf8Y(R1) args: 0, res: 0, upd: 0;
       cf92: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cf8S_info" {
     block_cf8S_info:
         const _cf8S;
         const 2;
         const 30;
 },
 _cf8Y() //  [R1]
         { []
         }
     {offset
       cf8Y: // global
           I64[Sp - 8] = block_cf96_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 16] = R1;
           Sp = Sp - 32;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cf8Y_info" {
     block_cf8Y_info:
         const _cf8Y;
         const 4;
         const 30;
 },
 _cf96() //  [R1]
         { []
         }
     {offset
       cf96: // global
           _cf9x::P64 = R1 & 7;
           if (_cf9x::P64 < 3) goto uf9z; else goto uf9A;
       uf9z: // global
           if (_cf9x::P64 < 2) goto uf9B; else goto cf9i;
       uf9B: // global
           Sp = Sp + 40;
           call _cf9s() args: 0, res: 0, upd: 0;
       cf9i: // global
           _s8cV::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cf9g_info;
           R4 = _s8cV::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       uf9A: // global
           Sp = Sp + 24;
           call _cf9w() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cf96_info" {
     block_cf96_info:
         const _cf96;
         const 5;
         const 30;
 },
 _cf9g() //  [R1]
         { []
         }
     {offset
       cf9g: // global
           if (R1 & 7 == 1) goto uf9C; else goto uf9D;
       uf9C: // global
           Sp = Sp + 24;
           call _cf9s() args: 0, res: 0, upd: 0;
       uf9D: // global
           Sp = Sp + 8;
           call _cf9w() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cf9g_info" {
     block_cf9g_info:
         const _cf9g;
         const 131;
         const 30;
 },
 _cf9s() //  []
         { []
         }
     {offset
       cf9s: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cf9w() //  []
         { []
         }
     {offset
       cf9w: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.903982769 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$cmin_closure" {
     GHC.Base.$fOrdNonEmpty_$cmin_closure:
         const GHC.Base.$fOrdNonEmpty_$cmin_info;
 },
 GHC.Base.$fOrdNonEmpty_$cmin_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cfao: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cfas; else goto cfat;
       cfas: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$cmin_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfat: // global
           I64[Sp - 24] = block_cfal_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufb8; else goto cfam;
       ufb8: // global
           call _cfal(R1) args: 0, res: 0, upd: 0;
       cfam: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdNonEmpty_$cmin_info" {
     GHC.Base.$fOrdNonEmpty_$cmin_info:
         const GHC.Base.$fOrdNonEmpty_$cmin_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cfal() //  [R1]
         { []
         }
     {offset
       cfal: // global
           I64[Sp - 16] = block_cfar_info;
           _s8d4::P64 = R1;
           _s8d5::P64 = P64[R1 + 7];
           _s8d6::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _s8d6::P64;
           P64[Sp] = _s8d5::P64;
           P64[Sp + 16] = _s8d4::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufb7; else goto cfav;
       ufb7: // global
           call _cfar(R1) args: 0, res: 0, upd: 0;
       cfav: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfal_info" {
     block_cfal_info:
         const _cfal;
         const 2;
         const 30;
 },
 _cfar() //  [R1]
         { []
         }
     {offset
       cfar: // global
           I64[Sp - 8] = block_cfaz_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 16] = R1;
           Sp = Sp - 32;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfar_info" {
     block_cfar_info:
         const _cfar;
         const 4;
         const 30;
 },
 _cfaz() //  [R1]
         { []
         }
     {offset
       cfaz: // global
           _cfb0::P64 = R1 & 7;
           if (_cfb0::P64 < 3) goto ufb2; else goto ufb3;
       ufb2: // global
           if (_cfb0::P64 < 2) goto ufb4; else goto cfaL;
       ufb4: // global
           Sp = Sp + 24;
           call _cfaV() args: 0, res: 0, upd: 0;
       cfaL: // global
           _s8d6::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cfaJ_info;
           R4 = _s8d6::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       ufb3: // global
           Sp = Sp + 40;
           call _cfaZ() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cfaz_info" {
     block_cfaz_info:
         const _cfaz;
         const 5;
         const 30;
 },
 _cfaJ() //  [R1]
         { []
         }
     {offset
       cfaJ: // global
           if (R1 & 7 == 1) goto ufb5; else goto ufb6;
       ufb5: // global
           Sp = Sp + 8;
           call _cfaV() args: 0, res: 0, upd: 0;
       ufb6: // global
           Sp = Sp + 24;
           call _cfaZ() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cfaJ_info" {
     block_cfaJ_info:
         const _cfaJ;
         const 131;
         const 30;
 },
 _cfaV() //  []
         { []
         }
     {offset
       cfaV: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfaZ() //  []
         { []
         }
     {offset
       cfaZ: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.917107311 UTC

[section ""data" . GHC.Base.$w$c>=_closure" {
     GHC.Base.$w$c>=_closure:
         const GHC.Base.$w$c>=_info;
 },
 GHC.Base.$w$c>=_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cfbV: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cfbW; else goto cfbX;
       cfbW: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c>=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfbX: // global
           I64[Sp - 32] = block_cfbO_info;
           _s8dc::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _s8dc::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$c>=_info" {
     GHC.Base.$w$c>=_info:
         const GHC.Base.$w$c>=_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cfbO() //  [R1]
         { []
         }
     {offset
       cfbO: // global
           _cfbU::P64 = R1 & 7;
           if (_cfbU::P64 < 3) goto ufcj; else goto ufck;
       ufcj: // global
           if (_cfbU::P64 < 2) goto ufcl; else goto cfbS;
       ufcl: // global
           Sp = Sp + 32;
           call _cfce() args: 0, res: 0, upd: 0;
       cfbS: // global
           _s8dg::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cfc3_info;
           R4 = _s8dg::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       ufck: // global
           Sp = Sp + 32;
           call _cfbT() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cfbO_info" {
     block_cfbO_info:
         const _cfbO;
         const 3;
         const 30;
 },
 _cfc3() //  [R1]
         { []
         }
     {offset
       cfc3: // global
           if (R1 & 7 == 1) goto ufcm; else goto ufcn;
       ufcm: // global
           Sp = Sp + 8;
           call _cfce() args: 0, res: 0, upd: 0;
       ufcn: // global
           Sp = Sp + 8;
           call _cfbT() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cfc3_info" {
     block_cfc3_info:
         const _cfc3;
         const 0;
         const 30;
 },
 _cfce() //  []
         { []
         }
     {offset
       cfce: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cfbT() //  []
         { []
         }
     {offset
       cfbT: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.926763215 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$c>=_closure" {
     GHC.Base.$fOrdNonEmpty_$c>=_closure:
         const GHC.Base.$fOrdNonEmpty_$c>=_info;
 },
 GHC.Base.$fOrdNonEmpty_$c>=_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cfcT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfcX; else goto cfcY;
       cfcX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$c>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfcY: // global
           I64[Sp - 24] = block_cfcQ_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufd6; else goto cfcR;
       ufd6: // global
           call _cfcQ(R1) args: 0, res: 0, upd: 0;
       cfcR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdNonEmpty_$c>=_info" {
     GHC.Base.$fOrdNonEmpty_$c>=_info:
         const GHC.Base.$fOrdNonEmpty_$c>=_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cfcQ() //  [R1]
         { []
         }
     {offset
       cfcQ: // global
           I64[Sp - 8] = block_cfcW_info;
           _s8dn::P64 = P64[R1 + 7];
           _s8do::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8do::P64;
           P64[Sp + 16] = _s8dn::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufd5; else goto cfd0;
       ufd5: // global
           call _cfcW(R1) args: 0, res: 0, upd: 0;
       cfd0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfcQ_info" {
     block_cfcQ_info:
         const _cfcQ;
         const 2;
         const 30;
 },
 _cfcW() //  [R1]
         { []
         }
     {offset
       cfcW: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c>=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfcW_info" {
     block_cfcW_info:
         const _cfcW;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.936656451 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_closure" {
     GHC.Base.$fOrdNonEmpty_closure:
         const GHC.Base.$fOrdNonEmpty_info;
 },
 sat_s8dC_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cfdt: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$cmin_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8dC_info" {
     sat_s8dC_info:
         const sat_s8dC_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8dB_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cfdB: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$cmax_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8dB_info" {
     sat_s8dB_info:
         const sat_s8dB_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8dA_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cfdJ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c>=_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8dA_info" {
     sat_s8dA_info:
         const sat_s8dA_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8dz_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cfdR: // global
           R4 = R2;
           R3 = R3;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c<_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8dz_info" {
     sat_s8dz_info:
         const sat_s8dz_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8dw_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cfdZ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c<=_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8dw_info" {
     sat_s8dw_info:
         const sat_s8dw_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8dv_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cfe7: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c<_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8dv_info" {
     sat_s8dv_info:
         const sat_s8dv_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8du_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cfef: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$ccompare_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8du_info" {
     sat_s8du_info:
         const sat_s8du_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8dt_entry() //  [R1]
         { []
         }
     {offset
       cfem: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfen; else goto cfeo;
       cfen: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfeo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fOrdNonEmpty_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8dt_info" {
     sat_s8dt_info:
         const sat_s8dt_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fOrdNonEmpty_entry() //  [R2]
         { []
         }
     {offset
       cfeq: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cfeu; else goto cfet;
       cfeu: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfet: // global
           I64[Hp - 200] = sat_s8dC_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_s8dB_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s8dA_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_s8dz_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_s8dw_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_s8dv_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s8du_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s8dt_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdNonEmpty_info" {
     GHC.Base.$fOrdNonEmpty_info:
         const GHC.Base.$fOrdNonEmpty_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.952586067 UTC

[section ""data" . GHC.Base.$fMonadIO_$cfail_closure" {
     GHC.Base.$fMonadIO_$cfail_closure:
         const GHC.Base.$fMonadIO_$cfail_info;
         const 0;
 },
 GHC.Base.$fMonadIO_$cfail_entry() //  [R2]
         { []
         }
     {offset
       cffb: // global
           R2 = R2;
           R1 = GHC.IO.failIO_closure;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonadIO_$cfail_info" {
     GHC.Base.$fMonadIO_$cfail_info:
         const GHC.Base.$fMonadIO_$cfail_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const S8R0_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.955953528 UTC

[section ""data" . GHC.Base.$fMonadIO_closure" {
     GHC.Base.$fMonadIO_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicativeIO_closure+1;
         const GHC.Base.$fMonadIO1_closure+3;
         const GHC.Base.$fApplicativeIO2_closure+3;
         const GHC.Base.$fApplicativeIO4_closure+2;
         const GHC.Base.$fMonadIO_$cfail_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.958417586 UTC

[section ""data" . GHC.Base.$fMonad[]_$cfail_closure" {
     GHC.Base.$fMonad[]_$cfail_closure:
         const GHC.Base.$fMonad[]_$cfail_info;
 },
 GHC.Base.$fMonad[]_$cfail_entry() //  []
         { []
         }
     {offset
       cffn: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonad[]_$cfail_info" {
     GHC.Base.$fMonad[]_$cfail_info:
         const GHC.Base.$fMonad[]_$cfail_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.961529048 UTC

[section ""data" . GHC.Base.$fMonad[]_closure" {
     GHC.Base.$fMonad[]_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicative[]_closure+1;
         const GHC.Base.$fMonad[]_$c>>=_closure+2;
         const GHC.Base.$fApplicative[]_$c*>_closure+2;
         const GHC.Base.$fApplicative[]_$cpure_closure+1;
         const GHC.Base.$fMonad[]_$cfail_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.963305858 UTC

[section ""data" . GHC.Base.$fMonadPlus[]_closure" {
     GHC.Base.$fMonadPlus[]_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Base.$fAlternative[]_closure+1;
         const GHC.Base.$fMonad[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.++_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.966915109 UTC

[section ""data" . GHC.Base.$fMonadMaybe_$c>>=_closure" {
     GHC.Base.$fMonadMaybe_$c>>=_closure:
         const GHC.Base.$fMonadMaybe_$c>>=_info;
 },
 GHC.Base.$fMonadMaybe_$c>>=_entry() //  [R2, R3]
         { []
         }
     {offset
       cffI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cffJ; else goto cffK;
       cffJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonadMaybe_$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cffK: // global
           I64[Sp - 16] = block_cffB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uffR; else goto cffC;
       uffR: // global
           call _cffB(R1) args: 0, res: 0, upd: 0;
       cffC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonadMaybe_$c>>=_info" {
     GHC.Base.$fMonadMaybe_$c>>=_info:
         const GHC.Base.$fMonadMaybe_$c>>=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cffB() //  [R1]
         { []
         }
     {offset
       cffB: // global
           if (R1 & 7 == 1) goto cffF; else goto cffG;
       cffF: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cffG: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cffB_info" {
     block_cffB_info:
         const _cffB;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.975472912 UTC

[section ""data" . GHC.Base.$fMonadMaybe_$cfail_closure" {
     GHC.Base.$fMonadMaybe_$cfail_closure:
         const GHC.Base.$fMonadMaybe_$cfail_info;
 },
 GHC.Base.$fMonadMaybe_$cfail_entry() //  []
         { []
         }
     {offset
       cfg8: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonadMaybe_$cfail_info" {
     GHC.Base.$fMonadMaybe_$cfail_info:
         const GHC.Base.$fMonadMaybe_$cfail_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.981301182 UTC

[section ""data" . GHC.Base.$fMonad(->)_$c>>=_closure" {
     GHC.Base.$fMonad(->)_$c>>=_closure:
         const GHC.Base.$fMonad(->)_$c>>=_info;
 },
 GHC.Base.$fMonad(->)_$c>>=_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cfgl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfgp; else goto cfgo;
       cfgp: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad(->)_$c>>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfgo: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           _s8dL::P64 = R3;
           R3 = R4;
           R2 = Hp - 24;
           R1 = _s8dL::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonad(->)_$c>>=_info" {
     GHC.Base.$fMonad(->)_$c>>=_info:
         const GHC.Base.$fMonad(->)_$c>>=_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:45.989298937 UTC

[section ""data" . GHC.Base.$fMonad(,)_$c>>=_closure" {
     GHC.Base.$fMonad(,)_$c>>=_closure:
         const GHC.Base.$fMonad(,)_$c>>=_info;
 },
 sat_s8dY_entry() //  [R1]
         { []
         }
     {offset
       cfgN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfgO; else goto cfgP;
       cfgO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfgP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cfgL_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8dY_info" {
     sat_s8dY_info:
         const sat_s8dY_entry;
         const 3;
         const 15;
 },
 _cfgL() //  [R1]
         { []
         }
     {offset
       cfgL: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cfgL_info" {
     block_cfgL_info:
         const _cfgL;
         const 2;
         const 30;
 },
 GHC.Base.$fMonad(,)_$c>>=_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cfgT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfgV; else goto cfgW;
       cfgV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad(,)_$c>>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfgW: // global
           I64[Sp - 24] = block_cfgy_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufh1; else goto cfgz;
       ufh1: // global
           call _cfgy(R1) args: 0, res: 0, upd: 0;
       cfgz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonad(,)_$c>>=_info" {
     GHC.Base.$fMonad(,)_$c>>=_info:
         const GHC.Base.$fMonad(,)_$c>>=_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cfgy() //  [R1]
         { []
         }
     {offset
       cfgy: // global
           I64[Sp] = block_cfgD_info;
           R2 = P64[R1 + 15];
           _s8dS::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8dS::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfgy_info" {
     block_cfgy_info:
         const _cfgy;
         const 2;
         const 30;
 },
 _cfgD() //  [R1]
         { []
         }
     {offset
       cfgD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfh0; else goto cfgZ;
       cfh0: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfgZ: // global
           _s8dV::P64 = P64[R1 + 7];
           _s8dW::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_s8dY_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s8dV::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = _s8dW::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfgD_info" {
     block_cfgD_info:
         const _cfgD;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.007653528 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$c<*>_closure" {
     GHC.Base.$fApplicative(,)_$c<*>_closure:
         const GHC.Base.$fApplicative(,)_$c<*>_info;
 },
 sat_s8e9_entry() //  [R1]
         { []
         }
     {offset
       cfhM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfhN; else goto cfhO;
       cfhN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfhO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cfhK_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8e9_info" {
     sat_s8e9_info:
         const sat_s8e9_entry;
         const 3;
         const 15;
 },
 _cfhK() //  [R1]
         { []
         }
     {offset
       cfhK: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cfhK_info" {
     block_cfhK_info:
         const _cfhK;
         const 2;
         const 30;
 },
 GHC.Base.$fApplicative(,)_$c<*>_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cfhS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfhU; else goto cfhV;
       cfhU: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$c<*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfhV: // global
           I64[Sp - 24] = block_cfhv_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufi1; else goto cfhw;
       ufi1: // global
           call _cfhv(R1) args: 0, res: 0, upd: 0;
       cfhw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative(,)_$c<*>_info" {
     GHC.Base.$fApplicative(,)_$c<*>_info:
         const GHC.Base.$fApplicative(,)_$c<*>_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cfhv() //  [R1]
         { []
         }
     {offset
       cfhv: // global
           I64[Sp - 8] = block_cfhA_info;
           _s8e3::P64 = P64[R1 + 7];
           _s8e4::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _s8e4::P64;
           P64[Sp + 16] = _s8e3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufi0; else goto cfhB;
       ufi0: // global
           call _cfhA(R1) args: 0, res: 0, upd: 0;
       cfhB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfhv_info" {
     block_cfhv_info:
         const _cfhv;
         const 2;
         const 30;
 },
 _cfhA() //  [R1]
         { []
         }
     {offset
       cfhA: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cfhZ; else goto cfhY;
       cfhZ: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfhY: // global
           _s8e6::P64 = P64[R1 + 7];
           _s8e7::P64 = P64[R1 + 15];
           I64[Hp - 88] = stg_ap_2_upd_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _s8e7::P64;
           I64[Hp - 56] = sat_s8e9_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _s8e6::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfhA_info" {
     block_cfhA_info:
         const _cfhA;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.025456886 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$c*>_closure" {
     GHC.Base.$fApplicative(,)_$c*>_closure:
         const GHC.Base.$fApplicative(,)_$c*>_info;
 },
 sat_s8el_entry() //  [R1]
         { []
         }
     {offset
       cfiO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfiP; else goto cfiQ;
       cfiP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfiQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cfiM_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8el_info" {
     sat_s8el_info:
         const sat_s8el_entry;
         const 3;
         const 15;
 },
 _cfiM() //  [R1]
         { []
         }
     {offset
       cfiM: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cfiM_info" {
     block_cfiM_info:
         const _cfiM;
         const 2;
         const 30;
 },
 GHC.Base.$fApplicative(,)_$c*>_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cfiU: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfiW; else goto cfiX;
       cfiW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$c*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfiX: // global
           I64[Sp - 24] = block_cfiy_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufj3; else goto cfiz;
       ufj3: // global
           call _cfiy(R1) args: 0, res: 0, upd: 0;
       cfiz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative(,)_$c*>_info" {
     GHC.Base.$fApplicative(,)_$c*>_info:
         const GHC.Base.$fApplicative(,)_$c*>_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cfiy() //  [R1]
         { []
         }
     {offset
       cfiy: // global
           I64[Sp] = block_cfiD_info;
           _s8ef::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8ef::P64;
           if (R1 & 7 != 0) goto ufj2; else goto cfiE;
       ufj2: // global
           call _cfiD(R1) args: 0, res: 0, upd: 0;
       cfiE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfiy_info" {
     block_cfiy_info:
         const _cfiy;
         const 2;
         const 30;
 },
 _cfiD() //  [R1]
         { []
         }
     {offset
       cfiD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cfj1; else goto cfj0;
       cfj1: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfj0: // global
           _s8ei::P64 = P64[R1 + 7];
           _s8ej::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_s8el_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _s8ei::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = _s8ej::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfiD_info" {
     block_cfiD_info:
         const _cfiD;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.0440883 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$cliftA2_closure" {
     GHC.Base.$fApplicative(,)_$cliftA2_closure:
         const GHC.Base.$fApplicative(,)_$cliftA2_info;
 },
 sat_s8ex_entry() //  [R1]
         { []
         }
     {offset
       cfjP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfjQ; else goto cfjR;
       cfjQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfjR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cfjN_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8ex_info" {
     sat_s8ex_info:
         const sat_s8ex_entry;
         const 3;
         const 15;
 },
 _cfjN() //  [R1]
         { []
         }
     {offset
       cfjN: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cfjN_info" {
     block_cfjN_info:
         const _cfjN;
         const 2;
         const 30;
 },
 GHC.Base.$fApplicative(,)_$cliftA2_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cfjV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfjX; else goto cfjY;
       cfjX: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$cliftA2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfjY: // global
           I64[Sp - 32] = block_cfjy_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufk4; else goto cfjz;
       ufk4: // global
           call _cfjy(R1) args: 0, res: 0, upd: 0;
       cfjz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative(,)_$cliftA2_info" {
     GHC.Base.$fApplicative(,)_$cliftA2_info:
         const GHC.Base.$fApplicative(,)_$cliftA2_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _cfjy() //  [R1]
         { []
         }
     {offset
       cfjy: // global
           I64[Sp - 8] = block_cfjD_info;
           _s8er::P64 = P64[R1 + 7];
           _s8es::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s8es::P64;
           P64[Sp + 24] = _s8er::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufk3; else goto cfjE;
       ufk3: // global
           call _cfjD(R1) args: 0, res: 0, upd: 0;
       cfjE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfjy_info" {
     block_cfjy_info:
         const _cfjy;
         const 3;
         const 30;
 },
 _cfjD() //  [R1]
         { []
         }
     {offset
       cfjD: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cfk2; else goto cfk1;
       cfk2: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfk1: // global
           _s8eu::P64 = P64[R1 + 7];
           _s8ev::P64 = P64[R1 + 15];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _s8ev::P64;
           I64[Hp - 56] = sat_s8ex_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _s8eu::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfjD_info" {
     block_cfjD_info:
         const _cfjD;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.059153799 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,,,,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,,,,)_$cmempty_info;
 },
 sat_s8eI_entry() //  [R1]
         { []
         }
     {offset
       cfkG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfkH; else goto cfkI;
       cfkH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfkI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8eI_info" {
     sat_s8eI_info:
         const sat_s8eI_entry;
         const 1;
         const 16;
 },
 sat_s8eH_entry() //  [R1]
         { []
         }
     {offset
       cfkN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfkO; else goto cfkP;
       cfkO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfkP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8eH_info" {
     sat_s8eH_info:
         const sat_s8eH_entry;
         const 1;
         const 16;
 },
 sat_s8eG_entry() //  [R1]
         { []
         }
     {offset
       cfkU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfkV; else goto cfkW;
       cfkV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfkW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8eG_info" {
     sat_s8eG_info:
         const sat_s8eG_entry;
         const 1;
         const 16;
 },
 sat_s8eF_entry() //  [R1]
         { []
         }
     {offset
       cfl1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfl2; else goto cfl3;
       cfl2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfl3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8eF_info" {
     sat_s8eF_info:
         const sat_s8eF_entry;
         const 1;
         const 16;
 },
 sat_s8eE_entry() //  [R1]
         { []
         }
     {offset
       cfl8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfl9; else goto cfla;
       cfl9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfla: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8eE_info" {
     sat_s8eE_info:
         const sat_s8eE_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fMonoid(,,,,)_$cmempty_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cflc: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cflg; else goto cflf;
       cflg: // global
           HpAlloc = 168;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cmempty_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cflf: // global
           I64[Hp - 160] = sat_s8eI_info;
           P64[Hp - 144] = R6;
           I64[Hp - 136] = sat_s8eH_info;
           P64[Hp - 120] = R5;
           I64[Hp - 112] = sat_s8eG_info;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_s8eF_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_s8eE_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,,)_$cmempty_info" {
     GHC.Base.$fMonoid(,,,,)_$cmempty_info:
         const GHC.Base.$fMonoid(,,,,)_$cmempty_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.072731305 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,,,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,,,)_$cmempty_info;
 },
 sat_s8eQ_entry() //  [R1]
         { []
         }
     {offset
       cflT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cflU; else goto cflV;
       cflU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cflV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8eQ_info" {
     sat_s8eQ_info:
         const sat_s8eQ_entry;
         const 1;
         const 16;
 },
 sat_s8eP_entry() //  [R1]
         { []
         }
     {offset
       cfm0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfm1; else goto cfm2;
       cfm1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfm2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8eP_info" {
     sat_s8eP_info:
         const sat_s8eP_entry;
         const 1;
         const 16;
 },
 sat_s8eO_entry() //  [R1]
         { []
         }
     {offset
       cfm7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfm8; else goto cfm9;
       cfm8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfm9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8eO_info" {
     sat_s8eO_info:
         const sat_s8eO_entry;
         const 1;
         const 16;
 },
 sat_s8eN_entry() //  [R1]
         { []
         }
     {offset
       cfme: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfmf; else goto cfmg;
       cfmf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfmg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8eN_info" {
     sat_s8eN_info:
         const sat_s8eN_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fMonoid(,,,)_$cmempty_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cfmi: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cfmm; else goto cfml;
       cfmm: // global
           HpAlloc = 136;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cmempty_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfml: // global
           I64[Hp - 128] = sat_s8eQ_info;
           P64[Hp - 112] = R5;
           I64[Hp - 104] = sat_s8eP_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = sat_s8eO_info;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_s8eN_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,)_$cmempty_info" {
     GHC.Base.$fMonoid(,,,)_$cmempty_info:
         const GHC.Base.$fMonoid(,,,)_$cmempty_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.084009943 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,,)_$cmempty_info;
 },
 sat_s8eW_entry() //  [R1]
         { []
         }
     {offset
       cfmU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfmV; else goto cfmW;
       cfmV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfmW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8eW_info" {
     sat_s8eW_info:
         const sat_s8eW_entry;
         const 1;
         const 16;
 },
 sat_s8eV_entry() //  [R1]
         { []
         }
     {offset
       cfn1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfn2; else goto cfn3;
       cfn2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfn3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8eV_info" {
     sat_s8eV_info:
         const sat_s8eV_entry;
         const 1;
         const 16;
 },
 sat_s8eU_entry() //  [R1]
         { []
         }
     {offset
       cfn8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfn9; else goto cfna;
       cfn9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfna: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8eU_info" {
     sat_s8eU_info:
         const sat_s8eU_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fMonoid(,,)_$cmempty_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cfnc: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cfng; else goto cfnf;
       cfng: // global
           HpAlloc = 104;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cmempty_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfnf: // global
           I64[Hp - 96] = sat_s8eW_info;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_s8eV_info;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_s8eU_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,)_$cmempty_info" {
     GHC.Base.$fMonoid(,,)_$cmempty_info:
         const GHC.Base.$fMonoid(,,)_$cmempty_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.093921171 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,)_$cmempty_info;
 },
 sat_s8f0_entry() //  [R1]
         { []
         }
     {offset
       cfnJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfnK; else goto cfnL;
       cfnK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfnL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8f0_info" {
     sat_s8f0_info:
         const sat_s8f0_entry;
         const 1;
         const 16;
 },
 sat_s8eZ_entry() //  [R1]
         { []
         }
     {offset
       cfnQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfnR; else goto cfnS;
       cfnR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfnS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8eZ_info" {
     sat_s8eZ_info:
         const sat_s8eZ_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fMonoid(,)_$cmempty_entry() //  [R2, R3]
         { []
         }
     {offset
       cfnU: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cfnY; else goto cfnX;
       cfnY: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cmempty_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfnX: // global
           I64[Hp - 64] = sat_s8f0_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_s8eZ_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,)_$cmempty_info" {
     GHC.Base.$fMonoid(,)_$cmempty_info:
         const GHC.Base.$fMonoid(,)_$cmempty_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.105537856 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,)_$cmconcat_info;
 },
 $dSemigroup_s8f4_entry() //  [R1]
         { []
         }
     {offset
       cfom: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfon; else goto cfoo;
       cfon: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfoo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dSemigroup_s8f4_info" {
     $dSemigroup_s8f4_info:
         const $dSemigroup_s8f4_entry;
         const 1;
         const 16;
 },
 $dSemigroup1_s8f5_entry() //  [R1]
         { []
         }
     {offset
       cfot: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfou; else goto cfov;
       cfou: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfov: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dSemigroup1_s8f5_info" {
     $dSemigroup1_s8f5_info:
         const $dSemigroup1_s8f5_entry;
         const 1;
         const 16;
 },
 z_s8f6_entry() //  [R1]
         { []
         }
     {offset
       cfoA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfoB; else goto cfoC;
       cfoB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfoC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z_s8f6_info" {
     z_s8f6_info:
         const z_s8f6_entry;
         const 1;
         const 16;
 },
 z1_s8f7_entry() //  [R1]
         { []
         }
     {offset
       cfoH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfoI; else goto cfoJ;
       cfoI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfoJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z1_s8f7_info" {
     z1_s8f7_info:
         const z1_s8f7_entry;
         const 1;
         const 16;
 },
 sat_s8fl_entry() //  [R1]
         { []
         }
     {offset
       cfp9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfpa; else goto cfpb;
       cfpa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfpb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8fl_info" {
     sat_s8fl_info:
         const sat_s8fl_entry;
         const 3;
         const 15;
 },
 sat_s8fk_entry() //  [R1]
         { []
         }
     {offset
       cfpg: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfph; else goto cfpi;
       cfph: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfpi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8fk_info" {
     sat_s8fk_info:
         const sat_s8fk_entry;
         const 3;
         const 15;
 },
 go_s8f9_entry() //  [R1, R2]
         { []
         }
     {offset
       cfpn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfpo; else goto cfpp;
       cfpo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfpp: // global
           I64[Sp - 40] = block_cfoQ_info;
           _s8f9::P64 = R1;
           _s8f4::P64 = P64[R1 + 7];
           _s8f5::P64 = P64[R1 + 15];
           _s8f8::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _s8f4::P64;
           P64[Sp - 24] = _s8f5::P64;
           P64[Sp - 16] = _s8f8::P64;
           P64[Sp - 8] = _s8f9::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufpz; else goto cfoR;
       ufpz: // global
           call _cfoQ(R1) args: 0, res: 0, upd: 0;
       cfoR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_s8f9_info" {
     go_s8f9_info:
         const go_s8f9_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 _cfoQ() //  [R1]
         { []
         }
     {offset
       cfoQ: // global
           if (R1 & 7 == 1) goto cfpk; else goto cfpl;
       cfpk: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfpl: // global
           I64[Sp] = block_cfoW_info;
           _s8fd::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _s8fd::P64;
           if (R1 & 7 != 0) goto ufpy; else goto cfoX;
       ufpy: // global
           call _cfoW(R1) args: 0, res: 0, upd: 0;
       cfoX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfoQ_info" {
     block_cfoQ_info:
         const _cfoQ;
         const 4;
         const 30;
 },
 _cfoW() //  [R1]
         { []
         }
     {offset
       cfoW: // global
           I64[Sp] = block_cfp1_info;
           R2 = P64[Sp + 24];
           _s8ff::P64 = P64[R1 + 7];
           _s8fg::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp + 24] = _s8fg::P64;
           P64[Sp + 32] = _s8ff::P64;
           call go_s8f9_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfoW_info" {
     block_cfoW_info:
         const _cfoW;
         const 4;
         const 30;
 },
 _cfp1() //  [R1]
         { []
         }
     {offset
       cfp1: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cfpx; else goto cfpw;
       cfpx: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfpw: // global
           _s8fi::P64 = P64[R1 + 7];
           _s8fj::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_s8fl_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = P64[Sp + 24];
           P64[Hp - 64] = _s8fj::P64;
           I64[Hp - 56] = sat_s8fk_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _s8fi::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfp1_info" {
     block_cfp1_info:
         const _cfp1;
         const 4;
         const 30;
 },
 GHC.Base.$fMonoid(,)_$cmconcat_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cfpA: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cfpE; else goto cfpD;
       cfpE: // global
           HpAlloc = 152;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cmconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfpD: // global
           I64[Hp - 144] = $dSemigroup_s8f4_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = $dSemigroup1_s8f5_info;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = z_s8f6_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = z1_s8f7_info;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = (,)_con_info;
           P64[Hp - 40] = Hp - 96;
           P64[Hp - 32] = Hp - 72;
           I64[Hp - 24] = go_s8f9_info;
           P64[Hp - 16] = Hp - 144;
           P64[Hp - 8] = Hp - 120;
           P64[Hp] = Hp - 47;
           R2 = R4;
           R1 = Hp - 23;
           call go_s8f9_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,)_$cmconcat_info" {
     GHC.Base.$fMonoid(,)_$cmconcat_info:
         const GHC.Base.$fMonoid(,)_$cmconcat_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.125779288 UTC

[section ""data" . GHC.Base.$fMonoid()_$cmconcat_closure" {
     GHC.Base.$fMonoid()_$cmconcat_closure:
         const GHC.Base.$fMonoid()_$cmconcat_info;
 },
 GHC.Base.$fMonoid()_$cmconcat_entry() //  []
         { []
         }
     {offset
       cfqJ: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid()_$cmconcat_info" {
     GHC.Base.$fMonoid()_$cmconcat_info:
         const GHC.Base.$fMonoid()_$cmconcat_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.131139035 UTC

[section ""data" . GHC.Base.$fMonoidMaybe_$c<>_closure" {
     GHC.Base.$fMonoidMaybe_$c<>_closure:
         const GHC.Base.$fMonoidMaybe_$c<>_info;
 },
 sat_s8fu_entry() //  [R1]
         { []
         }
     {offset
       cfrb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfrc; else goto cfrd;
       cfrc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfrd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8fu_info" {
     sat_s8fu_info:
         const sat_s8fu_entry;
         const 3;
         const 15;
 },
 GHC.Base.$fMonoidMaybe_$c<>_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cfri: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfrj; else goto cfrk;
       cfrj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidMaybe_$c<>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfrk: // global
           I64[Sp - 24] = block_cfqV_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufrz; else goto cfqW;
       ufrz: // global
           call _cfqV(R1) args: 0, res: 0, upd: 0;
       cfqW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoidMaybe_$c<>_info" {
     GHC.Base.$fMonoidMaybe_$c<>_info:
         const GHC.Base.$fMonoidMaybe_$c<>_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cfqV() //  [R1]
         { []
         }
     {offset
       cfqV: // global
           _s8fp::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cfrf; else goto cfrg;
       cfrf: // global
           R1 = _s8fp::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cfrg: // global
           I64[Sp - 8] = block_cfr1_info;
           _s8fq::P64 = R1;
           _s8fr::P64 = P64[R1 + 6];
           R1 = _s8fp::P64;
           P64[Sp] = _s8fr::P64;
           P64[Sp + 16] = _s8fq::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufry; else goto cfr2;
       ufry: // global
           call _cfr1(R1) args: 0, res: 0, upd: 0;
       cfr2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfqV_info" {
     block_cfqV_info:
         const _cfqV;
         const 2;
         const 30;
 },
 _cfr1() //  [R1]
         { []
         }
     {offset
       cfr1: // global
           if (R1 & 7 == 1) goto cfrr; else goto cfrt;
       cfrr: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cfrt: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfrw; else goto cfrv;
       cfrw: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfrv: // global
           _s8ft::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_s8fu_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s8ft::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfr1_info" {
     block_cfr1_info:
         const _cfr1;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.143760947 UTC

[section ""data" . GHC.Base.$w$csconcat5_closure" {
     GHC.Base.$w$csconcat5_closure:
         const GHC.Base.$w$csconcat5_info;
 },
 sat_s8fI_entry() //  [R1]
         { []
         }
     {offset
       cfsz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfsA; else goto cfsB;
       cfsA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfsB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8fI_info" {
     sat_s8fI_info:
         const sat_s8fI_entry;
         const 3;
         const 15;
 },
 go_s8fy_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cfsG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfsH; else goto uft3;
       cfsH: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uft3: // global
           P64[Sp - 24] = R1;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cfsb() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . go_s8fy_info" {
     go_s8fy_info:
         const go_s8fy_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 _cfsb() //  []
         { []
         }
     {offset
       cfsb: // global
           _s8fv::P64 = P64[P64[Sp] + 6];
           I64[Sp - 8] = block_cfse_info;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8fv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uft5; else goto cfsf;
       uft5: // global
           call _cfse(R1) args: 0, res: 0, upd: 0;
       cfsf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfse() //  [R1]
         { []
         }
     {offset
       cfse: // global
           _s8fz::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cfsD; else goto cfsE;
       cfsD: // global
           R1 = _s8fz::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cfsE: // global
           I64[Sp - 8] = block_cfsk_info;
           _s8fC::P64 = P64[R1 + 6];
           _s8fD::P64 = P64[R1 + 14];
           R1 = _s8fz::P64;
           P64[Sp] = _s8fD::P64;
           P64[Sp + 16] = _s8fC::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uft6; else goto cfsl;
       uft6: // global
           call _cfsk(R1) args: 0, res: 0, upd: 0;
       cfsl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfse_info" {
     block_cfse_info:
         const _cfse;
         const 3;
         const 30;
 },
 _cfsk() //  [R1]
         { []
         }
     {offset
       cfsk: // global
           _s8fC::P64 = P64[Sp + 24];
           _s8fD::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cfsP; else goto cfsR;
       cfsP: // global
           P64[Sp + 24] = _s8fC::P64;
           P64[Sp + 32] = _s8fD::P64;
           Sp = Sp + 16;
           call _cfsb() args: 0, res: 0, upd: 0;
       cfsR: // global
           I64[Sp + 8] = block_cfsq_info;
           R3 = _s8fD::P64;
           R2 = _s8fC::P64;
           _s8fE::P64 = R1;
           _s8fF::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8fF::P64;
           P64[Sp + 24] = _s8fE::P64;
           Sp = Sp + 8;
           call go_s8fy_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfsk_info" {
     block_cfsk_info:
         const _cfsk;
         const 4;
         const 30;
 },
 _cfsq() //  [R1]
         { []
         }
     {offset
       cfsq: // global
           if (R1 & 7 == 1) goto cfsV; else goto cfsX;
       cfsV: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cfsX: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cft0; else goto cfsZ;
       cft0: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfsZ: // global
           _s8fH::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_s8fI_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s8fH::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfsq_info" {
     block_cfsq_info:
         const _cfsq;
         const 3;
         const 30;
 },
 GHC.Base.$w$csconcat5_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cft9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cftd; else goto cftc;
       cftd: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cftc: // global
           I64[Hp - 8] = go_s8fy_info;
           P64[Hp] = R2;
           _s8fw::P64 = R3;
           R3 = R4;
           R2 = _s8fw::P64;
           R1 = Hp - 6;
           call go_s8fy_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$csconcat5_info" {
     GHC.Base.$w$csconcat5_info:
         const GHC.Base.$w$csconcat5_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.157016322 UTC

[section ""data" . GHC.Base.$fSemigroupMaybe_$csconcat_closure" {
     GHC.Base.$fSemigroupMaybe_$csconcat_closure:
         const GHC.Base.$fSemigroupMaybe_$csconcat_info;
 },
 GHC.Base.$fSemigroupMaybe_$csconcat_entry() //  [R2, R3]
         { []
         }
     {offset
       cfu1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfu2; else goto cfu3;
       cfu2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupMaybe_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfu3: // global
           I64[Sp - 16] = block_cftY_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufu7; else goto cftZ;
       ufu7: // global
           call _cftY(R1) args: 0, res: 0, upd: 0;
       cftZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupMaybe_$csconcat_info" {
     GHC.Base.$fSemigroupMaybe_$csconcat_info:
         const GHC.Base.$fSemigroupMaybe_$csconcat_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cftY() //  [R1]
         { []
         }
     {offset
       cftY: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat5_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cftY_info" {
     block_cftY_info:
         const _cftY;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.163840603 UTC

[section ""data" . GHC.Base.$fSemigroupMaybe_closure" {
     GHC.Base.$fSemigroupMaybe_closure:
         const GHC.Base.$fSemigroupMaybe_info;
         const 0;
 },
 sat_s8fS_entry() //  [R1, R2]
         { []
         }
     {offset
       cfuq: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesMaybe_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8fS_info" {
     sat_s8fS_info:
         const sat_s8fS_entry;
         const 1;
         const 4294967305;
         const 4294967301;
         const S8R0_srt+88;
 },
 sat_s8fQ_entry() //  [R1, R2]
         { []
         }
     {offset
       cfuy: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroupMaybe_$csconcat_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8fQ_info" {
     sat_s8fQ_info:
         const sat_s8fQ_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_s8fP_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cfuG: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoidMaybe_$c<>_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8fP_info" {
     sat_s8fP_info:
         const sat_s8fP_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 GHC.Base.$fSemigroupMaybe_entry() //  [R2]
         { []
         }
     {offset
       cfuK: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cfuO; else goto cfuN;
       cfuO: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfuN: // global
           I64[Hp - 72] = sat_s8fS_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s8fQ_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8fP_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 71;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupMaybe_info" {
     GHC.Base.$fSemigroupMaybe_info:
         const GHC.Base.$fSemigroupMaybe_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S8R0_srt+88;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.174919415 UTC

[section ""data" . GHC.Base.$fMonoidMaybe_$cmconcat_closure" {
     GHC.Base.$fMonoidMaybe_$cmconcat_closure:
         const GHC.Base.$fMonoidMaybe_$cmconcat_info;
 },
 sat_s8g4_entry() //  [R1]
         { []
         }
     {offset
       cfvA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfvB; else goto cfvC;
       cfvB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfvC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8g4_info" {
     sat_s8g4_info:
         const sat_s8g4_entry;
         const 3;
         const 15;
 },
 go_s8fV_entry() //  [R1, R2]
         { []
         }
     {offset
       cfvH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfvI; else goto ufw4;
       cfvI: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ufw4: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _cfvc() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . go_s8fV_info" {
     go_s8fV_info:
         const go_s8fV_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _cfvc() //  []
         { []
         }
     {offset
       cfvc: // global
           _s8fT::P64 = P64[P64[Sp] + 7];
           I64[Sp - 8] = block_cfvf_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _s8fT::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufw6; else goto cfvg;
       ufw6: // global
           call _cfvf(R1) args: 0, res: 0, upd: 0;
       cfvg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfvf() //  [R1]
         { []
         }
     {offset
       cfvf: // global
           if (R1 & 7 == 1) goto cfvE; else goto cfvF;
       cfvE: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfvF: // global
           I64[Sp - 8] = block_cfvl_info;
           _s8fZ::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8fZ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufw7; else goto cfvm;
       ufw7: // global
           call _cfvl(R1) args: 0, res: 0, upd: 0;
       cfvm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfvf_info" {
     block_cfvf_info:
         const _cfvf;
         const 2;
         const 30;
 },
 _cfvl() //  [R1]
         { []
         }
     {offset
       cfvl: // global
           _s8fZ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cfvQ; else goto cfvS;
       cfvQ: // global
           P64[Sp + 24] = _s8fZ::P64;
           Sp = Sp + 16;
           call _cfvc() args: 0, res: 0, upd: 0;
       cfvS: // global
           I64[Sp] = block_cfvr_info;
           R2 = _s8fZ::P64;
           _s8g0::P64 = R1;
           _s8g1::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _s8g1::P64;
           P64[Sp + 16] = _s8g0::P64;
           call go_s8fV_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfvl_info" {
     block_cfvl_info:
         const _cfvl;
         const 3;
         const 30;
 },
 _cfvr() //  [R1]
         { []
         }
     {offset
       cfvr: // global
           if (R1 & 7 == 1) goto cfvW; else goto cfvY;
       cfvW: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cfvY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cfw1; else goto cfw0;
       cfw1: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfw0: // global
           _s8g3::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_s8g4_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s8g3::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfvr_info" {
     block_cfvr_info:
         const _cfvr;
         const 3;
         const 30;
 },
 GHC.Base.$fMonoidMaybe_$cmconcat_entry() //  [R2, R3]
         { []
         }
     {offset
       cfwa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cfwe; else goto cfwd;
       cfwe: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidMaybe_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfwd: // global
           I64[Hp - 8] = go_s8fV_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go_s8fV_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoidMaybe_$cmconcat_info" {
     GHC.Base.$fMonoidMaybe_$cmconcat_info:
         const GHC.Base.$fMonoidMaybe_$cmconcat_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.190022781 UTC

[section ""data" . GHC.Base.$fMonoidMaybe_closure" {
     GHC.Base.$fMonoidMaybe_closure:
         const GHC.Base.$fMonoidMaybe_info;
         const 0;
 },
 sat_s8g8_entry() //  [R1, R2]
         { []
         }
     {offset
       cfx3: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fMonoidMaybe_$cmconcat_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8g8_info" {
     sat_s8g8_info:
         const sat_s8g8_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_s8g7_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cfxb: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoidMaybe_$c<>_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8g7_info" {
     sat_s8g7_info:
         const sat_s8g7_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8g6_entry() //  [R1]
         { []
         }
     {offset
       cfxi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfxj; else goto cfxk;
       cfxj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfxk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fSemigroupMaybe_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8g6_info" {
     sat_s8g6_info:
         const sat_s8g6_entry;
         const 1;
         const 4294967312;
         const S8R0_srt+96;
 },
 GHC.Base.$fMonoidMaybe_entry() //  [R2]
         { []
         }
     {offset
       cfxm: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cfxq; else goto cfxp;
       cfxq: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = GHC.Base.$fMonoidMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfxp: // global
           I64[Hp - 88] = sat_s8g8_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s8g7_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s8g6_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = Hp - 70;
           P64[Hp] = Hp - 87;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoidMaybe_info" {
     GHC.Base.$fMonoidMaybe_info:
         const GHC.Base.$fMonoidMaybe_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S8R0_srt+96;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.198795106 UTC

[section ""data" . GHC.Base.$fMonoidOrdering_$c<>_closure" {
     GHC.Base.$fMonoidOrdering_$c<>_closure:
         const GHC.Base.$fMonoidOrdering_$c<>_info;
 },
 GHC.Base.$fMonoidOrdering_$c<>_entry() //  [R2, R3]
         { []
         }
     {offset
       cfxV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfxW; else goto cfxX;
       cfxW: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidOrdering_$c<>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfxX: // global
           I64[Sp - 16] = block_cfxN_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ufy8; else goto cfxO;
       ufy8: // global
           call _cfxN(R1) args: 0, res: 0, upd: 0;
       cfxO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoidOrdering_$c<>_info" {
     GHC.Base.$fMonoidOrdering_$c<>_info:
         const GHC.Base.$fMonoidOrdering_$c<>_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cfxN() //  [R1]
         { []
         }
     {offset
       cfxN: // global
           _cfxU::P64 = R1 & 7;
           if (_cfxU::P64 < 3) goto ufy7; else goto cfxT;
       ufy7: // global
           if (_cfxU::P64 < 2) goto cfxR; else goto cfxS;
       cfxR: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfxS: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cfxT: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfxN_info" {
     block_cfxN_info:
         const _cfxN;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.206148008 UTC

[section ""data" . GHC.Base.$fMonoidOrdering_go_closure" {
     GHC.Base.$fMonoidOrdering_go_closure:
         const GHC.Base.$fMonoidOrdering_go_info;
 },
 GHC.Base.$fMonoidOrdering_go_entry() //  [R2]
         { []
         }
     {offset
       cfyy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfyz; else goto ufyZ;
       cfyz: // global
           R2 = R2;
           R1 = GHC.Base.$fMonoidOrdering_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ufyZ: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cfyo() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoidOrdering_go_info" {
     GHC.Base.$fMonoidOrdering_go_info:
         const GHC.Base.$fMonoidOrdering_go_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cfyo() //  []
         { []
         }
     {offset
       cfyo: // global
           _s8gc::P64 = P64[Sp];
           I64[Sp] = block_cfyr_info;
           R1 = _s8gc::P64;
           if (R1 & 7 != 0) goto ufz1; else goto cfys;
       ufz1: // global
           call _cfyr(R1) args: 0, res: 0, upd: 0;
       cfys: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cfyr() //  [R1]
         { []
         }
     {offset
       cfyr: // global
           if (R1 & 7 == 1) goto cfyv; else goto cfyw;
       cfyv: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfyw: // global
           I64[Sp - 8] = block_cfyG_info;
           _s8gf::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8gf::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufz2; else goto cfyI;
       ufz2: // global
           call _cfyG(R1) args: 0, res: 0, upd: 0;
       cfyI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfyr_info" {
     block_cfyr_info:
         const _cfyr;
         const 0;
         const 30;
 },
 _cfyG() //  [R1]
         { []
         }
     {offset
       cfyG: // global
           _cfyX::P64 = R1 & 7;
           if (_cfyX::P64 < 3) goto ufyY; else goto cfyW;
       ufyY: // global
           if (_cfyX::P64 < 2) goto cfyO; else goto cfyS;
       cfyO: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfyS: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cfyo() args: 0, res: 0, upd: 0;
       cfyW: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfyG_info" {
     block_cfyG_info:
         const _cfyG;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.21464828 UTC

[section ""data" . GHC.Base.$fSemigroupOrdering_closure" {
     GHC.Base.$fSemigroupOrdering_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.$fMonoidOrdering_$c<>_closure+2;
         const GHC.Base.$fSemigroupOrdering_$csconcat_closure+1;
         const GHC.Base.$fSemigroupOrdering_$cstimes_closure+1;
         const 0;
 },
 section ""data" . GHC.Base.$fMonoidOrdering_closure" {
     GHC.Base.$fMonoidOrdering_closure:
         const GHC.Base.C:Monoid_con_info;
         const GHC.Base.$fSemigroupOrdering_closure+1;
         const GHC.Types.EQ_closure+2;
         const GHC.Base.$fMonoidOrdering_$c<>_closure+2;
         const GHC.Base.$fMonoidOrdering_go_closure+1;
         const 0;
 },
 section ""data" . GHC.Base.$fSemigroupOrdering_$cstimes_closure" {
     GHC.Base.$fSemigroupOrdering_$cstimes_closure:
         const GHC.Base.$fSemigroupOrdering_$cstimes_info;
         const 0;
 },
 GHC.Base.$fSemigroupOrdering_$cstimes_entry() //  [R2]
         { []
         }
     {offset
       cfzv: // global
           R3 = GHC.Base.$fMonoidOrdering_closure+1;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupOrdering_$cstimes_info" {
     GHC.Base.$fSemigroupOrdering_$cstimes_info:
         const GHC.Base.$fSemigroupOrdering_$cstimes_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S8R0_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.223677296 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$c<>_closure" {
     GHC.Base.$fMonoid(,,,,)_$c<>_closure:
         const GHC.Base.$fMonoid(,,,,)_$c<>_info;
 },
 GHC.Base.$fMonoid(,,,,)_$c<>_slow() //  [R1]
         { []
         }
     {offset
       cfzF: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$fMonoid(,,,,)_$c<>_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s8gF_entry() //  [R1]
         { []
         }
     {offset
       cfzX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfzY; else goto cfzZ;
       cfzY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfzZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8gF_info" {
     sat_s8gF_info:
         const sat_s8gF_entry;
         const 3;
         const 15;
 },
 sat_s8gE_entry() //  [R1]
         { []
         }
     {offset
       cfA4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfA5; else goto cfA6;
       cfA5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfA6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8gE_info" {
     sat_s8gE_info:
         const sat_s8gE_entry;
         const 3;
         const 15;
 },
 sat_s8gD_entry() //  [R1]
         { []
         }
     {offset
       cfAb: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfAc; else goto cfAd;
       cfAc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfAd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8gD_info" {
     sat_s8gD_info:
         const sat_s8gD_entry;
         const 3;
         const 15;
 },
 sat_s8gC_entry() //  [R1]
         { []
         }
     {offset
       cfAi: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfAj; else goto cfAk;
       cfAj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfAk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8gC_info" {
     sat_s8gC_info:
         const sat_s8gC_entry;
         const 3;
         const 15;
 },
 sat_s8gB_entry() //  [R1]
         { []
         }
     {offset
       cfAp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfAq; else goto cfAr;
       cfAq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfAr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8gB_info" {
     sat_s8gB_info:
         const sat_s8gB_entry;
         const 3;
         const 15;
 },
 GHC.Base.$fMonoid(,,,,)_$c<>_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cfAs: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cfAu; else goto cfAv;
       cfAu: // global
           R1 = GHC.Base.$fMonoid(,,,,)_$c<>_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cfAv: // global
           I64[Sp - 40] = block_cfzJ_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufAB; else goto cfzK;
       ufAB: // global
           call _cfzJ(R1) args: 0, res: 0, upd: 0;
       cfzK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,,)_$c<>_info" {
     GHC.Base.$fMonoid(,,,,)_$c<>_info:
         const GHC.Base.$fMonoid(,,,,)_$c<>_entry;
         const 0;
         const 14;
         const 30064771072;
         const 0;
         const 7;
         const GHC.Base.$fMonoid(,,,,)_$c<>_slow;
 },
 _cfzJ() //  [R1]
         { []
         }
     {offset
       cfzJ: // global
           I64[Sp - 32] = block_cfzO_info;
           _s8gq::P64 = P64[R1 + 7];
           _s8gr::P64 = P64[R1 + 15];
           _s8gs::P64 = P64[R1 + 23];
           _s8gt::P64 = P64[R1 + 31];
           _s8gu::P64 = P64[R1 + 39];
           R1 = P64[Sp + 48];
           P64[Sp - 24] = _s8gs::P64;
           P64[Sp - 16] = _s8gt::P64;
           P64[Sp - 8] = _s8gu::P64;
           P64[Sp] = _s8gr::P64;
           P64[Sp + 48] = _s8gq::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufAA; else goto cfzP;
       ufAA: // global
           call _cfzO(R1) args: 0, res: 0, upd: 0;
       cfzP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfzJ_info" {
     block_cfzJ_info:
         const _cfzJ;
         const 6;
         const 30;
 },
 _cfzO() //  [R1]
         { []
         }
     {offset
       cfzO: // global
           Hp = Hp + 248;
           if (Hp > HpLim) (likely: False) goto cfAz; else goto cfAy;
       cfAz: // global
           HpAlloc = 248;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfAy: // global
           _s8gw::P64 = P64[R1 + 7];
           _s8gx::P64 = P64[R1 + 15];
           _s8gy::P64 = P64[R1 + 23];
           _s8gz::P64 = P64[R1 + 31];
           _s8gA::P64 = P64[R1 + 39];
           I64[Hp - 240] = sat_s8gF_info;
           P64[Hp - 224] = P64[Sp + 64];
           P64[Hp - 216] = P64[Sp + 24];
           P64[Hp - 208] = _s8gA::P64;
           I64[Hp - 200] = sat_s8gE_info;
           P64[Hp - 184] = P64[Sp + 56];
           P64[Hp - 176] = P64[Sp + 16];
           P64[Hp - 168] = _s8gz::P64;
           I64[Hp - 160] = sat_s8gD_info;
           P64[Hp - 144] = P64[Sp + 48];
           P64[Hp - 136] = P64[Sp + 8];
           P64[Hp - 128] = _s8gy::P64;
           I64[Hp - 120] = sat_s8gC_info;
           P64[Hp - 104] = P64[Sp + 40];
           P64[Hp - 96] = P64[Sp + 32];
           P64[Hp - 88] = _s8gx::P64;
           I64[Hp - 80] = sat_s8gB_info;
           P64[Hp - 64] = P64[Sp + 72];
           P64[Hp - 56] = P64[Sp + 80];
           P64[Hp - 48] = _s8gw::P64;
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = Hp - 80;
           P64[Hp - 24] = Hp - 120;
           P64[Hp - 16] = Hp - 160;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 240;
           R1 = Hp - 39;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfzO_info" {
     block_cfzO_info:
         const _cfzO;
         const 10;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.248222414 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$csconcat_closure" {
     GHC.Base.$fMonoid(,,,,)_$csconcat_closure:
         const GHC.Base.$fMonoid(,,,,)_$csconcat_info;
 },
 sat_s8hl_entry() //  [R1]
         { []
         }
     {offset
       cfCd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfCe; else goto cfCf;
       cfCe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfCf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8hl_info" {
     sat_s8hl_info:
         const sat_s8hl_entry;
         const 3;
         const 15;
 },
 sat_s8hk_entry() //  [R1]
         { []
         }
     {offset
       cfCk: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfCl; else goto cfCm;
       cfCl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfCm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8hk_info" {
     sat_s8hk_info:
         const sat_s8hk_entry;
         const 3;
         const 15;
 },
 sat_s8hj_entry() //  [R1]
         { []
         }
     {offset
       cfCr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfCs; else goto cfCt;
       cfCs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfCt: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8hj_info" {
     sat_s8hj_info:
         const sat_s8hj_entry;
         const 3;
         const 15;
 },
 sat_s8hi_entry() //  [R1]
         { []
         }
     {offset
       cfCy: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfCz; else goto cfCA;
       cfCz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfCA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8hi_info" {
     sat_s8hi_info:
         const sat_s8hi_entry;
         const 3;
         const 15;
 },
 sat_s8hh_entry() //  [R1]
         { []
         }
     {offset
       cfCF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfCG; else goto cfCH;
       cfCG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfCH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8hh_info" {
     sat_s8hh_info:
         const sat_s8hh_entry;
         const 3;
         const 15;
 },
 $wgo_s8gV_entry() //  [R1, R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cfCM: // global
           if ((Sp + -120) < SpLim) (likely: False) goto cfCN; else goto cfCO;
       cfCN: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cfCO: // global
           I64[Sp - 88] = block_cfBU_info;
           _s8gV::P64 = R1;
           _s8gG::P64 = P64[R1 + 2];
           _s8gH::P64 = P64[R1 + 10];
           _s8gI::P64 = P64[R1 + 18];
           _s8gJ::P64 = P64[R1 + 26];
           _s8gK::P64 = P64[R1 + 34];
           R1 = P64[Sp];
           P64[Sp - 80] = _s8gH::P64;
           P64[Sp - 72] = _s8gI::P64;
           P64[Sp - 64] = _s8gJ::P64;
           P64[Sp - 56] = _s8gK::P64;
           P64[Sp - 48] = _s8gV::P64;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = _s8gG::P64;
           Sp = Sp - 88;
           if (R1 & 7 != 0) goto ufCZ; else goto cfBV;
       ufCZ: // global
           call _cfBU(R1) args: 0, res: 0, upd: 0;
       cfBV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . $wgo_s8gV_info" {
     $wgo_s8gV_info:
         const $wgo_s8gV_entry;
         const 5;
         const 8;
         const 25769803802;
 },
 _cfBU() //  [R1]
         { []
         }
     {offset
       cfBU: // global
           if (R1 & 7 == 1) goto cfCJ; else goto cfCK;
       cfCJ: // global
           R5 = P64[Sp + 80];
           R4 = P64[Sp + 72];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 48];
           Sp = Sp + 96;
           call (I64[P64[Sp]])(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfCK: // global
           I64[Sp - 8] = block_cfC0_info;
           _s8h4::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8h4::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufCX; else goto cfC1;
       ufCX: // global
           call _cfC0(R1) args: 0, res: 0, upd: 0;
       cfC1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfBU_info" {
     block_cfBU_info:
         const _cfBU;
         const 11;
         const 30;
 },
 _cfC0() //  [R1]
         { []
         }
     {offset
       cfC0: // global
           _s8h4::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cfC5_info;
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 48];
           P64[Sp] = _s8h4::P64;
           call $wgo_s8gV_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfC0_info" {
     block_cfC0_info:
         const _cfC0;
         const 12;
         const 30;
 },
 _cfC5() //  [R1, R2, R3, R4, R5]
         { []
         }
     {offset
       cfC5: // global
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           P64[Sp] = R2;
           P64[Sp + 40] = R1;
           Sp = Sp - 32;
           call _cfC6() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cfC5_info" {
     block_cfC5_info:
         const _cfC5;
         const 1035;
         const 30;
 },
 _cfC6() //  []
         { []
         }
     {offset
       cfC6: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cfCV; else goto cfCU;
       cfCV: // global
           HpAlloc = 200;
           I64[Sp] = block_cfC6_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cfCU: // global
           I64[Hp - 192] = sat_s8hl_info;
           P64[Hp - 176] = P64[Sp + 64];
           P64[Hp - 168] = P64[Sp + 112];
           P64[Hp - 160] = P64[Sp + 24];
           I64[Hp - 152] = sat_s8hk_info;
           P64[Hp - 136] = P64[Sp + 56];
           P64[Hp - 128] = P64[Sp + 104];
           P64[Hp - 120] = P64[Sp + 16];
           I64[Hp - 112] = sat_s8hj_info;
           P64[Hp - 96] = P64[Sp + 48];
           P64[Hp - 88] = P64[Sp + 96];
           P64[Hp - 80] = P64[Sp + 8];
           I64[Hp - 72] = sat_s8hi_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = P64[Sp + 88];
           P64[Hp - 40] = P64[Sp + 32];
           I64[Hp - 32] = sat_s8hh_info;
           P64[Hp - 16] = P64[Sp + 120];
           P64[Hp - 8] = P64[Sp + 80];
           P64[Hp] = P64[Sp + 72];
           R5 = Hp - 192;
           R4 = Hp - 152;
           R3 = Hp - 112;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfC6_info" {
     block_cfC6_info:
         const _cfC6;
         const 15;
         const 30;
 },
 GHC.Base.$fMonoid(,,,,)_$csconcat_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cfD0: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfD6; else goto cfD7;
       cfD6: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$csconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cfD7: // global
           I64[Sp - 40] = block_cfBF_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufDh; else goto cfBG;
       ufDh: // global
           call _cfBF(R1) args: 0, res: 0, upd: 0;
       cfBG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,,)_$csconcat_info" {
     GHC.Base.$fMonoid(,,,,)_$csconcat_info:
         const GHC.Base.$fMonoid(,,,,)_$csconcat_entry;
         const 0;
         const 14;
         const 25769803802;
 },
 _cfBF() //  [R1]
         { []
         }
     {offset
       cfBF: // global
           I64[Sp - 8] = block_cfBK_info;
           _s8gO::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s8gO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufDg; else goto cfBL;
       ufDg: // global
           call _cfBK(R1) args: 0, res: 0, upd: 0;
       cfBL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfBF_info" {
     block_cfBF_info:
         const _cfBF;
         const 5;
         const 30;
 },
 _cfBK() //  [R1]
         { []
         }
     {offset
       cfBK: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfDb; else goto cfDa;
       cfDb: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfDa: // global
           _s8gQ::P64 = P64[R1 + 7];
           _s8gR::P64 = P64[R1 + 15];
           _s8gS::P64 = P64[R1 + 23];
           _s8gT::P64 = P64[R1 + 31];
           _s8gU::P64 = P64[R1 + 39];
           I64[Hp - 40] = $wgo_s8gV_info;
           P64[Hp - 32] = P64[Sp + 48];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           I64[Sp + 48] = block_cfD1_info;
           R6 = _s8gU::P64;
           R5 = _s8gT::P64;
           R4 = _s8gS::P64;
           R3 = _s8gR::P64;
           R2 = _s8gQ::P64;
           R1 = Hp - 34;
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 40;
           call $wgo_s8gV_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfBK_info" {
     block_cfBK_info:
         const _cfBK;
         const 6;
         const 30;
 },
 _cfD1() //  [R1, R2, R3, R4, R5]
         { []
         }
     {offset
       cfD1: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           P64[Sp] = R1;
           Sp = Sp - 40;
           call _cfD2() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cfD1_info" {
     block_cfD1_info:
         const _cfD1;
         const 0;
         const 30;
 },
 _cfD2() //  []
         { []
         }
     {offset
       cfD2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cfDe; else goto cfDd;
       cfDe: // global
           HpAlloc = 48;
           I64[Sp] = block_cfD2_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cfDd: // global
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           R1 = Hp - 39;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfD2_info" {
     block_cfD2_info:
         const _cfD2;
         const 5;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.281196443 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cstimes_closure" {
     GHC.Base.$fMonoid(,,,,)_$cstimes_closure:
         const GHC.Base.$fMonoid(,,,,)_$cstimes_info;
 },
 GHC.Base.$fMonoid(,,,,)_$cstimes_slow() //  [R1]
         { []
         }
     {offset
       cfEU: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$fMonoid(,,,,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_s8hK_entry() //  [R1]
         { []
         }
     {offset
       cfF7: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfF8; else goto cfF9;
       cfF8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfF9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8hK_info" {
     sat_s8hK_info:
         const sat_s8hK_entry;
         const 4;
         const 15;
 },
 sat_s8hJ_entry() //  [R1]
         { []
         }
     {offset
       cfFe: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfFf; else goto cfFg;
       cfFf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfFg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8hJ_info" {
     sat_s8hJ_info:
         const sat_s8hJ_entry;
         const 4;
         const 15;
 },
 sat_s8hI_entry() //  [R1]
         { []
         }
     {offset
       cfFl: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfFm; else goto cfFn;
       cfFm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfFn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8hI_info" {
     sat_s8hI_info:
         const sat_s8hI_entry;
         const 4;
         const 15;
 },
 sat_s8hH_entry() //  [R1]
         { []
         }
     {offset
       cfFs: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfFt; else goto cfFu;
       cfFt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfFu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8hH_info" {
     sat_s8hH_info:
         const sat_s8hH_entry;
         const 4;
         const 15;
 },
 sat_s8hG_entry() //  [R1]
         { []
         }
     {offset
       cfFz: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfFA; else goto cfFB;
       cfFA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfFB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8hG_info" {
     sat_s8hG_info:
         const sat_s8hG_entry;
         const 4;
         const 15;
 },
 GHC.Base.$fMonoid(,,,,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cfFC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfFE; else goto cfFF;
       cfFE: // global
           R1 = GHC.Base.$fMonoid(,,,,)_$cstimes_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cfFF: // global
           I64[Sp - 40] = block_cfEY_info;
           R1 = P64[Sp + 16];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp + 16] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufFJ; else goto cfEZ;
       ufFJ: // global
           call _cfEY(R1) args: 0, res: 0, upd: 0;
       cfEZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,,)_$cstimes_info" {
     GHC.Base.$fMonoid(,,,,)_$cstimes_info:
         const GHC.Base.$fMonoid(,,,,)_$cstimes_entry;
         const 0;
         const 14;
         const 34359738368;
         const 0;
         const 8;
         const GHC.Base.$fMonoid(,,,,)_$cstimes_slow;
 },
 _cfEY() //  [R1]
         { []
         }
     {offset
       cfEY: // global
           Hp = Hp + 288;
           if (Hp > HpLim) (likely: False) goto cfFI; else goto cfFH;
       cfFI: // global
           HpAlloc = 288;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfFH: // global
           _s8hB::P64 = P64[R1 + 7];
           _s8hC::P64 = P64[R1 + 15];
           _s8hD::P64 = P64[R1 + 23];
           _s8hE::P64 = P64[R1 + 31];
           _s8hF::P64 = P64[R1 + 39];
           I64[Hp - 280] = sat_s8hK_info;
           P64[Hp - 264] = P64[Sp + 32];
           _s8hx::P64 = P64[Sp + 40];
           P64[Hp - 256] = _s8hx::P64;
           _s8hy::P64 = P64[Sp + 48];
           P64[Hp - 248] = _s8hy::P64;
           P64[Hp - 240] = _s8hF::P64;
           I64[Hp - 232] = sat_s8hJ_info;
           P64[Hp - 216] = P64[Sp + 24];
           P64[Hp - 208] = _s8hx::P64;
           P64[Hp - 200] = _s8hy::P64;
           P64[Hp - 192] = _s8hE::P64;
           I64[Hp - 184] = sat_s8hI_info;
           P64[Hp - 168] = P64[Sp + 16];
           P64[Hp - 160] = _s8hx::P64;
           P64[Hp - 152] = _s8hy::P64;
           P64[Hp - 144] = _s8hD::P64;
           I64[Hp - 136] = sat_s8hH_info;
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _s8hx::P64;
           P64[Hp - 104] = _s8hy::P64;
           P64[Hp - 96] = _s8hC::P64;
           I64[Hp - 88] = sat_s8hG_info;
           P64[Hp - 72] = P64[Sp + 56];
           P64[Hp - 64] = _s8hx::P64;
           P64[Hp - 56] = _s8hy::P64;
           P64[Hp - 48] = _s8hB::P64;
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = Hp - 88;
           P64[Hp - 24] = Hp - 136;
           P64[Hp - 16] = Hp - 184;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 280;
           R1 = Hp - 39;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfEY_info" {
     block_cfEY_info:
         const _cfEY;
         const 7;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.300252402 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,,)_closure" {
     GHC.Base.$fSemigroup(,,,,)_closure:
         const GHC.Base.$fSemigroup(,,,,)_info;
 },
 sat_s8hS_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cfGO: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfGP; else goto cfGQ;
       cfGP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfGQ: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 24;
           call GHC.Base.$fMonoid(,,,,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8hS_info" {
     sat_s8hS_info:
         const sat_s8hS_entry;
         const 5;
         const 8;
         const 12884901911;
 },
 sat_s8hR_entry() //  [R1, R2]
         { []
         }
     {offset
       cfGW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfGX; else goto cfGY;
       cfGX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfGY: // global
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _B1::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,,)_$csconcat_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8hR_info" {
     sat_s8hR_info:
         const sat_s8hR_entry;
         const 5;
         const 8;
         const 4294967301;
 },
 sat_s8hQ_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cfH4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfH5; else goto cfH6;
       cfH5: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfH6: // global
           R6 = P64[R1 + 38];
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           _B2::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$c<>_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8hQ_info" {
     sat_s8hQ_info:
         const sat_s8hQ_entry;
         const 5;
         const 8;
         const 8589934607;
 },
 GHC.Base.$fSemigroup(,,,,)_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cfH8: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto cfHc; else goto cfHb;
       cfHc: // global
           HpAlloc = 176;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,,,)_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfHb: // global
           I64[Hp - 168] = sat_s8hS_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           P64[Hp - 136] = R5;
           P64[Hp - 128] = R6;
           I64[Hp - 120] = sat_s8hR_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           P64[Hp - 88] = R5;
           P64[Hp - 80] = R6;
           I64[Hp - 72] = sat_s8hQ_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           P64[Hp - 32] = R6;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 119;
           P64[Hp] = Hp - 165;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,,,,)_info" {
     GHC.Base.$fSemigroup(,,,,)_info:
         const GHC.Base.$fSemigroup(,,,,)_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.317925915 UTC

[section ""data" . GHC.Base.$w$cp1Monoid1_closure" {
     GHC.Base.$w$cp1Monoid1_closure:
         const GHC.Base.$w$cp1Monoid1_info;
 },
 sat_s8ie_entry() //  [R1]
         { []
         }
     {offset
       cfHF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfHG; else goto cfHH;
       cfHG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfHH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8ie_info" {
     sat_s8ie_info:
         const sat_s8ie_entry;
         const 1;
         const 16;
 },
 sat_s8id_entry() //  [R1]
         { []
         }
     {offset
       cfHM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfHN; else goto cfHO;
       cfHN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfHO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8id_info" {
     sat_s8id_info:
         const sat_s8id_entry;
         const 1;
         const 16;
 },
 sat_s8ic_entry() //  [R1]
         { []
         }
     {offset
       cfHT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfHU; else goto cfHV;
       cfHU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfHV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8ic_info" {
     sat_s8ic_info:
         const sat_s8ic_entry;
         const 1;
         const 16;
 },
 sat_s8ib_entry() //  [R1]
         { []
         }
     {offset
       cfI0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfI1; else goto cfI2;
       cfI1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfI2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8ib_info" {
     sat_s8ib_info:
         const sat_s8ib_entry;
         const 1;
         const 16;
 },
 sat_s8ia_entry() //  [R1]
         { []
         }
     {offset
       cfI7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfI8; else goto cfI9;
       cfI8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfI9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8ia_info" {
     sat_s8ia_info:
         const sat_s8ia_entry;
         const 1;
         const 16;
 },
 sat_s8if_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cfIf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cfIg; else goto cfIh;
       cfIg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfIh: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 24;
           call GHC.Base.$fMonoid(,,,,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8if_info" {
     sat_s8if_info:
         const sat_s8if_entry;
         const 5;
         const 8;
         const 12884901911;
 },
 sat_s8i8_entry() //  [R1]
         { []
         }
     {offset
       cfIm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfIn; else goto cfIo;
       cfIn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfIo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8i8_info" {
     sat_s8i8_info:
         const sat_s8i8_entry;
         const 1;
         const 16;
 },
 sat_s8i7_entry() //  [R1]
         { []
         }
     {offset
       cfIt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfIu; else goto cfIv;
       cfIu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfIv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8i7_info" {
     sat_s8i7_info:
         const sat_s8i7_entry;
         const 1;
         const 16;
 },
 sat_s8i6_entry() //  [R1]
         { []
         }
     {offset
       cfIA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfIB; else goto cfIC;
       cfIB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfIC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8i6_info" {
     sat_s8i6_info:
         const sat_s8i6_entry;
         const 1;
         const 16;
 },
 sat_s8i5_entry() //  [R1]
         { []
         }
     {offset
       cfIH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfII; else goto cfIJ;
       cfII: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfIJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8i5_info" {
     sat_s8i5_info:
         const sat_s8i5_entry;
         const 1;
         const 16;
 },
 sat_s8i4_entry() //  [R1]
         { []
         }
     {offset
       cfIO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfIP; else goto cfIQ;
       cfIP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfIQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8i4_info" {
     sat_s8i4_info:
         const sat_s8i4_entry;
         const 1;
         const 16;
 },
 sat_s8i9_entry() //  [R1, R2]
         { []
         }
     {offset
       cfIW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfIX; else goto cfIY;
       cfIX: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfIY: // global
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _B1::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,,)_$csconcat_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8i9_info" {
     sat_s8i9_info:
         const sat_s8i9_entry;
         const 5;
         const 8;
         const 4294967301;
 },
 sat_s8i2_entry() //  [R1]
         { []
         }
     {offset
       cfJ3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfJ4; else goto cfJ5;
       cfJ4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfJ5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8i2_info" {
     sat_s8i2_info:
         const sat_s8i2_entry;
         const 1;
         const 16;
 },
 sat_s8i1_entry() //  [R1]
         { []
         }
     {offset
       cfJa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfJb; else goto cfJc;
       cfJb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfJc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8i1_info" {
     sat_s8i1_info:
         const sat_s8i1_entry;
         const 1;
         const 16;
 },
 sat_s8i0_entry() //  [R1]
         { []
         }
     {offset
       cfJh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfJi; else goto cfJj;
       cfJi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfJj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8i0_info" {
     sat_s8i0_info:
         const sat_s8i0_entry;
         const 1;
         const 16;
 },
 sat_s8hZ_entry() //  [R1]
         { []
         }
     {offset
       cfJo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfJp; else goto cfJq;
       cfJp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfJq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8hZ_info" {
     sat_s8hZ_info:
         const sat_s8hZ_entry;
         const 1;
         const 16;
 },
 sat_s8hY_entry() //  [R1]
         { []
         }
     {offset
       cfJv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfJw; else goto cfJx;
       cfJw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfJx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8hY_info" {
     sat_s8hY_info:
         const sat_s8hY_entry;
         const 1;
         const 16;
 },
 sat_s8i3_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cfJD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfJE; else goto cfJF;
       cfJE: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfJF: // global
           R6 = P64[R1 + 38];
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           _B2::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$c<>_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8i3_info" {
     sat_s8i3_info:
         const sat_s8i3_entry;
         const 5;
         const 8;
         const 8589934607;
 },
 GHC.Base.$w$cp1Monoid1_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cfJG: // global
           Hp = Hp + 504;
           if (Hp > HpLim) (likely: False) goto cfJK; else goto cfJJ;
       cfJK: // global
           HpAlloc = 504;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$cp1Monoid1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfJJ: // global
           I64[Hp - 496] = sat_s8ie_info;
           P64[Hp - 480] = R6;
           I64[Hp - 472] = sat_s8id_info;
           P64[Hp - 456] = R5;
           I64[Hp - 448] = sat_s8ic_info;
           P64[Hp - 432] = R4;
           I64[Hp - 424] = sat_s8ib_info;
           P64[Hp - 408] = R3;
           I64[Hp - 400] = sat_s8ia_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_s8if_info;
           P64[Hp - 368] = Hp - 400;
           P64[Hp - 360] = Hp - 424;
           P64[Hp - 352] = Hp - 448;
           P64[Hp - 344] = Hp - 472;
           P64[Hp - 336] = Hp - 496;
           I64[Hp - 328] = sat_s8i8_info;
           P64[Hp - 312] = R6;
           I64[Hp - 304] = sat_s8i7_info;
           P64[Hp - 288] = R5;
           I64[Hp - 280] = sat_s8i6_info;
           P64[Hp - 264] = R4;
           I64[Hp - 256] = sat_s8i5_info;
           P64[Hp - 240] = R3;
           I64[Hp - 232] = sat_s8i4_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_s8i9_info;
           P64[Hp - 200] = Hp - 232;
           P64[Hp - 192] = Hp - 256;
           P64[Hp - 184] = Hp - 280;
           P64[Hp - 176] = Hp - 304;
           P64[Hp - 168] = Hp - 328;
           I64[Hp - 160] = sat_s8i2_info;
           P64[Hp - 144] = R6;
           I64[Hp - 136] = sat_s8i1_info;
           P64[Hp - 120] = R5;
           I64[Hp - 112] = sat_s8i0_info;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_s8hZ_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_s8hY_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8i3_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R3 = Hp - 373;
           R2 = Hp - 207;
           R1 = Hp - 38;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$cp1Monoid1_info" {
     GHC.Base.$w$cp1Monoid1_info:
         const GHC.Base.$w$cp1Monoid1_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.352756724 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,,,,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,,,,)_$cp1Monoid_info;
 },
 GHC.Base.$fMonoid(,,,,)_$cp1Monoid_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cfLm: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfLn; else goto cfLo;
       cfLn: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfLo: // global
           I64[Sp - 8] = block_cfLj_info;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid1_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,,)_$cp1Monoid_info" {
     GHC.Base.$fMonoid(,,,,)_$cp1Monoid_info:
         const GHC.Base.$fMonoid(,,,,)_$cp1Monoid_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cfLj() //  [R1, R2, R3]
         { []
         }
     {offset
       cfLj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfLr; else goto cfLq;
       cfLr: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       cfLq: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfLj_info" {
     block_cfLj_info:
         const _cfLj;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.359831621 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,,,,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,,,,)_$cmappend_info;
 },
 GHC.Base.$fMonoid(,,,,)_$cmappend_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cfLH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfLI; else goto cfLJ;
       cfLI: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cmappend_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfLJ: // global
           I64[Sp - 8] = block_cfLF_info;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid1_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,,)_$cmappend_info" {
     GHC.Base.$fMonoid(,,,,)_$cmappend_info:
         const GHC.Base.$fMonoid(,,,,)_$cmappend_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cfLF() //  [R1]
         { []
         }
     {offset
       cfLF: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfLF_info" {
     block_cfLF_info:
         const _cfLF;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.372272818 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,,,,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,,,,)_$cmconcat_info;
 },
 k_s8iD_entry() //  [R1]
         { []
         }
     {offset
       cfM4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfM5; else goto cfM6;
       cfM5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfM6: // global
           I64[Sp - 8] = block_cfM1_info;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid1_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . k_s8iD_info" {
     k_s8iD_info:
         const k_s8iD_entry;
         const 5;
         const 15;
 },
 _cfM1() //  [R1, R2, R3]
         { []
         }
     {offset
       cfM1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfM9; else goto cfM8;
       cfM9: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       cfM8: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfM1_info" {
     block_cfM1_info:
         const _cfM1;
         const 0;
         const 30;
 },
 k1_s8iI_entry() //  [R1]
         { []
         }
     {offset
       cfMe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfMf; else goto cfMg;
       cfMf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfMg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . k1_s8iI_info" {
     k1_s8iI_info:
         const k1_s8iI_entry;
         const 1;
         const 16;
 },
 z_s8iJ_entry() //  [R1]
         { []
         }
     {offset
       cfMl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfMm; else goto cfMn;
       cfMm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfMn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z_s8iJ_info" {
     z_s8iJ_info:
         const z_s8iJ_entry;
         const 1;
         const 16;
 },
 z1_s8iK_entry() //  [R1]
         { []
         }
     {offset
       cfMs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfMt; else goto cfMu;
       cfMt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfMu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z1_s8iK_info" {
     z1_s8iK_info:
         const z1_s8iK_entry;
         const 1;
         const 16;
 },
 z2_s8iL_entry() //  [R1]
         { []
         }
     {offset
       cfMz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfMA; else goto cfMB;
       cfMA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfMB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z2_s8iL_info" {
     z2_s8iL_info:
         const z2_s8iL_entry;
         const 1;
         const 16;
 },
 z3_s8iM_entry() //  [R1]
         { []
         }
     {offset
       cfMG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfMH; else goto cfMI;
       cfMH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfMI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z3_s8iM_info" {
     z3_s8iM_info:
         const z3_s8iM_entry;
         const 1;
         const 16;
 },
 z4_s8iN_entry() //  [R1]
         { []
         }
     {offset
       cfMN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfMO; else goto cfMP;
       cfMO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfMP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z4_s8iN_info" {
     z4_s8iN_info:
         const z4_s8iN_entry;
         const 1;
         const 16;
 },
 go_s8iP_entry() //  [R1, R2]
         { []
         }
     {offset
       cfN3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cfN4; else goto cfN5;
       cfN4: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfN5: // global
           I64[Sp - 32] = block_cfMW_info;
           _s8iP::P64 = R1;
           _s8iI::P64 = P64[R1 + 7];
           _s8iO::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s8iI::P64;
           P64[Sp - 16] = _s8iO::P64;
           P64[Sp - 8] = _s8iP::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ufNf; else goto cfMX;
       ufNf: // global
           call _cfMW(R1) args: 0, res: 0, upd: 0;
       cfMX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_s8iP_info" {
     go_s8iP_info:
         const go_s8iP_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _cfMW() //  [R1]
         { []
         }
     {offset
       cfMW: // global
           if (R1 & 7 == 1) goto cfN0; else goto cfN1;
       cfN0: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cfN1: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cfNe; else goto cfNd;
       cfNe: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfNd: // global
           _s8iS::P64 = P64[R1 + 6];
           _s8iT::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s8iT::P64;
           R3 = Hp - 24;
           R2 = _s8iS::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfMW_info" {
     block_cfMW_info:
         const _cfMW;
         const 3;
         const 30;
 },
 GHC.Base.$fMonoid(,,,,)_$cmconcat_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cfNg: // global
           Hp = Hp + 272;
           if (Hp > HpLim) (likely: False) goto cfNk; else goto cfNj;
       cfNk: // global
           HpAlloc = 272;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cmconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfNj: // global
           I64[Hp - 264] = k_s8iD_info;
           P64[Hp - 248] = R2;
           P64[Hp - 240] = R3;
           P64[Hp - 232] = R4;
           P64[Hp - 224] = R5;
           P64[Hp - 216] = R6;
           I64[Hp - 208] = k1_s8iI_info;
           P64[Hp - 192] = Hp - 264;
           I64[Hp - 184] = z_s8iJ_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = z1_s8iK_info;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = z2_s8iL_info;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = z3_s8iM_info;
           P64[Hp - 96] = R5;
           I64[Hp - 88] = z4_s8iN_info;
           P64[Hp - 72] = R6;
           I64[Hp - 64] = (,,,,)_con_info;
           P64[Hp - 56] = Hp - 184;
           P64[Hp - 48] = Hp - 160;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = go_s8iP_info;
           P64[Hp - 8] = Hp - 208;
           P64[Hp] = Hp - 63;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,,)_$cmconcat_info" {
     GHC.Base.$fMonoid(,,,,)_$cmconcat_info:
         const GHC.Base.$fMonoid(,,,,)_$cmconcat_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.403764028 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_closure" {
     GHC.Base.$fMonoid(,,,,)_closure:
         const GHC.Base.$fMonoid(,,,,)_info;
 },
 sat_s8j3_entry() //  [R1]
         { []
         }
     {offset
       cfOo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfOp; else goto cfOq;
       cfOp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfOq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cmconcat_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8j3_info" {
     sat_s8j3_info:
         const sat_s8j3_entry;
         const 5;
         const 15;
 },
 sat_s8j2_entry() //  [R1]
         { []
         }
     {offset
       cfOv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfOw; else goto cfOx;
       cfOw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfOx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cmappend_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8j2_info" {
     sat_s8j2_info:
         const sat_s8j2_entry;
         const 5;
         const 15;
 },
 sat_s8j1_entry() //  [R1]
         { []
         }
     {offset
       cfOC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfOD; else goto cfOE;
       cfOD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfOE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cmempty_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8j1_info" {
     sat_s8j1_info:
         const sat_s8j1_entry;
         const 5;
         const 15;
 },
 sat_s8j0_entry() //  [R1]
         { []
         }
     {offset
       cfOJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfOK; else goto cfOL;
       cfOK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfOL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cp1Monoid_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8j0_info" {
     sat_s8j0_info:
         const sat_s8j0_entry;
         const 5;
         const 15;
 },
 GHC.Base.$fMonoid(,,,,)_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cfON: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto cfOR; else goto cfOQ;
       cfOR: // global
           HpAlloc = 264;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfOQ: // global
           I64[Hp - 256] = sat_s8j3_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           P64[Hp - 224] = R4;
           P64[Hp - 216] = R5;
           P64[Hp - 208] = R6;
           I64[Hp - 200] = sat_s8j2_info;
           P64[Hp - 184] = R2;
           P64[Hp - 176] = R3;
           P64[Hp - 168] = R4;
           P64[Hp - 160] = R5;
           P64[Hp - 152] = R6;
           I64[Hp - 144] = sat_s8j1_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           P64[Hp - 104] = R5;
           P64[Hp - 96] = R6;
           I64[Hp - 88] = sat_s8j0_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R5;
           P64[Hp - 40] = R6;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 144;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 256;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,,)_info" {
     GHC.Base.$fMonoid(,,,,)_info:
         const GHC.Base.$fMonoid(,,,,)_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.418768747 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$c<>_closure" {
     GHC.Base.$fMonoid(,,,)_$c<>_closure:
         const GHC.Base.$fMonoid(,,,)_$c<>_info;
 },
 sat_s8jn_entry() //  [R1]
         { []
         }
     {offset
       cfPz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfPA; else goto cfPB;
       cfPA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfPB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8jn_info" {
     sat_s8jn_info:
         const sat_s8jn_entry;
         const 3;
         const 15;
 },
 sat_s8jm_entry() //  [R1]
         { []
         }
     {offset
       cfPG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfPH; else goto cfPI;
       cfPH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfPI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8jm_info" {
     sat_s8jm_info:
         const sat_s8jm_entry;
         const 3;
         const 15;
 },
 sat_s8jl_entry() //  [R1]
         { []
         }
     {offset
       cfPN: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfPO; else goto cfPP;
       cfPO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfPP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8jl_info" {
     sat_s8jl_info:
         const sat_s8jl_entry;
         const 3;
         const 15;
 },
 sat_s8jk_entry() //  [R1]
         { []
         }
     {offset
       cfPU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfPV; else goto cfPW;
       cfPV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfPW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8jk_info" {
     sat_s8jk_info:
         const sat_s8jk_entry;
         const 3;
         const 15;
 },
 GHC.Base.$fMonoid(,,,)_$c<>_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cfPX: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cfPZ; else goto cfQ0;
       cfPZ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$c<>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cfQ0: // global
           I64[Sp - 40] = block_cfPl_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufQ6; else goto cfPm;
       ufQ6: // global
           call _cfPl(R1) args: 0, res: 0, upd: 0;
       cfPm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,)_$c<>_info" {
     GHC.Base.$fMonoid(,,,)_$c<>_info:
         const GHC.Base.$fMonoid(,,,)_$c<>_entry;
         const 0;
         const 14;
         const 25769803802;
 },
 _cfPl() //  [R1]
         { []
         }
     {offset
       cfPl: // global
           I64[Sp - 24] = block_cfPq_info;
           _s8jb::P64 = P64[R1 + 7];
           _s8jc::P64 = P64[R1 + 15];
           _s8jd::P64 = P64[R1 + 23];
           _s8je::P64 = P64[R1 + 31];
           R1 = P64[Sp + 40];
           P64[Sp - 16] = _s8jd::P64;
           P64[Sp - 8] = _s8je::P64;
           P64[Sp] = _s8jc::P64;
           P64[Sp + 40] = _s8jb::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ufQ5; else goto cfPr;
       ufQ5: // global
           call _cfPq(R1) args: 0, res: 0, upd: 0;
       cfPr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfPl_info" {
     block_cfPl_info:
         const _cfPl;
         const 5;
         const 30;
 },
 _cfPq() //  [R1]
         { []
         }
     {offset
       cfPq: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto cfQ4; else goto cfQ3;
       cfQ4: // global
           HpAlloc = 200;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfQ3: // global
           _s8jg::P64 = P64[R1 + 7];
           _s8jh::P64 = P64[R1 + 15];
           _s8ji::P64 = P64[R1 + 23];
           _s8jj::P64 = P64[R1 + 31];
           I64[Hp - 192] = sat_s8jn_info;
           P64[Hp - 176] = P64[Sp + 56];
           P64[Hp - 168] = P64[Sp + 16];
           P64[Hp - 160] = _s8jj::P64;
           I64[Hp - 152] = sat_s8jm_info;
           P64[Hp - 136] = P64[Sp + 48];
           P64[Hp - 128] = P64[Sp + 8];
           P64[Hp - 120] = _s8ji::P64;
           I64[Hp - 112] = sat_s8jl_info;
           P64[Hp - 96] = P64[Sp + 40];
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = _s8jh::P64;
           I64[Hp - 72] = sat_s8jk_info;
           P64[Hp - 56] = P64[Sp + 32];
           P64[Hp - 48] = P64[Sp + 64];
           P64[Hp - 40] = _s8jg::P64;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 152;
           P64[Hp] = Hp - 192;
           R1 = Hp - 31;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfPq_info" {
     block_cfPq_info:
         const _cfPq;
         const 8;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.439530288 UTC

[section ""data" . GHC.Base.$w$csconcat2_closure" {
     GHC.Base.$w$csconcat2_closure:
         const GHC.Base.$w$csconcat2_info;
 },
 GHC.Base.$w$csconcat2_slow() //  [R1]
         { []
         }
     {offset
       cfQW: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$w$csconcat2_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2,
                                            R1) args: 40, res: 0, upd: 8;
     }
 },
 sat_s8jT_entry() //  [R1]
         { []
         }
     {offset
       cfRm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfRn; else goto cfRo;
       cfRn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfRo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8jT_info" {
     sat_s8jT_info:
         const sat_s8jT_entry;
         const 3;
         const 15;
 },
 sat_s8jS_entry() //  [R1]
         { []
         }
     {offset
       cfRt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfRu; else goto cfRv;
       cfRu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfRv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8jS_info" {
     sat_s8jS_info:
         const sat_s8jS_entry;
         const 3;
         const 15;
 },
 sat_s8jR_entry() //  [R1]
         { []
         }
     {offset
       cfRA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfRB; else goto cfRC;
       cfRB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfRC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8jR_info" {
     sat_s8jR_info:
         const sat_s8jR_entry;
         const 3;
         const 15;
 },
 sat_s8jQ_entry() //  [R1]
         { []
         }
     {offset
       cfRH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfRI; else goto cfRJ;
       cfRI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfRJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8jQ_info" {
     sat_s8jQ_info:
         const sat_s8jQ_entry;
         const 3;
         const 15;
 },
 $wgo_s8jx_entry() //  [R1, R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cfRO: // global
           if ((Sp + -88) < SpLim) (likely: False) goto cfRP; else goto cfRQ;
       cfRP: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfRQ: // global
           I64[Sp - 80] = block_cfR5_info;
           _s8jx::P64 = R1;
           _s8jo::P64 = P64[R1 + 3];
           _s8jp::P64 = P64[R1 + 11];
           _s8jq::P64 = P64[R1 + 19];
           _s8jr::P64 = P64[R1 + 27];
           R1 = R6;
           P64[Sp - 72] = _s8jo::P64;
           P64[Sp - 64] = _s8jp::P64;
           P64[Sp - 56] = _s8jq::P64;
           P64[Sp - 48] = _s8jr::P64;
           P64[Sp - 40] = _s8jx::P64;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 80;
           if (R1 & 7 != 0) goto ufRZ; else goto cfR6;
       ufRZ: // global
           call _cfR5(R1) args: 0, res: 0, upd: 0;
       cfR6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . $wgo_s8jx_info" {
     $wgo_s8jx_info:
         const $wgo_s8jx_entry;
         const 4;
         const 8;
         const 21474836505;
 },
 _cfR5() //  [R1]
         { []
         }
     {offset
       cfR5: // global
           if (R1 & 7 == 1) goto cfRL; else goto cfRM;
       cfRL: // global
           R4 = P64[Sp + 72];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 48];
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfRM: // global
           I64[Sp - 8] = block_cfRb_info;
           _s8jF::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8jF::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufRY; else goto cfRc;
       ufRY: // global
           call _cfRb(R1) args: 0, res: 0, upd: 0;
       cfRc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfR5_info" {
     block_cfR5_info:
         const _cfR5;
         const 9;
         const 30;
 },
 _cfRb() //  [R1]
         { []
         }
     {offset
       cfRb: // global
           _s8jF::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cfRg_info;
           R6 = _s8jF::P64;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 48];
           Sp = Sp + 8;
           call $wgo_s8jx_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfRb_info" {
     block_cfRb_info:
         const _cfRb;
         const 10;
         const 30;
 },
 _cfRg() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cfRg: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cfRX; else goto cfRW;
       cfRX: // global
           HpAlloc = 160;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_pppp(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       cfRW: // global
           I64[Hp - 152] = sat_s8jT_info;
           P64[Hp - 136] = P64[Sp + 32];
           P64[Hp - 128] = P64[Sp + 72];
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_s8jS_info;
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_s8jR_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 56];
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s8jQ_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R4 = Hp - 152;
           R3 = Hp - 112;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfRg_info" {
     block_cfRg_info:
         const _cfRg;
         const 1033;
         const 30;
 },
 GHC.Base.$w$csconcat2_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cfS0: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfS4; else goto cfS3;
       cfS4: // global
           HpAlloc = 40;
           R1 = GHC.Base.$w$csconcat2_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cfS3: // global
           I64[Hp - 32] = $wgo_s8jx_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _s8js::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _s8js::P64;
           R1 = Hp - 27;
           Sp = Sp + 32;
           call $wgo_s8jx_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$csconcat2_info" {
     GHC.Base.$w$csconcat2_info:
         const GHC.Base.$w$csconcat2_entry;
         const 0;
         const 14;
         const 38654705664;
         const 0;
         const 9;
         const GHC.Base.$w$csconcat2_slow;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.459942327 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,)_$csconcat_closure" {
     GHC.Base.$fSemigroup(,,,)_$csconcat_closure:
         const GHC.Base.$fSemigroup(,,,)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(,,,)_$csconcat_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { []
         }
     {offset
       cfT7: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfTi; else goto cfTj;
       cfTi: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,,)_$csconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfTj: // global
           I64[Sp - 40] = block_cfT4_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufTq; else goto cfT5;
       ufTq: // global
           call _cfT4(R1) args: 0, res: 0, upd: 0;
       cfT5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,,,)_$csconcat_info" {
     GHC.Base.$fSemigroup(,,,)_$csconcat_info:
         const GHC.Base.$fSemigroup(,,,)_$csconcat_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cfT4() //  [R1]
         { []
         }
     {offset
       cfT4: // global
           I64[Sp - 8] = block_cfTa_info;
           _s8k1::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s8k1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufTp; else goto cfTb;
       ufTp: // global
           call _cfTa(R1) args: 0, res: 0, upd: 0;
       cfTb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfT4_info" {
     block_cfT4_info:
         const _cfT4;
         const 4;
         const 30;
 },
 _cfTa() //  [R1]
         { []
         }
     {offset
       cfTa: // global
           _s8jX::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cfTf_info;
           R6 = P64[R1 + 7];
           R5 = _s8jX::P64;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           _s8k1::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 23];
           P64[Sp + 24] = P64[R1 + 31];
           P64[Sp + 32] = _s8k1::P64;
           Sp = Sp + 8;
           call GHC.Base.$w$csconcat2_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 40, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfTa_info" {
     block_cfTa_info:
         const _cfTa;
         const 5;
         const 30;
 },
 _cfTf() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cfTf: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfTo; else goto cfTn;
       cfTo: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_pppp(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       cfTn: // global
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = R1;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfTf_info" {
     block_cfTf_info:
         const _cfTf;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.472644133 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,)_$cstimes_closure" {
     GHC.Base.$fSemigroup(,,,)_$cstimes_closure:
         const GHC.Base.$fSemigroup(,,,)_$cstimes_info;
 },
 GHC.Base.$fSemigroup(,,,)_$cstimes_slow() //  [R1]
         { []
         }
     {offset
       cfTM: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$fSemigroup(,,,)_$cstimes_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s8kr_entry() //  [R1]
         { []
         }
     {offset
       cfTZ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfU0; else goto cfU1;
       cfU0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfU1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8kr_info" {
     sat_s8kr_info:
         const sat_s8kr_entry;
         const 4;
         const 15;
 },
 sat_s8kq_entry() //  [R1]
         { []
         }
     {offset
       cfU6: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfU7; else goto cfU8;
       cfU7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfU8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8kq_info" {
     sat_s8kq_info:
         const sat_s8kq_entry;
         const 4;
         const 15;
 },
 sat_s8kp_entry() //  [R1]
         { []
         }
     {offset
       cfUd: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfUe; else goto cfUf;
       cfUe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfUf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8kp_info" {
     sat_s8kp_info:
         const sat_s8kp_entry;
         const 4;
         const 15;
 },
 sat_s8ko_entry() //  [R1]
         { []
         }
     {offset
       cfUk: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfUl; else goto cfUm;
       cfUl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfUm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8ko_info" {
     sat_s8ko_info:
         const sat_s8ko_entry;
         const 4;
         const 15;
 },
 GHC.Base.$fSemigroup(,,,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cfUn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cfUp; else goto cfUq;
       cfUp: // global
           R1 = GHC.Base.$fSemigroup(,,,)_$cstimes_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cfUq: // global
           I64[Sp - 40] = block_cfTQ_info;
           R1 = P64[Sp + 8];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp + 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufUu; else goto cfTR;
       ufUu: // global
           call _cfTQ(R1) args: 0, res: 0, upd: 0;
       cfTR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,,,)_$cstimes_info" {
     GHC.Base.$fSemigroup(,,,)_$cstimes_info:
         const GHC.Base.$fSemigroup(,,,)_$cstimes_entry;
         const 0;
         const 14;
         const 30064771072;
         const 0;
         const 7;
         const GHC.Base.$fSemigroup(,,,)_$cstimes_slow;
 },
 _cfTQ() //  [R1]
         { []
         }
     {offset
       cfTQ: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cfUt; else goto cfUs;
       cfUt: // global
           HpAlloc = 232;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfUs: // global
           _s8kk::P64 = P64[R1 + 7];
           _s8kl::P64 = P64[R1 + 15];
           _s8km::P64 = P64[R1 + 23];
           _s8kn::P64 = P64[R1 + 31];
           I64[Hp - 224] = sat_s8kr_info;
           P64[Hp - 208] = P64[Sp + 24];
           _s8kg::P64 = P64[Sp + 32];
           P64[Hp - 200] = _s8kg::P64;
           _s8kh::P64 = P64[Sp + 40];
           P64[Hp - 192] = _s8kh::P64;
           P64[Hp - 184] = _s8kn::P64;
           I64[Hp - 176] = sat_s8kq_info;
           P64[Hp - 160] = P64[Sp + 16];
           P64[Hp - 152] = _s8kg::P64;
           P64[Hp - 144] = _s8kh::P64;
           P64[Hp - 136] = _s8km::P64;
           I64[Hp - 128] = sat_s8kp_info;
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = _s8kg::P64;
           P64[Hp - 96] = _s8kh::P64;
           P64[Hp - 88] = _s8kl::P64;
           I64[Hp - 80] = sat_s8ko_info;
           P64[Hp - 64] = P64[Sp + 48];
           P64[Hp - 56] = _s8kg::P64;
           P64[Hp - 48] = _s8kh::P64;
           P64[Hp - 40] = _s8kk::P64;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 80;
           P64[Hp - 16] = Hp - 128;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 224;
           R1 = Hp - 31;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfTQ_info" {
     block_cfTQ_info:
         const _cfTQ;
         const 6;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.488954671 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,)_closure" {
     GHC.Base.$fSemigroup(,,,)_closure:
         const GHC.Base.$fSemigroup(,,,)_info;
 },
 sat_s8ky_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cfVq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfVr; else goto cfVs;
       cfVr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfVs: // global
           R6 = R2;
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 16;
           call GHC.Base.$fSemigroup(,,,)_$cstimes_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8ky_info" {
     sat_s8ky_info:
         const sat_s8ky_entry;
         const 4;
         const 8;
         const 12884901911;
 },
 sat_s8kx_entry() //  [R1, R2]
         { []
         }
     {offset
       cfVy: // global
           R6 = R2;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(,,,)_$csconcat_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8kx_info" {
     sat_s8kx_info:
         const sat_s8kx_entry;
         const 4;
         const 8;
         const 4294967301;
 },
 sat_s8kw_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cfVG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfVH; else goto cfVI;
       cfVH: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfVI: // global
           R6 = R2;
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,)_$c<>_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8kw_info" {
     sat_s8kw_info:
         const sat_s8kw_entry;
         const 4;
         const 8;
         const 8589934607;
 },
 GHC.Base.$fSemigroup(,,,)_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cfVK: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cfVO; else goto cfVN;
       cfVO: // global
           HpAlloc = 152;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,,)_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfVN: // global
           I64[Hp - 144] = sat_s8ky_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           P64[Hp - 112] = R5;
           I64[Hp - 104] = sat_s8kx_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           P64[Hp - 72] = R5;
           I64[Hp - 64] = sat_s8kw_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 62;
           P64[Hp - 8] = Hp - 103;
           P64[Hp] = Hp - 141;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,,,)_info" {
     GHC.Base.$fSemigroup(,,,)_info:
         const GHC.Base.$fSemigroup(,,,)_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.508704585 UTC

[section ""data" . GHC.Base.$w$cp1Monoid_closure" {
     GHC.Base.$w$cp1Monoid_closure:
         const GHC.Base.$w$cp1Monoid_info;
 },
 w4_s8l1_entry() //  [R1]
         { []
         }
     {offset
       cfWg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWh; else goto cfWi;
       cfWh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . w4_s8l1_info" {
     w4_s8l1_info:
         const w4_s8l1_entry;
         const 1;
         const 16;
 },
 w5_s8l2_entry() //  [R1]
         { []
         }
     {offset
       cfWn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWo; else goto cfWp;
       cfWo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . w5_s8l2_info" {
     w5_s8l2_info:
         const w5_s8l2_entry;
         const 1;
         const 16;
 },
 w6_s8l3_entry() //  [R1]
         { []
         }
     {offset
       cfWu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWv; else goto cfWw;
       cfWv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . w6_s8l3_info" {
     w6_s8l3_info:
         const w6_s8l3_entry;
         const 1;
         const 16;
 },
 w7_s8l4_entry() //  [R1]
         { []
         }
     {offset
       cfWB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfWC; else goto cfWD;
       cfWC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . w7_s8l4_info" {
     w7_s8l4_info:
         const w7_s8l4_entry;
         const 1;
         const 16;
 },
 sat_s8lg_entry() //  [R1]
         { []
         }
     {offset
       cfWS: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfWT; else goto cfWU;
       cfWT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfWU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8lg_info" {
     sat_s8lg_info:
         const sat_s8lg_entry;
         const 4;
         const 15;
 },
 sat_s8lf_entry() //  [R1]
         { []
         }
     {offset
       cfWZ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfX0; else goto cfX1;
       cfX0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfX1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8lf_info" {
     sat_s8lf_info:
         const sat_s8lf_entry;
         const 4;
         const 15;
 },
 sat_s8le_entry() //  [R1]
         { []
         }
     {offset
       cfX6: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfX7; else goto cfX8;
       cfX7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfX8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8le_info" {
     sat_s8le_info:
         const sat_s8le_entry;
         const 4;
         const 15;
 },
 sat_s8ld_entry() //  [R1]
         { []
         }
     {offset
       cfXd: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfXe; else goto cfXf;
       cfXe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfXf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8ld_info" {
     sat_s8ld_info:
         const sat_s8ld_entry;
         const 4;
         const 15;
 },
 sat_s8lh_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cfXg: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cfXi; else goto cfXj;
       cfXi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfXj: // global
           I64[Sp - 56] = block_cfWJ_info;
           _s8l1::P64 = P64[R1 + 5];
           _s8l2::P64 = P64[R1 + 13];
           _s8l3::P64 = P64[R1 + 21];
           _s8l4::P64 = P64[R1 + 29];
           R1 = R4;
           P64[Sp - 48] = _s8l1::P64;
           P64[Sp - 40] = _s8l2::P64;
           P64[Sp - 32] = _s8l3::P64;
           P64[Sp - 24] = _s8l4::P64;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ufXn; else goto cfWK;
       ufXn: // global
           call _cfWJ(R1) args: 0, res: 0, upd: 0;
       cfWK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8lh_info" {
     sat_s8lh_info:
         const sat_s8lh_entry;
         const 4;
         const 8;
         const 12884901911;
 },
 _cfWJ() //  [R1]
         { []
         }
     {offset
       cfWJ: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cfXm; else goto cfXl;
       cfXm: // global
           HpAlloc = 232;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cfXl: // global
           _s8l9::P64 = P64[R1 + 7];
           _s8la::P64 = P64[R1 + 15];
           _s8lb::P64 = P64[R1 + 23];
           _s8lc::P64 = P64[R1 + 31];
           I64[Hp - 224] = sat_s8lg_info;
           P64[Hp - 208] = P64[Sp + 8];
           _s8l5::P64 = P64[Sp + 40];
           P64[Hp - 200] = _s8l5::P64;
           _s8l6::P64 = P64[Sp + 48];
           P64[Hp - 192] = _s8l6::P64;
           P64[Hp - 184] = _s8lc::P64;
           I64[Hp - 176] = sat_s8lf_info;
           P64[Hp - 160] = P64[Sp + 16];
           P64[Hp - 152] = _s8l5::P64;
           P64[Hp - 144] = _s8l6::P64;
           P64[Hp - 136] = _s8lb::P64;
           I64[Hp - 128] = sat_s8le_info;
           P64[Hp - 112] = P64[Sp + 24];
           P64[Hp - 104] = _s8l5::P64;
           P64[Hp - 96] = _s8l6::P64;
           P64[Hp - 88] = _s8la::P64;
           I64[Hp - 80] = sat_s8ld_info;
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = _s8l5::P64;
           P64[Hp - 48] = _s8l6::P64;
           P64[Hp - 40] = _s8l9::P64;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 80;
           P64[Hp - 16] = Hp - 128;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 224;
           R1 = Hp - 31;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfWJ_info" {
     block_cfWJ_info:
         const _cfWJ;
         const 6;
         const 30;
 },
 w4_s8kI_entry() //  [R1]
         { []
         }
     {offset
       cfXs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfXt; else goto cfXu;
       cfXt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfXu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . w4_s8kI_info" {
     w4_s8kI_info:
         const w4_s8kI_entry;
         const 1;
         const 16;
 },
 w5_s8kJ_entry() //  [R1]
         { []
         }
     {offset
       cfXz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfXA; else goto cfXB;
       cfXA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfXB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . w5_s8kJ_info" {
     w5_s8kJ_info:
         const w5_s8kJ_entry;
         const 1;
         const 16;
 },
 w6_s8kK_entry() //  [R1]
         { []
         }
     {offset
       cfXG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfXH; else goto cfXI;
       cfXH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfXI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . w6_s8kK_info" {
     w6_s8kK_info:
         const w6_s8kK_entry;
         const 1;
         const 16;
 },
 w7_s8kL_entry() //  [R1]
         { []
         }
     {offset
       cfXN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfXO; else goto cfXP;
       cfXO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfXP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . w7_s8kL_info" {
     w7_s8kL_info:
         const w7_s8kL_entry;
         const 1;
         const 16;
 },
 sat_s8l0_entry() //  [R1, R2]
         { []
         }
     {offset
       cfXY: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cfY9; else goto cfYa;
       cfY9: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cfYa: // global
           I64[Sp - 40] = block_cfXV_info;
           _s8kI::P64 = P64[R1 + 7];
           _s8kJ::P64 = P64[R1 + 15];
           _s8kK::P64 = P64[R1 + 23];
           _s8kL::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _s8kI::P64;
           P64[Sp - 24] = _s8kJ::P64;
           P64[Sp - 16] = _s8kK::P64;
           P64[Sp - 8] = _s8kL::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ufYh; else goto cfXW;
       ufYh: // global
           call _cfXV(R1) args: 0, res: 0, upd: 0;
       cfXW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8l0_info" {
     sat_s8l0_info:
         const sat_s8l0_entry;
         const 4;
         const 8;
         const 4294967301;
 },
 _cfXV() //  [R1]
         { []
         }
     {offset
       cfXV: // global
           I64[Sp - 8] = block_cfY1_info;
           _s8kP::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s8kP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ufYg; else goto cfY2;
       ufYg: // global
           call _cfY1(R1) args: 0, res: 0, upd: 0;
       cfY2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfXV_info" {
     block_cfXV_info:
         const _cfXV;
         const 4;
         const 30;
 },
 _cfY1() //  [R1]
         { []
         }
     {offset
       cfY1: // global
           _s8kL::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cfY6_info;
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 32];
           R2 = _s8kL::P64;
           _s8kP::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 23];
           P64[Sp + 24] = P64[R1 + 31];
           P64[Sp + 32] = _s8kP::P64;
           Sp = Sp + 8;
           call GHC.Base.$w$csconcat2_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 40, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cfY1_info" {
     block_cfY1_info:
         const _cfY1;
         const 5;
         const 30;
 },
 _cfY6() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cfY6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cfYf; else goto cfYe;
       cfYf: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_pppp(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       cfYe: // global
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = R1;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cfY6_info" {
     block_cfY6_info:
         const _cfY6;
         const 0;
         const 30;
 },
 sat_s8kG_entry() //  [R1]
         { []
         }
     {offset
       cfYm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYn; else goto cfYo;
       cfYn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8kG_info" {
     sat_s8kG_info:
         const sat_s8kG_entry;
         const 1;
         const 16;
 },
 sat_s8kF_entry() //  [R1]
         { []
         }
     {offset
       cfYt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYu; else goto cfYv;
       cfYu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8kF_info" {
     sat_s8kF_info:
         const sat_s8kF_entry;
         const 1;
         const 16;
 },
 sat_s8kE_entry() //  [R1]
         { []
         }
     {offset
       cfYA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYB; else goto cfYC;
       cfYB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8kE_info" {
     sat_s8kE_info:
         const sat_s8kE_entry;
         const 1;
         const 16;
 },
 sat_s8kD_entry() //  [R1]
         { []
         }
     {offset
       cfYH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cfYI; else goto cfYJ;
       cfYI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cfYJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8kD_info" {
     sat_s8kD_info:
         const sat_s8kD_entry;
         const 1;
         const 16;
 },
 sat_s8kH_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cfYP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cfYQ; else goto cfYR;
       cfYQ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYR: // global
           R6 = R2;
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,)_$c<>_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8kH_info" {
     sat_s8kH_info:
         const sat_s8kH_entry;
         const 4;
         const 8;
         const 8589934607;
 },
 GHC.Base.$w$cp1Monoid_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cfYS: // global
           Hp = Hp + 408;
           if (Hp > HpLim) (likely: False) goto cfYW; else goto cfYV;
       cfYW: // global
           HpAlloc = 408;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$cp1Monoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cfYV: // global
           I64[Hp - 400] = w4_s8l1_info;
           P64[Hp - 384] = R5;
           I64[Hp - 376] = w5_s8l2_info;
           P64[Hp - 360] = R4;
           I64[Hp - 352] = w6_s8l3_info;
           P64[Hp - 336] = R3;
           I64[Hp - 328] = w7_s8l4_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_s8lh_info;
           P64[Hp - 296] = Hp - 400;
           P64[Hp - 288] = Hp - 376;
           P64[Hp - 280] = Hp - 352;
           P64[Hp - 272] = Hp - 328;
           I64[Hp - 264] = w4_s8kI_info;
           P64[Hp - 248] = R5;
           I64[Hp - 240] = w5_s8kJ_info;
           P64[Hp - 224] = R4;
           I64[Hp - 216] = w6_s8kK_info;
           P64[Hp - 200] = R3;
           I64[Hp - 192] = w7_s8kL_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_s8l0_info;
           P64[Hp - 160] = Hp - 264;
           P64[Hp - 152] = Hp - 240;
           P64[Hp - 144] = Hp - 216;
           P64[Hp - 136] = Hp - 192;
           I64[Hp - 128] = sat_s8kG_info;
           P64[Hp - 112] = R5;
           I64[Hp - 104] = sat_s8kF_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = sat_s8kE_info;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_s8kD_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s8kH_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R3 = Hp - 301;
           R2 = Hp - 167;
           R1 = Hp - 30;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$cp1Monoid_info" {
     GHC.Base.$w$cp1Monoid_info:
         const GHC.Base.$w$cp1Monoid_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.55282434 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,,,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,,,)_$cp1Monoid_info;
 },
 GHC.Base.$fMonoid(,,,)_$cp1Monoid_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cg1d: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg1e; else goto cg1f;
       cg1e: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1f: // global
           I64[Sp - 8] = block_cg1a_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,)_$cp1Monoid_info" {
     GHC.Base.$fMonoid(,,,)_$cp1Monoid_info:
         const GHC.Base.$fMonoid(,,,)_$cp1Monoid_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _cg1a() //  [R1, R2, R3]
         { []
         }
     {offset
       cg1a: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg1i; else goto cg1h;
       cg1i: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       cg1h: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cg1a_info" {
     block_cg1a_info:
         const _cg1a;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.558908289 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,,,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,,,)_$cmappend_info;
 },
 GHC.Base.$fMonoid(,,,)_$cmappend_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cg1y: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg1z; else goto cg1A;
       cg1z: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cmappend_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg1A: // global
           I64[Sp - 8] = block_cg1w_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,)_$cmappend_info" {
     GHC.Base.$fMonoid(,,,)_$cmappend_info:
         const GHC.Base.$fMonoid(,,,)_$cmappend_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _cg1w() //  [R1]
         { []
         }
     {offset
       cg1w: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cg1w_info" {
     block_cg1w_info:
         const _cg1w;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.568970024 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,,,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,,,)_$cmconcat_info;
 },
 k_s8lC_entry() //  [R1]
         { []
         }
     {offset
       cg1V: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cg1W; else goto cg1X;
       cg1W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg1X: // global
           I64[Sp - 8] = block_cg1S_info;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . k_s8lC_info" {
     k_s8lC_info:
         const k_s8lC_entry;
         const 4;
         const 15;
 },
 _cg1S() //  [R1, R2, R3]
         { []
         }
     {offset
       cg1S: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg20; else goto cg1Z;
       cg20: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       cg1Z: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cg1S_info" {
     block_cg1S_info:
         const _cg1S;
         const 0;
         const 30;
 },
 k1_s8lH_entry() //  [R1]
         { []
         }
     {offset
       cg25: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg26; else goto cg27;
       cg26: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg27: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . k1_s8lH_info" {
     k1_s8lH_info:
         const k1_s8lH_entry;
         const 1;
         const 16;
 },
 z_s8lI_entry() //  [R1]
         { []
         }
     {offset
       cg2c: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2d; else goto cg2e;
       cg2d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z_s8lI_info" {
     z_s8lI_info:
         const z_s8lI_entry;
         const 1;
         const 16;
 },
 z1_s8lJ_entry() //  [R1]
         { []
         }
     {offset
       cg2j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2k; else goto cg2l;
       cg2k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z1_s8lJ_info" {
     z1_s8lJ_info:
         const z1_s8lJ_entry;
         const 1;
         const 16;
 },
 z2_s8lK_entry() //  [R1]
         { []
         }
     {offset
       cg2q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2r; else goto cg2s;
       cg2r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z2_s8lK_info" {
     z2_s8lK_info:
         const z2_s8lK_entry;
         const 1;
         const 16;
 },
 z3_s8lL_entry() //  [R1]
         { []
         }
     {offset
       cg2x: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg2y; else goto cg2z;
       cg2y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg2z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z3_s8lL_info" {
     z3_s8lL_info:
         const z3_s8lL_entry;
         const 1;
         const 16;
 },
 go_s8lN_entry() //  [R1, R2]
         { []
         }
     {offset
       cg2N: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cg2O; else goto cg2P;
       cg2O: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cg2P: // global
           I64[Sp - 32] = block_cg2G_info;
           _s8lN::P64 = R1;
           _s8lH::P64 = P64[R1 + 7];
           _s8lM::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _s8lH::P64;
           P64[Sp - 16] = _s8lM::P64;
           P64[Sp - 8] = _s8lN::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug2Z; else goto cg2H;
       ug2Z: // global
           call _cg2G(R1) args: 0, res: 0, upd: 0;
       cg2H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_s8lN_info" {
     go_s8lN_info:
         const go_s8lN_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _cg2G() //  [R1]
         { []
         }
     {offset
       cg2G: // global
           if (R1 & 7 == 1) goto cg2K; else goto cg2L;
       cg2K: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cg2L: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg2Y; else goto cg2X;
       cg2Y: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg2X: // global
           _s8lQ::P64 = P64[R1 + 6];
           _s8lR::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _s8lR::P64;
           R3 = Hp - 24;
           R2 = _s8lQ::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cg2G_info" {
     block_cg2G_info:
         const _cg2G;
         const 3;
         const 30;
 },
 GHC.Base.$fMonoid(,,,)_$cmconcat_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cg30: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cg34; else goto cg33;
       cg34: // global
           HpAlloc = 232;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cmconcat_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg33: // global
           I64[Hp - 224] = k_s8lC_info;
           P64[Hp - 208] = R2;
           P64[Hp - 200] = R3;
           P64[Hp - 192] = R4;
           P64[Hp - 184] = R5;
           I64[Hp - 176] = k1_s8lH_info;
           P64[Hp - 160] = Hp - 224;
           I64[Hp - 152] = z_s8lI_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = z1_s8lJ_info;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = z2_s8lK_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = z3_s8lL_info;
           P64[Hp - 64] = R5;
           I64[Hp - 56] = (,,,)_con_info;
           P64[Hp - 48] = Hp - 152;
           P64[Hp - 40] = Hp - 128;
           P64[Hp - 32] = Hp - 104;
           P64[Hp - 24] = Hp - 80;
           I64[Hp - 16] = go_s8lN_info;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,)_$cmconcat_info" {
     GHC.Base.$fMonoid(,,,)_$cmconcat_info:
         const GHC.Base.$fMonoid(,,,)_$cmconcat_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.591494251 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_closure" {
     GHC.Base.$fMonoid(,,,)_closure:
         const GHC.Base.$fMonoid(,,,)_info;
 },
 sat_s8m0_entry() //  [R1]
         { []
         }
     {offset
       cg43: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg44; else goto cg45;
       cg44: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg45: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cmconcat_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8m0_info" {
     sat_s8m0_info:
         const sat_s8m0_entry;
         const 4;
         const 15;
 },
 sat_s8lZ_entry() //  [R1]
         { []
         }
     {offset
       cg4a: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg4b; else goto cg4c;
       cg4b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg4c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cmappend_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8lZ_info" {
     sat_s8lZ_info:
         const sat_s8lZ_entry;
         const 4;
         const 15;
 },
 sat_s8lY_entry() //  [R1]
         { []
         }
     {offset
       cg4h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg4i; else goto cg4j;
       cg4i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg4j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cmempty_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8lY_info" {
     sat_s8lY_info:
         const sat_s8lY_entry;
         const 4;
         const 15;
 },
 sat_s8lX_entry() //  [R1]
         { []
         }
     {offset
       cg4o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cg4p; else goto cg4q;
       cg4p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg4q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cp1Monoid_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8lX_info" {
     sat_s8lX_info:
         const sat_s8lX_entry;
         const 4;
         const 15;
 },
 GHC.Base.$fMonoid(,,,)_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cg4s: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto cg4w; else goto cg4v;
       cg4w: // global
           HpAlloc = 232;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg4v: // global
           I64[Hp - 224] = sat_s8m0_info;
           P64[Hp - 208] = R2;
           P64[Hp - 200] = R3;
           P64[Hp - 192] = R4;
           P64[Hp - 184] = R5;
           I64[Hp - 176] = sat_s8lZ_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           P64[Hp - 136] = R5;
           I64[Hp - 128] = sat_s8lY_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           P64[Hp - 88] = R5;
           I64[Hp - 80] = sat_s8lX_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 80;
           P64[Hp - 16] = Hp - 128;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 224;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,)_info" {
     GHC.Base.$fMonoid(,,,)_info:
         const GHC.Base.$fMonoid(,,,)_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.605391876 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$c<>_closure" {
     GHC.Base.$fMonoid(,,)_$c<>_closure:
         const GHC.Base.$fMonoid(,,)_$c<>_info;
 },
 sat_s8mg_entry() //  [R1]
         { []
         }
     {offset
       cg5e: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg5f; else goto cg5g;
       cg5f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8mg_info" {
     sat_s8mg_info:
         const sat_s8mg_entry;
         const 3;
         const 15;
 },
 sat_s8mf_entry() //  [R1]
         { []
         }
     {offset
       cg5l: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg5m; else goto cg5n;
       cg5m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8mf_info" {
     sat_s8mf_info:
         const sat_s8mf_entry;
         const 3;
         const 15;
 },
 sat_s8me_entry() //  [R1]
         { []
         }
     {offset
       cg5s: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg5t; else goto cg5u;
       cg5t: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg5u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8me_info" {
     sat_s8me_info:
         const sat_s8me_entry;
         const 3;
         const 15;
 },
 GHC.Base.$fMonoid(,,)_$c<>_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cg5v: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg5x; else goto cg5y;
       cg5x: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$c<>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg5y: // global
           I64[Sp - 40] = block_cg50_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug5E; else goto cg51;
       ug5E: // global
           call _cg50(R1) args: 0, res: 0, upd: 0;
       cg51: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,)_$c<>_info" {
     GHC.Base.$fMonoid(,,)_$c<>_info:
         const GHC.Base.$fMonoid(,,)_$c<>_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cg50() //  [R1]
         { []
         }
     {offset
       cg50: // global
           I64[Sp - 16] = block_cg55_info;
           _s8m7::P64 = P64[R1 + 7];
           _s8m8::P64 = P64[R1 + 15];
           _s8m9::P64 = P64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 8] = _s8m9::P64;
           P64[Sp] = _s8m8::P64;
           P64[Sp + 32] = _s8m7::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ug5D; else goto cg56;
       ug5D: // global
           call _cg55(R1) args: 0, res: 0, upd: 0;
       cg56: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cg50_info" {
     block_cg50_info:
         const _cg50;
         const 4;
         const 30;
 },
 _cg55() //  [R1]
         { []
         }
     {offset
       cg55: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cg5C; else goto cg5B;
       cg5C: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg5B: // global
           _s8mb::P64 = P64[R1 + 7];
           _s8mc::P64 = P64[R1 + 15];
           _s8md::P64 = P64[R1 + 23];
           I64[Hp - 144] = sat_s8mg_info;
           P64[Hp - 128] = P64[Sp + 40];
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _s8md::P64;
           I64[Hp - 104] = sat_s8mf_info;
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _s8mc::P64;
           I64[Hp - 64] = sat_s8me_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _s8mb::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 64;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 144;
           R1 = Hp - 23;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cg55_info" {
     block_cg55_info:
         const _cg55;
         const 6;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.622647673 UTC

[section ""data" . GHC.Base.$w$csconcat1_closure" {
     GHC.Base.$w$csconcat1_closure:
         const GHC.Base.$w$csconcat1_info;
 },
 GHC.Base.$w$csconcat1_slow() //  [R1]
         { []
         }
     {offset
       cg6l: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$w$csconcat1_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2,
                                            R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_s8mG_entry() //  [R1]
         { []
         }
     {offset
       cg6L: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6M; else goto cg6N;
       cg6M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6N: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8mG_info" {
     sat_s8mG_info:
         const sat_s8mG_entry;
         const 3;
         const 15;
 },
 sat_s8mF_entry() //  [R1]
         { []
         }
     {offset
       cg6S: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg6T; else goto cg6U;
       cg6T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg6U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8mF_info" {
     sat_s8mF_info:
         const sat_s8mF_entry;
         const 3;
         const 15;
 },
 sat_s8mE_entry() //  [R1]
         { []
         }
     {offset
       cg6Z: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg70; else goto cg71;
       cg70: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg71: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8mE_info" {
     sat_s8mE_info:
         const sat_s8mE_entry;
         const 3;
         const 15;
 },
 $wgo_s8mo_entry() //  [R1, R2, R3, R4, R5]
         { []
         }
     {offset
       cg76: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cg77; else goto cg78;
       cg77: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg78: // global
           I64[Sp - 64] = block_cg6u_info;
           _s8mo::P64 = R1;
           _s8mh::P64 = P64[R1 + 4];
           _s8mi::P64 = P64[R1 + 12];
           _s8mj::P64 = P64[R1 + 20];
           R1 = R5;
           P64[Sp - 56] = _s8mh::P64;
           P64[Sp - 48] = _s8mi::P64;
           P64[Sp - 40] = _s8mj::P64;
           P64[Sp - 32] = _s8mo::P64;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ug7h; else goto cg6v;
       ug7h: // global
           call _cg6u(R1) args: 0, res: 0, upd: 0;
       cg6v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . $wgo_s8mo_info" {
     $wgo_s8mo_info:
         const $wgo_s8mo_entry;
         const 3;
         const 8;
         const 17179869208;
 },
 _cg6u() //  [R1]
         { []
         }
     {offset
       cg6u: // global
           if (R1 & 7 == 1) goto cg73; else goto cg74;
       cg73: // global
           R3 = P64[Sp + 56];
           R2 = P64[Sp + 48];
           R1 = P64[Sp + 40];
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       cg74: // global
           I64[Sp - 8] = block_cg6A_info;
           _s8mv::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _s8mv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug7g; else goto cg6B;
       ug7g: // global
           call _cg6A(R1) args: 0, res: 0, upd: 0;
       cg6B: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cg6u_info" {
     block_cg6u_info:
         const _cg6u;
         const 7;
         const 30;
 },
 _cg6A() //  [R1]
         { []
         }
     {offset
       cg6A: // global
           _s8mv::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cg6F_info;
           R5 = _s8mv::P64;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 40];
           Sp = Sp + 8;
           call $wgo_s8mo_entry(R5, R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cg6A_info" {
     block_cg6A_info:
         const _cg6A;
         const 8;
         const 30;
 },
 _cg6F() //  [R1, R2, R3]
         { []
         }
     {offset
       cg6F: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cg7f; else goto cg7e;
       cg7f: // global
           HpAlloc = 120;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       cg7e: // global
           I64[Hp - 112] = sat_s8mG_info;
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 56];
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_s8mF_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 48];
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_s8mE_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R3 = Hp - 112;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cg6F_info" {
     block_cg6F_info:
         const _cg6F;
         const 519;
         const 30;
 },
 GHC.Base.$w$csconcat1_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cg7i: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg7m; else goto cg7l;
       cg7m: // global
           HpAlloc = 32;
           R1 = GHC.Base.$w$csconcat1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cg7l: // global
           I64[Hp - 24] = $wgo_s8mo_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           _s8mk::P64 = R5;
           R5 = P64[Sp + 8];
           R4 = P64[Sp];
           R3 = R6;
           R2 = _s8mk::P64;
           R1 = Hp - 20;
           Sp = Sp + 16;
           call $wgo_s8mo_entry(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$csconcat1_info" {
     GHC.Base.$w$csconcat1_info:
         const GHC.Base.$w$csconcat1_entry;
         const 0;
         const 14;
         const 30064771072;
         const 0;
         const 7;
         const GHC.Base.$w$csconcat1_slow;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.641408962 UTC

[section ""data" . GHC.Base.$fSemigroup(,,)_$csconcat_closure" {
     GHC.Base.$fSemigroup(,,)_$csconcat_closure:
         const GHC.Base.$fSemigroup(,,)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(,,)_$csconcat_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cg8h: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg8s; else goto cg8t;
       cg8s: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,)_$csconcat_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg8t: // global
           I64[Sp - 32] = block_cg8e_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ug8A; else goto cg8f;
       ug8A: // global
           call _cg8e(R1) args: 0, res: 0, upd: 0;
       cg8f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,,)_$csconcat_info" {
     GHC.Base.$fSemigroup(,,)_$csconcat_info:
         const GHC.Base.$fSemigroup(,,)_$csconcat_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _cg8e() //  [R1]
         { []
         }
     {offset
       cg8e: // global
           I64[Sp - 8] = block_cg8k_info;
           _s8mN::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _s8mN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ug8z; else goto cg8l;
       ug8z: // global
           call _cg8k(R1) args: 0, res: 0, upd: 0;
       cg8l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cg8e_info" {
     block_cg8e_info:
         const _cg8e;
         const 3;
         const 30;
 },
 _cg8k() //  [R1]
         { []
         }
     {offset
       cg8k: // global
           _s8mJ::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_cg8p_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = _s8mJ::P64;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 23];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat1_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cg8k_info" {
     block_cg8k_info:
         const _cg8k;
         const 4;
         const 30;
 },
 _cg8p() //  [R1, R2, R3]
         { []
         }
     {offset
       cg8p: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cg8y; else goto cg8x;
       cg8y: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       cg8x: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cg8p_info" {
     block_cg8p_info:
         const _cg8p;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.653795224 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,,)_$cmappend_info;
 },
 sat_s8ne_entry() //  [R1]
         { []
         }
     {offset
       cg9e: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9f; else goto cg9g;
       cg9f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9g: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg9c_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8ne_info" {
     sat_s8ne_info:
         const sat_s8ne_entry;
         const 3;
         const 15;
 },
 _cg9c() //  [R1]
         { []
         }
     {offset
       cg9c: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cg9c_info" {
     block_cg9c_info:
         const _cg9c;
         const 2;
         const 30;
 },
 sat_s8nc_entry() //  [R1]
         { []
         }
     {offset
       cg9q: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9r; else goto cg9s;
       cg9r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg9o_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8nc_info" {
     sat_s8nc_info:
         const sat_s8nc_entry;
         const 3;
         const 15;
 },
 _cg9o() //  [R1]
         { []
         }
     {offset
       cg9o: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cg9o_info" {
     block_cg9o_info:
         const _cg9o;
         const 2;
         const 30;
 },
 sat_s8na_entry() //  [R1]
         { []
         }
     {offset
       cg9C: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cg9D; else goto cg9E;
       cg9D: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cg9E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cg9A_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8na_info" {
     sat_s8na_info:
         const sat_s8na_entry;
         const 3;
         const 15;
 },
 _cg9A() //  [R1]
         { []
         }
     {offset
       cg9A: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cg9A_info" {
     block_cg9A_info:
         const _cg9A;
         const 2;
         const 30;
 },
 GHC.Base.$fMonoid(,,)_$cmappend_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cg9I: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cg9K; else goto cg9L;
       cg9K: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cmappend_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cg9L: // global
           I64[Sp - 40] = block_cg8Y_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ug9R; else goto cg8Z;
       ug9R: // global
           call _cg8Y(R1) args: 0, res: 0, upd: 0;
       cg8Z: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,)_$cmappend_info" {
     GHC.Base.$fMonoid(,,)_$cmappend_info:
         const GHC.Base.$fMonoid(,,)_$cmappend_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cg8Y() //  [R1]
         { []
         }
     {offset
       cg8Y: // global
           I64[Sp - 16] = block_cg93_info;
           _s8n2::P64 = P64[R1 + 7];
           _s8n3::P64 = P64[R1 + 15];
           _s8n4::P64 = P64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 8] = _s8n4::P64;
           P64[Sp] = _s8n3::P64;
           P64[Sp + 32] = _s8n2::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ug9Q; else goto cg94;
       ug9Q: // global
           call _cg93(R1) args: 0, res: 0, upd: 0;
       cg94: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cg8Y_info" {
     block_cg8Y_info:
         const _cg8Y;
         const 4;
         const 30;
 },
 _cg93() //  [R1]
         { []
         }
     {offset
       cg93: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cg9P; else goto cg9O;
       cg9P: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cg9O: // global
           _s8n6::P64 = P64[R1 + 7];
           _s8n7::P64 = P64[R1 + 15];
           _s8n8::P64 = P64[R1 + 23];
           I64[Hp - 144] = sat_s8ne_info;
           P64[Hp - 128] = P64[Sp + 40];
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _s8n8::P64;
           I64[Hp - 104] = sat_s8nc_info;
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _s8n7::P64;
           I64[Hp - 64] = sat_s8na_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _s8n6::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 64;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 144;
           R1 = Hp - 23;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cg93_info" {
     block_cg93_info:
         const _cg93;
         const 6;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.676916207 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,,)_$cmconcat_info;
 },
 $dSemigroup_s8nj_entry() //  [R1]
         { []
         }
     {offset
       cgaO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgaP; else goto cgaQ;
       cgaP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgaQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dSemigroup_s8nj_info" {
     $dSemigroup_s8nj_info:
         const $dSemigroup_s8nj_entry;
         const 1;
         const 16;
 },
 $dSemigroup1_s8nk_entry() //  [R1]
         { []
         }
     {offset
       cgaV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgaW; else goto cgaX;
       cgaW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgaX: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dSemigroup1_s8nk_info" {
     $dSemigroup1_s8nk_info:
         const $dSemigroup1_s8nk_entry;
         const 1;
         const 16;
 },
 $dSemigroup2_s8nl_entry() //  [R1]
         { []
         }
     {offset
       cgb2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgb3; else goto cgb4;
       cgb3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgb4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dSemigroup2_s8nl_info" {
     $dSemigroup2_s8nl_info:
         const $dSemigroup2_s8nl_entry;
         const 1;
         const 16;
 },
 z_s8nm_entry() //  [R1]
         { []
         }
     {offset
       cgb9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgba; else goto cgbb;
       cgba: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z_s8nm_info" {
     z_s8nm_info:
         const z_s8nm_entry;
         const 1;
         const 16;
 },
 z1_s8nn_entry() //  [R1]
         { []
         }
     {offset
       cgbg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbh; else goto cgbi;
       cgbh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z1_s8nn_info" {
     z1_s8nn_info:
         const z1_s8nn_entry;
         const 1;
         const 16;
 },
 z2_s8no_entry() //  [R1]
         { []
         }
     {offset
       cgbn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgbo; else goto cgbp;
       cgbo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z2_s8no_info" {
     z2_s8no_info:
         const z2_s8no_entry;
         const 1;
         const 16;
 },
 sat_s8nF_entry() //  [R1]
         { []
         }
     {offset
       cgbP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbQ; else goto cgbR;
       cgbQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8nF_info" {
     sat_s8nF_info:
         const sat_s8nF_entry;
         const 3;
         const 15;
 },
 sat_s8nE_entry() //  [R1]
         { []
         }
     {offset
       cgbW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgbX; else goto cgbY;
       cgbX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgbY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8nE_info" {
     sat_s8nE_info:
         const sat_s8nE_entry;
         const 3;
         const 15;
 },
 sat_s8nD_entry() //  [R1]
         { []
         }
     {offset
       cgc3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgc4; else goto cgc5;
       cgc4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgc5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8nD_info" {
     sat_s8nD_info:
         const sat_s8nD_entry;
         const 3;
         const 15;
 },
 go_s8nq_entry() //  [R1, R2]
         { []
         }
     {offset
       cgca: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cgcb; else goto cgcc;
       cgcb: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgcc: // global
           I64[Sp - 48] = block_cgbw_info;
           _s8nq::P64 = R1;
           _s8nj::P64 = P64[R1 + 7];
           _s8nk::P64 = P64[R1 + 15];
           _s8nl::P64 = P64[R1 + 23];
           _s8np::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 40] = _s8nj::P64;
           P64[Sp - 32] = _s8nk::P64;
           P64[Sp - 24] = _s8nl::P64;
           P64[Sp - 16] = _s8np::P64;
           P64[Sp - 8] = _s8nq::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ugcm; else goto cgbx;
       ugcm: // global
           call _cgbw(R1) args: 0, res: 0, upd: 0;
       cgbx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_s8nq_info" {
     go_s8nq_info:
         const go_s8nq_entry;
         const 4;
         const 8;
         const 4294967301;
 },
 _cgbw() //  [R1]
         { []
         }
     {offset
       cgbw: // global
           if (R1 & 7 == 1) goto cgc7; else goto cgc8;
       cgc7: // global
           R1 = P64[Sp + 32];
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgc8: // global
           I64[Sp] = block_cgbC_info;
           _s8nu::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 32] = _s8nu::P64;
           if (R1 & 7 != 0) goto ugcl; else goto cgbD;
       ugcl: // global
           call _cgbC(R1) args: 0, res: 0, upd: 0;
       cgbD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cgbw_info" {
     block_cgbw_info:
         const _cgbw;
         const 5;
         const 30;
 },
 _cgbC() //  [R1]
         { []
         }
     {offset
       cgbC: // global
           I64[Sp - 8] = block_cgbH_info;
           R2 = P64[Sp + 32];
           _s8nw::P64 = P64[R1 + 7];
           _s8nx::P64 = P64[R1 + 15];
           _s8ny::P64 = P64[R1 + 23];
           R1 = P64[Sp + 40];
           P64[Sp] = _s8ny::P64;
           P64[Sp + 32] = _s8nx::P64;
           P64[Sp + 40] = _s8nw::P64;
           Sp = Sp - 8;
           call go_s8nq_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cgbC_info" {
     block_cgbC_info:
         const _cgbC;
         const 5;
         const 30;
 },
 _cgbH() //  [R1]
         { []
         }
     {offset
       cgbH: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cgck; else goto cgcj;
       cgck: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgcj: // global
           _s8nA::P64 = P64[R1 + 7];
           _s8nB::P64 = P64[R1 + 15];
           _s8nC::P64 = P64[R1 + 23];
           I64[Hp - 144] = sat_s8nF_info;
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _s8nC::P64;
           I64[Hp - 104] = sat_s8nE_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = _s8nB::P64;
           I64[Hp - 64] = sat_s8nD_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _s8nA::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 64;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 144;
           R1 = Hp - 23;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cgbH_info" {
     block_cgbH_info:
         const _cgbH;
         const 6;
         const 30;
 },
 GHC.Base.$fMonoid(,,)_$cmconcat_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cgcn: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto cgcr; else goto cgcq;
       cgcr: // global
           HpAlloc = 216;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cmconcat_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgcq: // global
           I64[Hp - 208] = $dSemigroup_s8nj_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = $dSemigroup1_s8nk_info;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = $dSemigroup2_s8nl_info;
           P64[Hp - 144] = R4;
           I64[Hp - 136] = z_s8nm_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = z1_s8nn_info;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = z2_s8no_info;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = (,,)_con_info;
           P64[Hp - 56] = Hp - 136;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 88;
           I64[Hp - 32] = go_s8nq_info;
           P64[Hp - 24] = Hp - 208;
           P64[Hp - 16] = Hp - 184;
           P64[Hp - 8] = Hp - 160;
           P64[Hp] = Hp - 63;
           R2 = R5;
           R1 = Hp - 31;
           call go_s8nq_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,)_$cmconcat_info" {
     GHC.Base.$fMonoid(,,)_$cmconcat_info:
         const GHC.Base.$fMonoid(,,)_$cmconcat_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.705365935 UTC

[section ""data" . GHC.Base.$fSemigroup(,,)_$cstimes_closure" {
     GHC.Base.$fSemigroup(,,)_$cstimes_closure:
         const GHC.Base.$fSemigroup(,,)_$cstimes_info;
 },
 sat_s8nS_entry() //  [R1]
         { []
         }
     {offset
       cgdY: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgdZ; else goto cge0;
       cgdZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8nS_info" {
     sat_s8nS_info:
         const sat_s8nS_entry;
         const 4;
         const 15;
 },
 sat_s8nR_entry() //  [R1]
         { []
         }
     {offset
       cge5: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cge6; else goto cge7;
       cge6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cge7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8nR_info" {
     sat_s8nR_info:
         const sat_s8nR_entry;
         const 4;
         const 15;
 },
 sat_s8nQ_entry() //  [R1]
         { []
         }
     {offset
       cgec: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cged; else goto cgee;
       cged: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgee: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8nQ_info" {
     sat_s8nQ_info:
         const sat_s8nQ_entry;
         const 4;
         const 15;
 },
 GHC.Base.$fSemigroup(,,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cgef: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgeh; else goto cgei;
       cgeh: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,)_$cstimes_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgei: // global
           I64[Sp - 40] = block_cgdP_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugem; else goto cgdQ;
       ugem: // global
           call _cgdP(R1) args: 0, res: 0, upd: 0;
       cgdQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,,)_$cstimes_info" {
     GHC.Base.$fSemigroup(,,)_$cstimes_info:
         const GHC.Base.$fSemigroup(,,)_$cstimes_entry;
         const 0;
         const 14;
         const 25769803802;
 },
 _cgdP() //  [R1]
         { []
         }
     {offset
       cgdP: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto cgel; else goto cgek;
       cgel: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgek: // global
           _s8nN::P64 = P64[R1 + 7];
           _s8nO::P64 = P64[R1 + 15];
           _s8nP::P64 = P64[R1 + 23];
           I64[Hp - 168] = sat_s8nS_info;
           P64[Hp - 152] = P64[Sp + 16];
           _s8nJ::P64 = P64[Sp + 24];
           P64[Hp - 144] = _s8nJ::P64;
           _s8nK::P64 = P64[Sp + 32];
           P64[Hp - 136] = _s8nK::P64;
           P64[Hp - 128] = _s8nP::P64;
           I64[Hp - 120] = sat_s8nR_info;
           P64[Hp - 104] = P64[Sp + 8];
           P64[Hp - 96] = _s8nJ::P64;
           P64[Hp - 88] = _s8nK::P64;
           P64[Hp - 80] = _s8nO::P64;
           I64[Hp - 72] = sat_s8nQ_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = _s8nJ::P64;
           P64[Hp - 40] = _s8nK::P64;
           P64[Hp - 32] = _s8nN::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 120;
           P64[Hp] = Hp - 168;
           R1 = Hp - 23;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cgdP_info" {
     block_cgdP_info:
         const _cgdP;
         const 5;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.718347506 UTC

[section ""data" . GHC.Base.$fSemigroup(,,)_closure" {
     GHC.Base.$fSemigroup(,,)_closure:
         const GHC.Base.$fSemigroup(,,)_info;
 },
 sat_s8nY_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cgf7: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgf8; else goto cgf9;
       cgf8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgf9: // global
           R6 = R3;
           R5 = R2;
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fSemigroup(,,)_$cstimes_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8nY_info" {
     sat_s8nY_info:
         const sat_s8nY_entry;
         const 3;
         const 8;
         const 12884901911;
 },
 sat_s8nX_entry() //  [R1, R2]
         { []
         }
     {offset
       cgff: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(,,)_$csconcat_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8nX_info" {
     sat_s8nX_info:
         const sat_s8nX_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 sat_s8nW_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cgfn: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(,,)_$c<>_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8nW_info" {
     sat_s8nW_info:
         const sat_s8nW_entry;
         const 3;
         const 8;
         const 8589934607;
 },
 GHC.Base.$fSemigroup(,,)_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cgfr: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto cgfv; else goto cgfu;
       cgfv: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,)_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgfu: // global
           I64[Hp - 120] = sat_s8nY_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_s8nX_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_s8nW_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 54;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 117;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,,)_info" {
     GHC.Base.$fSemigroup(,,)_info:
         const GHC.Base.$fSemigroup(,,)_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.72861851 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,,)_$cp1Monoid_info;
 },
 sat_s8o4_entry() //  [R1]
         { []
         }
     {offset
       cgfW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgfX; else goto cgfY;
       cgfX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgfY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8o4_info" {
     sat_s8o4_info:
         const sat_s8o4_entry;
         const 1;
         const 16;
 },
 sat_s8o3_entry() //  [R1]
         { []
         }
     {offset
       cgg3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgg4; else goto cgg5;
       cgg4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgg5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8o3_info" {
     sat_s8o3_info:
         const sat_s8o3_entry;
         const 1;
         const 16;
 },
 sat_s8o2_entry() //  [R1]
         { []
         }
     {offset
       cgga: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggb; else goto cggc;
       cggb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8o2_info" {
     sat_s8o2_info:
         const sat_s8o2_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fMonoid(,,)_$cp1Monoid_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cggd: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cggh; else goto cggg;
       cggh: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cggg: // global
           I64[Hp - 64] = sat_s8o4_info;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_s8o3_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s8o2_info;
           P64[Hp] = R2;
           R4 = Hp - 64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroup(,,)_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,)_$cp1Monoid_info" {
     GHC.Base.$fMonoid(,,)_$cp1Monoid_info:
         const GHC.Base.$fMonoid(,,)_$cp1Monoid_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.739364844 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_closure" {
     GHC.Base.$fMonoid(,,)_closure:
         const GHC.Base.$fMonoid(,,)_info;
 },
 sat_s8ob_entry() //  [R1, R2]
         { []
         }
     {offset
       cggH: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fMonoid(,,)_$cmconcat_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8ob_info" {
     sat_s8ob_info:
         const sat_s8ob_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 sat_s8oa_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cggP: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(,,)_$cmappend_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8oa_info" {
     sat_s8oa_info:
         const sat_s8oa_entry;
         const 3;
         const 8;
         const 8589934607;
 },
 sat_s8o9_entry() //  [R1]
         { []
         }
     {offset
       cggW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cggX; else goto cggY;
       cggX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cggY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,)_$cmempty_entry(R4,
                                                     R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8o9_info" {
     sat_s8o9_info:
         const sat_s8o9_entry;
         const 3;
         const 15;
 },
 sat_s8o8_entry() //  [R1]
         { []
         }
     {offset
       cgh3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgh4; else goto cgh5;
       cgh4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgh5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,)_$cp1Monoid_entry(R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8o8_info" {
     sat_s8o8_info:
         const sat_s8o8_entry;
         const 3;
         const 15;
 },
 GHC.Base.$fMonoid(,,)_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cgh7: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto cghb; else goto cgha;
       cghb: // global
           HpAlloc = 184;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgha: // global
           I64[Hp - 176] = sat_s8ob_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           P64[Hp - 152] = R4;
           I64[Hp - 144] = sat_s8oa_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_s8o9_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_s8o8_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 142;
           P64[Hp] = Hp - 175;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,)_info" {
     GHC.Base.$fMonoid(,,)_info:
         const GHC.Base.$fMonoid(,,)_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.752494313 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_$c<>_closure" {
     GHC.Base.$fSemigroup(,)_$c<>_closure:
         const GHC.Base.$fSemigroup(,)_$c<>_info;
 },
 sat_s8on_entry() //  [R1]
         { []
         }
     {offset
       cghR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghS; else goto cghT;
       cghS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cghT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8on_info" {
     sat_s8on_info:
         const sat_s8on_entry;
         const 3;
         const 15;
 },
 sat_s8om_entry() //  [R1]
         { []
         }
     {offset
       cghY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cghZ; else goto cgi0;
       cghZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgi0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8om_info" {
     sat_s8om_info:
         const sat_s8om_entry;
         const 3;
         const 15;
 },
 GHC.Base.$fSemigroup(,)_$c<>_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cgi1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgi3; else goto cgi4;
       cgi3: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_$c<>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgi4: // global
           I64[Sp - 32] = block_cghD_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugia; else goto cghE;
       ugia: // global
           call _cghD(R1) args: 0, res: 0, upd: 0;
       cghE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,)_$c<>_info" {
     GHC.Base.$fSemigroup(,)_$c<>_info:
         const GHC.Base.$fSemigroup(,)_$c<>_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _cghD() //  [R1]
         { []
         }
     {offset
       cghD: // global
           I64[Sp - 8] = block_cghI_info;
           _s8oh::P64 = P64[R1 + 7];
           _s8oi::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _s8oi::P64;
           P64[Sp + 24] = _s8oh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ugi9; else goto cghJ;
       ugi9: // global
           call _cghI(R1) args: 0, res: 0, upd: 0;
       cghJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cghD_info" {
     block_cghD_info:
         const _cghD;
         const 3;
         const 30;
 },
 _cghI() //  [R1]
         { []
         }
     {offset
       cghI: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgi8; else goto cgi7;
       cgi8: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgi7: // global
           _s8ok::P64 = P64[R1 + 7];
           _s8ol::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_s8on_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _s8ol::P64;
           I64[Hp - 56] = sat_s8om_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _s8ok::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cghI_info" {
     block_cghI_info:
         const _cghI;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.765100936 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_$cstimes_closure" {
     GHC.Base.$fSemigroup(,)_$cstimes_closure:
         const GHC.Base.$fSemigroup(,)_$cstimes_info;
 },
 sat_s8ox_entry() //  [R1]
         { []
         }
     {offset
       cgiU: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgiV; else goto cgiW;
       cgiV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgiW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8ox_info" {
     sat_s8ox_info:
         const sat_s8ox_entry;
         const 4;
         const 15;
 },
 sat_s8ow_entry() //  [R1]
         { []
         }
     {offset
       cgj1: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgj2; else goto cgj3;
       cgj2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgj3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8ow_info" {
     sat_s8ow_info:
         const sat_s8ow_entry;
         const 4;
         const 15;
 },
 GHC.Base.$fSemigroup(,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cgj4: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cgj6; else goto cgj7;
       cgj6: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_$cstimes_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgj7: // global
           I64[Sp - 40] = block_cgiL_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ugjb; else goto cgiM;
       ugjb: // global
           call _cgiL(R1) args: 0, res: 0, upd: 0;
       cgiM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,)_$cstimes_info" {
     GHC.Base.$fSemigroup(,)_$cstimes_info:
         const GHC.Base.$fSemigroup(,)_$cstimes_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cgiL() //  [R1]
         { []
         }
     {offset
       cgiL: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cgja; else goto cgj9;
       cgja: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgj9: // global
           _s8ou::P64 = P64[R1 + 7];
           _s8ov::P64 = P64[R1 + 15];
           I64[Hp - 112] = sat_s8ox_info;
           P64[Hp - 96] = P64[Sp + 16];
           _s8oq::P64 = P64[Sp + 24];
           P64[Hp - 88] = _s8oq::P64;
           _s8or::P64 = P64[Sp + 32];
           P64[Hp - 80] = _s8or::P64;
           P64[Hp - 72] = _s8ov::P64;
           I64[Hp - 64] = sat_s8ow_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _s8oq::P64;
           P64[Hp - 32] = _s8or::P64;
           P64[Hp - 24] = _s8ou::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cgiL_info" {
     block_cgiL_info:
         const _cgiL;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.776389912 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_closure" {
     GHC.Base.$fSemigroup(,)_closure:
         const GHC.Base.$fSemigroup(,)_info;
 },
 sat_s8oC_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cgjN: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroup(,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8oC_info" {
     sat_s8oC_info:
         const sat_s8oC_entry;
         const 2;
         const 11;
         const 12884901911;
 },
 sat_s8oB_entry() //  [R1, R2]
         { []
         }
     {offset
       cgjV: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(,)_$csconcat_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8oB_info" {
     sat_s8oB_info:
         const sat_s8oB_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 sat_s8oA_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cgk3: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fSemigroup(,)_$c<>_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8oA_info" {
     sat_s8oA_info:
         const sat_s8oA_entry;
         const 2;
         const 11;
         const 8589934607;
 },
 GHC.Base.$fSemigroup(,)_entry() //  [R2, R3]
         { []
         }
     {offset
       cgk7: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cgkb; else goto cgka;
       cgkb: // global
           HpAlloc = 104;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgka: // global
           I64[Hp - 96] = sat_s8oC_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_s8oB_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_s8oA_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 46;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 93;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,)_info" {
     GHC.Base.$fSemigroup(,)_info:
         const GHC.Base.$fSemigroup(,)_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.786283567 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,)_$cp1Monoid_info;
 },
 sat_s8oG_entry() //  [R1]
         { []
         }
     {offset
       cgkB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkC; else goto cgkD;
       cgkC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8oG_info" {
     sat_s8oG_info:
         const sat_s8oG_entry;
         const 1;
         const 16;
 },
 sat_s8oF_entry() //  [R1]
         { []
         }
     {offset
       cgkI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgkJ; else goto cgkK;
       cgkJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgkK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8oF_info" {
     sat_s8oF_info:
         const sat_s8oF_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fMonoid(,)_$cp1Monoid_entry() //  [R2, R3]
         { []
         }
     {offset
       cgkL: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgkP; else goto cgkO;
       cgkP: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgkO: // global
           I64[Hp - 40] = sat_s8oG_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_s8oF_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroup(,)_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,)_$cp1Monoid_info" {
     GHC.Base.$fMonoid(,)_$cp1Monoid_info:
         const GHC.Base.$fMonoid(,)_$cp1Monoid_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.794993428 UTC

[section ""data" . GHC.Base.$fMonoid(,)_closure" {
     GHC.Base.$fMonoid(,)_closure:
         const GHC.Base.$fMonoid(,)_info;
 },
 sat_s8oM_entry() //  [R1, R2]
         { []
         }
     {offset
       cglb: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fMonoid(,)_$cmconcat_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8oM_info" {
     sat_s8oM_info:
         const sat_s8oM_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 sat_s8oL_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cglj: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(,)_$cmappend_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8oL_info" {
     sat_s8oL_info:
         const sat_s8oL_entry;
         const 2;
         const 11;
         const 8589934607;
 },
 sat_s8oK_entry() //  [R1]
         { []
         }
     {offset
       cglq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cglr; else goto cgls;
       cglr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgls: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,)_$cmempty_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8oK_info" {
     sat_s8oK_info:
         const sat_s8oK_entry;
         const 2;
         const 18;
 },
 sat_s8oJ_entry() //  [R1]
         { []
         }
     {offset
       cglx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgly; else goto cglz;
       cgly: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cglz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,)_$cp1Monoid_entry(R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8oJ_info" {
     sat_s8oJ_info:
         const sat_s8oJ_entry;
         const 2;
         const 18;
 },
 GHC.Base.$fMonoid(,)_entry() //  [R2, R3]
         { []
         }
     {offset
       cglB: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cglF; else goto cglE;
       cglF: // global
           HpAlloc = 152;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cglE: // global
           I64[Hp - 144] = sat_s8oM_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           I64[Hp - 120] = sat_s8oL_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_s8oK_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_s8oJ_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 64;
           P64[Hp - 16] = Hp - 96;
           P64[Hp - 8] = Hp - 118;
           P64[Hp] = Hp - 143;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,)_info" {
     GHC.Base.$fMonoid(,)_info:
         const GHC.Base.$fMonoid(,)_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.805895868 UTC

[section ""data" . GHC.Base.$fMonoid()_$c<>_closure" {
     GHC.Base.$fMonoid()_$c<>_closure:
         const GHC.Base.$fMonoid()_$c<>_info;
 },
 GHC.Base.$fMonoid()_$c<>_entry() //  []
         { []
         }
     {offset
       cgm7: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid()_$c<>_info" {
     GHC.Base.$fMonoid()_$c<>_info:
         const GHC.Base.$fMonoid()_$c<>_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.809336442 UTC

[section ""data" . GHC.Base.$fSemigroup()_$csconcat_closure" {
     GHC.Base.$fSemigroup()_$csconcat_closure:
         const GHC.Base.$fSemigroup()_$csconcat_info;
 },
 GHC.Base.$fSemigroup()_$csconcat_entry() //  []
         { []
         }
     {offset
       cgmj: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup()_$csconcat_info" {
     GHC.Base.$fSemigroup()_$csconcat_info:
         const GHC.Base.$fSemigroup()_$csconcat_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.813153796 UTC

[section ""data" . GHC.Base.$fSemigroup()_$cstimes_closure" {
     GHC.Base.$fSemigroup()_$cstimes_closure:
         const GHC.Base.$fSemigroup()_$cstimes_info;
 },
 GHC.Base.$fSemigroup()_$cstimes_entry() //  []
         { []
         }
     {offset
       cgmv: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup()_$cstimes_info" {
     GHC.Base.$fSemigroup()_$cstimes_info:
         const GHC.Base.$fSemigroup()_$cstimes_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.816383987 UTC

[section ""data" . GHC.Base.$fSemigroup()_closure" {
     GHC.Base.$fSemigroup()_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.$fMonoid()_$c<>_closure+2;
         const GHC.Base.$fSemigroup()_$csconcat_closure+1;
         const GHC.Base.$fSemigroup()_$cstimes_closure+3;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.818259807 UTC

[section ""data" . GHC.Base.$fMonoid()_closure" {
     GHC.Base.$fMonoid()_closure:
         const GHC.Base.C:Monoid_con_info;
         const GHC.Base.$fSemigroup()_closure+1;
         const GHC.Tuple.()_closure+1;
         const GHC.Base.$fMonoid()_$c<>_closure+2;
         const GHC.Base.$fMonoid()_$cmconcat_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.820882204 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_$c<>_closure" {
     GHC.Base.$fSemigroup(->)_$c<>_closure:
         const GHC.Base.$fSemigroup(->)_$c<>_info;
 },
 GHC.Base.$fSemigroup(->)_$c<>_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cgmL: // global
           _s8oW::P64 = R5;
           _s8oV::P64 = R4;
           _s8oU::P64 = R3;
           _s8oT::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgmM; else goto cgmN;
       cgmN: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgmP; else goto cgmO;
       cgmP: // global
           HpAlloc = 64;
           goto cgmM;
       cgmM: // global
           R5 = _s8oW::P64;
           R4 = _s8oV::P64;
           R3 = _s8oU::P64;
           R2 = _s8oT::P64;
           R1 = GHC.Base.$fSemigroup(->)_$c<>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgmO: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _s8oV::P64;
           P64[Hp - 32] = _s8oW::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s8oU::P64;
           P64[Hp] = _s8oW::P64;
           R2 = _s8oT::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(->)_$c<>_info" {
     GHC.Base.$fSemigroup(->)_$c<>_info:
         const GHC.Base.$fSemigroup(->)_$c<>_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.825923809 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_$cstimes_closure" {
     GHC.Base.$fSemigroup(->)_$cstimes_closure:
         const GHC.Base.$fSemigroup(->)_$cstimes_info;
 },
 GHC.Base.$fSemigroup(->)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cgn2: // global
           _s8p3::P64 = R6;
           _s8p2::P64 = R5;
           _s8p1::P64 = R4;
           _s8p0::P64 = R3;
           _s8oZ::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cgn3; else goto cgn4;
       cgn4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgn6; else goto cgn5;
       cgn6: // global
           HpAlloc = 32;
           goto cgn3;
       cgn3: // global
           R6 = _s8p3::P64;
           R5 = _s8p2::P64;
           R4 = _s8p1::P64;
           R3 = _s8p0::P64;
           R2 = _s8oZ::P64;
           R1 = GHC.Base.$fSemigroup(->)_$cstimes_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgn5: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _s8p2::P64;
           P64[Hp] = _s8p3::P64;
           R2 = _s8oZ::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _s8p0::P64;
           P64[Sp - 16] = _s8p1::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Base.stimes_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(->)_$cstimes_info" {
     GHC.Base.$fSemigroup(->)_$cstimes_info:
         const GHC.Base.$fSemigroup(->)_$cstimes_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.831855292 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_closure" {
     GHC.Base.$fSemigroup(->)_closure:
         const GHC.Base.$fSemigroup(->)_info;
 },
 sat_s8p8_entry() //  [R1, R2, R3, R4, R5]
         { []
         }
     {offset
       cgnm: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call GHC.Base.$fSemigroup(->)_$cstimes_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8p8_info" {
     sat_s8p8_info:
         const sat_s8p8_entry;
         const 1;
         const 9;
         const 17179869208;
 },
 sat_s8p7_entry() //  [R1, R2]
         { []
         }
     {offset
       cgnu: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(->)_$csconcat_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8p7_info" {
     sat_s8p7_info:
         const sat_s8p7_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_s8p6_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cgnC: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroup(->)_$c<>_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8p6_info" {
     sat_s8p6_info:
         const sat_s8p6_entry;
         const 1;
         const 9;
         const 12884901911;
 },
 GHC.Base.$fSemigroup(->)_entry() //  [R2]
         { []
         }
     {offset
       cgnG: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cgnK; else goto cgnJ;
       cgnK: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(->)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgnJ: // global
           I64[Hp - 72] = sat_s8p8_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_s8p7_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_s8p6_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 37;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 68;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(->)_info" {
     GHC.Base.$fSemigroup(->)_info:
         const GHC.Base.$fSemigroup(->)_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.840995333 UTC

[section ""data" . GHC.Base.$fMonoid(->)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(->)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(->)_$cp1Monoid_info;
 },
 sat_s8pa_entry() //  [R1]
         { []
         }
     {offset
       cgoa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgob; else goto cgoc;
       cgob: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8pa_info" {
     sat_s8pa_info:
         const sat_s8pa_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fMonoid(->)_$cp1Monoid_entry() //  [R2]
         { []
         }
     {offset
       cgod: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgoh; else goto cgog;
       cgoh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(->)_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgog: // global
           I64[Hp - 16] = sat_s8pa_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroup(->)_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(->)_$cp1Monoid_info" {
     GHC.Base.$fMonoid(->)_$cp1Monoid_info:
         const GHC.Base.$fMonoid(->)_$cp1Monoid_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.848502753 UTC

[section ""data" . GHC.Base.$fMonoid(->)_closure" {
     GHC.Base.$fMonoid(->)_closure:
         const GHC.Base.$fMonoid(->)_info;
 },
 lvl3_s8pc_entry() //  [R1]
         { []
         }
     {offset
       cgoy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgoz; else goto cgoA;
       cgoz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgoA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl3_s8pc_info" {
     lvl3_s8pc_info:
         const lvl3_s8pc_entry;
         const 1;
         const 16;
 },
 sat_s8ph_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cgoG: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(->)_$cmconcat_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8ph_info" {
     sat_s8ph_info:
         const sat_s8ph_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8pg_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cgoO: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fMonoid(->)_$cmappend_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8pg_info" {
     sat_s8pg_info:
         const sat_s8pg_entry;
         const 1;
         const 9;
         const 12884901911;
 },
 sat_s8pf_entry() //  [R1]
         { []
         }
     {offset
       cgoW: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8pf_info" {
     sat_s8pf_info:
         const sat_s8pf_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_s8pd_entry() //  [R1]
         { []
         }
     {offset
       cgp3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgp4; else goto cgp5;
       cgp4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgp5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(->)_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8pd_info" {
     sat_s8pd_info:
         const sat_s8pd_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fMonoid(->)_entry() //  [R2]
         { []
         }
     {offset
       cgp7: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cgpb; else goto cgpa;
       cgpb: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(->)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpa: // global
           I64[Hp - 128] = lvl3_s8pc_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_s8ph_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_s8pg_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_s8pf_info;
           P64[Hp - 64] = Hp - 128;
           I64[Hp - 56] = sat_s8pd_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 71;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(->)_info" {
     GHC.Base.$fMonoid(->)_info:
         const GHC.Base.$fMonoid(->)_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.860502345 UTC

[section ""data" . GHC.Base.$fSemigroup[]_$cstimes_closure" {
     GHC.Base.$fSemigroup[]_$cstimes_closure:
         const GHC.Base.$fSemigroup[]_$cstimes_info;
         const 0;
 },
 GHC.Base.$fSemigroup[]_$cstimes_entry() //  [R2]
         { []
         }
     {offset
       cgpH: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesList_closure;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup[]_$cstimes_info" {
     GHC.Base.$fSemigroup[]_$cstimes_info:
         const GHC.Base.$fSemigroup[]_$cstimes_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const S8R0_srt+128;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.863762516 UTC

[section ""data" . GHC.Base.$fSemigroup[]_closure" {
     GHC.Base.$fSemigroup[]_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.++_closure+2;
         const GHC.Base.$fSemigroup[]_$csconcat_closure+1;
         const GHC.Base.$fSemigroup[]_$cstimes_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.865540286 UTC

[section ""data" . GHC.Base.$fMonoid[]_closure" {
     GHC.Base.$fMonoid[]_closure:
         const GHC.Base.C:Monoid_con_info;
         const GHC.Base.$fSemigroup[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.++_closure+2;
         const GHC.Base.$fMonoid[]_$cmconcat_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.868358873 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$cpure_closure" {
     GHC.Base.$fApplicativeNonEmpty_$cpure_closure:
         const GHC.Base.$fApplicativeNonEmpty_$cpure_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$cpure_entry() //  [R2]
         { []
         }
     {offset
       cgpV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgpZ; else goto cgpY;
       cgpZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$cpure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgpY: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeNonEmpty_$cpure_info" {
     GHC.Base.$fApplicativeNonEmpty_$cpure_info:
         const GHC.Base.$fApplicativeNonEmpty_$cpure_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.874349082 UTC

[section ""data" . GHC.Base.$w$cliftA2_closure" {
     GHC.Base.$w$cliftA2_closure:
         const GHC.Base.$w$cliftA2_info;
 },
 sat_s8pq_entry() //  [R1, R2]
         { []
         }
     {offset
       cgql: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgqp; else goto cgqo;
       cgqp: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqo: // global
           _s8pk::P64 = P64[R1 + 7];
           _s8pn::P64 = P64[R1 + 15];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _s8pk::P64;
           P64[Hp - 32] = _s8pn::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8pq_info" {
     sat_s8pq_info:
         const sat_s8pq_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 sat_s8pu_entry() //  [R1, R2]
         { []
         }
     {offset
       cgqt: // global
           _s8pn::P64 = R2;
           _s8pu::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cgqu; else goto cgqv;
       cgqv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqx; else goto cgqw;
       cgqx: // global
           HpAlloc = 24;
           goto cgqu;
       cgqu: // global
           R2 = _s8pn::P64;
           R1 = _s8pu::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgqw: // global
           _s8pk::P64 = P64[_s8pu::P64 + 7];
           _s8pm::P64 = P64[_s8pu::P64 + 15];
           I64[Hp - 16] = sat_s8pq_info;
           P64[Hp - 8] = _s8pk::P64;
           P64[Hp] = _s8pn::P64;
           I64[Sp - 8] = block_cgqq_info;
           R3 = Hp - 15;
           R2 = _s8pm::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8pu_info" {
     sat_s8pu_info:
         const sat_s8pu_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _cgqq() //  [R1, R2]
         { []
         }
     {offset
       cgqq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqA; else goto cgqz;
       cgqA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgqz: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cgqq_info" {
     block_cgqq_info:
         const _cgqq;
         const 0;
         const 30;
 },
 GHC.Base.$w$cliftA2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cgqB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgqF; else goto cgqE;
       cgqF: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgqE: // global
           I64[Hp - 16] = sat_s8pu_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           _s8pl::P64 = R3;
           R3 = Hp - 15;
           R2 = _s8pl::P64;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$cliftA2_info" {
     GHC.Base.$w$cliftA2_info:
         const GHC.Base.$w$cliftA2_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.88447046 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure" {
     GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure:
         const GHC.Base.$fApplicativeNonEmpty_$cliftA2_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$cliftA2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cgr4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgr5; else goto cgr6;
       cgr5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgr6: // global
           I64[Sp - 8] = block_cgr1_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cliftA2_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeNonEmpty_$cliftA2_info" {
     GHC.Base.$fApplicativeNonEmpty_$cliftA2_info:
         const GHC.Base.$fApplicativeNonEmpty_$cliftA2_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cgr1() //  [R1, R2]
         { []
         }
     {offset
       cgr1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgr9; else goto cgr8;
       cgr9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgr8: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cgr1_info" {
     block_cgr1_info:
         const _cgr1;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.891309214 UTC

[section ""data" . GHC.Base.$w$c<*_closure" {
     GHC.Base.$w$c<*_closure:
         const GHC.Base.$w$c<*_info;
 },
 sat_s8pG_entry() //  [R1]
         { []
         }
     {offset
       cgry: // global
           R1 = P64[R1 + 7];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8pG_info" {
     sat_s8pG_info:
         const sat_s8pG_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_s8pK_entry() //  [R1, R2]
         { []
         }
     {offset
       cgrE: // global
           _s8pD::P64 = R2;
           _s8pK::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cgrF; else goto cgrG;
       cgrG: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgrI; else goto cgrH;
       cgrI: // global
           HpAlloc = 40;
           goto cgrF;
       cgrF: // global
           R2 = _s8pD::P64;
           R1 = _s8pK::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgrH: // global
           _s8pC::P64 = P64[_s8pK::P64 + 7];
           I64[Hp - 32] = GHC.Base.:|_con_info;
           P64[Hp - 24] = _s8pD::P64;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           I64[Hp - 8] = sat_s8pG_info;
           P64[Hp] = Hp - 31;
           I64[Sp - 8] = block_cgrB_info;
           R3 = Hp - 7;
           R2 = _s8pC::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8pK_info" {
     sat_s8pK_info:
         const sat_s8pK_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _cgrB() //  [R1, R2]
         { []
         }
     {offset
       cgrB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgrL; else goto cgrK;
       cgrL: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgrK: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cgrB_info" {
     block_cgrB_info:
         const _cgrB;
         const 0;
         const 30;
 },
 GHC.Base.$w$c<*_entry() //  [R2, R3]
         { []
         }
     {offset
       cgrM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgrQ; else goto cgrP;
       cgrQ: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgrP: // global
           I64[Hp - 8] = sat_s8pK_info;
           P64[Hp] = R3;
           R3 = Hp - 7;
           R2 = R2;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$c<*_info" {
     GHC.Base.$w$c<*_info:
         const GHC.Base.$w$c<*_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.900963254 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$c<*_closure" {
     GHC.Base.$fApplicativeNonEmpty_$c<*_closure:
         const GHC.Base.$fApplicativeNonEmpty_$c<*_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$c<*_entry() //  [R2, R3]
         { []
         }
     {offset
       cgsf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgsg; else goto cgsh;
       cgsg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$c<*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgsh: // global
           I64[Sp - 8] = block_cgsc_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$c<*_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeNonEmpty_$c<*_info" {
     GHC.Base.$fApplicativeNonEmpty_$c<*_info:
         const GHC.Base.$fApplicativeNonEmpty_$c<*_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cgsc() //  [R1, R2]
         { []
         }
     {offset
       cgsc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgsk; else goto cgsj;
       cgsk: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgsj: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cgsc_info" {
     block_cgsc_info:
         const _cgsc;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.908396917 UTC

[section ""data" . GHC.Base.$w$c<*>_closure" {
     GHC.Base.$w$c<*>_closure:
         const GHC.Base.$w$c<*>_info;
 },
 sat_s8pV_entry() //  [R1, R2]
         { []
         }
     {offset
       cgsK: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgsO; else goto cgsN;
       cgsO: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgsN: // global
           _s8pS::P64 = P64[R1 + 7];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _s8pS::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8pV_info" {
     sat_s8pV_info:
         const sat_s8pV_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_s8pZ_entry() //  [R1, R2]
         { []
         }
     {offset
       cgsS: // global
           _s8pS::P64 = R2;
           _s8pZ::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cgsT; else goto cgsU;
       cgsU: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgsW; else goto cgsV;
       cgsW: // global
           HpAlloc = 16;
           goto cgsT;
       cgsT: // global
           R2 = _s8pS::P64;
           R1 = _s8pZ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgsV: // global
           _s8pR::P64 = P64[_s8pZ::P64 + 7];
           I64[Hp - 8] = sat_s8pV_info;
           P64[Hp] = _s8pS::P64;
           I64[Sp - 8] = block_cgsP_info;
           R3 = Hp - 7;
           R2 = _s8pR::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8pZ_info" {
     sat_s8pZ_info:
         const sat_s8pZ_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _cgsP() //  [R1, R2]
         { []
         }
     {offset
       cgsP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgsZ; else goto cgsY;
       cgsZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgsY: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cgsP_info" {
     block_cgsP_info:
         const _cgsP;
         const 0;
         const 30;
 },
 GHC.Base.$w$c<*>_entry() //  [R2, R3]
         { []
         }
     {offset
       cgt0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgt4; else goto cgt3;
       cgt4: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgt3: // global
           I64[Hp - 8] = sat_s8pZ_info;
           P64[Hp] = R3;
           R3 = Hp - 7;
           R2 = R2;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$c<*>_info" {
     GHC.Base.$w$c<*>_info:
         const GHC.Base.$w$c<*>_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.9182076 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$c<*>_closure" {
     GHC.Base.$fApplicativeNonEmpty_$c<*>_closure:
         const GHC.Base.$fApplicativeNonEmpty_$c<*>_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$c<*>_entry() //  [R2, R3]
         { []
         }
     {offset
       cgtt: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cgtu; else goto cgtv;
       cgtu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgtv: // global
           I64[Sp - 8] = block_cgtq_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$c<*>_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeNonEmpty_$c<*>_info" {
     GHC.Base.$fApplicativeNonEmpty_$c<*>_info:
         const GHC.Base.$fApplicativeNonEmpty_$c<*>_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cgtq() //  [R1, R2]
         { []
         }
     {offset
       cgtq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgty; else goto cgtx;
       cgty: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgtx: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cgtq_info" {
     block_cgtq_info:
         const _cgtq;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.92357883 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty1_closure" {
     GHC.Base.$fApplicativeNonEmpty1_closure:
         const GHC.Base.$fApplicativeNonEmpty1_info;
 },
 GHC.Base.$fApplicativeNonEmpty1_entry() //  [R3]
         { []
         }
     {offset
       cgtM: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeNonEmpty1_info" {
     GHC.Base.$fApplicativeNonEmpty1_info:
         const GHC.Base.$fApplicativeNonEmpty1_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.929370862 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$c*>_closure" {
     GHC.Base.$fApplicativeNonEmpty_$c*>_closure:
         const GHC.Base.$fApplicativeNonEmpty_$c*>_info;
 },
 sat_s8qc_entry() //  [R1]
         { []
         }
     {offset
       cgu4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgu5; else goto cgu6;
       cgu5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgu6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cgu1_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugua; else goto cgu2;
       ugua: // global
           call _cgu1(R1) args: 0, res: 0, upd: 0;
       cgu2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8qc_info" {
     sat_s8qc_info:
         const sat_s8qc_entry;
         const 1;
         const 16;
 },
 _cgu1() //  [R1]
         { []
         }
     {offset
       cgu1: // global
           R3 = P64[R1 + 15];
           R2 = GHC.Base.$fApplicativeNonEmpty1_closure+2;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cgu1_info" {
     block_cgu1_info:
         const _cgu1;
         const 0;
         const 30;
 },
 GHC.Base.$fApplicativeNonEmpty_$c*>_entry() //  [R2, R3]
         { []
         }
     {offset
       cguf: // global
           _s8q8::P64 = R3;
           _s8q7::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cgug; else goto cguh;
       cguh: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cguj; else goto cgui;
       cguj: // global
           HpAlloc = 48;
           goto cgug;
       cgug: // global
           R3 = _s8q8::P64;
           R2 = _s8q7::P64;
           R1 = GHC.Base.$fApplicativeNonEmpty_$c*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgui: // global
           I64[Hp - 40] = sat_s8qc_info;
           P64[Hp - 24] = _s8q7::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = GHC.Base.breakpoint_closure+1;
           P64[Hp] = Hp - 40;
           I64[Sp - 8] = block_cguc_info;
           R3 = _s8q8::P64;
           R2 = Hp - 15;
           Sp = Sp - 8;
           call GHC.Base.$w$c<*>_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeNonEmpty_$c*>_info" {
     GHC.Base.$fApplicativeNonEmpty_$c*>_info:
         const GHC.Base.$fApplicativeNonEmpty_$c*>_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cguc() //  [R1, R2]
         { []
         }
     {offset
       cguc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgum; else goto cgul;
       cgum: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cgul: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cguc_info" {
     block_cguc_info:
         const _cguc;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.938285798 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_closure" {
     GHC.Base.$fApplicativeNonEmpty_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctorNonEmpty_closure+1;
         const GHC.Base.$fApplicativeNonEmpty_$cpure_closure+1;
         const GHC.Base.$fApplicativeNonEmpty_$c<*>_closure+2;
         const GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure+3;
         const GHC.Base.$fApplicativeNonEmpty_$c*>_closure+2;
         const GHC.Base.$fApplicativeNonEmpty_$c<*_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.940559422 UTC

[section ""data" . lvl_r7PJ_closure" {
     lvl_r7PJ_closure:
         const lvl_r7PJ_info;
         const 0;
 },
 lvl_r7PJ_entry() //  [R2]
         { []
         }
     {offset
       cguK: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . lvl_r7PJ_info" {
     lvl_r7PJ_info:
         const lvl_r7PJ_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const S8R0_srt+72;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.943562817 UTC

[section ""data" . GHC.Base.$fMonadNonEmpty_closure" {
     GHC.Base.$fMonadNonEmpty_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicativeNonEmpty_closure+1;
         const GHC.Base.$fMonadNonEmpty_$c>>=_closure+2;
         const GHC.Base.$fMonadNonEmpty_$c>>_closure+2;
         const GHC.Base.$fApplicativeNonEmpty_$cpure_closure+1;
         const lvl_r7PJ_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.945383582 UTC

[section ""cstring" . GHC.Base.$fAlternativeIO4_bytes" {
     GHC.Base.$fAlternativeIO4_bytes:
         I8[] [109,122,101,114,111]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.947764356 UTC

[section ""data" . GHC.Base.$fAlternativeIO3_closure" {
     GHC.Base.$fAlternativeIO3_closure:
         const GHC.Base.$fAlternativeIO3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Base.$fAlternativeIO3_entry() //  [R1]
         { []
         }
     {offset
       cguZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgv0; else goto cgv1;
       cgv0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgv1: // global
           (_cguW::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cguW::I64 == 0) goto cguY; else goto cguX;
       cguY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cguX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cguW::I64;
           R2 = GHC.Base.$fAlternativeIO4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Base.$fAlternativeIO3_info" {
     GHC.Base.$fAlternativeIO3_info:
         const GHC.Base.$fAlternativeIO3_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.952516951 UTC

[section ""data" . GHC.Base.$fAlternativeIO_$cempty_closure" {
     GHC.Base.$fAlternativeIO_$cempty_closure:
         const GHC.Base.$fAlternativeIO_$cempty_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Base.$fAlternativeIO_$cempty_entry() //  [R1]
         { []
         }
     {offset
       cgvf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgvg; else goto cgvh;
       cgvg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgvh: // global
           (_cgvc::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cgvc::I64 == 0) goto cgve; else goto cgvd;
       cgve: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cgvd: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cgvc::I64;
           R2 = GHC.Base.$fAlternativeIO3_closure;
           R1 = GHC.IO.failIO_closure;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Base.$fAlternativeIO_$cempty_info" {
     GHC.Base.$fAlternativeIO_$cempty_info:
         const GHC.Base.$fAlternativeIO_$cempty_entry;
         const 0;
         const 554050781205;
         const S8R0_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.956736587 UTC

[section ""data" . GHC.Base.$fAlternativeIO_closure" {
     GHC.Base.$fAlternativeIO_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Base.$fApplicativeIO_closure+1;
         const GHC.Base.$fAlternativeIO_$cempty_closure;
         const GHC.IO.mplusIO_closure;
         const GHC.Base.$fAlternativeIO2_closure+2;
         const GHC.Base.$fAlternativeIO_$cmany_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.958508093 UTC

[section ""data" . GHC.Base.$fMonadPlusIO_closure" {
     GHC.Base.$fMonadPlusIO_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Base.$fAlternativeIO_closure+1;
         const GHC.Base.$fMonadIO_closure+1;
         const GHC.Base.$fAlternativeIO_$cempty_closure;
         const GHC.IO.mplusIO_closure;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.961279098 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_$c<|>_closure" {
     GHC.Base.$fAlternativeMaybe_$c<|>_closure:
         const GHC.Base.$fAlternativeMaybe_$c<|>_info;
 },
 GHC.Base.$fAlternativeMaybe_$c<|>_entry() //  [R2, R3]
         { []
         }
     {offset
       cgvC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgvD; else goto cgvE;
       cgvD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeMaybe_$c<|>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgvE: // global
           I64[Sp - 16] = block_cgvv_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugvL; else goto cgvw;
       ugvL: // global
           call _cgvv(R1) args: 0, res: 0, upd: 0;
       cgvw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fAlternativeMaybe_$c<|>_info" {
     GHC.Base.$fAlternativeMaybe_$c<|>_info:
         const GHC.Base.$fAlternativeMaybe_$c<|>_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cgvv() //  [R1]
         { []
         }
     {offset
       cgvv: // global
           if (R1 & 7 == 1) goto cgvz; else goto cgvA;
       cgvz: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cgvA: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cgvv_info" {
     block_cgvv_info:
         const _cgvv;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.968700724 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$cliftA2_closure" {
     GHC.Base.$fApplicativeMaybe_$cliftA2_closure:
         const GHC.Base.$fApplicativeMaybe_$cliftA2_info;
 },
 GHC.Base.$fApplicativeMaybe_$cliftA2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cgwc: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cgwd; else goto cgwe;
       cgwd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgwe: // global
           I64[Sp - 24] = block_cgw5_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ugwG; else goto cgw6;
       ugwG: // global
           call _cgw5(R1) args: 0, res: 0, upd: 0;
       cgw6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeMaybe_$cliftA2_info" {
     GHC.Base.$fApplicativeMaybe_$cliftA2_info:
         const GHC.Base.$fApplicativeMaybe_$cliftA2_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cgw5() //  [R1]
         { []
         }
     {offset
       cgw5: // global
           if (R1 & 7 == 1) goto ugwC; else goto cgwa;
       ugwC: // global
           Sp = Sp + 24;
           call _cgws() args: 0, res: 0, upd: 0;
       cgwa: // global
           I64[Sp] = block_cgwk_info;
           _s8qq::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8qq::P64;
           if (R1 & 7 != 0) goto ugwE; else goto cgwm;
       ugwE: // global
           call _cgwk(R1) args: 0, res: 0, upd: 0;
       cgwm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cgw5_info" {
     block_cgw5_info:
         const _cgw5;
         const 2;
         const 30;
 },
 _cgwk() //  [R1]
         { []
         }
     {offset
       cgwk: // global
           if (R1 & 7 == 1) goto ugwD; else goto cgwx;
       ugwD: // global
           Sp = Sp + 24;
           call _cgws() args: 0, res: 0, upd: 0;
       cgwx: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgwA; else goto cgwz;
       cgwA: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgwz: // global
           _s8qs::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _s8qs::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cgwk_info" {
     block_cgwk_info:
         const _cgwk;
         const 2;
         const 30;
 },
 _cgws() //  []
         { []
         }
     {offset
       cgws: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.977621016 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$c*>_closure" {
     GHC.Base.$fApplicativeMaybe_$c*>_closure:
         const GHC.Base.$fApplicativeMaybe_$c*>_info;
 },
 GHC.Base.$fApplicativeMaybe_$c*>_entry() //  [R2, R3]
         { []
         }
     {offset
       cgxh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgxi; else goto cgxj;
       cgxi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$c*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgxj: // global
           I64[Sp - 16] = block_cgxa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugxq; else goto cgxb;
       ugxq: // global
           call _cgxa(R1) args: 0, res: 0, upd: 0;
       cgxb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeMaybe_$c*>_info" {
     GHC.Base.$fApplicativeMaybe_$c*>_info:
         const GHC.Base.$fApplicativeMaybe_$c*>_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cgxa() //  [R1]
         { []
         }
     {offset
       cgxa: // global
           if (R1 & 7 == 1) goto cgxe; else goto cgxf;
       cgxe: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgxf: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cgxa_info" {
     block_cgxa_info:
         const _cgxa;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.984221545 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$c<*>_closure" {
     GHC.Base.$fApplicative(->)_$c<*>_closure:
         const GHC.Base.$fApplicative(->)_$c<*>_info;
 },
 GHC.Base.$fApplicative(->)_$c<*>_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cgxK: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgxO; else goto cgxN;
       cgxO: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(->)_$c<*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgxN: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = Hp - 24;
           _s8qy::P64 = R2;
           R2 = R4;
           R1 = _s8qy::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative(->)_$c<*>_info" {
     GHC.Base.$fApplicative(->)_$c<*>_info:
         const GHC.Base.$fApplicative(->)_$c<*>_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.988387468 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$cliftA2_closure" {
     GHC.Base.$fApplicative(->)_$cliftA2_closure:
         const GHC.Base.$fApplicative(->)_$cliftA2_info;
 },
 GHC.Base.$fApplicative(->)_$cliftA2_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cgxZ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgy3; else goto cgy2;
       cgy3: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(->)_$cliftA2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgy2: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _s8qC::P64 = R2;
           R2 = Hp - 24;
           R1 = _s8qC::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative(->)_$cliftA2_info" {
     GHC.Base.$fApplicative(->)_$cliftA2_info:
         const GHC.Base.$fApplicative(->)_$cliftA2_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.992054711 UTC

[section ""data" . GHC.Base.$fApplicative(->)_closure" {
     GHC.Base.$fApplicative(->)_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctor(->)_closure+1;
         const GHC.Base.const_closure+2;
         const GHC.Base.$fApplicative(->)_$c<*>_closure+3;
         const GHC.Base.$fApplicative(->)_$cliftA2_closure+4;
         const GHC.Base.$fApplicative(->)_$c*>_closure+3;
         const GHC.Base.$fApplicative(->)_$c<*_closure+3;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.994726583 UTC

[section ""data" . lvl1_r7PK_closure" {
     lvl1_r7PK_closure:
         const lvl1_r7PK_info;
         const 0;
 },
 lvl1_r7PK_entry() //  [R2]
         { []
         }
     {offset
       cgyd: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . lvl1_r7PK_info" {
     lvl1_r7PK_info:
         const lvl1_r7PK_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const S8R0_srt+72;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:46.997718043 UTC

[section ""data" . GHC.Base.$fMonad(->)_closure" {
     GHC.Base.$fMonad(->)_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicative(->)_closure+1;
         const GHC.Base.$fMonad(->)_$c>>=_closure+3;
         const GHC.Base.$fMonad(->)_$c>>_closure+3;
         const GHC.Base.const_closure+2;
         const lvl1_r7PK_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.000624826 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$cfmap_closure" {
     GHC.Base.$fApplicativeMaybe_$cfmap_closure:
         const GHC.Base.$fApplicativeMaybe_$cfmap_info;
 },
 GHC.Base.$fApplicativeMaybe_$cfmap_entry() //  [R2, R3]
         { []
         }
     {offset
       cgyw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgyx; else goto cgyy;
       cgyx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$cfmap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgyy: // global
           I64[Sp - 16] = block_cgyp_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugyJ; else goto cgyq;
       ugyJ: // global
           call _cgyp(R1) args: 0, res: 0, upd: 0;
       cgyq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeMaybe_$cfmap_info" {
     GHC.Base.$fApplicativeMaybe_$cfmap_info:
         const GHC.Base.$fApplicativeMaybe_$cfmap_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cgyp() //  [R1]
         { []
         }
     {offset
       cgyp: // global
           if (R1 & 7 == 1) goto cgyt; else goto cgyu;
       cgyt: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgyu: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgyI; else goto cgyH;
       cgyI: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgyH: // global
           _s8qM::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _s8qM::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cgyp_info" {
     block_cgyp_info:
         const _cgyp;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.006135259 UTC

[section ""data" . GHC.Base.$fFunctorMaybe_closure" {
     GHC.Base.$fFunctorMaybe_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fApplicativeMaybe_$cfmap_closure+2;
         const GHC.Base.$fFunctorMaybe_$c<$_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.009307916 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$c<*>_closure" {
     GHC.Base.$fApplicativeMaybe_$c<*>_closure:
         const GHC.Base.$fApplicativeMaybe_$c<*>_info;
 },
 GHC.Base.$fApplicativeMaybe_$c<*>_entry() //  [R2, R3]
         { []
         }
     {offset
       cgzb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgzc; else goto cgzd;
       cgzc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgzd: // global
           I64[Sp - 16] = block_cgz4_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugzk; else goto cgz5;
       ugzk: // global
           call _cgz4(R1) args: 0, res: 0, upd: 0;
       cgz5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeMaybe_$c<*>_info" {
     GHC.Base.$fApplicativeMaybe_$c<*>_info:
         const GHC.Base.$fApplicativeMaybe_$c<*>_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cgz4() //  [R1]
         { []
         }
     {offset
       cgz4: // global
           if (R1 & 7 == 1) goto cgz8; else goto cgz9;
       cgz8: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cgz9: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 6];
           Sp = Sp + 16;
           call GHC.Base.$fApplicativeMaybe_$cfmap_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cgz4_info" {
     block_cgz4_info:
         const _cgz4;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.014434804 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_closure" {
     GHC.Base.$fApplicativeMaybe_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctorMaybe_closure+1;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fApplicativeMaybe_$c<*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$cliftA2_closure+3;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c<*_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.016220396 UTC

[section ""data" . GHC.Base.$fMonadMaybe_closure" {
     GHC.Base.$fMonadMaybe_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicativeMaybe_closure+1;
         const GHC.Base.$fMonadMaybe_$c>>=_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fMonadMaybe_$cfail_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.018499506 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_closure" {
     GHC.Base.$fAlternativeMaybe_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Base.$fApplicativeMaybe_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.$fAlternativeMaybe_$c<|>_closure+2;
         const GHC.Base.$fAlternativeMaybe_$csome_closure+1;
         const GHC.Base.$fAlternativeMaybe_$cmany_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.0208033 UTC

[section ""data" . GHC.Base.$fMonadPlusMaybe_closure" {
     GHC.Base.$fMonadPlusMaybe_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Base.$fAlternativeMaybe_closure+1;
         const GHC.Base.$fMonadMaybe_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.$fAlternativeMaybe_$c<|>_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.024865728 UTC

[section ""data" . GHC.Base.liftA3_$sliftA3_closure" {
     GHC.Base.liftA3_$sliftA3_closure:
         const GHC.Base.liftA3_$sliftA3_info;
 },
 GHC.Base.liftA3_$sliftA3_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cgzM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgzN; else goto cgzO;
       cgzN: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftA3_$sliftA3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgzO: // global
           I64[Sp - 32] = block_cgzF_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ugAu; else goto cgzG;
       ugAu: // global
           call _cgzF(R1) args: 0, res: 0, upd: 0;
       cgzG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftA3_$sliftA3_info" {
     GHC.Base.liftA3_$sliftA3_info:
         const GHC.Base.liftA3_$sliftA3_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _cgzF() //  [R1]
         { []
         }
     {offset
       cgzF: // global
           if (R1 & 7 == 1) goto ugAp; else goto cgzK;
       ugAp: // global
           Sp = Sp + 32;
           call _cgAe() args: 0, res: 0, upd: 0;
       cgzK: // global
           I64[Sp] = block_cgzU_info;
           _s8qX::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _s8qX::P64;
           if (R1 & 7 != 0) goto ugAs; else goto cgzW;
       ugAs: // global
           call _cgzU(R1) args: 0, res: 0, upd: 0;
       cgzW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cgzF_info" {
     block_cgzF_info:
         const _cgzF;
         const 3;
         const 30;
 },
 _cgzU() //  [R1]
         { []
         }
     {offset
       cgzU: // global
           if (R1 & 7 == 1) goto ugAq; else goto cgA7;
       ugAq: // global
           Sp = Sp + 32;
           call _cgAe() args: 0, res: 0, upd: 0;
       cgA7: // global
           I64[Sp] = block_cgA5_info;
           _s8qZ::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _s8qZ::P64;
           if (R1 & 7 != 0) goto ugAv; else goto cgA8;
       ugAv: // global
           call _cgA5(R1) args: 0, res: 0, upd: 0;
       cgA8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cgzU_info" {
     block_cgzU_info:
         const _cgzU;
         const 3;
         const 30;
 },
 _cgA5() //  [R1]
         { []
         }
     {offset
       cgA5: // global
           if (R1 & 7 == 1) goto ugAr; else goto cgAj;
       ugAr: // global
           Sp = Sp + 32;
           call _cgAe() args: 0, res: 0, upd: 0;
       cgAj: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cgAm; else goto cgAl;
       cgAm: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgAl: // global
           _s8r1::P64 = P64[R1 + 6];
           I64[Hp - 56] = stg_ap_4_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _s8r1::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cgA5_info" {
     block_cgA5_info:
         const _cgA5;
         const 3;
         const 30;
 },
 _cgAe() //  []
         { []
         }
     {offset
       cgAe: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.036971863 UTC

[section ""data" . GHC.Base.liftA3_closure" {
     GHC.Base.liftA3_closure:
         const GHC.Base.liftA3_info;
 },
 sat_s8r8_entry() //  [R1]
         { []
         }
     {offset
       cgBb: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cgBc; else goto cgBd;
       cgBc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgBd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8r8_info" {
     sat_s8r8_info:
         const sat_s8r8_entry;
         const 4;
         const 15;
 },
 GHC.Base.liftA3_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cgBe: // global
           _s8r7::P64 = R6;
           _s8r6::P64 = R5;
           _s8r5::P64 = R4;
           _s8r4::P64 = R3;
           _s8r3::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgBf; else goto cgBg;
       cgBg: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgBi; else goto cgBh;
       cgBi: // global
           HpAlloc = 48;
           goto cgBf;
       cgBf: // global
           R6 = _s8r7::P64;
           R5 = _s8r6::P64;
           R4 = _s8r5::P64;
           R3 = _s8r4::P64;
           R2 = _s8r3::P64;
           R1 = GHC.Base.liftA3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgBh: // global
           I64[Hp - 40] = sat_s8r8_info;
           P64[Hp - 24] = _s8r3::P64;
           P64[Hp - 16] = _s8r4::P64;
           P64[Hp - 8] = _s8r5::P64;
           P64[Hp] = _s8r6::P64;
           R2 = _s8r3::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 40;
           P64[Sp - 8] = _s8r7::P64;
           Sp = Sp - 24;
           call GHC.Base.<*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftA3_info" {
     GHC.Base.liftA3_info:
         const GHC.Base.liftA3_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.042723799 UTC

[section ""data" . GHC.Base.liftA_$sliftA_closure" {
     GHC.Base.liftA_$sliftA_closure:
         const GHC.Base.liftA_$sliftA_info;
 },
 GHC.Base.liftA_$sliftA_entry() //  [R2, R3]
         { []
         }
     {offset
       cgBA: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fApplicativeMaybe_$cfmap_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftA_$sliftA_info" {
     GHC.Base.liftA_$sliftA_info:
         const GHC.Base.liftA_$sliftA_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.046996569 UTC

[section ""data" . GHC.Base.liftA_closure" {
     GHC.Base.liftA_closure:
         const GHC.Base.liftA_info;
 },
 sat_s8rc_entry() //  [R1]
         { []
         }
     {offset
       cgBP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cgBQ; else goto cgBR;
       cgBQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgBR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8rc_info" {
     sat_s8rc_info:
         const sat_s8rc_entry;
         const 2;
         const 18;
 },
 GHC.Base.liftA_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cgBS: // global
           _s8rb::P64 = R4;
           _s8ra::P64 = R3;
           _s8r9::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cgBT; else goto cgBU;
       cgBU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgBW; else goto cgBV;
       cgBW: // global
           HpAlloc = 32;
           goto cgBT;
       cgBT: // global
           R4 = _s8rb::P64;
           R3 = _s8ra::P64;
           R2 = _s8r9::P64;
           R1 = GHC.Base.liftA_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgBV: // global
           I64[Hp - 24] = sat_s8rc_info;
           P64[Hp - 8] = _s8r9::P64;
           P64[Hp] = _s8ra::P64;
           R2 = _s8r9::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _s8rb::P64;
           Sp = Sp - 24;
           call GHC.Base.<*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftA_info" {
     GHC.Base.liftA_info:
         const GHC.Base.liftA_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.054048074 UTC

[section ""data" . GHC.Base.$fFunctor(,)_$cfmap_closure" {
     GHC.Base.$fFunctor(,)_$cfmap_closure:
         const GHC.Base.$fFunctor(,)_$cfmap_info;
 },
 GHC.Base.$fFunctor(,)_$cfmap_entry() //  [R2, R3]
         { []
         }
     {offset
       cgCf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgCk; else goto cgCl;
       cgCk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctor(,)_$cfmap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgCl: // global
           I64[Sp - 16] = block_cgCc_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ugCp; else goto cgCd;
       ugCp: // global
           call _cgCc(R1) args: 0, res: 0, upd: 0;
       cgCd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fFunctor(,)_$cfmap_info" {
     GHC.Base.$fFunctor(,)_$cfmap_info:
         const GHC.Base.$fFunctor(,)_$cfmap_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cgCc() //  [R1]
         { []
         }
     {offset
       cgCc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgCo; else goto cgCn;
       cgCo: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cgCn: // global
           _s8rg::P64 = P64[R1 + 7];
           _s8rh::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _s8rh::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _s8rg::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cgCc_info" {
     block_cgCc_info:
         const _cgCc;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.059332887 UTC

[section ""data" . GHC.Base.$fFunctor(,)_closure" {
     GHC.Base.$fFunctor(,)_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fFunctor(,)_$cfmap_closure+2;
         const GHC.Base.$fFunctor(,)_$c<$_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.064710643 UTC

[section ""data" . GHC.Base.$fApplicative(,)_closure" {
     GHC.Base.$fApplicative(,)_closure:
         const GHC.Base.$fApplicative(,)_info;
 },
 lvl3_s8rk_entry() //  [R1]
         { []
         }
     {offset
       cgCL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgCM; else goto cgCN;
       cgCM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgCN: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl3_s8rk_info" {
     lvl3_s8rk_info:
         const lvl3_s8rk_entry;
         const 1;
         const 16;
 },
 sat_s8rq_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cgCT: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fApplicative(,)_$c<*_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8rq_info" {
     sat_s8rq_info:
         const sat_s8rq_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8rp_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cgD1: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fApplicative(,)_$c*>_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8rp_info" {
     sat_s8rp_info:
         const sat_s8rp_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8ro_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cgD9: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fApplicative(,)_$cliftA2_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8ro_info" {
     sat_s8ro_info:
         const sat_s8ro_entry;
         const 1;
         const 9;
         const 12884901911;
 },
 sat_s8rn_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cgDh: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fApplicative(,)_$c<*>_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8rn_info" {
     sat_s8rn_info:
         const sat_s8rn_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8rm_entry() //  [R1, R2]
         { []
         }
     {offset
       cgDq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgDu; else goto cgDt;
       cgDu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgDt: // global
           _s8rk::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _s8rk::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8rm_info" {
     sat_s8rm_info:
         const sat_s8rm_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 GHC.Base.$fApplicative(,)_entry() //  [R2]
         { []
         }
     {offset
       cgDw: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto cgDA; else goto cgDz;
       cgDA: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgDz: // global
           I64[Hp - 152] = lvl3_s8rk_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_s8rq_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s8rp_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_s8ro_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s8rn_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s8rm_info;
           P64[Hp - 56] = Hp - 152;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = GHC.Base.$fFunctor(,)_closure+1;
           P64[Hp - 32] = Hp - 63;
           P64[Hp - 24] = Hp - 78;
           P64[Hp - 16] = Hp - 93;
           P64[Hp - 8] = Hp - 110;
           P64[Hp] = Hp - 126;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative(,)_info" {
     GHC.Base.$fApplicative(,)_info:
         const GHC.Base.$fApplicative(,)_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.078217718 UTC

[section ""data" . lvl2_r7PL_closure" {
     lvl2_r7PL_closure:
         const lvl2_r7PL_info;
         const 0;
 },
 lvl2_r7PL_entry() //  [R2]
         { []
         }
     {offset
       cgEa: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . lvl2_r7PL_info" {
     lvl2_r7PL_info:
         const lvl2_r7PL_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const S8R0_srt+72;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.083595756 UTC

[section ""data" . GHC.Base.$fMonad(,)_closure" {
     GHC.Base.$fMonad(,)_closure:
         const GHC.Base.$fMonad(,)_info;
         const 0;
 },
 lvl3_s8rt_entry() //  [R1]
         { []
         }
     {offset
       cgEp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgEq; else goto cgEr;
       cgEq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgEr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl3_s8rt_info" {
     lvl3_s8rt_info:
         const lvl3_s8rt_entry;
         const 1;
         const 16;
 },
 sat_s8ry_entry() //  [R1, R2]
         { []
         }
     {offset
       cgEy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgEC; else goto cgEB;
       cgEC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgEB: // global
           _s8rt::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _s8rt::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8ry_info" {
     sat_s8ry_info:
         const sat_s8ry_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_s8rw_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cgEI: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonad(,)_$c>>_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8rw_info" {
     sat_s8rw_info:
         const sat_s8rw_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8rv_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cgEQ: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonad(,)_$c>>=_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_s8rv_info" {
     sat_s8rv_info:
         const sat_s8rv_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_s8ru_entry() //  [R1]
         { []
         }
     {offset
       cgEX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cgEY; else goto cgEZ;
       cgEY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cgEZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fApplicative(,)_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_s8ru_info" {
     sat_s8ru_info:
         const sat_s8ru_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fMonad(,)_entry() //  [R2]
         { []
         }
     {offset
       cgF1: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto cgF5; else goto cgF4;
       cgF5: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = GHC.Base.$fMonad(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgF4: // global
           I64[Hp - 136] = lvl3_s8rt_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_s8ry_info;
           P64[Hp - 104] = Hp - 136;
           I64[Hp - 96] = sat_s8rw_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_s8rv_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_s8ru_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 78;
           P64[Hp - 16] = Hp - 94;
           P64[Hp - 8] = Hp - 111;
           P64[Hp] = lvl2_r7PL_closure+1;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonad(,)_info" {
     GHC.Base.$fMonad(,)_info:
         const GHC.Base.$fMonad(,)_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const S8R0_srt+144;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.096628385 UTC

[section ""data" . GHC.Base.C:Monad_closure" {
     GHC.Base.C:Monad_closure:
         const GHC.Base.C:Monad_info;
 },
 GHC.Base.C:Monad_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cgFD: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgFH; else goto cgFG;
       cgFH: // global
           HpAlloc = 48;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Monad_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgFG: // global
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Monad_info" {
     GHC.Base.C:Monad_info:
         const GHC.Base.C:Monad_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.100634481 UTC

[section ""data" . GHC.Base.C:Functor_closure" {
     GHC.Base.C:Functor_closure:
         const GHC.Base.C:Functor_info;
 },
 GHC.Base.C:Functor_entry() //  [R2, R3]
         { []
         }
     {offset
       cgFS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgFW; else goto cgFV;
       cgFW: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Functor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgFV: // global
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Functor_info" {
     GHC.Base.C:Functor_info:
         const GHC.Base.C:Functor_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.105483033 UTC

[section ""data" . GHC.Base.C:Applicative_closure" {
     GHC.Base.C:Applicative_closure:
         const GHC.Base.C:Applicative_info;
 },
 GHC.Base.C:Applicative_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cgG7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cgGb; else goto cgGa;
       cgGb: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Applicative_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cgGa: // global
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Applicative_info" {
     GHC.Base.C:Applicative_info:
         const GHC.Base.C:Applicative_entry;
         const 0;
         const 14;
         const 25769803802;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.109638896 UTC

[section ""data" . GHC.Base.C:Semigroup_closure" {
     GHC.Base.C:Semigroup_closure:
         const GHC.Base.C:Semigroup_info;
 },
 GHC.Base.C:Semigroup_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cgGn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cgGr; else goto cgGq;
       cgGr: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Semigroup_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgGq: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Semigroup_info" {
     GHC.Base.C:Semigroup_info:
         const GHC.Base.C:Semigroup_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.113613399 UTC

[section ""data" . GHC.Base.C:Monoid_closure" {
     GHC.Base.C:Monoid_closure:
         const GHC.Base.C:Monoid_info;
 },
 GHC.Base.C:Monoid_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cgGC: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgGG; else goto cgGF;
       cgGG: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Monoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgGF: // global
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Monoid_info" {
     GHC.Base.C:Monoid_info:
         const GHC.Base.C:Monoid_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.117153788 UTC

[section ""data" . GHC.Base.Nothing_closure" {
     GHC.Base.Nothing_closure:
         const GHC.Base.Nothing_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.120548595 UTC

[section ""data" . GHC.Base.Just_closure" {
     GHC.Base.Just_closure:
         const GHC.Base.Just_info;
 },
 GHC.Base.Just_entry() //  [R2]
         { []
         }
     {offset
       cgGS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgGW; else goto cgGV;
       cgGW: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Base.Just_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgGV: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.Just_info" {
     GHC.Base.Just_info:
         const GHC.Base.Just_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.124599675 UTC

[section ""data" . GHC.Base.O_closure" {
     GHC.Base.O_closure:
         const GHC.Base.O_info;
 },
 GHC.Base.O_entry() //  [R2]
         { []
         }
     {offset
       cgH7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cgHb; else goto cgHa;
       cgHb: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Base.O_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cgHa: // global
           I64[Hp - 8] = GHC.Base.O_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.O_info" {
     GHC.Base.O_info:
         const GHC.Base.O_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.128489229 UTC

[section ""data" . GHC.Base.:|_closure" {
     GHC.Base.:|_closure:
         const GHC.Base.:|_info;
 },
 GHC.Base.:|_entry() //  [R2, R3]
         { []
         }
     {offset
       cgHm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cgHq; else goto cgHp;
       cgHq: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.:|_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cgHp: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.:|_info" {
     GHC.Base.:|_info:
         const GHC.Base.:|_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.133114081 UTC

[section ""data" . GHC.Base.C:MonadPlus_closure" {
     GHC.Base.C:MonadPlus_closure:
         const GHC.Base.C:MonadPlus_info;
 },
 GHC.Base.C:MonadPlus_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cgHB: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cgHF; else goto cgHE;
       cgHF: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:MonadPlus_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgHE: // global
           I64[Hp - 32] = GHC.Base.C:MonadPlus_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:MonadPlus_info" {
     GHC.Base.C:MonadPlus_info:
         const GHC.Base.C:MonadPlus_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.137913882 UTC

[section ""data" . GHC.Base.C:Alternative_closure" {
     GHC.Base.C:Alternative_closure:
         const GHC.Base.C:Alternative_info;
 },
 GHC.Base.C:Alternative_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cgHQ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cgHU; else goto cgHT;
       cgHU: // global
           HpAlloc = 48;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Alternative_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cgHT: // global
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Alternative_info" {
     GHC.Base.C:Alternative_info:
         const GHC.Base.C:Alternative_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.141759553 UTC

[section ""cstring" . id02_str" {
     id02_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,77,111,110,97,100]
 },
 GHC.Base.C:Monad_con_entry() //  [R1]
         { []
         }
     {offset
       cgI0: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Monad_con_info" {
     GHC.Base.C:Monad_con_info:
         const GHC.Base.C:Monad_con_entry;
         const 5;
         const 1;
         const id02_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.144871458 UTC

[section ""cstring" . id04_str" {
     id04_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,70,117,110,99,116,111,114]
 },
 GHC.Base.C:Functor_con_entry() //  [R1]
         { []
         }
     {offset
       cgI6: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Functor_con_info" {
     GHC.Base.C:Functor_con_info:
         const GHC.Base.C:Functor_con_entry;
         const 2;
         const 4;
         const id04_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.148630327 UTC

[section ""cstring" . id06_str" {
     id06_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,65,112,112,108,105,99,97,116,105,118,101]
 },
 GHC.Base.C:Applicative_con_entry() //  [R1]
         { []
         }
     {offset
       cgIc: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Applicative_con_info" {
     GHC.Base.C:Applicative_con_info:
         const GHC.Base.C:Applicative_con_entry;
         const 6;
         const 1;
         const id06_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.151965533 UTC

[section ""cstring" . id08_str" {
     id08_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,83,101,109,105,103,114,111,117,112]
 },
 GHC.Base.C:Semigroup_con_entry() //  [R1]
         { []
         }
     {offset
       cgIi: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Semigroup_con_info" {
     GHC.Base.C:Semigroup_con_info:
         const GHC.Base.C:Semigroup_con_entry;
         const 3;
         const 1;
         const id08_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.155199194 UTC

[section ""cstring" . id0a_str" {
     id0a_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,77,111,110,111,105,100]
 },
 GHC.Base.C:Monoid_con_entry() //  [R1]
         { []
         }
     {offset
       cgIo: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Monoid_con_info" {
     GHC.Base.C:Monoid_con_info:
         const GHC.Base.C:Monoid_con_entry;
         const 4;
         const 1;
         const id0a_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.158446499 UTC

[section ""cstring" . id0c_str" {
     id0c_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,78,111,116,104,105,110,103]
 },
 GHC.Base.Nothing_con_entry() //  [R1]
         { []
         }
     {offset
       cgIu: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.Nothing_con_info" {
     GHC.Base.Nothing_con_info:
         const GHC.Base.Nothing_con_entry;
         const 4294967296;
         const 3;
         const id0c_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.162295939 UTC

[section ""cstring" . id0e_str" {
     id0e_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,74,117,115,116]
 },
 GHC.Base.Just_con_entry() //  [R1]
         { []
         }
     {offset
       cgIA: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.Just_con_info" {
     GHC.Base.Just_con_info:
         const GHC.Base.Just_con_entry;
         const 1;
         const 4294967298;
         const id0e_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.166113737 UTC

[section ""cstring" . id0g_str" {
     id0g_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,79]
 },
 GHC.Base.O_con_entry() //  [R1]
         { []
         }
     {offset
       cgIG: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.O_con_info" {
     GHC.Base.O_con_info:
         const GHC.Base.O_con_entry;
         const 1;
         const 2;
         const id0g_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.16936338 UTC

[section ""cstring" . id0i_str" {
     id0i_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,58,124]
 },
 GHC.Base.:|_con_entry() //  [R1]
         { []
         }
     {offset
       cgIM: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.:|_con_info" {
     GHC.Base.:|_con_info:
         const GHC.Base.:|_con_entry;
         const 2;
         const 4;
         const id0i_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.172682199 UTC

[section ""cstring" . id0k_str" {
     id0k_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,77,111,110,97,100,80,108,117,115]
 },
 GHC.Base.C:MonadPlus_con_entry() //  [R1]
         { []
         }
     {offset
       cgIS: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:MonadPlus_con_info" {
     GHC.Base.C:MonadPlus_con_info:
         const GHC.Base.C:MonadPlus_con_entry;
         const 4;
         const 1;
         const id0k_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.176646716 UTC

[section ""cstring" . id0m_str" {
     id0m_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,65,108,116,101,114,110,97,116,105,118,101]
 },
 GHC.Base.C:Alternative_con_entry() //  [R1]
         { []
         }
     {offset
       cgIY: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Alternative_con_info" {
     GHC.Base.C:Alternative_con_info:
         const GHC.Base.C:Alternative_con_entry;
         const 5;
         const 1;
         const id0m_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:47.180615731 UTC

[section ""relreadonly" . S8R0_srt" {
     S8R0_srt:
         const GHC.Base.$fSemigroupIO_$cstimes_closure;
         const GHC.Base.$fSemigroupIO_closure;
         const Data.Semigroup.Internal.stimesDefault_closure;
         const GHC.Base.$fMonoidIO_$cp1Monoid_closure;
         const GHC.IO.mplusIO_closure;
         const GHC.Base.$fAlternativeIO2_closure;
         const GHC.Base.$fAlternativeIO_$cmany_closure;
         const GHC.Base.$fSemigroupNonEmpty_closure;
         const GHC.Base.$fMonoidIO_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.IO.failIO_closure;
         const Data.Semigroup.Internal.stimesMaybe_closure;
         const GHC.Base.$fSemigroupMaybe_closure;
         const GHC.Base.$fMonoidMaybe_closure;
         const Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
         const GHC.Base.$fMonoidOrdering_closure;
         const Data.Semigroup.Internal.stimesList_closure;
         const GHC.Base.$fAlternativeIO3_closure;
         const GHC.Base.$fMonad(,)_closure;
         const lvl2_r7PL_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.264047785 UTC

[]


==================== Raw Cmm ====================
2018-03-16 15:54:56.265894384 UTC

[section ""data" . GHC.Base.$p1Monad_closure" {
     GHC.Base.$p1Monad_closure:
         const GHC.Base.$p1Monad_info;
 },
 GHC.Base.$p1Monad_entry() //  [R2]
         { []
         }
     {offset
       chkY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chkZ; else goto chl0;
       chkZ: // global
           R2 = R2;
           R1 = GHC.Base.$p1Monad_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chl0: // global
           I64[Sp - 8] = block_chkV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhl4; else goto chkW;
       uhl4: // global
           call _chkV(R1) args: 0, res: 0, upd: 0;
       chkW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$p1Monad_info" {
     GHC.Base.$p1Monad_info:
         const GHC.Base.$p1Monad_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chkV() //  [R1]
         { []
         }
     {offset
       chkV: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chkV_info" {
     block_chkV_info:
         const _chkV;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.271114956 UTC

[section ""data" . GHC.Base.>>=_closure" {
     GHC.Base.>>=_closure:
         const GHC.Base.>>=_info;
 },
 GHC.Base.>>=_entry() //  [R2]
         { []
         }
     {offset
       chlo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chlp; else goto chlq;
       chlp: // global
           R2 = R2;
           R1 = GHC.Base.>>=_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chlq: // global
           I64[Sp - 8] = block_chll_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhlu; else goto chlm;
       uhlu: // global
           call _chll(R1) args: 0, res: 0, upd: 0;
       chlm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.>>=_info" {
     GHC.Base.>>=_info:
         const GHC.Base.>>=_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chll() //  [R1]
         { []
         }
     {offset
       chll: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chll_info" {
     block_chll_info:
         const _chll;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.276313853 UTC

[section ""data" . GHC.Base.>>_closure" {
     GHC.Base.>>_closure:
         const GHC.Base.>>_info;
 },
 GHC.Base.>>_entry() //  [R2]
         { []
         }
     {offset
       chlM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chlN; else goto chlO;
       chlN: // global
           R2 = R2;
           R1 = GHC.Base.>>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chlO: // global
           I64[Sp - 8] = block_chlJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhlS; else goto chlK;
       uhlS: // global
           call _chlJ(R1) args: 0, res: 0, upd: 0;
       chlK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.>>_info" {
     GHC.Base.>>_info:
         const GHC.Base.>>_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chlJ() //  [R1]
         { []
         }
     {offset
       chlJ: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chlJ_info" {
     block_chlJ_info:
         const _chlJ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.281560586 UTC

[section ""data" . GHC.Base.return_closure" {
     GHC.Base.return_closure:
         const GHC.Base.return_info;
 },
 GHC.Base.return_entry() //  [R2]
         { []
         }
     {offset
       chma: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chmb; else goto chmc;
       chmb: // global
           R2 = R2;
           R1 = GHC.Base.return_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chmc: // global
           I64[Sp - 8] = block_chm7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhmg; else goto chm8;
       uhmg: // global
           call _chm7(R1) args: 0, res: 0, upd: 0;
       chm8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.return_info" {
     GHC.Base.return_info:
         const GHC.Base.return_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chm7() //  [R1]
         { []
         }
     {offset
       chm7: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chm7_info" {
     block_chm7_info:
         const _chm7;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.304134154 UTC

[section ""data" . GHC.Base.fail_closure" {
     GHC.Base.fail_closure:
         const GHC.Base.fail_info;
 },
 GHC.Base.fail_entry() //  [R2]
         { []
         }
     {offset
       chmy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chmz; else goto chmA;
       chmz: // global
           R2 = R2;
           R1 = GHC.Base.fail_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chmA: // global
           I64[Sp - 8] = block_chmv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhmE; else goto chmw;
       uhmE: // global
           call _chmv(R1) args: 0, res: 0, upd: 0;
       chmw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.fail_info" {
     GHC.Base.fail_info:
         const GHC.Base.fail_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chmv() //  [R1]
         { []
         }
     {offset
       chmv: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chmv_info" {
     block_chmv_info:
         const _chmv;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.309710557 UTC

[section ""data" . GHC.Base.fmap_closure" {
     GHC.Base.fmap_closure:
         const GHC.Base.fmap_info;
 },
 GHC.Base.fmap_entry() //  [R2]
         { []
         }
     {offset
       chmW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chmX; else goto chmY;
       chmX: // global
           R2 = R2;
           R1 = GHC.Base.fmap_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chmY: // global
           I64[Sp - 8] = block_chmT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhn2; else goto chmU;
       uhn2: // global
           call _chmT(R1) args: 0, res: 0, upd: 0;
       chmU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.fmap_info" {
     GHC.Base.fmap_info:
         const GHC.Base.fmap_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chmT() //  [R1]
         { []
         }
     {offset
       chmT: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chmT_info" {
     block_chmT_info:
         const _chmT;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.314937576 UTC

[section ""data" . GHC.Base.<$_closure" {
     GHC.Base.<$_closure:
         const GHC.Base.<$_info;
 },
 GHC.Base.<$_entry() //  [R2]
         { []
         }
     {offset
       chnk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chnl; else goto chnm;
       chnl: // global
           R2 = R2;
           R1 = GHC.Base.<$_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chnm: // global
           I64[Sp - 8] = block_chnh_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhnq; else goto chni;
       uhnq: // global
           call _chnh(R1) args: 0, res: 0, upd: 0;
       chni: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.<$_info" {
     GHC.Base.<$_info:
         const GHC.Base.<$_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chnh() //  [R1]
         { []
         }
     {offset
       chnh: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chnh_info" {
     block_chnh_info:
         const _chnh;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.320336068 UTC

[section ""data" . GHC.Base.$p1Applicative_closure" {
     GHC.Base.$p1Applicative_closure:
         const GHC.Base.$p1Applicative_info;
 },
 GHC.Base.$p1Applicative_entry() //  [R2]
         { []
         }
     {offset
       chnI: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chnJ; else goto chnK;
       chnJ: // global
           R2 = R2;
           R1 = GHC.Base.$p1Applicative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chnK: // global
           I64[Sp - 8] = block_chnF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhnO; else goto chnG;
       uhnO: // global
           call _chnF(R1) args: 0, res: 0, upd: 0;
       chnG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$p1Applicative_info" {
     GHC.Base.$p1Applicative_info:
         const GHC.Base.$p1Applicative_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chnF() //  [R1]
         { []
         }
     {offset
       chnF: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chnF_info" {
     block_chnF_info:
         const _chnF;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.325598983 UTC

[section ""data" . GHC.Base.pure_closure" {
     GHC.Base.pure_closure:
         const GHC.Base.pure_info;
 },
 GHC.Base.pure_entry() //  [R2]
         { []
         }
     {offset
       cho8: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cho9; else goto choa;
       cho9: // global
           R2 = R2;
           R1 = GHC.Base.pure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       choa: // global
           I64[Sp - 8] = block_cho5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhoe; else goto cho6;
       uhoe: // global
           call _cho5(R1) args: 0, res: 0, upd: 0;
       cho6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.pure_info" {
     GHC.Base.pure_info:
         const GHC.Base.pure_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cho5() //  [R1]
         { []
         }
     {offset
       cho5: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cho5_info" {
     block_cho5_info:
         const _cho5;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.330793065 UTC

[section ""data" . GHC.Base.<*>_closure" {
     GHC.Base.<*>_closure:
         const GHC.Base.<*>_info;
 },
 GHC.Base.<*>_entry() //  [R2]
         { []
         }
     {offset
       chow: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chox; else goto choy;
       chox: // global
           R2 = R2;
           R1 = GHC.Base.<*>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       choy: // global
           I64[Sp - 8] = block_chot_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhoC; else goto chou;
       uhoC: // global
           call _chot(R1) args: 0, res: 0, upd: 0;
       chou: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.<*>_info" {
     GHC.Base.<*>_info:
         const GHC.Base.<*>_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chot() //  [R1]
         { []
         }
     {offset
       chot: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chot_info" {
     block_chot_info:
         const _chot;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.336987862 UTC

[section ""data" . GHC.Base.liftA2_closure" {
     GHC.Base.liftA2_closure:
         const GHC.Base.liftA2_info;
 },
 GHC.Base.liftA2_entry() //  [R2]
         { []
         }
     {offset
       choU: // global
           if ((Sp + -8) < SpLim) (likely: False) goto choV; else goto choW;
       choV: // global
           R2 = R2;
           R1 = GHC.Base.liftA2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       choW: // global
           I64[Sp - 8] = block_choR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhp0; else goto choS;
       uhp0: // global
           call _choR(R1) args: 0, res: 0, upd: 0;
       choS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftA2_info" {
     GHC.Base.liftA2_info:
         const GHC.Base.liftA2_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _choR() //  [R1]
         { []
         }
     {offset
       choR: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_choR_info" {
     block_choR_info:
         const _choR;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.342285774 UTC

[section ""data" . GHC.Base.*>_closure" {
     GHC.Base.*>_closure:
         const GHC.Base.*>_info;
 },
 GHC.Base.*>_entry() //  [R2]
         { []
         }
     {offset
       chpi: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chpj; else goto chpk;
       chpj: // global
           R2 = R2;
           R1 = GHC.Base.*>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chpk: // global
           I64[Sp - 8] = block_chpf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhpo; else goto chpg;
       uhpo: // global
           call _chpf(R1) args: 0, res: 0, upd: 0;
       chpg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.*>_info" {
     GHC.Base.*>_info:
         const GHC.Base.*>_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chpf() //  [R1]
         { []
         }
     {offset
       chpf: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chpf_info" {
     block_chpf_info:
         const _chpf;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.347593254 UTC

[section ""data" . GHC.Base.<*_closure" {
     GHC.Base.<*_closure:
         const GHC.Base.<*_info;
 },
 GHC.Base.<*_entry() //  [R2]
         { []
         }
     {offset
       chpG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chpH; else goto chpI;
       chpH: // global
           R2 = R2;
           R1 = GHC.Base.<*_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chpI: // global
           I64[Sp - 8] = block_chpD_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhpM; else goto chpE;
       uhpM: // global
           call _chpD(R1) args: 0, res: 0, upd: 0;
       chpE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.<*_info" {
     GHC.Base.<*_info:
         const GHC.Base.<*_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chpD() //  [R1]
         { []
         }
     {offset
       chpD: // global
           R1 = P64[R1 + 47];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chpD_info" {
     block_chpD_info:
         const _chpD;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.353128387 UTC

[section ""data" . GHC.Base.<>_closure" {
     GHC.Base.<>_closure:
         const GHC.Base.<>_info;
 },
 GHC.Base.<>_entry() //  [R2]
         { []
         }
     {offset
       chq4: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chq5; else goto chq6;
       chq5: // global
           R2 = R2;
           R1 = GHC.Base.<>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chq6: // global
           I64[Sp - 8] = block_chq1_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhqa; else goto chq2;
       uhqa: // global
           call _chq1(R1) args: 0, res: 0, upd: 0;
       chq2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.<>_info" {
     GHC.Base.<>_info:
         const GHC.Base.<>_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chq1() //  [R1]
         { []
         }
     {offset
       chq1: // global
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chq1_info" {
     block_chq1_info:
         const _chq1;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.358354299 UTC

[section ""data" . GHC.Base.sconcat_closure" {
     GHC.Base.sconcat_closure:
         const GHC.Base.sconcat_info;
 },
 GHC.Base.sconcat_entry() //  [R2]
         { []
         }
     {offset
       chqs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chqt; else goto chqu;
       chqt: // global
           R2 = R2;
           R1 = GHC.Base.sconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chqu: // global
           I64[Sp - 8] = block_chqp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhqy; else goto chqq;
       uhqy: // global
           call _chqp(R1) args: 0, res: 0, upd: 0;
       chqq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.sconcat_info" {
     GHC.Base.sconcat_info:
         const GHC.Base.sconcat_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chqp() //  [R1]
         { []
         }
     {offset
       chqp: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chqp_info" {
     block_chqp_info:
         const _chqp;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.36402446 UTC

[section ""data" . GHC.Base.stimes_closure" {
     GHC.Base.stimes_closure:
         const GHC.Base.stimes_info;
 },
 GHC.Base.stimes_entry() //  [R2]
         { []
         }
     {offset
       chqQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chqR; else goto chqS;
       chqR: // global
           R2 = R2;
           R1 = GHC.Base.stimes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chqS: // global
           I64[Sp - 8] = block_chqN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhqW; else goto chqO;
       uhqW: // global
           call _chqN(R1) args: 0, res: 0, upd: 0;
       chqO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.stimes_info" {
     GHC.Base.stimes_info:
         const GHC.Base.stimes_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chqN() //  [R1]
         { []
         }
     {offset
       chqN: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chqN_info" {
     block_chqN_info:
         const _chqN;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.369348909 UTC

[section ""data" . GHC.Base.$p1Monoid_closure" {
     GHC.Base.$p1Monoid_closure:
         const GHC.Base.$p1Monoid_info;
 },
 GHC.Base.$p1Monoid_entry() //  [R2]
         { []
         }
     {offset
       chre: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chrf; else goto chrg;
       chrf: // global
           R2 = R2;
           R1 = GHC.Base.$p1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chrg: // global
           I64[Sp - 8] = block_chrb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhrk; else goto chrc;
       uhrk: // global
           call _chrb(R1) args: 0, res: 0, upd: 0;
       chrc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$p1Monoid_info" {
     GHC.Base.$p1Monoid_info:
         const GHC.Base.$p1Monoid_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chrb() //  [R1]
         { []
         }
     {offset
       chrb: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chrb_info" {
     block_chrb_info:
         const _chrb;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.375445247 UTC

[section ""data" . GHC.Base.mempty_closure" {
     GHC.Base.mempty_closure:
         const GHC.Base.mempty_info;
 },
 GHC.Base.mempty_entry() //  [R2]
         { []
         }
     {offset
       chrE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chrF; else goto chrG;
       chrF: // global
           R2 = R2;
           R1 = GHC.Base.mempty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chrG: // global
           I64[Sp - 8] = block_chrB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhrK; else goto chrC;
       uhrK: // global
           call _chrB(R1) args: 0, res: 0, upd: 0;
       chrC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.mempty_info" {
     GHC.Base.mempty_info:
         const GHC.Base.mempty_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chrB() //  [R1]
         { []
         }
     {offset
       chrB: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chrB_info" {
     block_chrB_info:
         const _chrB;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.380724961 UTC

[section ""data" . GHC.Base.mappend_closure" {
     GHC.Base.mappend_closure:
         const GHC.Base.mappend_info;
 },
 GHC.Base.mappend_entry() //  [R2]
         { []
         }
     {offset
       chs2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chs3; else goto chs4;
       chs3: // global
           R2 = R2;
           R1 = GHC.Base.mappend_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chs4: // global
           I64[Sp - 8] = block_chrZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhs8; else goto chs0;
       uhs8: // global
           call _chrZ(R1) args: 0, res: 0, upd: 0;
       chs0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.mappend_info" {
     GHC.Base.mappend_info:
         const GHC.Base.mappend_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chrZ() //  [R1]
         { []
         }
     {offset
       chrZ: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chrZ_info" {
     block_chrZ_info:
         const _chrZ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.386147886 UTC

[section ""data" . GHC.Base.mconcat_closure" {
     GHC.Base.mconcat_closure:
         const GHC.Base.mconcat_info;
 },
 GHC.Base.mconcat_entry() //  [R2]
         { []
         }
     {offset
       chsq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chsr; else goto chss;
       chsr: // global
           R2 = R2;
           R1 = GHC.Base.mconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chss: // global
           I64[Sp - 8] = block_chsn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhsw; else goto chso;
       uhsw: // global
           call _chsn(R1) args: 0, res: 0, upd: 0;
       chso: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.mconcat_info" {
     GHC.Base.mconcat_info:
         const GHC.Base.mconcat_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chsn() //  [R1]
         { []
         }
     {offset
       chsn: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chsn_info" {
     block_chsn_info:
         const _chsn;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.391439522 UTC

[section ""data" . GHC.Base.$p1MonadPlus_closure" {
     GHC.Base.$p1MonadPlus_closure:
         const GHC.Base.$p1MonadPlus_info;
 },
 GHC.Base.$p1MonadPlus_entry() //  [R2]
         { []
         }
     {offset
       chsO: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chsP; else goto chsQ;
       chsP: // global
           R2 = R2;
           R1 = GHC.Base.$p1MonadPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chsQ: // global
           I64[Sp - 8] = block_chsL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhsU; else goto chsM;
       uhsU: // global
           call _chsL(R1) args: 0, res: 0, upd: 0;
       chsM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$p1MonadPlus_info" {
     GHC.Base.$p1MonadPlus_info:
         const GHC.Base.$p1MonadPlus_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chsL() //  [R1]
         { []
         }
     {offset
       chsL: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chsL_info" {
     block_chsL_info:
         const _chsL;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.397151558 UTC

[section ""data" . GHC.Base.$p2MonadPlus_closure" {
     GHC.Base.$p2MonadPlus_closure:
         const GHC.Base.$p2MonadPlus_info;
 },
 GHC.Base.$p2MonadPlus_entry() //  [R2]
         { []
         }
     {offset
       chte: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chtf; else goto chtg;
       chtf: // global
           R2 = R2;
           R1 = GHC.Base.$p2MonadPlus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chtg: // global
           I64[Sp - 8] = block_chtb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhtk; else goto chtc;
       uhtk: // global
           call _chtb(R1) args: 0, res: 0, upd: 0;
       chtc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$p2MonadPlus_info" {
     GHC.Base.$p2MonadPlus_info:
         const GHC.Base.$p2MonadPlus_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chtb() //  [R1]
         { []
         }
     {offset
       chtb: // global
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chtb_info" {
     block_chtb_info:
         const _chtb;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.402371189 UTC

[section ""data" . GHC.Base.mzero_closure" {
     GHC.Base.mzero_closure:
         const GHC.Base.mzero_info;
 },
 GHC.Base.mzero_entry() //  [R2]
         { []
         }
     {offset
       chtE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chtF; else goto chtG;
       chtF: // global
           R2 = R2;
           R1 = GHC.Base.mzero_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chtG: // global
           I64[Sp - 8] = block_chtB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhtK; else goto chtC;
       uhtK: // global
           call _chtB(R1) args: 0, res: 0, upd: 0;
       chtC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.mzero_info" {
     GHC.Base.mzero_info:
         const GHC.Base.mzero_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chtB() //  [R1]
         { []
         }
     {offset
       chtB: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chtB_info" {
     block_chtB_info:
         const _chtB;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.408226553 UTC

[section ""data" . GHC.Base.mplus_closure" {
     GHC.Base.mplus_closure:
         const GHC.Base.mplus_info;
 },
 GHC.Base.mplus_entry() //  [R2]
         { []
         }
     {offset
       chu2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chu3; else goto chu4;
       chu3: // global
           R2 = R2;
           R1 = GHC.Base.mplus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chu4: // global
           I64[Sp - 8] = block_chtZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhu8; else goto chu0;
       uhu8: // global
           call _chtZ(R1) args: 0, res: 0, upd: 0;
       chu0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.mplus_info" {
     GHC.Base.mplus_info:
         const GHC.Base.mplus_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chtZ() //  [R1]
         { []
         }
     {offset
       chtZ: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chtZ_info" {
     block_chtZ_info:
         const _chtZ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.414154782 UTC

[section ""data" . GHC.Base.$p1Alternative_closure" {
     GHC.Base.$p1Alternative_closure:
         const GHC.Base.$p1Alternative_info;
 },
 GHC.Base.$p1Alternative_entry() //  [R2]
         { []
         }
     {offset
       chuq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chur; else goto chus;
       chur: // global
           R2 = R2;
           R1 = GHC.Base.$p1Alternative_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chus: // global
           I64[Sp - 8] = block_chun_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhuw; else goto chuo;
       uhuw: // global
           call _chun(R1) args: 0, res: 0, upd: 0;
       chuo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$p1Alternative_info" {
     GHC.Base.$p1Alternative_info:
         const GHC.Base.$p1Alternative_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chun() //  [R1]
         { []
         }
     {offset
       chun: // global
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chun_info" {
     block_chun_info:
         const _chun;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.419527736 UTC

[section ""data" . GHC.Base.empty_closure" {
     GHC.Base.empty_closure:
         const GHC.Base.empty_info;
 },
 GHC.Base.empty_entry() //  [R2]
         { []
         }
     {offset
       chuQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chuR; else goto chuS;
       chuR: // global
           R2 = R2;
           R1 = GHC.Base.empty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chuS: // global
           I64[Sp - 8] = block_chuN_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhuW; else goto chuO;
       uhuW: // global
           call _chuN(R1) args: 0, res: 0, upd: 0;
       chuO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.empty_info" {
     GHC.Base.empty_info:
         const GHC.Base.empty_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chuN() //  [R1]
         { []
         }
     {offset
       chuN: // global
           R1 = P64[R1 + 15];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chuN_info" {
     block_chuN_info:
         const _chuN;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.425301167 UTC

[section ""data" . GHC.Base.<|>_closure" {
     GHC.Base.<|>_closure:
         const GHC.Base.<|>_info;
 },
 GHC.Base.<|>_entry() //  [R2]
         { []
         }
     {offset
       chve: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chvf; else goto chvg;
       chvf: // global
           R2 = R2;
           R1 = GHC.Base.<|>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chvg: // global
           I64[Sp - 8] = block_chvb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhvk; else goto chvc;
       uhvk: // global
           call _chvb(R1) args: 0, res: 0, upd: 0;
       chvc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.<|>_info" {
     GHC.Base.<|>_info:
         const GHC.Base.<|>_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chvb() //  [R1]
         { []
         }
     {offset
       chvb: // global
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chvb_info" {
     block_chvb_info:
         const _chvb;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.430613089 UTC

[section ""data" . GHC.Base.some_closure" {
     GHC.Base.some_closure:
         const GHC.Base.some_info;
 },
 GHC.Base.some_entry() //  [R2]
         { []
         }
     {offset
       chvC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chvD; else goto chvE;
       chvD: // global
           R2 = R2;
           R1 = GHC.Base.some_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chvE: // global
           I64[Sp - 8] = block_chvz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhvI; else goto chvA;
       uhvI: // global
           call _chvz(R1) args: 0, res: 0, upd: 0;
       chvA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.some_info" {
     GHC.Base.some_info:
         const GHC.Base.some_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chvz() //  [R1]
         { []
         }
     {offset
       chvz: // global
           R1 = P64[R1 + 31];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chvz_info" {
     block_chvz_info:
         const _chvz;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.436048718 UTC

[section ""data" . GHC.Base.many_closure" {
     GHC.Base.many_closure:
         const GHC.Base.many_info;
 },
 GHC.Base.many_entry() //  [R2]
         { []
         }
     {offset
       chw0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chw1; else goto chw2;
       chw1: // global
           R2 = R2;
           R1 = GHC.Base.many_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chw2: // global
           I64[Sp - 8] = block_chvX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhw6; else goto chvY;
       uhw6: // global
           call _chvX(R1) args: 0, res: 0, upd: 0;
       chvY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.many_info" {
     GHC.Base.many_info:
         const GHC.Base.many_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chvX() //  [R1]
         { []
         }
     {offset
       chvX: // global
           R1 = P64[R1 + 39];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chvX_info" {
     block_chvX_info:
         const _chvX;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.443754308 UTC

[section ""data" . GHC.Base.eqString_closure" {
     GHC.Base.eqString_closure:
         const GHC.Base.eqString_info;
 },
 GHC.Base.eqString_entry() //  [R2, R3]
         { []
         }
     {offset
       chws: // global
           if ((Sp + -32) < SpLim) (likely: False) goto chwt; else goto uhxi;
       chwt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.eqString_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uhxi: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _chwi() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Base.eqString_info" {
     GHC.Base.eqString_info:
         const GHC.Base.eqString_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _chwi() //  []
         { []
         }
     {offset
       chwi: // global
           _sgM8::P64 = P64[Sp];
           I64[Sp] = block_chwl_info;
           R1 = _sgM8::P64;
           if (R1 & 7 != 0) goto uhxn; else goto chwm;
       uhxn: // global
           call _chwl(R1) args: 0, res: 0, upd: 0;
       chwm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _chwl() //  [R1]
         { []
         }
     {offset
       chwl: // global
           _sgM9::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto chwp; else goto chwq;
       chwp: // global
           I64[Sp + 8] = block_chwx_info;
           R1 = _sgM9::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uhxo; else goto chwz;
       uhxo: // global
           call _chwx(R1) args: 0, res: 0, upd: 0;
       chwz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       chwq: // global
           I64[Sp - 8] = block_chwM_info;
           _sgMe::P64 = P64[R1 + 6];
           _sgMf::P64 = P64[R1 + 14];
           R1 = _sgM9::P64;
           P64[Sp] = _sgMf::P64;
           P64[Sp + 8] = _sgMe::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhxp; else goto chwO;
       uhxp: // global
           call _chwM(R1) args: 0, res: 0, upd: 0;
       chwO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chwl_info" {
     block_chwl_info:
         const _chwl;
         const 1;
         const 30;
 },
 _chwx() //  [R1]
         { []
         }
     {offset
       chwx: // global
           if (R1 & 7 == 1) goto chwF; else goto uhxm;
       chwF: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uhxm: // global
           Sp = Sp + 8;
           call _chxe() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_chwx_info" {
     block_chwx_info:
         const _chwx;
         const 0;
         const 30;
 },
 _chwM() //  [R1]
         { []
         }
     {offset
       chwM: // global
           if (R1 & 7 == 1) goto uhxj; else goto chx4;
       uhxj: // global
           Sp = Sp + 24;
           call _chxe() args: 0, res: 0, upd: 0;
       chx4: // global
           I64[Sp - 8] = block_chwX_info;
           _sgMh::P64 = P64[R1 + 6];
           _sgMi::P64 = P64[R1 + 14];
           R1 = P64[Sp + 16];
           P64[Sp] = _sgMi::P64;
           P64[Sp + 16] = _sgMh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uhxs; else goto chwY;
       uhxs: // global
           call _chwX(R1) args: 0, res: 0, upd: 0;
       chwY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chwM_info" {
     block_chwM_info:
         const _chwM;
         const 2;
         const 30;
 },
 _chwX() //  [R1]
         { []
         }
     {offset
       chwX: // global
           I64[Sp] = block_chx2_info;
           _sgMk::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sgMk::I64;
           if (R1 & 7 != 0) goto uhxu; else goto chx6;
       uhxu: // global
           call _chx2(R1) args: 0, res: 0, upd: 0;
       chx6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chwX_info" {
     block_chwX_info:
         const _chwX;
         const 3;
         const 30;
 },
 _chx2() //  [R1]
         { []
         }
     {offset
       chx2: // global
           if (I64[Sp + 24] == I64[R1 + 7]) goto chxf; else goto uhxk;
       chxf: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _chwi() args: 0, res: 0, upd: 0;
       uhxk: // global
           Sp = Sp + 32;
           call _chxe() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_chx2_info" {
     block_chx2_info:
         const _chx2;
         const 259;
         const 30;
 },
 _chxe() //  []
         { []
         }
     {offset
       chxe: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.458194565 UTC

[section ""data" . GHC.Base.when2_closure" {
     GHC.Base.when2_closure:
         const GHC.Base.when2_info;
 },
 GHC.Base.when2_entry() //  [R2, R3]
         { []
         }
     {offset
       chyt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chyu; else goto chyv;
       chyu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.when2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chyv: // global
           I64[Sp - 16] = block_chym_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uhyC; else goto chyn;
       uhyC: // global
           call _chym(R1) args: 0, res: 0, upd: 0;
       chyn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.when2_info" {
     GHC.Base.when2_info:
         const GHC.Base.when2_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _chym() //  [R1]
         { []
         }
     {offset
       chym: // global
           if (R1 & 7 == 1) goto chyq; else goto chyr;
       chyq: // global
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       chyr: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chym_info" {
     block_chym_info:
         const _chym;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.463407447 UTC

[section ""data" . GHC.Base.when_$swhen1_closure" {
     GHC.Base.when_$swhen1_closure:
         const GHC.Base.when_$swhen1_info;
 },
 GHC.Base.when_$swhen1_entry() //  [R2, R3]
         { []
         }
     {offset
       chyV: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.when2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.when_$swhen1_info" {
     GHC.Base.when_$swhen1_info:
         const GHC.Base.when_$swhen1_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.467139236 UTC

[section ""data" . GHC.Base.$fFunctorIO2_closure" {
     GHC.Base.$fFunctorIO2_closure:
         const GHC.Base.$fFunctorIO2_info;
 },
 GHC.Base.$fFunctorIO2_entry() //  [R2, R3]
         { []
         }
     {offset
       chz9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chza; else goto chzb;
       chza: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorIO2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chzb: // global
           I64[Sp - 16] = block_chz6_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fFunctorIO2_info" {
     GHC.Base.$fFunctorIO2_info:
         const GHC.Base.$fFunctorIO2_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _chz6() //  [R1]
         { []
         }
     {offset
       chz6: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto chze; else goto chzd;
       chze: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chzd: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chz6_info" {
     block_chz6_info:
         const _chz6;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.472622026 UTC

[section ""data" . GHC.Base.$fFunctorIO1_closure" {
     GHC.Base.$fFunctorIO1_closure:
         const GHC.Base.$fFunctorIO1_info;
 },
 GHC.Base.$fFunctorIO1_entry() //  [R2, R3]
         { []
         }
     {offset
       chzx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chzy; else goto chzz;
       chzy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chzz: // global
           I64[Sp - 16] = block_chzv_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fFunctorIO1_info" {
     GHC.Base.$fFunctorIO1_info:
         const GHC.Base.$fFunctorIO1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _chzv() //  []
         { []
         }
     {offset
       chzv: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chzv_info" {
     block_chzv_info:
         const _chzv;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.47767614 UTC

[section ""data" . GHC.Base.$fFunctorIO_closure" {
     GHC.Base.$fFunctorIO_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fFunctorIO2_closure+3;
         const GHC.Base.$fFunctorIO1_closure+3;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.479312568 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe1_closure" {
     GHC.Base.$fAlternativeMaybe1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.483372866 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_$cmany_closure" {
     GHC.Base.$fAlternativeMaybe_$cmany_closure:
         const GHC.Base.$fAlternativeMaybe_$cmany_info;
 },
 many_v_sgMG_entry() //  [R1]
         { []
         }
     {offset
       chA2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto chA3; else goto chA4;
       chA3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       chA4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_chzV_info;
           _sgMG::P64 = R1;
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sgMG::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uhAw; else goto chzW;
       uhAw: // global
           call _chzV(R1) args: 0, res: 0, upd: 0;
       chzW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . many_v_sgMG_info" {
     many_v_sgMG_info:
         const many_v_sgMG_entry;
         const 1;
         const 16;
 },
 _chzV() //  [R1]
         { []
         }
     {offset
       chzV: // global
           if (R1 & 7 == 1) goto uhAs; else goto chA0;
       uhAs: // global
           Sp = Sp + 16;
           call _chAi() args: 0, res: 0, upd: 0;
       chA0: // global
           I64[Sp] = block_chAa_info;
           _sgMI::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sgMI::P64;
           if (R1 & 7 != 0) goto uhAu; else goto chAc;
       uhAu: // global
           call _chAa(R1) args: 0, res: 0, upd: 0;
       chAc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_chzV_info" {
     block_chzV_info:
         const _chzV;
         const 1;
         const 30;
 },
 _chAa() //  [R1]
         { []
         }
     {offset
       chAa: // global
           if (R1 & 7 == 1) goto uhAt; else goto chAn;
       uhAt: // global
           Sp = Sp + 16;
           call _chAi() args: 0, res: 0, upd: 0;
       chAn: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto chAq; else goto chAp;
       chAq: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       chAp: // global
           _sgMK::P64 = P64[R1 + 6];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sgMK::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_chAa_info" {
     block_chAa_info:
         const _chAa;
         const 1;
         const 30;
 },
 _chAi() //  []
         { []
         }
     {offset
       chAi: // global
           R1 = GHC.Base.$fAlternativeMaybe1_closure+2;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 GHC.Base.$fAlternativeMaybe_$cmany_entry() //  [R2]
         { []
         }
     {offset
       chAy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto chAC; else goto chAB;
       chAC: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeMaybe_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chAB: // global
           I64[Hp - 16] = many_v_sgMG_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fAlternativeMaybe_$cmany_info" {
     GHC.Base.$fAlternativeMaybe_$cmany_info:
         const GHC.Base.$fAlternativeMaybe_$cmany_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.494480324 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_$csome_closure" {
     GHC.Base.$fAlternativeMaybe_$csome_closure:
         const GHC.Base.$fAlternativeMaybe_$csome_info;
 },
 some_v_sgMN_entry() //  [R1]
         { []
         }
     {offset
       chBq: // global
           if ((Sp + -32) < SpLim) (likely: False) goto chBr; else goto chBs;
       chBr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       chBs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_chBj_info;
           _sgMN::P64 = R1;
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sgMN::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uhBV; else goto chBk;
       uhBV: // global
           call _chBj(R1) args: 0, res: 0, upd: 0;
       chBk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . some_v_sgMN_info" {
     some_v_sgMN_info:
         const some_v_sgMN_entry;
         const 1;
         const 16;
 },
 _chBj() //  [R1]
         { []
         }
     {offset
       chBj: // global
           if (R1 & 7 == 1) goto chBn; else goto chBo;
       chBn: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       chBo: // global
           I64[Sp] = block_chBy_info;
           _sgMP::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sgMP::P64;
           if (R1 & 7 != 0) goto uhBU; else goto chBA;
       uhBU: // global
           call _chBy(R1) args: 0, res: 0, upd: 0;
       chBA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_chBj_info" {
     block_chBj_info:
         const _chBj;
         const 1;
         const 30;
 },
 _chBy() //  [R1]
         { []
         }
     {offset
       chBy: // global
           _sgMP::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto chBH; else goto chBP;
       chBH: // global
           Hp = Hp + 40;
           _sgMQ::P64 = R1;
           if (Hp > HpLim) (likely: False) goto chBS; else goto chBJ;
       chBJ: // global
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = _sgMP::P64;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       chBP: // global
           Hp = Hp + 40;
           _sgMQ::P64 = R1;
           if (Hp > HpLim) (likely: False) goto chBS; else goto chBR;
       chBS: // global
           HpAlloc = 40;
           R1 = _sgMQ::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       chBR: // global
           _sgMS::P64 = P64[_sgMQ::P64 + 6];
           I64[Hp - 32] = :_con_info;
           P64[Hp - 24] = _sgMP::P64;
           P64[Hp - 16] = _sgMS::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 30;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_chBy_info" {
     block_chBy_info:
         const _chBy;
         const 1;
         const 30;
 },
 GHC.Base.$fAlternativeMaybe_$csome_entry() //  [R2]
         { []
         }
     {offset
       chBW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto chC0; else goto chBZ;
       chC0: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeMaybe_$csome_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chBZ: // global
           I64[Hp - 16] = some_v_sgMN_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fAlternativeMaybe_$csome_info" {
     GHC.Base.$fAlternativeMaybe_$csome_info:
         const GHC.Base.$fAlternativeMaybe_$csome_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.505083804 UTC

[section ""data" . GHC.Base.ap_$sap_closure" {
     GHC.Base.ap_$sap_closure:
         const GHC.Base.ap_$sap_info;
 },
 GHC.Base.ap_$sap_entry() //  [R2, R3]
         { []
         }
     {offset
       chCN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chCO; else goto chCP;
       chCO: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.ap_$sap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chCP: // global
           I64[Sp - 16] = block_chCG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uhDh; else goto chCH;
       uhDh: // global
           call _chCG(R1) args: 0, res: 0, upd: 0;
       chCH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.ap_$sap_info" {
     GHC.Base.ap_$sap_info:
         const GHC.Base.ap_$sap_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _chCG() //  [R1]
         { []
         }
     {offset
       chCG: // global
           if (R1 & 7 == 1) goto uhDd; else goto chCL;
       uhDd: // global
           Sp = Sp + 16;
           call _chD3() args: 0, res: 0, upd: 0;
       chCL: // global
           I64[Sp] = block_chCV_info;
           _sgMX::P64 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sgMX::P64;
           if (R1 & 7 != 0) goto uhDf; else goto chCX;
       uhDf: // global
           call _chCV(R1) args: 0, res: 0, upd: 0;
       chCX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chCG_info" {
     block_chCG_info:
         const _chCG;
         const 1;
         const 30;
 },
 _chCV() //  [R1]
         { []
         }
     {offset
       chCV: // global
           if (R1 & 7 == 1) goto uhDe; else goto chD8;
       uhDe: // global
           Sp = Sp + 16;
           call _chD3() args: 0, res: 0, upd: 0;
       chD8: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto chDb; else goto chDa;
       chDb: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chDa: // global
           _sgMZ::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sgMZ::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chCV_info" {
     block_chCV_info:
         const _chCV;
         const 1;
         const 30;
 },
 _chD3() //  []
         { []
         }
     {offset
       chD3: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.51637416 UTC

[section ""data" . GHC.Base.liftM5_$sliftM5_closure" {
     GHC.Base.liftM5_$sliftM5_closure:
         const GHC.Base.liftM5_$sliftM5_info;
 },
 GHC.Base.liftM5_$sliftM5_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       chDV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto chDW; else goto chDX;
       chDW: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM5_$sliftM5_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       chDX: // global
           I64[Sp - 40] = block_chDO_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uhF5; else goto chDP;
       uhF5: // global
           call _chDO(R1) args: 0, res: 0, upd: 0;
       chDP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM5_$sliftM5_info" {
     GHC.Base.liftM5_$sliftM5_info:
         const GHC.Base.liftM5_$sliftM5_entry;
         const 0;
         const 14;
         const 25769803802;
 },
 _chDO() //  [R1]
         { []
         }
     {offset
       chDO: // global
           if (R1 & 7 == 1) goto uhEY; else goto chDT;
       uhEY: // global
           Sp = Sp + 48;
           call _chEL() args: 0, res: 0, upd: 0;
       chDT: // global
           I64[Sp] = block_chE3_info;
           _sgN8::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgN8::P64;
           if (R1 & 7 != 0) goto uhF3; else goto chE5;
       uhF3: // global
           call _chE3(R1) args: 0, res: 0, upd: 0;
       chE5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chDO_info" {
     block_chDO_info:
         const _chDO;
         const 5;
         const 30;
 },
 _chE3() //  [R1]
         { []
         }
     {offset
       chE3: // global
           if (R1 & 7 == 1) goto uhEZ; else goto chEg;
       uhEZ: // global
           Sp = Sp + 48;
           call _chEL() args: 0, res: 0, upd: 0;
       chEg: // global
           I64[Sp] = block_chEe_info;
           _sgNa::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sgNa::P64;
           if (R1 & 7 != 0) goto uhF6; else goto chEh;
       uhF6: // global
           call _chEe(R1) args: 0, res: 0, upd: 0;
       chEh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chE3_info" {
     block_chE3_info:
         const _chE3;
         const 5;
         const 30;
 },
 _chEe() //  [R1]
         { []
         }
     {offset
       chEe: // global
           if (R1 & 7 == 1) goto uhF0; else goto chEs;
       uhF0: // global
           Sp = Sp + 48;
           call _chEL() args: 0, res: 0, upd: 0;
       chEs: // global
           I64[Sp] = block_chEq_info;
           _sgNc::P64 = P64[R1 + 6];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sgNc::P64;
           if (R1 & 7 != 0) goto uhF8; else goto chEt;
       uhF8: // global
           call _chEq(R1) args: 0, res: 0, upd: 0;
       chEt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chEe_info" {
     block_chEe_info:
         const _chEe;
         const 5;
         const 30;
 },
 _chEq() //  [R1]
         { []
         }
     {offset
       chEq: // global
           if (R1 & 7 == 1) goto uhF1; else goto chEE;
       uhF1: // global
           Sp = Sp + 48;
           call _chEL() args: 0, res: 0, upd: 0;
       chEE: // global
           I64[Sp] = block_chEC_info;
           _sgNe::P64 = P64[R1 + 6];
           R1 = P64[Sp + 40];
           P64[Sp + 40] = _sgNe::P64;
           if (R1 & 7 != 0) goto uhFa; else goto chEF;
       uhFa: // global
           call _chEC(R1) args: 0, res: 0, upd: 0;
       chEF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chEq_info" {
     block_chEq_info:
         const _chEq;
         const 5;
         const 30;
 },
 _chEC() //  [R1]
         { []
         }
     {offset
       chEC: // global
           if (R1 & 7 == 1) goto uhF2; else goto chEQ;
       uhF2: // global
           Sp = Sp + 48;
           call _chEL() args: 0, res: 0, upd: 0;
       chEQ: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto chET; else goto chES;
       chET: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chES: // global
           _sgNg::P64 = P64[R1 + 6];
           I64[Hp - 72] = stg_ap_6_upd_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = _sgNg::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 72;
           R1 = Hp - 6;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chEC_info" {
     block_chEC_info:
         const _chEC;
         const 5;
         const 30;
 },
 _chEL() //  []
         { []
         }
     {offset
       chEL: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.53162522 UTC

[section ""data" . GHC.Base.liftM4_$sliftM4_closure" {
     GHC.Base.liftM4_$sliftM4_closure:
         const GHC.Base.liftM4_$sliftM4_info;
 },
 GHC.Base.liftM4_$sliftM4_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       chGe: // global
           if ((Sp + -40) < SpLim) (likely: False) goto chGf; else goto chGg;
       chGf: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM4_$sliftM4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       chGg: // global
           I64[Sp - 40] = block_chG7_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uhHa; else goto chG8;
       uhHa: // global
           call _chG7(R1) args: 0, res: 0, upd: 0;
       chG8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM4_$sliftM4_info" {
     GHC.Base.liftM4_$sliftM4_info:
         const GHC.Base.liftM4_$sliftM4_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _chG7() //  [R1]
         { []
         }
     {offset
       chG7: // global
           if (R1 & 7 == 1) goto uhH4; else goto chGc;
       uhH4: // global
           Sp = Sp + 40;
           call _chGS() args: 0, res: 0, upd: 0;
       chGc: // global
           I64[Sp] = block_chGm_info;
           _sgNo::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgNo::P64;
           if (R1 & 7 != 0) goto uhH8; else goto chGo;
       uhH8: // global
           call _chGm(R1) args: 0, res: 0, upd: 0;
       chGo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chG7_info" {
     block_chG7_info:
         const _chG7;
         const 4;
         const 30;
 },
 _chGm() //  [R1]
         { []
         }
     {offset
       chGm: // global
           if (R1 & 7 == 1) goto uhH5; else goto chGz;
       uhH5: // global
           Sp = Sp + 40;
           call _chGS() args: 0, res: 0, upd: 0;
       chGz: // global
           I64[Sp] = block_chGx_info;
           _sgNq::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sgNq::P64;
           if (R1 & 7 != 0) goto uhHb; else goto chGA;
       uhHb: // global
           call _chGx(R1) args: 0, res: 0, upd: 0;
       chGA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chGm_info" {
     block_chGm_info:
         const _chGm;
         const 4;
         const 30;
 },
 _chGx() //  [R1]
         { []
         }
     {offset
       chGx: // global
           if (R1 & 7 == 1) goto uhH6; else goto chGL;
       uhH6: // global
           Sp = Sp + 40;
           call _chGS() args: 0, res: 0, upd: 0;
       chGL: // global
           I64[Sp] = block_chGJ_info;
           _sgNs::P64 = P64[R1 + 6];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sgNs::P64;
           if (R1 & 7 != 0) goto uhHd; else goto chGM;
       uhHd: // global
           call _chGJ(R1) args: 0, res: 0, upd: 0;
       chGM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chGx_info" {
     block_chGx_info:
         const _chGx;
         const 4;
         const 30;
 },
 _chGJ() //  [R1]
         { []
         }
     {offset
       chGJ: // global
           if (R1 & 7 == 1) goto uhH7; else goto chGX;
       uhH7: // global
           Sp = Sp + 40;
           call _chGS() args: 0, res: 0, upd: 0;
       chGX: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto chH0; else goto chGZ;
       chH0: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chGZ: // global
           _sgNu::P64 = P64[R1 + 6];
           I64[Hp - 64] = stg_ap_5_upd_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = _sgNu::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 64;
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chGJ_info" {
     block_chGJ_info:
         const _chGJ;
         const 4;
         const 30;
 },
 _chGS() //  []
         { []
         }
     {offset
       chGS: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.54462163 UTC

[section ""data" . GHC.Base.liftM3_$sliftM3_closure" {
     GHC.Base.liftM3_$sliftM3_closure:
         const GHC.Base.liftM3_$sliftM3_info;
 },
 GHC.Base.liftM3_$sliftM3_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       chI9: // global
           if ((Sp + -32) < SpLim) (likely: False) goto chIa; else goto chIb;
       chIa: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM3_$sliftM3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       chIb: // global
           I64[Sp - 32] = block_chI2_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uhIR; else goto chI3;
       uhIR: // global
           call _chI2(R1) args: 0, res: 0, upd: 0;
       chI3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM3_$sliftM3_info" {
     GHC.Base.liftM3_$sliftM3_info:
         const GHC.Base.liftM3_$sliftM3_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _chI2() //  [R1]
         { []
         }
     {offset
       chI2: // global
           if (R1 & 7 == 1) goto uhIM; else goto chI7;
       uhIM: // global
           Sp = Sp + 32;
           call _chIB() args: 0, res: 0, upd: 0;
       chI7: // global
           I64[Sp] = block_chIh_info;
           _sgNB::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgNB::P64;
           if (R1 & 7 != 0) goto uhIP; else goto chIj;
       uhIP: // global
           call _chIh(R1) args: 0, res: 0, upd: 0;
       chIj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chI2_info" {
     block_chI2_info:
         const _chI2;
         const 3;
         const 30;
 },
 _chIh() //  [R1]
         { []
         }
     {offset
       chIh: // global
           if (R1 & 7 == 1) goto uhIN; else goto chIu;
       uhIN: // global
           Sp = Sp + 32;
           call _chIB() args: 0, res: 0, upd: 0;
       chIu: // global
           I64[Sp] = block_chIs_info;
           _sgND::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sgND::P64;
           if (R1 & 7 != 0) goto uhIS; else goto chIv;
       uhIS: // global
           call _chIs(R1) args: 0, res: 0, upd: 0;
       chIv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chIh_info" {
     block_chIh_info:
         const _chIh;
         const 3;
         const 30;
 },
 _chIs() //  [R1]
         { []
         }
     {offset
       chIs: // global
           if (R1 & 7 == 1) goto uhIO; else goto chIG;
       uhIO: // global
           Sp = Sp + 32;
           call _chIB() args: 0, res: 0, upd: 0;
       chIG: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto chIJ; else goto chII;
       chIJ: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chII: // global
           _sgNF::P64 = P64[R1 + 6];
           I64[Hp - 56] = stg_ap_4_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _sgNF::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chIs_info" {
     block_chIs_info:
         const _chIs;
         const 3;
         const 30;
 },
 _chIB() //  []
         { []
         }
     {offset
       chIB: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.556774381 UTC

[section ""data" . GHC.Base.liftM2_$sliftM2_closure" {
     GHC.Base.liftM2_$sliftM2_closure:
         const GHC.Base.liftM2_$sliftM2_info;
 },
 GHC.Base.liftM2_$sliftM2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       chJG: // global
           if ((Sp + -24) < SpLim) (likely: False) goto chJH; else goto chJI;
       chJH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM2_$sliftM2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       chJI: // global
           I64[Sp - 24] = block_chJz_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uhKa; else goto chJA;
       uhKa: // global
           call _chJz(R1) args: 0, res: 0, upd: 0;
       chJA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM2_$sliftM2_info" {
     GHC.Base.liftM2_$sliftM2_info:
         const GHC.Base.liftM2_$sliftM2_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _chJz() //  [R1]
         { []
         }
     {offset
       chJz: // global
           if (R1 & 7 == 1) goto uhK6; else goto chJE;
       uhK6: // global
           Sp = Sp + 24;
           call _chJW() args: 0, res: 0, upd: 0;
       chJE: // global
           I64[Sp] = block_chJO_info;
           _sgNL::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgNL::P64;
           if (R1 & 7 != 0) goto uhK8; else goto chJQ;
       uhK8: // global
           call _chJO(R1) args: 0, res: 0, upd: 0;
       chJQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chJz_info" {
     block_chJz_info:
         const _chJz;
         const 2;
         const 30;
 },
 _chJO() //  [R1]
         { []
         }
     {offset
       chJO: // global
           if (R1 & 7 == 1) goto uhK7; else goto chK1;
       uhK7: // global
           Sp = Sp + 24;
           call _chJW() args: 0, res: 0, upd: 0;
       chK1: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto chK4; else goto chK3;
       chK4: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chK3: // global
           _sgNN::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _sgNN::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chJO_info" {
     block_chJO_info:
         const _chJO;
         const 2;
         const 30;
 },
 _chJW() //  []
         { []
         }
     {offset
       chJW: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.565971168 UTC

[section ""data" . GHC.Base.liftM_$sliftM_closure" {
     GHC.Base.liftM_$sliftM_closure:
         const GHC.Base.liftM_$sliftM_info;
 },
 GHC.Base.liftM_$sliftM_entry() //  [R2, R3]
         { []
         }
     {offset
       chKP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chKQ; else goto chKR;
       chKQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM_$sliftM_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chKR: // global
           I64[Sp - 16] = block_chKI_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uhL2; else goto chKJ;
       uhL2: // global
           call _chKI(R1) args: 0, res: 0, upd: 0;
       chKJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM_$sliftM_info" {
     GHC.Base.liftM_$sliftM_info:
         const GHC.Base.liftM_$sliftM_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _chKI() //  [R1]
         { []
         }
     {offset
       chKI: // global
           if (R1 & 7 == 1) goto chKM; else goto chKN;
       chKM: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       chKN: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto chL1; else goto chL0;
       chL1: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chL0: // global
           _sgNS::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sgNS::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chKI_info" {
     block_chKI_info:
         const _chKI;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.57102609 UTC

[section ""data" . GHC.Base.when1_closure" {
     GHC.Base.when1_closure:
         const GHC.Base.Just_con_info;
         const GHC.Tuple.()_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.573665065 UTC

[section ""data" . GHC.Base.when_$swhen_closure" {
     GHC.Base.when_$swhen_closure:
         const GHC.Base.when_$swhen_info;
 },
 GHC.Base.when_$swhen_entry() //  [R2, R3]
         { []
         }
     {offset
       chLx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chLy; else goto chLz;
       chLy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.when_$swhen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chLz: // global
           I64[Sp - 16] = block_chLq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uhLG; else goto chLr;
       uhLG: // global
           call _chLq(R1) args: 0, res: 0, upd: 0;
       chLr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.when_$swhen_info" {
     GHC.Base.when_$swhen_info:
         const GHC.Base.when_$swhen_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _chLq() //  [R1]
         { []
         }
     {offset
       chLq: // global
           if (R1 & 7 == 1) goto chLu; else goto chLv;
       chLu: // global
           R1 = GHC.Base.when1_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       chLv: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chLq_info" {
     block_chLq_info:
         const _chLq;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.579520271 UTC

[section ""data" . GHC.Base.when_closure" {
     GHC.Base.when_closure:
         const GHC.Base.when_info;
 },
 GHC.Base.when_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       chM7: // global
           if ((Sp + -24) < SpLim) (likely: False) goto chM8; else goto chM9;
       chM8: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.when_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       chM9: // global
           I64[Sp - 24] = block_chM0_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uhMg; else goto chM1;
       uhMg: // global
           call _chM0(R1) args: 0, res: 0, upd: 0;
       chM1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.when_info" {
     GHC.Base.when_info:
         const GHC.Base.when_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _chM0() //  [R1]
         { []
         }
     {offset
       chM0: // global
           if (R1 & 7 == 1) goto chM4; else goto chM5;
       chM4: // global
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 24, res: 0, upd: 8;
       chM5: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chM0_info" {
     block_chM0_info:
         const _chM0;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.586399661 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$c<*_closure" {
     GHC.Base.$fApplicativeMaybe_$c<*_closure:
         const GHC.Base.$fApplicativeMaybe_$c<*_info;
 },
 GHC.Base.$fApplicativeMaybe_$c<*_entry() //  [R2, R3]
         { []
         }
     {offset
       chMH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chMI; else goto chMJ;
       chMI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$c<*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chMJ: // global
           I64[Sp - 16] = block_chMA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uhN7; else goto chMB;
       uhN7: // global
           call _chMA(R1) args: 0, res: 0, upd: 0;
       chMB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeMaybe_$c<*_info" {
     GHC.Base.$fApplicativeMaybe_$c<*_info:
         const GHC.Base.$fApplicativeMaybe_$c<*_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _chMA() //  [R1]
         { []
         }
     {offset
       chMA: // global
           if (R1 & 7 == 1) goto uhN3; else goto chMF;
       uhN3: // global
           Sp = Sp + 16;
           call _chMX() args: 0, res: 0, upd: 0;
       chMF: // global
           I64[Sp] = block_chMP_info;
           _sgO3::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sgO3::P64;
           if (R1 & 7 != 0) goto uhN5; else goto chMR;
       uhN5: // global
           call _chMP(R1) args: 0, res: 0, upd: 0;
       chMR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chMA_info" {
     block_chMA_info:
         const _chMA;
         const 1;
         const 30;
 },
 _chMP() //  [R1]
         { []
         }
     {offset
       chMP: // global
           if (R1 & 7 == 1) goto uhN4; else goto chN1;
       uhN4: // global
           Sp = Sp + 16;
           call _chMX() args: 0, res: 0, upd: 0;
       chN1: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chMP_info" {
     block_chMP_info:
         const _chMP;
         const 1;
         const 30;
 },
 _chMX() //  []
         { []
         }
     {offset
       chMX: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.594020862 UTC

[section ""cstring" . GHC.Base.$tc'O3_bytes" {
     GHC.Base.$tc'O3_bytes:
         I8[] [39,79]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.595689172 UTC

[section ""data" . GHC.Base.$tc'O2_closure" {
     GHC.Base.$tc'O2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'O3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.597782968 UTC

[section ""cstring" . GHC.Base.$tcOpaque2_bytes" {
     GHC.Base.$tcOpaque2_bytes:
         I8[] [79,112,97,113,117,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.599401121 UTC

[section ""data" . GHC.Base.$tcOpaque1_closure" {
     GHC.Base.$tcOpaque1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcOpaque2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.600986413 UTC

[section ""cstring" . GHC.Base.$tcMonadPlus2_bytes" {
     GHC.Base.$tcMonadPlus2_bytes:
         I8[] [77,111,110,97,100,80,108,117,115]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.602585458 UTC

[section ""data" . GHC.Base.$tcMonadPlus1_closure" {
     GHC.Base.$tcMonadPlus1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMonadPlus2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.604242846 UTC

[section ""cstring" . GHC.Base.$tcMonad2_bytes" {
     GHC.Base.$tcMonad2_bytes:
         I8[] [77,111,110,97,100]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.605905459 UTC

[section ""data" . GHC.Base.$tcMonad1_closure" {
     GHC.Base.$tcMonad1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMonad2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.607534006 UTC

[section ""cstring" . GHC.Base.$tc'C:Monoid3_bytes" {
     GHC.Base.$tc'C:Monoid3_bytes:
         I8[] [39,67,58,77,111,110,111,105,100]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.60917177 UTC

[section ""data" . GHC.Base.$tc'C:Monoid2_closure" {
     GHC.Base.$tc'C:Monoid2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'C:Monoid3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.610889155 UTC

[section ""cstring" . GHC.Base.$tcMonoid3_bytes" {
     GHC.Base.$tcMonoid3_bytes:
         I8[] [77,111,110,111,105,100]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.612581607 UTC

[section ""data" . GHC.Base.$tcMonoid2_closure" {
     GHC.Base.$tcMonoid2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMonoid3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.614696536 UTC

[section ""cstring" . GHC.Base.$tcSemigroup2_bytes" {
     GHC.Base.$tcSemigroup2_bytes:
         I8[] [83,101,109,105,103,114,111,117,112]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.616411488 UTC

[section ""data" . GHC.Base.$tcSemigroup1_closure" {
     GHC.Base.$tcSemigroup1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcSemigroup2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.618543705 UTC

[section ""cstring" . GHC.Base.$tc':|3_bytes" {
     GHC.Base.$tc':|3_bytes:
         I8[] [39,58,124]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.620254997 UTC

[section ""data" . GHC.Base.$tc':|2_closure" {
     GHC.Base.$tc':|2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc':|3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.621911663 UTC

[section ""cstring" . GHC.Base.$tcNonEmpty2_bytes" {
     GHC.Base.$tcNonEmpty2_bytes:
         I8[] [78,111,110,69,109,112,116,121]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.623554126 UTC

[section ""data" . GHC.Base.$tcNonEmpty1_closure" {
     GHC.Base.$tcNonEmpty1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcNonEmpty2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.625275155 UTC

[section ""cstring" . GHC.Base.$tcAlternative3_bytes" {
     GHC.Base.$tcAlternative3_bytes:
         I8[] [65,108,116,101,114,110,97,116,105,118,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.626893895 UTC

[section ""data" . GHC.Base.$tcAlternative2_closure" {
     GHC.Base.$tcAlternative2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcAlternative3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.628449681 UTC

[section ""cstring" . GHC.Base.$tcApplicative2_bytes" {
     GHC.Base.$tcApplicative2_bytes:
         I8[] [65,112,112,108,105,99,97,116,105,118,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.630097514 UTC

[section ""data" . GHC.Base.$tcApplicative1_closure" {
     GHC.Base.$tcApplicative1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcApplicative2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.631778579 UTC

[section ""cstring" . GHC.Base.$tcFunctor2_bytes" {
     GHC.Base.$tcFunctor2_bytes:
         I8[] [70,117,110,99,116,111,114]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.633477913 UTC

[section ""data" . GHC.Base.$tcFunctor1_closure" {
     GHC.Base.$tcFunctor1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcFunctor2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.635138191 UTC

[section ""cstring" . GHC.Base.$tc'Just3_bytes" {
     GHC.Base.$tc'Just3_bytes:
         I8[] [39,74,117,115,116]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.636785027 UTC

[section ""data" . GHC.Base.$tc'Just2_closure" {
     GHC.Base.$tc'Just2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'Just3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.638524212 UTC

[section ""cstring" . GHC.Base.$tc'Nothing3_bytes" {
     GHC.Base.$tc'Nothing3_bytes:
         I8[] [39,78,111,116,104,105,110,103]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.640204756 UTC

[section ""data" . GHC.Base.$tc'Nothing2_closure" {
     GHC.Base.$tc'Nothing2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tc'Nothing3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.642343654 UTC

[section ""cstring" . GHC.Base.$tcMaybe2_bytes" {
     GHC.Base.$tcMaybe2_bytes:
         I8[] [77,97,121,98,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.643922302 UTC

[section ""data" . GHC.Base.$tcMaybe1_closure" {
     GHC.Base.$tcMaybe1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$tcMaybe2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.646348215 UTC

[section ""data" . $krep_r7Pr_closure" {
     $krep_r7Pr_closure:
         const GHC.Types.KindRepVar_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.648005134 UTC

[section ""data" . $krep1_r7Ps_closure" {
     $krep1_r7Ps_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep_r7Pr_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.649763204 UTC

[section ""data" . $krep2_r7Pt_closure" {
     $krep2_r7Pt_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep1_r7Ps_closure+4;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.651376716 UTC

[section ""data" . $krep3_r7Pu_closure" {
     $krep3_r7Pu_closure:
         const :_con_info;
         const $krep_r7Pr_closure+2;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.653057794 UTC

[section ""data" . $krep4_r7Pv_closure" {
     $krep4_r7Pv_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tc[]_closure;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.655012552 UTC

[section ""data" . $krep5_r7Pw_closure" {
     $krep5_r7Pw_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r7Pv_closure+1;
         const $krep_r7Pr_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.656685808 UTC

[section ""data" . $krep6_r7Px_closure" {
     $krep6_r7Px_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Types.$tcConstraint_closure;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.658418557 UTC

[section ""data" . GHC.Base.$tcMonoid1_closure" {
     GHC.Base.$tcMonoid1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*_closure;
         const $krep6_r7Px_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.660052229 UTC

[section ""data" . GHC.Base.$tcAlternative1_closure" {
     GHC.Base.$tcAlternative1_closure:
         const GHC.Types.KindRepFun_con_info;
         const GHC.Types.krep$*Arr*_closure;
         const $krep6_r7Px_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.661748648 UTC

[section ""cstring" . GHC.Base.$trModule2_bytes" {
     GHC.Base.$trModule2_bytes:
         I8[] [71,72,67,46,66,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.663331154 UTC

[section ""data" . GHC.Base.$trModule1_closure" {
     GHC.Base.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.664920961 UTC

[section ""cstring" . GHC.Base.$trModule4_bytes" {
     GHC.Base.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.666994857 UTC

[section ""data" . GHC.Base.$trModule3_closure" {
     GHC.Base.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Base.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.668645648 UTC

[section ""data" . GHC.Base.$trModule_closure" {
     GHC.Base.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Base.$trModule3_closure+1;
         const GHC.Base.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.670999098 UTC

[section ""data" . GHC.Base.$tcMaybe_closure" {
     GHC.Base.$tcMaybe_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMaybe1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 625655543500963593;
         const 6391758309165051762;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.672667329 UTC

[section ""data" . GHC.Base.$tc'Nothing1_closure" {
     GHC.Base.$tc'Nothing1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMaybe_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.674394787 UTC

[section ""data" . GHC.Base.$tc'Just1_closure" {
     GHC.Base.$tc'Just1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const GHC.Base.$tc'Nothing1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.676072635 UTC

[section ""data" . GHC.Base.$tc'Nothing_closure" {
     GHC.Base.$tc'Nothing_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'Nothing2_closure+1;
         const GHC.Base.$tc'Nothing1_closure+1;
         const 14633289528184412192;
         const 12773126156421542470;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.677838073 UTC

[section ""data" . GHC.Base.$tc'Just_closure" {
     GHC.Base.$tc'Just_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'Just2_closure+1;
         const GHC.Base.$tc'Just1_closure+4;
         const 5794512144280699493;
         const 9434423460978218117;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.679613874 UTC

[section ""data" . GHC.Base.$tcFunctor_closure" {
     GHC.Base.$tcFunctor_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcFunctor1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 211182333006544237;
         const 5556320544348084514;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.681358577 UTC

[section ""data" . GHC.Base.$tcApplicative_closure" {
     GHC.Base.$tcApplicative_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcApplicative1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 12705055220831243597;
         const 2963353171490466073;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.683202588 UTC

[section ""data" . GHC.Base.$tcAlternative_closure" {
     GHC.Base.$tcAlternative_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcAlternative2_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 1073491102990665358;
         const 14320772755704808948;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.684989972 UTC

[section ""data" . GHC.Base.$tcNonEmpty_closure" {
     GHC.Base.$tcNonEmpty_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcNonEmpty1_closure+1;
         const GHC.Types.krep$*Arr*_closure;
         const 13207016872645468285;
         const 3455542966739695982;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.686828778 UTC

[section ""data" . $krep7_r7Py_closure" {
     $krep7_r7Py_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcNonEmpty_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.688478889 UTC

[section ""data" . $krep8_r7Pz_closure" {
     $krep8_r7Pz_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep4_r7Pv_closure+1;
         const $krep7_r7Py_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.690544316 UTC

[section ""data" . GHC.Base.$tc':|1_closure" {
     GHC.Base.$tc':|1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep8_r7Pz_closure+4;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.692180114 UTC

[section ""data" . GHC.Base.$tc':|_closure" {
     GHC.Base.$tc':|_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc':|2_closure+1;
         const GHC.Base.$tc':|1_closure+4;
         const 9440832435183810765;
         const 3053237465234607583;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.694455445 UTC

[section ""data" . GHC.Base.$tcSemigroup_closure" {
     GHC.Base.$tcSemigroup_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcSemigroup1_closure+1;
         const GHC.Base.$tcMonoid1_closure+4;
         const 16195352186364298277;
         const 3285685594139281062;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.696236121 UTC

[section ""data" . $krep9_r7PA_closure" {
     $krep9_r7PA_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcSemigroup_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.697981789 UTC

[section ""data" . GHC.Base.$tcMonoid_closure" {
     GHC.Base.$tcMonoid_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMonoid2_closure+1;
         const GHC.Base.$tcMonoid1_closure+4;
         const 13838560045895743776;
         const 1291018260833769143;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.699688377 UTC

[section ""data" . $krep10_r7PB_closure" {
     $krep10_r7PB_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcMonoid_closure+1;
         const $krep3_r7Pu_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.701817829 UTC

[section ""data" . $krep11_r7PC_closure" {
     $krep11_r7PC_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep5_r7Pw_closure+4;
         const $krep10_r7PB_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.703764432 UTC

[section ""data" . $krep12_r7PD_closure" {
     $krep12_r7PD_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep2_r7Pt_closure+4;
         const $krep11_r7PC_closure+4;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.70550908 UTC

[section ""data" . $krep13_r7PE_closure" {
     $krep13_r7PE_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep12_r7PD_closure+4;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.707180971 UTC

[section ""data" . GHC.Base.$tc'C:Monoid1_closure" {
     GHC.Base.$tc'C:Monoid1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep9_r7PA_closure+1;
         const $krep13_r7PE_closure+4;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.708903496 UTC

[section ""data" . GHC.Base.$tc'C:Monoid_closure" {
     GHC.Base.$tc'C:Monoid_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'C:Monoid2_closure+1;
         const GHC.Base.$tc'C:Monoid1_closure+4;
         const 16099296089107510343;
         const 5895832073319104984;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.710716967 UTC

[section ""data" . GHC.Base.$tcMonad_closure" {
     GHC.Base.$tcMonad_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMonad1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 3168880480603756299;
         const 8398240611646296094;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.712485568 UTC

[section ""data" . GHC.Base.$tcMonadPlus_closure" {
     GHC.Base.$tcMonadPlus_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcMonadPlus1_closure+1;
         const GHC.Base.$tcAlternative1_closure+4;
         const 14115673251620372550;
         const 14155357326069389390;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.714294028 UTC

[section ""data" . GHC.Base.$tcOpaque_closure" {
     GHC.Base.$tcOpaque_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tcOpaque1_closure+1;
         const GHC.Types.krep$*_closure;
         const 9339725405829241186;
         const 15550233501624900571;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.716045715 UTC

[section ""data" . $krep14_r7PF_closure" {
     $krep14_r7PF_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.Base.$tcOpaque_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.718383435 UTC

[section ""data" . GHC.Base.$tc'O1_closure" {
     GHC.Base.$tc'O1_closure:
         const GHC.Types.KindRepFun_con_info;
         const $krep_r7Pr_closure+2;
         const $krep14_r7PF_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.720624194 UTC

[section ""data" . GHC.Base.$tc'O_closure" {
     GHC.Base.$tc'O_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.Base.$trModule_closure+1;
         const GHC.Base.$tc'O2_closure+1;
         const GHC.Base.$tc'O1_closure+4;
         const 12551274612394834805;
         const 13000664474148134329;
         const 1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.723935323 UTC

[section ""data" . GHC.Base.quotRemInt_closure" {
     GHC.Base.quotRemInt_closure:
         const GHC.Base.quotRemInt_info;
 },
 GHC.Base.quotRemInt_entry() //  [R2, R3]
         { []
         }
     {offset
       chOO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chOZ; else goto chP0;
       chOZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.quotRemInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chP0: // global
           I64[Sp - 16] = block_chOL_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uhP6; else goto chOM;
       uhP6: // global
           call _chOL(R1) args: 0, res: 0, upd: 0;
       chOM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.quotRemInt_info" {
     GHC.Base.quotRemInt_info:
         const GHC.Base.quotRemInt_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _chOL() //  [R1]
         { []
         }
     {offset
       chOL: // global
           I64[Sp] = block_chOR_info;
           _sgOa::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sgOa::I64;
           if (R1 & 7 != 0) goto uhP5; else goto chOS;
       uhP5: // global
           call _chOR(R1) args: 0, res: 0, upd: 0;
       chOS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chOL_info" {
     block_chOL_info:
         const _chOL;
         const 1;
         const 30;
 },
 _chOR() //  [R1]
         { []
         }
     {offset
       chOR: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto chP4; else goto chP3;
       chP4: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chP3: // global
           (_sgOe::I64, _sgOf::I64) = call MO_S_QuotRem W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _sgOf::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sgOe::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chOR_info" {
     block_chOR_info:
         const _chOR;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.732021279 UTC

[section ""data" . GHC.Base.modInt_closure" {
     GHC.Base.modInt_closure:
         const GHC.Base.modInt_info;
 },
 GHC.Base.modInt_entry() //  [R2, R3]
         { []
         }
     {offset
       chPz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chPM; else goto chPN;
       chPM: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.modInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chPN: // global
           I64[Sp - 16] = block_chPw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uhPU; else goto chPx;
       uhPU: // global
           call _chPw(R1) args: 0, res: 0, upd: 0;
       chPx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.modInt_info" {
     GHC.Base.modInt_info:
         const GHC.Base.modInt_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _chPw() //  [R1]
         { []
         }
     {offset
       chPw: // global
           I64[Sp] = block_chPC_info;
           _sgOl::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sgOl::I64;
           if (R1 & 7 != 0) goto uhPT; else goto chPD;
       uhPT: // global
           call _chPC(R1) args: 0, res: 0, upd: 0;
       chPD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chPw_info" {
     block_chPw_info:
         const _chPw;
         const 1;
         const 30;
 },
 _chPC() //  [R1]
         { []
         }
     {offset
       chPC: // global
           _sgOl::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_chPH_info;
           R3 = I64[R1 + 7];
           R2 = _sgOl::I64;
           Sp = Sp + 8;
           call GHC.Classes.modInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chPC_info" {
     block_chPC_info:
         const _chPC;
         const 65;
         const 30;
 },
 _chPH() //  [R1]
         { []
         }
     {offset
       chPH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto chPS; else goto chPR;
       chPS: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       chPR: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chPH_info" {
     block_chPH_info:
         const _chPH;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.741604769 UTC

[section ""data" . GHC.Base.divInt_closure" {
     GHC.Base.divInt_closure:
         const GHC.Base.divInt_info;
 },
 GHC.Base.divInt_entry() //  [R2, R3]
         { []
         }
     {offset
       chQn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chQA; else goto chQB;
       chQA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.divInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chQB: // global
           I64[Sp - 16] = block_chQk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uhQI; else goto chQl;
       uhQI: // global
           call _chQk(R1) args: 0, res: 0, upd: 0;
       chQl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.divInt_info" {
     GHC.Base.divInt_info:
         const GHC.Base.divInt_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _chQk() //  [R1]
         { []
         }
     {offset
       chQk: // global
           I64[Sp] = block_chQq_info;
           _sgOs::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sgOs::I64;
           if (R1 & 7 != 0) goto uhQH; else goto chQr;
       uhQH: // global
           call _chQq(R1) args: 0, res: 0, upd: 0;
       chQr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chQk_info" {
     block_chQk_info:
         const _chQk;
         const 1;
         const 30;
 },
 _chQq() //  [R1]
         { []
         }
     {offset
       chQq: // global
           _sgOs::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_chQv_info;
           R3 = I64[R1 + 7];
           R2 = _sgOs::I64;
           Sp = Sp + 8;
           call GHC.Classes.divInt#_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chQq_info" {
     block_chQq_info:
         const _chQq;
         const 65;
         const 30;
 },
 _chQv() //  [R1]
         { []
         }
     {offset
       chQv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto chQG; else goto chQF;
       chQG: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       chQF: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chQv_info" {
     block_chQv_info:
         const _chQv;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.75079192 UTC

[section ""data" . GHC.Base.remInt_closure" {
     GHC.Base.remInt_closure:
         const GHC.Base.remInt_info;
 },
 GHC.Base.remInt_entry() //  [R2, R3]
         { []
         }
     {offset
       chRb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chRn; else goto chRo;
       chRn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.remInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chRo: // global
           I64[Sp - 16] = block_chR8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uhRu; else goto chR9;
       uhRu: // global
           call _chR8(R1) args: 0, res: 0, upd: 0;
       chR9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.remInt_info" {
     GHC.Base.remInt_info:
         const GHC.Base.remInt_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _chR8() //  [R1]
         { []
         }
     {offset
       chR8: // global
           I64[Sp] = block_chRe_info;
           _sgOz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sgOz::I64;
           if (R1 & 7 != 0) goto uhRt; else goto chRf;
       uhRt: // global
           call _chRe(R1) args: 0, res: 0, upd: 0;
       chRf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chR8_info" {
     block_chR8_info:
         const _chR8;
         const 1;
         const 30;
 },
 _chRe() //  [R1]
         { []
         }
     {offset
       chRe: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto chRs; else goto chRr;
       chRs: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chRr: // global
           _sgOC::I64 = %MO_S_Rem_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sgOC::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chRe_info" {
     block_chRe_info:
         const _chRe;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.759653654 UTC

[section ""data" . GHC.Base.quotInt_closure" {
     GHC.Base.quotInt_closure:
         const GHC.Base.quotInt_info;
 },
 GHC.Base.quotInt_entry() //  [R2, R3]
         { []
         }
     {offset
       chRT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chS5; else goto chS6;
       chS5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.quotInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chS6: // global
           I64[Sp - 16] = block_chRQ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uhSc; else goto chRR;
       uhSc: // global
           call _chRQ(R1) args: 0, res: 0, upd: 0;
       chRR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.quotInt_info" {
     GHC.Base.quotInt_info:
         const GHC.Base.quotInt_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _chRQ() //  [R1]
         { []
         }
     {offset
       chRQ: // global
           I64[Sp] = block_chRW_info;
           _sgOG::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sgOG::I64;
           if (R1 & 7 != 0) goto uhSb; else goto chRX;
       uhSb: // global
           call _chRW(R1) args: 0, res: 0, upd: 0;
       chRX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chRQ_info" {
     block_chRQ_info:
         const _chRQ;
         const 1;
         const 30;
 },
 _chRW() //  [R1]
         { []
         }
     {offset
       chRW: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto chSa; else goto chS9;
       chSa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chS9: // global
           _sgOJ::I64 = %MO_S_Quot_W64(I64[Sp + 8], I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sgOJ::I64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chRW_info" {
     block_chRW_info:
         const _chRW;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.766918034 UTC

[section ""data" . GHC.Base.getTag_closure" {
     GHC.Base.getTag_closure:
         const GHC.Base.getTag_info;
 },
 GHC.Base.getTag_entry() //  [R2]
         { []
         }
     {offset
       chSB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto chSC; else goto chSD;
       chSC: // global
           R2 = R2;
           R1 = GHC.Base.getTag_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chSD: // global
           I64[Sp - 8] = block_chSy_info;
           R1 = R2;
           Sp = Sp - 8;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.getTag_info" {
     GHC.Base.getTag_info:
         const GHC.Base.getTag_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _chSy() //  [R1]
         { []
         }
     {offset
       chSy: // global
           R1 = %MO_UU_Conv_W32_W64(I32[I64[R1 & (-8)] + 20]);
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chSy_info" {
     block_chSy_info:
         const _chSy;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.772166549 UTC

[section ""data" . GHC.Base.$fMonadIO1_closure" {
     GHC.Base.$fMonadIO1_closure:
         const GHC.Base.$fMonadIO1_info;
 },
 GHC.Base.$fMonadIO1_entry() //  [R2, R3]
         { []
         }
     {offset
       chSY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chSZ; else goto chT0;
       chSZ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonadIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chT0: // global
           I64[Sp - 16] = block_chSW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonadIO1_info" {
     GHC.Base.$fMonadIO1_info:
         const GHC.Base.$fMonadIO1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _chSW() //  [R1]
         { []
         }
     {offset
       chSW: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pv_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chSW_info" {
     block_chSW_info:
         const _chSW;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.777191615 UTC

[section ""data" . GHC.Base.bindIO_closure" {
     GHC.Base.bindIO_closure:
         const GHC.Base.bindIO_info;
 },
 GHC.Base.bindIO_entry() //  [R2, R3]
         { []
         }
     {offset
       chTf: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fMonadIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.bindIO_info" {
     GHC.Base.bindIO_info:
         const GHC.Base.bindIO_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.78079765 UTC

[section ""data" . GHC.Base.$fApplicativeIO2_closure" {
     GHC.Base.$fApplicativeIO2_closure:
         const GHC.Base.$fApplicativeIO2_info;
 },
 GHC.Base.$fApplicativeIO2_entry() //  [R2, R3]
         { []
         }
     {offset
       chTs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chTt; else goto chTu;
       chTt: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeIO2_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chTu: // global
           I64[Sp - 16] = block_chTq_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeIO2_info" {
     GHC.Base.$fApplicativeIO2_info:
         const GHC.Base.$fApplicativeIO2_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _chTq() //  []
         { []
         }
     {offset
       chTq: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chTq_info" {
     block_chTq_info:
         const _chTq;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.786339674 UTC

[section ""data" . GHC.Base.thenIO_closure" {
     GHC.Base.thenIO_closure:
         const GHC.Base.thenIO_info;
 },
 GHC.Base.thenIO_entry() //  [R2, R3]
         { []
         }
     {offset
       chTJ: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fApplicativeIO2_entry(R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.thenIO_info" {
     GHC.Base.thenIO_info:
         const GHC.Base.thenIO_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.789577537 UTC

[section ""data" . GHC.Base.unIO1_closure" {
     GHC.Base.unIO1_closure:
         const GHC.Base.unIO1_info;
 },
 GHC.Base.unIO1_entry() //  [R2]
         { []
         }
     {offset
       chTU: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.unIO1_info" {
     GHC.Base.unIO1_info:
         const GHC.Base.unIO1_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.793344478 UTC

[section ""data" . GHC.Base.unIO_closure" {
     GHC.Base.unIO_closure:
         const GHC.Base.unIO_info;
 },
 GHC.Base.unIO_entry() //  [R2]
         { []
         }
     {offset
       chU5: // global
           R2 = R2;
           call GHC.Base.unIO1_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.unIO_info" {
     GHC.Base.unIO_info:
         const GHC.Base.unIO_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.796529343 UTC

[section ""data" . GHC.Base.$fApplicativeIO4_closure" {
     GHC.Base.$fApplicativeIO4_closure:
         const GHC.Base.$fApplicativeIO4_info;
 },
 GHC.Base.$fApplicativeIO4_entry() //  [R2]
         { []
         }
     {offset
       chUg: // global
           R1 = R2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeIO4_info" {
     GHC.Base.$fApplicativeIO4_info:
         const GHC.Base.$fApplicativeIO4_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.799792709 UTC

[section ""data" . GHC.Base.returnIO_closure" {
     GHC.Base.returnIO_closure:
         const GHC.Base.returnIO_info;
 },
 GHC.Base.returnIO_entry() //  [R2]
         { []
         }
     {offset
       chUs: // global
           R2 = R2;
           call GHC.Base.$fApplicativeIO4_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.returnIO_info" {
     GHC.Base.returnIO_info:
         const GHC.Base.returnIO_entry;
         const 0;
         const 14;
         const 8589934597;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.803644154 UTC

[section ""data" . GHC.Base.$fApplicativeIO3_closure" {
     GHC.Base.$fApplicativeIO3_closure:
         const GHC.Base.$fApplicativeIO3_info;
 },
 GHC.Base.$fApplicativeIO3_entry() //  [R2, R3]
         { []
         }
     {offset
       chUI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chUJ; else goto chUK;
       chUJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeIO3_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chUK: // global
           I64[Sp - 16] = block_chUD_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeIO3_info" {
     GHC.Base.$fApplicativeIO3_info:
         const GHC.Base.$fApplicativeIO3_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _chUD() //  [R1]
         { []
         }
     {offset
       chUD: // global
           I64[Sp] = block_chUF_info;
           _sgP5::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sgP5::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chUD_info" {
     block_chUD_info:
         const _chUD;
         const 1;
         const 30;
 },
 _chUF() //  [R1]
         { []
         }
     {offset
       chUF: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto chUO; else goto chUN;
       chUO: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chUN: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chUF_info" {
     block_chUF_info:
         const _chUF;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.810374818 UTC

[section ""data" . GHC.Base.liftA_$sliftA1_closure" {
     GHC.Base.liftA_$sliftA1_closure:
         const GHC.Base.liftA_$sliftA1_info;
 },
 GHC.Base.liftA_$sliftA1_entry() //  [R2, R3]
         { []
         }
     {offset
       chV9: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fFunctorIO2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftA_$sliftA1_info" {
     GHC.Base.liftA_$sliftA1_info:
         const GHC.Base.liftA_$sliftA1_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.814311916 UTC

[section ""data" . GHC.Base.ap1_closure" {
     GHC.Base.ap1_closure:
         const GHC.Base.ap1_info;
 },
 GHC.Base.ap1_entry() //  [R2, R3]
         { []
         }
     {offset
       chVp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto chVq; else goto chVr;
       chVq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.ap1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       chVr: // global
           I64[Sp - 16] = block_chVk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.ap1_info" {
     GHC.Base.ap1_info:
         const GHC.Base.ap1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _chVk() //  [R1]
         { []
         }
     {offset
       chVk: // global
           I64[Sp] = block_chVm_info;
           _sgPf::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sgPf::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chVk_info" {
     block_chVk_info:
         const _chVk;
         const 1;
         const 30;
 },
 _chVm() //  [R1]
         { []
         }
     {offset
       chVm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto chVv; else goto chVu;
       chVv: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chVu: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 24;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chVm_info" {
     block_chVm_info:
         const _chVm;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.821355196 UTC

[section ""data" . GHC.Base.ap_$sap1_closure" {
     GHC.Base.ap_$sap1_closure:
         const GHC.Base.ap_$sap1_info;
 },
 GHC.Base.ap_$sap1_entry() //  [R2, R3]
         { []
         }
     {offset
       chVQ: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.ap1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.ap_$sap1_info" {
     GHC.Base.ap_$sap1_info:
         const GHC.Base.ap_$sap1_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.826053016 UTC

[section ""data" . GHC.Base.ap_closure" {
     GHC.Base.ap_closure:
         const GHC.Base.ap_info;
 },
 sat_sgPq_entry() //  [R1, R2]
         { []
         }
     {offset
       chWc: // global
           _sgPo::P64 = R2;
           _sgPq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto chWd; else goto chWe;
       chWe: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto chWg; else goto chWf;
       chWg: // global
           HpAlloc = 32;
           goto chWd;
       chWd: // global
           R2 = _sgPo::P64;
           R1 = _sgPq::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chWf: // global
           _sgPk::P64 = P64[_sgPq::P64 + 7];
           _sgPn::P64 = P64[_sgPq::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgPn::P64;
           P64[Hp] = _sgPo::P64;
           R2 = _sgPk::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgPq_info" {
     sat_sgPq_info:
         const sat_sgPq_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 sat_sgPr_entry() //  [R1, R2]
         { []
         }
     {offset
       chWh: // global
           _sgPn::P64 = R2;
           _sgPr::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto chWi; else goto chWj;
       chWj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto chWl; else goto chWk;
       chWl: // global
           HpAlloc = 24;
           goto chWi;
       chWi: // global
           R2 = _sgPn::P64;
           R1 = _sgPr::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chWk: // global
           _sgPk::P64 = P64[_sgPr::P64 + 7];
           _sgPm::P64 = P64[_sgPr::P64 + 15];
           I64[Hp - 16] = sat_sgPq_info;
           P64[Hp - 8] = _sgPk::P64;
           P64[Hp] = _sgPn::P64;
           R2 = _sgPk::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgPm::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgPr_info" {
     sat_sgPr_info:
         const sat_sgPr_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 GHC.Base.ap_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       chWm: // global
           _sgPm::P64 = R4;
           _sgPl::P64 = R3;
           _sgPk::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto chWn; else goto chWo;
       chWo: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto chWq; else goto chWp;
       chWq: // global
           HpAlloc = 24;
           goto chWn;
       chWn: // global
           R4 = _sgPm::P64;
           R3 = _sgPl::P64;
           R2 = _sgPk::P64;
           R1 = GHC.Base.ap_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       chWp: // global
           I64[Hp - 16] = sat_sgPr_info;
           P64[Hp - 8] = _sgPk::P64;
           P64[Hp] = _sgPm::P64;
           R2 = _sgPk::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgPl::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.ap_info" {
     GHC.Base.ap_info:
         const GHC.Base.ap_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.834475295 UTC

[section ""data" . GHC.Base.liftM1_closure" {
     GHC.Base.liftM1_closure:
         const GHC.Base.liftM1_info;
 },
 GHC.Base.liftM1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       chWW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto chWX; else goto chWY;
       chWX: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       chWY: // global
           I64[Sp - 24] = block_chWR_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM1_info" {
     GHC.Base.liftM1_info:
         const GHC.Base.liftM1_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _chWR() //  [R1]
         { []
         }
     {offset
       chWR: // global
           I64[Sp] = block_chWT_info;
           _sgPy::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgPy::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chWR_info" {
     block_chWR_info:
         const _chWR;
         const 2;
         const 30;
 },
 _chWT() //  [R1]
         { []
         }
     {offset
       chWT: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto chX2; else goto chX1;
       chX2: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chX1: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chWT_info" {
     block_chWT_info:
         const _chWT;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.841586607 UTC

[section ""data" . GHC.Base.liftM2_$sliftM1_closure" {
     GHC.Base.liftM2_$sliftM1_closure:
         const GHC.Base.liftM2_$sliftM1_info;
 },
 GHC.Base.liftM2_$sliftM1_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       chXo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftM1_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM2_$sliftM1_info" {
     GHC.Base.liftM2_$sliftM1_info:
         const GHC.Base.liftM2_$sliftM1_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.846749419 UTC

[section ""data" . GHC.Base.liftM2_closure" {
     GHC.Base.liftM2_closure:
         const GHC.Base.liftM2_info;
 },
 sat_sgPK_entry() //  [R1, R2]
         { []
         }
     {offset
       chXK: // global
           _sgPI::P64 = R2;
           _sgPK::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto chXL; else goto chXM;
       chXM: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto chXO; else goto chXN;
       chXO: // global
           HpAlloc = 40;
           goto chXL;
       chXL: // global
           R2 = _sgPI::P64;
           R1 = _sgPK::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chXN: // global
           _sgPD::P64 = P64[_sgPK::P64 + 7];
           _sgPE::P64 = P64[_sgPK::P64 + 15];
           _sgPH::P64 = P64[_sgPK::P64 + 23];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = _sgPE::P64;
           P64[Hp - 8] = _sgPH::P64;
           P64[Hp] = _sgPI::P64;
           R2 = _sgPD::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgPK_info" {
     sat_sgPK_info:
         const sat_sgPK_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 sat_sgPL_entry() //  [R1, R2]
         { []
         }
     {offset
       chXP: // global
           _sgPH::P64 = R2;
           _sgPL::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto chXQ; else goto chXR;
       chXR: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto chXT; else goto chXS;
       chXT: // global
           HpAlloc = 32;
           goto chXQ;
       chXQ: // global
           R2 = _sgPH::P64;
           R1 = _sgPL::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       chXS: // global
           _sgPD::P64 = P64[_sgPL::P64 + 7];
           _sgPE::P64 = P64[_sgPL::P64 + 15];
           _sgPG::P64 = P64[_sgPL::P64 + 23];
           I64[Hp - 24] = sat_sgPK_info;
           P64[Hp - 16] = _sgPD::P64;
           P64[Hp - 8] = _sgPE::P64;
           P64[Hp] = _sgPH::P64;
           R2 = _sgPD::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgPG::P64;
           P64[Sp - 8] = Hp - 23;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgPL_info" {
     sat_sgPL_info:
         const sat_sgPL_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 GHC.Base.liftM2_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       chXU: // global
           _sgPG::P64 = R5;
           _sgPF::P64 = R4;
           _sgPE::P64 = R3;
           _sgPD::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto chXV; else goto chXW;
       chXW: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto chXY; else goto chXX;
       chXY: // global
           HpAlloc = 32;
           goto chXV;
       chXV: // global
           R5 = _sgPG::P64;
           R4 = _sgPF::P64;
           R3 = _sgPE::P64;
           R2 = _sgPD::P64;
           R1 = GHC.Base.liftM2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       chXX: // global
           I64[Hp - 24] = sat_sgPL_info;
           P64[Hp - 16] = _sgPD::P64;
           P64[Hp - 8] = _sgPE::P64;
           P64[Hp] = _sgPG::P64;
           R2 = _sgPD::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgPF::P64;
           P64[Sp - 8] = Hp - 23;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM2_info" {
     GHC.Base.liftM2_info:
         const GHC.Base.liftM2_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.855312299 UTC

[section ""data" . $cliftA2_r7PG_closure" {
     $cliftA2_r7PG_closure:
         const $cliftA2_r7PG_info;
 },
 $cliftA2_r7PG_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       chYu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto chYv; else goto chYw;
       chYv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $cliftA2_r7PG_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       chYw: // global
           I64[Sp - 24] = block_chYp_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . $cliftA2_r7PG_info" {
     $cliftA2_r7PG_info:
         const $cliftA2_r7PG_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _chYp() //  [R1]
         { []
         }
     {offset
       chYp: // global
           I64[Sp] = block_chYr_info;
           _sgPS::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgPS::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chYp_info" {
     block_chYp_info:
         const _chYp;
         const 2;
         const 30;
 },
 _chYr() //  [R1]
         { []
         }
     {offset
       chYr: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto chYA; else goto chYz;
       chYA: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chYz: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chYr_info" {
     block_chYr_info:
         const _chYr;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.862561508 UTC

[section ""data" . GHC.Base.$fApplicativeIO_$cliftA2_closure" {
     GHC.Base.$fApplicativeIO_$cliftA2_closure:
         const GHC.Base.$fApplicativeIO_$cliftA2_info;
 },
 GHC.Base.$fApplicativeIO_$cliftA2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       chYW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $cliftA2_r7PG_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeIO_$cliftA2_info" {
     GHC.Base.$fApplicativeIO_$cliftA2_info:
         const GHC.Base.$fApplicativeIO_$cliftA2_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.866821761 UTC

[section ""data" . GHC.Base.liftA1_closure" {
     GHC.Base.liftA1_closure:
         const GHC.Base.liftA1_info;
 },
 GHC.Base.liftA1_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       chZe: // global
           if ((Sp + -32) < SpLim) (likely: False) goto chZf; else goto chZg;
       chZf: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftA1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       chZg: // global
           I64[Sp - 32] = block_chZ7_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftA1_info" {
     GHC.Base.liftA1_info:
         const GHC.Base.liftA1_entry;
         const 0;
         const 14;
         const 21474836504;
 },
 _chZ7() //  [R1]
         { []
         }
     {offset
       chZ7: // global
           I64[Sp] = block_chZ9_info;
           _sgQ4::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgQ4::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chZ7_info" {
     block_chZ7_info:
         const _chZ7;
         const 3;
         const 30;
 },
 _chZ9() //  [R1]
         { []
         }
     {offset
       chZ9: // global
           I64[Sp] = block_chZb_info;
           _sgQ7::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sgQ7::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chZ9_info" {
     block_chZ9_info:
         const _chZ9;
         const 3;
         const 30;
 },
 _chZb() //  [R1]
         { []
         }
     {offset
       chZb: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto chZl; else goto chZk;
       chZl: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       chZk: // global
           I64[Hp - 40] = stg_ap_4_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R1 = Hp - 40;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chZb_info" {
     block_chZb_info:
         const _chZb;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.875040919 UTC

[section ""data" . GHC.Base.liftA3_$sliftA1_closure" {
     GHC.Base.liftA3_$sliftA1_closure:
         const GHC.Base.liftA3_$sliftA1_info;
 },
 GHC.Base.liftA3_$sliftA1_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       chZM: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftA1_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftA3_$sliftA1_info" {
     GHC.Base.liftA3_$sliftA1_info:
         const GHC.Base.liftA3_$sliftA1_entry;
         const 0;
         const 14;
         const 21474836504;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.879412762 UTC

[section ""data" . GHC.Base.$fSemigroupIO2_closure" {
     GHC.Base.$fSemigroupIO2_closure:
         const GHC.Base.$fSemigroupIO2_info;
 },
 sat_sgQm_entry() //  [R1]
         { []
         }
     {offset
       ci05: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ci06; else goto ci07;
       ci06: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ci07: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sgQm_info" {
     sat_sgQm_info:
         const sat_sgQm_entry;
         const 3;
         const 15;
 },
 GHC.Base.$fSemigroupIO2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ci08: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ci09; else goto ci0a;
       ci09: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ci0a: // global
           I64[Sp - 24] = block_chZX_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupIO2_info" {
     GHC.Base.$fSemigroupIO2_info:
         const GHC.Base.$fSemigroupIO2_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _chZX() //  [R1]
         { []
         }
     {offset
       chZX: // global
           I64[Sp] = block_chZZ_info;
           _sgQi::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgQi::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_chZX_info" {
     block_chZX_info:
         const _chZX;
         const 2;
         const 30;
 },
 _chZZ() //  [R1]
         { []
         }
     {offset
       chZZ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ci0e; else goto ci0d;
       ci0e: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ci0d: // global
           I64[Hp - 32] = sat_sgQm_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_chZZ_info" {
     block_chZZ_info:
         const _chZZ;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.889903589 UTC

[section ""data" . GHC.Base.$w$csconcat4_closure" {
     GHC.Base.$w$csconcat4_closure:
         const GHC.Base.$w$csconcat4_info;
 },
 sat_sgQE_entry() //  [R1]
         { []
         }
     {offset
       ci11: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ci12; else goto ci13;
       ci12: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ci13: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sgQE_info" {
     sat_sgQE_info:
         const sat_sgQE_entry;
         const 3;
         const 15;
 },
 go_sgQr_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       ci18: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ci19; else goto ci1a;
       ci19: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ci1a: // global
           I64[Sp - 32] = block_ci0N_info;
           _sgQr::P64 = R1;
           _sgQn::P64 = P64[R1 + 5];
           R1 = R3;
           P64[Sp - 24] = _sgQn::P64;
           P64[Sp - 16] = _sgQr::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ui1i; else goto ci0O;
       ui1i: // global
           call _ci0N(R1) args: 0, res: 0, upd: 0;
       ci0O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_sgQr_info" {
     go_sgQr_info:
         const go_sgQr_entry;
         const 1;
         const 9;
         const 12884901903;
 },
 _ci0N() //  [R1]
         { []
         }
     {offset
       ci0N: // global
           _sgQs::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto ci15; else goto ci16;
       ci15: // global
           R1 = _sgQs::P64;
           Sp = Sp + 32;
           call stg_ap_v_fast(R1) args: 8, res: 0, upd: 8;
       ci16: // global
           I64[Sp - 8] = block_ci0T_info;
           _sgQw::P64 = P64[R1 + 6];
           _sgQx::P64 = P64[R1 + 14];
           R1 = _sgQs::P64;
           P64[Sp] = _sgQx::P64;
           P64[Sp + 24] = _sgQw::P64;
           Sp = Sp - 8;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ci0N_info" {
     block_ci0N_info:
         const _ci0N;
         const 3;
         const 30;
 },
 _ci0T() //  [R1]
         { []
         }
     {offset
       ci0T: // global
           _sgQx::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ci0V_info;
           R3 = _sgQx::P64;
           R2 = P64[Sp + 32];
           _sgQA::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 32] = _sgQA::P64;
           Sp = Sp + 8;
           call go_sgQr_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ci0T_info" {
     block_ci0T_info:
         const _ci0T;
         const 4;
         const 30;
 },
 _ci0V() //  [R1]
         { []
         }
     {offset
       ci0V: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ci1h; else goto ci1g;
       ci1h: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ci1g: // global
           I64[Hp - 32] = sat_sgQE_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ci0V_info" {
     block_ci0V_info:
         const _ci0V;
         const 131;
         const 30;
 },
 GHC.Base.$w$csconcat4_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ci1j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ci1n; else goto ci1m;
       ci1n: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ci1m: // global
           I64[Hp - 8] = go_sgQr_info;
           P64[Hp] = R2;
           _sgQo::P64 = R3;
           R3 = R4;
           R2 = _sgQo::P64;
           R1 = Hp - 5;
           call go_sgQr_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$csconcat4_info" {
     GHC.Base.$w$csconcat4_info:
         const GHC.Base.$w$csconcat4_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.902872373 UTC

[section ""data" . GHC.Base.$fSemigroupIO1_closure" {
     GHC.Base.$fSemigroupIO1_closure:
         const GHC.Base.$fSemigroupIO1_info;
 },
 GHC.Base.$fSemigroupIO1_entry() //  [R2, R3]
         { []
         }
     {offset
       ci25: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ci26; else goto ci27;
       ci26: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ci27: // global
           I64[Sp - 16] = block_ci22_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ui2b; else goto ci23;
       ui2b: // global
           call _ci22(R1) args: 0, res: 0, upd: 0;
       ci23: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupIO1_info" {
     GHC.Base.$fSemigroupIO1_info:
         const GHC.Base.$fSemigroupIO1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _ci22() //  [R1]
         { []
         }
     {offset
       ci22: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat4_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ci22_info" {
     block_ci22_info:
         const _ci22;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.910181933 UTC

[section ""data" . GHC.Base.$fSemigroupIO_closure" {
     GHC.Base.$fSemigroupIO_closure:
         const GHC.Base.$fSemigroupIO_info;
         const 0;
 },
 sat_sgQO_entry() //  [R1, R2]
         { []
         }
     {offset
       ci2v: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroupIO_$cstimes_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgQO_info" {
     sat_sgQO_info:
         const sat_sgQO_entry;
         const 1;
         const 4294967305;
         const 4294967301;
         const Si3a_srt;
 },
 sat_sgQN_entry() //  [R1, R2]
         { []
         }
     {offset
       ci2D: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fSemigroupIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgQN_info" {
     sat_sgQN_info:
         const sat_sgQN_entry;
         const 1;
         const 9;
         const 8589934597;
 },
 sat_sgQM_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       ci2L: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroupIO2_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgQM_info" {
     sat_sgQM_info:
         const sat_sgQM_entry;
         const 1;
         const 9;
         const 12884901903;
 },
 GHC.Base.$fSemigroupIO_entry() //  [R2]
         { []
         }
     {offset
       ci2P: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ci2T; else goto ci2S;
       ci2T: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ci2S: // global
           I64[Hp - 72] = sat_sgQO_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgQN_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sgQM_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 37;
           P64[Hp - 8] = Hp - 54;
           P64[Hp] = Hp - 71;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupIO_info" {
     GHC.Base.$fSemigroupIO_info:
         const GHC.Base.$fSemigroupIO_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const Si3a_srt;
 },
 section ""data" . GHC.Base.$fSemigroupIO_$cstimes_closure" {
     GHC.Base.$fSemigroupIO_$cstimes_closure:
         const GHC.Base.$fSemigroupIO_$cstimes_info;
         const 0;
 },
 sat_sgQR_entry() //  [R1]
         { []
         }
     {offset
       ci32: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ci33; else goto ci34;
       ci33: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ci34: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fSemigroupIO_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sgQR_info" {
     sat_sgQR_info:
         const sat_sgQR_entry;
         const 1;
         const 4294967312;
         const Si3a_srt+8;
 },
 GHC.Base.$fSemigroupIO_$cstimes_entry() //  [R2, R3]
         { []
         }
     {offset
       ci35: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ci39; else goto ci38;
       ci39: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupIO_$cstimes_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ci38: // global
           I64[Hp - 16] = sat_sgQR_info;
           P64[Hp] = R2;
           _sgQQ::P64 = R3;
           R3 = Hp - 16;
           R2 = _sgQQ::P64;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupIO_$cstimes_info" {
     GHC.Base.$fSemigroupIO_$cstimes_info:
         const GHC.Base.$fSemigroupIO_$cstimes_entry;
         const 0;
         const 30064771086;
         const 8589934607;
         const Si3a_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.922570424 UTC

[section ""data" . GHC.Base.$fMonoidIO_$cp1Monoid_closure" {
     GHC.Base.$fMonoidIO_$cp1Monoid_closure:
         const GHC.Base.$fMonoidIO_$cp1Monoid_info;
         const 0;
 },
 sat_sgQT_entry() //  [R1]
         { []
         }
     {offset
       ci3O: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ci3P; else goto ci3Q;
       ci3P: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ci3Q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sgQT_info" {
     sat_sgQT_info:
         const sat_sgQT_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fMonoidIO_$cp1Monoid_entry() //  [R2]
         { []
         }
     {offset
       ci3R: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ci3V; else goto ci3U;
       ci3V: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fMonoidIO_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ci3U: // global
           I64[Hp - 16] = sat_sgQT_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroupIO_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoidIO_$cp1Monoid_info" {
     GHC.Base.$fMonoidIO_$cp1Monoid_info:
         const GHC.Base.$fMonoidIO_$cp1Monoid_entry;
         const 0;
         const 21474836494;
         const 4294967301;
         const Si3a_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.928879239 UTC

[section ""data" . $cmappend_r7PH_closure" {
     $cmappend_r7PH_closure:
         const $cmappend_r7PH_info;
 },
 sat_sgR5_entry() //  [R1]
         { []
         }
     {offset
       ci4k: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ci4l; else goto ci4m;
       ci4l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ci4m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ci4i_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sgR5_info" {
     sat_sgR5_info:
         const sat_sgR5_entry;
         const 3;
         const 15;
 },
 _ci4i() //  [R1]
         { []
         }
     {offset
       ci4i: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ci4i_info" {
     block_ci4i_info:
         const _ci4i;
         const 2;
         const 30;
 },
 $cmappend_r7PH_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ci4q: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ci4r; else goto ci4s;
       ci4r: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = $cmappend_r7PH_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ci4s: // global
           I64[Sp - 24] = block_ci4a_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . $cmappend_r7PH_info" {
     $cmappend_r7PH_info:
         const $cmappend_r7PH_entry;
         const 0;
         const 14;
         const 17179869207;
 },
 _ci4a() //  [R1]
         { []
         }
     {offset
       ci4a: // global
           I64[Sp] = block_ci4c_info;
           _sgR0::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgR0::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ci4a_info" {
     block_ci4a_info:
         const _ci4a;
         const 2;
         const 30;
 },
 _ci4c() //  [R1]
         { []
         }
     {offset
       ci4c: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ci4w; else goto ci4v;
       ci4w: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ci4v: // global
           I64[Hp - 32] = sat_sgR5_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ci4c_info" {
     block_ci4c_info:
         const _ci4c;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.93939579 UTC

[section ""data" . GHC.Base.$fMonoidIO_$cmappend_closure" {
     GHC.Base.$fMonoidIO_$cmappend_closure:
         const GHC.Base.$fMonoidIO_$cmappend_info;
 },
 GHC.Base.$fMonoidIO_$cmappend_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ci54: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call $cmappend_r7PH_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoidIO_$cmappend_info" {
     GHC.Base.$fMonoidIO_$cmappend_info:
         const GHC.Base.$fMonoidIO_$cmappend_entry;
         const 0;
         const 14;
         const 17179869207;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.942633283 UTC

[section ""data" . GHC.Base.$fAlternativeIO1_closure" {
     GHC.Base.$fAlternativeIO1_closure:
         const GHC.Base.$fAlternativeIO1_info;
 },
 GHC.Base.$fAlternativeIO1_entry() //  []
         { []
         }
     {offset
       ci5f: // global
           R1 = GHC.Types.[]_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fAlternativeIO1_info" {
     GHC.Base.$fAlternativeIO1_info:
         const GHC.Base.$fAlternativeIO1_entry;
         const 0;
         const 14;
         const 4294967299;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.947042956 UTC

[section ""data" . GHC.Base.$fAlternativeIO2_closure" {
     GHC.Base.$fAlternativeIO2_closure:
         const GHC.Base.$fAlternativeIO2_info;
         const 0;
 },
 some_v_sgR9_entry() //  [R1]
         { []
         }
     {offset
       ci5C: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ci5D; else goto ci5E;
       ci5D: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ci5E: // global
           I64[Sp - 16] = block_ci5x_info;
           _sgR9::P64 = R1;
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sgR9::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . some_v_sgR9_info" {
     some_v_sgR9_info:
         const some_v_sgR9_entry;
         const 1;
         const 4294967305;
         const 4294967299;
         const Si3a_srt+32;
 },
 _ci5x() //  [R1]
         { []
         }
     {offset
       ci5x: // global
           I64[Sp] = block_ci5z_info;
           R3 = GHC.Base.$fAlternativeIO1_closure+1;
           R2 = P64[Sp + 8];
           _sgRd::P64 = R1;
           R1 = GHC.IO.mplusIO_closure;
           P64[Sp + 8] = _sgRd::P64;
           call stg_ap_ppv_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ci5x_info" {
     block_ci5x_info:
         const _ci5x;
         const 1;
         const 4294967326;
         const Si3a_srt+32;
 },
 _ci5z() //  [R1]
         { []
         }
     {offset
       ci5z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ci5I; else goto ci5H;
       ci5I: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ci5H: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ci5z_info" {
     block_ci5z_info:
         const _ci5z;
         const 1;
         const 30;
 },
 GHC.Base.$fAlternativeIO2_entry() //  [R2]
         { []
         }
     {offset
       ci5J: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ci5N; else goto ci5M;
       ci5N: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeIO2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ci5M: // global
           I64[Hp - 8] = some_v_sgR9_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call some_v_sgR9_entry(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fAlternativeIO2_info" {
     GHC.Base.$fAlternativeIO2_info:
         const GHC.Base.$fAlternativeIO2_entry;
         const 0;
         const 12884901902;
         const 8589934597;
         const Si3a_srt+32;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.957157839 UTC

[section ""data" . GHC.Base.$fAlternativeIO_$cmany_closure" {
     GHC.Base.$fAlternativeIO_$cmany_closure:
         const GHC.Base.$fAlternativeIO_$cmany_info;
         const 0;
 },
 sat_sgRs_entry() //  [R1]
         { []
         }
     {offset
       ci6q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ci6r; else goto ci6s;
       ci6r: // global
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ci6s: // global
           I64[Sp - 16] = block_ci6l_info;
           _sgRj::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sgRj::P64;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgRs_info" {
     sat_sgRs_info:
         const sat_sgRs_entry;
         const 2;
         const 11;
         const 4294967299;
 },
 _ci6l() //  [R1]
         { []
         }
     {offset
       ci6l: // global
           I64[Sp] = block_ci6n_info;
           _sgRn::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sgRn::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ci6l_info" {
     block_ci6l_info:
         const _ci6l;
         const 1;
         const 30;
 },
 _ci6n() //  [R1]
         { []
         }
     {offset
       ci6n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ci6w; else goto ci6v;
       ci6w: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ci6v: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ci6n_info" {
     block_ci6n_info:
         const _ci6n;
         const 1;
         const 30;
 },
 many_v_sgRj_entry() //  [R1]
         { []
         }
     {offset
       ci6x: // global
           _sgRj::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ci6y; else goto ci6z;
       ci6z: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ci6B; else goto ci6A;
       ci6B: // global
           HpAlloc = 24;
           goto ci6y;
       ci6y: // global
           R1 = _sgRj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ci6A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgRj::P64;
           _sgRi::P64 = P64[_sgRj::P64 + 16];
           I64[Hp - 16] = sat_sgRs_info;
           P64[Hp - 8] = _sgRi::P64;
           P64[Hp] = _sgRj::P64;
           R3 = GHC.Base.$fAlternativeIO1_closure+1;
           R2 = Hp - 15;
           R1 = GHC.IO.mplusIO_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . many_v_sgRj_info" {
     many_v_sgRj_info:
         const many_v_sgRj_entry;
         const 1;
         const 4294967312;
         const Si3a_srt+32;
 },
 GHC.Base.$fAlternativeIO_$cmany_entry() //  [R2]
         { []
         }
     {offset
       ci6C: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ci6G; else goto ci6F;
       ci6G: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeIO_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ci6F: // global
           I64[Hp - 16] = many_v_sgRj_info;
           P64[Hp] = R2;
           R1 = Hp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fAlternativeIO_$cmany_info" {
     GHC.Base.$fAlternativeIO_$cmany_info:
         const GHC.Base.$fAlternativeIO_$cmany_entry;
         const 0;
         const 21474836494;
         const 4294967301;
         const Si3a_srt+32;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.968558798 UTC

[section ""data" . GHC.Base.liftM9_closure" {
     GHC.Base.liftM9_closure:
         const GHC.Base.liftM9_info;
 },
 GHC.Base.liftM9_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ci7m: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ci7n; else goto ci7o;
       ci7n: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM9_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ci7o: // global
           I64[Sp - 40] = block_ci7b_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM9_info" {
     GHC.Base.liftM9_info:
         const GHC.Base.liftM9_entry;
         const 0;
         const 14;
         const 30064771098;
 },
 _ci7b() //  [R1]
         { []
         }
     {offset
       ci7b: // global
           I64[Sp] = block_ci7d_info;
           _sgRC::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgRC::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ci7b_info" {
     block_ci7b_info:
         const _ci7b;
         const 5;
         const 30;
 },
 _ci7d() //  [R1]
         { []
         }
     {offset
       ci7d: // global
           I64[Sp] = block_ci7f_info;
           _sgRF::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sgRF::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ci7d_info" {
     block_ci7d_info:
         const _ci7d;
         const 5;
         const 30;
 },
 _ci7f() //  [R1]
         { []
         }
     {offset
       ci7f: // global
           I64[Sp] = block_ci7h_info;
           _sgRI::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sgRI::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ci7f_info" {
     block_ci7f_info:
         const _ci7f;
         const 5;
         const 30;
 },
 _ci7h() //  [R1]
         { []
         }
     {offset
       ci7h: // global
           I64[Sp] = block_ci7j_info;
           _sgRL::P64 = R1;
           R1 = P64[Sp + 40];
           P64[Sp + 40] = _sgRL::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ci7h_info" {
     block_ci7h_info:
         const _ci7h;
         const 5;
         const 30;
 },
 _ci7j() //  [R1]
         { []
         }
     {offset
       ci7j: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ci7v; else goto ci7u;
       ci7v: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ci7u: // global
           I64[Hp - 56] = stg_ap_6_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R1 = Hp - 56;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ci7j_info" {
     block_ci7j_info:
         const _ci7j;
         const 5;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.980539863 UTC

[section ""data" . GHC.Base.liftM5_$sliftM1_closure" {
     GHC.Base.liftM5_$sliftM1_closure:
         const GHC.Base.liftM5_$sliftM1_info;
 },
 GHC.Base.liftM5_$sliftM1_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ci86: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftM9_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM5_$sliftM1_info" {
     GHC.Base.liftM5_$sliftM1_info:
         const GHC.Base.liftM5_$sliftM1_entry;
         const 0;
         const 14;
         const 30064771098;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:56.987893649 UTC

[section ""data" . GHC.Base.liftM5_closure" {
     GHC.Base.liftM5_closure:
         const GHC.Base.liftM5_info;
 },
 GHC.Base.liftM5_slow() //  [R1]
         { []
         }
     {offset
       ci8e: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.liftM5_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2,
                                      R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_sgS3_entry() //  [R1, R2]
         { []
         }
     {offset
       ci8I: // global
           _sgS1::P64 = R2;
           _sgS3::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ci8J; else goto ci8K;
       ci8K: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ci8M; else goto ci8L;
       ci8M: // global
           HpAlloc = 64;
           goto ci8J;
       ci8J: // global
           R2 = _sgS1::P64;
           R1 = _sgS3::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ci8L: // global
           _sgRQ::P64 = P64[_sgS3::P64 + 7];
           _sgRR::P64 = P64[_sgS3::P64 + 15];
           _sgRX::P64 = P64[_sgS3::P64 + 23];
           _sgRY::P64 = P64[_sgS3::P64 + 31];
           _sgRZ::P64 = P64[_sgS3::P64 + 39];
           _sgS0::P64 = P64[_sgS3::P64 + 47];
           I64[Hp - 56] = stg_ap_6_upd_info;
           P64[Hp - 40] = _sgRR::P64;
           P64[Hp - 32] = _sgRX::P64;
           P64[Hp - 24] = _sgRY::P64;
           P64[Hp - 16] = _sgRZ::P64;
           P64[Hp - 8] = _sgS0::P64;
           P64[Hp] = _sgS1::P64;
           R2 = _sgRQ::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgS3_info" {
     sat_sgS3_info:
         const sat_sgS3_entry;
         const 6;
         const 8;
         const 4294967301;
 },
 sat_sgS4_entry() //  [R1, R2]
         { []
         }
     {offset
       ci8N: // global
           _sgS0::P64 = R2;
           _sgS4::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ci8O; else goto ci8P;
       ci8P: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ci8R; else goto ci8Q;
       ci8R: // global
           HpAlloc = 56;
           goto ci8O;
       ci8O: // global
           R2 = _sgS0::P64;
           R1 = _sgS4::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ci8Q: // global
           _sgRQ::P64 = P64[_sgS4::P64 + 7];
           _sgRR::P64 = P64[_sgS4::P64 + 15];
           _sgRW::P64 = P64[_sgS4::P64 + 23];
           _sgRX::P64 = P64[_sgS4::P64 + 31];
           _sgRY::P64 = P64[_sgS4::P64 + 39];
           _sgRZ::P64 = P64[_sgS4::P64 + 47];
           I64[Hp - 48] = sat_sgS3_info;
           P64[Hp - 40] = _sgRQ::P64;
           P64[Hp - 32] = _sgRR::P64;
           P64[Hp - 24] = _sgRX::P64;
           P64[Hp - 16] = _sgRY::P64;
           P64[Hp - 8] = _sgRZ::P64;
           P64[Hp] = _sgS0::P64;
           R2 = _sgRQ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgRW::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgS4_info" {
     sat_sgS4_info:
         const sat_sgS4_entry;
         const 6;
         const 8;
         const 4294967301;
 },
 sat_sgS5_entry() //  [R1, R2]
         { []
         }
     {offset
       ci8S: // global
           _sgRZ::P64 = R2;
           _sgS5::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ci8T; else goto ci8U;
       ci8U: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ci8W; else goto ci8V;
       ci8W: // global
           HpAlloc = 56;
           goto ci8T;
       ci8T: // global
           R2 = _sgRZ::P64;
           R1 = _sgS5::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ci8V: // global
           _sgRQ::P64 = P64[_sgS5::P64 + 7];
           _sgRR::P64 = P64[_sgS5::P64 + 15];
           _sgRV::P64 = P64[_sgS5::P64 + 23];
           _sgRW::P64 = P64[_sgS5::P64 + 31];
           _sgRX::P64 = P64[_sgS5::P64 + 39];
           _sgRY::P64 = P64[_sgS5::P64 + 47];
           I64[Hp - 48] = sat_sgS4_info;
           P64[Hp - 40] = _sgRQ::P64;
           P64[Hp - 32] = _sgRR::P64;
           P64[Hp - 24] = _sgRW::P64;
           P64[Hp - 16] = _sgRX::P64;
           P64[Hp - 8] = _sgRY::P64;
           P64[Hp] = _sgRZ::P64;
           R2 = _sgRQ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgRV::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgS5_info" {
     sat_sgS5_info:
         const sat_sgS5_entry;
         const 6;
         const 8;
         const 4294967301;
 },
 sat_sgS6_entry() //  [R1, R2]
         { []
         }
     {offset
       ci8X: // global
           _sgRY::P64 = R2;
           _sgS6::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ci8Y; else goto ci8Z;
       ci8Z: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ci91; else goto ci90;
       ci91: // global
           HpAlloc = 56;
           goto ci8Y;
       ci8Y: // global
           R2 = _sgRY::P64;
           R1 = _sgS6::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ci90: // global
           _sgRQ::P64 = P64[_sgS6::P64 + 7];
           _sgRR::P64 = P64[_sgS6::P64 + 15];
           _sgRU::P64 = P64[_sgS6::P64 + 23];
           _sgRV::P64 = P64[_sgS6::P64 + 31];
           _sgRW::P64 = P64[_sgS6::P64 + 39];
           _sgRX::P64 = P64[_sgS6::P64 + 47];
           I64[Hp - 48] = sat_sgS5_info;
           P64[Hp - 40] = _sgRQ::P64;
           P64[Hp - 32] = _sgRR::P64;
           P64[Hp - 24] = _sgRV::P64;
           P64[Hp - 16] = _sgRW::P64;
           P64[Hp - 8] = _sgRX::P64;
           P64[Hp] = _sgRY::P64;
           R2 = _sgRQ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgRU::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgS6_info" {
     sat_sgS6_info:
         const sat_sgS6_entry;
         const 6;
         const 8;
         const 4294967301;
 },
 sat_sgS7_entry() //  [R1, R2]
         { []
         }
     {offset
       ci92: // global
           _sgRX::P64 = R2;
           _sgS7::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ci93; else goto ci94;
       ci94: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ci96; else goto ci95;
       ci96: // global
           HpAlloc = 56;
           goto ci93;
       ci93: // global
           R2 = _sgRX::P64;
           R1 = _sgS7::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ci95: // global
           _sgRQ::P64 = P64[_sgS7::P64 + 7];
           _sgRR::P64 = P64[_sgS7::P64 + 15];
           _sgRT::P64 = P64[_sgS7::P64 + 23];
           _sgRU::P64 = P64[_sgS7::P64 + 31];
           _sgRV::P64 = P64[_sgS7::P64 + 39];
           _sgRW::P64 = P64[_sgS7::P64 + 47];
           I64[Hp - 48] = sat_sgS6_info;
           P64[Hp - 40] = _sgRQ::P64;
           P64[Hp - 32] = _sgRR::P64;
           P64[Hp - 24] = _sgRU::P64;
           P64[Hp - 16] = _sgRV::P64;
           P64[Hp - 8] = _sgRW::P64;
           P64[Hp] = _sgRX::P64;
           R2 = _sgRQ::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgRT::P64;
           P64[Sp - 8] = Hp - 47;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgS7_info" {
     sat_sgS7_info:
         const sat_sgS7_entry;
         const 6;
         const 8;
         const 4294967301;
 },
 GHC.Base.liftM5_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ci97: // global
           _sgRU::P64 = R6;
           _sgRT::P64 = R5;
           _sgRS::P64 = R4;
           _sgRR::P64 = R3;
           _sgRQ::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ci98; else goto ci99;
       ci99: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ci9b; else goto ci9a;
       ci9b: // global
           HpAlloc = 56;
           goto ci98;
       ci98: // global
           R1 = GHC.Base.liftM5_closure;
           P64[Sp - 40] = _sgRQ::P64;
           P64[Sp - 32] = _sgRR::P64;
           P64[Sp - 24] = _sgRS::P64;
           P64[Sp - 16] = _sgRT::P64;
           P64[Sp - 8] = _sgRU::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       ci9a: // global
           I64[Hp - 48] = sat_sgS7_info;
           P64[Hp - 40] = _sgRQ::P64;
           P64[Hp - 32] = _sgRR::P64;
           P64[Hp - 24] = _sgRT::P64;
           P64[Hp - 16] = _sgRU::P64;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = P64[Sp + 8];
           R2 = _sgRQ::P64;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _sgRS::P64;
           P64[Sp + 8] = Hp - 47;
           Sp = Sp - 8;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM5_info" {
     GHC.Base.liftM5_info:
         const GHC.Base.liftM5_entry;
         const 0;
         const 14;
         const 30064771072;
         const 0;
         const 7;
         const GHC.Base.liftM5_slow;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.004210859 UTC

[section ""data" . GHC.Base.liftM8_closure" {
     GHC.Base.liftM8_closure:
         const GHC.Base.liftM8_info;
 },
 GHC.Base.liftM8_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ciaa: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ciab; else goto ciac;
       ciab: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftM8_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ciac: // global
           I64[Sp - 40] = block_cia1_info;
           R1 = R3;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM8_info" {
     GHC.Base.liftM8_info:
         const GHC.Base.liftM8_entry;
         const 0;
         const 14;
         const 25769803801;
 },
 _cia1() //  [R1]
         { []
         }
     {offset
       cia1: // global
           I64[Sp] = block_cia3_info;
           _sgSg::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgSg::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cia1_info" {
     block_cia1_info:
         const _cia1;
         const 4;
         const 30;
 },
 _cia3() //  [R1]
         { []
         }
     {offset
       cia3: // global
           I64[Sp] = block_cia5_info;
           _sgSj::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sgSj::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cia3_info" {
     block_cia3_info:
         const _cia3;
         const 4;
         const 30;
 },
 _cia5() //  [R1]
         { []
         }
     {offset
       cia5: // global
           I64[Sp] = block_cia7_info;
           _sgSm::P64 = R1;
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sgSm::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cia5_info" {
     block_cia5_info:
         const _cia5;
         const 4;
         const 30;
 },
 _cia7() //  [R1]
         { []
         }
     {offset
       cia7: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ciai; else goto ciah;
       ciai: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciah: // global
           I64[Hp - 48] = stg_ap_5_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R1 = Hp - 48;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cia7_info" {
     block_cia7_info:
         const _cia7;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.014259943 UTC

[section ""data" . GHC.Base.liftM4_$sliftM1_closure" {
     GHC.Base.liftM4_$sliftM1_closure:
         const GHC.Base.liftM4_$sliftM1_info;
 },
 GHC.Base.liftM4_$sliftM1_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ciaO: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftM8_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM4_$sliftM1_info" {
     GHC.Base.liftM4_$sliftM1_info:
         const GHC.Base.liftM4_$sliftM1_entry;
         const 0;
         const 14;
         const 25769803801;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.020577766 UTC

[section ""data" . GHC.Base.liftM4_closure" {
     GHC.Base.liftM4_closure:
         const GHC.Base.liftM4_info;
 },
 sat_sgSC_entry() //  [R1, R2]
         { []
         }
     {offset
       cibk: // global
           _sgSA::P64 = R2;
           _sgSC::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cibl; else goto cibm;
       cibm: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cibo; else goto cibn;
       cibo: // global
           HpAlloc = 56;
           goto cibl;
       cibl: // global
           R2 = _sgSA::P64;
           R1 = _sgSC::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cibn: // global
           _sgSr::P64 = P64[_sgSC::P64 + 7];
           _sgSs::P64 = P64[_sgSC::P64 + 15];
           _sgSx::P64 = P64[_sgSC::P64 + 23];
           _sgSy::P64 = P64[_sgSC::P64 + 31];
           _sgSz::P64 = P64[_sgSC::P64 + 39];
           I64[Hp - 48] = stg_ap_5_upd_info;
           P64[Hp - 32] = _sgSs::P64;
           P64[Hp - 24] = _sgSx::P64;
           P64[Hp - 16] = _sgSy::P64;
           P64[Hp - 8] = _sgSz::P64;
           P64[Hp] = _sgSA::P64;
           R2 = _sgSr::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgSC_info" {
     sat_sgSC_info:
         const sat_sgSC_entry;
         const 5;
         const 8;
         const 4294967301;
 },
 sat_sgSD_entry() //  [R1, R2]
         { []
         }
     {offset
       cibp: // global
           _sgSz::P64 = R2;
           _sgSD::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cibq; else goto cibr;
       cibr: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cibt; else goto cibs;
       cibt: // global
           HpAlloc = 48;
           goto cibq;
       cibq: // global
           R2 = _sgSz::P64;
           R1 = _sgSD::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cibs: // global
           _sgSr::P64 = P64[_sgSD::P64 + 7];
           _sgSs::P64 = P64[_sgSD::P64 + 15];
           _sgSw::P64 = P64[_sgSD::P64 + 23];
           _sgSx::P64 = P64[_sgSD::P64 + 31];
           _sgSy::P64 = P64[_sgSD::P64 + 39];
           I64[Hp - 40] = sat_sgSC_info;
           P64[Hp - 32] = _sgSr::P64;
           P64[Hp - 24] = _sgSs::P64;
           P64[Hp - 16] = _sgSx::P64;
           P64[Hp - 8] = _sgSy::P64;
           P64[Hp] = _sgSz::P64;
           R2 = _sgSr::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgSw::P64;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgSD_info" {
     sat_sgSD_info:
         const sat_sgSD_entry;
         const 5;
         const 8;
         const 4294967301;
 },
 sat_sgSE_entry() //  [R1, R2]
         { []
         }
     {offset
       cibu: // global
           _sgSy::P64 = R2;
           _sgSE::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cibv; else goto cibw;
       cibw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ciby; else goto cibx;
       ciby: // global
           HpAlloc = 48;
           goto cibv;
       cibv: // global
           R2 = _sgSy::P64;
           R1 = _sgSE::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cibx: // global
           _sgSr::P64 = P64[_sgSE::P64 + 7];
           _sgSs::P64 = P64[_sgSE::P64 + 15];
           _sgSv::P64 = P64[_sgSE::P64 + 23];
           _sgSw::P64 = P64[_sgSE::P64 + 31];
           _sgSx::P64 = P64[_sgSE::P64 + 39];
           I64[Hp - 40] = sat_sgSD_info;
           P64[Hp - 32] = _sgSr::P64;
           P64[Hp - 24] = _sgSs::P64;
           P64[Hp - 16] = _sgSw::P64;
           P64[Hp - 8] = _sgSx::P64;
           P64[Hp] = _sgSy::P64;
           R2 = _sgSr::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgSv::P64;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgSE_info" {
     sat_sgSE_info:
         const sat_sgSE_entry;
         const 5;
         const 8;
         const 4294967301;
 },
 sat_sgSF_entry() //  [R1, R2]
         { []
         }
     {offset
       cibz: // global
           _sgSx::P64 = R2;
           _sgSF::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cibA; else goto cibB;
       cibB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cibD; else goto cibC;
       cibD: // global
           HpAlloc = 48;
           goto cibA;
       cibA: // global
           R2 = _sgSx::P64;
           R1 = _sgSF::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cibC: // global
           _sgSr::P64 = P64[_sgSF::P64 + 7];
           _sgSs::P64 = P64[_sgSF::P64 + 15];
           _sgSu::P64 = P64[_sgSF::P64 + 23];
           _sgSv::P64 = P64[_sgSF::P64 + 31];
           _sgSw::P64 = P64[_sgSF::P64 + 39];
           I64[Hp - 40] = sat_sgSE_info;
           P64[Hp - 32] = _sgSr::P64;
           P64[Hp - 24] = _sgSs::P64;
           P64[Hp - 16] = _sgSv::P64;
           P64[Hp - 8] = _sgSw::P64;
           P64[Hp] = _sgSx::P64;
           R2 = _sgSr::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgSu::P64;
           P64[Sp - 8] = Hp - 39;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgSF_info" {
     sat_sgSF_info:
         const sat_sgSF_entry;
         const 5;
         const 8;
         const 4294967301;
 },
 GHC.Base.liftM4_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cibE: // global
           _sgSv::P64 = R6;
           _sgSu::P64 = R5;
           _sgSt::P64 = R4;
           _sgSs::P64 = R3;
           _sgSr::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cibF; else goto cibG;
       cibG: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cibI; else goto cibH;
       cibI: // global
           HpAlloc = 48;
           goto cibF;
       cibF: // global
           R6 = _sgSv::P64;
           R5 = _sgSu::P64;
           R4 = _sgSt::P64;
           R3 = _sgSs::P64;
           R2 = _sgSr::P64;
           R1 = GHC.Base.liftM4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cibH: // global
           I64[Hp - 40] = sat_sgSF_info;
           P64[Hp - 32] = _sgSr::P64;
           P64[Hp - 24] = _sgSs::P64;
           P64[Hp - 16] = _sgSu::P64;
           P64[Hp - 8] = _sgSv::P64;
           P64[Hp] = P64[Sp];
           R2 = _sgSr::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _sgSt::P64;
           P64[Sp] = Hp - 39;
           Sp = Sp - 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM4_info" {
     GHC.Base.liftM4_info:
         const GHC.Base.liftM4_entry;
         const 0;
         const 14;
         const 25769803802;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.032233734 UTC

[section ""data" . GHC.Base.liftM3_$sliftM1_closure" {
     GHC.Base.liftM3_$sliftM1_closure:
         const GHC.Base.liftM3_$sliftM1_info;
 },
 GHC.Base.liftM3_$sliftM1_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cico: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.Base.liftA1_entry(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM3_$sliftM1_info" {
     GHC.Base.liftM3_$sliftM1_info:
         const GHC.Base.liftM3_$sliftM1_entry;
         const 0;
         const 14;
         const 21474836504;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.037692078 UTC

[section ""data" . GHC.Base.liftM3_closure" {
     GHC.Base.liftM3_closure:
         const GHC.Base.liftM3_info;
 },
 sat_sgSP_entry() //  [R1, R2]
         { []
         }
     {offset
       cicP: // global
           _sgSN::P64 = R2;
           _sgSP::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cicQ; else goto cicR;
       cicR: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cicT; else goto cicS;
       cicT: // global
           HpAlloc = 48;
           goto cicQ;
       cicQ: // global
           R2 = _sgSN::P64;
           R1 = _sgSP::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cicS: // global
           _sgSG::P64 = P64[_sgSP::P64 + 7];
           _sgSH::P64 = P64[_sgSP::P64 + 15];
           _sgSL::P64 = P64[_sgSP::P64 + 23];
           _sgSM::P64 = P64[_sgSP::P64 + 31];
           I64[Hp - 40] = stg_ap_4_upd_info;
           P64[Hp - 24] = _sgSH::P64;
           P64[Hp - 16] = _sgSL::P64;
           P64[Hp - 8] = _sgSM::P64;
           P64[Hp] = _sgSN::P64;
           R2 = _sgSG::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgSP_info" {
     sat_sgSP_info:
         const sat_sgSP_entry;
         const 4;
         const 8;
         const 4294967301;
 },
 sat_sgSQ_entry() //  [R1, R2]
         { []
         }
     {offset
       cicU: // global
           _sgSM::P64 = R2;
           _sgSQ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cicV; else goto cicW;
       cicW: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cicY; else goto cicX;
       cicY: // global
           HpAlloc = 40;
           goto cicV;
       cicV: // global
           R2 = _sgSM::P64;
           R1 = _sgSQ::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cicX: // global
           _sgSG::P64 = P64[_sgSQ::P64 + 7];
           _sgSH::P64 = P64[_sgSQ::P64 + 15];
           _sgSK::P64 = P64[_sgSQ::P64 + 23];
           _sgSL::P64 = P64[_sgSQ::P64 + 31];
           I64[Hp - 32] = sat_sgSP_info;
           P64[Hp - 24] = _sgSG::P64;
           P64[Hp - 16] = _sgSH::P64;
           P64[Hp - 8] = _sgSL::P64;
           P64[Hp] = _sgSM::P64;
           R2 = _sgSG::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgSK::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgSQ_info" {
     sat_sgSQ_info:
         const sat_sgSQ_entry;
         const 4;
         const 8;
         const 4294967301;
 },
 sat_sgSR_entry() //  [R1, R2]
         { []
         }
     {offset
       cicZ: // global
           _sgSL::P64 = R2;
           _sgSR::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cid0; else goto cid1;
       cid1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cid3; else goto cid2;
       cid3: // global
           HpAlloc = 40;
           goto cid0;
       cid0: // global
           R2 = _sgSL::P64;
           R1 = _sgSR::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cid2: // global
           _sgSG::P64 = P64[_sgSR::P64 + 7];
           _sgSH::P64 = P64[_sgSR::P64 + 15];
           _sgSJ::P64 = P64[_sgSR::P64 + 23];
           _sgSK::P64 = P64[_sgSR::P64 + 31];
           I64[Hp - 32] = sat_sgSQ_info;
           P64[Hp - 24] = _sgSG::P64;
           P64[Hp - 16] = _sgSH::P64;
           P64[Hp - 8] = _sgSK::P64;
           P64[Hp] = _sgSL::P64;
           R2 = _sgSG::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgSJ::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgSR_info" {
     sat_sgSR_info:
         const sat_sgSR_entry;
         const 4;
         const 8;
         const 4294967301;
 },
 GHC.Base.liftM3_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cid4: // global
           _sgSK::P64 = R6;
           _sgSJ::P64 = R5;
           _sgSI::P64 = R4;
           _sgSH::P64 = R3;
           _sgSG::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cid5; else goto cid6;
       cid6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cid8; else goto cid7;
       cid8: // global
           HpAlloc = 40;
           goto cid5;
       cid5: // global
           R6 = _sgSK::P64;
           R5 = _sgSJ::P64;
           R4 = _sgSI::P64;
           R3 = _sgSH::P64;
           R2 = _sgSG::P64;
           R1 = GHC.Base.liftM3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cid7: // global
           I64[Hp - 32] = sat_sgSR_info;
           P64[Hp - 24] = _sgSG::P64;
           P64[Hp - 16] = _sgSH::P64;
           P64[Hp - 8] = _sgSJ::P64;
           P64[Hp] = _sgSK::P64;
           R2 = _sgSG::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgSI::P64;
           P64[Sp - 8] = Hp - 31;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM3_info" {
     GHC.Base.liftM3_info:
         const GHC.Base.liftM3_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.047414549 UTC

[section ""data" . GHC.Base.liftM_$sliftM1_closure" {
     GHC.Base.liftM_$sliftM1_closure:
         const GHC.Base.liftM_$sliftM1_info;
 },
 GHC.Base.liftM_$sliftM1_entry() //  [R2, R3]
         { []
         }
     {offset
       cidG: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fFunctorIO2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM_$sliftM1_info" {
     GHC.Base.liftM_$sliftM1_info:
         const GHC.Base.liftM_$sliftM1_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.051923406 UTC

[section ""data" . GHC.Base.liftM_closure" {
     GHC.Base.liftM_closure:
         const GHC.Base.liftM_info;
 },
 sat_sgSX_entry() //  [R1, R2]
         { []
         }
     {offset
       cidX: // global
           _sgSV::P64 = R2;
           _sgSX::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cidY; else goto cidZ;
       cidZ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cie1; else goto cie0;
       cie1: // global
           HpAlloc = 32;
           goto cidY;
       cidY: // global
           R2 = _sgSV::P64;
           R1 = _sgSX::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cie0: // global
           _sgSS::P64 = P64[_sgSX::P64 + 7];
           _sgST::P64 = P64[_sgSX::P64 + 15];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgST::P64;
           P64[Hp] = _sgSV::P64;
           R2 = _sgSS::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgSX_info" {
     sat_sgSX_info:
         const sat_sgSX_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 GHC.Base.liftM_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cie2: // global
           _sgSU::P64 = R4;
           _sgST::P64 = R3;
           _sgSS::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cie3; else goto cie4;
       cie4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cie6; else goto cie5;
       cie6: // global
           HpAlloc = 24;
           goto cie3;
       cie3: // global
           R4 = _sgSU::P64;
           R3 = _sgST::P64;
           R2 = _sgSS::P64;
           R1 = GHC.Base.liftM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cie5: // global
           I64[Hp - 16] = sat_sgSX_info;
           P64[Hp - 8] = _sgSS::P64;
           P64[Hp] = _sgST::P64;
           R2 = _sgSS::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgSU::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftM_info" {
     GHC.Base.liftM_info:
         const GHC.Base.liftM_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.058137763 UTC

[section ""data" . GHC.Base.$!_closure" {
     GHC.Base.$!_closure:
         const GHC.Base.$!_info;
 },
 GHC.Base.$!_entry() //  [R2, R3]
         { []
         }
     {offset
       cies: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciet; else goto cieu;
       ciet: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$!_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cieu: // global
           I64[Sp - 16] = block_cieq_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$!_info" {
     GHC.Base.$!_info:
         const GHC.Base.$!_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cieq() //  [R1]
         { []
         }
     {offset
       cieq: // global
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cieq_info" {
     block_cieq_info:
         const _cieq;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.062970119 UTC

[section ""data" . GHC.Base.$_closure" {
     GHC.Base.$_closure:
         const GHC.Base.$_info;
 },
 GHC.Base.$_entry() //  [R2, R3]
         { []
         }
     {offset
       cieJ: // global
           _sgT1::P64 = R2;
           R2 = R3;
           R1 = _sgT1::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$_info" {
     GHC.Base.$_info:
         const GHC.Base.$_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.06659372 UTC

[section ""data" . GHC.Base.flip_closure" {
     GHC.Base.flip_closure:
         const GHC.Base.flip_info;
 },
 GHC.Base.flip_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cieU: // global
           R3 = R3;
           _sgT3::P64 = R2;
           R2 = R4;
           R1 = _sgT3::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.flip_info" {
     GHC.Base.flip_info:
         const GHC.Base.flip_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.069852904 UTC

[section ""data" . GHC.Base.$fMonad(->)_$c>>_closure" {
     GHC.Base.$fMonad(->)_$c>>_closure:
         const GHC.Base.$fMonad(->)_$c>>_info;
 },
 GHC.Base.$fMonad(->)_$c>>_entry() //  [R3, R4]
         { []
         }
     {offset
       cif5: // global
           R2 = R4;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonad(->)_$c>>_info" {
     GHC.Base.$fMonad(->)_$c>>_info:
         const GHC.Base.$fMonad(->)_$c>>_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.073014079 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$c<*_closure" {
     GHC.Base.$fApplicative(->)_$c<*_closure:
         const GHC.Base.$fApplicative(->)_$c<*_info;
 },
 GHC.Base.$fApplicative(->)_$c<*_entry() //  [R2, R4]
         { []
         }
     {offset
       cifg: // global
           _sgT9::P64 = R2;
           R2 = R4;
           R1 = _sgT9::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative(->)_$c<*_info" {
     GHC.Base.$fApplicative(->)_$c<*_info:
         const GHC.Base.$fApplicative(->)_$c<*_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.078555213 UTC

[section ""data" . GHC.Base.$fMonad(,)_$c>>_closure" {
     GHC.Base.$fMonad(,)_$c>>_closure:
         const GHC.Base.$fMonad(,)_$c>>_info;
 },
 sat_sgTm_entry() //  [R1]
         { []
         }
     {offset
       cifH: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cifI; else goto cifJ;
       cifI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cifJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cifF_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sgTm_info" {
     sat_sgTm_info:
         const sat_sgTm_entry;
         const 3;
         const 15;
 },
 _cifF() //  [R1]
         { []
         }
     {offset
       cifF: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cifF_info" {
     block_cifF_info:
         const _cifF;
         const 2;
         const 30;
 },
 GHC.Base.$fMonad(,)_$c>>_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cifN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cifP; else goto cifQ;
       cifP: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad(,)_$c>>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cifQ: // global
           I64[Sp - 24] = block_cifr_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uifW; else goto cifs;
       uifW: // global
           call _cifr(R1) args: 0, res: 0, upd: 0;
       cifs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonad(,)_$c>>_info" {
     GHC.Base.$fMonad(,)_$c>>_info:
         const GHC.Base.$fMonad(,)_$c>>_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cifr() //  [R1]
         { []
         }
     {offset
       cifr: // global
           I64[Sp] = block_cifw_info;
           _sgTg::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sgTg::P64;
           if (R1 & 7 != 0) goto uifV; else goto cifx;
       uifV: // global
           call _cifw(R1) args: 0, res: 0, upd: 0;
       cifx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cifr_info" {
     block_cifr_info:
         const _cifr;
         const 2;
         const 30;
 },
 _cifw() //  [R1]
         { []
         }
     {offset
       cifw: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cifU; else goto cifT;
       cifU: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cifT: // global
           _sgTj::P64 = P64[R1 + 7];
           _sgTk::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sgTm_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sgTj::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = _sgTk::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cifw_info" {
     block_cifw_info:
         const _cifw;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.090791854 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$c<*_closure" {
     GHC.Base.$fApplicative(,)_$c<*_closure:
         const GHC.Base.$fApplicative(,)_$c<*_info;
 },
 sat_sgTx_entry() //  [R1]
         { []
         }
     {offset
       cigO: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cigP; else goto cigQ;
       cigP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cigQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cigM_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sgTx_info" {
     sat_sgTx_info:
         const sat_sgTx_entry;
         const 3;
         const 15;
 },
 _cigM() //  [R1]
         { []
         }
     {offset
       cigM: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cigM_info" {
     block_cigM_info:
         const _cigM;
         const 2;
         const 30;
 },
 GHC.Base.$fApplicative(,)_$c<*_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cigU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cigW; else goto cigX;
       cigW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$c<*_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cigX: // global
           I64[Sp - 24] = block_cigy_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uih3; else goto cigz;
       uih3: // global
           call _cigy(R1) args: 0, res: 0, upd: 0;
       cigz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative(,)_$c<*_info" {
     GHC.Base.$fApplicative(,)_$c<*_info:
         const GHC.Base.$fApplicative(,)_$c<*_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cigy() //  [R1]
         { []
         }
     {offset
       cigy: // global
           I64[Sp - 8] = block_cigD_info;
           _sgTr::P64 = P64[R1 + 7];
           _sgTs::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sgTs::P64;
           P64[Sp + 16] = _sgTr::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uih2; else goto cigE;
       uih2: // global
           call _cigD(R1) args: 0, res: 0, upd: 0;
       cigE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cigy_info" {
     block_cigy_info:
         const _cigy;
         const 2;
         const 30;
 },
 _cigD() //  [R1]
         { []
         }
     {offset
       cigD: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cih1; else goto cih0;
       cih1: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cih0: // global
           _sgTu::P64 = P64[R1 + 7];
           I64[Hp - 56] = sat_sgTx_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _sgTu::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cigD_info" {
     block_cigD_info:
         const _cigD;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.102248575 UTC

[section ""data" . GHC.Base.$fFunctor(,)_$c<$_closure" {
     GHC.Base.$fFunctor(,)_$c<$_closure:
         const GHC.Base.$fFunctor(,)_$c<$_info;
 },
 GHC.Base.$fFunctor(,)_$c<$_entry() //  [R2, R3]
         { []
         }
     {offset
       cihJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cihN; else goto cihO;
       cihN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctor(,)_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cihO: // global
           I64[Sp - 16] = block_cihG_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uihS; else goto cihH;
       uihS: // global
           call _cihG(R1) args: 0, res: 0, upd: 0;
       cihH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fFunctor(,)_$c<$_info" {
     GHC.Base.$fFunctor(,)_$c<$_info:
         const GHC.Base.$fFunctor(,)_$c<$_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cihG() //  [R1]
         { []
         }
     {offset
       cihG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cihR; else goto cihQ;
       cihR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cihQ: // global
           _sgTB::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sgTB::P64;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cihG_info" {
     block_cihG_info:
         const _cihG;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.108414648 UTC

[section ""data" . GHC.Base.$fFunctorMaybe_$c<$_closure" {
     GHC.Base.$fFunctorMaybe_$c<$_closure:
         const GHC.Base.$fFunctorMaybe_$c<$_info;
 },
 GHC.Base.$fFunctorMaybe_$c<$_entry() //  [R2, R3]
         { []
         }
     {offset
       ciih: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciii; else goto ciij;
       ciii: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorMaybe_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciij: // global
           I64[Sp - 16] = block_ciia_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uiit; else goto ciib;
       uiit: // global
           call _ciia(R1) args: 0, res: 0, upd: 0;
       ciib: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fFunctorMaybe_$c<$_info" {
     GHC.Base.$fFunctorMaybe_$c<$_info:
         const GHC.Base.$fFunctorMaybe_$c<$_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ciia() //  [R1]
         { []
         }
     {offset
       ciia: // global
           if (R1 & 7 == 1) goto ciie; else goto ciif;
       ciie: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciif: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ciis; else goto ciir;
       ciis: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciir: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciia_info" {
     block_ciia_info:
         const _ciia;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.114549972 UTC

[section ""data" . GHC.Base.$dm<$_closure" {
     GHC.Base.$dm<$_closure:
         const GHC.Base.$dm<$_info;
 },
 sat_sgTK_entry() //  [R1]
         { []
         }
     {offset
       ciiT: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgTK_info" {
     sat_sgTK_info:
         const sat_sgTK_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 GHC.Base.$dm<$_entry() //  [R2, R3]
         { []
         }
     {offset
       ciiW: // global
           _sgTI::P64 = R3;
           _sgTH::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto ciiX; else goto ciiY;
       ciiY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cij0; else goto ciiZ;
       cij0: // global
           HpAlloc = 16;
           goto ciiX;
       ciiX: // global
           R3 = _sgTI::P64;
           R2 = _sgTH::P64;
           R1 = GHC.Base.$dm<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciiZ: // global
           I64[Hp - 8] = sat_sgTK_info;
           P64[Hp] = _sgTI::P64;
           R2 = _sgTH::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 16;
           call GHC.Base.fmap_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dm<$_info" {
     GHC.Base.$dm<$_info:
         const GHC.Base.$dm<$_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.120316379 UTC

[section ""data" . GHC.Base.$fMonoid(->)_$cmappend_closure" {
     GHC.Base.$fMonoid(->)_$cmappend_closure:
         const GHC.Base.$fMonoid(->)_$cmappend_info;
 },
 GHC.Base.$fMonoid(->)_$cmappend_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cijk: // global
           _sgTO::P64 = R5;
           _sgTN::P64 = R4;
           _sgTM::P64 = R3;
           _sgTL::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cijl; else goto cijm;
       cijm: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cijo; else goto cijn;
       cijo: // global
           HpAlloc = 64;
           goto cijl;
       cijl: // global
           R5 = _sgTO::P64;
           R4 = _sgTN::P64;
           R3 = _sgTM::P64;
           R2 = _sgTL::P64;
           R1 = GHC.Base.$fMonoid(->)_$cmappend_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cijn: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sgTN::P64;
           P64[Hp - 32] = _sgTO::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgTM::P64;
           P64[Hp] = _sgTO::P64;
           I64[Sp - 24] = block_ciji_info;
           R2 = _sgTL::P64;
           P64[Sp - 16] = Hp - 56;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 24;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(->)_$cmappend_info" {
     GHC.Base.$fMonoid(->)_$cmappend_info:
         const GHC.Base.$fMonoid(->)_$cmappend_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _ciji() //  [R1]
         { []
         }
     {offset
       ciji: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           _cijg::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _cijg::P64;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciji_info" {
     block_ciji_info:
         const _ciji;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.128518778 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,)_$cmappend_info;
 },
 sat_sgU5_entry() //  [R1]
         { []
         }
     {offset
       cik1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cik2; else goto cik3;
       cik2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cik3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cijZ_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sgU5_info" {
     sat_sgU5_info:
         const sat_sgU5_entry;
         const 3;
         const 15;
 },
 _cijZ() //  [R1]
         { []
         }
     {offset
       cijZ: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cijZ_info" {
     block_cijZ_info:
         const _cijZ;
         const 2;
         const 30;
 },
 sat_sgU3_entry() //  [R1]
         { []
         }
     {offset
       cikd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cike; else goto cikf;
       cike: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cikf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cikb_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sgU3_info" {
     sat_sgU3_info:
         const sat_sgU3_entry;
         const 3;
         const 15;
 },
 _cikb() //  [R1]
         { []
         }
     {offset
       cikb: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cikb_info" {
     block_cikb_info:
         const _cikb;
         const 2;
         const 30;
 },
 GHC.Base.$fMonoid(,)_$cmappend_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cikj: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cikl; else goto cikm;
       cikl: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cmappend_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cikm: // global
           I64[Sp - 32] = block_cijL_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uiks; else goto cijM;
       uiks: // global
           call _cijL(R1) args: 0, res: 0, upd: 0;
       cijM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,)_$cmappend_info" {
     GHC.Base.$fMonoid(,)_$cmappend_info:
         const GHC.Base.$fMonoid(,)_$cmappend_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _cijL() //  [R1]
         { []
         }
     {offset
       cijL: // global
           I64[Sp - 8] = block_cijQ_info;
           _sgTX::P64 = P64[R1 + 7];
           _sgTY::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sgTY::P64;
           P64[Sp + 24] = _sgTX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uikr; else goto cijR;
       uikr: // global
           call _cijQ(R1) args: 0, res: 0, upd: 0;
       cijR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cijL_info" {
     block_cijL_info:
         const _cijL;
         const 3;
         const 30;
 },
 _cijQ() //  [R1]
         { []
         }
     {offset
       cijQ: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cikq; else goto cikp;
       cikq: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cikp: // global
           _sgU0::P64 = P64[R1 + 7];
           _sgU1::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sgU5_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sgU1::P64;
           I64[Hp - 56] = sat_sgU3_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sgU0::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cijQ_info" {
     block_cijQ_info:
         const _cijQ;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.142874063 UTC

[section ""data" . GHC.Base.$fSemigroupOrdering_go_closure" {
     GHC.Base.$fSemigroupOrdering_go_closure:
         const GHC.Base.$fSemigroupOrdering_go_info;
 },
 GHC.Base.$fSemigroupOrdering_go_entry() //  [R2, R3]
         { []
         }
     {offset
       cilr: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cils; else goto uilS;
       cils: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupOrdering_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uilS: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cilh() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupOrdering_go_info" {
     GHC.Base.$fSemigroupOrdering_go_info:
         const GHC.Base.$fSemigroupOrdering_go_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cilh() //  []
         { []
         }
     {offset
       cilh: // global
           I64[Sp - 8] = block_cilk_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uilU; else goto cill;
       uilU: // global
           call _cilk(R1) args: 0, res: 0, upd: 0;
       cill: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cilk() //  [R1]
         { []
         }
     {offset
       cilk: // global
           _sgU6::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cilo; else goto cilp;
       cilo: // global
           R1 = _sgU6::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cilp: // global
           I64[Sp] = block_cilz_info;
           _sgU9::P64 = P64[R1 + 6];
           _sgUa::P64 = P64[R1 + 14];
           R1 = _sgU6::P64;
           P64[Sp + 8] = _sgUa::P64;
           P64[Sp + 16] = _sgU9::P64;
           if (R1 & 7 != 0) goto uilV; else goto cilB;
       uilV: // global
           call _cilz(R1) args: 0, res: 0, upd: 0;
       cilB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cilk_info" {
     block_cilk_info:
         const _cilk;
         const 130;
         const 30;
 },
 _cilz() //  [R1]
         { []
         }
     {offset
       cilz: // global
           _cilQ::P64 = R1 & 7;
           if (_cilQ::P64 < 3) goto uilR; else goto cilP;
       uilR: // global
           if (_cilQ::P64 < 2) goto cilH; else goto cilL;
       cilH: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cilL: // global
           _sgU7::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = _sgU7::P64;
           Sp = Sp + 8;
           call _cilh() args: 0, res: 0, upd: 0;
       cilP: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cilz_info" {
     block_cilz_info:
         const _cilz;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.151222198 UTC

[section ""data" . GHC.Base.$fSemigroupOrdering_$csconcat_closure" {
     GHC.Base.$fSemigroupOrdering_$csconcat_closure:
         const GHC.Base.$fSemigroupOrdering_$csconcat_info;
 },
 GHC.Base.$fSemigroupOrdering_$csconcat_entry() //  [R2]
         { []
         }
     {offset
       cimw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cimx; else goto cimy;
       cimx: // global
           R2 = R2;
           R1 = GHC.Base.$fSemigroupOrdering_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cimy: // global
           I64[Sp - 8] = block_cimt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uimC; else goto cimu;
       uimC: // global
           call _cimt(R1) args: 0, res: 0, upd: 0;
       cimu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupOrdering_$csconcat_info" {
     GHC.Base.$fSemigroupOrdering_$csconcat_info:
         const GHC.Base.$fSemigroupOrdering_$csconcat_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cimt() //  [R1]
         { []
         }
     {offset
       cimt: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$fSemigroupOrdering_go_entry(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cimt_info" {
     block_cimt_info:
         const _cimt;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.156735253 UTC

[section ""data" . GHC.Base.._closure" {
     GHC.Base.._closure:
         const GHC.Base.._info;
 },
 GHC.Base.._entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cimS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cimW; else goto cimV;
       cimW: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.._closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cimV: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           _sgUg::P64 = R2;
           R2 = Hp - 24;
           R1 = _sgUg::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.._info" {
     GHC.Base.._info:
         const GHC.Base.._entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.16103374 UTC

[section ""data" . GHC.Base.mapFB_closure" {
     GHC.Base.mapFB_closure:
         const GHC.Base.mapFB_info;
 },
 GHC.Base.mapFB_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cin7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cinb; else goto cina;
       cinb: // global
           HpAlloc = 32;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.mapFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cina: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = R5;
           _sgUk::P64 = R2;
           R2 = Hp - 24;
           R1 = _sgUk::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.mapFB_info" {
     GHC.Base.mapFB_info:
         const GHC.Base.mapFB_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.164604322 UTC

[section ""data" . GHC.Base.$fFunctor(->)_$c<$_closure" {
     GHC.Base.$fFunctor(->)_$c<$_closure:
         const GHC.Base.$fFunctor(->)_$c<$_info;
 },
 GHC.Base.$fFunctor(->)_$c<$_entry() //  [R2]
         { []
         }
     {offset
       cinl: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fFunctor(->)_$c<$_info" {
     GHC.Base.$fFunctor(->)_$c<$_info:
         const GHC.Base.$fFunctor(->)_$c<$_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.167681885 UTC

[section ""data" . GHC.Base.$fFunctor(->)_closure" {
     GHC.Base.$fFunctor(->)_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.._closure+3;
         const GHC.Base.$fFunctor(->)_$c<$_closure+3;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.169702724 UTC

[section ""data" . GHC.Base.const_closure" {
     GHC.Base.const_closure:
         const GHC.Base.const_info;
 },
 GHC.Base.const_entry() //  [R2]
         { []
         }
     {offset
       cinx: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.const_info" {
     GHC.Base.const_info:
         const GHC.Base.const_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.172810762 UTC

[section ""data" . GHC.Base.asTypeOf_closure" {
     GHC.Base.asTypeOf_closure:
         const GHC.Base.asTypeOf_info;
 },
 GHC.Base.asTypeOf_entry() //  [R2, R3]
         { []
         }
     {offset
       cinI: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.const_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.asTypeOf_info" {
     GHC.Base.asTypeOf_info:
         const GHC.Base.asTypeOf_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.176451592 UTC

[section ""data" . GHC.Base.$dm<*_closure" {
     GHC.Base.$dm<*_closure:
         const GHC.Base.$dm<*_info;
 },
 GHC.Base.$dm<*_entry() //  [R2]
         { []
         }
     {offset
       cinT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cinU; else goto cinV;
       cinU: // global
           R2 = R2;
           R1 = GHC.Base.$dm<*_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cinV: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.const_closure+2;
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dm<*_info" {
     GHC.Base.$dm<*_info:
         const GHC.Base.$dm<*_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.180418411 UTC

[section ""data" . GHC.Base.$fApplicativeIO1_closure" {
     GHC.Base.$fApplicativeIO1_closure:
         const GHC.Base.$fApplicativeIO1_info;
 },
 GHC.Base.$fApplicativeIO1_entry() //  [R2, R3]
         { []
         }
     {offset
       ciob: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cioc; else goto ciod;
       cioc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciod: // global
           I64[Sp - 16] = block_cio7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeIO1_info" {
     GHC.Base.$fApplicativeIO1_info:
         const GHC.Base.$fApplicativeIO1_entry;
         const 0;
         const 14;
         const 12884901903;
 },
 _cio7() //  [R1]
         { []
         }
     {offset
       cio7: // global
           I64[Sp] = block_cio9_info;
           _sgUA::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sgUA::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cio7_info" {
     block_cio7_info:
         const _cio7;
         const 1;
         const 30;
 },
 _cio9() //  []
         { []
         }
     {offset
       cio9: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cio9_info" {
     block_cio9_info:
         const _cio9;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.186507918 UTC

[section ""data" . GHC.Base.$fApplicativeIO_closure" {
     GHC.Base.$fApplicativeIO_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctorIO_closure+1;
         const GHC.Base.$fApplicativeIO4_closure+2;
         const GHC.Base.$fApplicativeIO3_closure+3;
         const GHC.Base.$fApplicativeIO_$cliftA2_closure+4;
         const GHC.Base.$fApplicativeIO2_closure+3;
         const GHC.Base.$fApplicativeIO1_closure+3;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.188558091 UTC

[section ""data" . GHC.Base.breakpointCond_closure" {
     GHC.Base.breakpointCond_closure:
         const GHC.Base.breakpointCond_info;
 },
 GHC.Base.breakpointCond_entry() //  [R3]
         { []
         }
     {offset
       cioz: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.breakpointCond_info" {
     GHC.Base.breakpointCond_info:
         const GHC.Base.breakpointCond_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.192250615 UTC

[section ""data" . GHC.Base.breakpoint_closure" {
     GHC.Base.breakpoint_closure:
         const GHC.Base.breakpoint_info;
 },
 GHC.Base.breakpoint_entry() //  [R2]
         { []
         }
     {offset
       cioK: // global
           R1 = R2;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.breakpoint_info" {
     GHC.Base.breakpoint_info:
         const GHC.Base.breakpoint_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.195343939 UTC

[section ""data" . GHC.Base.assert_closure" {
     GHC.Base.assert_closure:
         const GHC.Base.assert_info;
 },
 GHC.Base.assert_entry() //  [R2, R3]
         { []
         }
     {offset
       cioV: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.breakpointCond_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.assert_info" {
     GHC.Base.assert_info:
         const GHC.Base.assert_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.199023277 UTC

[section ""data" . GHC.Base.id_closure" {
     GHC.Base.id_closure:
         const GHC.Base.id_info;
 },
 GHC.Base.id_entry() //  [R2]
         { []
         }
     {offset
       cip6: // global
           R2 = R2;
           call GHC.Base.breakpoint_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.id_info" {
     GHC.Base.id_info:
         const GHC.Base.id_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.202264361 UTC

[section ""data" . GHC.Base.join_closure" {
     GHC.Base.join_closure:
         const GHC.Base.join_info;
 },
 GHC.Base.join_entry() //  [R2, R3]
         { []
         }
     {offset
       ciph: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cipi; else goto cipj;
       cipi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.join_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cipj: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.join_info" {
     GHC.Base.join_info:
         const GHC.Base.join_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.205916435 UTC

[section ""data" . GHC.Base.$dm<*>_closure" {
     GHC.Base.$dm<*>_closure:
         const GHC.Base.$dm<*>_info;
 },
 GHC.Base.$dm<*>_entry() //  [R2]
         { []
         }
     {offset
       cipv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cipw; else goto cipx;
       cipw: // global
           R2 = R2;
           R1 = GHC.Base.$dm<*>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cipx: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dm<*>_info" {
     GHC.Base.$dm<*>_info:
         const GHC.Base.$dm<*>_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.210190331 UTC

[section ""data" . GHC.Base.$dm*>_closure" {
     GHC.Base.$dm*>_closure:
         const GHC.Base.$dm*>_info;
 },
 sat_sgUO_entry() //  [R1]
         { []
         }
     {offset
       cipP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cipQ; else goto cipR;
       cipQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cipR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cipN_info;
           R2 = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sgUO_info" {
     sat_sgUO_info:
         const sat_sgUO_entry;
         const 2;
         const 18;
 },
 _cipN() //  [R1]
         { []
         }
     {offset
       cipN: // global
           R2 = R1;
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = GHC.Base.breakpoint_closure+1;
           Sp = Sp - 8;
           call GHC.Base.<$_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cipN_info" {
     block_cipN_info:
         const _cipN;
         const 1;
         const 30;
 },
 GHC.Base.$dm*>_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cipV: // global
           _sgUM::P64 = R4;
           _sgUL::P64 = R3;
           _sgUK::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cipW; else goto cipX;
       cipX: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cipZ; else goto cipY;
       cipZ: // global
           HpAlloc = 32;
           goto cipW;
       cipW: // global
           R4 = _sgUM::P64;
           R3 = _sgUL::P64;
           R2 = _sgUK::P64;
           R1 = GHC.Base.$dm*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cipY: // global
           I64[Hp - 24] = sat_sgUO_info;
           P64[Hp - 8] = _sgUK::P64;
           P64[Hp] = _sgUL::P64;
           R2 = _sgUK::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _sgUM::P64;
           Sp = Sp - 24;
           call GHC.Base.<*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dm*>_info" {
     GHC.Base.$dm*>_info:
         const GHC.Base.$dm*>_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.217211575 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$c*>_closure" {
     GHC.Base.$fApplicative(->)_$c*>_closure:
         const GHC.Base.$fApplicative(->)_$c*>_info;
 },
 GHC.Base.$fApplicative(->)_$c*>_entry() //  [R3, R4]
         { []
         }
     {offset
       ciqo: // global
           R2 = R4;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative(->)_$c*>_info" {
     GHC.Base.$fApplicative(->)_$c*>_info:
         const GHC.Base.$fApplicative(->)_$c*>_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.220242859 UTC

[section ""data" . GHC.Base.maxInt_closure" {
     GHC.Base.maxInt_closure:
         const GHC.Types.I#_con_info;
         const 9223372036854775807;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.222689448 UTC

[section ""data" . GHC.Base.minInt_closure" {
     GHC.Base.minInt_closure:
         const GHC.Types.I#_con_info;
         const (-9223372036854775808);
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.225147462 UTC

[section ""data" . GHC.Base.ord_closure" {
     GHC.Base.ord_closure:
         const GHC.Base.ord_info;
 },
 GHC.Base.ord_entry() //  [R2]
         { []
         }
     {offset
       ciqE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ciqL; else goto ciqM;
       ciqL: // global
           R2 = R2;
           R1 = GHC.Base.ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciqM: // global
           I64[Sp - 8] = block_ciqB_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uiqQ; else goto ciqC;
       uiqQ: // global
           call _ciqB(R1) args: 0, res: 0, upd: 0;
       ciqC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.ord_info" {
     GHC.Base.ord_info:
         const GHC.Base.ord_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _ciqB() //  [R1]
         { []
         }
     {offset
       ciqB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ciqP; else goto ciqO;
       ciqP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciqO: // global
           _sgUV::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sgUV::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciqB_info" {
     block_ciqB_info:
         const _ciqB;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.231068394 UTC

[section ""data" . GHC.Base.unsafeChr_closure" {
     GHC.Base.unsafeChr_closure:
         const GHC.Base.unsafeChr_info;
 },
 GHC.Base.unsafeChr_entry() //  [R2]
         { []
         }
     {offset
       cira: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cirh; else goto ciri;
       cirh: // global
           R2 = R2;
           R1 = GHC.Base.unsafeChr_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciri: // global
           I64[Sp - 8] = block_cir7_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uirm; else goto cir8;
       uirm: // global
           call _cir7(R1) args: 0, res: 0, upd: 0;
       cir8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.unsafeChr_info" {
     GHC.Base.unsafeChr_info:
         const GHC.Base.unsafeChr_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cir7() //  [R1]
         { []
         }
     {offset
       cir7: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cirl; else goto cirk;
       cirl: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cirk: // global
           _sgUZ::I64 = I64[R1 + 7];
           I64[Hp - 8] = GHC.Types.C#_con_info;
           I64[Hp] = _sgUZ::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cir7_info" {
     block_cir7_info:
         const _cir7;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.236354215 UTC

[section ""data" . GHC.Base.otherwise_closure" {
     GHC.Base.otherwise_closure:
         const GHC.Types.True_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.239317309 UTC

[section ""data" . GHC.Base.until_closure" {
     GHC.Base.until_closure:
         const GHC.Base.until_info;
 },
 GHC.Base.until_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cirG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cirH; else goto cirI;
       cirH: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.until_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cirI: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cirK() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Base.until_info" {
     GHC.Base.until_info:
         const GHC.Base.until_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cirK() //  []
         { []
         }
     {offset
       cirK: // global
           I64[Sp - 8] = block_cirM_info;
           R2 = P64[Sp + 16];
           R1 = P64[Sp];
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 _cirM() //  [R1]
         { []
         }
     {offset
       cirM: // global
           _sgV4::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cirQ; else goto cirZ;
       cirQ: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cirV; else goto cirU;
       cirV: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cirU: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sgV4::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call _cirK() args: 0, res: 0, upd: 0;
       cirZ: // global
           R1 = _sgV4::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cirM_info" {
     block_cirM_info:
         const _cirM;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.246639206 UTC

[section ""data" . GHC.Base.divModInt#_closure" {
     GHC.Base.divModInt#_closure:
         const GHC.Base.divModInt#_info;
 },
 GHC.Base.divModInt#_entry() //  [R2, R3]
         { []
         }
     {offset
       cisv: // global
           if (%MO_S_Le_W64(R2, 0)) goto cist; else goto cisu;
       cist: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cisF; else goto cisP;
       cisF: // global
           _sgV8::I64 = R3;
           (_cisC::I64, _cisD::I64) = call MO_S_QuotRem W64(R2, _sgV8::I64);
           R2 = _cisD::I64;
           R1 = _cisC::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cisP: // global
           if (%MO_S_Le_W64(R3, 0)) goto cisN; else goto cisO;
       cisN: // global
           _sgV8::I64 = R3;
           (_cisK::I64, _cisL::I64) = call MO_S_QuotRem W64(R2, _sgV8::I64);
           R2 = _cisL::I64;
           R1 = _cisK::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cisO: // global
           _sgV8::I64 = R3;
           (_sgVe::I64, _sgVf::I64) = call MO_S_QuotRem W64(R2 + 1, _sgV8::I64);
           R2 = _sgVf::I64 + _sgV8::I64 - 1;
           R1 = _sgVe::I64 - 1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cisu: // global
           if (%MO_S_Ge_W64(R3, 0)) goto citc; else goto citd;
       citc: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cit0; else goto cita;
       cit0: // global
           _sgV8::I64 = R3;
           (_cisX::I64, _cisY::I64) = call MO_S_QuotRem W64(R2, _sgV8::I64);
           R2 = _cisY::I64;
           R1 = _cisX::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cita: // global
           if (%MO_S_Le_W64(R3, 0)) goto cit8; else goto cit9;
       cit8: // global
           _sgV8::I64 = R3;
           (_cit5::I64, _cit6::I64) = call MO_S_QuotRem W64(R2, _sgV8::I64);
           R2 = _cit6::I64;
           R1 = _cit5::I64;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cit9: // global
           _sgV8::I64 = R3;
           (_sgVo::I64, _sgVp::I64) = call MO_S_QuotRem W64(R2 + 1, _sgV8::I64);
           R2 = _sgVp::I64 + _sgV8::I64 - 1;
           R1 = _sgVo::I64 - 1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       citd: // global
           _sgV8::I64 = R3;
           (_sgVv::I64, _sgVw::I64) = call MO_S_QuotRem W64(R2 - 1, _sgV8::I64);
           R2 = _sgVw::I64 + _sgV8::I64 + 1;
           R1 = _sgVv::I64 - 1;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.divModInt#_info" {
     GHC.Base.divModInt#_info:
         const GHC.Base.divModInt#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.254342131 UTC

[section ""data" . GHC.Base.divModInt_closure" {
     GHC.Base.divModInt_closure:
         const GHC.Base.divModInt_info;
 },
 GHC.Base.divModInt_entry() //  [R2, R3]
         { []
         }
     {offset
       ciu9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciud; else goto ciue;
       ciud: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.divModInt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciue: // global
           I64[Sp - 16] = block_ciu6_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uivZ; else goto ciu7;
       uivZ: // global
           call _ciu6(R1) args: 0, res: 0, upd: 0;
       ciu7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.divModInt_info" {
     GHC.Base.divModInt_info:
         const GHC.Base.divModInt_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ciu6() //  [R1]
         { []
         }
     {offset
       ciu6: // global
           I64[Sp] = block_ciuc_info;
           _sgVD::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sgVD::I64;
           if (R1 & 7 != 0) goto uivY; else goto ciug;
       uivY: // global
           call _ciuc(R1) args: 0, res: 0, upd: 0;
       ciug: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ciu6_info" {
     block_ciu6_info:
         const _ciu6;
         const 1;
         const 30;
 },
 _ciuc() //  [R1]
         { []
         }
     {offset
       ciuc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cium; else goto ciul;
       cium: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciul: // global
           _sgVD::I64 = I64[Sp + 8];
           _sgVF::I64 = I64[R1 + 7];
           if (%MO_S_Le_W64(_sgVD::I64, 0)) goto civ0; else goto civX;
       civ0: // global
           if (%MO_S_Ge_W64(_sgVD::I64, 0)) goto ciux; else goto ciuY;
       ciux: // global
           (_sgVJ::I64, _sgVK::I64) = call MO_S_QuotRem W64(_sgVD::I64, _sgVF::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _sgVK::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sgVJ::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciuY: // global
           if (%MO_S_Le_W64(_sgVF::I64, 0)) goto ciuG; else goto ciuX;
       ciuG: // global
           (_sgVP::I64, _sgVQ::I64) = call MO_S_QuotRem W64(_sgVD::I64, _sgVF::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _sgVQ::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sgVP::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciuX: // global
           (_sgVV::I64, _sgVW::I64) = call MO_S_QuotRem W64(_sgVD::I64 + 1, _sgVF::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _sgVW::I64 + _sgVF::I64 - 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sgVV::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       civX: // global
           if (%MO_S_Ge_W64(_sgVF::I64, 0)) goto civF; else goto civW;
       civF: // global
           if (%MO_S_Ge_W64(_sgVD::I64, 0)) goto civc; else goto civD;
       civc: // global
           (_sgW5::I64, _sgW6::I64) = call MO_S_QuotRem W64(_sgVD::I64, _sgVF::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _sgW6::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sgW5::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       civD: // global
           if (%MO_S_Le_W64(_sgVF::I64, 0)) goto civl; else goto civC;
       civl: // global
           (_sgWb::I64, _sgWc::I64) = call MO_S_QuotRem W64(_sgVD::I64, _sgVF::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _sgWc::I64;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sgWb::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       civC: // global
           (_sgWh::I64, _sgWi::I64) = call MO_S_QuotRem W64(_sgVD::I64 + 1, _sgVF::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _sgWi::I64 + _sgVF::I64 - 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sgWh::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       civW: // global
           (_sgWq::I64, _sgWr::I64) = call MO_S_QuotRem W64(_sgVD::I64 - 1, _sgVF::I64);
           I64[Hp - 48] = GHC.Types.I#_con_info;
           I64[Hp - 40] = _sgWr::I64 + _sgVF::I64 + 1;
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sgWq::I64 - 1;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciuc_info" {
     block_ciuc_info:
         const _ciuc;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.264776333 UTC

[section ""data" . GHC.Base.shiftL#_closure" {
     GHC.Base.shiftL#_closure:
         const GHC.Base.shiftL#_info;
 },
 GHC.Base.shiftL#_entry() //  [R2, R3]
         { []
         }
     {offset
       cixg: // global
           if (%MO_S_Lt_W64(R3, 64)) goto cixe; else goto cixf;
       cixe: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cixf: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.shiftL#_info" {
     GHC.Base.shiftL#_info:
         const GHC.Base.shiftL#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.268592395 UTC

[section ""data" . GHC.Base.shiftRL#_closure" {
     GHC.Base.shiftRL#_closure:
         const GHC.Base.shiftRL#_info;
 },
 GHC.Base.shiftRL#_entry() //  [R2, R3]
         { []
         }
     {offset
       cixB: // global
           if (%MO_S_Lt_W64(R3, 64)) goto cixz; else goto cixA;
       cixz: // global
           R1 = R2 >> R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cixA: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.shiftRL#_info" {
     GHC.Base.shiftRL#_info:
         const GHC.Base.shiftRL#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.272087839 UTC

[section ""data" . GHC.Base.iShiftL#_closure" {
     GHC.Base.iShiftL#_closure:
         const GHC.Base.iShiftL#_info;
 },
 GHC.Base.iShiftL#_entry() //  [R2, R3]
         { []
         }
     {offset
       cixW: // global
           if (%MO_S_Lt_W64(R3, 64)) goto cixU; else goto cixV;
       cixU: // global
           R1 = R2 << R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cixV: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.iShiftL#_info" {
     GHC.Base.iShiftL#_info:
         const GHC.Base.iShiftL#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.275695571 UTC

[section ""data" . GHC.Base.iShiftRA#_closure" {
     GHC.Base.iShiftRA#_closure:
         const GHC.Base.iShiftRA#_info;
 },
 GHC.Base.iShiftRA#_entry() //  [R2, R3]
         { []
         }
     {offset
       ciyh: // global
           if (%MO_S_Lt_W64(R3, 64)) goto ciyf; else goto ciyg;
       ciyf: // global
           R1 = %MO_S_Shr_W64(R2, R3);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciyg: // global
           if (%MO_S_Ge_W64(R2, 0)) goto ciyq; else goto ciyr;
       ciyq: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciyr: // global
           R1 = (-1);
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.iShiftRA#_info" {
     GHC.Base.iShiftRA#_info:
         const GHC.Base.iShiftRA#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.279476516 UTC

[section ""data" . GHC.Base.iShiftRL#_closure" {
     GHC.Base.iShiftRL#_closure:
         const GHC.Base.iShiftRL#_info;
 },
 GHC.Base.iShiftRL#_entry() //  [R2, R3]
         { []
         }
     {offset
       ciyJ: // global
           if (%MO_S_Lt_W64(R3, 64)) goto ciyH; else goto ciyI;
       ciyH: // global
           R1 = R2 >> R3;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciyI: // global
           R1 = 0;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.iShiftRL#_info" {
     GHC.Base.iShiftRL#_info:
         const GHC.Base.iShiftRL#_entry;
         const 0;
         const 14;
         const 8589934604;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.282858989 UTC

[section ""data" . GHC.Base.build_closure" {
     GHC.Base.build_closure:
         const GHC.Base.build_info;
 },
 GHC.Base.build_entry() //  [R2]
         { []
         }
     {offset
       ciyZ: // global
           R3 = GHC.Types.[]_closure+1;
           _sgWN::P64 = R2;
           R2 = GHC.Types.:_closure+2;
           R1 = _sgWN::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.build_info" {
     GHC.Base.build_info:
         const GHC.Base.build_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.28636232 UTC

[section ""data" . GHC.Base.$fApplicative[]_$cpure_closure" {
     GHC.Base.$fApplicative[]_$cpure_closure:
         const GHC.Base.$fApplicative[]_$cpure_info;
 },
 GHC.Base.$fApplicative[]_$cpure_entry() //  [R2]
         { []
         }
     {offset
       cizd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cizh; else goto cizg;
       cizh: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$cpure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cizg: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative[]_$cpure_info" {
     GHC.Base.$fApplicative[]_$cpure_info:
         const GHC.Base.$fApplicative[]_$cpure_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.289831793 UTC

[section ""data" . GHC.Base.augment_closure" {
     GHC.Base.augment_closure:
         const GHC.Base.augment_info;
 },
 GHC.Base.augment_entry() //  [R2, R3]
         { []
         }
     {offset
       cizu: // global
           R3 = R3;
           _sgWP::P64 = R2;
           R2 = GHC.Types.:_closure+2;
           R1 = _sgWP::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.augment_info" {
     GHC.Base.augment_info:
         const GHC.Base.augment_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.297447506 UTC

[section ""data" . GHC.Base.++_closure" {
     GHC.Base.++_closure:
         const GHC.Base.++_info;
 },
 sat_sgWW_entry() //  [R1]
         { []
         }
     {offset
       cizQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cizR; else goto cizS;
       cizR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cizS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = P64[R1 + 24];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sgWW_info" {
     sat_sgWW_info:
         const sat_sgWW_entry;
         const 2;
         const 18;
 },
 GHC.Base.++_entry() //  [R2, R3]
         { []
         }
     {offset
       cizX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cizY; else goto cizZ;
       cizY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.++_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cizZ: // global
           I64[Sp - 16] = block_cizG_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uiA6; else goto cizH;
       uiA6: // global
           call _cizG(R1) args: 0, res: 0, upd: 0;
       cizH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.++_info" {
     GHC.Base.++_info:
         const GHC.Base.++_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cizG() //  [R1]
         { []
         }
     {offset
       cizG: // global
           _sgWS::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cizU; else goto cizV;
       cizU: // global
           R1 = _sgWS::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cizV: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ciA5; else goto ciA4;
       ciA5: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciA4: // global
           _sgWU::P64 = P64[R1 + 6];
           _sgWV::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_sgWW_info;
           P64[Hp - 32] = _sgWS::P64;
           P64[Hp - 24] = _sgWV::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sgWU::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cizG_info" {
     block_cizG_info:
         const _cizG;
         const 1;
         const 30;
 },
 section ""data" . GHC.Base.foldr_closure" {
     GHC.Base.foldr_closure:
         const GHC.Base.foldr_info;
 },
 go_sgX0_entry() //  [R1, R2]
         { []
         }
     {offset
       ciAn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ciAo; else goto ciAp;
       ciAo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciAp: // global
           I64[Sp - 32] = block_ciAg_info;
           _sgX0::P64 = R1;
           _sgWX::P64 = P64[R1 + 7];
           _sgWY::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sgWX::P64;
           P64[Sp - 16] = _sgWY::P64;
           P64[Sp - 8] = _sgX0::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uiAz; else goto ciAh;
       uiAz: // global
           call _ciAg(R1) args: 0, res: 0, upd: 0;
       ciAh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_sgX0_info" {
     go_sgX0_info:
         const go_sgX0_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _ciAg() //  [R1]
         { []
         }
     {offset
       ciAg: // global
           if (R1 & 7 == 1) goto ciAk; else goto ciAl;
       ciAk: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ciAl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ciAy; else goto ciAx;
       ciAy: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciAx: // global
           _sgX3::P64 = P64[R1 + 6];
           _sgX4::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sgX4::P64;
           R3 = Hp - 24;
           R2 = _sgX3::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciAg_info" {
     block_ciAg_info:
         const _ciAg;
         const 3;
         const 30;
 },
 GHC.Base.foldr_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ciAA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ciAE; else goto ciAD;
       ciAE: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.foldr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ciAD: // global
           I64[Hp - 16] = go_sgX0_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = R4;
           R1 = Hp - 15;
           call go_sgX0_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.foldr_info" {
     GHC.Base.foldr_info:
         const GHC.Base.foldr_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 section ""data" . GHC.Base.map_closure" {
     GHC.Base.map_closure:
         const GHC.Base.map_info;
 },
 sat_sgXc_entry() //  [R1]
         { []
         }
     {offset
       ciAT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciAU; else goto ciAV;
       ciAU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciAV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sgXc_info" {
     sat_sgXc_info:
         const sat_sgXc_entry;
         const 2;
         const 18;
 },
 GHC.Base.map_entry() //  [R2, R3]
         { []
         }
     {offset
       ciB0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciB1; else goto ciB2;
       ciB1: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.map_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciB2: // global
           I64[Sp - 16] = block_ciAJ_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uiBa; else goto ciAK;
       uiBa: // global
           call _ciAJ(R1) args: 0, res: 0, upd: 0;
       ciAK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.map_info" {
     GHC.Base.map_info:
         const GHC.Base.map_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ciAJ() //  [R1]
         { []
         }
     {offset
       ciAJ: // global
           if (R1 & 7 == 1) goto ciAX; else goto ciAY;
       ciAX: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciAY: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ciB9; else goto ciB8;
       ciB9: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciB8: // global
           _sgX9::P64 = P64[R1 + 6];
           _sgXa::P64 = P64[R1 + 14];
           I64[Hp - 80] = sat_sgXc_info;
           _sgX6::P64 = P64[Sp + 8];
           P64[Hp - 64] = _sgX6::P64;
           P64[Hp - 56] = _sgXa::P64;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _sgX6::P64;
           P64[Hp - 24] = _sgX9::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciAJ_info" {
     block_ciAJ_info:
         const _ciAJ;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.318231796 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty_$c<>_closure" {
     GHC.Base.$fSemigroupNonEmpty_$c<>_closure:
         const GHC.Base.$fSemigroupNonEmpty_$c<>_info;
 },
 sat_sgXr_entry() //  [R1]
         { []
         }
     {offset
       ciCv: // global
           _sgXr::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ciCw; else goto ciCx;
       ciCx: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ciCz; else goto ciCy;
       ciCz: // global
           HpAlloc = 72;
           goto ciCw;
       ciCw: // global
           R1 = _sgXr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciCy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgXr::P64;
           _sgXe::P64 = P64[_sgXr::P64 + 16];
           _sgXh::P64 = P64[_sgXr::P64 + 24];
           I64[Hp - 64] = stg_sel_1_upd_info;
           P64[Hp - 48] = _sgXe::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _sgXe::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = _sgXh::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sgXr_info" {
     sat_sgXr_info:
         const sat_sgXr_entry;
         const 2;
         const 18;
 },
 GHC.Base.$fSemigroupNonEmpty_$c<>_entry() //  [R2, R3]
         { []
         }
     {offset
       ciCA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciCC; else goto ciCD;
       ciCC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupNonEmpty_$c<>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciCD: // global
           I64[Sp - 16] = block_ciCj_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uiCH; else goto ciCk;
       uiCH: // global
           call _ciCj(R1) args: 0, res: 0, upd: 0;
       ciCk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupNonEmpty_$c<>_info" {
     GHC.Base.$fSemigroupNonEmpty_$c<>_info:
         const GHC.Base.$fSemigroupNonEmpty_$c<>_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ciCj() //  [R1]
         { []
         }
     {offset
       ciCj: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ciCG; else goto ciCF;
       ciCG: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciCF: // global
           _sgXg::P64 = P64[R1 + 7];
           _sgXh::P64 = P64[R1 + 15];
           I64[Hp - 48] = sat_sgXr_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sgXh::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = _sgXg::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciCj_info" {
     block_ciCj_info:
         const _ciCj;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.328335872 UTC

[section ""data" . GHC.Base.$wpoly_go_closure" {
     GHC.Base.$wpoly_go_closure:
         const GHC.Base.$wpoly_go_info;
 },
 ds_sgXy_entry() //  [R1]
         { []
         }
     {offset
       ciDs: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ciDy; else goto ciDz;
       ciDy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciDz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ciDp_info;
           _sgXx::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 24] = _sgXx::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uiDE; else goto ciDq;
       uiDE: // global
           call _ciDp(R1) args: 0, res: 0, upd: 0;
       ciDq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ds_sgXy_info" {
     ds_sgXy_info:
         const ds_sgXy_entry;
         const 2;
         const 18;
 },
 _ciDp() //  [R1]
         { []
         }
     {offset
       ciDp: // global
           _sgXx::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ciDv_info;
           R4 = _sgXx::P64;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$wpoly_go_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_ciDp_info" {
     block_ciDp_info:
         const _ciDp;
         const 1;
         const 30;
 },
 _ciDv() //  [R1, R2]
         { []
         }
     {offset
       ciDv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ciDD; else goto ciDC;
       ciDD: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ciDC: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ciDv_info" {
     block_ciDv_info:
         const _ciDv;
         const 0;
         const 30;
 },
 sat_sgXO_entry() //  [R1]
         { []
         }
     {offset
       ciDI: // global
           _sgXO::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ciDJ; else goto ciDK;
       ciDK: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ciDM; else goto ciDL;
       ciDM: // global
           HpAlloc = 104;
           goto ciDJ;
       ciDJ: // global
           R1 = _sgXO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciDL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sgXO::P64;
           _sgXt::P64 = P64[_sgXO::P64 + 16];
           _sgXw::P64 = P64[_sgXO::P64 + 24];
           _sgXx::P64 = P64[_sgXO::P64 + 32];
           I64[Hp - 96] = ds_sgXy_info;
           P64[Hp - 80] = _sgXw::P64;
           P64[Hp - 72] = _sgXx::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _ciDl::P64 = Hp - 96;
           P64[Hp - 48] = _ciDl::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _ciDl::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = _sgXt::P64;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sgXO_info" {
     sat_sgXO_info:
         const sat_sgXO_entry;
         const 3;
         const 15;
 },
 GHC.Base.$wpoly_go_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ciDR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ciDS; else goto ciDT;
       ciDS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$wpoly_go_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ciDT: // global
           I64[Sp - 24] = block_ciDb_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uiDZ; else goto ciDc;
       uiDZ: // global
           call _ciDb(R1) args: 0, res: 0, upd: 0;
       ciDc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$wpoly_go_info" {
     GHC.Base.$wpoly_go_info:
         const GHC.Base.$wpoly_go_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _ciDb() //  [R1]
         { []
         }
     {offset
       ciDb: // global
           _sgXs::P64 = P64[Sp + 8];
           _sgXt::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ciDO; else goto ciDP;
       ciDO: // global
           R2 = _sgXt::P64;
           R1 = _sgXs::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       ciDP: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ciDY; else goto ciDX;
       ciDY: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciDX: // global
           _sgXw::P64 = P64[R1 + 6];
           _sgXx::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_sgXO_info;
           P64[Hp - 16] = _sgXt::P64;
           P64[Hp - 8] = _sgXw::P64;
           P64[Hp] = _sgXx::P64;
           R2 = Hp - 32;
           R1 = _sgXs::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciDb_info" {
     block_ciDb_info:
         const _ciDb;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.342499994 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty1_closure" {
     GHC.Base.$fSemigroupNonEmpty1_closure:
         const GHC.Base.$fSemigroupNonEmpty1_info;
 },
 GHC.Base.$fSemigroupNonEmpty1_entry() //  [R2, R3]
         { []
         }
     {offset
       ciEN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciET; else goto ciEU;
       ciET: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupNonEmpty1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciEU: // global
           I64[Sp - 16] = block_ciEK_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uiEZ; else goto ciEL;
       uiEZ: // global
           call _ciEK(R1) args: 0, res: 0, upd: 0;
       ciEL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupNonEmpty1_info" {
     GHC.Base.$fSemigroupNonEmpty1_info:
         const GHC.Base.$fSemigroupNonEmpty1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ciEK() //  [R1]
         { []
         }
     {offset
       ciEK: // global
           _sgXQ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ciEQ_info;
           R4 = _sgXQ::P64;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$wpoly_go_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ciEK_info" {
     block_ciEK_info:
         const _ciEK;
         const 1;
         const 30;
 },
 _ciEQ() //  [R1, R2]
         { []
         }
     {offset
       ciEQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ciEY; else goto ciEX;
       ciEY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       ciEX: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciEQ_info" {
     block_ciEQ_info:
         const _ciEQ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.349653778 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty_$csconcat_closure" {
     GHC.Base.$fSemigroupNonEmpty_$csconcat_closure:
         const GHC.Base.$fSemigroupNonEmpty_$csconcat_info;
 },
 GHC.Base.$fSemigroupNonEmpty_$csconcat_entry() //  [R2]
         { []
         }
     {offset
       ciFn: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ciFo; else goto ciFp;
       ciFo: // global
           R2 = R2;
           R1 = GHC.Base.$fSemigroupNonEmpty_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciFp: // global
           I64[Sp - 8] = block_ciFk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uiFt; else goto ciFl;
       uiFt: // global
           call _ciFk(R1) args: 0, res: 0, upd: 0;
       ciFl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupNonEmpty_$csconcat_info" {
     GHC.Base.$fSemigroupNonEmpty_$csconcat_info:
         const GHC.Base.$fSemigroupNonEmpty_$csconcat_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _ciFk() //  [R1]
         { []
         }
     {offset
       ciFk: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$fSemigroupNonEmpty1_entry(R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciFk_info" {
     block_ciFk_info:
         const _ciFk;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.354739031 UTC

[section ""data" . GHC.Base.$fSemigroupNonEmpty_closure" {
     GHC.Base.$fSemigroupNonEmpty_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.$fSemigroupNonEmpty_$c<>_closure+2;
         const GHC.Base.$fSemigroupNonEmpty_$csconcat_closure+1;
         const GHC.Base.$fSemigroupNonEmpty_$cstimes_closure+1;
         const 0;
 },
 section ""data" . GHC.Base.$fSemigroupNonEmpty_$cstimes_closure" {
     GHC.Base.$fSemigroupNonEmpty_$cstimes_closure:
         const GHC.Base.$fSemigroupNonEmpty_$cstimes_info;
         const 0;
 },
 GHC.Base.$fSemigroupNonEmpty_$cstimes_entry() //  [R2]
         { []
         }
     {offset
       ciFI: // global
           R3 = GHC.Base.$fSemigroupNonEmpty_closure+1;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupNonEmpty_$cstimes_info" {
     GHC.Base.$fSemigroupNonEmpty_$cstimes_info:
         const GHC.Base.$fSemigroupNonEmpty_$cstimes_entry;
         const 0;
         const 141733920782;
         const 4294967301;
         const Si3a_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.360244477 UTC

[section ""data" . GHC.Base.$fSemigroup[]1_closure" {
     GHC.Base.$fSemigroup[]1_closure:
         const GHC.Base.$fSemigroup[]1_info;
 },
 sat_sgY7_entry() //  [R1]
         { []
         }
     {offset
       ciG4: // global
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           call GHC.Base.$fSemigroup[]1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgY7_info" {
     sat_sgY7_info:
         const sat_sgY7_entry;
         const 2;
         const 18;
 },
 GHC.Base.$fSemigroup[]1_entry() //  [R2, R3]
         { []
         }
     {offset
       ciGb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciGc; else goto ciGd;
       ciGc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup[]1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciGd: // global
           I64[Sp - 16] = block_ciFU_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uiGj; else goto ciFV;
       uiGj: // global
           call _ciFU(R1) args: 0, res: 0, upd: 0;
       ciFV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup[]1_info" {
     GHC.Base.$fSemigroup[]1_info:
         const GHC.Base.$fSemigroup[]1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ciFU() //  [R1]
         { []
         }
     {offset
       ciFU: // global
           _sgY2::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ciG8; else goto ciG9;
       ciG8: // global
           R1 = _sgY2::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ciG9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ciGi; else goto ciGh;
       ciGi: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciGh: // global
           _sgY5::P64 = P64[R1 + 6];
           _sgY6::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_sgY7_info;
           P64[Hp - 8] = _sgY5::P64;
           P64[Hp] = _sgY6::P64;
           R3 = Hp - 24;
           R2 = _sgY2::P64;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciFU_info" {
     block_ciFU_info:
         const _ciFU;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.367618575 UTC

[section ""data" . GHC.Base.$fSemigroup[]_$csconcat_closure" {
     GHC.Base.$fSemigroup[]_$csconcat_closure:
         const GHC.Base.$fSemigroup[]_$csconcat_info;
 },
 GHC.Base.$fSemigroup[]_$csconcat_entry() //  [R2]
         { []
         }
     {offset
       ciGJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ciGK; else goto ciGL;
       ciGK: // global
           R2 = R2;
           R1 = GHC.Base.$fSemigroup[]_$csconcat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciGL: // global
           I64[Sp - 8] = block_ciGG_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uiGP; else goto ciGH;
       uiGP: // global
           call _ciGG(R1) args: 0, res: 0, upd: 0;
       ciGH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup[]_$csconcat_info" {
     GHC.Base.$fSemigroup[]_$csconcat_info:
         const GHC.Base.$fSemigroup[]_$csconcat_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _ciGG() //  [R1]
         { []
         }
     {offset
       ciGG: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           Sp = Sp + 8;
           call GHC.Base.$fSemigroup[]1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciGG_info" {
     block_ciGG_info:
         const _ciGG;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.375449681 UTC

[section ""data" . GHC.Base.mapM_closure" {
     GHC.Base.mapM_closure:
         const GHC.Base.mapM_info;
 },
 z_sgYf_entry() //  [R1]
         { []
         }
     {offset
       ciH8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ciH9; else goto ciHa;
       ciH9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciHa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.return_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z_sgYf_info" {
     z_sgYf_info:
         const z_sgYf_entry;
         const 1;
         const 16;
 },
 sat_sgYq_entry() //  [R1, R2]
         { []
         }
     {offset
       ciHy: // global
           _sgYo::P64 = R2;
           _sgYq::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ciHz; else goto ciHA;
       ciHA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ciHC; else goto ciHB;
       ciHC: // global
           HpAlloc = 24;
           goto ciHz;
       ciHz: // global
           R2 = _sgYo::P64;
           R1 = _sgYq::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciHB: // global
           _sgYc::P64 = P64[_sgYq::P64 + 7];
           _sgYn::P64 = P64[_sgYq::P64 + 15];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sgYn::P64;
           P64[Hp] = _sgYo::P64;
           R2 = _sgYc::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 14;
           Sp = Sp - 16;
           call GHC.Base.return_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgYq_info" {
     sat_sgYq_info:
         const sat_sgYq_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 sat_sgYr_entry() //  [R1, R2]
         { []
         }
     {offset
       ciHD: // global
           _sgYn::P64 = R2;
           _sgYr::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto ciHE; else goto ciHF;
       ciHF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ciHH; else goto ciHG;
       ciHH: // global
           HpAlloc = 24;
           goto ciHE;
       ciHE: // global
           R2 = _sgYn::P64;
           R1 = _sgYr::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciHG: // global
           _sgYc::P64 = P64[_sgYr::P64 + 7];
           _sgYl::P64 = P64[_sgYr::P64 + 15];
           I64[Hp - 16] = sat_sgYq_info;
           P64[Hp - 8] = _sgYc::P64;
           P64[Hp] = _sgYn::P64;
           R2 = _sgYc::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sgYl::P64;
           P64[Sp - 8] = Hp - 15;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgYr_info" {
     sat_sgYr_info:
         const sat_sgYr_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 go_sgYg_entry() //  [R1, R2]
         { []
         }
     {offset
       ciHM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ciHN; else goto ciHO;
       ciHN: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciHO: // global
           I64[Sp - 40] = block_ciHg_info;
           _sgYg::P64 = R1;
           _sgYc::P64 = P64[R1 + 7];
           _sgYd::P64 = P64[R1 + 15];
           _sgYf::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sgYc::P64;
           P64[Sp - 24] = _sgYd::P64;
           P64[Sp - 16] = _sgYf::P64;
           P64[Sp - 8] = _sgYg::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uiHV; else goto ciHh;
       uiHV: // global
           call _ciHg(R1) args: 0, res: 0, upd: 0;
       ciHh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_sgYg_info" {
     go_sgYg_info:
         const go_sgYg_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 _ciHg() //  [R1]
         { []
         }
     {offset
       ciHg: // global
           if (R1 & 7 == 1) goto ciHJ; else goto ciHK;
       ciHJ: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ciHK: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ciHT; else goto ciHS;
       ciHT: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciHS: // global
           _sgYj::P64 = P64[R1 + 6];
           _sgYk::P64 = P64[R1 + 14];
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = _sgYk::P64;
           I64[Hp - 48] = sat_sgYr_info;
           _sgYc::P64 = P64[Sp + 8];
           P64[Hp - 40] = _sgYc::P64;
           P64[Hp - 32] = Hp - 80;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sgYj::P64;
           R2 = _sgYc::P64;
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 47;
           Sp = Sp + 16;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciHg_info" {
     block_ciHg_info:
         const _ciHg;
         const 4;
         const 30;
 },
 GHC.Base.mapM_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ciHW: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ciI0; else goto ciHZ;
       ciI0: // global
           HpAlloc = 56;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.mapM_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ciHZ: // global
           I64[Hp - 48] = z_sgYf_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = go_sgYg_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = Hp - 48;
           R2 = R4;
           R1 = Hp - 23;
           call go_sgYg_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.mapM_info" {
     GHC.Base.mapM_info:
         const GHC.Base.mapM_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.389151206 UTC

[section ""data" . GHC.Base.sequence_closure" {
     GHC.Base.sequence_closure:
         const GHC.Base.sequence_info;
 },
 GHC.Base.sequence_entry() //  [R2, R3]
         { []
         }
     {offset
       ciIS: // global
           R4 = R3;
           R3 = GHC.Base.breakpoint_closure+1;
           R2 = R2;
           call GHC.Base.mapM_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.sequence_info" {
     GHC.Base.sequence_info:
         const GHC.Base.sequence_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.39416248 UTC

[section ""data" . GHC.Base.$dmmconcat_closure" {
     GHC.Base.$dmmconcat_closure:
         const GHC.Base.$dmmconcat_info;
 },
 z_sgYv_entry() //  [R1]
         { []
         }
     {offset
       ciJ7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciJ8; else goto ciJ9;
       ciJ8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciJ9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z_sgYv_info" {
     z_sgYv_info:
         const z_sgYv_entry;
         const 1;
         const 16;
 },
 go_sgYw_entry() //  [R1, R2]
         { []
         }
     {offset
       ciJm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ciJn; else goto ciJo;
       ciJn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciJo: // global
           I64[Sp - 32] = block_ciJf_info;
           _sgYw::P64 = R1;
           _sgYt::P64 = P64[R1 + 7];
           _sgYv::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sgYt::P64;
           P64[Sp - 16] = _sgYv::P64;
           P64[Sp - 8] = _sgYw::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uiJy; else goto ciJg;
       uiJy: // global
           call _ciJf(R1) args: 0, res: 0, upd: 0;
       ciJg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_sgYw_info" {
     go_sgYw_info:
         const go_sgYw_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _ciJf() //  [R1]
         { []
         }
     {offset
       ciJf: // global
           if (R1 & 7 == 1) goto ciJj; else goto ciJk;
       ciJj: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ciJk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ciJw; else goto ciJv;
       ciJw: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciJv: // global
           _sgYz::P64 = P64[R1 + 6];
           _sgYA::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _sgYA::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _sgYz::P64;
           P64[Sp + 24] = Hp - 24;
           Sp = Sp + 8;
           call GHC.Base.mappend_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciJf_info" {
     block_ciJf_info:
         const _ciJf;
         const 3;
         const 30;
 },
 GHC.Base.$dmmconcat_entry() //  [R2, R3]
         { []
         }
     {offset
       ciJz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ciJD; else goto ciJC;
       ciJD: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciJC: // global
           I64[Hp - 40] = z_sgYv_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_sgYw_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 40;
           R2 = R3;
           R1 = Hp - 15;
           call go_sgYw_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmmconcat_info" {
     GHC.Base.$dmmconcat_info:
         const GHC.Base.$dmmconcat_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.405151054 UTC

[section ""data" . GHC.Base.$fMonoid(->)_$cmconcat_closure" {
     GHC.Base.$fMonoid(->)_$cmconcat_closure:
         const GHC.Base.$fMonoid(->)_$cmconcat_info;
 },
 lvl3_sgYF_entry() //  [R1]
         { []
         }
     {offset
       ciKd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciKe; else goto ciKf;
       ciKe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciKf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl3_sgYF_info" {
     lvl3_sgYF_info:
         const lvl3_sgYF_entry;
         const 1;
         const 16;
 },
 $dSemigroup_sgYG_entry() //  [R1]
         { []
         }
     {offset
       ciKk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciKl; else goto ciKm;
       ciKl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciKm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dSemigroup_sgYG_info" {
     $dSemigroup_sgYG_info:
         const $dSemigroup_sgYG_entry;
         const 1;
         const 16;
 },
 go_sgYH_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       ciKz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ciKA; else goto ciKB;
       ciKA: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciKB: // global
           I64[Sp - 40] = block_ciKs_info;
           _sgYH::P64 = R1;
           _sgYF::P64 = P64[R1 + 6];
           _sgYG::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 32] = _sgYF::P64;
           P64[Sp - 24] = _sgYG::P64;
           P64[Sp - 16] = _sgYH::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uiKM; else goto ciKt;
       uiKM: // global
           call _ciKs(R1) args: 0, res: 0, upd: 0;
       ciKt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_sgYH_info" {
     go_sgYH_info:
         const go_sgYH_entry;
         const 2;
         const 11;
         const 8589934607;
 },
 _ciKs() //  [R1]
         { []
         }
     {offset
       ciKs: // global
           if (R1 & 7 == 1) goto ciKw; else goto ciKx;
       ciKw: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       ciKx: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ciKJ; else goto ciKI;
       ciKJ: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciKI: // global
           _sgYL::P64 = P64[R1 + 6];
           _sgYM::P64 = P64[R1 + 14];
           I64[Hp - 64] = stg_ap_3_upd_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = _sgYM::P64;
           _sgYJ::P64 = P64[Sp + 32];
           P64[Hp - 32] = _sgYJ::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sgYL::P64;
           P64[Hp] = _sgYJ::P64;
           R2 = P64[Sp + 16];
           I64[Sp + 16] = stg_ap_pp_info;
           P64[Sp + 24] = Hp - 24;
           P64[Sp + 32] = Hp - 64;
           Sp = Sp + 16;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciKs_info" {
     block_ciKs_info:
         const _ciKs;
         const 4;
         const 30;
 },
 GHC.Base.$fMonoid(->)_$cmconcat_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ciKN: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ciKR; else goto ciKQ;
       ciKR: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(->)_$cmconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ciKQ: // global
           I64[Hp - 64] = lvl3_sgYF_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = $dSemigroup_sgYG_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_sgYH_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           _sgYD::P64 = R3;
           R3 = R4;
           R2 = _sgYD::P64;
           R1 = Hp - 14;
           call go_sgYH_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(->)_$cmconcat_info" {
     GHC.Base.$fMonoid(->)_$cmconcat_info:
         const GHC.Base.$fMonoid(->)_$cmconcat_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.419579615 UTC

[section ""data" . GHC.Base.$fMonoidIO1_closure" {
     GHC.Base.$fMonoidIO1_closure:
         const GHC.Base.$fMonoidIO1_info;
 },
 $dSemigroup_sgYS_entry() //  [R1]
         { []
         }
     {offset
       ciLA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciLB; else goto ciLC;
       ciLB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciLC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dSemigroup_sgYS_info" {
     $dSemigroup_sgYS_info:
         const $dSemigroup_sgYS_entry;
         const 1;
         const 16;
 },
 lvl3_sgYT_entry() //  [R1]
         { []
         }
     {offset
       ciLH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciLI; else goto ciLJ;
       ciLI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciLJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl3_sgYT_info" {
     lvl3_sgYT_info:
         const lvl3_sgYT_entry;
         const 1;
         const 16;
 },
 sat_sgZ6_entry() //  [R1]
         { []
         }
     {offset
       ciM3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ciM4; else goto ciM5;
       ciM4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciM5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sgZ6_info" {
     sat_sgZ6_info:
         const sat_sgZ6_entry;
         const 3;
         const 15;
 },
 go_sgYU_entry() //  [R1, R2]
         { []
         }
     {offset
       ciMa: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ciMb; else goto ciMc;
       ciMb: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciMc: // global
           I64[Sp - 32] = block_ciLP_info;
           _sgYU::P64 = R1;
           _sgYS::P64 = P64[R1 + 6];
           _sgYT::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 24] = _sgYS::P64;
           P64[Sp - 16] = _sgYT::P64;
           P64[Sp - 8] = _sgYU::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uiMk; else goto ciLQ;
       uiMk: // global
           call _ciLP(R1) args: 0, res: 0, upd: 0;
       ciLQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_sgYU_info" {
     go_sgYU_info:
         const go_sgYU_entry;
         const 2;
         const 11;
         const 8589934597;
 },
 _ciLP() //  [R1]
         { []
         }
     {offset
       ciLP: // global
           if (R1 & 7 == 1) goto ciM7; else goto ciM8;
       ciM7: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciM8: // global
           I64[Sp] = block_ciLV_info;
           _sgYZ::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 16] = _sgYZ::P64;
           call stg_ap_v_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ciLP_info" {
     block_ciLP_info:
         const _ciLP;
         const 3;
         const 30;
 },
 _ciLV() //  [R1]
         { []
         }
     {offset
       ciLV: // global
           I64[Sp] = block_ciLX_info;
           R2 = P64[Sp + 16];
           _sgZ2::P64 = R1;
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sgZ2::P64;
           call go_sgYU_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ciLV_info" {
     block_ciLV_info:
         const _ciLV;
         const 3;
         const 30;
 },
 _ciLX() //  [R1]
         { []
         }
     {offset
       ciLX: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ciMj; else goto ciMi;
       ciMj: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciMi: // global
           I64[Hp - 32] = sat_sgZ6_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R1 = Hp - 32;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciLX_info" {
     block_ciLX_info:
         const _ciLX;
         const 131;
         const 30;
 },
 GHC.Base.$fMonoidIO1_entry() //  [R2, R3]
         { []
         }
     {offset
       ciMl: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ciMp; else goto ciMo;
       ciMp: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidIO1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciMo: // global
           I64[Hp - 64] = $dSemigroup_sgYS_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = lvl3_sgYT_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = go_sgYU_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 40;
           R2 = R3;
           R1 = Hp - 14;
           call go_sgYU_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoidIO1_info" {
     GHC.Base.$fMonoidIO1_info:
         const GHC.Base.$fMonoidIO1_entry;
         const 0;
         const 14;
         const 12884901903;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.436432997 UTC

[section ""data" . GHC.Base.$fMonoidIO_closure" {
     GHC.Base.$fMonoidIO_closure:
         const GHC.Base.$fMonoidIO_info;
         const 0;
 },
 sat_sgZd_entry() //  [R1, R2]
         { []
         }
     {offset
       ciNo: // global
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoidIO1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgZd_info" {
     sat_sgZd_info:
         const sat_sgZd_entry;
         const 1;
         const 9;
         const 8589934597;
 },
 sat_sgZc_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       ciNw: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fMonoidIO_$cmappend_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgZc_info" {
     sat_sgZc_info:
         const sat_sgZc_entry;
         const 1;
         const 9;
         const 12884901903;
 },
 sat_sgZa_entry() //  [R1]
         { []
         }
     {offset
       ciNI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciNJ; else goto ciNK;
       ciNJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciNK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sgZa_info" {
     sat_sgZa_info:
         const sat_sgZa_entry;
         const 1;
         const 16;
 },
 sat_sgZb_entry() //  [R1]
         { []
         }
     {offset
       ciNL: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ciNP; else goto ciNO;
       ciNP: // global
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ciNO: // global
           _sgZ7::P64 = P64[R1 + 7];
           I64[Hp - 16] = sat_sgZa_info;
           P64[Hp] = _sgZ7::P64;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgZb_info" {
     sat_sgZb_info:
         const sat_sgZb_entry;
         const 1;
         const 9;
         const 4294967299;
 },
 sat_sgZ8_entry() //  [R1]
         { []
         }
     {offset
       ciNU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciNV; else goto ciNW;
       ciNV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciNW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoidIO_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sgZ8_info" {
     sat_sgZ8_info:
         const sat_sgZ8_entry;
         const 1;
         const 4294967312;
         const Si3a_srt+24;
 },
 GHC.Base.$fMonoidIO_entry() //  [R2]
         { []
         }
     {offset
       ciNY: // global
           Hp = Hp + 112;
           if (Hp > HpLim) (likely: False) goto ciO2; else goto ciO1;
       ciO2: // global
           HpAlloc = 112;
           R2 = R2;
           R1 = GHC.Base.$fMonoidIO_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciO1: // global
           I64[Hp - 104] = sat_sgZd_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sgZc_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sgZb_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sgZ8_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 71;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoidIO_info" {
     GHC.Base.$fMonoidIO_info:
         const GHC.Base.$fMonoidIO_entry;
         const 0;
         const 141733920782;
         const 4294967301;
         const Si3a_srt+24;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.448345992 UTC

[section ""data" . GHC.Base.$fFunctor[]_$c<$_closure" {
     GHC.Base.$fFunctor[]_$c<$_closure:
         const GHC.Base.$fFunctor[]_$c<$_info;
 },
 sat_sgZh_entry() //  [R1]
         { []
         }
     {offset
       ciOL: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgZh_info" {
     sat_sgZh_info:
         const sat_sgZh_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 GHC.Base.$fFunctor[]_$c<$_entry() //  [R2, R3]
         { []
         }
     {offset
       ciOO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ciOS; else goto ciOR;
       ciOS: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctor[]_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciOR: // global
           I64[Hp - 8] = sat_sgZh_info;
           P64[Hp] = R2;
           R3 = R3;
           R2 = Hp - 7;
           call GHC.Base.map_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fFunctor[]_$c<$_info" {
     GHC.Base.$fFunctor[]_$c<$_info:
         const GHC.Base.$fFunctor[]_$c<$_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.455042982 UTC

[section ""data" . GHC.Base.$fFunctorNonEmpty_$c<$_closure" {
     GHC.Base.$fFunctorNonEmpty_$c<$_closure:
         const GHC.Base.$fFunctorNonEmpty_$c<$_info;
 },
 sat_sgZo_entry() //  [R1]
         { []
         }
     {offset
       ciPj: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgZo_info" {
     sat_sgZo_info:
         const sat_sgZo_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sgZp_entry() //  [R1]
         { []
         }
     {offset
       ciPm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ciPn; else goto ciPo;
       ciPn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciPo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ciP9_info;
           _sgZi::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sgZi::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uiPs; else goto ciPa;
       uiPs: // global
           call _ciP9(R1) args: 0, res: 0, upd: 0;
       ciPa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sgZp_info" {
     sat_sgZp_info:
         const sat_sgZp_entry;
         const 2;
         const 18;
 },
 _ciP9() //  [R1]
         { []
         }
     {offset
       ciP9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ciPr; else goto ciPq;
       ciPr: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       ciPq: // global
           _sgZm::P64 = P64[R1 + 15];
           I64[Hp - 8] = sat_sgZo_info;
           P64[Hp] = P64[Sp + 8];
           R3 = _sgZm::P64;
           R2 = Hp - 7;
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ciP9_info" {
     block_ciP9_info:
         const _ciP9;
         const 1;
         const 30;
 },
 GHC.Base.$fFunctorNonEmpty_$c<$_entry() //  [R2, R3]
         { []
         }
     {offset
       ciPu: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ciPy; else goto ciPx;
       ciPy: // global
           HpAlloc = 56;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorNonEmpty_$c<$_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciPx: // global
           I64[Hp - 48] = sat_sgZp_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fFunctorNonEmpty_$c<$_info" {
     GHC.Base.$fFunctorNonEmpty_$c<$_info:
         const GHC.Base.$fFunctorNonEmpty_$c<$_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.463833287 UTC

[section ""data" . GHC.Base.$fFunctor[]_closure" {
     GHC.Base.$fFunctor[]_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.map_closure+2;
         const GHC.Base.$fFunctor[]_$c<$_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.467663894 UTC

[section ""data" . GHC.Base.$fMonad[]_$c>>=_closure" {
     GHC.Base.$fMonad[]_$c>>=_closure:
         const GHC.Base.$fMonad[]_$c>>=_info;
 },
 sat_sgZy_entry() //  [R1]
         { []
         }
     {offset
       ciQg: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_sgZs_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgZy_info" {
     sat_sgZy_info:
         const sat_sgZy_entry;
         const 2;
         const 18;
 },
 go_sgZs_entry() //  [R1, R2]
         { []
         }
     {offset
       ciQn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ciQo; else goto ciQp;
       ciQo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciQp: // global
           I64[Sp - 24] = block_ciQ6_info;
           _sgZs::P64 = R1;
           _sgZr::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sgZr::P64;
           P64[Sp - 8] = _sgZs::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uiQA; else goto ciQ7;
       uiQA: // global
           call _ciQ6(R1) args: 0, res: 0, upd: 0;
       ciQ7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_sgZs_info" {
     go_sgZs_info:
         const go_sgZs_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _ciQ6() //  [R1]
         { []
         }
     {offset
       ciQ6: // global
           if (R1 & 7 == 1) goto ciQk; else goto ciQl;
       ciQk: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciQl: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ciQv; else goto ciQu;
       ciQv: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciQu: // global
           _sgZv::P64 = P64[R1 + 6];
           _sgZw::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_sgZy_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sgZw::P64;
           _sgZr::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ciQs_info;
           R2 = _sgZv::P64;
           R1 = _sgZr::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ciQ6_info" {
     block_ciQ6_info:
         const _ciQ6;
         const 2;
         const 30;
 },
 _ciQs() //  [R1]
         { []
         }
     {offset
       ciQs: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciQs_info" {
     block_ciQs_info:
         const _ciQs;
         const 1;
         const 30;
 },
 GHC.Base.$fMonad[]_$c>>=_entry() //  [R2, R3]
         { []
         }
     {offset
       ciQB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ciQF; else goto ciQE;
       ciQF: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad[]_$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciQE: // global
           I64[Hp - 8] = go_sgZs_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_sgZs_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonad[]_$c>>=_info" {
     GHC.Base.$fMonad[]_$c>>=_info:
         const GHC.Base.$fMonad[]_$c>>=_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.477949724 UTC

[section ""data" . GHC.Base.=<<_$s=<<_closure" {
     GHC.Base.=<<_$s=<<_closure:
         const GHC.Base.=<<_$s=<<_info;
 },
 GHC.Base.=<<_$s=<<_entry() //  [R2, R3]
         { []
         }
     {offset
       ciRc: // global
           _sgZA::P64 = R3;
           R3 = R2;
           R2 = _sgZA::P64;
           call GHC.Base.$fMonad[]_$c>>=_entry(R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.=<<_$s=<<_info" {
     GHC.Base.=<<_$s=<<_info:
         const GHC.Base.=<<_$s=<<_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.481443963 UTC

[section ""data" . GHC.Base.=<<_closure" {
     GHC.Base.=<<_closure:
         const GHC.Base.=<<_info;
 },
 GHC.Base.=<<_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ciRn: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ciRo; else goto ciRp;
       ciRo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.=<<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ciRp: // global
           R2 = R2;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.=<<_info" {
     GHC.Base.=<<_info:
         const GHC.Base.=<<_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.485983513 UTC

[section ""data" . poly_go_r7PI_closure" {
     poly_go_r7PI_closure:
         const poly_go_r7PI_info;
 },
 sat_sgZI_entry() //  [R1]
         { []
         }
     {offset
       ciRK: // global
           R2 = P64[R1 + 16];
           call poly_go_r7PI_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sgZI_info" {
     sat_sgZI_info:
         const sat_sgZI_entry;
         const 1;
         const 16;
 },
 poly_go_r7PI_entry() //  [R2]
         { []
         }
     {offset
       ciRR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ciRS; else goto ciRT;
       ciRS: // global
           R2 = R2;
           R1 = poly_go_r7PI_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciRT: // global
           I64[Sp - 8] = block_ciRA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uiRZ; else goto ciRB;
       uiRZ: // global
           call _ciRA(R1) args: 0, res: 0, upd: 0;
       ciRB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . poly_go_r7PI_info" {
     poly_go_r7PI_info:
         const poly_go_r7PI_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _ciRA() //  [R1]
         { []
         }
     {offset
       ciRA: // global
           if (R1 & 7 == 1) goto ciRO; else goto ciRP;
       ciRO: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciRP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ciRY; else goto ciRX;
       ciRY: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciRX: // global
           _sgZG::P64 = P64[R1 + 6];
           _sgZH::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sgZI_info;
           P64[Hp] = _sgZH::P64;
           R3 = Hp - 16;
           R2 = _sgZG::P64;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciRA_info" {
     block_ciRA_info:
         const _ciRA;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.493174214 UTC

[section ""data" . GHC.Base.$fMonoid[]_$cmconcat_closure" {
     GHC.Base.$fMonoid[]_$cmconcat_closure:
         const GHC.Base.$fMonoid[]_$cmconcat_info;
 },
 GHC.Base.$fMonoid[]_$cmconcat_entry() //  [R2]
         { []
         }
     {offset
       ciSm: // global
           R2 = R2;
           call poly_go_r7PI_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid[]_$cmconcat_info" {
     GHC.Base.$fMonoid[]_$cmconcat_info:
         const GHC.Base.$fMonoid[]_$cmconcat_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.499039898 UTC

[section ""data" . GHC.Base.$fApplicative[]_$c<*>_closure" {
     GHC.Base.$fApplicative[]_$c<*>_closure:
         const GHC.Base.$fApplicative[]_$c<*>_info;
 },
 go1_sgZS_entry() //  [R1, R2]
         { []
         }
     {offset
       ciSV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ciSW; else goto ciSX;
       ciSW: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciSX: // global
           I64[Sp - 32] = block_ciSO_info;
           _sgZS::P64 = R1;
           _sgZP::P64 = P64[R1 + 7];
           _sgZR::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sgZP::P64;
           P64[Sp - 16] = _sgZR::P64;
           P64[Sp - 8] = _sgZS::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uiT9; else goto ciSP;
       uiT9: // global
           call _ciSO(R1) args: 0, res: 0, upd: 0;
       ciSP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go1_sgZS_info" {
     go1_sgZS_info:
         const go1_sgZS_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _ciSO() //  [R1]
         { []
         }
     {offset
       ciSO: // global
           if (R1 & 7 == 1) goto ciSS; else goto ciST;
       ciSS: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ciST: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ciT8; else goto ciT7;
       ciT8: // global
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciT7: // global
           _sgZV::P64 = P64[R1 + 6];
           _sgZW::P64 = P64[R1 + 14];
           I64[Hp - 80] = stg_ap_2_upd_info;
           P64[Hp - 64] = P64[Sp + 24];
           P64[Hp - 56] = _sgZW::P64;
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sgZV::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciSO_info" {
     block_ciSO_info:
         const _ciSO;
         const 3;
         const 30;
 },
 go_sgZM_entry() //  [R1, R2]
         { []
         }
     {offset
       ciTe: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ciTf; else goto ciTg;
       ciTf: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciTg: // global
           I64[Sp - 24] = block_ciSC_info;
           _sgZM::P64 = R1;
           _sgZL::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sgZL::P64;
           P64[Sp - 8] = _sgZM::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uiTm; else goto ciSD;
       uiTm: // global
           call _ciSC(R1) args: 0, res: 0, upd: 0;
       ciSD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_sgZM_info" {
     go_sgZM_info:
         const go_sgZM_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _ciSC() //  [R1]
         { []
         }
     {offset
       ciSC: // global
           if (R1 & 7 == 1) goto ciTb; else goto ciTc;
       ciTb: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciTc: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ciTl; else goto ciTk;
       ciTl: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciTk: // global
           _sgZP::P64 = P64[R1 + 6];
           _sgZQ::P64 = P64[R1 + 14];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sgZQ::P64;
           I64[Hp - 16] = go1_sgZS_info;
           P64[Hp - 8] = _sgZP::P64;
           P64[Hp] = Hp - 48;
           R2 = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call go1_sgZS_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciSC_info" {
     block_ciSC_info:
         const _ciSC;
         const 2;
         const 30;
 },
 GHC.Base.$fApplicative[]_$c<*>_entry() //  [R2, R3]
         { []
         }
     {offset
       ciTn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ciTr; else goto ciTq;
       ciTr: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciTq: // global
           I64[Hp - 8] = go_sgZM_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_sgZM_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative[]_$c<*>_info" {
     GHC.Base.$fApplicative[]_$c<*>_info:
         const GHC.Base.$fApplicative[]_$c<*>_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.512423049 UTC

[section ""data" . GHC.Base.$fApplicative[]_$cliftA2_closure" {
     GHC.Base.$fApplicative[]_$cliftA2_closure:
         const GHC.Base.$fApplicative[]_$cliftA2_info;
 },
 go1_sh08_entry() //  [R1, R2]
         { []
         }
     {offset
       ciUB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ciUC; else goto ciUD;
       ciUC: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciUD: // global
           I64[Sp - 40] = block_ciUu_info;
           _sh08::P64 = R1;
           _sgZZ::P64 = P64[R1 + 7];
           _sh05::P64 = P64[R1 + 15];
           _sh07::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sgZZ::P64;
           P64[Sp - 24] = _sh05::P64;
           P64[Sp - 16] = _sh07::P64;
           P64[Sp - 8] = _sh08::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uiUP; else goto ciUv;
       uiUP: // global
           call _ciUu(R1) args: 0, res: 0, upd: 0;
       ciUv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go1_sh08_info" {
     go1_sh08_info:
         const go1_sh08_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 _ciUu() //  [R1]
         { []
         }
     {offset
       ciUu: // global
           if (R1 & 7 == 1) goto ciUy; else goto ciUz;
       ciUy: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 40;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ciUz: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ciUO; else goto ciUN;
       ciUO: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciUN: // global
           _sh0b::P64 = P64[R1 + 6];
           _sh0c::P64 = P64[R1 + 14];
           I64[Hp - 88] = stg_ap_2_upd_info;
           P64[Hp - 72] = P64[Sp + 32];
           P64[Hp - 64] = _sh0c::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sh0b::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciUu_info" {
     block_ciUu_info:
         const _ciUu;
         const 4;
         const 30;
 },
 go_sh02_entry() //  [R1, R2]
         { []
         }
     {offset
       ciUU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ciUV; else goto ciUW;
       ciUV: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciUW: // global
           I64[Sp - 32] = block_ciUi_info;
           _sh02::P64 = R1;
           _sgZZ::P64 = P64[R1 + 7];
           _sh01::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sgZZ::P64;
           P64[Sp - 16] = _sh01::P64;
           P64[Sp - 8] = _sh02::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uiV2; else goto ciUj;
       uiV2: // global
           call _ciUi(R1) args: 0, res: 0, upd: 0;
       ciUj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_sh02_info" {
     go_sh02_info:
         const go_sh02_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _ciUi() //  [R1]
         { []
         }
     {offset
       ciUi: // global
           if (R1 & 7 == 1) goto ciUR; else goto ciUS;
       ciUR: // global
           R1 = []_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciUS: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto ciV1; else goto ciV0;
       ciV1: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciV0: // global
           _sh05::P64 = P64[R1 + 6];
           _sh06::P64 = P64[R1 + 14];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = _sh06::P64;
           I64[Hp - 24] = go1_sh08_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sh05::P64;
           P64[Hp] = Hp - 56;
           R2 = P64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 32;
           call go1_sh08_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciUi_info" {
     block_ciUi_info:
         const _ciUi;
         const 3;
         const 30;
 },
 GHC.Base.$fApplicative[]_$cliftA2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ciV3: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ciV7; else goto ciV6;
       ciV7: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ciV6: // global
           I64[Hp - 16] = go_sh02_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           R2 = R3;
           R1 = Hp - 15;
           call go_sh02_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative[]_$cliftA2_info" {
     GHC.Base.$fApplicative[]_$cliftA2_info:
         const GHC.Base.$fApplicative[]_$cliftA2_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.524086469 UTC

[section ""data" . GHC.Base.$fApplicative[]_$c<*_closure" {
     GHC.Base.$fApplicative[]_$c<*_closure:
         const GHC.Base.$fApplicative[]_$c<*_info;
 },
 GHC.Base.$fApplicative[]_$c<*_entry() //  [R2, R3]
         { []
         }
     {offset
       ciVV: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.Base.const_closure+2;
           call GHC.Base.$fApplicative[]_$cliftA2_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative[]_$c<*_info" {
     GHC.Base.$fApplicative[]_$c<*_info:
         const GHC.Base.$fApplicative[]_$c<*_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.528995747 UTC

[section ""data" . GHC.Base.$fApplicative[]_$c*>_closure" {
     GHC.Base.$fApplicative[]_$c*>_closure:
         const GHC.Base.$fApplicative[]_$c*>_info;
 },
 sat_sh0m_entry() //  [R1]
         { []
         }
     {offset
       ciWl: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_sh0h_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh0m_info" {
     sat_sh0m_info:
         const sat_sh0m_entry;
         const 2;
         const 18;
 },
 go_sh0h_entry() //  [R1, R2]
         { []
         }
     {offset
       ciWs: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ciWt; else goto ciWu;
       ciWt: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciWu: // global
           I64[Sp - 24] = block_ciWb_info;
           _sh0h::P64 = R1;
           _sh0g::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sh0g::P64;
           P64[Sp - 8] = _sh0h::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uiWA; else goto ciWc;
       uiWA: // global
           call _ciWb(R1) args: 0, res: 0, upd: 0;
       ciWc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_sh0h_info" {
     go_sh0h_info:
         const go_sh0h_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _ciWb() //  [R1]
         { []
         }
     {offset
       ciWb: // global
           if (R1 & 7 == 1) goto ciWp; else goto ciWq;
       ciWp: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciWq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ciWz; else goto ciWy;
       ciWz: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciWy: // global
           _sh0l::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_sh0m_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sh0l::P64;
           R3 = Hp - 24;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciWb_info" {
     block_ciWb_info:
         const _ciWb;
         const 2;
         const 30;
 },
 GHC.Base.$fApplicative[]_$c*>_entry() //  [R2, R3]
         { []
         }
     {offset
       ciWB: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ciWF; else goto ciWE;
       ciWF: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative[]_$c*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciWE: // global
           I64[Hp - 8] = go_sh0h_info;
           P64[Hp] = R3;
           R2 = R2;
           R1 = Hp - 7;
           call go_sh0h_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative[]_$c*>_info" {
     GHC.Base.$fApplicative[]_$c*>_info:
         const GHC.Base.$fApplicative[]_$c*>_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.538115271 UTC

[section ""data" . GHC.Base.$fApplicative[]_closure" {
     GHC.Base.$fApplicative[]_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctor[]_closure+1;
         const GHC.Base.$fApplicative[]_$cpure_closure+1;
         const GHC.Base.$fApplicative[]_$c<*>_closure+2;
         const GHC.Base.$fApplicative[]_$cliftA2_closure+3;
         const GHC.Base.$fApplicative[]_$c*>_closure+2;
         const GHC.Base.$fApplicative[]_$c<*_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.541709941 UTC

[section ""data" . GHC.Base.$fFunctorNonEmpty_$cfmap_closure" {
     GHC.Base.$fFunctorNonEmpty_$cfmap_closure:
         const GHC.Base.$fFunctorNonEmpty_$cfmap_info;
 },
 sat_sh0x_entry() //  [R1]
         { []
         }
     {offset
       ciXf: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ciXg; else goto ciXh;
       ciXg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciXh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_ciXc_info;
           _sh0n::P64 = P64[R1 + 16];
           R1 = P64[R1 + 24];
           P64[Sp - 24] = _sh0n::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uiXl; else goto ciXd;
       uiXl: // global
           call _ciXc(R1) args: 0, res: 0, upd: 0;
       ciXd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh0x_info" {
     sat_sh0x_info:
         const sat_sh0x_entry;
         const 2;
         const 18;
 },
 _ciXc() //  [R1]
         { []
         }
     {offset
       ciXc: // global
           R3 = P64[R1 + 15];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ciXc_info" {
     block_ciXc_info:
         const _ciXc;
         const 1;
         const 30;
 },
 sat_sh0t_entry() //  [R1]
         { []
         }
     {offset
       ciXr: // global
           _sh0t::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ciXs; else goto ciXt;
       ciXt: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ciXv; else goto ciXu;
       ciXv: // global
           HpAlloc = 24;
           goto ciXs;
       ciXs: // global
           R1 = _sh0t::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciXu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sh0t::P64;
           _sh0n::P64 = P64[_sh0t::P64 + 16];
           _sh0o::P64 = P64[_sh0t::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sh0o::P64;
           R2 = Hp - 16;
           R1 = _sh0n::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh0t_info" {
     sat_sh0t_info:
         const sat_sh0t_entry;
         const 2;
         const 18;
 },
 GHC.Base.$fFunctorNonEmpty_$cfmap_entry() //  [R2, R3]
         { []
         }
     {offset
       ciXx: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ciXB; else goto ciXA;
       ciXB: // global
           HpAlloc = 88;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctorNonEmpty_$cfmap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ciXA: // global
           I64[Hp - 80] = sat_sh0x_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sh0t_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = Hp - 80;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fFunctorNonEmpty_$cfmap_info" {
     GHC.Base.$fFunctorNonEmpty_$cfmap_info:
         const GHC.Base.$fFunctorNonEmpty_$cfmap_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.550301802 UTC

[section ""data" . GHC.Base.$fFunctorNonEmpty_closure" {
     GHC.Base.$fFunctorNonEmpty_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fFunctorNonEmpty_$cfmap_closure+2;
         const GHC.Base.$fFunctorNonEmpty_$c<$_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.551883143 UTC

[section ""data" . GHC.Base.$fAlternative[]1_closure" {
     GHC.Base.$fAlternative[]1_closure:
         const :_con_info;
         const GHC.Types.[]_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.557471287 UTC

[section ""data" . GHC.Base.$fAlternative[]_$csome_closure" {
     GHC.Base.$fAlternative[]_$csome_closure:
         const GHC.Base.$fAlternative[]_$csome_info;
 },
 ys_sh0A_entry() //  [R1]
         { []
         }
     {offset
       ciYg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ciYh; else goto ciYi;
       ciYh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciYi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = GHC.Base.$fAlternative[]1_closure+2;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ys_sh0A_info" {
     ys_sh0A_info:
         const ys_sh0A_entry;
         const 1;
         const 16;
 },
 go1_sh0H_entry() //  [R1, R2]
         { []
         }
     {offset
       ciYH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ciYI; else goto ciYJ;
       ciYI: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciYJ: // global
           I64[Sp - 32] = block_ciYA_info;
           _sh0H::P64 = R1;
           _sh0E::P64 = P64[R1 + 7];
           _sh0G::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sh0E::P64;
           P64[Sp - 16] = _sh0G::P64;
           P64[Sp - 8] = _sh0H::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uiYV; else goto ciYB;
       uiYV: // global
           call _ciYA(R1) args: 0, res: 0, upd: 0;
       ciYB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go1_sh0H_info" {
     go1_sh0H_info:
         const go1_sh0H_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _ciYA() //  [R1]
         { []
         }
     {offset
       ciYA: // global
           if (R1 & 7 == 1) goto ciYE; else goto ciYF;
       ciYE: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ciYF: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ciYU; else goto ciYT;
       ciYU: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciYT: // global
           _sh0K::P64 = P64[R1 + 6];
           _sh0L::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _sh0L::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sh0K::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciYA_info" {
     block_ciYA_info:
         const _ciYA;
         const 3;
         const 30;
 },
 go_sh0B_entry() //  [R1, R2]
         { []
         }
     {offset
       ciZ0: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ciZ1; else goto ciZ2;
       ciZ1: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciZ2: // global
           I64[Sp - 24] = block_ciYo_info;
           _sh0B::P64 = R1;
           _sh0A::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sh0A::P64;
           P64[Sp - 8] = _sh0B::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uiZ8; else goto ciYp;
       uiZ8: // global
           call _ciYo(R1) args: 0, res: 0, upd: 0;
       ciYp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_sh0B_info" {
     go_sh0B_info:
         const go_sh0B_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _ciYo() //  [R1]
         { []
         }
     {offset
       ciYo: // global
           if (R1 & 7 == 1) goto ciYX; else goto ciYY;
       ciYX: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ciYY: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ciZ7; else goto ciZ6;
       ciZ7: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ciZ6: // global
           _sh0E::P64 = P64[R1 + 6];
           _sh0F::P64 = P64[R1 + 14];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sh0F::P64;
           I64[Hp - 16] = go1_sh0H_info;
           P64[Hp - 8] = _sh0E::P64;
           P64[Hp] = Hp - 48;
           R2 = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call go1_sh0H_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ciYo_info" {
     block_ciYo_info:
         const _ciYo;
         const 2;
         const 30;
 },
 some_v_sh0z_entry() //  [R1]
         { []
         }
     {offset
       ciZ9: // global
           _sh0z::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ciZa; else goto ciZb;
       ciZb: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ciZd; else goto ciZc;
       ciZd: // global
           HpAlloc = 40;
           goto ciZa;
       ciZa: // global
           R1 = _sh0z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ciZc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sh0z::P64;
           _sh0y::P64 = P64[_sh0z::P64 + 16];
           I64[Hp - 32] = ys_sh0A_info;
           P64[Hp - 16] = _sh0z::P64;
           I64[Hp - 8] = go_sh0B_info;
           P64[Hp] = Hp - 32;
           R2 = _sh0y::P64;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call go_sh0B_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . some_v_sh0z_info" {
     some_v_sh0z_info:
         const some_v_sh0z_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fAlternative[]_$csome_entry() //  [R2]
         { []
         }
     {offset
       ciZe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ciZi; else goto ciZh;
       ciZi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternative[]_$csome_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ciZh: // global
           I64[Hp - 16] = some_v_sh0z_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fAlternative[]_$csome_info" {
     GHC.Base.$fAlternative[]_$csome_info:
         const GHC.Base.$fAlternative[]_$csome_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.575845648 UTC

[section ""data" . GHC.Base.$fAlternative[]_$cmany_closure" {
     GHC.Base.$fAlternative[]_$cmany_closure:
         const GHC.Base.$fAlternative[]_$cmany_info;
 },
 go1_sh0W_entry() //  [R1, R2]
         { []
         }
     {offset
       cj0L: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cj0M; else goto cj0N;
       cj0M: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cj0N: // global
           I64[Sp - 32] = block_cj0E_info;
           _sh0W::P64 = R1;
           _sh0T::P64 = P64[R1 + 7];
           _sh0V::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sh0T::P64;
           P64[Sp - 16] = _sh0V::P64;
           P64[Sp - 8] = _sh0W::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uj0Z; else goto cj0F;
       uj0Z: // global
           call _cj0E(R1) args: 0, res: 0, upd: 0;
       cj0F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go1_sh0W_info" {
     go1_sh0W_info:
         const go1_sh0W_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _cj0E() //  [R1]
         { []
         }
     {offset
       cj0E: // global
           if (R1 & 7 == 1) goto cj0I; else goto cj0J;
       cj0I: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cj0J: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cj0Y; else goto cj0X;
       cj0Y: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cj0X: // global
           _sh0Z::P64 = P64[R1 + 6];
           _sh10::P64 = P64[R1 + 14];
           I64[Hp - 72] = stg_ap_2_upd_info;
           P64[Hp - 56] = P64[Sp + 24];
           P64[Hp - 48] = _sh10::P64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _sh0Z::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cj0E_info" {
     block_cj0E_info:
         const _cj0E;
         const 3;
         const 30;
 },
 go_sh0Q_entry() //  [R1, R2]
         { []
         }
     {offset
       cj14: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cj15; else goto cj16;
       cj15: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cj16: // global
           I64[Sp - 24] = block_cj0s_info;
           _sh0Q::P64 = R1;
           _sh0P::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sh0P::P64;
           P64[Sp - 8] = _sh0Q::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uj1c; else goto cj0t;
       uj1c: // global
           call _cj0s(R1) args: 0, res: 0, upd: 0;
       cj0t: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_sh0Q_info" {
     go_sh0Q_info:
         const go_sh0Q_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _cj0s() //  [R1]
         { []
         }
     {offset
       cj0s: // global
           if (R1 & 7 == 1) goto cj11; else goto cj12;
       cj11: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cj12: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cj1b; else goto cj1a;
       cj1b: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cj1a: // global
           _sh0T::P64 = P64[R1 + 6];
           _sh0U::P64 = P64[R1 + 14];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sh0U::P64;
           I64[Hp - 16] = go1_sh0W_info;
           P64[Hp - 8] = _sh0T::P64;
           P64[Hp] = Hp - 48;
           R2 = P64[Sp + 8];
           R1 = Hp - 15;
           Sp = Sp + 24;
           call go1_sh0W_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cj0s_info" {
     block_cj0s_info:
         const _cj0s;
         const 2;
         const 30;
 },
 many_v_sh0P_entry() //  [R1]
         { []
         }
     {offset
       cj1f: // global
           _sh0P::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cj1g; else goto cj1h;
       cj1h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cj1j; else goto cj1i;
       cj1j: // global
           HpAlloc = 16;
           goto cj1g;
       cj1g: // global
           R1 = _sh0P::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj1i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sh0P::P64;
           _sh0O::P64 = P64[_sh0P::P64 + 16];
           I64[Hp - 8] = go_sh0Q_info;
           P64[Hp] = _sh0P::P64;
           I64[Sp - 24] = block_cj1d_info;
           R2 = _sh0O::P64;
           R1 = Hp - 7;
           Sp = Sp - 24;
           call go_sh0Q_entry(R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . many_v_sh0P_info" {
     many_v_sh0P_info:
         const many_v_sh0P_entry;
         const 1;
         const 16;
 },
 _cj1d() //  [R1]
         { []
         }
     {offset
       cj1d: // global
           R3 = GHC.Base.$fAlternative[]1_closure+2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cj1d_info" {
     block_cj1d_info:
         const _cj1d;
         const 0;
         const 30;
 },
 GHC.Base.$fAlternative[]_$cmany_entry() //  [R2]
         { []
         }
     {offset
       cj1n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cj1r; else goto cj1q;
       cj1r: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fAlternative[]_$cmany_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cj1q: // global
           I64[Hp - 16] = many_v_sh0P_info;
           P64[Hp] = R2;
           R1 = (Hp + -16) & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fAlternative[]_$cmany_info" {
     GHC.Base.$fAlternative[]_$cmany_info:
         const GHC.Base.$fAlternative[]_$cmany_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.590116703 UTC

[section ""data" . GHC.Base.$fAlternative[]_closure" {
     GHC.Base.$fAlternative[]_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Base.$fApplicative[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.++_closure+2;
         const GHC.Base.$fAlternative[]_$csome_closure+1;
         const GHC.Base.$fAlternative[]_$cmany_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.596447945 UTC

[section ""data" . GHC.Base.$w$c>>=_closure" {
     GHC.Base.$w$c>>=_closure:
         const GHC.Base.$w$c>>=_info;
 },
 ds_sh16_entry() //  [R1]
         { []
         }
     {offset
       cj2v: // global
           _sh16::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cj2w; else goto cj2x;
       cj2x: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cj2z; else goto cj2y;
       cj2z: // global
           HpAlloc = 24;
           goto cj2w;
       cj2w: // global
           R1 = _sh16::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj2y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sh16::P64;
           _sh14::P64 = P64[_sh16::P64 + 16];
           _sh15::P64 = P64[_sh16::P64 + 24];
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _sh14::P64;
           R2 = Hp - 16;
           R1 = _sh15::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . ds_sh16_info" {
     ds_sh16_info:
         const ds_sh16_entry;
         const 2;
         const 18;
 },
 sat_sh1A_entry() //  [R1]
         { []
         }
     {offset
       cj38: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go_sh1l_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh1A_info" {
     sat_sh1A_info:
         const sat_sh1A_entry;
         const 2;
         const 18;
 },
 go_sh1l_entry() //  [R1, R2]
         { []
         }
     {offset
       cj3f: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cj3g; else goto cj3h;
       cj3g: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cj3h: // global
           I64[Sp - 24] = block_cj2X_info;
           _sh1l::P64 = R1;
           _sh15::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sh15::P64;
           P64[Sp - 8] = _sh1l::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uj3q; else goto cj2Y;
       uj3q: // global
           call _cj2X(R1) args: 0, res: 0, upd: 0;
       cj2Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_sh1l_info" {
     go_sh1l_info:
         const go_sh1l_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _cj2X() //  [R1]
         { []
         }
     {offset
       cj2X: // global
           if (R1 & 7 == 1) goto cj3c; else goto cj3d;
       cj3c: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cj3d: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cj3p; else goto cj3o;
       cj3p: // global
           HpAlloc = 136;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cj3o: // global
           _sh1o::P64 = P64[R1 + 6];
           _sh1p::P64 = P64[R1 + 14];
           I64[Hp - 128] = stg_ap_2_upd_info;
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = _sh1o::P64;
           I64[Hp - 96] = sat_sh1A_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _sh1p::P64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cj33::P64 = Hp - 128;
           P64[Hp - 48] = _cj33::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cj33::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R3 = Hp - 96;
           R2 = Hp - 14;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cj2X_info" {
     block_cj2X_info:
         const _cj2X;
         const 2;
         const 30;
 },
 sat_sh1B_entry() //  [R1]
         { []
         }
     {offset
       cj3r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cj3s; else goto cj3t;
       cj3s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj3t: // global
           I64[Sp - 16] = block_cj2N_info;
           _sh15::P64 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           P64[Sp - 8] = _sh15::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uj3x; else goto cj2O;
       uj3x: // global
           call _cj2N(R1) args: 0, res: 0, upd: 0;
       cj2O: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh1B_info" {
     sat_sh1B_info:
         const sat_sh1B_entry;
         const 2;
         const 18;
 },
 _cj2N() //  [R1]
         { []
         }
     {offset
       cj2N: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cj3w; else goto cj3v;
       cj3w: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cj3v: // global
           _sh1k::P64 = P64[R1 + 15];
           I64[Hp - 8] = go_sh1l_info;
           P64[Hp] = P64[Sp + 8];
           R2 = _sh1k::P64;
           R1 = Hp - 7;
           Sp = Sp + 16;
           call go_sh1l_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cj2N_info" {
     block_cj2N_info:
         const _cj2N;
         const 1;
         const 30;
 },
 sat_sh1C_entry() //  [R1]
         { []
         }
     {offset
       cj3y: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cj3z; else goto cj3A;
       cj3z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj3A: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cj2E_info;
           _sh14::P64 = P64[R1 + 16];
           _sh15::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sh14::P64;
           P64[Sp - 24] = _sh15::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uj3E; else goto cj2F;
       uj3E: // global
           call _cj2E(R1) args: 0, res: 0, upd: 0;
       cj2F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh1C_info" {
     sat_sh1C_info:
         const sat_sh1C_entry;
         const 3;
         const 15;
 },
 _cj2E() //  [R1]
         { []
         }
     {offset
       cj2E: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cj3D; else goto cj3C;
       cj3D: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cj3C: // global
           _sh1h::P64 = P64[R1 + 15];
           I64[Hp - 24] = sat_sh1B_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = P64[Sp + 16];
           R3 = Hp - 24;
           R2 = _sh1h::P64;
           Sp = Sp + 24;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cj2E_info" {
     block_cj2E_info:
         const _cj2E;
         const 2;
         const 30;
 },
 GHC.Base.$w$c>>=_entry() //  [R2, R3]
         { []
         }
     {offset
       cj3G: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cj3K; else goto cj3J;
       cj3K: // global
           HpAlloc = 96;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cj3J: // global
           I64[Hp - 88] = ds_sh16_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_sh1C_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           _cj2q::P64 = Hp - 88;
           P64[Hp - 24] = _cj2q::P64;
           I64[Hp - 16] = stg_sel_0_upd_info;
           P64[Hp] = _cj2q::P64;
           R2 = Hp - 56;
           R1 = Hp - 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$c>>=_info" {
     GHC.Base.$w$c>>=_info:
         const GHC.Base.$w$c>>=_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.614574869 UTC

[section ""data" . GHC.Base.$fMonadNonEmpty_$c>>=_closure" {
     GHC.Base.$fMonadNonEmpty_$c>>=_closure:
         const GHC.Base.$fMonadNonEmpty_$c>>=_info;
 },
 GHC.Base.$fMonadNonEmpty_$c>>=_entry() //  [R2, R3]
         { []
         }
     {offset
       cj4T: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cj4U; else goto cj4V;
       cj4U: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonadNonEmpty_$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cj4V: // global
           I64[Sp - 8] = block_cj4Q_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonadNonEmpty_$c>>=_info" {
     GHC.Base.$fMonadNonEmpty_$c>>=_info:
         const GHC.Base.$fMonadNonEmpty_$c>>=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cj4Q() //  [R1, R2]
         { []
         }
     {offset
       cj4Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cj4Y; else goto cj4X;
       cj4Y: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cj4X: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cj4Q_info" {
     block_cj4Q_info:
         const _cj4Q;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.621343626 UTC

[section ""data" . GHC.Base.$fMonadNonEmpty_$c>>_closure" {
     GHC.Base.$fMonadNonEmpty_$c>>_closure:
         const GHC.Base.$fMonadNonEmpty_$c>>_info;
 },
 sat_sh1L_entry() //  [R1]
         { []
         }
     {offset
       cj5j: // global
           R1 = P64[R1 + 7] & (-8);
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh1L_info" {
     sat_sh1L_info:
         const sat_sh1L_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 GHC.Base.$fMonadNonEmpty_$c>>_entry() //  [R2, R3]
         { []
         }
     {offset
       cj5p: // global
           _sh1J::P64 = R3;
           _sh1I::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cj5q; else goto cj5r;
       cj5r: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cj5t; else goto cj5s;
       cj5t: // global
           HpAlloc = 16;
           goto cj5q;
       cj5q: // global
           R3 = _sh1J::P64;
           R2 = _sh1I::P64;
           R1 = GHC.Base.$fMonadNonEmpty_$c>>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cj5s: // global
           I64[Hp - 8] = sat_sh1L_info;
           P64[Hp] = _sh1J::P64;
           I64[Sp - 8] = block_cj5m_info;
           R3 = Hp - 7;
           R2 = _sh1I::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonadNonEmpty_$c>>_info" {
     GHC.Base.$fMonadNonEmpty_$c>>_info:
         const GHC.Base.$fMonadNonEmpty_$c>>_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cj5m() //  [R1, R2]
         { []
         }
     {offset
       cj5m: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cj5w; else goto cj5v;
       cj5w: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cj5v: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cj5m_info" {
     block_cj5m_info:
         const _cj5m;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.628124409 UTC

[section ""data" . GHC.Base.<**>1_closure" {
     GHC.Base.<**>1_closure:
         const GHC.Base.<**>1_info;
 },
 GHC.Base.<**>1_entry() //  [R2, R3]
         { []
         }
     {offset
       cj5S: // global
           R2 = R2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.<**>1_info" {
     GHC.Base.<**>1_info:
         const GHC.Base.<**>1_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.631556299 UTC

[section ""data" . GHC.Base.<**>_closure" {
     GHC.Base.<**>_closure:
         const GHC.Base.<**>_info;
 },
 GHC.Base.<**>_entry() //  [R2]
         { []
         }
     {offset
       cj63: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cj64; else goto cj65;
       cj64: // global
           R2 = R2;
           R1 = GHC.Base.<**>_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cj65: // global
           R2 = R2;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = GHC.Base.<**>1_closure+2;
           Sp = Sp - 16;
           call GHC.Base.liftA2_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.<**>_info" {
     GHC.Base.<**>_info:
         const GHC.Base.<**>_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.636144095 UTC

[section ""data" . GHC.Base.$dmliftA2_closure" {
     GHC.Base.$dmliftA2_closure:
         const GHC.Base.$dmliftA2_info;
 },
 sat_sh1W_entry() //  [R1]
         { []
         }
     {offset
       cj6n: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cj6o; else goto cj6p;
       cj6o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj6p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cj6l_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Applicative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh1W_info" {
     sat_sh1W_info:
         const sat_sh1W_entry;
         const 3;
         const 15;
 },
 _cj6l() //  [R1]
         { []
         }
     {offset
       cj6l: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.fmap_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cj6l_info" {
     block_cj6l_info:
         const _cj6l;
         const 2;
         const 30;
 },
 GHC.Base.$dmliftA2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cj6t: // global
           _sh1U::P64 = R4;
           _sh1T::P64 = R3;
           _sh1S::P64 = R2;
           if ((Sp + -16) < SpLim) (likely: False) goto cj6u; else goto cj6v;
       cj6v: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cj6x; else goto cj6w;
       cj6x: // global
           HpAlloc = 40;
           goto cj6u;
       cj6u: // global
           R4 = _sh1U::P64;
           R3 = _sh1T::P64;
           R2 = _sh1S::P64;
           R1 = GHC.Base.$dmliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cj6w: // global
           I64[Hp - 32] = sat_sh1W_info;
           P64[Hp - 16] = _sh1S::P64;
           P64[Hp - 8] = _sh1T::P64;
           P64[Hp] = _sh1U::P64;
           R2 = _sh1S::P64;
           I64[Sp - 16] = stg_ap_p_info;
           P64[Sp - 8] = Hp - 32;
           Sp = Sp - 16;
           call GHC.Base.<*>_entry(R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmliftA2_info" {
     GHC.Base.$dmliftA2_info:
         const GHC.Base.$dmliftA2_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.64523652 UTC

[section ""data" . GHC.Base.$dmsome_closure" {
     GHC.Base.$dmsome_closure:
         const GHC.Base.$dmsome_info;
 },
 sat_sh21_entry() //  [R1]
         { []
         }
     {offset
       cj7c: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cj7d; else goto cj7e;
       cj7d: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj7e: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh21_info" {
     sat_sh21_info:
         const sat_sh21_entry;
         const 1;
         const 16;
 },
 sat_sh22_entry() //  [R1]
         { []
         }
     {offset
       cj7f: // global
           _sh22::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cj7g; else goto cj7h;
       cj7h: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cj7j; else goto cj7i;
       cj7j: // global
           HpAlloc = 24;
           goto cj7g;
       cj7g: // global
           R1 = _sh22::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj7i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sh22::P64;
           _sh1X::P64 = P64[_sh22::P64 + 16];
           _sh1Z::P64 = P64[_sh22::P64 + 24];
           _sh20::P64 = P64[_sh22::P64 + 32];
           I64[Hp - 16] = sat_sh21_info;
           P64[Hp] = _sh20::P64;
           R2 = _sh1X::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = _sh1Z::P64;
           P64[Sp - 24] = Hp - 16;
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh22_info" {
     sat_sh22_info:
         const sat_sh22_entry;
         const 3;
         const 15;
 },
 some_v_sh1Z_entry() //  [R1]
         { []
         }
     {offset
       cj7k: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cj7l; else goto cj7m;
       cj7l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj7m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 48] = block_cj70_info;
           _sh1X::P64 = P64[R1 + 16];
           R2 = _sh1X::P64;
           P64[Sp - 40] = _sh1X::P64;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = R1;
           Sp = Sp - 48;
           call GHC.Base.$p1Alternative_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . some_v_sh1Z_info" {
     some_v_sh1Z_info:
         const some_v_sh1Z_entry;
         const 2;
         const 18;
 },
 _cj70() //  [R1]
         { []
         }
     {offset
       cj70: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cj7p; else goto cj7o;
       cj7p: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cj7o: // global
           I64[Hp - 32] = sat_sh22_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R2 = R1;
           I64[Sp] = stg_ap_ppp_info;
           P64[Sp + 8] = GHC.Types.:_closure+2;
           P64[Sp + 24] = Hp - 32;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cj70_info" {
     block_cj70_info:
         const _cj70;
         const 3;
         const 30;
 },
 GHC.Base.$dmsome_entry() //  [R2, R3]
         { []
         }
     {offset
       cj7q: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cj7u; else goto cj7t;
       cj7u: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmsome_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cj7t: // global
           I64[Hp - 24] = some_v_sh1Z_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmsome_info" {
     GHC.Base.$dmsome_info:
         const GHC.Base.$dmsome_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.659022612 UTC

[section ""data" . GHC.Base.$dmmany_closure" {
     GHC.Base.$dmmany_closure:
         const GHC.Base.$dmmany_info;
 },
 $dApplicative_sh26_entry() //  [R1]
         { []
         }
     {offset
       cj8j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cj8k; else goto cj8l;
       cj8k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj8l: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Alternative_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dApplicative_sh26_info" {
     $dApplicative_sh26_info:
         const $dApplicative_sh26_entry;
         const 1;
         const 16;
 },
 sat_sh28_entry() //  [R1]
         { []
         }
     {offset
       cj8q: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cj8r; else goto cj8s;
       cj8r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj8s: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = GHC.Types.[]_closure+1;
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh28_info" {
     sat_sh28_info:
         const sat_sh28_entry;
         const 1;
         const 16;
 },
 sat_sh27_entry() //  [R1]
         { []
         }
     {offset
       cj8x: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cj8y; else goto cj8z;
       cj8y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj8z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 32];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = GHC.Types.:_closure+2;
           P64[Sp - 32] = P64[R1 + 16];
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh27_info" {
     sat_sh27_info:
         const sat_sh27_entry;
         const 3;
         const 15;
 },
 many_v_sh25_entry() //  [R1]
         { []
         }
     {offset
       cj8A: // global
           _sh25::P64 = R1;
           if ((Sp + -40) < SpLim) (likely: False) goto cj8B; else goto cj8C;
       cj8C: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cj8E; else goto cj8D;
       cj8E: // global
           HpAlloc = 88;
           goto cj8B;
       cj8B: // global
           R1 = _sh25::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cj8D: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sh25::P64;
           _sh23::P64 = P64[_sh25::P64 + 16];
           _sh24::P64 = P64[_sh25::P64 + 24];
           I64[Hp - 80] = $dApplicative_sh26_info;
           P64[Hp - 64] = _sh23::P64;
           I64[Hp - 56] = sat_sh28_info;
           _cj8f::P64 = Hp - 80;
           P64[Hp - 40] = _cj8f::P64;
           I64[Hp - 32] = sat_sh27_info;
           P64[Hp - 16] = _sh24::P64;
           P64[Hp - 8] = _sh25::P64;
           P64[Hp] = _cj8f::P64;
           R2 = _sh23::P64;
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = Hp - 32;
           P64[Sp - 24] = Hp - 56;
           Sp = Sp - 40;
           call GHC.Base.<|>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . many_v_sh25_info" {
     many_v_sh25_info:
         const many_v_sh25_entry;
         const 2;
         const 18;
 },
 GHC.Base.$dmmany_entry() //  [R2, R3]
         { []
         }
     {offset
       cj8F: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cj8J; else goto cj8I;
       cj8J: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmmany_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cj8I: // global
           I64[Hp - 24] = many_v_sh25_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmmany_info" {
     GHC.Base.$dmmany_info:
         const GHC.Base.$dmmany_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.672005668 UTC

[section ""data" . GHC.Base.$w$csconcat3_closure" {
     GHC.Base.$w$csconcat3_closure:
         const GHC.Base.$w$csconcat3_info;
 },
 sat_sh2m_entry() //  [R1, R2]
         { []
         }
     {offset
       cj9K: // global
           _sh2j::P64 = R2;
           _sh2m::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cj9L; else goto cj9M;
       cj9M: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cj9O; else goto cj9N;
       cj9O: // global
           HpAlloc = 64;
           goto cj9L;
       cj9L: // global
           R2 = _sh2j::P64;
           R1 = _sh2m::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cj9N: // global
           _sh29::P64 = P64[_sh2m::P64 + 7];
           _sh2d::P64 = P64[_sh2m::P64 + 15];
           _sh2i::P64 = P64[_sh2m::P64 + 23];
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _sh2i::P64;
           P64[Hp - 32] = _sh2j::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sh2d::P64;
           P64[Hp] = _sh2j::P64;
           R2 = _sh29::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh2m_info" {
     sat_sh2m_info:
         const sat_sh2m_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 go_sh2c_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cj9T: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cj9U; else goto cj9V;
       cj9U: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cj9V: // global
           I64[Sp - 32] = block_cj9w_info;
           _sh2c::P64 = R1;
           _sh29::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _sh29::P64;
           P64[Sp - 16] = _sh2c::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uja1; else goto cj9x;
       uja1: // global
           call _cj9w(R1) args: 0, res: 0, upd: 0;
       cj9x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_sh2c_info" {
     go_sh2c_info:
         const go_sh2c_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 _cj9w() //  [R1]
         { []
         }
     {offset
       cj9w: // global
           _sh2d::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cj9Q; else goto cj9R;
       cj9Q: // global
           R1 = _sh2d::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cj9R: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cja0; else goto cj9Z;
       cja0: // global
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cj9Z: // global
           _sh2g::P64 = P64[R1 + 6];
           _sh2h::P64 = P64[R1 + 14];
           I64[Hp - 64] = stg_ap_3_upd_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = _sh2g::P64;
           P64[Hp - 32] = _sh2h::P64;
           I64[Hp - 24] = sat_sh2m_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sh2d::P64;
           P64[Hp] = Hp - 64;
           R1 = Hp - 23;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cj9w_info" {
     block_cj9w_info:
         const _cj9w;
         const 3;
         const 30;
 },
 GHC.Base.$w$csconcat3_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cja2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cja6; else goto cja5;
       cja6: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cja5: // global
           I64[Hp - 8] = go_sh2c_info;
           P64[Hp] = R2;
           _sh2a::P64 = R3;
           R3 = R4;
           R2 = _sh2a::P64;
           R1 = Hp - 6;
           call go_sh2c_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$csconcat3_info" {
     GHC.Base.$w$csconcat3_info:
         const GHC.Base.$w$csconcat3_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.682220328 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_$csconcat_closure" {
     GHC.Base.$fSemigroup(->)_$csconcat_closure:
         const GHC.Base.$fSemigroup(->)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(->)_$csconcat_entry() //  [R2, R3]
         { []
         }
     {offset
       cjaJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjaK; else goto cjaL;
       cjaK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(->)_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cjaL: // global
           I64[Sp - 16] = block_cjaG_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ujaP; else goto cjaH;
       ujaP: // global
           call _cjaG(R1) args: 0, res: 0, upd: 0;
       cjaH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(->)_$csconcat_info" {
     GHC.Base.$fSemigroup(->)_$csconcat_info:
         const GHC.Base.$fSemigroup(->)_$csconcat_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cjaG() //  [R1]
         { []
         }
     {offset
       cjaG: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat3_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjaG_info" {
     block_cjaG_info:
         const _cjaG;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.690489844 UTC

[section ""data" . GHC.Base.$w$csconcat_closure" {
     GHC.Base.$w$csconcat_closure:
         const GHC.Base.$w$csconcat_info;
 },
 sat_sh2L_entry() //  [R1]
         { []
         }
     {offset
       cjbq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjbr; else goto cjbs;
       cjbr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjbs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh2L_info" {
     sat_sh2L_info:
         const sat_sh2L_entry;
         const 3;
         const 15;
 },
 sat_sh2K_entry() //  [R1]
         { []
         }
     {offset
       cjbx: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjby; else goto cjbz;
       cjby: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjbz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh2K_info" {
     sat_sh2K_info:
         const sat_sh2K_entry;
         const 3;
         const 15;
 },
 $wgo_sh2x_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cjbE: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cjbF; else goto cjbG;
       cjbF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjbG: // global
           I64[Sp - 48] = block_cjb9_info;
           _sh2x::P64 = R1;
           _sh2s::P64 = P64[R1 + 5];
           _sh2t::P64 = P64[R1 + 13];
           R1 = R4;
           P64[Sp - 40] = _sh2s::P64;
           P64[Sp - 32] = _sh2t::P64;
           P64[Sp - 24] = _sh2x::P64;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ujbP; else goto cjba;
       ujbP: // global
           call _cjb9(R1) args: 0, res: 0, upd: 0;
       cjba: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . $wgo_sh2x_info" {
     $wgo_sh2x_info:
         const $wgo_sh2x_entry;
         const 2;
         const 11;
         const 12884901911;
 },
 _cjb9() //  [R1]
         { []
         }
     {offset
       cjb9: // global
           if (R1 & 7 == 1) goto cjbB; else goto cjbC;
       cjbB: // global
           R2 = P64[Sp + 40];
           R1 = P64[Sp + 32];
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cjbC: // global
           I64[Sp - 8] = block_cjbf_info;
           _sh2D::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sh2D::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujbO; else goto cjbg;
       ujbO: // global
           call _cjbf(R1) args: 0, res: 0, upd: 0;
       cjbg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjb9_info" {
     block_cjb9_info:
         const _cjb9;
         const 5;
         const 30;
 },
 _cjbf() //  [R1]
         { []
         }
     {offset
       cjbf: // global
           _sh2D::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cjbk_info;
           R4 = _sh2D::P64;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 32];
           Sp = Sp + 8;
           call $wgo_sh2x_entry(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjbf_info" {
     block_cjbf_info:
         const _cjbf;
         const 6;
         const 30;
 },
 _cjbk() //  [R1, R2]
         { []
         }
     {offset
       cjbk: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cjbN; else goto cjbM;
       cjbN: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cjbM: // global
           I64[Hp - 72] = sat_sh2L_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 40];
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sh2K_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = R1;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjbk_info" {
     block_cjbk_info:
         const _cjbk;
         const 261;
         const 30;
 },
 GHC.Base.$w$csconcat_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cjbQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cjbU; else goto cjbT;
       cjbU: // global
           HpAlloc = 24;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjbT: // global
           I64[Hp - 16] = $wgo_sh2x_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           _sh2u::P64 = R4;
           R4 = R6;
           R3 = R5;
           R2 = _sh2u::P64;
           R1 = Hp - 13;
           call $wgo_sh2x_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$csconcat_info" {
     GHC.Base.$w$csconcat_info:
         const GHC.Base.$w$csconcat_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.706464552 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_$csconcat_closure" {
     GHC.Base.$fSemigroup(,)_$csconcat_closure:
         const GHC.Base.$fSemigroup(,)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(,)_$csconcat_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjcP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjd0; else goto cjd1;
       cjd0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_$csconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjd1: // global
           I64[Sp - 24] = block_cjcM_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujd8; else goto cjcN;
       ujd8: // global
           call _cjcM(R1) args: 0, res: 0, upd: 0;
       cjcN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,)_$csconcat_info" {
     GHC.Base.$fSemigroup(,)_$csconcat_info:
         const GHC.Base.$fSemigroup(,)_$csconcat_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjcM() //  [R1]
         { []
         }
     {offset
       cjcM: // global
           I64[Sp - 8] = block_cjcS_info;
           _sh2R::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sh2R::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujd7; else goto cjcT;
       ujd7: // global
           call _cjcS(R1) args: 0, res: 0, upd: 0;
       cjcT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjcM_info" {
     block_cjcM_info:
         const _cjcM;
         const 2;
         const 30;
 },
 _cjcS() //  [R1]
         { []
         }
     {offset
       cjcS: // global
           _sh2N::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cjcX_info;
           R6 = P64[Sp + 8];
           R5 = P64[R1 + 15];
           R4 = P64[R1 + 7];
           R3 = _sh2N::P64;
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Base.$w$csconcat_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjcS_info" {
     block_cjcS_info:
         const _cjcS;
         const 3;
         const 30;
 },
 _cjcX() //  [R1, R2]
         { []
         }
     {offset
       cjcX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cjd6; else goto cjd5;
       cjd6: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cjd5: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjcX_info" {
     block_cjcX_info:
         const _cjcX;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.716681621 UTC

[section ""data" . GHC.Base.$dmsconcat_closure" {
     GHC.Base.$dmsconcat_closure:
         const GHC.Base.$dmsconcat_info;
 },
 go_sh33_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cjdP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjdQ; else goto cjdR;
       cjdQ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cjdR: // global
           I64[Sp - 32] = block_cjdI_info;
           _sh33::P64 = R1;
           _sh2Y::P64 = P64[R1 + 6];
           R1 = R3;
           P64[Sp - 24] = _sh2Y::P64;
           P64[Sp - 16] = _sh33::P64;
           P64[Sp - 8] = R2;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uje1; else goto cjdJ;
       uje1: // global
           call _cjdI(R1) args: 0, res: 0, upd: 0;
       cjdJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_sh33_info" {
     go_sh33_info:
         const go_sh33_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 _cjdI() //  [R1]
         { []
         }
     {offset
       cjdI: // global
           _sh34::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cjdM; else goto cjdN;
       cjdM: // global
           R1 = _sh34::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cjdN: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cjdZ; else goto cjdY;
       cjdZ: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cjdY: // global
           _sh37::P64 = P64[R1 + 6];
           _sh38::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = _sh37::P64;
           P64[Hp] = _sh38::P64;
           R2 = P64[Sp + 8];
           I64[Sp + 8] = stg_ap_pp_info;
           P64[Sp + 16] = _sh34::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjdI_info" {
     block_cjdI_info:
         const _cjdI;
         const 3;
         const 30;
 },
 GHC.Base.$dmsconcat_entry() //  [R2, R3]
         { []
         }
     {offset
       cje2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cje3; else goto cje4;
       cje3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$dmsconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cje4: // global
           I64[Sp - 16] = block_cjdy_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uje8; else goto cjdz;
       uje8: // global
           call _cjdy(R1) args: 0, res: 0, upd: 0;
       cjdz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmsconcat_info" {
     GHC.Base.$dmsconcat_info:
         const GHC.Base.$dmsconcat_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cjdy() //  [R1]
         { []
         }
     {offset
       cjdy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cje7; else goto cje6;
       cje7: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cje6: // global
           _sh31::P64 = P64[R1 + 7];
           _sh32::P64 = P64[R1 + 15];
           I64[Hp - 8] = go_sh33_info;
           P64[Hp] = P64[Sp + 8];
           R3 = _sh32::P64;
           R2 = _sh31::P64;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call go_sh33_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjdy_info" {
     block_cjdy_info:
         const _cjdy;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.72644562 UTC

[section ""data" . GHC.Base.$dmstimes_closure" {
     GHC.Base.$dmstimes_closure:
         const GHC.Base.$dmstimes_info;
         const 0;
 },
 GHC.Base.$dmstimes_entry() //  [R2, R3]
         { []
         }
     {offset
       cjeE: // global
           _sh3b::P64 = R3;
           R3 = R2;
           R2 = _sh3b::P64;
           R1 = Data.Semigroup.Internal.stimesDefault_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmstimes_info" {
     GHC.Base.$dmstimes_info:
         const GHC.Base.$dmstimes_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const Si3a_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.730272834 UTC

[section ""data" . GHC.Base.$dmmappend_closure" {
     GHC.Base.$dmmappend_closure:
         const GHC.Base.$dmmappend_info;
 },
 GHC.Base.$dmmappend_entry() //  [R2]
         { []
         }
     {offset
       cjeR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cjeS; else goto cjeT;
       cjeS: // global
           R2 = R2;
           R1 = GHC.Base.$dmmappend_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjeT: // global
           I64[Sp - 8] = block_cjeP_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmmappend_info" {
     GHC.Base.$dmmappend_info:
         const GHC.Base.$dmmappend_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cjeP() //  [R1]
         { []
         }
     {offset
       cjeP: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.<>_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjeP_info" {
     block_cjeP_info:
         const _cjeP;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.736294892 UTC

[section ""data" . GHC.Base.$dm>>_closure" {
     GHC.Base.$dm>>_closure:
         const GHC.Base.$dm>>_info;
 },
 sat_sh3i_entry() //  [R1]
         { []
         }
     {offset
       cjff: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh3i_info" {
     sat_sh3i_info:
         const sat_sh3i_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 GHC.Base.$dm>>_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjfi: // global
           _sh3g::P64 = R4;
           _sh3f::P64 = R3;
           _sh3e::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cjfj; else goto cjfk;
       cjfk: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cjfm; else goto cjfl;
       cjfm: // global
           HpAlloc = 16;
           goto cjfj;
       cjfj: // global
           R4 = _sh3g::P64;
           R3 = _sh3f::P64;
           R2 = _sh3e::P64;
           R1 = GHC.Base.$dm>>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjfl: // global
           I64[Hp - 8] = sat_sh3i_info;
           P64[Hp] = _sh3g::P64;
           R2 = _sh3e::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = _sh3f::P64;
           P64[Sp - 8] = Hp - 7;
           Sp = Sp - 24;
           call GHC.Base.>>=_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dm>>_info" {
     GHC.Base.$dm>>_info:
         const GHC.Base.$dm>>_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.742036853 UTC

[section ""data" . GHC.Base.$dmreturn_closure" {
     GHC.Base.$dmreturn_closure:
         const GHC.Base.$dmreturn_info;
 },
 GHC.Base.$dmreturn_entry() //  [R2]
         { []
         }
     {offset
       cjfE: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cjfF; else goto cjfG;
       cjfF: // global
           R2 = R2;
           R1 = GHC.Base.$dmreturn_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjfG: // global
           I64[Sp - 8] = block_cjfC_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1Monad_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmreturn_info" {
     GHC.Base.$dmreturn_info:
         const GHC.Base.$dmreturn_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cjfC() //  [R1]
         { []
         }
     {offset
       cjfC: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.pure_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjfC_info" {
     block_cjfC_info:
         const _cjfC;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.746738168 UTC

[section ""data" . GHC.Base.$dmfail_closure" {
     GHC.Base.$dmfail_closure:
         const GHC.Base.$dmfail_info;
         const 0;
 },
 GHC.Base.$dmfail_entry() //  [R3]
         { []
         }
     {offset
       cjfX: // global
           R2 = R3;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmfail_info" {
     GHC.Base.$dmfail_info:
         const GHC.Base.$dmfail_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const Si3a_srt+72;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.750307739 UTC

[section ""data" . GHC.Base.$dmmzero_closure" {
     GHC.Base.$dmmzero_closure:
         const GHC.Base.$dmmzero_info;
 },
 GHC.Base.$dmmzero_entry() //  [R2]
         { []
         }
     {offset
       cjga: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cjgb; else goto cjgc;
       cjgb: // global
           R2 = R2;
           R1 = GHC.Base.$dmmzero_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjgc: // global
           I64[Sp - 8] = block_cjg8_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmmzero_info" {
     GHC.Base.$dmmzero_info:
         const GHC.Base.$dmmzero_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cjg8() //  [R1]
         { []
         }
     {offset
       cjg8: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.empty_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjg8_info" {
     block_cjg8_info:
         const _cjg8;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.755568316 UTC

[section ""data" . GHC.Base.$dmmplus_closure" {
     GHC.Base.$dmmplus_closure:
         const GHC.Base.$dmmplus_info;
 },
 GHC.Base.$dmmplus_entry() //  [R2]
         { []
         }
     {offset
       cjgv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cjgw; else goto cjgx;
       cjgw: // global
           R2 = R2;
           R1 = GHC.Base.$dmmplus_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjgx: // global
           I64[Sp - 8] = block_cjgt_info;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$p1MonadPlus_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$dmmplus_info" {
     GHC.Base.$dmmplus_info:
         const GHC.Base.$dmmplus_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cjgt() //  [R1]
         { []
         }
     {offset
       cjgt: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Base.<|>_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjgt_info" {
     block_cjgt_info:
         const _cjgt;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.762039214 UTC

[section ""data" . GHC.Base.$fEqMaybe_$c==_closure" {
     GHC.Base.$fEqMaybe_$c==_closure:
         const GHC.Base.$fEqMaybe_$c==_info;
 },
 GHC.Base.$fEqMaybe_$c==_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjgV: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cjgW; else goto cjgX;
       cjgW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqMaybe_$c==_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjgX: // global
           I64[Sp - 24] = block_cjgO_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujhy; else goto cjgP;
       ujhy: // global
           call _cjgO(R1) args: 0, res: 0, upd: 0;
       cjgP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fEqMaybe_$c==_info" {
     GHC.Base.$fEqMaybe_$c==_info:
         const GHC.Base.$fEqMaybe_$c==_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjgO() //  [R1]
         { []
         }
     {offset
       cjgO: // global
           _sh3t::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cjgS; else goto cjgT;
       cjgS: // global
           I64[Sp + 16] = block_cjh0_info;
           R1 = _sh3t::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ujhw; else goto cjh2;
       ujhw: // global
           call _cjh0(R1) args: 0, res: 0, upd: 0;
       cjh2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cjgT: // global
           I64[Sp] = block_cjhf_info;
           _sh3x::P64 = P64[R1 + 6];
           R1 = _sh3t::P64;
           P64[Sp + 16] = _sh3x::P64;
           if (R1 & 7 != 0) goto ujhx; else goto cjhh;
       ujhx: // global
           call _cjhf(R1) args: 0, res: 0, upd: 0;
       cjhh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjgO_info" {
     block_cjgO_info:
         const _cjgO;
         const 2;
         const 30;
 },
 _cjh0() //  [R1]
         { []
         }
     {offset
       cjh0: // global
           if (R1 & 7 == 1) goto cjh8; else goto ujhv;
       cjh8: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ujhv: // global
           Sp = Sp + 8;
           call _cjhn() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cjh0_info" {
     block_cjh0_info:
         const _cjh0;
         const 0;
         const 30;
 },
 _cjhf() //  [R1]
         { []
         }
     {offset
       cjhf: // global
           if (R1 & 7 == 1) goto ujhu; else goto cjhr;
       ujhu: // global
           Sp = Sp + 24;
           call _cjhn() args: 0, res: 0, upd: 0;
       cjhr: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.Classes.==_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjhf_info" {
     block_cjhf_info:
         const _cjhf;
         const 2;
         const 30;
 },
 _cjhn() //  []
         { []
         }
     {offset
       cjhn: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.773855207 UTC

[section ""data" . GHC.Base.$fEqMaybe_$c/=_closure" {
     GHC.Base.$fEqMaybe_$c/=_closure:
         const GHC.Base.$fEqMaybe_$c/=_info;
 },
 GHC.Base.$fEqMaybe_$c/=_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjil: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjim; else goto cjin;
       cjim: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqMaybe_$c/=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjin: // global
           I64[Sp - 24] = block_cjie_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujjd; else goto cjif;
       ujjd: // global
           call _cjie(R1) args: 0, res: 0, upd: 0;
       cjif: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fEqMaybe_$c/=_info" {
     GHC.Base.$fEqMaybe_$c/=_info:
         const GHC.Base.$fEqMaybe_$c/=_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjie() //  [R1]
         { []
         }
     {offset
       cjie: // global
           _sh3C::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cjii; else goto cjij;
       cjii: // global
           I64[Sp + 16] = block_cjiq_info;
           R1 = _sh3C::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ujjb; else goto cjis;
       ujjb: // global
           call _cjiq(R1) args: 0, res: 0, upd: 0;
       cjis: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cjij: // global
           I64[Sp] = block_cjiF_info;
           _sh3G::P64 = P64[R1 + 6];
           R1 = _sh3C::P64;
           P64[Sp + 16] = _sh3G::P64;
           if (R1 & 7 != 0) goto ujjc; else goto cjiH;
       ujjc: // global
           call _cjiF(R1) args: 0, res: 0, upd: 0;
       cjiH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjie_info" {
     block_cjie_info:
         const _cjie;
         const 2;
         const 30;
 },
 _cjiq() //  [R1]
         { []
         }
     {offset
       cjiq: // global
           if (R1 & 7 == 1) goto ujj9; else goto ujja;
       ujj9: // global
           Sp = Sp + 8;
           call _cjj2() args: 0, res: 0, upd: 0;
       ujja: // global
           Sp = Sp + 8;
           call _cjiY() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cjiq_info" {
     block_cjiq_info:
         const _cjiq;
         const 0;
         const 30;
 },
 _cjiF() //  [R1]
         { []
         }
     {offset
       cjiF: // global
           if (R1 & 7 == 1) goto ujj6; else goto cjiS;
       ujj6: // global
           Sp = Sp + 24;
           call _cjiY() args: 0, res: 0, upd: 0;
       cjiS: // global
           _sh3G::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cjiQ_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _sh3G::P64;
           P64[Sp + 8] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjiF_info" {
     block_cjiF_info:
         const _cjiF;
         const 2;
         const 30;
 },
 _cjiQ() //  [R1]
         { []
         }
     {offset
       cjiQ: // global
           if (R1 & 7 == 1) goto ujj7; else goto ujj8;
       ujj7: // global
           Sp = Sp + 8;
           call _cjiY() args: 0, res: 0, upd: 0;
       ujj8: // global
           Sp = Sp + 8;
           call _cjj2() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cjiQ_info" {
     block_cjiQ_info:
         const _cjiQ;
         const 0;
         const 30;
 },
 _cjiY() //  []
         { []
         }
     {offset
       cjiY: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjj2() //  []
         { []
         }
     {offset
       cjj2: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.786786649 UTC

[section ""data" . GHC.Base.$fEqMaybe_closure" {
     GHC.Base.$fEqMaybe_closure:
         const GHC.Base.$fEqMaybe_info;
 },
 sat_sh3M_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cjk8: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c/=_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh3M_info" {
     sat_sh3M_info:
         const sat_sh3M_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sh3L_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cjkg: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqMaybe_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh3L_info" {
     sat_sh3L_info:
         const sat_sh3L_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 GHC.Base.$fEqMaybe_entry() //  [R2]
         { []
         }
     {offset
       cjkk: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cjko; else goto cjkn;
       cjko: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.Base.$fEqMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjkn: // global
           I64[Hp - 48] = sat_sh3M_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sh3L_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fEqMaybe_info" {
     GHC.Base.$fEqMaybe_info:
         const GHC.Base.$fEqMaybe_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.793943704 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$cp1Ord_closure" {
     GHC.Base.$fOrdMaybe_$cp1Ord_closure:
         const GHC.Base.$fOrdMaybe_$cp1Ord_info;
 },
 sat_sh3O_entry() //  [R1]
         { []
         }
     {offset
       cjkN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjkO; else goto cjkP;
       cjkO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjkP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh3O_info" {
     sat_sh3O_info:
         const sat_sh3O_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fOrdMaybe_$cp1Ord_entry() //  [R2]
         { []
         }
     {offset
       cjkQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cjkU; else goto cjkT;
       cjkU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjkT: // global
           I64[Hp - 16] = sat_sh3O_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fEqMaybe_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdMaybe_$cp1Ord_info" {
     GHC.Base.$fOrdMaybe_$cp1Ord_info:
         const GHC.Base.$fOrdMaybe_$cp1Ord_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.800300325 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$ccompare_closure" {
     GHC.Base.$fOrdMaybe_$ccompare_closure:
         const GHC.Base.$fOrdMaybe_$ccompare_info;
 },
 GHC.Base.$fOrdMaybe_$ccompare_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjlg: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cjlh; else goto cjli;
       cjlh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$ccompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjli: // global
           I64[Sp - 24] = block_cjl9_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujlR; else goto cjla;
       ujlR: // global
           call _cjl9(R1) args: 0, res: 0, upd: 0;
       cjla: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdMaybe_$ccompare_info" {
     GHC.Base.$fOrdMaybe_$ccompare_info:
         const GHC.Base.$fOrdMaybe_$ccompare_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjl9() //  [R1]
         { []
         }
     {offset
       cjl9: // global
           _sh3R::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cjld; else goto cjle;
       cjld: // global
           I64[Sp + 16] = block_cjll_info;
           R1 = _sh3R::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ujlP; else goto cjln;
       ujlP: // global
           call _cjll(R1) args: 0, res: 0, upd: 0;
       cjln: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cjle: // global
           I64[Sp] = block_cjlA_info;
           _sh3V::P64 = P64[R1 + 6];
           R1 = _sh3R::P64;
           P64[Sp + 16] = _sh3V::P64;
           if (R1 & 7 != 0) goto ujlQ; else goto cjlC;
       ujlQ: // global
           call _cjlA(R1) args: 0, res: 0, upd: 0;
       cjlC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjl9_info" {
     block_cjl9_info:
         const _cjl9;
         const 2;
         const 30;
 },
 _cjll() //  [R1]
         { []
         }
     {offset
       cjll: // global
           if (R1 & 7 == 1) goto cjlt; else goto cjlx;
       cjlt: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cjlx: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjll_info" {
     block_cjll_info:
         const _cjll;
         const 0;
         const 30;
 },
 _cjlA() //  [R1]
         { []
         }
     {offset
       cjlA: // global
           if (R1 & 7 == 1) goto cjlI; else goto cjlM;
       cjlI: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cjlM: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.Classes.compare_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjlA_info" {
     block_cjlA_info:
         const _cjlA;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.811416139 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$c<_closure" {
     GHC.Base.$fOrdMaybe_$c<_closure:
         const GHC.Base.$fOrdMaybe_$c<_info;
 },
 GHC.Base.$fOrdMaybe_$c<_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjmC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cjmD; else goto cjmE;
       cjmD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$c<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjmE: // global
           I64[Sp - 24] = block_cjmv_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujnf; else goto cjmw;
       ujnf: // global
           call _cjmv(R1) args: 0, res: 0, upd: 0;
       cjmw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdMaybe_$c<_info" {
     GHC.Base.$fOrdMaybe_$c<_info:
         const GHC.Base.$fOrdMaybe_$c<_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjmv() //  [R1]
         { []
         }
     {offset
       cjmv: // global
           _sh40::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cjmz; else goto cjmA;
       cjmz: // global
           I64[Sp + 16] = block_cjmH_info;
           R1 = _sh40::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ujnd; else goto cjmJ;
       ujnd: // global
           call _cjmH(R1) args: 0, res: 0, upd: 0;
       cjmJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cjmA: // global
           I64[Sp] = block_cjmW_info;
           _sh44::P64 = P64[R1 + 6];
           R1 = _sh40::P64;
           P64[Sp + 16] = _sh44::P64;
           if (R1 & 7 != 0) goto ujne; else goto cjmY;
       ujne: // global
           call _cjmW(R1) args: 0, res: 0, upd: 0;
       cjmY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjmv_info" {
     block_cjmv_info:
         const _cjmv;
         const 2;
         const 30;
 },
 _cjmH() //  [R1]
         { []
         }
     {offset
       cjmH: // global
           if (R1 & 7 == 1) goto ujnc; else goto cjmT;
       ujnc: // global
           Sp = Sp + 8;
           call _cjn4() args: 0, res: 0, upd: 0;
       cjmT: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjmH_info" {
     block_cjmH_info:
         const _cjmH;
         const 0;
         const 30;
 },
 _cjmW() //  [R1]
         { []
         }
     {offset
       cjmW: // global
           if (R1 & 7 == 1) goto ujnb; else goto cjn8;
       ujnb: // global
           Sp = Sp + 24;
           call _cjn4() args: 0, res: 0, upd: 0;
       cjn8: // global
           R2 = P64[Sp + 8];
           I64[Sp] = stg_ap_pp_info;
           P64[Sp + 8] = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 6];
           call GHC.Classes.<_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjmW_info" {
     block_cjmW_info:
         const _cjmW;
         const 2;
         const 30;
 },
 _cjn4() //  []
         { []
         }
     {offset
       cjn4: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.822736371 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$c<=_closure" {
     GHC.Base.$fOrdMaybe_$c<=_closure:
         const GHC.Base.$fOrdMaybe_$c<=_info;
 },
 GHC.Base.$fOrdMaybe_$c<=_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjo2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjo3; else goto cjo4;
       cjo3: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$c<=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjo4: // global
           I64[Sp - 24] = block_cjnV_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujoU; else goto cjnW;
       ujoU: // global
           call _cjnV(R1) args: 0, res: 0, upd: 0;
       cjnW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdMaybe_$c<=_info" {
     GHC.Base.$fOrdMaybe_$c<=_info:
         const GHC.Base.$fOrdMaybe_$c<=_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjnV() //  [R1]
         { []
         }
     {offset
       cjnV: // global
           _sh48::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cjnZ; else goto cjo0;
       cjnZ: // global
           I64[Sp + 16] = block_cjo7_info;
           R1 = _sh48::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ujoS; else goto cjo9;
       ujoS: // global
           call _cjo7(R1) args: 0, res: 0, upd: 0;
       cjo9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cjo0: // global
           I64[Sp] = block_cjom_info;
           _sh4d::P64 = P64[R1 + 6];
           R1 = _sh48::P64;
           P64[Sp + 16] = _sh4d::P64;
           if (R1 & 7 != 0) goto ujoT; else goto cjoo;
       ujoT: // global
           call _cjom(R1) args: 0, res: 0, upd: 0;
       cjoo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjnV_info" {
     block_cjnV_info:
         const _cjnV;
         const 2;
         const 30;
 },
 _cjo7() //  [R1]
         { []
         }
     {offset
       cjo7: // global
           if (R1 & 7 == 1) goto ujoQ; else goto ujoR;
       ujoQ: // global
           Sp = Sp + 8;
           call _cjoF() args: 0, res: 0, upd: 0;
       ujoR: // global
           Sp = Sp + 8;
           call _cjoJ() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cjo7_info" {
     block_cjo7_info:
         const _cjo7;
         const 0;
         const 30;
 },
 _cjom() //  [R1]
         { []
         }
     {offset
       cjom: // global
           if (R1 & 7 == 1) goto ujoN; else goto cjoz;
       ujoN: // global
           Sp = Sp + 24;
           call _cjoF() args: 0, res: 0, upd: 0;
       cjoz: // global
           _sh4d::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cjox_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _sh4d::P64;
           P64[Sp + 8] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjom_info" {
     block_cjom_info:
         const _cjom;
         const 2;
         const 30;
 },
 _cjox() //  [R1]
         { []
         }
     {offset
       cjox: // global
           if (R1 & 7 == 1) goto ujoO; else goto ujoP;
       ujoO: // global
           Sp = Sp + 8;
           call _cjoF() args: 0, res: 0, upd: 0;
       ujoP: // global
           Sp = Sp + 8;
           call _cjoJ() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cjox_info" {
     block_cjox_info:
         const _cjox;
         const 0;
         const 30;
 },
 _cjoF() //  []
         { []
         }
     {offset
       cjoF: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjoJ() //  []
         { []
         }
     {offset
       cjoJ: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.835899946 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$cmax_closure" {
     GHC.Base.$fOrdMaybe_$cmax_closure:
         const GHC.Base.$fOrdMaybe_$cmax_info;
 },
 GHC.Base.$fOrdMaybe_$cmax_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjpR: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cjpS; else goto cjpT;
       cjpS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$cmax_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjpT: // global
           I64[Sp - 24] = block_cjpK_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujqs; else goto cjpL;
       ujqs: // global
           call _cjpK(R1) args: 0, res: 0, upd: 0;
       cjpL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdMaybe_$cmax_info" {
     GHC.Base.$fOrdMaybe_$cmax_info:
         const GHC.Base.$fOrdMaybe_$cmax_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjpK() //  [R1]
         { []
         }
     {offset
       cjpK: // global
           _sh4i::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cjpO; else goto cjpP;
       cjpO: // global
           R1 = _sh4i::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cjpP: // global
           I64[Sp - 8] = block_cjpZ_info;
           _sh4k::P64 = R1;
           _sh4l::P64 = P64[R1 + 6];
           R1 = _sh4i::P64;
           P64[Sp] = _sh4l::P64;
           P64[Sp + 16] = _sh4k::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujqr; else goto cjq1;
       ujqr: // global
           call _cjpZ(R1) args: 0, res: 0, upd: 0;
       cjq1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjpK_info" {
     block_cjpK_info:
         const _cjpK;
         const 2;
         const 30;
 },
 _cjpZ() //  [R1]
         { []
         }
     {offset
       cjpZ: // global
           if (R1 & 7 == 1) goto ujqp; else goto cjqc;
       ujqp: // global
           Sp = Sp + 24;
           call _cjqi() args: 0, res: 0, upd: 0;
       cjqc: // global
           _sh4l::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cjqa_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _sh4l::P64;
           P64[Sp] = P64[R1 + 6];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjpZ_info" {
     block_cjpZ_info:
         const _cjpZ;
         const 3;
         const 30;
 },
 _cjqa() //  [R1]
         { []
         }
     {offset
       cjqa: // global
           if (R1 & 7 == 1) goto ujqq; else goto cjqm;
       ujqq: // global
           Sp = Sp + 16;
           call _cjqi() args: 0, res: 0, upd: 0;
       cjqm: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjqa_info" {
     block_cjqa_info:
         const _cjqa;
         const 2;
         const 30;
 },
 _cjqi() //  []
         { []
         }
     {offset
       cjqi: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.847484426 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$cmin_closure" {
     GHC.Base.$fOrdMaybe_$cmin_closure:
         const GHC.Base.$fOrdMaybe_$cmin_info;
 },
 GHC.Base.$fOrdMaybe_$cmin_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjrf: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cjrg; else goto cjrh;
       cjrg: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$cmin_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjrh: // global
           I64[Sp - 24] = block_cjr8_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujrV; else goto cjr9;
       ujrV: // global
           call _cjr8(R1) args: 0, res: 0, upd: 0;
       cjr9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdMaybe_$cmin_info" {
     GHC.Base.$fOrdMaybe_$cmin_info:
         const GHC.Base.$fOrdMaybe_$cmin_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjr8() //  [R1]
         { []
         }
     {offset
       cjr8: // global
           _sh4q::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cjrc; else goto cjrd;
       cjrc: // global
           I64[Sp + 16] = block_cjrk_info;
           R1 = _sh4q::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ujrT; else goto cjrm;
       ujrT: // global
           call _cjrk() args: 0, res: 0, upd: 0;
       cjrm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cjrd: // global
           I64[Sp - 8] = block_cjrt_info;
           _sh4s::P64 = R1;
           _sh4u::P64 = P64[R1 + 6];
           R1 = _sh4q::P64;
           P64[Sp] = _sh4u::P64;
           P64[Sp + 16] = _sh4s::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujrU; else goto cjrv;
       ujrU: // global
           call _cjrt(R1) args: 0, res: 0, upd: 0;
       cjrv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjr8_info" {
     block_cjr8_info:
         const _cjr8;
         const 2;
         const 30;
 },
 _cjrk() //  []
         { []
         }
     {offset
       cjrk: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjrk_info" {
     block_cjrk_info:
         const _cjrk;
         const 0;
         const 30;
 },
 _cjrt() //  [R1]
         { []
         }
     {offset
       cjrt: // global
           if (R1 & 7 == 1) goto cjrB; else goto cjrG;
       cjrB: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cjrG: // global
           _sh4u::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cjrE_info;
           R2 = P64[Sp + 16];
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = _sh4u::P64;
           P64[Sp] = P64[R1 + 6];
           P64[Sp + 16] = R1;
           Sp = Sp - 16;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjrt_info" {
     block_cjrt_info:
         const _cjrt;
         const 3;
         const 30;
 },
 _cjrE() //  [R1]
         { []
         }
     {offset
       cjrE: // global
           if (R1 & 7 == 1) goto cjrM; else goto cjrQ;
       cjrM: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cjrQ: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjrE_info" {
     block_cjrE_info:
         const _cjrE;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.86055475 UTC

[section ""data" . GHC.Base.$fOrdMaybe_$c>=_closure" {
     GHC.Base.$fOrdMaybe_$c>=_closure:
         const GHC.Base.$fOrdMaybe_$c>=_info;
 },
 GHC.Base.$fOrdMaybe_$c>=_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjsJ: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjsK; else goto cjsL;
       cjsK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_$c>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjsL: // global
           I64[Sp - 24] = block_cjsC_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujtB; else goto cjsD;
       ujtB: // global
           call _cjsC(R1) args: 0, res: 0, upd: 0;
       cjsD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdMaybe_$c>=_info" {
     GHC.Base.$fOrdMaybe_$c>=_info:
         const GHC.Base.$fOrdMaybe_$c>=_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjsC() //  [R1]
         { []
         }
     {offset
       cjsC: // global
           _sh4A::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cjsG; else goto cjsH;
       cjsG: // global
           I64[Sp + 16] = block_cjsO_info;
           R1 = _sh4A::P64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto ujtz; else goto cjsQ;
       ujtz: // global
           call _cjsO(R1) args: 0, res: 0, upd: 0;
       cjsQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cjsH: // global
           I64[Sp] = block_cjt3_info;
           _sh4E::P64 = P64[R1 + 6];
           R1 = _sh4A::P64;
           P64[Sp + 16] = _sh4E::P64;
           if (R1 & 7 != 0) goto ujtA; else goto cjt5;
       ujtA: // global
           call _cjt3(R1) args: 0, res: 0, upd: 0;
       cjt5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjsC_info" {
     block_cjsC_info:
         const _cjsC;
         const 2;
         const 30;
 },
 _cjsO() //  [R1]
         { []
         }
     {offset
       cjsO: // global
           if (R1 & 7 == 1) goto ujtx; else goto ujty;
       ujtx: // global
           Sp = Sp + 8;
           call _cjtm() args: 0, res: 0, upd: 0;
       ujty: // global
           Sp = Sp + 8;
           call _cjtq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cjsO_info" {
     block_cjsO_info:
         const _cjsO;
         const 0;
         const 30;
 },
 _cjt3() //  [R1]
         { []
         }
     {offset
       cjt3: // global
           if (R1 & 7 == 1) goto ujtu; else goto cjtg;
       ujtu: // global
           Sp = Sp + 24;
           call _cjtm() args: 0, res: 0, upd: 0;
       cjtg: // global
           _sh4E::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cjte_info;
           R2 = P64[Sp + 8];
           I64[Sp - 8] = stg_ap_pp_info;
           P64[Sp] = _sh4E::P64;
           P64[Sp + 8] = P64[R1 + 6];
           Sp = Sp - 8;
           call GHC.Classes.<_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjt3_info" {
     block_cjt3_info:
         const _cjt3;
         const 2;
         const 30;
 },
 _cjte() //  [R1]
         { []
         }
     {offset
       cjte: // global
           if (R1 & 7 == 1) goto ujtv; else goto ujtw;
       ujtv: // global
           Sp = Sp + 8;
           call _cjtm() args: 0, res: 0, upd: 0;
       ujtw: // global
           Sp = Sp + 8;
           call _cjtq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cjte_info" {
     block_cjte_info:
         const _cjte;
         const 0;
         const 30;
 },
 _cjtm() //  []
         { []
         }
     {offset
       cjtm: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjtq() //  []
         { []
         }
     {offset
       cjtq: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.874826472 UTC

[section ""data" . GHC.Base.$fOrdMaybe_closure" {
     GHC.Base.$fOrdMaybe_closure:
         const GHC.Base.$fOrdMaybe_info;
 },
 sat_sh4S_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cjuw: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmin_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh4S_info" {
     sat_sh4S_info:
         const sat_sh4S_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sh4R_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cjuE: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$cmax_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh4R_info" {
     sat_sh4R_info:
         const sat_sh4R_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sh4Q_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cjuM: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c>=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh4Q_info" {
     sat_sh4Q_info:
         const sat_sh4Q_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sh4P_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cjuU: // global
           R4 = R2;
           R3 = R3;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh4P_info" {
     sat_sh4P_info:
         const sat_sh4P_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sh4M_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cjv2: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<=_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh4M_info" {
     sat_sh4M_info:
         const sat_sh4M_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sh4L_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cjva: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh4L_info" {
     sat_sh4L_info:
         const sat_sh4L_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sh4K_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cjvi: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdMaybe_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh4K_info" {
     sat_sh4K_info:
         const sat_sh4K_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sh4J_entry() //  [R1]
         { []
         }
     {offset
       cjvp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjvq; else goto cjvr;
       cjvq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjvr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fOrdMaybe_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh4J_info" {
     sat_sh4J_info:
         const sat_sh4J_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fOrdMaybe_entry() //  [R2]
         { []
         }
     {offset
       cjvt: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cjvx; else goto cjvw;
       cjvx: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = GHC.Base.$fOrdMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjvw: // global
           I64[Hp - 200] = sat_sh4S_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_sh4R_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_sh4Q_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sh4P_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sh4M_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sh4L_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sh4K_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sh4J_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdMaybe_info" {
     GHC.Base.$fOrdMaybe_info:
         const GHC.Base.$fOrdMaybe_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.892604311 UTC

[section ""data" . GHC.Base.$fEqNonEmpty_$c/=_closure" {
     GHC.Base.$fEqNonEmpty_$c/=_closure:
         const GHC.Base.$fEqNonEmpty_$c/=_info;
 },
 GHC.Base.$fEqNonEmpty_$c/=_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjwr: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cjwv; else goto cjww;
       cjwv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqNonEmpty_$c/=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjww: // global
           I64[Sp - 24] = block_cjwo_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujx4; else goto cjwp;
       ujx4: // global
           call _cjwo(R1) args: 0, res: 0, upd: 0;
       cjwp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fEqNonEmpty_$c/=_info" {
     GHC.Base.$fEqNonEmpty_$c/=_info:
         const GHC.Base.$fEqNonEmpty_$c/=_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjwo() //  [R1]
         { []
         }
     {offset
       cjwo: // global
           I64[Sp - 8] = block_cjwu_info;
           _sh4X::P64 = P64[R1 + 7];
           _sh4Y::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sh4Y::P64;
           P64[Sp + 16] = _sh4X::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujx3; else goto cjwy;
       ujx3: // global
           call _cjwu(R1) args: 0, res: 0, upd: 0;
       cjwy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjwo_info" {
     block_cjwo_info:
         const _cjwo;
         const 2;
         const 30;
 },
 _cjwu() //  [R1]
         { []
         }
     {offset
       cjwu: // global
           I64[Sp] = block_cjwC_info;
           R2 = P64[Sp + 16];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[R1 + 7];
           P64[Sp + 24] = P64[R1 + 15];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjwu_info" {
     block_cjwu_info:
         const _cjwu;
         const 3;
         const 30;
 },
 _cjwC() //  [R1]
         { []
         }
     {offset
       cjwC: // global
           if (R1 & 7 == 1) goto ujx1; else goto cjwO;
       ujx1: // global
           Sp = Sp + 32;
           call _cjwU() args: 0, res: 0, upd: 0;
       cjwO: // global
           _sh51::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cjwM_info;
           R4 = _sh51::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 24;
           call GHC.Classes.$fEq[]_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjwC_info" {
     block_cjwC_info:
         const _cjwC;
         const 3;
         const 30;
 },
 _cjwM() //  [R1]
         { []
         }
     {offset
       cjwM: // global
           if (R1 & 7 == 1) goto ujx2; else goto cjwY;
       ujx2: // global
           Sp = Sp + 8;
           call _cjwU() args: 0, res: 0, upd: 0;
       cjwY: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjwM_info" {
     block_cjwM_info:
         const _cjwM;
         const 0;
         const 30;
 },
 _cjwU() //  []
         { []
         }
     {offset
       cjwU: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.904003647 UTC

[section ""data" . GHC.Base.$w$c==_closure" {
     GHC.Base.$w$c==_closure:
         const GHC.Base.$w$c==_info;
 },
 GHC.Base.$w$c==_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cjxS: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cjxT; else goto cjxU;
       cjxT: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c==_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjxU: // global
           I64[Sp - 32] = block_cjxM_info;
           _sh54::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _sh54::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$c==_info" {
     GHC.Base.$w$c==_info:
         const GHC.Base.$w$c==_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cjxM() //  [R1]
         { []
         }
     {offset
       cjxM: // global
           if (R1 & 7 == 1) goto cjxP; else goto cjxQ;
       cjxP: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cjxQ: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Classes.$fEq[]_$c==_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjxM_info" {
     block_cjxM_info:
         const _cjxM;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.910656342 UTC

[section ""data" . GHC.Base.$fEqNonEmpty_$c==_closure" {
     GHC.Base.$fEqNonEmpty_$c==_closure:
         const GHC.Base.$fEqNonEmpty_$c==_info;
 },
 GHC.Base.$fEqNonEmpty_$c==_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjym: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjyq; else goto cjyr;
       cjyq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fEqNonEmpty_$c==_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjyr: // global
           I64[Sp - 24] = block_cjyj_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujyz; else goto cjyk;
       ujyz: // global
           call _cjyj(R1) args: 0, res: 0, upd: 0;
       cjyk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fEqNonEmpty_$c==_info" {
     GHC.Base.$fEqNonEmpty_$c==_info:
         const GHC.Base.$fEqNonEmpty_$c==_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjyj() //  [R1]
         { []
         }
     {offset
       cjyj: // global
           I64[Sp - 8] = block_cjyp_info;
           _sh5e::P64 = P64[R1 + 7];
           _sh5f::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sh5f::P64;
           P64[Sp + 16] = _sh5e::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujyy; else goto cjyt;
       ujyy: // global
           call _cjyp(R1) args: 0, res: 0, upd: 0;
       cjyt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjyj_info" {
     block_cjyj_info:
         const _cjyj;
         const 2;
         const 30;
 },
 _cjyp() //  [R1]
         { []
         }
     {offset
       cjyp: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c==_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjyp_info" {
     block_cjyp_info:
         const _cjyp;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.918515659 UTC

[section ""data" . GHC.Base.$fEqNonEmpty_closure" {
     GHC.Base.$fEqNonEmpty_closure:
         const GHC.Base.$fEqNonEmpty_info;
 },
 sat_sh5l_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cjyY: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqNonEmpty_$c/=_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh5l_info" {
     sat_sh5l_info:
         const sat_sh5l_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sh5k_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cjz6: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fEqNonEmpty_$c==_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh5k_info" {
     sat_sh5k_info:
         const sat_sh5k_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 GHC.Base.$fEqNonEmpty_entry() //  [R2]
         { []
         }
     {offset
       cjza: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cjze; else goto cjzd;
       cjze: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = GHC.Base.$fEqNonEmpty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjzd: // global
           I64[Hp - 48] = sat_sh5l_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_sh5k_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.C:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fEqNonEmpty_info" {
     GHC.Base.$fEqNonEmpty_info:
         const GHC.Base.$fEqNonEmpty_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.926560293 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$cp1Ord_closure" {
     GHC.Base.$fOrdNonEmpty_$cp1Ord_closure:
         const GHC.Base.$fOrdNonEmpty_$cp1Ord_info;
 },
 sat_sh5n_entry() //  [R1]
         { []
         }
     {offset
       cjzD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjzE; else goto cjzF;
       cjzE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjzF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Classes.$p1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh5n_info" {
     sat_sh5n_info:
         const sat_sh5n_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fOrdNonEmpty_$cp1Ord_entry() //  [R2]
         { []
         }
     {offset
       cjzG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cjzK; else goto cjzJ;
       cjzK: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$cp1Ord_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjzJ: // global
           I64[Hp - 16] = sat_sh5n_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fEqNonEmpty_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdNonEmpty_$cp1Ord_info" {
     GHC.Base.$fOrdNonEmpty_$cp1Ord_info:
         const GHC.Base.$fOrdNonEmpty_$cp1Ord_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.932560479 UTC

[section ""data" . GHC.Base.$w$ccompare_closure" {
     GHC.Base.$w$ccompare_closure:
         const GHC.Base.$w$ccompare_info;
 },
 GHC.Base.$w$ccompare_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cjA6: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cjA7; else goto cjA8;
       cjA7: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$ccompare_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjA8: // global
           I64[Sp - 32] = block_cjzZ_info;
           _sh5o::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _sh5o::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$ccompare_info" {
     GHC.Base.$w$ccompare_info:
         const GHC.Base.$w$ccompare_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cjzZ() //  [R1]
         { []
         }
     {offset
       cjzZ: // global
           _cjA5::P64 = R1 & 7;
           if (_cjA5::P64 < 3) goto ujAi; else goto cjA4;
       ujAi: // global
           if (_cjA5::P64 < 2) goto cjA2; else goto cjA3;
       cjA2: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cjA3: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
       cjA4: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjzZ_info" {
     block_cjzZ_info:
         const _cjzZ;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.939130123 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$ccompare_closure" {
     GHC.Base.$fOrdNonEmpty_$ccompare_closure:
         const GHC.Base.$fOrdNonEmpty_$ccompare_info;
 },
 GHC.Base.$fOrdNonEmpty_$ccompare_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjAF: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjAJ; else goto cjAK;
       cjAJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$ccompare_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjAK: // global
           I64[Sp - 24] = block_cjAC_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujAS; else goto cjAD;
       ujAS: // global
           call _cjAC(R1) args: 0, res: 0, upd: 0;
       cjAD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdNonEmpty_$ccompare_info" {
     GHC.Base.$fOrdNonEmpty_$ccompare_info:
         const GHC.Base.$fOrdNonEmpty_$ccompare_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjAC() //  [R1]
         { []
         }
     {offset
       cjAC: // global
           I64[Sp - 8] = block_cjAI_info;
           _sh5y::P64 = P64[R1 + 7];
           _sh5z::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sh5z::P64;
           P64[Sp + 16] = _sh5y::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujAR; else goto cjAM;
       ujAR: // global
           call _cjAI(R1) args: 0, res: 0, upd: 0;
       cjAM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjAC_info" {
     block_cjAC_info:
         const _cjAC;
         const 2;
         const 30;
 },
 _cjAI() //  [R1]
         { []
         }
     {offset
       cjAI: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$ccompare_entry(R6,
                                           R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjAI_info" {
     block_cjAI_info:
         const _cjAI;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.946948892 UTC

[section ""data" . GHC.Base.$w$c<_closure" {
     GHC.Base.$w$c<_closure:
         const GHC.Base.$w$c<_info;
 },
 GHC.Base.$w$c<_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cjBj: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cjBk; else goto cjBl;
       cjBk: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjBl: // global
           I64[Sp - 32] = block_cjBc_info;
           _sh5D::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _sh5D::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$c<_info" {
     GHC.Base.$w$c<_info:
         const GHC.Base.$w$c<_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cjBc() //  [R1]
         { []
         }
     {offset
       cjBc: // global
           _cjBi::P64 = R1 & 7;
           if (_cjBi::P64 < 3) goto ujBv; else goto cjBh;
       ujBv: // global
           if (_cjBi::P64 < 2) goto cjBf; else goto cjBg;
       cjBf: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cjBg: // global
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call GHC.Classes.$fOrd[]_$c<_entry(R4,
                                              R3,
                                              R2) args: 8, res: 0, upd: 8;
       cjBh: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjBc_info" {
     block_cjBc_info:
         const _cjBc;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.953520072 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$c<_closure" {
     GHC.Base.$fOrdNonEmpty_$c<_closure:
         const GHC.Base.$fOrdNonEmpty_$c<_info;
 },
 GHC.Base.$fOrdNonEmpty_$c<_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjBS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjBW; else goto cjBX;
       cjBW: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$c<_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjBX: // global
           I64[Sp - 24] = block_cjBP_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujC5; else goto cjBQ;
       ujC5: // global
           call _cjBP(R1) args: 0, res: 0, upd: 0;
       cjBQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdNonEmpty_$c<_info" {
     GHC.Base.$fOrdNonEmpty_$c<_info:
         const GHC.Base.$fOrdNonEmpty_$c<_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjBP() //  [R1]
         { []
         }
     {offset
       cjBP: // global
           I64[Sp - 8] = block_cjBV_info;
           _sh5N::P64 = P64[R1 + 7];
           _sh5O::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sh5O::P64;
           P64[Sp + 16] = _sh5N::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujC4; else goto cjBZ;
       ujC4: // global
           call _cjBV(R1) args: 0, res: 0, upd: 0;
       cjBZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjBP_info" {
     block_cjBP_info:
         const _cjBP;
         const 2;
         const 30;
 },
 _cjBV() //  [R1]
         { []
         }
     {offset
       cjBV: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c<_entry(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjBV_info" {
     block_cjBV_info:
         const _cjBV;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.961444626 UTC

[section ""data" . GHC.Base.$w$c<=_closure" {
     GHC.Base.$w$c<=_closure:
         const GHC.Base.$w$c<=_info;
 },
 GHC.Base.$w$c<=_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cjCw: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cjCx; else goto cjCy;
       cjCx: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjCy: // global
           I64[Sp - 32] = block_cjCp_info;
           _sh5S::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R5;
           P64[Sp - 40] = R3;
           P64[Sp - 24] = _sh5S::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$c<=_info" {
     GHC.Base.$w$c<=_info:
         const GHC.Base.$w$c<=_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cjCp() //  [R1]
         { []
         }
     {offset
       cjCp: // global
           _cjCv::P64 = R1 & 7;
           if (_cjCv::P64 < 3) goto ujCU; else goto ujCV;
       ujCU: // global
           if (_cjCv::P64 < 2) goto ujCW; else goto cjCt;
       ujCW: // global
           Sp = Sp + 32;
           call _cjCP() args: 0, res: 0, upd: 0;
       cjCt: // global
           _sh5W::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cjCE_info;
           R4 = P64[Sp + 16];
           R3 = _sh5W::P64;
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       ujCV: // global
           Sp = Sp + 32;
           call _cjCu() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cjCp_info" {
     block_cjCp_info:
         const _cjCp;
         const 3;
         const 30;
 },
 _cjCE() //  [R1]
         { []
         }
     {offset
       cjCE: // global
           if (R1 & 7 == 1) goto ujCX; else goto ujCY;
       ujCX: // global
           Sp = Sp + 8;
           call _cjCP() args: 0, res: 0, upd: 0;
       ujCY: // global
           Sp = Sp + 8;
           call _cjCu() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cjCE_info" {
     block_cjCE_info:
         const _cjCE;
         const 0;
         const 30;
 },
 _cjCP() //  []
         { []
         }
     {offset
       cjCP: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjCu() //  []
         { []
         }
     {offset
       cjCu: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.971480241 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$c<=_closure" {
     GHC.Base.$fOrdNonEmpty_$c<=_closure:
         const GHC.Base.$fOrdNonEmpty_$c<=_info;
 },
 GHC.Base.$fOrdNonEmpty_$c<=_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjDz: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjDD; else goto cjDE;
       cjDD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$c<=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjDE: // global
           I64[Sp - 24] = block_cjDw_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujDM; else goto cjDx;
       ujDM: // global
           call _cjDw(R1) args: 0, res: 0, upd: 0;
       cjDx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdNonEmpty_$c<=_info" {
     GHC.Base.$fOrdNonEmpty_$c<=_info:
         const GHC.Base.$fOrdNonEmpty_$c<=_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjDw() //  [R1]
         { []
         }
     {offset
       cjDw: // global
           I64[Sp - 8] = block_cjDC_info;
           _sh63::P64 = P64[R1 + 7];
           _sh64::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sh64::P64;
           P64[Sp + 16] = _sh63::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujDL; else goto cjDG;
       ujDL: // global
           call _cjDC(R1) args: 0, res: 0, upd: 0;
       cjDG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjDw_info" {
     block_cjDw_info:
         const _cjDw;
         const 2;
         const 30;
 },
 _cjDC() //  [R1]
         { []
         }
     {offset
       cjDC: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c<=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjDC_info" {
     block_cjDC_info:
         const _cjDC;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.980182047 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$cmax_closure" {
     GHC.Base.$fOrdNonEmpty_$cmax_closure:
         const GHC.Base.$fOrdNonEmpty_$cmax_info;
 },
 GHC.Base.$fOrdNonEmpty_$cmax_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjE9: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cjEd; else goto cjEe;
       cjEd: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$cmax_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjEe: // global
           I64[Sp - 24] = block_cjE6_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujET; else goto cjE7;
       ujET: // global
           call _cjE6(R1) args: 0, res: 0, upd: 0;
       cjE7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdNonEmpty_$cmax_info" {
     GHC.Base.$fOrdNonEmpty_$cmax_info:
         const GHC.Base.$fOrdNonEmpty_$cmax_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjE6() //  [R1]
         { []
         }
     {offset
       cjE6: // global
           I64[Sp - 16] = block_cjEc_info;
           _sh6b::P64 = R1;
           _sh6c::P64 = P64[R1 + 7];
           _sh6d::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _sh6d::P64;
           P64[Sp] = _sh6c::P64;
           P64[Sp + 16] = _sh6b::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ujES; else goto cjEg;
       ujES: // global
           call _cjEc(R1) args: 0, res: 0, upd: 0;
       cjEg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjE6_info" {
     block_cjE6_info:
         const _cjE6;
         const 2;
         const 30;
 },
 _cjEc() //  [R1]
         { []
         }
     {offset
       cjEc: // global
           I64[Sp - 8] = block_cjEk_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 16] = R1;
           Sp = Sp - 32;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjEc_info" {
     block_cjEc_info:
         const _cjEc;
         const 4;
         const 30;
 },
 _cjEk() //  [R1]
         { []
         }
     {offset
       cjEk: // global
           _cjEL::P64 = R1 & 7;
           if (_cjEL::P64 < 3) goto ujEN; else goto ujEO;
       ujEN: // global
           if (_cjEL::P64 < 2) goto ujEP; else goto cjEw;
       ujEP: // global
           Sp = Sp + 40;
           call _cjEG() args: 0, res: 0, upd: 0;
       cjEw: // global
           _sh6d::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cjEu_info;
           R4 = _sh6d::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       ujEO: // global
           Sp = Sp + 24;
           call _cjEK() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cjEk_info" {
     block_cjEk_info:
         const _cjEk;
         const 5;
         const 30;
 },
 _cjEu() //  [R1]
         { []
         }
     {offset
       cjEu: // global
           if (R1 & 7 == 1) goto ujEQ; else goto ujER;
       ujEQ: // global
           Sp = Sp + 24;
           call _cjEG() args: 0, res: 0, upd: 0;
       ujER: // global
           Sp = Sp + 8;
           call _cjEK() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cjEu_info" {
     block_cjEu_info:
         const _cjEu;
         const 131;
         const 30;
 },
 _cjEG() //  []
         { []
         }
     {offset
       cjEG: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjEK() //  []
         { []
         }
     {offset
       cjEK: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:57.993322347 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$cmin_closure" {
     GHC.Base.$fOrdNonEmpty_$cmin_closure:
         const GHC.Base.$fOrdNonEmpty_$cmin_info;
 },
 GHC.Base.$fOrdNonEmpty_$cmin_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjFH: // global
           if ((Sp + -72) < SpLim) (likely: False) goto cjFL; else goto cjFM;
       cjFL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$cmin_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjFM: // global
           I64[Sp - 24] = block_cjFE_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujGr; else goto cjFF;
       ujGr: // global
           call _cjFE(R1) args: 0, res: 0, upd: 0;
       cjFF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdNonEmpty_$cmin_info" {
     GHC.Base.$fOrdNonEmpty_$cmin_info:
         const GHC.Base.$fOrdNonEmpty_$cmin_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjFE() //  [R1]
         { []
         }
     {offset
       cjFE: // global
           I64[Sp - 16] = block_cjFK_info;
           _sh6m::P64 = R1;
           _sh6n::P64 = P64[R1 + 7];
           _sh6o::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp - 8] = _sh6o::P64;
           P64[Sp] = _sh6n::P64;
           P64[Sp + 16] = _sh6m::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ujGq; else goto cjFO;
       ujGq: // global
           call _cjFK(R1) args: 0, res: 0, upd: 0;
       cjFO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjFE_info" {
     block_cjFE_info:
         const _cjFE;
         const 2;
         const 30;
 },
 _cjFK() //  [R1]
         { []
         }
     {offset
       cjFK: // global
           I64[Sp - 8] = block_cjFS_info;
           R2 = P64[Sp + 24];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[R1 + 7];
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp] = P64[R1 + 15];
           P64[Sp + 16] = R1;
           Sp = Sp - 32;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjFK_info" {
     block_cjFK_info:
         const _cjFK;
         const 4;
         const 30;
 },
 _cjFS() //  [R1]
         { []
         }
     {offset
       cjFS: // global
           _cjGj::P64 = R1 & 7;
           if (_cjGj::P64 < 3) goto ujGl; else goto ujGm;
       ujGl: // global
           if (_cjGj::P64 < 2) goto ujGn; else goto cjG4;
       ujGn: // global
           Sp = Sp + 24;
           call _cjGe() args: 0, res: 0, upd: 0;
       cjG4: // global
           _sh6o::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cjG2_info;
           R4 = _sh6o::P64;
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 32];
           Sp = Sp + 16;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       ujGm: // global
           Sp = Sp + 40;
           call _cjGi() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cjFS_info" {
     block_cjFS_info:
         const _cjFS;
         const 5;
         const 30;
 },
 _cjG2() //  [R1]
         { []
         }
     {offset
       cjG2: // global
           if (R1 & 7 == 1) goto ujGo; else goto ujGp;
       ujGo: // global
           Sp = Sp + 8;
           call _cjGe() args: 0, res: 0, upd: 0;
       ujGp: // global
           Sp = Sp + 24;
           call _cjGi() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cjG2_info" {
     block_cjG2_info:
         const _cjG2;
         const 131;
         const 30;
 },
 _cjGe() //  []
         { []
         }
     {offset
       cjGe: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjGi() //  []
         { []
         }
     {offset
       cjGi: // global
           R1 = P64[Sp] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.008102233 UTC

[section ""data" . GHC.Base.$w$c>=_closure" {
     GHC.Base.$w$c>=_closure:
         const GHC.Base.$w$c>=_info;
 },
 GHC.Base.$w$c>=_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cjHj: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cjHk; else goto cjHl;
       cjHk: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c>=_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjHl: // global
           I64[Sp - 32] = block_cjHc_info;
           _sh6u::P64 = R2;
           R2 = R2;
           I64[Sp - 56] = stg_ap_pp_info;
           P64[Sp - 48] = R3;
           P64[Sp - 40] = R5;
           P64[Sp - 24] = _sh6u::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 56;
           call GHC.Classes.compare_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$c>=_info" {
     GHC.Base.$w$c>=_info:
         const GHC.Base.$w$c>=_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cjHc() //  [R1]
         { []
         }
     {offset
       cjHc: // global
           _cjHi::P64 = R1 & 7;
           if (_cjHi::P64 < 3) goto ujHH; else goto ujHI;
       ujHH: // global
           if (_cjHi::P64 < 2) goto ujHJ; else goto cjHg;
       ujHJ: // global
           Sp = Sp + 32;
           call _cjHC() args: 0, res: 0, upd: 0;
       cjHg: // global
           _sh6y::P64 = P64[Sp + 24];
           I64[Sp + 24] = block_cjHr_info;
           R4 = _sh6y::P64;
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 24;
           call GHC.Classes.$fOrd[]_$ccompare_entry(R4,
                                                    R3,
                                                    R2) args: 8, res: 8, upd: 8;
       ujHI: // global
           Sp = Sp + 32;
           call _cjHh() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cjHc_info" {
     block_cjHc_info:
         const _cjHc;
         const 3;
         const 30;
 },
 _cjHr() //  [R1]
         { []
         }
     {offset
       cjHr: // global
           if (R1 & 7 == 1) goto ujHK; else goto ujHL;
       ujHK: // global
           Sp = Sp + 8;
           call _cjHC() args: 0, res: 0, upd: 0;
       ujHL: // global
           Sp = Sp + 8;
           call _cjHh() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cjHr_info" {
     block_cjHr_info:
         const _cjHr;
         const 0;
         const 30;
 },
 _cjHC() //  []
         { []
         }
     {offset
       cjHC: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cjHh() //  []
         { []
         }
     {offset
       cjHh: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.017602163 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_$c>=_closure" {
     GHC.Base.$fOrdNonEmpty_$c>=_closure:
         const GHC.Base.$fOrdNonEmpty_$c>=_info;
 },
 GHC.Base.$fOrdNonEmpty_$c>=_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjIm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjIq; else goto cjIr;
       cjIq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_$c>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjIr: // global
           I64[Sp - 24] = block_cjIj_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujIz; else goto cjIk;
       ujIz: // global
           call _cjIj(R1) args: 0, res: 0, upd: 0;
       cjIk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdNonEmpty_$c>=_info" {
     GHC.Base.$fOrdNonEmpty_$c>=_info:
         const GHC.Base.$fOrdNonEmpty_$c>=_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjIj() //  [R1]
         { []
         }
     {offset
       cjIj: // global
           I64[Sp - 8] = block_cjIp_info;
           _sh6F::P64 = P64[R1 + 7];
           _sh6G::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sh6G::P64;
           P64[Sp + 16] = _sh6F::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujIy; else goto cjIt;
       ujIy: // global
           call _cjIp(R1) args: 0, res: 0, upd: 0;
       cjIt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjIj_info" {
     block_cjIj_info:
         const _cjIj;
         const 2;
         const 30;
 },
 _cjIp() //  [R1]
         { []
         }
     {offset
       cjIp: // global
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = P64[Sp + 8];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call GHC.Base.$w$c>=_entry(R6,
                                      R5,
                                      R4,
                                      R3,
                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjIp_info" {
     block_cjIp_info:
         const _cjIp;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.026898745 UTC

[section ""data" . GHC.Base.$fOrdNonEmpty_closure" {
     GHC.Base.$fOrdNonEmpty_closure:
         const GHC.Base.$fOrdNonEmpty_info;
 },
 sat_sh6U_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cjIY: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$cmin_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh6U_info" {
     sat_sh6U_info:
         const sat_sh6U_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sh6T_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cjJ6: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$cmax_entry(R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh6T_info" {
     sat_sh6T_info:
         const sat_sh6T_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sh6S_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cjJe: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c>=_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh6S_info" {
     sat_sh6S_info:
         const sat_sh6S_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sh6R_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cjJm: // global
           R4 = R2;
           R3 = R3;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c<_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh6R_info" {
     sat_sh6R_info:
         const sat_sh6R_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sh6O_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cjJu: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c<=_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh6O_info" {
     sat_sh6O_info:
         const sat_sh6O_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sh6N_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cjJC: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$c<_entry(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh6N_info" {
     sat_sh6N_info:
         const sat_sh6N_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sh6M_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cjJK: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fOrdNonEmpty_$ccompare_entry(R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh6M_info" {
     sat_sh6M_info:
         const sat_sh6M_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sh6L_entry() //  [R1]
         { []
         }
     {offset
       cjJR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjJS; else goto cjJT;
       cjJS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjJT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fOrdNonEmpty_$cp1Ord_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh6L_info" {
     sat_sh6L_info:
         const sat_sh6L_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fOrdNonEmpty_entry() //  [R2]
         { []
         }
     {offset
       cjJV: // global
           Hp = Hp + 208;
           if (Hp > HpLim) (likely: False) goto cjJZ; else goto cjJY;
       cjJZ: // global
           HpAlloc = 208;
           R2 = R2;
           R1 = GHC.Base.$fOrdNonEmpty_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjJY: // global
           I64[Hp - 200] = sat_sh6U_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = sat_sh6T_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_sh6S_info;
           P64[Hp - 160] = R2;
           I64[Hp - 152] = sat_sh6R_info;
           P64[Hp - 144] = R2;
           I64[Hp - 136] = sat_sh6O_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = sat_sh6N_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_sh6M_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_sh6L_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = GHC.Classes.C:Ord_con_info;
           P64[Hp - 56] = Hp - 88;
           P64[Hp - 48] = Hp - 102;
           P64[Hp - 40] = Hp - 118;
           P64[Hp - 32] = Hp - 134;
           P64[Hp - 24] = Hp - 150;
           P64[Hp - 16] = Hp - 166;
           P64[Hp - 8] = Hp - 182;
           P64[Hp] = Hp - 198;
           R1 = Hp - 63;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fOrdNonEmpty_info" {
     GHC.Base.$fOrdNonEmpty_info:
         const GHC.Base.$fOrdNonEmpty_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.043451947 UTC

[section ""data" . GHC.Base.$fMonadIO_$cfail_closure" {
     GHC.Base.$fMonadIO_$cfail_closure:
         const GHC.Base.$fMonadIO_$cfail_info;
         const 0;
 },
 GHC.Base.$fMonadIO_$cfail_entry() //  [R2]
         { []
         }
     {offset
       cjKQ: // global
           R2 = R2;
           R1 = GHC.IO.failIO_closure;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonadIO_$cfail_info" {
     GHC.Base.$fMonadIO_$cfail_info:
         const GHC.Base.$fMonadIO_$cfail_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const Si3a_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.046599559 UTC

[section ""data" . GHC.Base.$fMonadIO_closure" {
     GHC.Base.$fMonadIO_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicativeIO_closure+1;
         const GHC.Base.$fMonadIO1_closure+3;
         const GHC.Base.$fApplicativeIO2_closure+3;
         const GHC.Base.$fApplicativeIO4_closure+2;
         const GHC.Base.$fMonadIO_$cfail_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.048615145 UTC

[section ""data" . GHC.Base.$fMonad[]_$cfail_closure" {
     GHC.Base.$fMonad[]_$cfail_closure:
         const GHC.Base.$fMonad[]_$cfail_info;
 },
 GHC.Base.$fMonad[]_$cfail_entry() //  []
         { []
         }
     {offset
       cjL2: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonad[]_$cfail_info" {
     GHC.Base.$fMonad[]_$cfail_info:
         const GHC.Base.$fMonad[]_$cfail_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.051610505 UTC

[section ""data" . GHC.Base.$fMonad[]_closure" {
     GHC.Base.$fMonad[]_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicative[]_closure+1;
         const GHC.Base.$fMonad[]_$c>>=_closure+2;
         const GHC.Base.$fApplicative[]_$c*>_closure+2;
         const GHC.Base.$fApplicative[]_$cpure_closure+1;
         const GHC.Base.$fMonad[]_$cfail_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.053422193 UTC

[section ""data" . GHC.Base.$fMonadPlus[]_closure" {
     GHC.Base.$fMonadPlus[]_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Base.$fAlternative[]_closure+1;
         const GHC.Base.$fMonad[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.++_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.056034754 UTC

[section ""data" . GHC.Base.$fMonadMaybe_$c>>=_closure" {
     GHC.Base.$fMonadMaybe_$c>>=_closure:
         const GHC.Base.$fMonadMaybe_$c>>=_info;
 },
 GHC.Base.$fMonadMaybe_$c>>=_entry() //  [R2, R3]
         { []
         }
     {offset
       cjLo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjLp; else goto cjLq;
       cjLp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonadMaybe_$c>>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cjLq: // global
           I64[Sp - 16] = block_cjLh_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ujLx; else goto cjLi;
       ujLx: // global
           call _cjLh(R1) args: 0, res: 0, upd: 0;
       cjLi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonadMaybe_$c>>=_info" {
     GHC.Base.$fMonadMaybe_$c>>=_info:
         const GHC.Base.$fMonadMaybe_$c>>=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cjLh() //  [R1]
         { []
         }
     {offset
       cjLh: // global
           if (R1 & 7 == 1) goto cjLl; else goto cjLm;
       cjLl: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cjLm: // global
           R2 = P64[R1 + 6];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjLh_info" {
     block_cjLh_info:
         const _cjLh;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.061294176 UTC

[section ""data" . GHC.Base.$fMonadMaybe_$cfail_closure" {
     GHC.Base.$fMonadMaybe_$cfail_closure:
         const GHC.Base.$fMonadMaybe_$cfail_info;
 },
 GHC.Base.$fMonadMaybe_$cfail_entry() //  []
         { []
         }
     {offset
       cjLP: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonadMaybe_$cfail_info" {
     GHC.Base.$fMonadMaybe_$cfail_info:
         const GHC.Base.$fMonadMaybe_$cfail_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.064942949 UTC

[section ""data" . GHC.Base.$fMonad(->)_$c>>=_closure" {
     GHC.Base.$fMonad(->)_$c>>=_closure:
         const GHC.Base.$fMonad(->)_$c>>=_info;
 },
 GHC.Base.$fMonad(->)_$c>>=_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjM2: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cjM6; else goto cjM5;
       cjM6: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad(->)_$c>>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjM5: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           _sh73::P64 = R3;
           R3 = R4;
           R2 = Hp - 24;
           R1 = _sh73::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonad(->)_$c>>=_info" {
     GHC.Base.$fMonad(->)_$c>>=_info:
         const GHC.Base.$fMonad(->)_$c>>=_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.069980235 UTC

[section ""data" . GHC.Base.$fMonad(,)_$c>>=_closure" {
     GHC.Base.$fMonad(,)_$c>>=_closure:
         const GHC.Base.$fMonad(,)_$c>>=_info;
 },
 sat_sh7g_entry() //  [R1]
         { []
         }
     {offset
       cjMv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjMw; else goto cjMx;
       cjMw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjMx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cjMt_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh7g_info" {
     sat_sh7g_info:
         const sat_sh7g_entry;
         const 3;
         const 15;
 },
 _cjMt() //  [R1]
         { []
         }
     {offset
       cjMt: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cjMt_info" {
     block_cjMt_info:
         const _cjMt;
         const 2;
         const 30;
 },
 GHC.Base.$fMonad(,)_$c>>=_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjMB: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cjMD; else goto cjME;
       cjMD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonad(,)_$c>>=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjME: // global
           I64[Sp - 24] = block_cjMg_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujMJ; else goto cjMh;
       ujMJ: // global
           call _cjMg(R1) args: 0, res: 0, upd: 0;
       cjMh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonad(,)_$c>>=_info" {
     GHC.Base.$fMonad(,)_$c>>=_info:
         const GHC.Base.$fMonad(,)_$c>>=_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjMg() //  [R1]
         { []
         }
     {offset
       cjMg: // global
           I64[Sp] = block_cjMl_info;
           R2 = P64[R1 + 15];
           _sh7a::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sh7a::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjMg_info" {
     block_cjMg_info:
         const _cjMg;
         const 2;
         const 30;
 },
 _cjMl() //  [R1]
         { []
         }
     {offset
       cjMl: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cjMI; else goto cjMH;
       cjMI: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cjMH: // global
           _sh7d::P64 = P64[R1 + 7];
           _sh7e::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sh7g_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sh7d::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = _sh7e::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjMl_info" {
     block_cjMl_info:
         const _cjMl;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.081851501 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$c<*>_closure" {
     GHC.Base.$fApplicative(,)_$c<*>_closure:
         const GHC.Base.$fApplicative(,)_$c<*>_info;
 },
 sat_sh7r_entry() //  [R1]
         { []
         }
     {offset
       cjNB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjNC; else goto cjND;
       cjNC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjND: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cjNz_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh7r_info" {
     sat_sh7r_info:
         const sat_sh7r_entry;
         const 3;
         const 15;
 },
 _cjNz() //  [R1]
         { []
         }
     {offset
       cjNz: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cjNz_info" {
     block_cjNz_info:
         const _cjNz;
         const 2;
         const 30;
 },
 GHC.Base.$fApplicative(,)_$c<*>_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjNH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjNJ; else goto cjNK;
       cjNJ: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$c<*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjNK: // global
           I64[Sp - 24] = block_cjNk_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujNQ; else goto cjNl;
       ujNQ: // global
           call _cjNk(R1) args: 0, res: 0, upd: 0;
       cjNl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative(,)_$c<*>_info" {
     GHC.Base.$fApplicative(,)_$c<*>_info:
         const GHC.Base.$fApplicative(,)_$c<*>_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjNk() //  [R1]
         { []
         }
     {offset
       cjNk: // global
           I64[Sp - 8] = block_cjNp_info;
           _sh7l::P64 = P64[R1 + 7];
           _sh7m::P64 = P64[R1 + 15];
           R1 = P64[Sp + 16];
           P64[Sp] = _sh7m::P64;
           P64[Sp + 16] = _sh7l::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujNP; else goto cjNq;
       ujNP: // global
           call _cjNp(R1) args: 0, res: 0, upd: 0;
       cjNq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjNk_info" {
     block_cjNk_info:
         const _cjNk;
         const 2;
         const 30;
 },
 _cjNp() //  [R1]
         { []
         }
     {offset
       cjNp: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cjNO; else goto cjNN;
       cjNO: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cjNN: // global
           _sh7o::P64 = P64[R1 + 7];
           _sh7p::P64 = P64[R1 + 15];
           I64[Hp - 88] = stg_ap_2_upd_info;
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sh7p::P64;
           I64[Hp - 56] = sat_sh7r_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _sh7o::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjNp_info" {
     block_cjNp_info:
         const _cjNp;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.093514669 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$c*>_closure" {
     GHC.Base.$fApplicative(,)_$c*>_closure:
         const GHC.Base.$fApplicative(,)_$c*>_info;
 },
 sat_sh7D_entry() //  [R1]
         { []
         }
     {offset
       cjOL: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjOM; else goto cjON;
       cjOM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjON: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cjOJ_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh7D_info" {
     sat_sh7D_info:
         const sat_sh7D_entry;
         const 3;
         const 15;
 },
 _cjOJ() //  [R1]
         { []
         }
     {offset
       cjOJ: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cjOJ_info" {
     block_cjOJ_info:
         const _cjOJ;
         const 2;
         const 30;
 },
 GHC.Base.$fApplicative(,)_$c*>_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjOR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cjOT; else goto cjOU;
       cjOT: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$c*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjOU: // global
           I64[Sp - 24] = block_cjOv_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujP0; else goto cjOw;
       ujP0: // global
           call _cjOv(R1) args: 0, res: 0, upd: 0;
       cjOw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative(,)_$c*>_info" {
     GHC.Base.$fApplicative(,)_$c*>_info:
         const GHC.Base.$fApplicative(,)_$c*>_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjOv() //  [R1]
         { []
         }
     {offset
       cjOv: // global
           I64[Sp] = block_cjOA_info;
           _sh7x::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sh7x::P64;
           if (R1 & 7 != 0) goto ujOZ; else goto cjOB;
       ujOZ: // global
           call _cjOA(R1) args: 0, res: 0, upd: 0;
       cjOB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjOv_info" {
     block_cjOv_info:
         const _cjOv;
         const 2;
         const 30;
 },
 _cjOA() //  [R1]
         { []
         }
     {offset
       cjOA: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cjOY; else goto cjOX;
       cjOY: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cjOX: // global
           _sh7A::P64 = P64[R1 + 7];
           _sh7B::P64 = P64[R1 + 15];
           I64[Hp - 56] = sat_sh7D_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sh7A::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = _sh7B::P64;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjOA_info" {
     block_cjOA_info:
         const _cjOA;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.105102162 UTC

[section ""data" . GHC.Base.$fApplicative(,)_$cliftA2_closure" {
     GHC.Base.$fApplicative(,)_$cliftA2_closure:
         const GHC.Base.$fApplicative(,)_$cliftA2_info;
 },
 sat_sh7P_entry() //  [R1]
         { []
         }
     {offset
       cjPT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjPU; else goto cjPV;
       cjPU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjPV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cjPR_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh7P_info" {
     sat_sh7P_info:
         const sat_sh7P_entry;
         const 3;
         const 15;
 },
 _cjPR() //  [R1]
         { []
         }
     {offset
       cjPR: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cjPR_info" {
     block_cjPR_info:
         const _cjPR;
         const 2;
         const 30;
 },
 GHC.Base.$fApplicative(,)_$cliftA2_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cjPZ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjQ1; else goto cjQ2;
       cjQ1: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_$cliftA2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjQ2: // global
           I64[Sp - 32] = block_cjPC_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ujQ8; else goto cjPD;
       ujQ8: // global
           call _cjPC(R1) args: 0, res: 0, upd: 0;
       cjPD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative(,)_$cliftA2_info" {
     GHC.Base.$fApplicative(,)_$cliftA2_info:
         const GHC.Base.$fApplicative(,)_$cliftA2_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _cjPC() //  [R1]
         { []
         }
     {offset
       cjPC: // global
           I64[Sp - 8] = block_cjPH_info;
           _sh7J::P64 = P64[R1 + 7];
           _sh7K::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _sh7K::P64;
           P64[Sp + 24] = _sh7J::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujQ7; else goto cjPI;
       ujQ7: // global
           call _cjPH(R1) args: 0, res: 0, upd: 0;
       cjPI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjPC_info" {
     block_cjPC_info:
         const _cjPC;
         const 3;
         const 30;
 },
 _cjPH() //  [R1]
         { []
         }
     {offset
       cjPH: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cjQ6; else goto cjQ5;
       cjQ6: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cjQ5: // global
           _sh7M::P64 = P64[R1 + 7];
           _sh7N::P64 = P64[R1 + 15];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sh7N::P64;
           I64[Hp - 56] = sat_sh7P_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sh7M::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjPH_info" {
     block_cjPH_info:
         const _cjPH;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.118332499 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,,,,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,,,,)_$cmempty_info;
 },
 sat_sh80_entry() //  [R1]
         { []
         }
     {offset
       cjQS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjQT; else goto cjQU;
       cjQT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjQU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh80_info" {
     sat_sh80_info:
         const sat_sh80_entry;
         const 1;
         const 16;
 },
 sat_sh7Z_entry() //  [R1]
         { []
         }
     {offset
       cjQZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjR0; else goto cjR1;
       cjR0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjR1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh7Z_info" {
     sat_sh7Z_info:
         const sat_sh7Z_entry;
         const 1;
         const 16;
 },
 sat_sh7Y_entry() //  [R1]
         { []
         }
     {offset
       cjR6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjR7; else goto cjR8;
       cjR7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjR8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh7Y_info" {
     sat_sh7Y_info:
         const sat_sh7Y_entry;
         const 1;
         const 16;
 },
 sat_sh7X_entry() //  [R1]
         { []
         }
     {offset
       cjRd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjRe; else goto cjRf;
       cjRe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjRf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh7X_info" {
     sat_sh7X_info:
         const sat_sh7X_entry;
         const 1;
         const 16;
 },
 sat_sh7W_entry() //  [R1]
         { []
         }
     {offset
       cjRk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjRl; else goto cjRm;
       cjRl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjRm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh7W_info" {
     sat_sh7W_info:
         const sat_sh7W_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fMonoid(,,,,)_$cmempty_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cjRo: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cjRs; else goto cjRr;
       cjRs: // global
           HpAlloc = 168;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cmempty_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjRr: // global
           I64[Hp - 160] = sat_sh80_info;
           P64[Hp - 144] = R6;
           I64[Hp - 136] = sat_sh7Z_info;
           P64[Hp - 120] = R5;
           I64[Hp - 112] = sat_sh7Y_info;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_sh7X_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_sh7W_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,,)_$cmempty_info" {
     GHC.Base.$fMonoid(,,,,)_$cmempty_info:
         const GHC.Base.$fMonoid(,,,,)_$cmempty_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.131753623 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,,,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,,,)_$cmempty_info;
 },
 sat_sh88_entry() //  [R1]
         { []
         }
     {offset
       cjSg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjSh; else goto cjSi;
       cjSh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjSi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh88_info" {
     sat_sh88_info:
         const sat_sh88_entry;
         const 1;
         const 16;
 },
 sat_sh87_entry() //  [R1]
         { []
         }
     {offset
       cjSn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjSo; else goto cjSp;
       cjSo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjSp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh87_info" {
     sat_sh87_info:
         const sat_sh87_entry;
         const 1;
         const 16;
 },
 sat_sh86_entry() //  [R1]
         { []
         }
     {offset
       cjSu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjSv; else goto cjSw;
       cjSv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjSw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh86_info" {
     sat_sh86_info:
         const sat_sh86_entry;
         const 1;
         const 16;
 },
 sat_sh85_entry() //  [R1]
         { []
         }
     {offset
       cjSB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjSC; else goto cjSD;
       cjSC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjSD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh85_info" {
     sat_sh85_info:
         const sat_sh85_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fMonoid(,,,)_$cmempty_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cjSF: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cjSJ; else goto cjSI;
       cjSJ: // global
           HpAlloc = 136;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cmempty_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjSI: // global
           I64[Hp - 128] = sat_sh88_info;
           P64[Hp - 112] = R5;
           I64[Hp - 104] = sat_sh87_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = sat_sh86_info;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_sh85_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,)_$cmempty_info" {
     GHC.Base.$fMonoid(,,,)_$cmempty_info:
         const GHC.Base.$fMonoid(,,,)_$cmempty_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.144031234 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,,)_$cmempty_info;
 },
 sat_sh8e_entry() //  [R1]
         { []
         }
     {offset
       cjTq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjTr; else goto cjTs;
       cjTr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjTs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh8e_info" {
     sat_sh8e_info:
         const sat_sh8e_entry;
         const 1;
         const 16;
 },
 sat_sh8d_entry() //  [R1]
         { []
         }
     {offset
       cjTx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjTy; else goto cjTz;
       cjTy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjTz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh8d_info" {
     sat_sh8d_info:
         const sat_sh8d_entry;
         const 1;
         const 16;
 },
 sat_sh8c_entry() //  [R1]
         { []
         }
     {offset
       cjTE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjTF; else goto cjTG;
       cjTF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjTG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh8c_info" {
     sat_sh8c_info:
         const sat_sh8c_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fMonoid(,,)_$cmempty_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjTI: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cjTM; else goto cjTL;
       cjTM: // global
           HpAlloc = 104;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cmempty_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjTL: // global
           I64[Hp - 96] = sat_sh8e_info;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_sh8d_info;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_sh8c_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 48;
           P64[Hp - 8] = Hp - 72;
           P64[Hp] = Hp - 96;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,)_$cmempty_info" {
     GHC.Base.$fMonoid(,,)_$cmempty_info:
         const GHC.Base.$fMonoid(,,)_$cmempty_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.154612579 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cmempty_closure" {
     GHC.Base.$fMonoid(,)_$cmempty_closure:
         const GHC.Base.$fMonoid(,)_$cmempty_info;
 },
 sat_sh8i_entry() //  [R1]
         { []
         }
     {offset
       cjUm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjUn; else goto cjUo;
       cjUn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjUo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh8i_info" {
     sat_sh8i_info:
         const sat_sh8i_entry;
         const 1;
         const 16;
 },
 sat_sh8h_entry() //  [R1]
         { []
         }
     {offset
       cjUt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjUu; else goto cjUv;
       cjUu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjUv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh8h_info" {
     sat_sh8h_info:
         const sat_sh8h_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fMonoid(,)_$cmempty_entry() //  [R2, R3]
         { []
         }
     {offset
       cjUx: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cjUB; else goto cjUA;
       cjUB: // global
           HpAlloc = 72;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cmempty_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cjUA: // global
           I64[Hp - 64] = sat_sh8i_info;
           P64[Hp - 48] = R3;
           I64[Hp - 40] = sat_sh8h_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,)_$cmempty_info" {
     GHC.Base.$fMonoid(,)_$cmempty_info:
         const GHC.Base.$fMonoid(,)_$cmempty_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.165998541 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,)_$cmconcat_info;
 },
 $dSemigroup_sh8m_entry() //  [R1]
         { []
         }
     {offset
       cjV4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjV5; else goto cjV6;
       cjV5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjV6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dSemigroup_sh8m_info" {
     $dSemigroup_sh8m_info:
         const $dSemigroup_sh8m_entry;
         const 1;
         const 16;
 },
 $dSemigroup1_sh8n_entry() //  [R1]
         { []
         }
     {offset
       cjVb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjVc; else goto cjVd;
       cjVc: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjVd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dSemigroup1_sh8n_info" {
     $dSemigroup1_sh8n_info:
         const $dSemigroup1_sh8n_entry;
         const 1;
         const 16;
 },
 z_sh8o_entry() //  [R1]
         { []
         }
     {offset
       cjVi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjVj; else goto cjVk;
       cjVj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjVk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z_sh8o_info" {
     z_sh8o_info:
         const z_sh8o_entry;
         const 1;
         const 16;
 },
 z1_sh8p_entry() //  [R1]
         { []
         }
     {offset
       cjVp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cjVq; else goto cjVr;
       cjVq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjVr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z1_sh8p_info" {
     z1_sh8p_info:
         const z1_sh8p_entry;
         const 1;
         const 16;
 },
 sat_sh8D_entry() //  [R1]
         { []
         }
     {offset
       cjVR: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjVS; else goto cjVT;
       cjVS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjVT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh8D_info" {
     sat_sh8D_info:
         const sat_sh8D_entry;
         const 3;
         const 15;
 },
 sat_sh8C_entry() //  [R1]
         { []
         }
     {offset
       cjVY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjVZ; else goto cjW0;
       cjVZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjW0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh8C_info" {
     sat_sh8C_info:
         const sat_sh8C_entry;
         const 3;
         const 15;
 },
 go_sh8r_entry() //  [R1, R2]
         { []
         }
     {offset
       cjW5: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjW6; else goto cjW7;
       cjW6: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cjW7: // global
           I64[Sp - 40] = block_cjVy_info;
           _sh8r::P64 = R1;
           _sh8m::P64 = P64[R1 + 7];
           _sh8n::P64 = P64[R1 + 15];
           _sh8q::P64 = P64[R1 + 23];
           R1 = R2;
           P64[Sp - 32] = _sh8m::P64;
           P64[Sp - 24] = _sh8n::P64;
           P64[Sp - 16] = _sh8q::P64;
           P64[Sp - 8] = _sh8r::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ujWh; else goto cjVz;
       ujWh: // global
           call _cjVy(R1) args: 0, res: 0, upd: 0;
       cjVz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_sh8r_info" {
     go_sh8r_info:
         const go_sh8r_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 _cjVy() //  [R1]
         { []
         }
     {offset
       cjVy: // global
           if (R1 & 7 == 1) goto cjW2; else goto cjW3;
       cjW2: // global
           R1 = P64[Sp + 24];
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cjW3: // global
           I64[Sp] = block_cjVE_info;
           _sh8v::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _sh8v::P64;
           if (R1 & 7 != 0) goto ujWg; else goto cjVF;
       ujWg: // global
           call _cjVE(R1) args: 0, res: 0, upd: 0;
       cjVF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjVy_info" {
     block_cjVy_info:
         const _cjVy;
         const 4;
         const 30;
 },
 _cjVE() //  [R1]
         { []
         }
     {offset
       cjVE: // global
           I64[Sp] = block_cjVJ_info;
           R2 = P64[Sp + 24];
           _sh8x::P64 = P64[R1 + 7];
           _sh8y::P64 = P64[R1 + 15];
           R1 = P64[Sp + 32];
           P64[Sp + 24] = _sh8y::P64;
           P64[Sp + 32] = _sh8x::P64;
           call go_sh8r_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjVE_info" {
     block_cjVE_info:
         const _cjVE;
         const 4;
         const 30;
 },
 _cjVJ() //  [R1]
         { []
         }
     {offset
       cjVJ: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cjWf; else goto cjWe;
       cjWf: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cjWe: // global
           _sh8A::P64 = P64[R1 + 7];
           _sh8B::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_sh8D_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = P64[Sp + 24];
           P64[Hp - 64] = _sh8B::P64;
           I64[Hp - 56] = sat_sh8C_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sh8A::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjVJ_info" {
     block_cjVJ_info:
         const _cjVJ;
         const 4;
         const 30;
 },
 GHC.Base.$fMonoid(,)_$cmconcat_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjWi: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto cjWm; else goto cjWl;
       cjWm: // global
           HpAlloc = 152;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cmconcat_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjWl: // global
           I64[Hp - 144] = $dSemigroup_sh8m_info;
           P64[Hp - 128] = R2;
           I64[Hp - 120] = $dSemigroup1_sh8n_info;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = z_sh8o_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = z1_sh8p_info;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = (,)_con_info;
           P64[Hp - 40] = Hp - 96;
           P64[Hp - 32] = Hp - 72;
           I64[Hp - 24] = go_sh8r_info;
           P64[Hp - 16] = Hp - 144;
           P64[Hp - 8] = Hp - 120;
           P64[Hp] = Hp - 47;
           R2 = R4;
           R1 = Hp - 23;
           call go_sh8r_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,)_$cmconcat_info" {
     GHC.Base.$fMonoid(,)_$cmconcat_info:
         const GHC.Base.$fMonoid(,)_$cmconcat_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.185910697 UTC

[section ""data" . GHC.Base.$fMonoid()_$cmconcat_closure" {
     GHC.Base.$fMonoid()_$cmconcat_closure:
         const GHC.Base.$fMonoid()_$cmconcat_info;
 },
 GHC.Base.$fMonoid()_$cmconcat_entry() //  []
         { []
         }
     {offset
       cjXL: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid()_$cmconcat_info" {
     GHC.Base.$fMonoid()_$cmconcat_info:
         const GHC.Base.$fMonoid()_$cmconcat_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.190887687 UTC

[section ""data" . GHC.Base.$fMonoidMaybe_$c<>_closure" {
     GHC.Base.$fMonoidMaybe_$c<>_closure:
         const GHC.Base.$fMonoidMaybe_$c<>_info;
 },
 sat_sh8M_entry() //  [R1]
         { []
         }
     {offset
       cjYe: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjYf; else goto cjYg;
       cjYf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjYg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh8M_info" {
     sat_sh8M_info:
         const sat_sh8M_entry;
         const 3;
         const 15;
 },
 GHC.Base.$fMonoidMaybe_$c<>_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cjYl: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cjYm; else goto cjYn;
       cjYm: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidMaybe_$c<>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cjYn: // global
           I64[Sp - 24] = block_cjXY_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ujYC; else goto cjXZ;
       ujYC: // global
           call _cjXY(R1) args: 0, res: 0, upd: 0;
       cjXZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoidMaybe_$c<>_info" {
     GHC.Base.$fMonoidMaybe_$c<>_info:
         const GHC.Base.$fMonoidMaybe_$c<>_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cjXY() //  [R1]
         { []
         }
     {offset
       cjXY: // global
           _sh8H::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cjYi; else goto cjYj;
       cjYi: // global
           R1 = _sh8H::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cjYj: // global
           I64[Sp - 8] = block_cjY4_info;
           _sh8I::P64 = R1;
           _sh8J::P64 = P64[R1 + 6];
           R1 = _sh8H::P64;
           P64[Sp] = _sh8J::P64;
           P64[Sp + 16] = _sh8I::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ujYB; else goto cjY5;
       ujYB: // global
           call _cjY4(R1) args: 0, res: 0, upd: 0;
       cjY5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjXY_info" {
     block_cjXY_info:
         const _cjXY;
         const 2;
         const 30;
 },
 _cjY4() //  [R1]
         { []
         }
     {offset
       cjY4: // global
           if (R1 & 7 == 1) goto cjYu; else goto cjYw;
       cjYu: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cjYw: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cjYz; else goto cjYy;
       cjYz: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cjYy: // global
           _sh8L::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sh8M_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sh8L::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjY4_info" {
     block_cjY4_info:
         const _cjY4;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.203208803 UTC

[section ""data" . GHC.Base.$w$csconcat5_closure" {
     GHC.Base.$w$csconcat5_closure:
         const GHC.Base.$w$csconcat5_info;
 },
 sat_sh90_entry() //  [R1]
         { []
         }
     {offset
       cjZI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjZJ; else goto cjZK;
       cjZJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cjZK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh90_info" {
     sat_sh90_info:
         const sat_sh90_entry;
         const 3;
         const 15;
 },
 go_sh8Q_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cjZP: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cjZQ; else goto uk0c;
       cjZQ: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uk0c: // global
           P64[Sp - 24] = R1;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cjZk() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . go_sh8Q_info" {
     go_sh8Q_info:
         const go_sh8Q_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 _cjZk() //  []
         { []
         }
     {offset
       cjZk: // global
           _sh8N::P64 = P64[P64[Sp] + 6];
           I64[Sp - 8] = block_cjZn_info;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sh8N::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uk0e; else goto cjZo;
       uk0e: // global
           call _cjZn(R1) args: 0, res: 0, upd: 0;
       cjZo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cjZn() //  [R1]
         { []
         }
     {offset
       cjZn: // global
           _sh8R::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cjZM; else goto cjZN;
       cjZM: // global
           R1 = _sh8R::P64 & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cjZN: // global
           I64[Sp - 8] = block_cjZt_info;
           _sh8U::P64 = P64[R1 + 6];
           _sh8V::P64 = P64[R1 + 14];
           R1 = _sh8R::P64;
           P64[Sp] = _sh8V::P64;
           P64[Sp + 16] = _sh8U::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uk0f; else goto cjZu;
       uk0f: // global
           call _cjZt(R1) args: 0, res: 0, upd: 0;
       cjZu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjZn_info" {
     block_cjZn_info:
         const _cjZn;
         const 3;
         const 30;
 },
 _cjZt() //  [R1]
         { []
         }
     {offset
       cjZt: // global
           _sh8U::P64 = P64[Sp + 24];
           _sh8V::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cjZY; else goto ck00;
       cjZY: // global
           P64[Sp + 24] = _sh8U::P64;
           P64[Sp + 32] = _sh8V::P64;
           Sp = Sp + 16;
           call _cjZk() args: 0, res: 0, upd: 0;
       ck00: // global
           I64[Sp + 8] = block_cjZz_info;
           R3 = _sh8V::P64;
           R2 = _sh8U::P64;
           _sh8W::P64 = R1;
           _sh8X::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sh8X::P64;
           P64[Sp + 24] = _sh8W::P64;
           Sp = Sp + 8;
           call go_sh8Q_entry(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cjZt_info" {
     block_cjZt_info:
         const _cjZt;
         const 4;
         const 30;
 },
 _cjZz() //  [R1]
         { []
         }
     {offset
       cjZz: // global
           if (R1 & 7 == 1) goto ck04; else goto ck06;
       ck04: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ck06: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ck09; else goto ck08;
       ck09: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ck08: // global
           _sh8Z::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sh90_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sh8Z::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cjZz_info" {
     block_cjZz_info:
         const _cjZz;
         const 3;
         const 30;
 },
 GHC.Base.$w$csconcat5_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ck0i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ck0m; else goto ck0l;
       ck0m: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$csconcat5_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ck0l: // global
           I64[Hp - 8] = go_sh8Q_info;
           P64[Hp] = R2;
           _sh8O::P64 = R3;
           R3 = R4;
           R2 = _sh8O::P64;
           R1 = Hp - 6;
           call go_sh8Q_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$csconcat5_info" {
     GHC.Base.$w$csconcat5_info:
         const GHC.Base.$w$csconcat5_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.216649608 UTC

[section ""data" . GHC.Base.$fSemigroupMaybe_$csconcat_closure" {
     GHC.Base.$fSemigroupMaybe_$csconcat_closure:
         const GHC.Base.$fSemigroupMaybe_$csconcat_info;
 },
 GHC.Base.$fSemigroupMaybe_$csconcat_entry() //  [R2, R3]
         { []
         }
     {offset
       ck1i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck1j; else goto ck1k;
       ck1j: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupMaybe_$csconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ck1k: // global
           I64[Sp - 16] = block_ck1f_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uk1o; else goto ck1g;
       uk1o: // global
           call _ck1f(R1) args: 0, res: 0, upd: 0;
       ck1g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupMaybe_$csconcat_info" {
     GHC.Base.$fSemigroupMaybe_$csconcat_info:
         const GHC.Base.$fSemigroupMaybe_$csconcat_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ck1f() //  [R1]
         { []
         }
     {offset
       ck1f: // global
           R4 = P64[R1 + 15];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat5_entry(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ck1f_info" {
     block_ck1f_info:
         const _ck1f;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.2227493 UTC

[section ""data" . GHC.Base.$fSemigroupMaybe_closure" {
     GHC.Base.$fSemigroupMaybe_closure:
         const GHC.Base.$fSemigroupMaybe_info;
         const 0;
 },
 sat_sh9a_entry() //  [R1, R2]
         { []
         }
     {offset
       ck1I: // global
           R3 = P64[R1 + 7];
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesMaybe_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh9a_info" {
     sat_sh9a_info:
         const sat_sh9a_entry;
         const 1;
         const 4294967305;
         const 4294967301;
         const Si3a_srt+88;
 },
 sat_sh98_entry() //  [R1, R2]
         { []
         }
     {offset
       ck1Q: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroupMaybe_$csconcat_entry(R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh98_info" {
     sat_sh98_info:
         const sat_sh98_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sh97_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       ck1Y: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoidMaybe_$c<>_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh97_info" {
     sat_sh97_info:
         const sat_sh97_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 GHC.Base.$fSemigroupMaybe_entry() //  [R2]
         { []
         }
     {offset
       ck22: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto ck26; else goto ck25;
       ck26: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Base.$fSemigroupMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ck25: // global
           I64[Hp - 72] = sat_sh9a_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sh98_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_sh97_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 38;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 71;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupMaybe_info" {
     GHC.Base.$fSemigroupMaybe_info:
         const GHC.Base.$fSemigroupMaybe_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const Si3a_srt+88;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.234055912 UTC

[section ""data" . GHC.Base.$fMonoidMaybe_$cmconcat_closure" {
     GHC.Base.$fMonoidMaybe_$cmconcat_closure:
         const GHC.Base.$fMonoidMaybe_$cmconcat_info;
 },
 sat_sh9m_entry() //  [R1]
         { []
         }
     {offset
       ck2W: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ck2X; else goto ck2Y;
       ck2X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck2Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh9m_info" {
     sat_sh9m_info:
         const sat_sh9m_entry;
         const 3;
         const 15;
 },
 go_sh9d_entry() //  [R1, R2]
         { []
         }
     {offset
       ck33: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ck34; else goto uk3q;
       ck34: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uk3q: // global
           P64[Sp - 16] = R1;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call _ck2y() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . go_sh9d_info" {
     go_sh9d_info:
         const go_sh9d_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _ck2y() //  []
         { []
         }
     {offset
       ck2y: // global
           _sh9b::P64 = P64[P64[Sp] + 7];
           I64[Sp - 8] = block_ck2B_info;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sh9b::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uk3s; else goto ck2C;
       uk3s: // global
           call _ck2B(R1) args: 0, res: 0, upd: 0;
       ck2C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ck2B() //  [R1]
         { []
         }
     {offset
       ck2B: // global
           if (R1 & 7 == 1) goto ck30; else goto ck31;
       ck30: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ck31: // global
           I64[Sp - 8] = block_ck2H_info;
           _sh9h::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sh9h::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uk3t; else goto ck2I;
       uk3t: // global
           call _ck2H(R1) args: 0, res: 0, upd: 0;
       ck2I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ck2B_info" {
     block_ck2B_info:
         const _ck2B;
         const 2;
         const 30;
 },
 _ck2H() //  [R1]
         { []
         }
     {offset
       ck2H: // global
           _sh9h::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ck3c; else goto ck3e;
       ck3c: // global
           P64[Sp + 24] = _sh9h::P64;
           Sp = Sp + 16;
           call _ck2y() args: 0, res: 0, upd: 0;
       ck3e: // global
           I64[Sp] = block_ck2N_info;
           R2 = _sh9h::P64;
           _sh9i::P64 = R1;
           _sh9j::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 8] = _sh9j::P64;
           P64[Sp + 16] = _sh9i::P64;
           call go_sh9d_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ck2H_info" {
     block_ck2H_info:
         const _ck2H;
         const 3;
         const 30;
 },
 _ck2N() //  [R1]
         { []
         }
     {offset
       ck2N: // global
           if (R1 & 7 == 1) goto ck3i; else goto ck3k;
       ck3i: // global
           R1 = P64[Sp + 16] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ck3k: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto ck3n; else goto ck3m;
       ck3n: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ck3m: // global
           _sh9l::P64 = P64[R1 + 6];
           I64[Hp - 48] = sat_sh9m_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _sh9l::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ck2N_info" {
     block_ck2N_info:
         const _ck2N;
         const 3;
         const 30;
 },
 GHC.Base.$fMonoidMaybe_$cmconcat_entry() //  [R2, R3]
         { []
         }
     {offset
       ck3w: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto ck3A; else goto ck3z;
       ck3A: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidMaybe_$cmconcat_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ck3z: // global
           I64[Hp - 8] = go_sh9d_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go_sh9d_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoidMaybe_$cmconcat_info" {
     GHC.Base.$fMonoidMaybe_$cmconcat_info:
         const GHC.Base.$fMonoidMaybe_$cmconcat_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.247879901 UTC

[section ""data" . GHC.Base.$fMonoidMaybe_closure" {
     GHC.Base.$fMonoidMaybe_closure:
         const GHC.Base.$fMonoidMaybe_info;
         const 0;
 },
 sat_sh9q_entry() //  [R1, R2]
         { []
         }
     {offset
       ck4x: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fMonoidMaybe_$cmconcat_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh9q_info" {
     sat_sh9q_info:
         const sat_sh9q_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_sh9p_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       ck4F: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoidMaybe_$c<>_entry(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sh9p_info" {
     sat_sh9p_info:
         const sat_sh9p_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_sh9o_entry() //  [R1]
         { []
         }
     {offset
       ck4M: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck4N; else goto ck4O;
       ck4N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck4O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fSemigroupMaybe_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh9o_info" {
     sat_sh9o_info:
         const sat_sh9o_entry;
         const 1;
         const 4294967312;
         const Si3a_srt+96;
 },
 GHC.Base.$fMonoidMaybe_entry() //  [R2]
         { []
         }
     {offset
       ck4Q: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto ck4U; else goto ck4T;
       ck4U: // global
           HpAlloc = 96;
           R2 = R2;
           R1 = GHC.Base.$fMonoidMaybe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ck4T: // global
           I64[Hp - 88] = sat_sh9q_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_sh9p_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_sh9o_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = Hp - 70;
           P64[Hp] = Hp - 87;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoidMaybe_info" {
     GHC.Base.$fMonoidMaybe_info:
         const GHC.Base.$fMonoidMaybe_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const Si3a_srt+96;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.256586892 UTC

[section ""data" . GHC.Base.$fMonoidOrdering_$c<>_closure" {
     GHC.Base.$fMonoidOrdering_$c<>_closure:
         const GHC.Base.$fMonoidOrdering_$c<>_info;
 },
 GHC.Base.$fMonoidOrdering_$c<>_entry() //  [R2, R3]
         { []
         }
     {offset
       ck5v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck5w; else goto ck5x;
       ck5w: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoidOrdering_$c<>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ck5x: // global
           I64[Sp - 16] = block_ck5n_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uk5I; else goto ck5o;
       uk5I: // global
           call _ck5n(R1) args: 0, res: 0, upd: 0;
       ck5o: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoidOrdering_$c<>_info" {
     GHC.Base.$fMonoidOrdering_$c<>_info:
         const GHC.Base.$fMonoidOrdering_$c<>_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ck5n() //  [R1]
         { []
         }
     {offset
       ck5n: // global
           _ck5u::P64 = R1 & 7;
           if (_ck5u::P64 < 3) goto uk5H; else goto ck5t;
       uk5H: // global
           if (_ck5u::P64 < 2) goto ck5r; else goto ck5s;
       ck5r: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ck5s: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ck5t: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ck5n_info" {
     block_ck5n_info:
         const _ck5n;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.263170989 UTC

[section ""data" . GHC.Base.$fMonoidOrdering_go_closure" {
     GHC.Base.$fMonoidOrdering_go_closure:
         const GHC.Base.$fMonoidOrdering_go_info;
 },
 GHC.Base.$fMonoidOrdering_go_entry() //  [R2]
         { []
         }
     {offset
       ck6b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ck6c; else goto uk6C;
       ck6c: // global
           R2 = R2;
           R1 = GHC.Base.$fMonoidOrdering_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uk6C: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _ck61() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoidOrdering_go_info" {
     GHC.Base.$fMonoidOrdering_go_info:
         const GHC.Base.$fMonoidOrdering_go_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _ck61() //  []
         { []
         }
     {offset
       ck61: // global
           _sh9u::P64 = P64[Sp];
           I64[Sp] = block_ck64_info;
           R1 = _sh9u::P64;
           if (R1 & 7 != 0) goto uk6E; else goto ck65;
       uk6E: // global
           call _ck64(R1) args: 0, res: 0, upd: 0;
       ck65: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _ck64() //  [R1]
         { []
         }
     {offset
       ck64: // global
           if (R1 & 7 == 1) goto ck68; else goto ck69;
       ck68: // global
           R1 = GHC.Types.EQ_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ck69: // global
           I64[Sp - 8] = block_ck6j_info;
           _sh9x::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sh9x::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uk6F; else goto ck6l;
       uk6F: // global
           call _ck6j(R1) args: 0, res: 0, upd: 0;
       ck6l: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ck64_info" {
     block_ck64_info:
         const _ck64;
         const 0;
         const 30;
 },
 _ck6j() //  [R1]
         { []
         }
     {offset
       ck6j: // global
           _ck6A::P64 = R1 & 7;
           if (_ck6A::P64 < 3) goto uk6B; else goto ck6z;
       uk6B: // global
           if (_ck6A::P64 < 2) goto ck6r; else goto ck6v;
       ck6r: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ck6v: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _ck61() args: 0, res: 0, upd: 0;
       ck6z: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ck6j_info" {
     block_ck6j_info:
         const _ck6j;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.271856005 UTC

[section ""data" . GHC.Base.$fSemigroupOrdering_closure" {
     GHC.Base.$fSemigroupOrdering_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.$fMonoidOrdering_$c<>_closure+2;
         const GHC.Base.$fSemigroupOrdering_$csconcat_closure+1;
         const GHC.Base.$fSemigroupOrdering_$cstimes_closure+1;
         const 0;
 },
 section ""data" . GHC.Base.$fMonoidOrdering_closure" {
     GHC.Base.$fMonoidOrdering_closure:
         const GHC.Base.C:Monoid_con_info;
         const GHC.Base.$fSemigroupOrdering_closure+1;
         const GHC.Types.EQ_closure+2;
         const GHC.Base.$fMonoidOrdering_$c<>_closure+2;
         const GHC.Base.$fMonoidOrdering_go_closure+1;
         const 0;
 },
 section ""data" . GHC.Base.$fSemigroupOrdering_$cstimes_closure" {
     GHC.Base.$fSemigroupOrdering_$cstimes_closure:
         const GHC.Base.$fSemigroupOrdering_$cstimes_info;
         const 0;
 },
 GHC.Base.$fSemigroupOrdering_$cstimes_entry() //  [R2]
         { []
         }
     {offset
       ck7d: // global
           R3 = GHC.Base.$fMonoidOrdering_closure+1;
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroupOrdering_$cstimes_info" {
     GHC.Base.$fSemigroupOrdering_$cstimes_info:
         const GHC.Base.$fSemigroupOrdering_$cstimes_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const Si3a_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.280359468 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$c<>_closure" {
     GHC.Base.$fMonoid(,,,,)_$c<>_closure:
         const GHC.Base.$fMonoid(,,,,)_$c<>_info;
 },
 GHC.Base.$fMonoid(,,,,)_$c<>_slow() //  [R1]
         { []
         }
     {offset
       ck7n: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$fMonoid(,,,,)_$c<>_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2,
                                                   R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_sh9X_entry() //  [R1]
         { []
         }
     {offset
       ck7F: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ck7G; else goto ck7H;
       ck7G: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck7H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh9X_info" {
     sat_sh9X_info:
         const sat_sh9X_entry;
         const 3;
         const 15;
 },
 sat_sh9W_entry() //  [R1]
         { []
         }
     {offset
       ck7M: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ck7N; else goto ck7O;
       ck7N: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck7O: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh9W_info" {
     sat_sh9W_info:
         const sat_sh9W_entry;
         const 3;
         const 15;
 },
 sat_sh9V_entry() //  [R1]
         { []
         }
     {offset
       ck7T: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ck7U; else goto ck7V;
       ck7U: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck7V: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh9V_info" {
     sat_sh9V_info:
         const sat_sh9V_entry;
         const 3;
         const 15;
 },
 sat_sh9U_entry() //  [R1]
         { []
         }
     {offset
       ck80: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ck81; else goto ck82;
       ck81: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck82: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh9U_info" {
     sat_sh9U_info:
         const sat_sh9U_entry;
         const 3;
         const 15;
 },
 sat_sh9T_entry() //  [R1]
         { []
         }
     {offset
       ck87: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ck88; else goto ck89;
       ck88: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck89: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sh9T_info" {
     sat_sh9T_info:
         const sat_sh9T_entry;
         const 3;
         const 15;
 },
 GHC.Base.$fMonoid(,,,,)_$c<>_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ck8a: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ck8c; else goto ck8d;
       ck8c: // global
           R1 = GHC.Base.$fMonoid(,,,,)_$c<>_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       ck8d: // global
           I64[Sp - 40] = block_ck7r_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uk8j; else goto ck7s;
       uk8j: // global
           call _ck7r(R1) args: 0, res: 0, upd: 0;
       ck7s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,,)_$c<>_info" {
     GHC.Base.$fMonoid(,,,,)_$c<>_info:
         const GHC.Base.$fMonoid(,,,,)_$c<>_entry;
         const 0;
         const 14;
         const 30064771072;
         const 0;
         const 7;
         const GHC.Base.$fMonoid(,,,,)_$c<>_slow;
 },
 _ck7r() //  [R1]
         { []
         }
     {offset
       ck7r: // global
           I64[Sp - 32] = block_ck7w_info;
           _sh9I::P64 = P64[R1 + 7];
           _sh9J::P64 = P64[R1 + 15];
           _sh9K::P64 = P64[R1 + 23];
           _sh9L::P64 = P64[R1 + 31];
           _sh9M::P64 = P64[R1 + 39];
           R1 = P64[Sp + 48];
           P64[Sp - 24] = _sh9K::P64;
           P64[Sp - 16] = _sh9L::P64;
           P64[Sp - 8] = _sh9M::P64;
           P64[Sp] = _sh9J::P64;
           P64[Sp + 48] = _sh9I::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uk8i; else goto ck7x;
       uk8i: // global
           call _ck7w(R1) args: 0, res: 0, upd: 0;
       ck7x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ck7r_info" {
     block_ck7r_info:
         const _ck7r;
         const 6;
         const 30;
 },
 _ck7w() //  [R1]
         { []
         }
     {offset
       ck7w: // global
           Hp = Hp + 248;
           if (Hp > HpLim) (likely: False) goto ck8h; else goto ck8g;
       ck8h: // global
           HpAlloc = 248;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ck8g: // global
           _sh9O::P64 = P64[R1 + 7];
           _sh9P::P64 = P64[R1 + 15];
           _sh9Q::P64 = P64[R1 + 23];
           _sh9R::P64 = P64[R1 + 31];
           _sh9S::P64 = P64[R1 + 39];
           I64[Hp - 240] = sat_sh9X_info;
           P64[Hp - 224] = P64[Sp + 64];
           P64[Hp - 216] = P64[Sp + 24];
           P64[Hp - 208] = _sh9S::P64;
           I64[Hp - 200] = sat_sh9W_info;
           P64[Hp - 184] = P64[Sp + 56];
           P64[Hp - 176] = P64[Sp + 16];
           P64[Hp - 168] = _sh9R::P64;
           I64[Hp - 160] = sat_sh9V_info;
           P64[Hp - 144] = P64[Sp + 48];
           P64[Hp - 136] = P64[Sp + 8];
           P64[Hp - 128] = _sh9Q::P64;
           I64[Hp - 120] = sat_sh9U_info;
           P64[Hp - 104] = P64[Sp + 40];
           P64[Hp - 96] = P64[Sp + 32];
           P64[Hp - 88] = _sh9P::P64;
           I64[Hp - 80] = sat_sh9T_info;
           P64[Hp - 64] = P64[Sp + 72];
           P64[Hp - 56] = P64[Sp + 80];
           P64[Hp - 48] = _sh9O::P64;
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = Hp - 80;
           P64[Hp - 24] = Hp - 120;
           P64[Hp - 16] = Hp - 160;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 240;
           R1 = Hp - 39;
           Sp = Sp + 88;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ck7w_info" {
     block_ck7w_info:
         const _ck7w;
         const 10;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.304968169 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$csconcat_closure" {
     GHC.Base.$fMonoid(,,,,)_$csconcat_closure:
         const GHC.Base.$fMonoid(,,,,)_$csconcat_info;
 },
 sat_shaD_entry() //  [R1]
         { []
         }
     {offset
       ckad: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckae; else goto ckaf;
       ckae: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckaf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shaD_info" {
     sat_shaD_info:
         const sat_shaD_entry;
         const 3;
         const 15;
 },
 sat_shaC_entry() //  [R1]
         { []
         }
     {offset
       ckak: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckal; else goto ckam;
       ckal: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckam: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shaC_info" {
     sat_shaC_info:
         const sat_shaC_entry;
         const 3;
         const 15;
 },
 sat_shaB_entry() //  [R1]
         { []
         }
     {offset
       ckar: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckas; else goto ckat;
       ckas: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckat: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shaB_info" {
     sat_shaB_info:
         const sat_shaB_entry;
         const 3;
         const 15;
 },
 sat_shaA_entry() //  [R1]
         { []
         }
     {offset
       ckay: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckaz; else goto ckaA;
       ckaz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckaA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shaA_info" {
     sat_shaA_info:
         const sat_shaA_entry;
         const 3;
         const 15;
 },
 sat_shaz_entry() //  [R1]
         { []
         }
     {offset
       ckaF: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckaG; else goto ckaH;
       ckaG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckaH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shaz_info" {
     sat_shaz_info:
         const sat_shaz_entry;
         const 3;
         const 15;
 },
 $wgo_shad_entry() //  [R1, R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ckaM: // global
           if ((Sp + -120) < SpLim) (likely: False) goto ckaN; else goto ckaO;
       ckaN: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ckaO: // global
           I64[Sp - 88] = block_ck9U_info;
           _shad::P64 = R1;
           _sh9Y::P64 = P64[R1 + 2];
           _sh9Z::P64 = P64[R1 + 10];
           _sha0::P64 = P64[R1 + 18];
           _sha1::P64 = P64[R1 + 26];
           _sha2::P64 = P64[R1 + 34];
           R1 = P64[Sp];
           P64[Sp - 80] = _sh9Z::P64;
           P64[Sp - 72] = _sha0::P64;
           P64[Sp - 64] = _sha1::P64;
           P64[Sp - 56] = _sha2::P64;
           P64[Sp - 48] = _shad::P64;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = _sh9Y::P64;
           Sp = Sp - 88;
           if (R1 & 7 != 0) goto ukaZ; else goto ck9V;
       ukaZ: // global
           call _ck9U(R1) args: 0, res: 0, upd: 0;
       ck9V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . $wgo_shad_info" {
     $wgo_shad_info:
         const $wgo_shad_entry;
         const 5;
         const 8;
         const 25769803802;
 },
 _ck9U() //  [R1]
         { []
         }
     {offset
       ck9U: // global
           if (R1 & 7 == 1) goto ckaJ; else goto ckaK;
       ckaJ: // global
           R5 = P64[Sp + 80];
           R4 = P64[Sp + 72];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 48];
           Sp = Sp + 96;
           call (I64[P64[Sp]])(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckaK: // global
           I64[Sp - 8] = block_cka0_info;
           _sham::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sham::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ukaX; else goto cka1;
       ukaX: // global
           call _cka0(R1) args: 0, res: 0, upd: 0;
       cka1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ck9U_info" {
     block_ck9U_info:
         const _ck9U;
         const 11;
         const 30;
 },
 _cka0() //  [R1]
         { []
         }
     {offset
       cka0: // global
           _sham::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cka5_info;
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 48];
           P64[Sp] = _sham::P64;
           call $wgo_shad_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cka0_info" {
     block_cka0_info:
         const _cka0;
         const 12;
         const 30;
 },
 _cka5() //  [R1, R2, R3, R4, R5]
         { []
         }
     {offset
       cka5: // global
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           P64[Sp] = R2;
           P64[Sp + 40] = R1;
           Sp = Sp - 32;
           call _cka6() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cka5_info" {
     block_cka5_info:
         const _cka5;
         const 1035;
         const 30;
 },
 _cka6() //  []
         { []
         }
     {offset
       cka6: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto ckaV; else goto ckaU;
       ckaV: // global
           HpAlloc = 200;
           I64[Sp] = block_cka6_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ckaU: // global
           I64[Hp - 192] = sat_shaD_info;
           P64[Hp - 176] = P64[Sp + 64];
           P64[Hp - 168] = P64[Sp + 112];
           P64[Hp - 160] = P64[Sp + 24];
           I64[Hp - 152] = sat_shaC_info;
           P64[Hp - 136] = P64[Sp + 56];
           P64[Hp - 128] = P64[Sp + 104];
           P64[Hp - 120] = P64[Sp + 16];
           I64[Hp - 112] = sat_shaB_info;
           P64[Hp - 96] = P64[Sp + 48];
           P64[Hp - 88] = P64[Sp + 96];
           P64[Hp - 80] = P64[Sp + 8];
           I64[Hp - 72] = sat_shaA_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = P64[Sp + 88];
           P64[Hp - 40] = P64[Sp + 32];
           I64[Hp - 32] = sat_shaz_info;
           P64[Hp - 16] = P64[Sp + 120];
           P64[Hp - 8] = P64[Sp + 80];
           P64[Hp] = P64[Sp + 72];
           R5 = Hp - 192;
           R4 = Hp - 152;
           R3 = Hp - 112;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 128;
           call (I64[P64[Sp]])(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cka6_info" {
     block_cka6_info:
         const _cka6;
         const 15;
         const 30;
 },
 GHC.Base.$fMonoid(,,,,)_$csconcat_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ckb0: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckb6; else goto ckb7;
       ckb6: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$csconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ckb7: // global
           I64[Sp - 40] = block_ck9F_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ukbh; else goto ck9G;
       ukbh: // global
           call _ck9F(R1) args: 0, res: 0, upd: 0;
       ck9G: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,,)_$csconcat_info" {
     GHC.Base.$fMonoid(,,,,)_$csconcat_info:
         const GHC.Base.$fMonoid(,,,,)_$csconcat_entry;
         const 0;
         const 14;
         const 25769803802;
 },
 _ck9F() //  [R1]
         { []
         }
     {offset
       ck9F: // global
           I64[Sp - 8] = block_ck9K_info;
           _sha6::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _sha6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ukbg; else goto ck9L;
       ukbg: // global
           call _ck9K(R1) args: 0, res: 0, upd: 0;
       ck9L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ck9F_info" {
     block_ck9F_info:
         const _ck9F;
         const 5;
         const 30;
 },
 _ck9K() //  [R1]
         { []
         }
     {offset
       ck9K: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ckbb; else goto ckba;
       ckbb: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckba: // global
           _sha8::P64 = P64[R1 + 7];
           _sha9::P64 = P64[R1 + 15];
           _shaa::P64 = P64[R1 + 23];
           _shab::P64 = P64[R1 + 31];
           _shac::P64 = P64[R1 + 39];
           I64[Hp - 40] = $wgo_shad_info;
           P64[Hp - 32] = P64[Sp + 48];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = P64[Sp + 40];
           I64[Sp + 48] = block_ckb1_info;
           R6 = _shac::P64;
           R5 = _shab::P64;
           R4 = _shaa::P64;
           R3 = _sha9::P64;
           R2 = _sha8::P64;
           R1 = Hp - 34;
           P64[Sp + 40] = P64[Sp + 8];
           Sp = Sp + 40;
           call $wgo_shad_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ck9K_info" {
     block_ck9K_info:
         const _ck9K;
         const 6;
         const 30;
 },
 _ckb1() //  [R1, R2, R3, R4, R5]
         { []
         }
     {offset
       ckb1: // global
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           P64[Sp] = R1;
           Sp = Sp - 40;
           call _ckb2() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ckb1_info" {
     block_ckb1_info:
         const _ckb1;
         const 0;
         const 30;
 },
 _ckb2() //  []
         { []
         }
     {offset
       ckb2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ckbe; else goto ckbd;
       ckbe: // global
           HpAlloc = 48;
           I64[Sp] = block_ckb2_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       ckbd: // global
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = P64[Sp + 40];
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = P64[Sp + 32];
           R1 = Hp - 39;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckb2_info" {
     block_ckb2_info:
         const _ckb2;
         const 5;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.338030865 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cstimes_closure" {
     GHC.Base.$fMonoid(,,,,)_$cstimes_closure:
         const GHC.Base.$fMonoid(,,,,)_$cstimes_info;
 },
 GHC.Base.$fMonoid(,,,,)_$cstimes_slow() //  [R1]
         { []
         }
     {offset
       ckdj: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$fMonoid(,,,,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2,
                                                       R1) args: 32, res: 0, upd: 8;
     }
 },
 sat_shb2_entry() //  [R1]
         { []
         }
     {offset
       ckdw: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckdx; else goto ckdy;
       ckdx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckdy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shb2_info" {
     sat_shb2_info:
         const sat_shb2_entry;
         const 4;
         const 15;
 },
 sat_shb1_entry() //  [R1]
         { []
         }
     {offset
       ckdD: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckdE; else goto ckdF;
       ckdE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckdF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shb1_info" {
     sat_shb1_info:
         const sat_shb1_entry;
         const 4;
         const 15;
 },
 sat_shb0_entry() //  [R1]
         { []
         }
     {offset
       ckdK: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckdL; else goto ckdM;
       ckdL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckdM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shb0_info" {
     sat_shb0_info:
         const sat_shb0_entry;
         const 4;
         const 15;
 },
 sat_shaZ_entry() //  [R1]
         { []
         }
     {offset
       ckdR: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckdS; else goto ckdT;
       ckdS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckdT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shaZ_info" {
     sat_shaZ_info:
         const sat_shaZ_entry;
         const 4;
         const 15;
 },
 sat_shaY_entry() //  [R1]
         { []
         }
     {offset
       ckdY: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckdZ; else goto cke0;
       ckdZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cke0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shaY_info" {
     sat_shaY_info:
         const sat_shaY_entry;
         const 4;
         const 15;
 },
 GHC.Base.$fMonoid(,,,,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cke1: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cke3; else goto cke4;
       cke3: // global
           R1 = GHC.Base.$fMonoid(,,,,)_$cstimes_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 72, res: 0, upd: 8;
       cke4: // global
           I64[Sp - 40] = block_ckdn_info;
           R1 = P64[Sp + 16];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp + 16] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uke8; else goto ckdo;
       uke8: // global
           call _ckdn(R1) args: 0, res: 0, upd: 0;
       ckdo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,,)_$cstimes_info" {
     GHC.Base.$fMonoid(,,,,)_$cstimes_info:
         const GHC.Base.$fMonoid(,,,,)_$cstimes_entry;
         const 0;
         const 14;
         const 34359738368;
         const 0;
         const 8;
         const GHC.Base.$fMonoid(,,,,)_$cstimes_slow;
 },
 _ckdn() //  [R1]
         { []
         }
     {offset
       ckdn: // global
           Hp = Hp + 288;
           if (Hp > HpLim) (likely: False) goto cke7; else goto cke6;
       cke7: // global
           HpAlloc = 288;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cke6: // global
           _shaT::P64 = P64[R1 + 7];
           _shaU::P64 = P64[R1 + 15];
           _shaV::P64 = P64[R1 + 23];
           _shaW::P64 = P64[R1 + 31];
           _shaX::P64 = P64[R1 + 39];
           I64[Hp - 280] = sat_shb2_info;
           P64[Hp - 264] = P64[Sp + 32];
           _shaP::P64 = P64[Sp + 40];
           P64[Hp - 256] = _shaP::P64;
           _shaQ::P64 = P64[Sp + 48];
           P64[Hp - 248] = _shaQ::P64;
           P64[Hp - 240] = _shaX::P64;
           I64[Hp - 232] = sat_shb1_info;
           P64[Hp - 216] = P64[Sp + 24];
           P64[Hp - 208] = _shaP::P64;
           P64[Hp - 200] = _shaQ::P64;
           P64[Hp - 192] = _shaW::P64;
           I64[Hp - 184] = sat_shb0_info;
           P64[Hp - 168] = P64[Sp + 16];
           P64[Hp - 160] = _shaP::P64;
           P64[Hp - 152] = _shaQ::P64;
           P64[Hp - 144] = _shaV::P64;
           I64[Hp - 136] = sat_shaZ_info;
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _shaP::P64;
           P64[Hp - 104] = _shaQ::P64;
           P64[Hp - 96] = _shaU::P64;
           I64[Hp - 88] = sat_shaY_info;
           P64[Hp - 72] = P64[Sp + 56];
           P64[Hp - 64] = _shaP::P64;
           P64[Hp - 56] = _shaQ::P64;
           P64[Hp - 48] = _shaT::P64;
           I64[Hp - 40] = (,,,,)_con_info;
           P64[Hp - 32] = Hp - 88;
           P64[Hp - 24] = Hp - 136;
           P64[Hp - 16] = Hp - 184;
           P64[Hp - 8] = Hp - 232;
           P64[Hp] = Hp - 280;
           R1 = Hp - 39;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckdn_info" {
     block_ckdn_info:
         const _ckdn;
         const 7;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.355251921 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,,)_closure" {
     GHC.Base.$fSemigroup(,,,,)_closure:
         const GHC.Base.$fSemigroup(,,,,)_info;
 },
 sat_shba_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       ckfu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ckfv; else goto ckfw;
       ckfv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckfw: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 24;
           call GHC.Base.$fMonoid(,,,,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shba_info" {
     sat_shba_info:
         const sat_shba_entry;
         const 5;
         const 8;
         const 12884901911;
 },
 sat_shb9_entry() //  [R1, R2]
         { []
         }
     {offset
       ckfC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ckfD; else goto ckfE;
       ckfD: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckfE: // global
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _B1::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,,)_$csconcat_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shb9_info" {
     sat_shb9_info:
         const sat_shb9_entry;
         const 5;
         const 8;
         const 4294967301;
 },
 sat_shb8_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       ckfK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckfL; else goto ckfM;
       ckfL: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckfM: // global
           R6 = P64[R1 + 38];
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           _B2::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$c<>_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shb8_info" {
     sat_shb8_info:
         const sat_shb8_entry;
         const 5;
         const 8;
         const 8589934607;
 },
 GHC.Base.$fSemigroup(,,,,)_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ckfO: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ckfS; else goto ckfR;
       ckfS: // global
           HpAlloc = 176;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,,,)_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckfR: // global
           I64[Hp - 168] = sat_shba_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           P64[Hp - 136] = R5;
           P64[Hp - 128] = R6;
           I64[Hp - 120] = sat_shb9_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           P64[Hp - 88] = R5;
           P64[Hp - 80] = R6;
           I64[Hp - 72] = sat_shb8_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           P64[Hp - 32] = R6;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 70;
           P64[Hp - 8] = Hp - 119;
           P64[Hp] = Hp - 165;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,,,,)_info" {
     GHC.Base.$fSemigroup(,,,,)_info:
         const GHC.Base.$fSemigroup(,,,,)_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.372544968 UTC

[section ""data" . GHC.Base.$w$cp1Monoid1_closure" {
     GHC.Base.$w$cp1Monoid1_closure:
         const GHC.Base.$w$cp1Monoid1_info;
 },
 sat_shbw_entry() //  [R1]
         { []
         }
     {offset
       ckgp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckgq; else goto ckgr;
       ckgq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckgr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shbw_info" {
     sat_shbw_info:
         const sat_shbw_entry;
         const 1;
         const 16;
 },
 sat_shbv_entry() //  [R1]
         { []
         }
     {offset
       ckgw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckgx; else goto ckgy;
       ckgx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckgy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shbv_info" {
     sat_shbv_info:
         const sat_shbv_entry;
         const 1;
         const 16;
 },
 sat_shbu_entry() //  [R1]
         { []
         }
     {offset
       ckgD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckgE; else goto ckgF;
       ckgE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckgF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shbu_info" {
     sat_shbu_info:
         const sat_shbu_entry;
         const 1;
         const 16;
 },
 sat_shbt_entry() //  [R1]
         { []
         }
     {offset
       ckgK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckgL; else goto ckgM;
       ckgL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckgM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shbt_info" {
     sat_shbt_info:
         const sat_shbt_entry;
         const 1;
         const 16;
 },
 sat_shbs_entry() //  [R1]
         { []
         }
     {offset
       ckgR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckgS; else goto ckgT;
       ckgS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckgT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shbs_info" {
     sat_shbs_info:
         const sat_shbs_entry;
         const 1;
         const 16;
 },
 sat_shbx_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       ckgZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ckh0; else goto ckh1;
       ckh0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckh1: // global
           R6 = P64[R1 + 37];
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           _B3::P64 = R2;
           R2 = P64[R1 + 5];
           P64[Sp - 24] = _B3::P64;
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 24;
           call GHC.Base.$fMonoid(,,,,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shbx_info" {
     sat_shbx_info:
         const sat_shbx_entry;
         const 5;
         const 8;
         const 12884901911;
 },
 sat_shbq_entry() //  [R1]
         { []
         }
     {offset
       ckh6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckh7; else goto ckh8;
       ckh7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckh8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shbq_info" {
     sat_shbq_info:
         const sat_shbq_entry;
         const 1;
         const 16;
 },
 sat_shbp_entry() //  [R1]
         { []
         }
     {offset
       ckhd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckhe; else goto ckhf;
       ckhe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckhf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shbp_info" {
     sat_shbp_info:
         const sat_shbp_entry;
         const 1;
         const 16;
 },
 sat_shbo_entry() //  [R1]
         { []
         }
     {offset
       ckhk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckhl; else goto ckhm;
       ckhl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckhm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shbo_info" {
     sat_shbo_info:
         const sat_shbo_entry;
         const 1;
         const 16;
 },
 sat_shbn_entry() //  [R1]
         { []
         }
     {offset
       ckhr: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckhs; else goto ckht;
       ckhs: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckht: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shbn_info" {
     sat_shbn_info:
         const sat_shbn_entry;
         const 1;
         const 16;
 },
 sat_shbm_entry() //  [R1]
         { []
         }
     {offset
       ckhy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckhz; else goto ckhA;
       ckhz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckhA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shbm_info" {
     sat_shbm_info:
         const sat_shbm_entry;
         const 1;
         const 16;
 },
 sat_shbr_entry() //  [R1, R2]
         { []
         }
     {offset
       ckhG: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ckhH; else goto ckhI;
       ckhH: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckhI: // global
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           _B1::P64 = R2;
           R2 = P64[R1 + 7];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,,)_$csconcat_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shbr_info" {
     sat_shbr_info:
         const sat_shbr_entry;
         const 5;
         const 8;
         const 4294967301;
 },
 sat_shbk_entry() //  [R1]
         { []
         }
     {offset
       ckhN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckhO; else goto ckhP;
       ckhO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckhP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shbk_info" {
     sat_shbk_info:
         const sat_shbk_entry;
         const 1;
         const 16;
 },
 sat_shbj_entry() //  [R1]
         { []
         }
     {offset
       ckhU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckhV; else goto ckhW;
       ckhV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckhW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shbj_info" {
     sat_shbj_info:
         const sat_shbj_entry;
         const 1;
         const 16;
 },
 sat_shbi_entry() //  [R1]
         { []
         }
     {offset
       cki1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cki2; else goto cki3;
       cki2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cki3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shbi_info" {
     sat_shbi_info:
         const sat_shbi_entry;
         const 1;
         const 16;
 },
 sat_shbh_entry() //  [R1]
         { []
         }
     {offset
       cki8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cki9; else goto ckia;
       cki9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckia: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shbh_info" {
     sat_shbh_info:
         const sat_shbh_entry;
         const 1;
         const 16;
 },
 sat_shbg_entry() //  [R1]
         { []
         }
     {offset
       ckif: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckig; else goto ckih;
       ckig: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckih: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shbg_info" {
     sat_shbg_info:
         const sat_shbg_entry;
         const 1;
         const 16;
 },
 sat_shbl_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       ckin: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckio; else goto ckip;
       ckio: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckip: // global
           R6 = P64[R1 + 38];
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           _B2::P64 = R2;
           R2 = P64[R1 + 6];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$c<>_entry(R6,
                                                   R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shbl_info" {
     sat_shbl_info:
         const sat_shbl_entry;
         const 5;
         const 8;
         const 8589934607;
 },
 GHC.Base.$w$cp1Monoid1_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ckiq: // global
           Hp = Hp + 504;
           if (Hp > HpLim) (likely: False) goto ckiu; else goto ckit;
       ckiu: // global
           HpAlloc = 504;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$cp1Monoid1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckit: // global
           I64[Hp - 496] = sat_shbw_info;
           P64[Hp - 480] = R6;
           I64[Hp - 472] = sat_shbv_info;
           P64[Hp - 456] = R5;
           I64[Hp - 448] = sat_shbu_info;
           P64[Hp - 432] = R4;
           I64[Hp - 424] = sat_shbt_info;
           P64[Hp - 408] = R3;
           I64[Hp - 400] = sat_shbs_info;
           P64[Hp - 384] = R2;
           I64[Hp - 376] = sat_shbx_info;
           P64[Hp - 368] = Hp - 400;
           P64[Hp - 360] = Hp - 424;
           P64[Hp - 352] = Hp - 448;
           P64[Hp - 344] = Hp - 472;
           P64[Hp - 336] = Hp - 496;
           I64[Hp - 328] = sat_shbq_info;
           P64[Hp - 312] = R6;
           I64[Hp - 304] = sat_shbp_info;
           P64[Hp - 288] = R5;
           I64[Hp - 280] = sat_shbo_info;
           P64[Hp - 264] = R4;
           I64[Hp - 256] = sat_shbn_info;
           P64[Hp - 240] = R3;
           I64[Hp - 232] = sat_shbm_info;
           P64[Hp - 216] = R2;
           I64[Hp - 208] = sat_shbr_info;
           P64[Hp - 200] = Hp - 232;
           P64[Hp - 192] = Hp - 256;
           P64[Hp - 184] = Hp - 280;
           P64[Hp - 176] = Hp - 304;
           P64[Hp - 168] = Hp - 328;
           I64[Hp - 160] = sat_shbk_info;
           P64[Hp - 144] = R6;
           I64[Hp - 136] = sat_shbj_info;
           P64[Hp - 120] = R5;
           I64[Hp - 112] = sat_shbi_info;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_shbh_info;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_shbg_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_shbl_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 136;
           P64[Hp] = Hp - 160;
           R3 = Hp - 373;
           R2 = Hp - 207;
           R1 = Hp - 38;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$cp1Monoid1_info" {
     GHC.Base.$w$cp1Monoid1_info:
         const GHC.Base.$w$cp1Monoid1_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.407038624 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,,,,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,,,,)_$cp1Monoid_info;
 },
 GHC.Base.$fMonoid(,,,,)_$cp1Monoid_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ckkD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ckkE; else goto ckkF;
       ckkE: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckkF: // global
           I64[Sp - 8] = block_ckkA_info;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid1_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,,)_$cp1Monoid_info" {
     GHC.Base.$fMonoid(,,,,)_$cp1Monoid_info:
         const GHC.Base.$fMonoid(,,,,)_$cp1Monoid_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _ckkA() //  [R1, R2, R3]
         { []
         }
     {offset
       ckkA: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ckkI; else goto ckkH;
       ckkI: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       ckkH: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckkA_info" {
     block_ckkA_info:
         const _ckkA;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.412715373 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,,,,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,,,,)_$cmappend_info;
 },
 GHC.Base.$fMonoid(,,,,)_$cmappend_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ckl0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ckl1; else goto ckl2;
       ckl1: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cmappend_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckl2: // global
           I64[Sp - 8] = block_ckkY_info;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid1_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,,)_$cmappend_info" {
     GHC.Base.$fMonoid(,,,,)_$cmappend_info:
         const GHC.Base.$fMonoid(,,,,)_$cmappend_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _ckkY() //  [R1]
         { []
         }
     {offset
       ckkY: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckkY_info" {
     block_ckkY_info:
         const _ckkY;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.422032751 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,,,,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,,,,)_$cmconcat_info;
 },
 k_shbV_entry() //  [R1]
         { []
         }
     {offset
       cklo: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cklp; else goto cklq;
       cklp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cklq: // global
           I64[Sp - 8] = block_ckll_info;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid1_entry(R6,
                                             R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . k_shbV_info" {
     k_shbV_info:
         const k_shbV_entry;
         const 5;
         const 15;
 },
 _ckll() //  [R1, R2, R3]
         { []
         }
     {offset
       ckll: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cklt; else goto ckls;
       cklt: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       ckls: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckll_info" {
     block_ckll_info:
         const _ckll;
         const 0;
         const 30;
 },
 k1_shc0_entry() //  [R1]
         { []
         }
     {offset
       ckly: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cklz; else goto cklA;
       cklz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cklA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . k1_shc0_info" {
     k1_shc0_info:
         const k1_shc0_entry;
         const 1;
         const 16;
 },
 z_shc1_entry() //  [R1]
         { []
         }
     {offset
       cklF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cklG; else goto cklH;
       cklG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cklH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z_shc1_info" {
     z_shc1_info:
         const z_shc1_entry;
         const 1;
         const 16;
 },
 z1_shc2_entry() //  [R1]
         { []
         }
     {offset
       cklM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cklN; else goto cklO;
       cklN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cklO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z1_shc2_info" {
     z1_shc2_info:
         const z1_shc2_entry;
         const 1;
         const 16;
 },
 z2_shc3_entry() //  [R1]
         { []
         }
     {offset
       cklT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cklU; else goto cklV;
       cklU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cklV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z2_shc3_info" {
     z2_shc3_info:
         const z2_shc3_entry;
         const 1;
         const 16;
 },
 z3_shc4_entry() //  [R1]
         { []
         }
     {offset
       ckm0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckm1; else goto ckm2;
       ckm1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckm2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z3_shc4_info" {
     z3_shc4_info:
         const z3_shc4_entry;
         const 1;
         const 16;
 },
 z4_shc5_entry() //  [R1]
         { []
         }
     {offset
       ckm7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckm8; else goto ckm9;
       ckm8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckm9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z4_shc5_info" {
     z4_shc5_info:
         const z4_shc5_entry;
         const 1;
         const 16;
 },
 go_shc7_entry() //  [R1, R2]
         { []
         }
     {offset
       ckmn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ckmo; else goto ckmp;
       ckmo: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckmp: // global
           I64[Sp - 32] = block_ckmg_info;
           _shc7::P64 = R1;
           _shc0::P64 = P64[R1 + 7];
           _shc6::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _shc0::P64;
           P64[Sp - 16] = _shc6::P64;
           P64[Sp - 8] = _shc7::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ukmz; else goto ckmh;
       ukmz: // global
           call _ckmg(R1) args: 0, res: 0, upd: 0;
       ckmh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_shc7_info" {
     go_shc7_info:
         const go_shc7_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _ckmg() //  [R1]
         { []
         }
     {offset
       ckmg: // global
           if (R1 & 7 == 1) goto ckmk; else goto ckml;
       ckmk: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ckml: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ckmy; else goto ckmx;
       ckmy: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckmx: // global
           _shca::P64 = P64[R1 + 6];
           _shcb::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _shcb::P64;
           R3 = Hp - 24;
           R2 = _shca::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckmg_info" {
     block_ckmg_info:
         const _ckmg;
         const 3;
         const 30;
 },
 GHC.Base.$fMonoid(,,,,)_$cmconcat_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ckmA: // global
           Hp = Hp + 272;
           if (Hp > HpLim) (likely: False) goto ckmE; else goto ckmD;
       ckmE: // global
           HpAlloc = 272;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_$cmconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckmD: // global
           I64[Hp - 264] = k_shbV_info;
           P64[Hp - 248] = R2;
           P64[Hp - 240] = R3;
           P64[Hp - 232] = R4;
           P64[Hp - 224] = R5;
           P64[Hp - 216] = R6;
           I64[Hp - 208] = k1_shc0_info;
           P64[Hp - 192] = Hp - 264;
           I64[Hp - 184] = z_shc1_info;
           P64[Hp - 168] = R2;
           I64[Hp - 160] = z1_shc2_info;
           P64[Hp - 144] = R3;
           I64[Hp - 136] = z2_shc3_info;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = z3_shc4_info;
           P64[Hp - 96] = R5;
           I64[Hp - 88] = z4_shc5_info;
           P64[Hp - 72] = R6;
           I64[Hp - 64] = (,,,,)_con_info;
           P64[Hp - 56] = Hp - 184;
           P64[Hp - 48] = Hp - 160;
           P64[Hp - 40] = Hp - 136;
           P64[Hp - 32] = Hp - 112;
           P64[Hp - 24] = Hp - 88;
           I64[Hp - 16] = go_shc7_info;
           P64[Hp - 8] = Hp - 208;
           P64[Hp] = Hp - 63;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,,)_$cmconcat_info" {
     GHC.Base.$fMonoid(,,,,)_$cmconcat_info:
         const GHC.Base.$fMonoid(,,,,)_$cmconcat_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.445860823 UTC

[section ""data" . GHC.Base.$fMonoid(,,,,)_closure" {
     GHC.Base.$fMonoid(,,,,)_closure:
         const GHC.Base.$fMonoid(,,,,)_info;
 },
 sat_shcl_entry() //  [R1]
         { []
         }
     {offset
       cko1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cko2; else goto cko3;
       cko2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cko3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cmconcat_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shcl_info" {
     sat_shcl_info:
         const sat_shcl_entry;
         const 5;
         const 15;
 },
 sat_shck_entry() //  [R1]
         { []
         }
     {offset
       cko8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cko9; else goto ckoa;
       cko9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckoa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cmappend_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shck_info" {
     sat_shck_info:
         const sat_shck_entry;
         const 5;
         const 15;
 },
 sat_shcj_entry() //  [R1]
         { []
         }
     {offset
       ckof: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckog; else goto ckoh;
       ckog: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckoh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cmempty_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shcj_info" {
     sat_shcj_info:
         const sat_shcj_entry;
         const 5;
         const 15;
 },
 sat_shci_entry() //  [R1]
         { []
         }
     {offset
       ckom: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckon; else goto ckoo;
       ckon: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckoo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R6 = P64[R1 + 48];
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,,)_$cp1Monoid_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shci_info" {
     sat_shci_info:
         const sat_shci_entry;
         const 5;
         const 15;
 },
 GHC.Base.$fMonoid(,,,,)_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ckoq: // global
           Hp = Hp + 264;
           if (Hp > HpLim) (likely: False) goto ckou; else goto ckot;
       ckou: // global
           HpAlloc = 264;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,,)_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckot: // global
           I64[Hp - 256] = sat_shcl_info;
           P64[Hp - 240] = R2;
           P64[Hp - 232] = R3;
           P64[Hp - 224] = R4;
           P64[Hp - 216] = R5;
           P64[Hp - 208] = R6;
           I64[Hp - 200] = sat_shck_info;
           P64[Hp - 184] = R2;
           P64[Hp - 176] = R3;
           P64[Hp - 168] = R4;
           P64[Hp - 160] = R5;
           P64[Hp - 152] = R6;
           I64[Hp - 144] = sat_shcj_info;
           P64[Hp - 128] = R2;
           P64[Hp - 120] = R3;
           P64[Hp - 112] = R4;
           P64[Hp - 104] = R5;
           P64[Hp - 96] = R6;
           I64[Hp - 88] = sat_shci_info;
           P64[Hp - 72] = R2;
           P64[Hp - 64] = R3;
           P64[Hp - 56] = R4;
           P64[Hp - 48] = R5;
           P64[Hp - 40] = R6;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 88;
           P64[Hp - 16] = Hp - 144;
           P64[Hp - 8] = Hp - 200;
           P64[Hp] = Hp - 256;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,,)_info" {
     GHC.Base.$fMonoid(,,,,)_info:
         const GHC.Base.$fMonoid(,,,,)_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.460257222 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$c<>_closure" {
     GHC.Base.$fMonoid(,,,)_$c<>_closure:
         const GHC.Base.$fMonoid(,,,)_$c<>_info;
 },
 sat_shcF_entry() //  [R1]
         { []
         }
     {offset
       ckpl: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckpm; else goto ckpn;
       ckpm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckpn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shcF_info" {
     sat_shcF_info:
         const sat_shcF_entry;
         const 3;
         const 15;
 },
 sat_shcE_entry() //  [R1]
         { []
         }
     {offset
       ckps: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckpt; else goto ckpu;
       ckpt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckpu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shcE_info" {
     sat_shcE_info:
         const sat_shcE_entry;
         const 3;
         const 15;
 },
 sat_shcD_entry() //  [R1]
         { []
         }
     {offset
       ckpz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckpA; else goto ckpB;
       ckpA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckpB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shcD_info" {
     sat_shcD_info:
         const sat_shcD_entry;
         const 3;
         const 15;
 },
 sat_shcC_entry() //  [R1]
         { []
         }
     {offset
       ckpG: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckpH; else goto ckpI;
       ckpH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckpI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shcC_info" {
     sat_shcC_info:
         const sat_shcC_entry;
         const 3;
         const 15;
 },
 GHC.Base.$fMonoid(,,,)_$c<>_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ckpJ: // global
           if ((Sp + -64) < SpLim) (likely: False) goto ckpL; else goto ckpM;
       ckpL: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$c<>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ckpM: // global
           I64[Sp - 40] = block_ckp7_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ukpS; else goto ckp8;
       ukpS: // global
           call _ckp7(R1) args: 0, res: 0, upd: 0;
       ckp8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,)_$c<>_info" {
     GHC.Base.$fMonoid(,,,)_$c<>_info:
         const GHC.Base.$fMonoid(,,,)_$c<>_entry;
         const 0;
         const 14;
         const 25769803802;
 },
 _ckp7() //  [R1]
         { []
         }
     {offset
       ckp7: // global
           I64[Sp - 24] = block_ckpc_info;
           _shct::P64 = P64[R1 + 7];
           _shcu::P64 = P64[R1 + 15];
           _shcv::P64 = P64[R1 + 23];
           _shcw::P64 = P64[R1 + 31];
           R1 = P64[Sp + 40];
           P64[Sp - 16] = _shcv::P64;
           P64[Sp - 8] = _shcw::P64;
           P64[Sp] = _shcu::P64;
           P64[Sp + 40] = _shct::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ukpR; else goto ckpd;
       ukpR: // global
           call _ckpc(R1) args: 0, res: 0, upd: 0;
       ckpd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ckp7_info" {
     block_ckp7_info:
         const _ckp7;
         const 5;
         const 30;
 },
 _ckpc() //  [R1]
         { []
         }
     {offset
       ckpc: // global
           Hp = Hp + 200;
           if (Hp > HpLim) (likely: False) goto ckpQ; else goto ckpP;
       ckpQ: // global
           HpAlloc = 200;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckpP: // global
           _shcy::P64 = P64[R1 + 7];
           _shcz::P64 = P64[R1 + 15];
           _shcA::P64 = P64[R1 + 23];
           _shcB::P64 = P64[R1 + 31];
           I64[Hp - 192] = sat_shcF_info;
           P64[Hp - 176] = P64[Sp + 56];
           P64[Hp - 168] = P64[Sp + 16];
           P64[Hp - 160] = _shcB::P64;
           I64[Hp - 152] = sat_shcE_info;
           P64[Hp - 136] = P64[Sp + 48];
           P64[Hp - 128] = P64[Sp + 8];
           P64[Hp - 120] = _shcA::P64;
           I64[Hp - 112] = sat_shcD_info;
           P64[Hp - 96] = P64[Sp + 40];
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = _shcz::P64;
           I64[Hp - 72] = sat_shcC_info;
           P64[Hp - 56] = P64[Sp + 32];
           P64[Hp - 48] = P64[Sp + 64];
           P64[Hp - 40] = _shcy::P64;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 152;
           P64[Hp] = Hp - 192;
           R1 = Hp - 31;
           Sp = Sp + 72;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckpc_info" {
     block_ckpc_info:
         const _ckpc;
         const 8;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.481897581 UTC

[section ""data" . GHC.Base.$w$csconcat2_closure" {
     GHC.Base.$w$csconcat2_closure:
         const GHC.Base.$w$csconcat2_info;
 },
 GHC.Base.$w$csconcat2_slow() //  [R1]
         { []
         }
     {offset
       ckqX: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$w$csconcat2_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2,
                                            R1) args: 40, res: 0, upd: 8;
     }
 },
 sat_shdb_entry() //  [R1]
         { []
         }
     {offset
       ckrn: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckro; else goto ckrp;
       ckro: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckrp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shdb_info" {
     sat_shdb_info:
         const sat_shdb_entry;
         const 3;
         const 15;
 },
 sat_shda_entry() //  [R1]
         { []
         }
     {offset
       ckru: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckrv; else goto ckrw;
       ckrv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckrw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shda_info" {
     sat_shda_info:
         const sat_shda_entry;
         const 3;
         const 15;
 },
 sat_shd9_entry() //  [R1]
         { []
         }
     {offset
       ckrB: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckrC; else goto ckrD;
       ckrC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckrD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shd9_info" {
     sat_shd9_info:
         const sat_shd9_entry;
         const 3;
         const 15;
 },
 sat_shd8_entry() //  [R1]
         { []
         }
     {offset
       ckrI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckrJ; else goto ckrK;
       ckrJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckrK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shd8_info" {
     sat_shd8_info:
         const sat_shd8_entry;
         const 3;
         const 15;
 },
 $wgo_shcP_entry() //  [R1, R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ckrP: // global
           if ((Sp + -88) < SpLim) (likely: False) goto ckrQ; else goto ckrR;
       ckrQ: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckrR: // global
           I64[Sp - 80] = block_ckr6_info;
           _shcP::P64 = R1;
           _shcG::P64 = P64[R1 + 3];
           _shcH::P64 = P64[R1 + 11];
           _shcI::P64 = P64[R1 + 19];
           _shcJ::P64 = P64[R1 + 27];
           R1 = R6;
           P64[Sp - 72] = _shcG::P64;
           P64[Sp - 64] = _shcH::P64;
           P64[Sp - 56] = _shcI::P64;
           P64[Sp - 48] = _shcJ::P64;
           P64[Sp - 40] = _shcP::P64;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 80;
           if (R1 & 7 != 0) goto uks0; else goto ckr7;
       uks0: // global
           call _ckr6(R1) args: 0, res: 0, upd: 0;
       ckr7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . $wgo_shcP_info" {
     $wgo_shcP_info:
         const $wgo_shcP_entry;
         const 4;
         const 8;
         const 21474836505;
 },
 _ckr6() //  [R1]
         { []
         }
     {offset
       ckr6: // global
           if (R1 & 7 == 1) goto ckrM; else goto ckrN;
       ckrM: // global
           R4 = P64[Sp + 72];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 48];
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckrN: // global
           I64[Sp - 8] = block_ckrc_info;
           _shcX::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _shcX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ukrZ; else goto ckrd;
       ukrZ: // global
           call _ckrc(R1) args: 0, res: 0, upd: 0;
       ckrd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ckr6_info" {
     block_ckr6_info:
         const _ckr6;
         const 9;
         const 30;
 },
 _ckrc() //  [R1]
         { []
         }
     {offset
       ckrc: // global
           _shcX::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ckrh_info;
           R6 = _shcX::P64;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 48];
           Sp = Sp + 8;
           call $wgo_shcP_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ckrc_info" {
     block_ckrc_info:
         const _ckrc;
         const 10;
         const 30;
 },
 _ckrh() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       ckrh: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto ckrY; else goto ckrX;
       ckrY: // global
           HpAlloc = 160;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_pppp(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       ckrX: // global
           I64[Hp - 152] = sat_shdb_info;
           P64[Hp - 136] = P64[Sp + 32];
           P64[Hp - 128] = P64[Sp + 72];
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_shda_info;
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 64];
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_shd9_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 56];
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_shd8_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = R1;
           R4 = Hp - 152;
           R3 = Hp - 112;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 80;
           call (I64[P64[Sp]])(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckrh_info" {
     block_ckrh_info:
         const _ckrh;
         const 1033;
         const 30;
 },
 GHC.Base.$w$csconcat2_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cks1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cks5; else goto cks4;
       cks5: // global
           HpAlloc = 40;
           R1 = GHC.Base.$w$csconcat2_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 80, res: 0, upd: 8;
       cks4: // global
           I64[Hp - 32] = $wgo_shcP_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           _shcK::P64 = R6;
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 8];
           R3 = P64[Sp];
           R2 = _shcK::P64;
           R1 = Hp - 27;
           Sp = Sp + 32;
           call $wgo_shcP_entry(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$csconcat2_info" {
     GHC.Base.$w$csconcat2_info:
         const GHC.Base.$w$csconcat2_entry;
         const 0;
         const 14;
         const 38654705664;
         const 0;
         const 9;
         const GHC.Base.$w$csconcat2_slow;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.504798565 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,)_$csconcat_closure" {
     GHC.Base.$fSemigroup(,,,)_$csconcat_closure:
         const GHC.Base.$fSemigroup(,,,)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(,,,)_$csconcat_entry() //  [R2, R3, R4, R5,
                                                  R6]
         { []
         }
     {offset
       ckto: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cktz; else goto cktA;
       cktz: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,,)_$csconcat_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cktA: // global
           I64[Sp - 40] = block_cktl_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uktH; else goto cktm;
       uktH: // global
           call _cktl(R1) args: 0, res: 0, upd: 0;
       cktm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,,,)_$csconcat_info" {
     GHC.Base.$fSemigroup(,,,)_$csconcat_info:
         const GHC.Base.$fSemigroup(,,,)_$csconcat_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cktl() //  [R1]
         { []
         }
     {offset
       cktl: // global
           I64[Sp - 8] = block_cktr_info;
           _shdj::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _shdj::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uktG; else goto ckts;
       uktG: // global
           call _cktr(R1) args: 0, res: 0, upd: 0;
       ckts: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cktl_info" {
     block_cktl_info:
         const _cktl;
         const 4;
         const 30;
 },
 _cktr() //  [R1]
         { []
         }
     {offset
       cktr: // global
           _shdf::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_cktw_info;
           R6 = P64[R1 + 7];
           R5 = _shdf::P64;
           R4 = P64[Sp + 32];
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           _shdj::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 23];
           P64[Sp + 24] = P64[R1 + 31];
           P64[Sp + 32] = _shdj::P64;
           Sp = Sp + 8;
           call GHC.Base.$w$csconcat2_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 40, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cktr_info" {
     block_cktr_info:
         const _cktr;
         const 5;
         const 30;
 },
 _cktw() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cktw: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cktF; else goto cktE;
       cktF: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_pppp(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       cktE: // global
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = R1;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cktw_info" {
     block_cktw_info:
         const _cktw;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.519994238 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,)_$cstimes_closure" {
     GHC.Base.$fSemigroup(,,,)_$cstimes_closure:
         const GHC.Base.$fSemigroup(,,,)_$cstimes_info;
 },
 GHC.Base.$fSemigroup(,,,)_$cstimes_slow() //  [R1]
         { []
         }
     {offset
       cku7: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$fSemigroup(,,,)_$cstimes_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2,
                                                         R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_shdJ_entry() //  [R1]
         { []
         }
     {offset
       ckuk: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckul; else goto ckum;
       ckul: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckum: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shdJ_info" {
     sat_shdJ_info:
         const sat_shdJ_entry;
         const 4;
         const 15;
 },
 sat_shdI_entry() //  [R1]
         { []
         }
     {offset
       ckur: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckus; else goto ckut;
       ckus: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckut: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shdI_info" {
     sat_shdI_info:
         const sat_shdI_entry;
         const 4;
         const 15;
 },
 sat_shdH_entry() //  [R1]
         { []
         }
     {offset
       ckuy: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckuz; else goto ckuA;
       ckuz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckuA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shdH_info" {
     sat_shdH_info:
         const sat_shdH_entry;
         const 4;
         const 15;
 },
 sat_shdG_entry() //  [R1]
         { []
         }
     {offset
       ckuF: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckuG; else goto ckuH;
       ckuG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckuH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shdG_info" {
     sat_shdG_info:
         const sat_shdG_entry;
         const 4;
         const 15;
 },
 GHC.Base.$fSemigroup(,,,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ckuI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckuK; else goto ckuL;
       ckuK: // global
           R1 = GHC.Base.$fSemigroup(,,,)_$cstimes_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       ckuL: // global
           I64[Sp - 40] = block_ckub_info;
           R1 = P64[Sp + 8];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp + 8] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ukuP; else goto ckuc;
       ukuP: // global
           call _ckub(R1) args: 0, res: 0, upd: 0;
       ckuc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,,,)_$cstimes_info" {
     GHC.Base.$fSemigroup(,,,)_$cstimes_info:
         const GHC.Base.$fSemigroup(,,,)_$cstimes_entry;
         const 0;
         const 14;
         const 30064771072;
         const 0;
         const 7;
         const GHC.Base.$fSemigroup(,,,)_$cstimes_slow;
 },
 _ckub() //  [R1]
         { []
         }
     {offset
       ckub: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto ckuO; else goto ckuN;
       ckuO: // global
           HpAlloc = 232;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckuN: // global
           _shdC::P64 = P64[R1 + 7];
           _shdD::P64 = P64[R1 + 15];
           _shdE::P64 = P64[R1 + 23];
           _shdF::P64 = P64[R1 + 31];
           I64[Hp - 224] = sat_shdJ_info;
           P64[Hp - 208] = P64[Sp + 24];
           _shdy::P64 = P64[Sp + 32];
           P64[Hp - 200] = _shdy::P64;
           _shdz::P64 = P64[Sp + 40];
           P64[Hp - 192] = _shdz::P64;
           P64[Hp - 184] = _shdF::P64;
           I64[Hp - 176] = sat_shdI_info;
           P64[Hp - 160] = P64[Sp + 16];
           P64[Hp - 152] = _shdy::P64;
           P64[Hp - 144] = _shdz::P64;
           P64[Hp - 136] = _shdE::P64;
           I64[Hp - 128] = sat_shdH_info;
           P64[Hp - 112] = P64[Sp + 8];
           P64[Hp - 104] = _shdy::P64;
           P64[Hp - 96] = _shdz::P64;
           P64[Hp - 88] = _shdD::P64;
           I64[Hp - 80] = sat_shdG_info;
           P64[Hp - 64] = P64[Sp + 48];
           P64[Hp - 56] = _shdy::P64;
           P64[Hp - 48] = _shdz::P64;
           P64[Hp - 40] = _shdC::P64;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 80;
           P64[Hp - 16] = Hp - 128;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 224;
           R1 = Hp - 31;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckub_info" {
     block_ckub_info:
         const _ckub;
         const 6;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.537925778 UTC

[section ""data" . GHC.Base.$fSemigroup(,,,)_closure" {
     GHC.Base.$fSemigroup(,,,)_closure:
         const GHC.Base.$fSemigroup(,,,)_info;
 },
 sat_shdQ_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       ckvZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckw0; else goto ckw1;
       ckw0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckw1: // global
           R6 = R2;
           R5 = P64[R1 + 29];
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           _B2::P64 = R3;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           P64[Sp - 16] = _B2::P64;
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 16;
           call GHC.Base.$fSemigroup(,,,)_$cstimes_entry(R6,
                                                         R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 24, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shdQ_info" {
     sat_shdQ_info:
         const sat_shdQ_entry;
         const 4;
         const 8;
         const 12884901911;
 },
 sat_shdP_entry() //  [R1, R2]
         { []
         }
     {offset
       ckw7: // global
           R6 = R2;
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(,,,)_$csconcat_entry(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shdP_info" {
     sat_shdP_info:
         const sat_shdP_entry;
         const 4;
         const 8;
         const 4294967301;
 },
 sat_shdO_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       ckwf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ckwg; else goto ckwh;
       ckwg: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckwh: // global
           R6 = R2;
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,)_$c<>_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shdO_info" {
     sat_shdO_info:
         const sat_shdO_entry;
         const 4;
         const 8;
         const 8589934607;
 },
 GHC.Base.$fSemigroup(,,,)_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       ckwj: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ckwn; else goto ckwm;
       ckwn: // global
           HpAlloc = 152;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,,)_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckwm: // global
           I64[Hp - 144] = sat_shdQ_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           P64[Hp - 112] = R5;
           I64[Hp - 104] = sat_shdP_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           P64[Hp - 72] = R5;
           I64[Hp - 64] = sat_shdO_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 62;
           P64[Hp - 8] = Hp - 103;
           P64[Hp] = Hp - 141;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,,,)_info" {
     GHC.Base.$fSemigroup(,,,)_info:
         const GHC.Base.$fSemigroup(,,,)_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.558602663 UTC

[section ""data" . GHC.Base.$w$cp1Monoid_closure" {
     GHC.Base.$w$cp1Monoid_closure:
         const GHC.Base.$w$cp1Monoid_info;
 },
 w4_shej_entry() //  [R1]
         { []
         }
     {offset
       ckwT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckwU; else goto ckwV;
       ckwU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckwV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . w4_shej_info" {
     w4_shej_info:
         const w4_shej_entry;
         const 1;
         const 16;
 },
 w5_shek_entry() //  [R1]
         { []
         }
     {offset
       ckx0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckx1; else goto ckx2;
       ckx1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckx2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . w5_shek_info" {
     w5_shek_info:
         const w5_shek_entry;
         const 1;
         const 16;
 },
 w6_shel_entry() //  [R1]
         { []
         }
     {offset
       ckx7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckx8; else goto ckx9;
       ckx8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckx9: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . w6_shel_info" {
     w6_shel_info:
         const w6_shel_entry;
         const 1;
         const 16;
 },
 w7_shem_entry() //  [R1]
         { []
         }
     {offset
       ckxe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckxf; else goto ckxg;
       ckxf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckxg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . w7_shem_info" {
     w7_shem_info:
         const w7_shem_entry;
         const 1;
         const 16;
 },
 sat_shey_entry() //  [R1]
         { []
         }
     {offset
       ckxv: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckxw; else goto ckxx;
       ckxw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckxx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shey_info" {
     sat_shey_info:
         const sat_shey_entry;
         const 4;
         const 15;
 },
 sat_shex_entry() //  [R1]
         { []
         }
     {offset
       ckxC: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckxD; else goto ckxE;
       ckxD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckxE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shex_info" {
     sat_shex_info:
         const sat_shex_entry;
         const 4;
         const 15;
 },
 sat_shew_entry() //  [R1]
         { []
         }
     {offset
       ckxJ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckxK; else goto ckxL;
       ckxK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckxL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shew_info" {
     sat_shew_info:
         const sat_shew_entry;
         const 4;
         const 15;
 },
 sat_shev_entry() //  [R1]
         { []
         }
     {offset
       ckxQ: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckxR; else goto ckxS;
       ckxR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckxS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shev_info" {
     sat_shev_info:
         const sat_shev_entry;
         const 4;
         const 15;
 },
 sat_shez_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       ckxT: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ckxV; else goto ckxW;
       ckxV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckxW: // global
           I64[Sp - 56] = block_ckxm_info;
           _shej::P64 = P64[R1 + 5];
           _shek::P64 = P64[R1 + 13];
           _shel::P64 = P64[R1 + 21];
           _shem::P64 = P64[R1 + 29];
           R1 = R4;
           P64[Sp - 48] = _shej::P64;
           P64[Sp - 40] = _shek::P64;
           P64[Sp - 32] = _shel::P64;
           P64[Sp - 24] = _shem::P64;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto uky0; else goto ckxn;
       uky0: // global
           call _ckxm(R1) args: 0, res: 0, upd: 0;
       ckxn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_shez_info" {
     sat_shez_info:
         const sat_shez_entry;
         const 4;
         const 8;
         const 12884901911;
 },
 _ckxm() //  [R1]
         { []
         }
     {offset
       ckxm: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto ckxZ; else goto ckxY;
       ckxZ: // global
           HpAlloc = 232;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckxY: // global
           _sher::P64 = P64[R1 + 7];
           _shes::P64 = P64[R1 + 15];
           _shet::P64 = P64[R1 + 23];
           _sheu::P64 = P64[R1 + 31];
           I64[Hp - 224] = sat_shey_info;
           P64[Hp - 208] = P64[Sp + 8];
           _shen::P64 = P64[Sp + 40];
           P64[Hp - 200] = _shen::P64;
           _sheo::P64 = P64[Sp + 48];
           P64[Hp - 192] = _sheo::P64;
           P64[Hp - 184] = _sheu::P64;
           I64[Hp - 176] = sat_shex_info;
           P64[Hp - 160] = P64[Sp + 16];
           P64[Hp - 152] = _shen::P64;
           P64[Hp - 144] = _sheo::P64;
           P64[Hp - 136] = _shet::P64;
           I64[Hp - 128] = sat_shew_info;
           P64[Hp - 112] = P64[Sp + 24];
           P64[Hp - 104] = _shen::P64;
           P64[Hp - 96] = _sheo::P64;
           P64[Hp - 88] = _shes::P64;
           I64[Hp - 80] = sat_shev_info;
           P64[Hp - 64] = P64[Sp + 32];
           P64[Hp - 56] = _shen::P64;
           P64[Hp - 48] = _sheo::P64;
           P64[Hp - 40] = _sher::P64;
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = Hp - 80;
           P64[Hp - 16] = Hp - 128;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 224;
           R1 = Hp - 31;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckxm_info" {
     block_ckxm_info:
         const _ckxm;
         const 6;
         const 30;
 },
 w4_she0_entry() //  [R1]
         { []
         }
     {offset
       cky5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cky6; else goto cky7;
       cky6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cky7: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . w4_she0_info" {
     w4_she0_info:
         const w4_she0_entry;
         const 1;
         const 16;
 },
 w5_she1_entry() //  [R1]
         { []
         }
     {offset
       ckyc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckyd; else goto ckye;
       ckyd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckye: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . w5_she1_info" {
     w5_she1_info:
         const w5_she1_entry;
         const 1;
         const 16;
 },
 w6_she2_entry() //  [R1]
         { []
         }
     {offset
       ckyj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckyk; else goto ckyl;
       ckyk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckyl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . w6_she2_info" {
     w6_she2_info:
         const w6_she2_entry;
         const 1;
         const 16;
 },
 w7_she3_entry() //  [R1]
         { []
         }
     {offset
       ckyq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckyr; else goto ckys;
       ckyr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckys: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . w7_she3_info" {
     w7_she3_info:
         const w7_she3_entry;
         const 1;
         const 16;
 },
 sat_shei_entry() //  [R1, R2]
         { []
         }
     {offset
       ckyB: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckyM; else goto ckyN;
       ckyM: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckyN: // global
           I64[Sp - 40] = block_ckyy_info;
           _she0::P64 = P64[R1 + 7];
           _she1::P64 = P64[R1 + 15];
           _she2::P64 = P64[R1 + 23];
           _she3::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 32] = _she0::P64;
           P64[Sp - 24] = _she1::P64;
           P64[Sp - 16] = _she2::P64;
           P64[Sp - 8] = _she3::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ukyU; else goto ckyz;
       ukyU: // global
           call _ckyy(R1) args: 0, res: 0, upd: 0;
       ckyz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_shei_info" {
     sat_shei_info:
         const sat_shei_entry;
         const 4;
         const 8;
         const 4294967301;
 },
 _ckyy() //  [R1]
         { []
         }
     {offset
       ckyy: // global
           I64[Sp - 8] = block_ckyE_info;
           _she7::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _she7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ukyT; else goto ckyF;
       ukyT: // global
           call _ckyE(R1) args: 0, res: 0, upd: 0;
       ckyF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ckyy_info" {
     block_ckyy_info:
         const _ckyy;
         const 4;
         const 30;
 },
 _ckyE() //  [R1]
         { []
         }
     {offset
       ckyE: // global
           _she3::P64 = P64[Sp + 40];
           I64[Sp + 40] = block_ckyJ_info;
           R6 = P64[R1 + 7];
           R5 = P64[Sp + 16];
           R4 = P64[Sp + 24];
           R3 = P64[Sp + 32];
           R2 = _she3::P64;
           _she7::P64 = P64[Sp + 8];
           P64[Sp + 8] = P64[R1 + 15];
           P64[Sp + 16] = P64[R1 + 23];
           P64[Sp + 24] = P64[R1 + 31];
           P64[Sp + 32] = _she7::P64;
           Sp = Sp + 8;
           call GHC.Base.$w$csconcat2_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 40, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ckyE_info" {
     block_ckyE_info:
         const _ckyE;
         const 5;
         const 30;
 },
 _ckyJ() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       ckyJ: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto ckyS; else goto ckyR;
       ckyS: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_pppp(R4, R3, R2, R1) args: 8, res: 8, upd: 8;
       ckyR: // global
           I64[Hp - 32] = (,,,)_con_info;
           P64[Hp - 24] = R1;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 31;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckyJ_info" {
     block_ckyJ_info:
         const _ckyJ;
         const 0;
         const 30;
 },
 sat_shdY_entry() //  [R1]
         { []
         }
     {offset
       ckyZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckz0; else goto ckz1;
       ckz0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckz1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shdY_info" {
     sat_shdY_info:
         const sat_shdY_entry;
         const 1;
         const 16;
 },
 sat_shdX_entry() //  [R1]
         { []
         }
     {offset
       ckz6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckz7; else goto ckz8;
       ckz7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckz8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shdX_info" {
     sat_shdX_info:
         const sat_shdX_entry;
         const 1;
         const 16;
 },
 sat_shdW_entry() //  [R1]
         { []
         }
     {offset
       ckzd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckze; else goto ckzf;
       ckze: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckzf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shdW_info" {
     sat_shdW_info:
         const sat_shdW_entry;
         const 1;
         const 16;
 },
 sat_shdV_entry() //  [R1]
         { []
         }
     {offset
       ckzk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckzl; else goto ckzm;
       ckzl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckzm: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shdV_info" {
     sat_shdV_info:
         const sat_shdV_entry;
         const 1;
         const 16;
 },
 sat_shdZ_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       ckzs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ckzt; else goto ckzu;
       ckzt: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckzu: // global
           R6 = R2;
           R5 = P64[R1 + 30];
           R4 = P64[R1 + 22];
           _B1::P64 = R3;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fMonoid(,,,)_$c<>_entry(R6,
                                                  R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shdZ_info" {
     sat_shdZ_info:
         const sat_shdZ_entry;
         const 4;
         const 8;
         const 8589934607;
 },
 GHC.Base.$w$cp1Monoid_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       ckzv: // global
           Hp = Hp + 408;
           if (Hp > HpLim) (likely: False) goto ckzz; else goto ckzy;
       ckzz: // global
           HpAlloc = 408;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$cp1Monoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckzy: // global
           I64[Hp - 400] = w4_shej_info;
           P64[Hp - 384] = R5;
           I64[Hp - 376] = w5_shek_info;
           P64[Hp - 360] = R4;
           I64[Hp - 352] = w6_shel_info;
           P64[Hp - 336] = R3;
           I64[Hp - 328] = w7_shem_info;
           P64[Hp - 312] = R2;
           I64[Hp - 304] = sat_shez_info;
           P64[Hp - 296] = Hp - 400;
           P64[Hp - 288] = Hp - 376;
           P64[Hp - 280] = Hp - 352;
           P64[Hp - 272] = Hp - 328;
           I64[Hp - 264] = w4_she0_info;
           P64[Hp - 248] = R5;
           I64[Hp - 240] = w5_she1_info;
           P64[Hp - 224] = R4;
           I64[Hp - 216] = w6_she2_info;
           P64[Hp - 200] = R3;
           I64[Hp - 192] = w7_she3_info;
           P64[Hp - 176] = R2;
           I64[Hp - 168] = sat_shei_info;
           P64[Hp - 160] = Hp - 264;
           P64[Hp - 152] = Hp - 240;
           P64[Hp - 144] = Hp - 216;
           P64[Hp - 136] = Hp - 192;
           I64[Hp - 128] = sat_shdY_info;
           P64[Hp - 112] = R5;
           I64[Hp - 104] = sat_shdX_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = sat_shdW_info;
           P64[Hp - 64] = R3;
           I64[Hp - 56] = sat_shdV_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_shdZ_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 80;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 128;
           R3 = Hp - 301;
           R2 = Hp - 167;
           R1 = Hp - 30;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$cp1Monoid_info" {
     GHC.Base.$w$cp1Monoid_info:
         const GHC.Base.$w$cp1Monoid_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.606731145 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,,,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,,,)_$cp1Monoid_info;
 },
 GHC.Base.$fMonoid(,,,)_$cp1Monoid_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       ckCz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ckCA; else goto ckCB;
       ckCA: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckCB: // global
           I64[Sp - 8] = block_ckCw_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,)_$cp1Monoid_info" {
     GHC.Base.$fMonoid(,,,)_$cp1Monoid_info:
         const GHC.Base.$fMonoid(,,,)_$cp1Monoid_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _ckCw() //  [R1, R2, R3]
         { []
         }
     {offset
       ckCw: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ckCE; else goto ckCD;
       ckCE: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       ckCD: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckCw_info" {
     block_ckCw_info:
         const _ckCw;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.613975417 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,,,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,,,)_$cmappend_info;
 },
 GHC.Base.$fMonoid(,,,)_$cmappend_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       ckCW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ckCX; else goto ckCY;
       ckCX: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cmappend_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckCY: // global
           I64[Sp - 8] = block_ckCU_info;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,)_$cmappend_info" {
     GHC.Base.$fMonoid(,,,)_$cmappend_info:
         const GHC.Base.$fMonoid(,,,)_$cmappend_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _ckCU() //  [R1]
         { []
         }
     {offset
       ckCU: // global
           R1 = R1;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckCU_info" {
     block_ckCU_info:
         const _ckCU;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.62346801 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,,,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,,,)_$cmconcat_info;
 },
 k_sheU_entry() //  [R1]
         { []
         }
     {offset
       ckDk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ckDl; else goto ckDm;
       ckDl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckDm: // global
           I64[Sp - 8] = block_ckDh_info;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 8;
           call GHC.Base.$w$cp1Monoid_entry(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . k_sheU_info" {
     k_sheU_info:
         const k_sheU_entry;
         const 4;
         const 15;
 },
 _ckDh() //  [R1, R2, R3]
         { []
         }
     {offset
       ckDh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ckDp; else goto ckDo;
       ckDp: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       ckDo: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckDh_info" {
     block_ckDh_info:
         const _ckDh;
         const 0;
         const 30;
 },
 k1_sheZ_entry() //  [R1]
         { []
         }
     {offset
       ckDu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckDv; else goto ckDw;
       ckDv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckDw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.<>_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . k1_sheZ_info" {
     k1_sheZ_info:
         const k1_sheZ_entry;
         const 1;
         const 16;
 },
 z_shf0_entry() //  [R1]
         { []
         }
     {offset
       ckDB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckDC; else goto ckDD;
       ckDC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckDD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z_shf0_info" {
     z_shf0_info:
         const z_shf0_entry;
         const 1;
         const 16;
 },
 z1_shf1_entry() //  [R1]
         { []
         }
     {offset
       ckDI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckDJ; else goto ckDK;
       ckDJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckDK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z1_shf1_info" {
     z1_shf1_info:
         const z1_shf1_entry;
         const 1;
         const 16;
 },
 z2_shf2_entry() //  [R1]
         { []
         }
     {offset
       ckDP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckDQ; else goto ckDR;
       ckDQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckDR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z2_shf2_info" {
     z2_shf2_info:
         const z2_shf2_entry;
         const 1;
         const 16;
 },
 z3_shf3_entry() //  [R1]
         { []
         }
     {offset
       ckDW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckDX; else goto ckDY;
       ckDX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckDY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z3_shf3_info" {
     z3_shf3_info:
         const z3_shf3_entry;
         const 1;
         const 16;
 },
 go_shf5_entry() //  [R1, R2]
         { []
         }
     {offset
       ckEc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto ckEd; else goto ckEe;
       ckEd: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckEe: // global
           I64[Sp - 32] = block_ckE5_info;
           _shf5::P64 = R1;
           _sheZ::P64 = P64[R1 + 7];
           _shf4::P64 = P64[R1 + 15];
           R1 = R2;
           P64[Sp - 24] = _sheZ::P64;
           P64[Sp - 16] = _shf4::P64;
           P64[Sp - 8] = _shf5::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ukEo; else goto ckE6;
       ukEo: // global
           call _ckE5(R1) args: 0, res: 0, upd: 0;
       ckE6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_shf5_info" {
     go_shf5_info:
         const go_shf5_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _ckE5() //  [R1]
         { []
         }
     {offset
       ckE5: // global
           if (R1 & 7 == 1) goto ckE9; else goto ckEa;
       ckE9: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ckEa: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ckEn; else goto ckEm;
       ckEn: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckEm: // global
           _shf8::P64 = P64[R1 + 6];
           _shf9::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = _shf9::P64;
           R3 = Hp - 24;
           R2 = _shf8::P64;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckE5_info" {
     block_ckE5_info:
         const _ckE5;
         const 3;
         const 30;
 },
 GHC.Base.$fMonoid(,,,)_$cmconcat_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       ckEp: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto ckEt; else goto ckEs;
       ckEt: // global
           HpAlloc = 232;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_$cmconcat_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckEs: // global
           I64[Hp - 224] = k_sheU_info;
           P64[Hp - 208] = R2;
           P64[Hp - 200] = R3;
           P64[Hp - 192] = R4;
           P64[Hp - 184] = R5;
           I64[Hp - 176] = k1_sheZ_info;
           P64[Hp - 160] = Hp - 224;
           I64[Hp - 152] = z_shf0_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = z1_shf1_info;
           P64[Hp - 112] = R3;
           I64[Hp - 104] = z2_shf2_info;
           P64[Hp - 88] = R4;
           I64[Hp - 80] = z3_shf3_info;
           P64[Hp - 64] = R5;
           I64[Hp - 56] = (,,,)_con_info;
           P64[Hp - 48] = Hp - 152;
           P64[Hp - 40] = Hp - 128;
           P64[Hp - 32] = Hp - 104;
           P64[Hp - 24] = Hp - 80;
           I64[Hp - 16] = go_shf5_info;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 55;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,)_$cmconcat_info" {
     GHC.Base.$fMonoid(,,,)_$cmconcat_info:
         const GHC.Base.$fMonoid(,,,)_$cmconcat_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.648402078 UTC

[section ""data" . GHC.Base.$fMonoid(,,,)_closure" {
     GHC.Base.$fMonoid(,,,)_closure:
         const GHC.Base.$fMonoid(,,,)_info;
 },
 sat_shfi_entry() //  [R1]
         { []
         }
     {offset
       ckFJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckFK; else goto ckFL;
       ckFK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckFL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cmconcat_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shfi_info" {
     sat_shfi_info:
         const sat_shfi_entry;
         const 4;
         const 15;
 },
 sat_shfh_entry() //  [R1]
         { []
         }
     {offset
       ckFQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckFR; else goto ckFS;
       ckFR: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckFS: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cmappend_entry(R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shfh_info" {
     sat_shfh_info:
         const sat_shfh_entry;
         const 4;
         const 15;
 },
 sat_shfg_entry() //  [R1]
         { []
         }
     {offset
       ckFX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckFY; else goto ckFZ;
       ckFY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckFZ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cmempty_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shfg_info" {
     sat_shfg_info:
         const sat_shfg_entry;
         const 4;
         const 15;
 },
 sat_shff_entry() //  [R1]
         { []
         }
     {offset
       ckG4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckG5; else goto ckG6;
       ckG5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckG6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R5 = P64[R1 + 40];
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,,)_$cp1Monoid_entry(R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shff_info" {
     sat_shff_info:
         const sat_shff_entry;
         const 4;
         const 15;
 },
 GHC.Base.$fMonoid(,,,)_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       ckG8: // global
           Hp = Hp + 232;
           if (Hp > HpLim) (likely: False) goto ckGc; else goto ckGb;
       ckGc: // global
           HpAlloc = 232;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,,)_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckGb: // global
           I64[Hp - 224] = sat_shfi_info;
           P64[Hp - 208] = R2;
           P64[Hp - 200] = R3;
           P64[Hp - 192] = R4;
           P64[Hp - 184] = R5;
           I64[Hp - 176] = sat_shfh_info;
           P64[Hp - 160] = R2;
           P64[Hp - 152] = R3;
           P64[Hp - 144] = R4;
           P64[Hp - 136] = R5;
           I64[Hp - 128] = sat_shfg_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           P64[Hp - 88] = R5;
           I64[Hp - 80] = sat_shff_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           P64[Hp - 48] = R4;
           P64[Hp - 40] = R5;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 80;
           P64[Hp - 16] = Hp - 128;
           P64[Hp - 8] = Hp - 176;
           P64[Hp] = Hp - 224;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,,)_info" {
     GHC.Base.$fMonoid(,,,)_info:
         const GHC.Base.$fMonoid(,,,)_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.66951884 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$c<>_closure" {
     GHC.Base.$fMonoid(,,)_$c<>_closure:
         const GHC.Base.$fMonoid(,,)_$c<>_info;
 },
 sat_shfy_entry() //  [R1]
         { []
         }
     {offset
       ckH3: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckH4; else goto ckH5;
       ckH4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckH5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shfy_info" {
     sat_shfy_info:
         const sat_shfy_entry;
         const 3;
         const 15;
 },
 sat_shfx_entry() //  [R1]
         { []
         }
     {offset
       ckHa: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckHb; else goto ckHc;
       ckHb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckHc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shfx_info" {
     sat_shfx_info:
         const sat_shfx_entry;
         const 3;
         const 15;
 },
 sat_shfw_entry() //  [R1]
         { []
         }
     {offset
       ckHh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckHi; else goto ckHj;
       ckHi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckHj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shfw_info" {
     sat_shfw_info:
         const sat_shfw_entry;
         const 3;
         const 15;
 },
 GHC.Base.$fMonoid(,,)_$c<>_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ckHk: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ckHm; else goto ckHn;
       ckHm: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$c<>_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckHn: // global
           I64[Sp - 40] = block_ckGP_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ukHt; else goto ckGQ;
       ukHt: // global
           call _ckGP(R1) args: 0, res: 0, upd: 0;
       ckGQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,)_$c<>_info" {
     GHC.Base.$fMonoid(,,)_$c<>_info:
         const GHC.Base.$fMonoid(,,)_$c<>_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _ckGP() //  [R1]
         { []
         }
     {offset
       ckGP: // global
           I64[Sp - 16] = block_ckGU_info;
           _shfp::P64 = P64[R1 + 7];
           _shfq::P64 = P64[R1 + 15];
           _shfr::P64 = P64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 8] = _shfr::P64;
           P64[Sp] = _shfq::P64;
           P64[Sp + 32] = _shfp::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ukHs; else goto ckGV;
       ukHs: // global
           call _ckGU(R1) args: 0, res: 0, upd: 0;
       ckGV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ckGP_info" {
     block_ckGP_info:
         const _ckGP;
         const 4;
         const 30;
 },
 _ckGU() //  [R1]
         { []
         }
     {offset
       ckGU: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ckHr; else goto ckHq;
       ckHr: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckHq: // global
           _shft::P64 = P64[R1 + 7];
           _shfu::P64 = P64[R1 + 15];
           _shfv::P64 = P64[R1 + 23];
           I64[Hp - 144] = sat_shfy_info;
           P64[Hp - 128] = P64[Sp + 40];
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _shfv::P64;
           I64[Hp - 104] = sat_shfx_info;
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _shfu::P64;
           I64[Hp - 64] = sat_shfw_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _shft::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 64;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 144;
           R1 = Hp - 23;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckGU_info" {
     block_ckGU_info:
         const _ckGU;
         const 6;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.690459764 UTC

[section ""data" . GHC.Base.$w$csconcat1_closure" {
     GHC.Base.$w$csconcat1_closure:
         const GHC.Base.$w$csconcat1_info;
 },
 GHC.Base.$w$csconcat1_slow() //  [R1]
         { []
         }
     {offset
       ckIm: // global
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call GHC.Base.$w$csconcat1_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2,
                                            R1) args: 24, res: 0, upd: 8;
     }
 },
 sat_shfY_entry() //  [R1]
         { []
         }
     {offset
       ckIM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckIN; else goto ckIO;
       ckIN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckIO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shfY_info" {
     sat_shfY_info:
         const sat_shfY_entry;
         const 3;
         const 15;
 },
 sat_shfX_entry() //  [R1]
         { []
         }
     {offset
       ckIT: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckIU; else goto ckIV;
       ckIU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckIV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shfX_info" {
     sat_shfX_info:
         const sat_shfX_entry;
         const 3;
         const 15;
 },
 sat_shfW_entry() //  [R1]
         { []
         }
     {offset
       ckJ0: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckJ1; else goto ckJ2;
       ckJ1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckJ2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shfW_info" {
     sat_shfW_info:
         const sat_shfW_entry;
         const 3;
         const 15;
 },
 $wgo_shfG_entry() //  [R1, R2, R3, R4, R5]
         { []
         }
     {offset
       ckJ7: // global
           if ((Sp + -72) < SpLim) (likely: False) goto ckJ8; else goto ckJ9;
       ckJ8: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckJ9: // global
           I64[Sp - 64] = block_ckIv_info;
           _shfG::P64 = R1;
           _shfz::P64 = P64[R1 + 4];
           _shfA::P64 = P64[R1 + 12];
           _shfB::P64 = P64[R1 + 20];
           R1 = R5;
           P64[Sp - 56] = _shfz::P64;
           P64[Sp - 48] = _shfA::P64;
           P64[Sp - 40] = _shfB::P64;
           P64[Sp - 32] = _shfG::P64;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ukJi; else goto ckIw;
       ukJi: // global
           call _ckIv(R1) args: 0, res: 0, upd: 0;
       ckIw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . $wgo_shfG_info" {
     $wgo_shfG_info:
         const $wgo_shfG_entry;
         const 3;
         const 8;
         const 17179869208;
 },
 _ckIv() //  [R1]
         { []
         }
     {offset
       ckIv: // global
           if (R1 & 7 == 1) goto ckJ4; else goto ckJ5;
       ckJ4: // global
           R3 = P64[Sp + 56];
           R2 = P64[Sp + 48];
           R1 = P64[Sp + 40];
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckJ5: // global
           I64[Sp - 8] = block_ckIB_info;
           _shfN::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _shfN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ukJh; else goto ckIC;
       ukJh: // global
           call _ckIB(R1) args: 0, res: 0, upd: 0;
       ckIC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ckIv_info" {
     block_ckIv_info:
         const _ckIv;
         const 7;
         const 30;
 },
 _ckIB() //  [R1]
         { []
         }
     {offset
       ckIB: // global
           _shfN::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_ckIG_info;
           R5 = _shfN::P64;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 40];
           Sp = Sp + 8;
           call $wgo_shfG_entry(R5, R4, R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ckIB_info" {
     block_ckIB_info:
         const _ckIB;
         const 8;
         const 30;
 },
 _ckIG() //  [R1, R2, R3]
         { []
         }
     {offset
       ckIG: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ckJg; else goto ckJf;
       ckJg: // global
           HpAlloc = 120;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       ckJf: // global
           I64[Hp - 112] = sat_shfY_info;
           P64[Hp - 96] = P64[Sp + 24];
           P64[Hp - 88] = P64[Sp + 56];
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_shfX_info;
           P64[Hp - 56] = P64[Sp + 16];
           P64[Hp - 48] = P64[Sp + 48];
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_shfW_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = R1;
           R3 = Hp - 112;
           R2 = Hp - 72;
           R1 = Hp - 32;
           Sp = Sp + 64;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckIG_info" {
     block_ckIG_info:
         const _ckIG;
         const 519;
         const 30;
 },
 GHC.Base.$w$csconcat1_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ckJj: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ckJn; else goto ckJm;
       ckJn: // global
           HpAlloc = 32;
           R1 = GHC.Base.$w$csconcat1_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       ckJm: // global
           I64[Hp - 24] = $wgo_shfG_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           _shfC::P64 = R5;
           R5 = P64[Sp + 8];
           R4 = P64[Sp];
           R3 = R6;
           R2 = _shfC::P64;
           R1 = Hp - 20;
           Sp = Sp + 16;
           call $wgo_shfG_entry(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$csconcat1_info" {
     GHC.Base.$w$csconcat1_info:
         const GHC.Base.$w$csconcat1_entry;
         const 0;
         const 14;
         const 30064771072;
         const 0;
         const 7;
         const GHC.Base.$w$csconcat1_slow;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.709065709 UTC

[section ""data" . GHC.Base.$fSemigroup(,,)_$csconcat_closure" {
     GHC.Base.$fSemigroup(,,)_$csconcat_closure:
         const GHC.Base.$fSemigroup(,,)_$csconcat_info;
 },
 GHC.Base.$fSemigroup(,,)_$csconcat_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       ckKv: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckKG; else goto ckKH;
       ckKG: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,)_$csconcat_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckKH: // global
           I64[Sp - 32] = block_ckKs_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ukKO; else goto ckKt;
       ukKO: // global
           call _ckKs(R1) args: 0, res: 0, upd: 0;
       ckKt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,,)_$csconcat_info" {
     GHC.Base.$fSemigroup(,,)_$csconcat_info:
         const GHC.Base.$fSemigroup(,,)_$csconcat_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _ckKs() //  [R1]
         { []
         }
     {offset
       ckKs: // global
           I64[Sp - 8] = block_ckKy_info;
           _shg5::P64 = P64[R1 + 15];
           R1 = P64[R1 + 7];
           P64[Sp] = _shg5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ukKN; else goto ckKz;
       ukKN: // global
           call _ckKy(R1) args: 0, res: 0, upd: 0;
       ckKz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ckKs_info" {
     block_ckKs_info:
         const _ckKs;
         const 3;
         const 30;
 },
 _ckKy() //  [R1]
         { []
         }
     {offset
       ckKy: // global
           _shg1::P64 = P64[Sp + 32];
           I64[Sp + 32] = block_ckKD_info;
           R6 = P64[R1 + 15];
           R5 = P64[R1 + 7];
           R4 = _shg1::P64;
           R3 = P64[Sp + 24];
           R2 = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 23];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.Base.$w$csconcat1_entry(R6,
                                            R5,
                                            R4,
                                            R3,
                                            R2) args: 24, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ckKy_info" {
     block_ckKy_info:
         const _ckKy;
         const 4;
         const 30;
 },
 _ckKD() //  [R1, R2, R3]
         { []
         }
     {offset
       ckKD: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto ckKM; else goto ckKL;
       ckKM: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       ckKL: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckKD_info" {
     block_ckKD_info:
         const _ckKD;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.721344111 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cmappend_closure" {
     GHC.Base.$fMonoid(,,)_$cmappend_closure:
         const GHC.Base.$fMonoid(,,)_$cmappend_info;
 },
 sat_shgw_entry() //  [R1]
         { []
         }
     {offset
       ckLw: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckLx; else goto ckLy;
       ckLx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckLy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ckLu_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_shgw_info" {
     sat_shgw_info:
         const sat_shgw_entry;
         const 3;
         const 15;
 },
 _ckLu() //  [R1]
         { []
         }
     {offset
       ckLu: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ckLu_info" {
     block_ckLu_info:
         const _ckLu;
         const 2;
         const 30;
 },
 sat_shgu_entry() //  [R1]
         { []
         }
     {offset
       ckLI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckLJ; else goto ckLK;
       ckLJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckLK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ckLG_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_shgu_info" {
     sat_shgu_info:
         const sat_shgu_entry;
         const 3;
         const 15;
 },
 _ckLG() //  [R1]
         { []
         }
     {offset
       ckLG: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ckLG_info" {
     block_ckLG_info:
         const _ckLG;
         const 2;
         const 30;
 },
 sat_shgs_entry() //  [R1]
         { []
         }
     {offset
       ckLU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckLV; else goto ckLW;
       ckLV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckLW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_ckLS_info;
           R2 = P64[R1 + 16];
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.$p1Monoid_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_shgs_info" {
     sat_shgs_info:
         const sat_shgs_entry;
         const 3;
         const 15;
 },
 _ckLS() //  [R1]
         { []
         }
     {offset
       ckLS: // global
           R2 = R1;
           I64[Sp] = stg_ap_pp_info;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ckLS_info" {
     block_ckLS_info:
         const _ckLS;
         const 2;
         const 30;
 },
 GHC.Base.$fMonoid(,,)_$cmappend_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ckM0: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ckM2; else goto ckM3;
       ckM2: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cmappend_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckM3: // global
           I64[Sp - 40] = block_ckLg_info;
           R1 = R5;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ukM9; else goto ckLh;
       ukM9: // global
           call _ckLg(R1) args: 0, res: 0, upd: 0;
       ckLh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,)_$cmappend_info" {
     GHC.Base.$fMonoid(,,)_$cmappend_info:
         const GHC.Base.$fMonoid(,,)_$cmappend_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _ckLg() //  [R1]
         { []
         }
     {offset
       ckLg: // global
           I64[Sp - 16] = block_ckLl_info;
           _shgk::P64 = P64[R1 + 7];
           _shgl::P64 = P64[R1 + 15];
           _shgm::P64 = P64[R1 + 23];
           R1 = P64[Sp + 32];
           P64[Sp - 8] = _shgm::P64;
           P64[Sp] = _shgl::P64;
           P64[Sp + 32] = _shgk::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ukM8; else goto ckLm;
       ukM8: // global
           call _ckLl(R1) args: 0, res: 0, upd: 0;
       ckLm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ckLg_info" {
     block_ckLg_info:
         const _ckLg;
         const 4;
         const 30;
 },
 _ckLl() //  [R1]
         { []
         }
     {offset
       ckLl: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ckM7; else goto ckM6;
       ckM7: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckM6: // global
           _shgo::P64 = P64[R1 + 7];
           _shgp::P64 = P64[R1 + 15];
           _shgq::P64 = P64[R1 + 23];
           I64[Hp - 144] = sat_shgw_info;
           P64[Hp - 128] = P64[Sp + 40];
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _shgq::P64;
           I64[Hp - 104] = sat_shgu_info;
           P64[Hp - 88] = P64[Sp + 32];
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _shgp::P64;
           I64[Hp - 64] = sat_shgs_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _shgo::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 64;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 144;
           R1 = Hp - 23;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckLl_info" {
     block_ckLl_info:
         const _ckLl;
         const 6;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.744313535 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cmconcat_closure" {
     GHC.Base.$fMonoid(,,)_$cmconcat_closure:
         const GHC.Base.$fMonoid(,,)_$cmconcat_info;
 },
 $dSemigroup_shgB_entry() //  [R1]
         { []
         }
     {offset
       ckNl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckNm; else goto ckNn;
       ckNm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckNn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dSemigroup_shgB_info" {
     $dSemigroup_shgB_info:
         const $dSemigroup_shgB_entry;
         const 1;
         const 16;
 },
 $dSemigroup1_shgC_entry() //  [R1]
         { []
         }
     {offset
       ckNs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckNt; else goto ckNu;
       ckNt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckNu: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dSemigroup1_shgC_info" {
     $dSemigroup1_shgC_info:
         const $dSemigroup1_shgC_entry;
         const 1;
         const 16;
 },
 $dSemigroup2_shgD_entry() //  [R1]
         { []
         }
     {offset
       ckNz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckNA; else goto ckNB;
       ckNA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckNB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . $dSemigroup2_shgD_info" {
     $dSemigroup2_shgD_info:
         const $dSemigroup2_shgD_entry;
         const 1;
         const 16;
 },
 z_shgE_entry() //  [R1]
         { []
         }
     {offset
       ckNG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckNH; else goto ckNI;
       ckNH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckNI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z_shgE_info" {
     z_shgE_info:
         const z_shgE_entry;
         const 1;
         const 16;
 },
 z1_shgF_entry() //  [R1]
         { []
         }
     {offset
       ckNN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckNO; else goto ckNP;
       ckNO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckNP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z1_shgF_info" {
     z1_shgF_info:
         const z1_shgF_entry;
         const 1;
         const 16;
 },
 z2_shgG_entry() //  [R1]
         { []
         }
     {offset
       ckNU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckNV; else goto ckNW;
       ckNV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckNW: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . z2_shgG_info" {
     z2_shgG_info:
         const z2_shgG_entry;
         const 1;
         const 16;
 },
 sat_shgX_entry() //  [R1]
         { []
         }
     {offset
       ckOm: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckOn; else goto ckOo;
       ckOn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckOo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shgX_info" {
     sat_shgX_info:
         const sat_shgX_entry;
         const 3;
         const 15;
 },
 sat_shgW_entry() //  [R1]
         { []
         }
     {offset
       ckOt: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckOu; else goto ckOv;
       ckOu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckOv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shgW_info" {
     sat_shgW_info:
         const sat_shgW_entry;
         const 3;
         const 15;
 },
 sat_shgV_entry() //  [R1]
         { []
         }
     {offset
       ckOA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckOB; else goto ckOC;
       ckOB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckOC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shgV_info" {
     sat_shgV_info:
         const sat_shgV_entry;
         const 3;
         const 15;
 },
 go_shgI_entry() //  [R1, R2]
         { []
         }
     {offset
       ckOH: // global
           if ((Sp + -56) < SpLim) (likely: False) goto ckOI; else goto ckOJ;
       ckOI: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckOJ: // global
           I64[Sp - 48] = block_ckO3_info;
           _shgI::P64 = R1;
           _shgB::P64 = P64[R1 + 7];
           _shgC::P64 = P64[R1 + 15];
           _shgD::P64 = P64[R1 + 23];
           _shgH::P64 = P64[R1 + 31];
           R1 = R2;
           P64[Sp - 40] = _shgB::P64;
           P64[Sp - 32] = _shgC::P64;
           P64[Sp - 24] = _shgD::P64;
           P64[Sp - 16] = _shgH::P64;
           P64[Sp - 8] = _shgI::P64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto ukOT; else goto ckO4;
       ukOT: // global
           call _ckO3(R1) args: 0, res: 0, upd: 0;
       ckO4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_shgI_info" {
     go_shgI_info:
         const go_shgI_entry;
         const 4;
         const 8;
         const 4294967301;
 },
 _ckO3() //  [R1]
         { []
         }
     {offset
       ckO3: // global
           if (R1 & 7 == 1) goto ckOE; else goto ckOF;
       ckOE: // global
           R1 = P64[Sp + 32];
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ckOF: // global
           I64[Sp] = block_ckO9_info;
           _shgM::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 32] = _shgM::P64;
           if (R1 & 7 != 0) goto ukOS; else goto ckOa;
       ukOS: // global
           call _ckO9(R1) args: 0, res: 0, upd: 0;
       ckOa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ckO3_info" {
     block_ckO3_info:
         const _ckO3;
         const 5;
         const 30;
 },
 _ckO9() //  [R1]
         { []
         }
     {offset
       ckO9: // global
           I64[Sp - 8] = block_ckOe_info;
           R2 = P64[Sp + 32];
           _shgO::P64 = P64[R1 + 7];
           _shgP::P64 = P64[R1 + 15];
           _shgQ::P64 = P64[R1 + 23];
           R1 = P64[Sp + 40];
           P64[Sp] = _shgQ::P64;
           P64[Sp + 32] = _shgP::P64;
           P64[Sp + 40] = _shgO::P64;
           Sp = Sp - 8;
           call go_shgI_entry(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ckO9_info" {
     block_ckO9_info:
         const _ckO9;
         const 5;
         const 30;
 },
 _ckOe() //  [R1]
         { []
         }
     {offset
       ckOe: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ckOR; else goto ckOQ;
       ckOR: // global
           HpAlloc = 152;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckOQ: // global
           _shgS::P64 = P64[R1 + 7];
           _shgT::P64 = P64[R1 + 15];
           _shgU::P64 = P64[R1 + 23];
           I64[Hp - 144] = sat_shgX_info;
           P64[Hp - 128] = P64[Sp + 32];
           P64[Hp - 120] = P64[Sp + 8];
           P64[Hp - 112] = _shgU::P64;
           I64[Hp - 104] = sat_shgW_info;
           P64[Hp - 88] = P64[Sp + 24];
           P64[Hp - 80] = P64[Sp + 40];
           P64[Hp - 72] = _shgT::P64;
           I64[Hp - 64] = sat_shgV_info;
           P64[Hp - 48] = P64[Sp + 16];
           P64[Hp - 40] = P64[Sp + 48];
           P64[Hp - 32] = _shgS::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 64;
           P64[Hp - 8] = Hp - 104;
           P64[Hp] = Hp - 144;
           R1 = Hp - 23;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckOe_info" {
     block_ckOe_info:
         const _ckOe;
         const 6;
         const 30;
 },
 GHC.Base.$fMonoid(,,)_$cmconcat_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       ckOU: // global
           Hp = Hp + 216;
           if (Hp > HpLim) (likely: False) goto ckOY; else goto ckOX;
       ckOY: // global
           HpAlloc = 216;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cmconcat_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckOX: // global
           I64[Hp - 208] = $dSemigroup_shgB_info;
           P64[Hp - 192] = R2;
           I64[Hp - 184] = $dSemigroup1_shgC_info;
           P64[Hp - 168] = R3;
           I64[Hp - 160] = $dSemigroup2_shgD_info;
           P64[Hp - 144] = R4;
           I64[Hp - 136] = z_shgE_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = z1_shgF_info;
           P64[Hp - 96] = R3;
           I64[Hp - 88] = z2_shgG_info;
           P64[Hp - 72] = R4;
           I64[Hp - 64] = (,,)_con_info;
           P64[Hp - 56] = Hp - 136;
           P64[Hp - 48] = Hp - 112;
           P64[Hp - 40] = Hp - 88;
           I64[Hp - 32] = go_shgI_info;
           P64[Hp - 24] = Hp - 208;
           P64[Hp - 16] = Hp - 184;
           P64[Hp - 8] = Hp - 160;
           P64[Hp] = Hp - 63;
           R2 = R5;
           R1 = Hp - 31;
           call go_shgI_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,)_$cmconcat_info" {
     GHC.Base.$fMonoid(,,)_$cmconcat_info:
         const GHC.Base.$fMonoid(,,)_$cmconcat_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.772632106 UTC

[section ""data" . GHC.Base.$fSemigroup(,,)_$cstimes_closure" {
     GHC.Base.$fSemigroup(,,)_$cstimes_closure:
         const GHC.Base.$fSemigroup(,,)_$cstimes_info;
 },
 sat_shha_entry() //  [R1]
         { []
         }
     {offset
       ckQW: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckQX; else goto ckQY;
       ckQX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckQY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shha_info" {
     sat_shha_info:
         const sat_shha_entry;
         const 4;
         const 15;
 },
 sat_shh9_entry() //  [R1]
         { []
         }
     {offset
       ckR3: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckR4; else goto ckR5;
       ckR4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckR5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shh9_info" {
     sat_shh9_info:
         const sat_shh9_entry;
         const 4;
         const 15;
 },
 sat_shh8_entry() //  [R1]
         { []
         }
     {offset
       ckRa: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckRb; else goto ckRc;
       ckRb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckRc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shh8_info" {
     sat_shh8_info:
         const sat_shh8_entry;
         const 4;
         const 15;
 },
 GHC.Base.$fSemigroup(,,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ckRd: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckRf; else goto ckRg;
       ckRf: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,)_$cstimes_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       ckRg: // global
           I64[Sp - 40] = block_ckQN_info;
           R1 = P64[Sp];
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           P64[Sp] = R2;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ukRk; else goto ckQO;
       ukRk: // global
           call _ckQN(R1) args: 0, res: 0, upd: 0;
       ckQO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,,)_$cstimes_info" {
     GHC.Base.$fSemigroup(,,)_$cstimes_info:
         const GHC.Base.$fSemigroup(,,)_$cstimes_entry;
         const 0;
         const 14;
         const 25769803802;
 },
 _ckQN() //  [R1]
         { []
         }
     {offset
       ckQN: // global
           Hp = Hp + 176;
           if (Hp > HpLim) (likely: False) goto ckRj; else goto ckRi;
       ckRj: // global
           HpAlloc = 176;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckRi: // global
           _shh5::P64 = P64[R1 + 7];
           _shh6::P64 = P64[R1 + 15];
           _shh7::P64 = P64[R1 + 23];
           I64[Hp - 168] = sat_shha_info;
           P64[Hp - 152] = P64[Sp + 16];
           _shh1::P64 = P64[Sp + 24];
           P64[Hp - 144] = _shh1::P64;
           _shh2::P64 = P64[Sp + 32];
           P64[Hp - 136] = _shh2::P64;
           P64[Hp - 128] = _shh7::P64;
           I64[Hp - 120] = sat_shh9_info;
           P64[Hp - 104] = P64[Sp + 8];
           P64[Hp - 96] = _shh1::P64;
           P64[Hp - 88] = _shh2::P64;
           P64[Hp - 80] = _shh6::P64;
           I64[Hp - 72] = sat_shh8_info;
           P64[Hp - 56] = P64[Sp + 40];
           P64[Hp - 48] = _shh1::P64;
           P64[Hp - 40] = _shh2::P64;
           P64[Hp - 32] = _shh5::P64;
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = Hp - 72;
           P64[Hp - 8] = Hp - 120;
           P64[Hp] = Hp - 168;
           R1 = Hp - 23;
           Sp = Sp + 48;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckQN_info" {
     block_ckQN_info:
         const _ckQN;
         const 5;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.78609951 UTC

[section ""data" . GHC.Base.$fSemigroup(,,)_closure" {
     GHC.Base.$fSemigroup(,,)_closure:
         const GHC.Base.$fSemigroup(,,)_info;
 },
 sat_shhg_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       ckSg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ckSh; else goto ckSi;
       ckSh: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckSi: // global
           R6 = R3;
           R5 = R2;
           _B1::P64 = R4;
           R4 = P64[R1 + 21];
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           P64[Sp - 8] = _B1::P64;
           Sp = Sp - 8;
           call GHC.Base.$fSemigroup(,,)_$cstimes_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 16, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shhg_info" {
     sat_shhg_info:
         const sat_shhg_entry;
         const 3;
         const 8;
         const 12884901911;
 },
 sat_shhf_entry() //  [R1, R2]
         { []
         }
     {offset
       ckSo: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(,,)_$csconcat_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shhf_info" {
     sat_shhf_info:
         const sat_shhf_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 sat_shhe_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       ckSw: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(,,)_$c<>_entry(R6,
                                                 R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shhe_info" {
     sat_shhe_info:
         const sat_shhe_entry;
         const 3;
         const 8;
         const 8589934607;
 },
 GHC.Base.$fSemigroup(,,)_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ckSA: // global
           Hp = Hp + 128;
           if (Hp > HpLim) (likely: False) goto ckSE; else goto ckSD;
       ckSE: // global
           HpAlloc = 128;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,,)_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckSD: // global
           I64[Hp - 120] = sat_shhg_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           P64[Hp - 96] = R4;
           I64[Hp - 88] = sat_shhf_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           P64[Hp - 64] = R4;
           I64[Hp - 56] = sat_shhe_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 54;
           P64[Hp - 8] = Hp - 87;
           P64[Hp] = Hp - 117;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,,)_info" {
     GHC.Base.$fSemigroup(,,)_info:
         const GHC.Base.$fSemigroup(,,)_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.796188696 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,,)_$cp1Monoid_info;
 },
 sat_shhm_entry() //  [R1]
         { []
         }
     {offset
       ckT9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckTa; else goto ckTb;
       ckTa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckTb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shhm_info" {
     sat_shhm_info:
         const sat_shhm_entry;
         const 1;
         const 16;
 },
 sat_shhl_entry() //  [R1]
         { []
         }
     {offset
       ckTg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckTh; else goto ckTi;
       ckTh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckTi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shhl_info" {
     sat_shhl_info:
         const sat_shhl_entry;
         const 1;
         const 16;
 },
 sat_shhk_entry() //  [R1]
         { []
         }
     {offset
       ckTn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckTo; else goto ckTp;
       ckTo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckTp: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shhk_info" {
     sat_shhk_info:
         const sat_shhk_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fMonoid(,,)_$cp1Monoid_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ckTq: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ckTu; else goto ckTt;
       ckTu: // global
           HpAlloc = 72;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckTt: // global
           I64[Hp - 64] = sat_shhm_info;
           P64[Hp - 48] = R4;
           I64[Hp - 40] = sat_shhl_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_shhk_info;
           P64[Hp] = R2;
           R4 = Hp - 64;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroup(,,)_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,)_$cp1Monoid_info" {
     GHC.Base.$fMonoid(,,)_$cp1Monoid_info:
         const GHC.Base.$fMonoid(,,)_$cp1Monoid_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.80624945 UTC

[section ""data" . GHC.Base.$fMonoid(,,)_closure" {
     GHC.Base.$fMonoid(,,)_closure:
         const GHC.Base.$fMonoid(,,)_info;
 },
 sat_shht_entry() //  [R1, R2]
         { []
         }
     {offset
       ckU0: // global
           R5 = R2;
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fMonoid(,,)_$cmconcat_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shht_info" {
     sat_shht_info:
         const sat_shht_entry;
         const 3;
         const 8;
         const 4294967301;
 },
 sat_shhs_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       ckU8: // global
           R6 = R3;
           R5 = R2;
           R4 = P64[R1 + 22];
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(,,)_$cmappend_entry(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shhs_info" {
     sat_shhs_info:
         const sat_shhs_entry;
         const 3;
         const 8;
         const 8589934607;
 },
 sat_shhr_entry() //  [R1]
         { []
         }
     {offset
       ckUf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckUg; else goto ckUh;
       ckUg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckUh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,)_$cmempty_entry(R4,
                                                     R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shhr_info" {
     sat_shhr_info:
         const sat_shhr_entry;
         const 3;
         const 15;
 },
 sat_shhq_entry() //  [R1]
         { []
         }
     {offset
       ckUm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckUn; else goto ckUo;
       ckUn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckUo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,,)_$cp1Monoid_entry(R4,
                                                       R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shhq_info" {
     sat_shhq_info:
         const sat_shhq_entry;
         const 3;
         const 15;
 },
 GHC.Base.$fMonoid(,,)_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ckUq: // global
           Hp = Hp + 184;
           if (Hp > HpLim) (likely: False) goto ckUu; else goto ckUt;
       ckUu: // global
           HpAlloc = 184;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,,)_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckUt: // global
           I64[Hp - 176] = sat_shht_info;
           P64[Hp - 168] = R2;
           P64[Hp - 160] = R3;
           P64[Hp - 152] = R4;
           I64[Hp - 144] = sat_shhs_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           P64[Hp - 120] = R4;
           I64[Hp - 112] = sat_shhr_info;
           P64[Hp - 96] = R2;
           P64[Hp - 88] = R3;
           P64[Hp - 80] = R4;
           I64[Hp - 72] = sat_shhq_info;
           P64[Hp - 56] = R2;
           P64[Hp - 48] = R3;
           P64[Hp - 40] = R4;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 72;
           P64[Hp - 16] = Hp - 112;
           P64[Hp - 8] = Hp - 142;
           P64[Hp] = Hp - 175;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,,)_info" {
     GHC.Base.$fMonoid(,,)_info:
         const GHC.Base.$fMonoid(,,)_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.818848206 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_$c<>_closure" {
     GHC.Base.$fSemigroup(,)_$c<>_closure:
         const GHC.Base.$fSemigroup(,)_$c<>_info;
 },
 sat_shhF_entry() //  [R1]
         { []
         }
     {offset
       ckVh: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckVi; else goto ckVj;
       ckVi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckVj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shhF_info" {
     sat_shhF_info:
         const sat_shhF_entry;
         const 3;
         const 15;
 },
 sat_shhE_entry() //  [R1]
         { []
         }
     {offset
       ckVo: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckVp; else goto ckVq;
       ckVp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckVq: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Base.<>_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shhE_info" {
     sat_shhE_info:
         const sat_shhE_entry;
         const 3;
         const 15;
 },
 GHC.Base.$fSemigroup(,)_$c<>_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       ckVr: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckVt; else goto ckVu;
       ckVt: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_$c<>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckVu: // global
           I64[Sp - 32] = block_ckV3_info;
           R1 = R4;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ukVA; else goto ckV4;
       ukVA: // global
           call _ckV3(R1) args: 0, res: 0, upd: 0;
       ckV4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,)_$c<>_info" {
     GHC.Base.$fSemigroup(,)_$c<>_info:
         const GHC.Base.$fSemigroup(,)_$c<>_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _ckV3() //  [R1]
         { []
         }
     {offset
       ckV3: // global
           I64[Sp - 8] = block_ckV8_info;
           _shhz::P64 = P64[R1 + 7];
           _shhA::P64 = P64[R1 + 15];
           R1 = P64[Sp + 24];
           P64[Sp] = _shhA::P64;
           P64[Sp + 24] = _shhz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ukVz; else goto ckV9;
       ukVz: // global
           call _ckV8(R1) args: 0, res: 0, upd: 0;
       ckV9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ckV3_info" {
     block_ckV3_info:
         const _ckV3;
         const 3;
         const 30;
 },
 _ckV8() //  [R1]
         { []
         }
     {offset
       ckV8: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ckVy; else goto ckVx;
       ckVy: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckVx: // global
           _shhC::P64 = P64[R1 + 7];
           _shhD::P64 = P64[R1 + 15];
           I64[Hp - 96] = sat_shhF_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _shhD::P64;
           I64[Hp - 56] = sat_shhE_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _shhC::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckV8_info" {
     block_ckV8_info:
         const _ckV8;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.832291841 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_$cstimes_closure" {
     GHC.Base.$fSemigroup(,)_$cstimes_closure:
         const GHC.Base.$fSemigroup(,)_$cstimes_info;
 },
 sat_shhP_entry() //  [R1]
         { []
         }
     {offset
       ckWt: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckWu; else goto ckWv;
       ckWu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckWv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shhP_info" {
     sat_shhP_info:
         const sat_shhP_entry;
         const 4;
         const 15;
 },
 sat_shhO_entry() //  [R1]
         { []
         }
     {offset
       ckWA: // global
           if ((Sp + -48) < SpLim) (likely: False) goto ckWB; else goto ckWC;
       ckWB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckWC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.stimes_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shhO_info" {
     sat_shhO_info:
         const sat_shhO_entry;
         const 4;
         const 15;
 },
 GHC.Base.$fSemigroup(,)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       ckWD: // global
           if ((Sp + -40) < SpLim) (likely: False) goto ckWF; else goto ckWG;
       ckWF: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_$cstimes_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckWG: // global
           I64[Sp - 40] = block_ckWk_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ukWK; else goto ckWl;
       ukWK: // global
           call _ckWk(R1) args: 0, res: 0, upd: 0;
       ckWl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,)_$cstimes_info" {
     GHC.Base.$fSemigroup(,)_$cstimes_info:
         const GHC.Base.$fSemigroup(,)_$cstimes_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _ckWk() //  [R1]
         { []
         }
     {offset
       ckWk: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto ckWJ; else goto ckWI;
       ckWJ: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ckWI: // global
           _shhM::P64 = P64[R1 + 7];
           _shhN::P64 = P64[R1 + 15];
           I64[Hp - 112] = sat_shhP_info;
           P64[Hp - 96] = P64[Sp + 16];
           _shhI::P64 = P64[Sp + 24];
           P64[Hp - 88] = _shhI::P64;
           _shhJ::P64 = P64[Sp + 32];
           P64[Hp - 80] = _shhJ::P64;
           P64[Hp - 72] = _shhN::P64;
           I64[Hp - 64] = sat_shhO_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = _shhI::P64;
           P64[Hp - 32] = _shhJ::P64;
           P64[Hp - 24] = _shhM::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 15;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ckWk_info" {
     block_ckWk_info:
         const _ckWk;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.842828386 UTC

[section ""data" . GHC.Base.$fSemigroup(,)_closure" {
     GHC.Base.$fSemigroup(,)_closure:
         const GHC.Base.$fSemigroup(,)_info;
 },
 sat_shhU_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       ckXu: // global
           R6 = R4;
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 13];
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroup(,)_$cstimes_entry(R6,
                                                       R5,
                                                       R4,
                                                       R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shhU_info" {
     sat_shhU_info:
         const sat_shhU_entry;
         const 2;
         const 11;
         const 12884901911;
 },
 sat_shhT_entry() //  [R1, R2]
         { []
         }
     {offset
       ckXC: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(,)_$csconcat_entry(R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shhT_info" {
     sat_shhT_info:
         const sat_shhT_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 sat_shhS_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       ckXK: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fSemigroup(,)_$c<>_entry(R5,
                                                   R4,
                                                   R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shhS_info" {
     sat_shhS_info:
         const sat_shhS_entry;
         const 2;
         const 11;
         const 8589934607;
 },
 GHC.Base.$fSemigroup(,)_entry() //  [R2, R3]
         { []
         }
     {offset
       ckXO: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto ckXS; else goto ckXR;
       ckXS: // global
           HpAlloc = 104;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(,)_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckXR: // global
           I64[Hp - 96] = sat_shhU_info;
           P64[Hp - 88] = R2;
           P64[Hp - 80] = R3;
           I64[Hp - 72] = sat_shhT_info;
           P64[Hp - 64] = R2;
           P64[Hp - 56] = R3;
           I64[Hp - 48] = sat_shhS_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 46;
           P64[Hp - 8] = Hp - 71;
           P64[Hp] = Hp - 93;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(,)_info" {
     GHC.Base.$fSemigroup(,)_info:
         const GHC.Base.$fSemigroup(,)_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.851838669 UTC

[section ""data" . GHC.Base.$fMonoid(,)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(,)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(,)_$cp1Monoid_info;
 },
 sat_shhY_entry() //  [R1]
         { []
         }
     {offset
       ckYm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckYn; else goto ckYo;
       ckYn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckYo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shhY_info" {
     sat_shhY_info:
         const sat_shhY_entry;
         const 1;
         const 16;
 },
 sat_shhX_entry() //  [R1]
         { []
         }
     {offset
       ckYt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckYu; else goto ckYv;
       ckYu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckYv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shhX_info" {
     sat_shhX_info:
         const sat_shhX_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fMonoid(,)_$cp1Monoid_entry() //  [R2, R3]
         { []
         }
     {offset
       ckYw: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto ckYA; else goto ckYz;
       ckYA: // global
           HpAlloc = 48;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_$cp1Monoid_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckYz: // global
           I64[Hp - 40] = sat_shhY_info;
           P64[Hp - 24] = R3;
           I64[Hp - 16] = sat_shhX_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroup(,)_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,)_$cp1Monoid_info" {
     GHC.Base.$fMonoid(,)_$cp1Monoid_info:
         const GHC.Base.$fMonoid(,)_$cp1Monoid_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.860968862 UTC

[section ""data" . GHC.Base.$fMonoid(,)_closure" {
     GHC.Base.$fMonoid(,)_closure:
         const GHC.Base.$fMonoid(,)_info;
 },
 sat_shi4_entry() //  [R1, R2]
         { []
         }
     {offset
       ckZ0: // global
           R4 = R2;
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           call GHC.Base.$fMonoid(,)_$cmconcat_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shi4_info" {
     sat_shi4_info:
         const sat_shi4_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 sat_shi3_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       ckZ8: // global
           R5 = R3;
           R4 = R2;
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(,)_$cmappend_entry(R5,
                                                     R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shi3_info" {
     sat_shi3_info:
         const sat_shi3_entry;
         const 2;
         const 11;
         const 8589934607;
 },
 sat_shi2_entry() //  [R1]
         { []
         }
     {offset
       ckZf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckZg; else goto ckZh;
       ckZg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckZh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,)_$cmempty_entry(R3,
                                                    R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shi2_info" {
     sat_shi2_info:
         const sat_shi2_entry;
         const 2;
         const 18;
 },
 sat_shi1_entry() //  [R1]
         { []
         }
     {offset
       ckZm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ckZn; else goto ckZo;
       ckZn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckZo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(,)_$cp1Monoid_entry(R3,
                                                      R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shi1_info" {
     sat_shi1_info:
         const sat_shi1_entry;
         const 2;
         const 18;
 },
 GHC.Base.$fMonoid(,)_entry() //  [R2, R3]
         { []
         }
     {offset
       ckZq: // global
           Hp = Hp + 152;
           if (Hp > HpLim) (likely: False) goto ckZu; else goto ckZt;
       ckZu: // global
           HpAlloc = 152;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(,)_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckZt: // global
           I64[Hp - 144] = sat_shi4_info;
           P64[Hp - 136] = R2;
           P64[Hp - 128] = R3;
           I64[Hp - 120] = sat_shi3_info;
           P64[Hp - 112] = R2;
           P64[Hp - 104] = R3;
           I64[Hp - 96] = sat_shi2_info;
           P64[Hp - 80] = R2;
           P64[Hp - 72] = R3;
           I64[Hp - 64] = sat_shi1_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 64;
           P64[Hp - 16] = Hp - 96;
           P64[Hp - 8] = Hp - 118;
           P64[Hp] = Hp - 143;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(,)_info" {
     GHC.Base.$fMonoid(,)_info:
         const GHC.Base.$fMonoid(,)_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.871735595 UTC

[section ""data" . GHC.Base.$fMonoid()_$c<>_closure" {
     GHC.Base.$fMonoid()_$c<>_closure:
         const GHC.Base.$fMonoid()_$c<>_info;
 },
 GHC.Base.$fMonoid()_$c<>_entry() //  []
         { []
         }
     {offset
       cl03: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid()_$c<>_info" {
     GHC.Base.$fMonoid()_$c<>_info:
         const GHC.Base.$fMonoid()_$c<>_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.875254526 UTC

[section ""data" . GHC.Base.$fSemigroup()_$csconcat_closure" {
     GHC.Base.$fSemigroup()_$csconcat_closure:
         const GHC.Base.$fSemigroup()_$csconcat_info;
 },
 GHC.Base.$fSemigroup()_$csconcat_entry() //  []
         { []
         }
     {offset
       cl0g: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup()_$csconcat_info" {
     GHC.Base.$fSemigroup()_$csconcat_info:
         const GHC.Base.$fSemigroup()_$csconcat_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.878473329 UTC

[section ""data" . GHC.Base.$fSemigroup()_$cstimes_closure" {
     GHC.Base.$fSemigroup()_$cstimes_closure:
         const GHC.Base.$fSemigroup()_$cstimes_info;
 },
 GHC.Base.$fSemigroup()_$cstimes_entry() //  []
         { []
         }
     {offset
       cl0t: // global
           R1 = ()_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup()_$cstimes_info" {
     GHC.Base.$fSemigroup()_$cstimes_info:
         const GHC.Base.$fSemigroup()_$cstimes_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.881604926 UTC

[section ""data" . GHC.Base.$fSemigroup()_closure" {
     GHC.Base.$fSemigroup()_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.$fMonoid()_$c<>_closure+2;
         const GHC.Base.$fSemigroup()_$csconcat_closure+1;
         const GHC.Base.$fSemigroup()_$cstimes_closure+3;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.883355069 UTC

[section ""data" . GHC.Base.$fMonoid()_closure" {
     GHC.Base.$fMonoid()_closure:
         const GHC.Base.C:Monoid_con_info;
         const GHC.Base.$fSemigroup()_closure+1;
         const GHC.Tuple.()_closure+1;
         const GHC.Base.$fMonoid()_$c<>_closure+2;
         const GHC.Base.$fMonoid()_$cmconcat_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.886749067 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_$c<>_closure" {
     GHC.Base.$fSemigroup(->)_$c<>_closure:
         const GHC.Base.$fSemigroup(->)_$c<>_info;
 },
 GHC.Base.$fSemigroup(->)_$c<>_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cl0K: // global
           _shie::P64 = R5;
           _shid::P64 = R4;
           _shic::P64 = R3;
           _shib::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto cl0L; else goto cl0M;
       cl0M: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cl0O; else goto cl0N;
       cl0O: // global
           HpAlloc = 64;
           goto cl0L;
       cl0L: // global
           R5 = _shie::P64;
           R4 = _shid::P64;
           R3 = _shic::P64;
           R2 = _shib::P64;
           R1 = GHC.Base.$fSemigroup(->)_$c<>_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cl0N: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = _shid::P64;
           P64[Hp - 32] = _shie::P64;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _shic::P64;
           P64[Hp] = _shie::P64;
           R2 = _shib::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = Hp - 56;
           Sp = Sp - 24;
           call GHC.Base.<>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(->)_$c<>_info" {
     GHC.Base.$fSemigroup(->)_$c<>_info:
         const GHC.Base.$fSemigroup(->)_$c<>_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.891218247 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_$cstimes_closure" {
     GHC.Base.$fSemigroup(->)_$cstimes_closure:
         const GHC.Base.$fSemigroup(->)_$cstimes_info;
 },
 GHC.Base.$fSemigroup(->)_$cstimes_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cl14: // global
           _shil::P64 = R6;
           _shik::P64 = R5;
           _shij::P64 = R4;
           _shii::P64 = R3;
           _shih::P64 = R2;
           if ((Sp + -32) < SpLim) (likely: False) goto cl15; else goto cl16;
       cl16: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cl18; else goto cl17;
       cl18: // global
           HpAlloc = 32;
           goto cl15;
       cl15: // global
           R6 = _shil::P64;
           R5 = _shik::P64;
           R4 = _shij::P64;
           R3 = _shii::P64;
           R2 = _shih::P64;
           R1 = GHC.Base.$fSemigroup(->)_$cstimes_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cl17: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _shik::P64;
           P64[Hp] = _shil::P64;
           R2 = _shih::P64;
           I64[Sp - 32] = stg_ap_ppp_info;
           P64[Sp - 24] = _shii::P64;
           P64[Sp - 16] = _shij::P64;
           P64[Sp - 8] = Hp - 24;
           Sp = Sp - 32;
           call GHC.Base.stimes_entry(R2) args: 40, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(->)_$cstimes_info" {
     GHC.Base.$fSemigroup(->)_$cstimes_info:
         const GHC.Base.$fSemigroup(->)_$cstimes_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.89688158 UTC

[section ""data" . GHC.Base.$fSemigroup(->)_closure" {
     GHC.Base.$fSemigroup(->)_closure:
         const GHC.Base.$fSemigroup(->)_info;
 },
 sat_shiq_entry() //  [R1, R2, R3, R4, R5]
         { []
         }
     {offset
       cl1q: // global
           R6 = R5;
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 4];
           call GHC.Base.$fSemigroup(->)_$cstimes_entry(R6,
                                                        R5,
                                                        R4,
                                                        R3,
                                                        R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shiq_info" {
     sat_shiq_info:
         const sat_shiq_entry;
         const 1;
         const 9;
         const 17179869208;
 },
 sat_ship_entry() //  [R1, R2]
         { []
         }
     {offset
       cl1y: // global
           R3 = R2;
           R2 = P64[R1 + 7];
           call GHC.Base.$fSemigroup(->)_$csconcat_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_ship_info" {
     sat_ship_info:
         const sat_ship_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_shio_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cl1G: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fSemigroup(->)_$c<>_entry(R5,
                                                    R4,
                                                    R3,
                                                    R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shio_info" {
     sat_shio_info:
         const sat_shio_entry;
         const 1;
         const 9;
         const 12884901911;
 },
 GHC.Base.$fSemigroup(->)_entry() //  [R2]
         { []
         }
     {offset
       cl1K: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cl1O; else goto cl1N;
       cl1O: // global
           HpAlloc = 80;
           R2 = R2;
           R1 = GHC.Base.$fSemigroup(->)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl1N: // global
           I64[Hp - 72] = sat_shiq_info;
           P64[Hp - 64] = R2;
           I64[Hp - 56] = sat_ship_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = sat_shio_info;
           P64[Hp - 32] = R2;
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = Hp - 37;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = Hp - 68;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup(->)_info" {
     GHC.Base.$fSemigroup(->)_info:
         const GHC.Base.$fSemigroup(->)_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.905912884 UTC

[section ""data" . GHC.Base.$fMonoid(->)_$cp1Monoid_closure" {
     GHC.Base.$fMonoid(->)_$cp1Monoid_closure:
         const GHC.Base.$fMonoid(->)_$cp1Monoid_info;
 },
 sat_shis_entry() //  [R1]
         { []
         }
     {offset
       cl2i: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cl2j; else goto cl2k;
       cl2j: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl2k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$p1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shis_info" {
     sat_shis_info:
         const sat_shis_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fMonoid(->)_$cp1Monoid_entry() //  [R2]
         { []
         }
     {offset
       cl2l: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl2p; else goto cl2o;
       cl2p: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(->)_$cp1Monoid_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl2o: // global
           I64[Hp - 16] = sat_shis_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           call GHC.Base.$fSemigroup(->)_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(->)_$cp1Monoid_info" {
     GHC.Base.$fMonoid(->)_$cp1Monoid_info:
         const GHC.Base.$fMonoid(->)_$cp1Monoid_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.912664802 UTC

[section ""data" . GHC.Base.$fMonoid(->)_closure" {
     GHC.Base.$fMonoid(->)_closure:
         const GHC.Base.$fMonoid(->)_info;
 },
 lvl3_shiu_entry() //  [R1]
         { []
         }
     {offset
       cl2I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cl2J; else goto cl2K;
       cl2J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl2K: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl3_shiu_info" {
     lvl3_shiu_info:
         const lvl3_shiu_entry;
         const 1;
         const 16;
 },
 sat_shiz_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cl2Q: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonoid(->)_$cmconcat_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shiz_info" {
     sat_shiz_info:
         const sat_shiz_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_shiy_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cl2Y: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fMonoid(->)_$cmappend_entry(R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shiy_info" {
     sat_shiy_info:
         const sat_shiy_entry;
         const 1;
         const 9;
         const 12884901911;
 },
 sat_shix_entry() //  [R1]
         { []
         }
     {offset
       cl36: // global
           R1 = P64[R1 + 7];
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shix_info" {
     sat_shix_info:
         const sat_shix_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_shiv_entry() //  [R1]
         { []
         }
     {offset
       cl3d: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cl3e; else goto cl3f;
       cl3e: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl3f: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fMonoid(->)_$cp1Monoid_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shiv_info" {
     sat_shiv_info:
         const sat_shiv_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fMonoid(->)_entry() //  [R2]
         { []
         }
     {offset
       cl3h: // global
           Hp = Hp + 136;
           if (Hp > HpLim) (likely: False) goto cl3l; else goto cl3k;
       cl3l: // global
           HpAlloc = 136;
           R2 = R2;
           R1 = GHC.Base.$fMonoid(->)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl3k: // global
           I64[Hp - 128] = lvl3_shiu_info;
           P64[Hp - 112] = R2;
           I64[Hp - 104] = sat_shiz_info;
           P64[Hp - 96] = R2;
           I64[Hp - 88] = sat_shiy_info;
           P64[Hp - 80] = R2;
           I64[Hp - 72] = sat_shix_info;
           P64[Hp - 64] = Hp - 128;
           I64[Hp - 56] = sat_shiv_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = Hp - 56;
           P64[Hp - 16] = Hp - 71;
           P64[Hp - 8] = Hp - 85;
           P64[Hp] = Hp - 102;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonoid(->)_info" {
     GHC.Base.$fMonoid(->)_info:
         const GHC.Base.$fMonoid(->)_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.923832892 UTC

[section ""data" . GHC.Base.$fSemigroup[]_$cstimes_closure" {
     GHC.Base.$fSemigroup[]_$cstimes_closure:
         const GHC.Base.$fSemigroup[]_$cstimes_info;
         const 0;
 },
 GHC.Base.$fSemigroup[]_$cstimes_entry() //  [R2]
         { []
         }
     {offset
       cl3Z: // global
           R2 = R2;
           R1 = Data.Semigroup.Internal.stimesList_closure;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fSemigroup[]_$cstimes_info" {
     GHC.Base.$fSemigroup[]_$cstimes_info:
         const GHC.Base.$fSemigroup[]_$cstimes_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const Si3a_srt+128;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.926914028 UTC

[section ""data" . GHC.Base.$fSemigroup[]_closure" {
     GHC.Base.$fSemigroup[]_closure:
         const GHC.Base.C:Semigroup_con_info;
         const GHC.Base.++_closure+2;
         const GHC.Base.$fSemigroup[]_$csconcat_closure+1;
         const GHC.Base.$fSemigroup[]_$cstimes_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.928605994 UTC

[section ""data" . GHC.Base.$fMonoid[]_closure" {
     GHC.Base.$fMonoid[]_closure:
         const GHC.Base.C:Monoid_con_info;
         const GHC.Base.$fSemigroup[]_closure+1;
         const GHC.Types.[]_closure+1;
         const GHC.Base.++_closure+2;
         const GHC.Base.$fMonoid[]_$cmconcat_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.931406491 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$cpure_closure" {
     GHC.Base.$fApplicativeNonEmpty_$cpure_closure:
         const GHC.Base.$fApplicativeNonEmpty_$cpure_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$cpure_entry() //  [R2]
         { []
         }
     {offset
       cl4d: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl4h; else goto cl4g;
       cl4h: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$cpure_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl4g: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeNonEmpty_$cpure_info" {
     GHC.Base.$fApplicativeNonEmpty_$cpure_info:
         const GHC.Base.$fApplicativeNonEmpty_$cpure_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.936804428 UTC

[section ""data" . GHC.Base.$w$cliftA2_closure" {
     GHC.Base.$w$cliftA2_closure:
         const GHC.Base.$w$cliftA2_info;
 },
 sat_shiI_entry() //  [R1, R2]
         { []
         }
     {offset
       cl4G: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cl4K; else goto cl4J;
       cl4K: // global
           HpAlloc = 64;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl4J: // global
           _shiC::P64 = P64[R1 + 7];
           _shiF::P64 = P64[R1 + 15];
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = _shiC::P64;
           P64[Hp - 32] = _shiF::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shiI_info" {
     sat_shiI_info:
         const sat_shiI_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 sat_shiM_entry() //  [R1, R2]
         { []
         }
     {offset
       cl4O: // global
           _shiF::P64 = R2;
           _shiM::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cl4P; else goto cl4Q;
       cl4Q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl4S; else goto cl4R;
       cl4S: // global
           HpAlloc = 24;
           goto cl4P;
       cl4P: // global
           R2 = _shiF::P64;
           R1 = _shiM::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl4R: // global
           _shiC::P64 = P64[_shiM::P64 + 7];
           _shiE::P64 = P64[_shiM::P64 + 15];
           I64[Hp - 16] = sat_shiI_info;
           P64[Hp - 8] = _shiC::P64;
           P64[Hp] = _shiF::P64;
           I64[Sp - 8] = block_cl4L_info;
           R3 = Hp - 15;
           R2 = _shiE::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_shiM_info" {
     sat_shiM_info:
         const sat_shiM_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _cl4L() //  [R1, R2]
         { []
         }
     {offset
       cl4L: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl4V; else goto cl4U;
       cl4V: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cl4U: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cl4L_info" {
     block_cl4L_info:
         const _cl4L;
         const 0;
         const 30;
 },
 GHC.Base.$w$cliftA2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cl4W: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl50; else goto cl4Z;
       cl50: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cl4Z: // global
           I64[Hp - 16] = sat_shiM_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R4;
           _shiD::P64 = R3;
           R3 = Hp - 15;
           R2 = _shiD::P64;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$cliftA2_info" {
     GHC.Base.$w$cliftA2_info:
         const GHC.Base.$w$cliftA2_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.946628644 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure" {
     GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure:
         const GHC.Base.$fApplicativeNonEmpty_$cliftA2_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$cliftA2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cl5x: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cl5y; else goto cl5z;
       cl5y: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cl5z: // global
           I64[Sp - 8] = block_cl5u_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$cliftA2_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeNonEmpty_$cliftA2_info" {
     GHC.Base.$fApplicativeNonEmpty_$cliftA2_info:
         const GHC.Base.$fApplicativeNonEmpty_$cliftA2_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cl5u() //  [R1, R2]
         { []
         }
     {offset
       cl5u: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl5C; else goto cl5B;
       cl5C: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cl5B: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cl5u_info" {
     block_cl5u_info:
         const _cl5u;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.953505501 UTC

[section ""data" . GHC.Base.$w$c<*_closure" {
     GHC.Base.$w$c<*_closure:
         const GHC.Base.$w$c<*_info;
 },
 sat_shiY_entry() //  [R1]
         { []
         }
     {offset
       cl63: // global
           R1 = P64[R1 + 7];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shiY_info" {
     sat_shiY_info:
         const sat_shiY_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_shj2_entry() //  [R1, R2]
         { []
         }
     {offset
       cl69: // global
           _shiV::P64 = R2;
           _shj2::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cl6a; else goto cl6b;
       cl6b: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cl6d; else goto cl6c;
       cl6d: // global
           HpAlloc = 40;
           goto cl6a;
       cl6a: // global
           R2 = _shiV::P64;
           R1 = _shj2::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl6c: // global
           _shiU::P64 = P64[_shj2::P64 + 7];
           I64[Hp - 32] = GHC.Base.:|_con_info;
           P64[Hp - 24] = _shiV::P64;
           P64[Hp - 16] = GHC.Types.[]_closure+1;
           I64[Hp - 8] = sat_shiY_info;
           P64[Hp] = Hp - 31;
           I64[Sp - 8] = block_cl66_info;
           R3 = Hp - 7;
           R2 = _shiU::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_shj2_info" {
     sat_shj2_info:
         const sat_shj2_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _cl66() //  [R1, R2]
         { []
         }
     {offset
       cl66: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl6g; else goto cl6f;
       cl6g: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cl6f: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cl66_info" {
     block_cl66_info:
         const _cl66;
         const 0;
         const 30;
 },
 GHC.Base.$w$c<*_entry() //  [R2, R3]
         { []
         }
     {offset
       cl6h: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cl6l; else goto cl6k;
       cl6l: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cl6k: // global
           I64[Hp - 8] = sat_shj2_info;
           P64[Hp] = R3;
           R3 = Hp - 7;
           R2 = R2;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$c<*_info" {
     GHC.Base.$w$c<*_info:
         const GHC.Base.$w$c<*_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.962392391 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$c<*_closure" {
     GHC.Base.$fApplicativeNonEmpty_$c<*_closure:
         const GHC.Base.$fApplicativeNonEmpty_$c<*_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$c<*_entry() //  [R2, R3]
         { []
         }
     {offset
       cl6R: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cl6S; else goto cl6T;
       cl6S: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$c<*_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cl6T: // global
           I64[Sp - 8] = block_cl6O_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$c<*_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeNonEmpty_$c<*_info" {
     GHC.Base.$fApplicativeNonEmpty_$c<*_info:
         const GHC.Base.$fApplicativeNonEmpty_$c<*_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cl6O() //  [R1, R2]
         { []
         }
     {offset
       cl6O: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl6W; else goto cl6V;
       cl6W: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cl6V: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cl6O_info" {
     block_cl6O_info:
         const _cl6O;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.969105932 UTC

[section ""data" . GHC.Base.$w$c<*>_closure" {
     GHC.Base.$w$c<*>_closure:
         const GHC.Base.$w$c<*>_info;
 },
 sat_shjd_entry() //  [R1, R2]
         { []
         }
     {offset
       cl7o: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cl7s; else goto cl7r;
       cl7s: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl7r: // global
           _shja::P64 = P64[R1 + 7];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = _shja::P64;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shjd_info" {
     sat_shjd_info:
         const sat_shjd_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_shjh_entry() //  [R1, R2]
         { []
         }
     {offset
       cl7w: // global
           _shja::P64 = R2;
           _shjh::P64 = R1;
           if ((Sp + -8) < SpLim) (likely: False) goto cl7x; else goto cl7y;
       cl7y: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cl7A; else goto cl7z;
       cl7A: // global
           HpAlloc = 16;
           goto cl7x;
       cl7x: // global
           R2 = _shja::P64;
           R1 = _shjh::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl7z: // global
           _shj9::P64 = P64[_shjh::P64 + 7];
           I64[Hp - 8] = sat_shjd_info;
           P64[Hp] = _shja::P64;
           I64[Sp - 8] = block_cl7t_info;
           R3 = Hp - 7;
           R2 = _shj9::P64;
           Sp = Sp - 8;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . sat_shjh_info" {
     sat_shjh_info:
         const sat_shjh_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _cl7t() //  [R1, R2]
         { []
         }
     {offset
       cl7t: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl7D; else goto cl7C;
       cl7D: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cl7C: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cl7t_info" {
     block_cl7t_info:
         const _cl7t;
         const 0;
         const 30;
 },
 GHC.Base.$w$c<*>_entry() //  [R2, R3]
         { []
         }
     {offset
       cl7E: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cl7I; else goto cl7H;
       cl7I: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$w$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cl7H: // global
           I64[Hp - 8] = sat_shjh_info;
           P64[Hp] = R3;
           R3 = Hp - 7;
           R2 = R2;
           call GHC.Base.$w$c>>=_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$w$c<*>_info" {
     GHC.Base.$w$c<*>_info:
         const GHC.Base.$w$c<*>_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.978960705 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$c<*>_closure" {
     GHC.Base.$fApplicativeNonEmpty_$c<*>_closure:
         const GHC.Base.$fApplicativeNonEmpty_$c<*>_info;
 },
 GHC.Base.$fApplicativeNonEmpty_$c<*>_entry() //  [R2, R3]
         { []
         }
     {offset
       cl8f: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cl8g; else goto cl8h;
       cl8g: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeNonEmpty_$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cl8h: // global
           I64[Sp - 8] = block_cl8c_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.Base.$w$c<*>_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeNonEmpty_$c<*>_info" {
     GHC.Base.$fApplicativeNonEmpty_$c<*>_info:
         const GHC.Base.$fApplicativeNonEmpty_$c<*>_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cl8c() //  [R1, R2]
         { []
         }
     {offset
       cl8c: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl8k; else goto cl8j;
       cl8k: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cl8j: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cl8c_info" {
     block_cl8c_info:
         const _cl8c;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.983855161 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty1_closure" {
     GHC.Base.$fApplicativeNonEmpty1_closure:
         const GHC.Base.$fApplicativeNonEmpty1_info;
 },
 GHC.Base.$fApplicativeNonEmpty1_entry() //  [R3]
         { []
         }
     {offset
       cl8A: // global
           R1 = R3;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeNonEmpty1_info" {
     GHC.Base.$fApplicativeNonEmpty1_info:
         const GHC.Base.$fApplicativeNonEmpty1_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.988405 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_$c*>_closure" {
     GHC.Base.$fApplicativeNonEmpty_$c*>_closure:
         const GHC.Base.$fApplicativeNonEmpty_$c*>_info;
 },
 sat_shju_entry() //  [R1]
         { []
         }
     {offset
       cl8S: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cl8T; else goto cl8U;
       cl8T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl8U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cl8P_info;
           R1 = P64[R1 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ul8Y; else goto cl8Q;
       ul8Y: // global
           call _cl8P(R1) args: 0, res: 0, upd: 0;
       cl8Q: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_shju_info" {
     sat_shju_info:
         const sat_shju_entry;
         const 1;
         const 16;
 },
 _cl8P() //  [R1]
         { []
         }
     {offset
       cl8P: // global
           R3 = P64[R1 + 15];
           R2 = GHC.Base.$fApplicativeNonEmpty1_closure+2;
           Sp = Sp + 8;
           call GHC.Base.map_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cl8P_info" {
     block_cl8P_info:
         const _cl8P;
         const 0;
         const 30;
 },
 GHC.Base.$fApplicativeNonEmpty_$c*>_entry() //  [R2, R3]
         { []
         }
     {offset
       cl93: // global
           _shjq::P64 = R3;
           _shjp::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cl94; else goto cl95;
       cl95: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cl97; else goto cl96;
       cl97: // global
           HpAlloc = 48;
           goto cl94;
       cl94: // global
           R3 = _shjq::P64;
           R2 = _shjp::P64;
           R1 = GHC.Base.$fApplicativeNonEmpty_$c*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cl96: // global
           I64[Hp - 40] = sat_shju_info;
           P64[Hp - 24] = _shjp::P64;
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = GHC.Base.breakpoint_closure+1;
           P64[Hp] = Hp - 40;
           I64[Sp - 8] = block_cl90_info;
           R3 = _shjq::P64;
           R2 = Hp - 15;
           Sp = Sp - 8;
           call GHC.Base.$w$c<*>_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeNonEmpty_$c*>_info" {
     GHC.Base.$fApplicativeNonEmpty_$c*>_info:
         const GHC.Base.$fApplicativeNonEmpty_$c*>_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cl90() //  [R1, R2]
         { []
         }
     {offset
       cl90: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cl9a; else goto cl99;
       cl9a: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cl99: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cl90_info" {
     block_cl90_info:
         const _cl90;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.996424243 UTC

[section ""data" . GHC.Base.$fApplicativeNonEmpty_closure" {
     GHC.Base.$fApplicativeNonEmpty_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctorNonEmpty_closure+1;
         const GHC.Base.$fApplicativeNonEmpty_$cpure_closure+1;
         const GHC.Base.$fApplicativeNonEmpty_$c<*>_closure+2;
         const GHC.Base.$fApplicativeNonEmpty_$cliftA2_closure+3;
         const GHC.Base.$fApplicativeNonEmpty_$c*>_closure+2;
         const GHC.Base.$fApplicativeNonEmpty_$c<*_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:58.998598252 UTC

[section ""data" . lvl_r7PJ_closure" {
     lvl_r7PJ_closure:
         const lvl_r7PJ_info;
         const 0;
 },
 lvl_r7PJ_entry() //  [R2]
         { []
         }
     {offset
       cl9F: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . lvl_r7PJ_info" {
     lvl_r7PJ_info:
         const lvl_r7PJ_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const Si3a_srt+72;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.001671625 UTC

[section ""data" . GHC.Base.$fMonadNonEmpty_closure" {
     GHC.Base.$fMonadNonEmpty_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicativeNonEmpty_closure+1;
         const GHC.Base.$fMonadNonEmpty_$c>>=_closure+2;
         const GHC.Base.$fMonadNonEmpty_$c>>_closure+2;
         const GHC.Base.$fApplicativeNonEmpty_$cpure_closure+1;
         const lvl_r7PJ_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.00385297 UTC

[section ""cstring" . GHC.Base.$fAlternativeIO4_bytes" {
     GHC.Base.$fAlternativeIO4_bytes:
         I8[] [109,122,101,114,111]
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.006279096 UTC

[section ""data" . GHC.Base.$fAlternativeIO3_closure" {
     GHC.Base.$fAlternativeIO3_closure:
         const GHC.Base.$fAlternativeIO3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Base.$fAlternativeIO3_entry() //  [R1]
         { []
         }
     {offset
       cl9U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cl9V; else goto cl9W;
       cl9V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9W: // global
           (_cl9R::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cl9R::I64 == 0) goto cl9T; else goto cl9S;
       cl9T: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cl9S: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cl9R::I64;
           R2 = GHC.Base.$fAlternativeIO4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Base.$fAlternativeIO3_info" {
     GHC.Base.$fAlternativeIO3_info:
         const GHC.Base.$fAlternativeIO3_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.010311355 UTC

[section ""data" . GHC.Base.$fAlternativeIO_$cempty_closure" {
     GHC.Base.$fAlternativeIO_$cempty_closure:
         const GHC.Base.$fAlternativeIO_$cempty_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.Base.$fAlternativeIO_$cempty_entry() //  [R1]
         { []
         }
     {offset
       clab: // global
           if ((Sp + -16) < SpLim) (likely: False) goto clac; else goto clad;
       clac: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clad: // global
           (_cla8::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cla8::I64 == 0) goto claa; else goto cla9;
       claa: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cla9: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cla8::I64;
           R2 = GHC.Base.$fAlternativeIO3_closure;
           R1 = GHC.IO.failIO_closure;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.Base.$fAlternativeIO_$cempty_info" {
     GHC.Base.$fAlternativeIO_$cempty_info:
         const GHC.Base.$fAlternativeIO_$cempty_entry;
         const 0;
         const 554050781205;
         const Si3a_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.014753819 UTC

[section ""data" . GHC.Base.$fAlternativeIO_closure" {
     GHC.Base.$fAlternativeIO_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Base.$fApplicativeIO_closure+1;
         const GHC.Base.$fAlternativeIO_$cempty_closure;
         const GHC.IO.mplusIO_closure;
         const GHC.Base.$fAlternativeIO2_closure+2;
         const GHC.Base.$fAlternativeIO_$cmany_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.016479291 UTC

[section ""data" . GHC.Base.$fMonadPlusIO_closure" {
     GHC.Base.$fMonadPlusIO_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Base.$fAlternativeIO_closure+1;
         const GHC.Base.$fMonadIO_closure+1;
         const GHC.Base.$fAlternativeIO_$cempty_closure;
         const GHC.IO.mplusIO_closure;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.019118714 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_$c<|>_closure" {
     GHC.Base.$fAlternativeMaybe_$c<|>_closure:
         const GHC.Base.$fAlternativeMaybe_$c<|>_info;
 },
 GHC.Base.$fAlternativeMaybe_$c<|>_entry() //  [R2, R3]
         { []
         }
     {offset
       claz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto claA; else goto claB;
       claA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fAlternativeMaybe_$c<|>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       claB: // global
           I64[Sp - 16] = block_clas_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ulaI; else goto clat;
       ulaI: // global
           call _clas(R1) args: 0, res: 0, upd: 0;
       clat: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fAlternativeMaybe_$c<|>_info" {
     GHC.Base.$fAlternativeMaybe_$c<|>_info:
         const GHC.Base.$fAlternativeMaybe_$c<|>_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _clas() //  [R1]
         { []
         }
     {offset
       clas: // global
           if (R1 & 7 == 1) goto claw; else goto clax;
       claw: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       clax: // global
           R1 = R1 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_clas_info" {
     block_clas_info:
         const _clas;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.026941498 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$cliftA2_closure" {
     GHC.Base.$fApplicativeMaybe_$cliftA2_closure:
         const GHC.Base.$fApplicativeMaybe_$cliftA2_info;
 },
 GHC.Base.$fApplicativeMaybe_$cliftA2_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       clba: // global
           if ((Sp + -24) < SpLim) (likely: False) goto clbb; else goto clbc;
       clbb: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$cliftA2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       clbc: // global
           I64[Sp - 24] = block_clb3_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ulbE; else goto clb4;
       ulbE: // global
           call _clb3(R1) args: 0, res: 0, upd: 0;
       clb4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeMaybe_$cliftA2_info" {
     GHC.Base.$fApplicativeMaybe_$cliftA2_info:
         const GHC.Base.$fApplicativeMaybe_$cliftA2_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _clb3() //  [R1]
         { []
         }
     {offset
       clb3: // global
           if (R1 & 7 == 1) goto ulbA; else goto clb8;
       ulbA: // global
           Sp = Sp + 24;
           call _clbq() args: 0, res: 0, upd: 0;
       clb8: // global
           I64[Sp] = block_clbi_info;
           _shjI::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _shjI::P64;
           if (R1 & 7 != 0) goto ulbC; else goto clbk;
       ulbC: // global
           call _clbi(R1) args: 0, res: 0, upd: 0;
       clbk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_clb3_info" {
     block_clb3_info:
         const _clb3;
         const 2;
         const 30;
 },
 _clbi() //  [R1]
         { []
         }
     {offset
       clbi: // global
           if (R1 & 7 == 1) goto ulbB; else goto clbv;
       ulbB: // global
           Sp = Sp + 24;
           call _clbq() args: 0, res: 0, upd: 0;
       clbv: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto clby; else goto clbx;
       clby: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       clbx: // global
           _shjK::P64 = P64[R1 + 6];
           I64[Hp - 48] = stg_ap_3_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = P64[Sp + 16];
           P64[Hp - 16] = _shjK::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 48;
           R1 = Hp - 6;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_clbi_info" {
     block_clbi_info:
         const _clbi;
         const 2;
         const 30;
 },
 _clbq() //  []
         { []
         }
     {offset
       clbq: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.035145007 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$c*>_closure" {
     GHC.Base.$fApplicativeMaybe_$c*>_closure:
         const GHC.Base.$fApplicativeMaybe_$c*>_info;
 },
 GHC.Base.$fApplicativeMaybe_$c*>_entry() //  [R2, R3]
         { []
         }
     {offset
       clcj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto clck; else goto clcl;
       clck: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$c*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       clcl: // global
           I64[Sp - 16] = block_clcc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ulcs; else goto clcd;
       ulcs: // global
           call _clcc(R1) args: 0, res: 0, upd: 0;
       clcd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeMaybe_$c*>_info" {
     GHC.Base.$fApplicativeMaybe_$c*>_info:
         const GHC.Base.$fApplicativeMaybe_$c*>_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _clcc() //  [R1]
         { []
         }
     {offset
       clcc: // global
           if (R1 & 7 == 1) goto clcg; else goto clch;
       clcg: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       clch: // global
           R1 = P64[Sp + 8] & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_clcc_info" {
     block_clcc_info:
         const _clcc;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.041020833 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$c<*>_closure" {
     GHC.Base.$fApplicative(->)_$c<*>_closure:
         const GHC.Base.$fApplicative(->)_$c<*>_info;
 },
 GHC.Base.$fApplicative(->)_$c<*>_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       clcN: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto clcR; else goto clcQ;
       clcR: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(->)_$c<*>_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       clcQ: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = Hp - 24;
           _shjQ::P64 = R2;
           R2 = R4;
           R1 = _shjQ::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative(->)_$c<*>_info" {
     GHC.Base.$fApplicative(->)_$c<*>_info:
         const GHC.Base.$fApplicative(->)_$c<*>_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.045322772 UTC

[section ""data" . GHC.Base.$fApplicative(->)_$cliftA2_closure" {
     GHC.Base.$fApplicative(->)_$cliftA2_closure:
         const GHC.Base.$fApplicative(->)_$cliftA2_info;
 },
 GHC.Base.$fApplicative(->)_$cliftA2_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cld3: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cld7; else goto cld6;
       cld7: // global
           HpAlloc = 64;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(->)_$cliftA2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cld6: // global
           I64[Hp - 56] = stg_ap_2_upd_info;
           P64[Hp - 40] = R4;
           P64[Hp - 32] = R5;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R5;
           R3 = Hp - 56;
           _shjU::P64 = R2;
           R2 = Hp - 24;
           R1 = _shjU::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative(->)_$cliftA2_info" {
     GHC.Base.$fApplicative(->)_$cliftA2_info:
         const GHC.Base.$fApplicative(->)_$cliftA2_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.048705514 UTC

[section ""data" . GHC.Base.$fApplicative(->)_closure" {
     GHC.Base.$fApplicative(->)_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctor(->)_closure+1;
         const GHC.Base.const_closure+2;
         const GHC.Base.$fApplicative(->)_$c<*>_closure+3;
         const GHC.Base.$fApplicative(->)_$cliftA2_closure+4;
         const GHC.Base.$fApplicative(->)_$c*>_closure+3;
         const GHC.Base.$fApplicative(->)_$c<*_closure+3;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.050686626 UTC

[section ""data" . lvl1_r7PK_closure" {
     lvl1_r7PK_closure:
         const lvl1_r7PK_info;
         const 0;
 },
 lvl1_r7PK_entry() //  [R2]
         { []
         }
     {offset
       cldj: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . lvl1_r7PK_info" {
     lvl1_r7PK_info:
         const lvl1_r7PK_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const Si3a_srt+72;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.053603455 UTC

[section ""data" . GHC.Base.$fMonad(->)_closure" {
     GHC.Base.$fMonad(->)_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicative(->)_closure+1;
         const GHC.Base.$fMonad(->)_$c>>=_closure+3;
         const GHC.Base.$fMonad(->)_$c>>_closure+3;
         const GHC.Base.const_closure+2;
         const lvl1_r7PK_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.056442699 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$cfmap_closure" {
     GHC.Base.$fApplicativeMaybe_$cfmap_closure:
         const GHC.Base.$fApplicativeMaybe_$cfmap_info;
 },
 GHC.Base.$fApplicativeMaybe_$cfmap_entry() //  [R2, R3]
         { []
         }
     {offset
       cldC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cldD; else goto cldE;
       cldD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$cfmap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cldE: // global
           I64[Sp - 16] = block_cldv_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uldP; else goto cldw;
       uldP: // global
           call _cldv(R1) args: 0, res: 0, upd: 0;
       cldw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeMaybe_$cfmap_info" {
     GHC.Base.$fApplicativeMaybe_$cfmap_info:
         const GHC.Base.$fApplicativeMaybe_$cfmap_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cldv() //  [R1]
         { []
         }
     {offset
       cldv: // global
           if (R1 & 7 == 1) goto cldz; else goto cldA;
       cldz: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cldA: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cldO; else goto cldN;
       cldO: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cldN: // global
           _shk4::P64 = P64[R1 + 6];
           I64[Hp - 40] = stg_ap_2_upd_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = _shk4::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 40;
           R1 = Hp - 6;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cldv_info" {
     block_cldv_info:
         const _cldv;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.061810299 UTC

[section ""data" . GHC.Base.$fFunctorMaybe_closure" {
     GHC.Base.$fFunctorMaybe_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fApplicativeMaybe_$cfmap_closure+2;
         const GHC.Base.$fFunctorMaybe_$c<$_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.064279097 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_$c<*>_closure" {
     GHC.Base.$fApplicativeMaybe_$c<*>_closure:
         const GHC.Base.$fApplicativeMaybe_$c<*>_info;
 },
 GHC.Base.$fApplicativeMaybe_$c<*>_entry() //  [R2, R3]
         { []
         }
     {offset
       clek: // global
           if ((Sp + -16) < SpLim) (likely: False) goto clel; else goto clem;
       clel: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fApplicativeMaybe_$c<*>_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       clem: // global
           I64[Sp - 16] = block_cled_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ulet; else goto clee;
       ulet: // global
           call _cled(R1) args: 0, res: 0, upd: 0;
       clee: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicativeMaybe_$c<*>_info" {
     GHC.Base.$fApplicativeMaybe_$c<*>_info:
         const GHC.Base.$fApplicativeMaybe_$c<*>_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cled() //  [R1]
         { []
         }
     {offset
       cled: // global
           if (R1 & 7 == 1) goto cleh; else goto clei;
       cleh: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       clei: // global
           R3 = P64[Sp + 8];
           R2 = P64[R1 + 6];
           Sp = Sp + 16;
           call GHC.Base.$fApplicativeMaybe_$cfmap_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cled_info" {
     block_cled_info:
         const _cled;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.069726144 UTC

[section ""data" . GHC.Base.$fApplicativeMaybe_closure" {
     GHC.Base.$fApplicativeMaybe_closure:
         const GHC.Base.C:Applicative_con_info;
         const GHC.Base.$fFunctorMaybe_closure+1;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fApplicativeMaybe_$c<*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$cliftA2_closure+3;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c<*_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.071850301 UTC

[section ""data" . GHC.Base.$fMonadMaybe_closure" {
     GHC.Base.$fMonadMaybe_closure:
         const GHC.Base.C:Monad_con_info;
         const GHC.Base.$fApplicativeMaybe_closure+1;
         const GHC.Base.$fMonadMaybe_$c>>=_closure+2;
         const GHC.Base.$fApplicativeMaybe_$c*>_closure+2;
         const GHC.Base.Just_closure+1;
         const GHC.Base.$fMonadMaybe_$cfail_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.074047 UTC

[section ""data" . GHC.Base.$fAlternativeMaybe_closure" {
     GHC.Base.$fAlternativeMaybe_closure:
         const GHC.Base.C:Alternative_con_info;
         const GHC.Base.$fApplicativeMaybe_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.$fAlternativeMaybe_$c<|>_closure+2;
         const GHC.Base.$fAlternativeMaybe_$csome_closure+1;
         const GHC.Base.$fAlternativeMaybe_$cmany_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.07573839 UTC

[section ""data" . GHC.Base.$fMonadPlusMaybe_closure" {
     GHC.Base.$fMonadPlusMaybe_closure:
         const GHC.Base.C:MonadPlus_con_info;
         const GHC.Base.$fAlternativeMaybe_closure+1;
         const GHC.Base.$fMonadMaybe_closure+1;
         const GHC.Base.Nothing_closure+1;
         const GHC.Base.$fAlternativeMaybe_$c<|>_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.079580516 UTC

[section ""data" . GHC.Base.liftA3_$sliftA3_closure" {
     GHC.Base.liftA3_$sliftA3_closure:
         const GHC.Base.liftA3_$sliftA3_info;
 },
 GHC.Base.liftA3_$sliftA3_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cleW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cleX; else goto cleY;
       cleX: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.liftA3_$sliftA3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cleY: // global
           I64[Sp - 32] = block_cleP_info;
           R1 = R3;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ulfE; else goto cleQ;
       ulfE: // global
           call _cleP(R1) args: 0, res: 0, upd: 0;
       cleQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftA3_$sliftA3_info" {
     GHC.Base.liftA3_$sliftA3_info:
         const GHC.Base.liftA3_$sliftA3_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _cleP() //  [R1]
         { []
         }
     {offset
       cleP: // global
           if (R1 & 7 == 1) goto ulfz; else goto cleU;
       ulfz: // global
           Sp = Sp + 32;
           call _clfo() args: 0, res: 0, upd: 0;
       cleU: // global
           I64[Sp] = block_clf4_info;
           _shkf::P64 = P64[R1 + 6];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _shkf::P64;
           if (R1 & 7 != 0) goto ulfC; else goto clf6;
       ulfC: // global
           call _clf4(R1) args: 0, res: 0, upd: 0;
       clf6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cleP_info" {
     block_cleP_info:
         const _cleP;
         const 3;
         const 30;
 },
 _clf4() //  [R1]
         { []
         }
     {offset
       clf4: // global
           if (R1 & 7 == 1) goto ulfA; else goto clfh;
       ulfA: // global
           Sp = Sp + 32;
           call _clfo() args: 0, res: 0, upd: 0;
       clfh: // global
           I64[Sp] = block_clff_info;
           _shkh::P64 = P64[R1 + 6];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _shkh::P64;
           if (R1 & 7 != 0) goto ulfF; else goto clfi;
       ulfF: // global
           call _clff(R1) args: 0, res: 0, upd: 0;
       clfi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_clf4_info" {
     block_clf4_info:
         const _clf4;
         const 3;
         const 30;
 },
 _clff() //  [R1]
         { []
         }
     {offset
       clff: // global
           if (R1 & 7 == 1) goto ulfB; else goto clft;
       ulfB: // global
           Sp = Sp + 32;
           call _clfo() args: 0, res: 0, upd: 0;
       clft: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto clfw; else goto clfv;
       clfw: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       clfv: // global
           _shkj::P64 = P64[R1 + 6];
           I64[Hp - 56] = stg_ap_4_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = _shkj::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 56;
           R1 = Hp - 6;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_clff_info" {
     block_clff_info:
         const _clff;
         const 3;
         const 30;
 },
 _clfo() //  []
         { []
         }
     {offset
       clfo: // global
           R1 = GHC.Base.Nothing_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.090247266 UTC

[section ""data" . GHC.Base.liftA3_closure" {
     GHC.Base.liftA3_closure:
         const GHC.Base.liftA3_info;
 },
 sat_shkq_entry() //  [R1]
         { []
         }
     {offset
       clgq: // global
           if ((Sp + -48) < SpLim) (likely: False) goto clgr; else goto clgs;
       clgr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clgs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 48] = stg_ap_ppp_info;
           P64[Sp - 40] = P64[R1 + 24];
           P64[Sp - 32] = P64[R1 + 32];
           P64[Sp - 24] = P64[R1 + 40];
           Sp = Sp - 48;
           call GHC.Base.liftA2_entry(R2) args: 56, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shkq_info" {
     sat_shkq_info:
         const sat_shkq_entry;
         const 4;
         const 15;
 },
 GHC.Base.liftA3_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       clgt: // global
           _shkp::P64 = R6;
           _shko::P64 = R5;
           _shkn::P64 = R4;
           _shkm::P64 = R3;
           _shkl::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto clgu; else goto clgv;
       clgv: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto clgx; else goto clgw;
       clgx: // global
           HpAlloc = 48;
           goto clgu;
       clgu: // global
           R6 = _shkp::P64;
           R5 = _shko::P64;
           R4 = _shkn::P64;
           R3 = _shkm::P64;
           R2 = _shkl::P64;
           R1 = GHC.Base.liftA3_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       clgw: // global
           I64[Hp - 40] = sat_shkq_info;
           P64[Hp - 24] = _shkl::P64;
           P64[Hp - 16] = _shkm::P64;
           P64[Hp - 8] = _shkn::P64;
           P64[Hp] = _shko::P64;
           R2 = _shkl::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 40;
           P64[Sp - 8] = _shkp::P64;
           Sp = Sp - 24;
           call GHC.Base.<*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftA3_info" {
     GHC.Base.liftA3_info:
         const GHC.Base.liftA3_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.09559762 UTC

[section ""data" . GHC.Base.liftA_$sliftA_closure" {
     GHC.Base.liftA_$sliftA_closure:
         const GHC.Base.liftA_$sliftA_info;
 },
 GHC.Base.liftA_$sliftA_entry() //  [R2, R3]
         { []
         }
     {offset
       clgT: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.$fApplicativeMaybe_$cfmap_entry(R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftA_$sliftA_info" {
     GHC.Base.liftA_$sliftA_info:
         const GHC.Base.liftA_$sliftA_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.099556026 UTC

[section ""data" . GHC.Base.liftA_closure" {
     GHC.Base.liftA_closure:
         const GHC.Base.liftA_info;
 },
 sat_shku_entry() //  [R1]
         { []
         }
     {offset
       clh8: // global
           if ((Sp + -32) < SpLim) (likely: False) goto clh9; else goto clha;
       clh9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clha: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = P64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Base.pure_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shku_info" {
     sat_shku_info:
         const sat_shku_entry;
         const 2;
         const 18;
 },
 GHC.Base.liftA_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       clhb: // global
           _shkt::P64 = R4;
           _shks::P64 = R3;
           _shkr::P64 = R2;
           if ((Sp + -24) < SpLim) (likely: False) goto clhc; else goto clhd;
       clhd: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto clhf; else goto clhe;
       clhf: // global
           HpAlloc = 32;
           goto clhc;
       clhc: // global
           R4 = _shkt::P64;
           R3 = _shks::P64;
           R2 = _shkr::P64;
           R1 = GHC.Base.liftA_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       clhe: // global
           I64[Hp - 24] = sat_shku_info;
           P64[Hp - 8] = _shkr::P64;
           P64[Hp] = _shks::P64;
           R2 = _shkr::P64;
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = Hp - 24;
           P64[Sp - 8] = _shkt::P64;
           Sp = Sp - 24;
           call GHC.Base.<*>_entry(R2) args: 32, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.liftA_info" {
     GHC.Base.liftA_info:
         const GHC.Base.liftA_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.105515326 UTC

[section ""data" . GHC.Base.$fFunctor(,)_$cfmap_closure" {
     GHC.Base.$fFunctor(,)_$cfmap_closure:
         const GHC.Base.$fFunctor(,)_$cfmap_info;
 },
 GHC.Base.$fFunctor(,)_$cfmap_entry() //  [R2, R3]
         { []
         }
     {offset
       clhC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto clhH; else goto clhI;
       clhH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.$fFunctor(,)_$cfmap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       clhI: // global
           I64[Sp - 16] = block_clhz_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ulhM; else goto clhA;
       ulhM: // global
           call _clhz(R1) args: 0, res: 0, upd: 0;
       clhA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fFunctor(,)_$cfmap_info" {
     GHC.Base.$fFunctor(,)_$cfmap_info:
         const GHC.Base.$fFunctor(,)_$cfmap_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _clhz() //  [R1]
         { []
         }
     {offset
       clhz: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto clhL; else goto clhK;
       clhL: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       clhK: // global
           _shky::P64 = P64[R1 + 7];
           _shkz::P64 = P64[R1 + 15];
           I64[Hp - 48] = stg_ap_2_upd_info;
           P64[Hp - 32] = P64[Sp + 8];
           P64[Hp - 24] = _shkz::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _shky::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_clhz_info" {
     block_clhz_info:
         const _clhz;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.11120824 UTC

[section ""data" . GHC.Base.$fFunctor(,)_closure" {
     GHC.Base.$fFunctor(,)_closure:
         const GHC.Base.C:Functor_con_info;
         const GHC.Base.$fFunctor(,)_$cfmap_closure+2;
         const GHC.Base.$fFunctor(,)_$c<$_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.115409224 UTC

[section ""data" . GHC.Base.$fApplicative(,)_closure" {
     GHC.Base.$fApplicative(,)_closure:
         const GHC.Base.$fApplicative(,)_info;
 },
 lvl3_shkC_entry() //  [R1]
         { []
         }
     {offset
       clib: // global
           if ((Sp + -16) < SpLim) (likely: False) goto clic; else goto clid;
       clic: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clid: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl3_shkC_info" {
     lvl3_shkC_info:
         const lvl3_shkC_entry;
         const 1;
         const 16;
 },
 sat_shkI_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       clij: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fApplicative(,)_$c<*_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shkI_info" {
     sat_shkI_info:
         const sat_shkI_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_shkH_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       clir: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fApplicative(,)_$c*>_entry(R4,
                                                     R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shkH_info" {
     sat_shkH_info:
         const sat_shkH_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_shkG_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cliz: // global
           R5 = R4;
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 5];
           call GHC.Base.$fApplicative(,)_$cliftA2_entry(R5,
                                                         R4,
                                                         R3,
                                                         R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shkG_info" {
     sat_shkG_info:
         const sat_shkG_entry;
         const 1;
         const 9;
         const 12884901911;
 },
 sat_shkF_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cliH: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fApplicative(,)_$c<*>_entry(R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shkF_info" {
     sat_shkF_info:
         const sat_shkF_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_shkE_entry() //  [R1, R2]
         { []
         }
     {offset
       cliQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cliU; else goto cliT;
       cliU: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cliT: // global
           _shkC::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _shkC::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shkE_info" {
     sat_shkE_info:
         const sat_shkE_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 GHC.Base.$fApplicative(,)_entry() //  [R2]
         { []
         }
     {offset
       cliW: // global
           Hp = Hp + 160;
           if (Hp > HpLim) (likely: False) goto clj0; else goto cliZ;
       clj0: // global
           HpAlloc = 160;
           R2 = R2;
           R1 = GHC.Base.$fApplicative(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cliZ: // global
           I64[Hp - 152] = lvl3_shkC_info;
           P64[Hp - 136] = R2;
           I64[Hp - 128] = sat_shkI_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_shkH_info;
           P64[Hp - 104] = R2;
           I64[Hp - 96] = sat_shkG_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_shkF_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_shkE_info;
           P64[Hp - 56] = Hp - 152;
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = GHC.Base.$fFunctor(,)_closure+1;
           P64[Hp - 32] = Hp - 63;
           P64[Hp - 24] = Hp - 78;
           P64[Hp - 16] = Hp - 93;
           P64[Hp - 8] = Hp - 110;
           P64[Hp] = Hp - 126;
           R1 = Hp - 47;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fApplicative(,)_info" {
     GHC.Base.$fApplicative(,)_info:
         const GHC.Base.$fApplicative(,)_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.128026513 UTC

[section ""data" . lvl2_r7PL_closure" {
     lvl2_r7PL_closure:
         const lvl2_r7PL_info;
         const 0;
 },
 lvl2_r7PL_entry() //  [R2]
         { []
         }
     {offset
       cljK: // global
           R2 = R2;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . lvl2_r7PL_info" {
     lvl2_r7PL_info:
         const lvl2_r7PL_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const Si3a_srt+72;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.133236252 UTC

[section ""data" . GHC.Base.$fMonad(,)_closure" {
     GHC.Base.$fMonad(,)_closure:
         const GHC.Base.$fMonad(,)_info;
         const 0;
 },
 lvl3_shkL_entry() //  [R1]
         { []
         }
     {offset
       cljZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto clk0; else goto clk1;
       clk0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clk1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.mempty_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl3_shkL_info" {
     lvl3_shkL_info:
         const lvl3_shkL_entry;
         const 1;
         const 16;
 },
 sat_shkQ_entry() //  [R1, R2]
         { []
         }
     {offset
       clk8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto clkc; else goto clkb;
       clkc: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       clkb: // global
           _shkL::P64 = P64[R1 + 7];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _shkL::P64;
           P64[Hp] = R2;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shkQ_info" {
     sat_shkQ_info:
         const sat_shkQ_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 sat_shkO_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       clki: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonad(,)_$c>>_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shkO_info" {
     sat_shkO_info:
         const sat_shkO_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_shkN_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       clkq: // global
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call GHC.Base.$fMonad(,)_$c>>=_entry(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_shkN_info" {
     sat_shkN_info:
         const sat_shkN_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 sat_shkM_entry() //  [R1]
         { []
         }
     {offset
       clkx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto clky; else goto clkz;
       clky: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clkz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.$fApplicative(,)_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_shkM_info" {
     sat_shkM_info:
         const sat_shkM_entry;
         const 1;
         const 16;
 },
 GHC.Base.$fMonad(,)_entry() //  [R2]
         { []
         }
     {offset
       clkB: // global
           Hp = Hp + 144;
           if (Hp > HpLim) (likely: False) goto clkF; else goto clkE;
       clkF: // global
           HpAlloc = 144;
           R2 = R2;
           R1 = GHC.Base.$fMonad(,)_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       clkE: // global
           I64[Hp - 136] = lvl3_shkL_info;
           P64[Hp - 120] = R2;
           I64[Hp - 112] = sat_shkQ_info;
           P64[Hp - 104] = Hp - 136;
           I64[Hp - 96] = sat_shkO_info;
           P64[Hp - 88] = R2;
           I64[Hp - 80] = sat_shkN_info;
           P64[Hp - 72] = R2;
           I64[Hp - 64] = sat_shkM_info;
           P64[Hp - 48] = R2;
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = Hp - 64;
           P64[Hp - 24] = Hp - 78;
           P64[Hp - 16] = Hp - 94;
           P64[Hp - 8] = Hp - 111;
           P64[Hp] = lvl2_r7PL_closure+1;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.$fMonad(,)_info" {
     GHC.Base.$fMonad(,)_info:
         const GHC.Base.$fMonad(,)_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const Si3a_srt+144;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.14585609 UTC

[section ""data" . GHC.Base.C:Monad_closure" {
     GHC.Base.C:Monad_closure:
         const GHC.Base.C:Monad_info;
 },
 GHC.Base.C:Monad_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       clln: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cllr; else goto cllq;
       cllr: // global
           HpAlloc = 48;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Monad_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cllq: // global
           I64[Hp - 40] = GHC.Base.C:Monad_con_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Monad_info" {
     GHC.Base.C:Monad_info:
         const GHC.Base.C:Monad_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.150207588 UTC

[section ""data" . GHC.Base.C:Functor_closure" {
     GHC.Base.C:Functor_closure:
         const GHC.Base.C:Functor_info;
 },
 GHC.Base.C:Functor_entry() //  [R2, R3]
         { []
         }
     {offset
       cllD: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cllH; else goto cllG;
       cllH: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Functor_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cllG: // global
           I64[Hp - 16] = GHC.Base.C:Functor_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Functor_info" {
     GHC.Base.C:Functor_info:
         const GHC.Base.C:Functor_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.1541342 UTC

[section ""data" . GHC.Base.C:Applicative_closure" {
     GHC.Base.C:Applicative_closure:
         const GHC.Base.C:Applicative_info;
 },
 GHC.Base.C:Applicative_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cllT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cllX; else goto cllW;
       cllX: // global
           HpAlloc = 56;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Applicative_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cllW: // global
           I64[Hp - 48] = GHC.Base.C:Applicative_con_info;
           P64[Hp - 40] = R2;
           P64[Hp - 32] = R3;
           P64[Hp - 24] = R4;
           P64[Hp - 16] = R5;
           P64[Hp - 8] = R6;
           P64[Hp] = P64[Sp];
           R1 = Hp - 47;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Applicative_info" {
     GHC.Base.C:Applicative_info:
         const GHC.Base.C:Applicative_entry;
         const 0;
         const 14;
         const 25769803802;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.158233823 UTC

[section ""data" . GHC.Base.C:Semigroup_closure" {
     GHC.Base.C:Semigroup_closure:
         const GHC.Base.C:Semigroup_info;
 },
 GHC.Base.C:Semigroup_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       clma: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto clme; else goto clmd;
       clme: // global
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Semigroup_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       clmd: // global
           I64[Hp - 24] = GHC.Base.C:Semigroup_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Semigroup_info" {
     GHC.Base.C:Semigroup_info:
         const GHC.Base.C:Semigroup_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.162003979 UTC

[section ""data" . GHC.Base.C:Monoid_closure" {
     GHC.Base.C:Monoid_closure:
         const GHC.Base.C:Monoid_info;
 },
 GHC.Base.C:Monoid_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       clmq: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto clmu; else goto clmt;
       clmu: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Monoid_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       clmt: // global
           I64[Hp - 32] = GHC.Base.C:Monoid_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Monoid_info" {
     GHC.Base.C:Monoid_info:
         const GHC.Base.C:Monoid_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.165200889 UTC

[section ""data" . GHC.Base.Nothing_closure" {
     GHC.Base.Nothing_closure:
         const GHC.Base.Nothing_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.167303694 UTC

[section ""data" . GHC.Base.Just_closure" {
     GHC.Base.Just_closure:
         const GHC.Base.Just_info;
 },
 GHC.Base.Just_entry() //  [R2]
         { []
         }
     {offset
       clmH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto clmL; else goto clmK;
       clmL: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Base.Just_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       clmK: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R2;
           R1 = Hp - 6;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.Just_info" {
     GHC.Base.Just_info:
         const GHC.Base.Just_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.170941937 UTC

[section ""data" . GHC.Base.O_closure" {
     GHC.Base.O_closure:
         const GHC.Base.O_info;
 },
 GHC.Base.O_entry() //  [R2]
         { []
         }
     {offset
       clmX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cln1; else goto cln0;
       cln1: // global
           HpAlloc = 16;
           R2 = R2;
           R1 = GHC.Base.O_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cln0: // global
           I64[Hp - 8] = GHC.Base.O_con_info;
           P64[Hp] = R2;
           R1 = Hp - 7;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.O_info" {
     GHC.Base.O_info:
         const GHC.Base.O_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.174858156 UTC

[section ""data" . GHC.Base.:|_closure" {
     GHC.Base.:|_closure:
         const GHC.Base.:|_info;
 },
 GHC.Base.:|_entry() //  [R2, R3]
         { []
         }
     {offset
       clnd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto clnh; else goto clng;
       clnh: // global
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.:|_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       clng: // global
           I64[Hp - 16] = GHC.Base.:|_con_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 15;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.:|_info" {
     GHC.Base.:|_info:
         const GHC.Base.:|_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.179371364 UTC

[section ""data" . GHC.Base.C:MonadPlus_closure" {
     GHC.Base.C:MonadPlus_closure:
         const GHC.Base.C:MonadPlus_info;
 },
 GHC.Base.C:MonadPlus_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       clnt: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto clnx; else goto clnw;
       clnx: // global
           HpAlloc = 40;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:MonadPlus_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       clnw: // global
           I64[Hp - 32] = GHC.Base.C:MonadPlus_con_info;
           P64[Hp - 24] = R2;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R1 = Hp - 31;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:MonadPlus_info" {
     GHC.Base.C:MonadPlus_info:
         const GHC.Base.C:MonadPlus_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.183909776 UTC

[section ""data" . GHC.Base.C:Alternative_closure" {
     GHC.Base.C:Alternative_closure:
         const GHC.Base.C:Alternative_info;
 },
 GHC.Base.C:Alternative_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       clnJ: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto clnN; else goto clnM;
       clnN: // global
           HpAlloc = 48;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.Base.C:Alternative_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       clnM: // global
           I64[Hp - 40] = GHC.Base.C:Alternative_con_info;
           P64[Hp - 32] = R2;
           P64[Hp - 24] = R3;
           P64[Hp - 16] = R4;
           P64[Hp - 8] = R5;
           P64[Hp] = R6;
           R1 = Hp - 39;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Alternative_info" {
     GHC.Base.C:Alternative_info:
         const GHC.Base.C:Alternative_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.187687478 UTC

[section ""cstring" . ilnV_str" {
     ilnV_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,77,111,110,97,100]
 },
 GHC.Base.C:Monad_con_entry() //  [R1]
         { []
         }
     {offset
       clnU: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Monad_con_info" {
     GHC.Base.C:Monad_con_info:
         const GHC.Base.C:Monad_con_entry;
         const 5;
         const 1;
         const ilnV_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.191152296 UTC

[section ""cstring" . ilo2_str" {
     ilo2_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,70,117,110,99,116,111,114]
 },
 GHC.Base.C:Functor_con_entry() //  [R1]
         { []
         }
     {offset
       clo1: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Functor_con_info" {
     GHC.Base.C:Functor_con_info:
         const GHC.Base.C:Functor_con_entry;
         const 2;
         const 4;
         const ilo2_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.194250474 UTC

[section ""cstring" . ilo9_str" {
     ilo9_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,65,112,112,108,105,99,97,116,105,118,101]
 },
 GHC.Base.C:Applicative_con_entry() //  [R1]
         { []
         }
     {offset
       clo8: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Applicative_con_info" {
     GHC.Base.C:Applicative_con_info:
         const GHC.Base.C:Applicative_con_entry;
         const 6;
         const 1;
         const ilo9_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.197414651 UTC

[section ""cstring" . ilog_str" {
     ilog_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,83,101,109,105,103,114,111,117,112]
 },
 GHC.Base.C:Semigroup_con_entry() //  [R1]
         { []
         }
     {offset
       clof: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Semigroup_con_info" {
     GHC.Base.C:Semigroup_con_info:
         const GHC.Base.C:Semigroup_con_entry;
         const 3;
         const 1;
         const ilog_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.200362648 UTC

[section ""cstring" . ilon_str" {
     ilon_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,77,111,110,111,105,100]
 },
 GHC.Base.C:Monoid_con_entry() //  [R1]
         { []
         }
     {offset
       clom: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Monoid_con_info" {
     GHC.Base.C:Monoid_con_info:
         const GHC.Base.C:Monoid_con_entry;
         const 4;
         const 1;
         const ilon_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.203475218 UTC

[section ""cstring" . ilou_str" {
     ilou_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,78,111,116,104,105,110,103]
 },
 GHC.Base.Nothing_con_entry() //  [R1]
         { []
         }
     {offset
       clot: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.Nothing_con_info" {
     GHC.Base.Nothing_con_info:
         const GHC.Base.Nothing_con_entry;
         const 4294967296;
         const 3;
         const ilou_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.207141572 UTC

[section ""cstring" . iloB_str" {
     iloB_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,74,117,115,116]
 },
 GHC.Base.Just_con_entry() //  [R1]
         { []
         }
     {offset
       cloA: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.Just_con_info" {
     GHC.Base.Just_con_info:
         const GHC.Base.Just_con_entry;
         const 1;
         const 4294967298;
         const iloB_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.210792513 UTC

[section ""cstring" . iloI_str" {
     iloI_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,79]
 },
 GHC.Base.O_con_entry() //  [R1]
         { []
         }
     {offset
       cloH: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.O_con_info" {
     GHC.Base.O_con_info:
         const GHC.Base.O_con_entry;
         const 1;
         const 2;
         const iloI_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.213908065 UTC

[section ""cstring" . iloP_str" {
     iloP_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,58,124]
 },
 GHC.Base.:|_con_entry() //  [R1]
         { []
         }
     {offset
       cloO: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.:|_con_info" {
     GHC.Base.:|_con_info:
         const GHC.Base.:|_con_entry;
         const 2;
         const 4;
         const iloP_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.216906388 UTC

[section ""cstring" . iloW_str" {
     iloW_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,77,111,110,97,100,80,108,117,115]
 },
 GHC.Base.C:MonadPlus_con_entry() //  [R1]
         { []
         }
     {offset
       cloV: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:MonadPlus_con_info" {
     GHC.Base.C:MonadPlus_con_info:
         const GHC.Base.C:MonadPlus_con_entry;
         const 4;
         const 1;
         const iloW_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.220079752 UTC

[section ""cstring" . ilp3_str" {
     ilp3_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,97,115,101,46,67,58,65,108,116,101,114,110,97,116,105,118,101]
 },
 GHC.Base.C:Alternative_con_entry() //  [R1]
         { []
         }
     {offset
       clp2: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Base.C:Alternative_con_info" {
     GHC.Base.C:Alternative_con_info:
         const GHC.Base.C:Alternative_con_entry;
         const 5;
         const 1;
         const ilp3_str;
 }]


==================== Raw Cmm ====================
2018-03-16 15:54:59.22349223 UTC

[section ""relreadonly" . Si3a_srt" {
     Si3a_srt:
         const GHC.Base.$fSemigroupIO_$cstimes_closure;
         const GHC.Base.$fSemigroupIO_closure;
         const Data.Semigroup.Internal.stimesDefault_closure;
         const GHC.Base.$fMonoidIO_$cp1Monoid_closure;
         const GHC.IO.mplusIO_closure;
         const GHC.Base.$fAlternativeIO2_closure;
         const GHC.Base.$fAlternativeIO_$cmany_closure;
         const GHC.Base.$fSemigroupNonEmpty_closure;
         const GHC.Base.$fMonoidIO_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.IO.failIO_closure;
         const Data.Semigroup.Internal.stimesMaybe_closure;
         const GHC.Base.$fSemigroupMaybe_closure;
         const GHC.Base.$fMonoidMaybe_closure;
         const Data.Semigroup.Internal.stimesIdempotentMonoid_closure;
         const GHC.Base.$fMonoidOrdering_closure;
         const Data.Semigroup.Internal.stimesList_closure;
         const GHC.Base.$fAlternativeIO3_closure;
         const GHC.Base.$fMonad(,)_closure;
         const lvl2_r7PL_closure;
 }]

