
==================== Pre unarise: ====================
2018-03-16 15:55:06.165382453 UTC

$wunsafeDrop_ru8P :: forall a. GHC.Prim.Int# -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    sat-only [] \r [ww_su9t w_su9u]
        case w_su9u of {
          [] -> [] [];
          : _ [Occ=Dead] ipv1_su9x [Occ=Once*] ->
              case ww_su9t of ds_su9y {
                __DEFAULT ->
                    case -# [ds_su9y 1#] of sat_su9z {
                      __DEFAULT -> $wunsafeDrop_ru8P sat_su9z ipv1_su9x;
                    };
                1# -> ipv1_su9x;
              };
        };

GHC.List.drop [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Types.Int -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_su9A eta1_su9B]
        case eta_su9A of {
          GHC.Types.I# x_su9D ->
              case <=# [x_su9D 0#] of {
                __DEFAULT -> $wunsafeDrop_ru8P x_su9D eta1_su9B;
                1# -> eta1_su9B;
              };
        };

GHC.List.$wsplitAt' [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. GHC.Types.Int -> [a] -> (# [a], [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_su9F w1_su9G]
        case w1_su9G of {
          [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
          : ipv_su9I [Occ=Once*] ipv1_su9J [Occ=Once*] ->
              case w_su9F of {
                GHC.Types.I# ds_su9L [Occ=Once!] ->
                    case ds_su9L of ds1_su9M {
                      __DEFAULT ->
                          let {
                            ds2_su9N [Dmd=<L,U(1*U,1*U)>] :: ([a_stMO], [a_stMO])
                            [LclId] =
                                [ipv1_su9J ds1_su9M] \u []
                                    case -# [ds1_su9M 1#] of sat_su9O {
                                      __DEFAULT ->
                                          let {
                                            sat_su9P [Occ=Once] :: GHC.Types.Int
                                            [LclId] =
                                                CCCS GHC.Types.I#! [sat_su9O];
                                          } in 
                                            case GHC.List.$wsplitAt' sat_su9P ipv1_su9J of {
                                              (#,#) ww1_su9R [Occ=Once] ww2_su9S [Occ=Once] ->
                                                  (,) [ww1_su9R ww2_su9S];
                                            };
                                    }; } in
                          let {
                            sat_sua1 [Occ=Once] :: [a_stMO]
                            [LclId] =
                                [ds2_su9N] \u []
                                    case ds2_su9N of {
                                      (,) _ [Occ=Dead] xs''_sua0 [Occ=Once] -> xs''_sua0;
                                    }; } in
                          let {
                            sat_su9W [Occ=Once] :: [a_stMO]
                            [LclId] =
                                [ds2_su9N] \u []
                                    case ds2_su9N of {
                                      (,) xs'_su9U [Occ=Once] _ [Occ=Dead] -> xs'_su9U;
                                    }; } in
                          let {
                            sat_su9X [Occ=Once] :: [a_stMO]
                            [LclId] =
                                CCCS :! [ipv_su9I sat_su9W];
                          } in  (#,#) [sat_su9X sat_sua1];
                      1# ->
                          let {
                            sat_sua2 [Occ=Once] :: [a_stMO]
                            [LclId] =
                                CCCS :! [ipv_su9I GHC.Types.[]];
                          } in  (#,#) [sat_sua2 ipv1_su9J];
                    };
              };
        };

GHC.List.splitAt_splitAt' [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Types.Int -> [a] -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U)><S,1*U>m,
 Unf=OtherCon []] =
    [] \r [w_sua3 w1_sua4]
        case GHC.List.$wsplitAt' w_sua3 w1_sua4 of {
          (#,#) ww1_sua6 [Occ=Once] ww2_sua7 [Occ=Once] ->
              (,) [ww1_sua6 ww2_sua7];
        };

GHC.List.splitAt :: forall a. GHC.Types.Int -> [a] -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U>m,
 Unf=OtherCon []] =
    [] \r [n_sua8 ls_sua9]
        case n_sua8 of wild_suaa {
          GHC.Types.I# x_suab [Occ=Once] ->
              case <=# [x_suab 0#] of {
                __DEFAULT ->
                    case GHC.List.$wsplitAt' wild_suaa ls_sua9 of {
                      (#,#) ww1_suae [Occ=Once] ww2_suaf [Occ=Once] ->
                          (,) [ww1_suae ww2_suaf];
                    };
                1# -> (,) [GHC.Types.[] ls_sua9];
              };
        };

GHC.List.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.List.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.List.$trModule4];

GHC.List.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.List"#;

GHC.List.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.List.$trModule2];

GHC.List.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.List.$trModule3
                                     GHC.List.$trModule1];

GHC.List.init1 [Occ=LoopBreaker] :: forall a. a -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_suag ds1_suah]
        case ds1_suah of {
          [] -> [] [];
          : z_suaj [Occ=Once] zs_suak [Occ=Once] ->
              let {
                sat_sual [Occ=Once] :: [a_aszc]
                [LclId] =
                    [z_suaj zs_suak] \u [] GHC.List.init1 z_suaj zs_suak;
              } in  : [ds_suag sat_sual];
        };

lvl_ru8Q :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ": empty list"#;

lvl1_ru8R :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl_ru8Q;

GHC.List.!!4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Prelude."#;

GHC.List.prel_list_str :: GHC.Base.String
[GblId] =
    [] \u [] GHC.CString.unpackCString# GHC.List.!!4;

GHC.List.errorEmptyList :: forall a. GHC.Base.String -> a
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []] =
    [] \r [fun_suam]
        let {
          sat_suan [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [fun_suam] \s [] GHC.Base.++ fun_suam lvl1_ru8R;
        } in 
          case GHC.Base.++ GHC.List.prel_list_str sat_suan of sat_suao {
            __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_suao;
          };

lvl2_ru8S :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "!!: negative index"#;

lvl3_ru8T :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl2_ru8S;

GHC.List.negIndex :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.Base.++ GHC.List.prel_list_str lvl3_ru8T of sat_suap {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_suap;
        };

GHC.List.!!3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "!!: index too large"#;

GHC.List.!!2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# GHC.List.!!3;

GHC.List.!!1 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.Base.++ GHC.List.prel_list_str GHC.List.!!2;

GHC.List.tooLarge :: forall a. GHC.Types.Int -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [ds_suaq] GHC.Err.errorWithoutStackTrace GHC.List.!!1;

poly_exit_ru8U :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace GHC.List.!!1;

poly_$wgo_ru8V :: forall a. [a] -> GHC.Prim.Int# -> a
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [w_suar ww_suas]
        case w_suar of {
          [] -> poly_exit_ru8U;
          : y_suau [Occ=Once] ys_suav [Occ=Once] ->
              case ww_suas of ds_suaw {
                __DEFAULT ->
                    case -# [ds_suaw 1#] of sat_suax {
                      __DEFAULT -> poly_$wgo_ru8V ys_suav sat_suax;
                    };
                0# -> y_suau;
              };
        };

GHC.List.$w!! [InlPrag=INLINABLE[0]]
  :: forall a. [a] -> GHC.Prim.Int# -> a
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [w_suay ww_suaz]
        case <# [ww_suaz 0#] of {
          __DEFAULT -> poly_$wgo_ru8V w_suay ww_suaz;
          1# -> GHC.List.negIndex;
        };

GHC.List.!! [InlPrag=NOUSERINLINE[0]]
  :: forall a. [a] -> GHC.Types.Int -> a
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [w_suaB w1_suaC]
        case w1_suaC of {
          GHC.Types.I# ww1_suaE [Occ=Once] -> GHC.List.$w!! w_suaB ww1_suaE;
        };

lvl4_ru8W :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "cycle"#;

lvl5_ru8X :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl4_ru8W;

GHC.List.cycle1 :: forall a. [a]
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl5_ru8X;

GHC.List.cycle :: forall a. [a] -> [a]
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_suaF]
        case ds_suaF of wild_suaG {
          [] -> GHC.List.cycle1;
          : _ [Occ=Dead] _ [Occ=Dead] ->
              let {
                xs'_suaJ [Occ=LoopBreaker] :: [a_ass8]
                [LclId] =
                    [wild_suaG xs'_suaJ] \u [] GHC.Base.++ wild_suaG xs'_suaJ;
              } in  xs'_suaJ;
        };

lvl6_ru8Y :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1"#;

lvl7_ru8Z :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl6_ru8Y;

lvl8_ru90 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl7_ru8Z;

GHC.List.foldr1 [InlPrag=INLINE[0] (sat-args=1)]
  :: forall a. (a -> a -> a) -> [a] -> a
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []] =
    [] \r [f_suaK eta_suaL]
        let {
          go2_suaM [Occ=LoopBreaker] :: [a_asug] -> a_asug
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [f_suaK go2_suaM] \r [ds_suaN]
                  case ds_suaN of {
                    [] -> lvl8_ru90;
                    : x_suaP [Occ=Once*] ds1_suaQ [Occ=Once!] ->
                        case ds1_suaQ of wild1_suaR {
                          [] -> x_suaP;
                          : _ [Occ=Dead] _ [Occ=Dead] ->
                              let {
                                sat_suaU [Occ=Once] :: a_asug
                                [LclId] =
                                    [go2_suaM wild1_suaR] \u [] go2_suaM wild1_suaR;
                              } in  f_suaK x_suaP sat_suaU;
                        };
                  };
        } in  go2_suaM eta_suaL;

lvl9_ru91 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "init"#;

lvl10_ru92 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl9_ru91;

GHC.List.init2 :: forall a. [a]
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl10_ru92;

GHC.List.init :: forall a. [a] -> [a]
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_suaV]
        case ds_suaV of {
          [] -> GHC.List.init2;
          : x_suaX [Occ=Once] xs_suaY [Occ=Once] ->
              GHC.List.init1 x_suaX xs_suaY;
        };

lvl11_ru93 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "last"#;

lvl12_ru94 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl11_ru93;

GHC.List.lastError :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl12_ru94;

poly_go_ru95 :: forall a. [a] -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    sat-only [] \r [ds_suaZ eta_sub0]
        case ds_suaZ of {
          [] -> eta_sub0;
          : y_sub2 [Occ=Once] ys_sub3 [Occ=Once] ->
              poly_go_ru95 ys_sub3 y_sub2;
        };

GHC.List.last [InlPrag=INLINE (sat-args=1)] :: forall a. [a] -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [xs_sub4] poly_go_ru95 xs_sub4 GHC.List.lastError;

lvl13_ru96 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "tail"#;

lvl14_ru97 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl13_ru96;

GHC.List.scanl2 :: forall a. [a]
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl14_ru97;

GHC.List.tail :: forall a. [a] -> [a]
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sub5]
        case ds_sub5 of {
          [] -> GHC.List.scanl2;
          : _ [Occ=Dead] xs_sub8 [Occ=Once] -> xs_sub8;
        };

lvl15_ru98 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "head"#;

lvl16_ru99 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl15_ru98;

GHC.List.badHead :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl16_ru99;

GHC.List.head [InlPrag=NOINLINE[1], Occ=LoopBreaker!]
  :: forall a. [a] -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sub9]
        case ds_sub9 of {
          [] -> GHC.List.badHead;
          : x_subb [Occ=Once] _ [Occ=Dead] -> x_subb;
        };

lvl17_ru9a :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum"#;

lvl18_ru9b :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl17_ru9a;

GHC.List.maximum1 :: GHC.Integer.Type.Integer
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl18_ru9b;

GHC.List.maximum2 :: GHC.Types.Int
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl18_ru9b;

lvl19_ru9c :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl18_ru9b;

GHC.List.maximum_go [Occ=LoopBreaker]
  :: [GHC.Integer.Type.Integer]
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [ds_subd eta_sube]
        case ds_subd of {
          [] -> eta_sube;
          : y_subg ys_subh [Occ=Once*] ->
              case GHC.Integer.Type.leInteger# eta_sube y_subg of {
                __DEFAULT -> GHC.List.maximum_go ys_subh eta_sube;
                1# -> GHC.List.maximum_go ys_subh y_subg;
              };
        };

GHC.List.maximum_$smaximum [InlPrag=INLINABLE]
  :: [GHC.Integer.Type.Integer] -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_subj]
        case ds_subj of {
          [] -> GHC.List.maximum1;
          : ipv_subl [Occ=Once] ipv1_subm [Occ=Once] ->
              GHC.List.maximum_go ipv1_subm ipv_subl;
        };

lvl20_ru9d :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum"#;

lvl21_ru9e :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl20_ru9d;

GHC.List.minimum1 :: GHC.Integer.Type.Integer
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl21_ru9e;

GHC.List.minimum2 :: GHC.Types.Int
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl21_ru9e;

lvl22_ru9f :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl21_ru9e;

GHC.List.minimum_go [Occ=LoopBreaker]
  :: [GHC.Integer.Type.Integer]
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [ds_subn eta_subo]
        case ds_subn of {
          [] -> eta_subo;
          : y_subq ys_subr [Occ=Once*] ->
              case GHC.Integer.Type.leInteger# eta_subo y_subq of {
                __DEFAULT -> GHC.List.minimum_go ys_subr y_subq;
                1# -> GHC.List.minimum_go ys_subr eta_subo;
              };
        };

GHC.List.minimum_$sminimum [InlPrag=INLINABLE]
  :: [GHC.Integer.Type.Integer] -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_subt]
        case ds_subt of {
          [] -> GHC.List.minimum1;
          : ipv_subv [Occ=Once] ipv1_subw [Occ=Once] ->
              GHC.List.minimum_go ipv1_subw ipv_subv;
        };

GHC.List.$wgo [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: [GHC.Types.Int] -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_subx ww_suby]
        case w_subx of {
          [] -> ww_suby;
          : y_subA [Occ=Once!] ys_subB [Occ=Once*] ->
              case y_subA of {
                GHC.Types.I# y1_subD ->
                    case <=# [ww_suby y1_subD] of {
                      __DEFAULT -> GHC.List.$wgo ys_subB ww_suby;
                      1# -> GHC.List.$wgo ys_subB y1_subD;
                    };
              };
        };

GHC.List.maximum_$smaximum1 [InlPrag=NOUSERINLINE[0]]
  :: [GHC.Types.Int] -> GHC.Types.Int
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [w_subF]
        case w_subF of {
          [] -> GHC.List.maximum2;
          : ipv_subH [Occ=Once!] ipv1_subI [Occ=Once] ->
              case ipv_subH of {
                GHC.Types.I# ww1_subK [Occ=Once] ->
                    case GHC.List.$wgo ipv1_subI ww1_subK of ww2_subL {
                      __DEFAULT -> GHC.Types.I# [ww2_subL];
                    };
              };
        };

GHC.List.maximum [InlPrag=INLINABLE]
  :: forall a. GHC.Classes.Ord a => [a] -> a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,A,A,A,C(C1(U)),A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_subM ds_subN]
        case ds_subN of {
          [] -> lvl19_ru9c;
          : ipv_subP [Occ=Once] ipv1_subQ [Occ=Once] ->
              let-no-escape {
                go2_subR [Occ=LoopBreakerT[2]] :: [a_asxy] -> a_asxy -> a_asxy
                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
                    sat-only [$dOrd_subM go2_subR] \r [ds1_subS eta_subT]
                        case ds1_subS of {
                          [] -> eta_subT;
                          : y_subV [Occ=Once] ys_subW [Occ=Once] ->
                              let {
                                sat_subX [Occ=Once] :: a_asxy
                                [LclId] =
                                    [$dOrd_subM eta_subT y_subV] \u []
                                        GHC.Classes.max $dOrd_subM eta_subT y_subV;
                              } in  go2_subR ys_subW sat_subX;
                        };
              } in  go2_subR ipv1_subQ ipv_subP;
        };

GHC.List.$wgo1 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: [GHC.Types.Int] -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_subY ww_subZ]
        case w_subY of {
          [] -> ww_subZ;
          : y_suc1 [Occ=Once!] ys_suc2 [Occ=Once*] ->
              case y_suc1 of {
                GHC.Types.I# y1_suc4 ->
                    case <=# [ww_subZ y1_suc4] of {
                      __DEFAULT -> GHC.List.$wgo1 ys_suc2 y1_suc4;
                      1# -> GHC.List.$wgo1 ys_suc2 ww_subZ;
                    };
              };
        };

GHC.List.minimum_$sminimum1 [InlPrag=NOUSERINLINE[0]]
  :: [GHC.Types.Int] -> GHC.Types.Int
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [w_suc6]
        case w_suc6 of {
          [] -> GHC.List.minimum2;
          : ipv_suc8 [Occ=Once!] ipv1_suc9 [Occ=Once] ->
              case ipv_suc8 of {
                GHC.Types.I# ww1_sucb [Occ=Once] ->
                    case GHC.List.$wgo1 ipv1_suc9 ww1_sucb of ww2_succ {
                      __DEFAULT -> GHC.Types.I# [ww2_succ];
                    };
              };
        };

GHC.List.minimum [InlPrag=INLINABLE]
  :: forall a. GHC.Classes.Ord a => [a] -> a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,A,A,A,A,C(C1(U)))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sucd ds_suce]
        case ds_suce of {
          [] -> lvl22_ru9f;
          : ipv_sucg [Occ=Once] ipv1_such [Occ=Once] ->
              let-no-escape {
                go2_suci [Occ=LoopBreakerT[2]] :: [a_asxY] -> a_asxY -> a_asxY
                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
                    sat-only [$dOrd_sucd go2_suci] \r [ds1_sucj eta_suck]
                        case ds1_sucj of {
                          [] -> eta_suck;
                          : y_sucm [Occ=Once] ys_sucn [Occ=Once] ->
                              let {
                                sat_suco [Occ=Once] :: a_asxY
                                [LclId] =
                                    [$dOrd_sucd eta_suck y_sucm] \u []
                                        GHC.Classes.min $dOrd_sucd eta_suck y_sucm;
                              } in  go2_suci ys_sucn sat_suco;
                        };
              } in  go2_suci ipv1_such ipv_sucg;
        };

lvl23_ru9g :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1'"#;

lvl24_ru9h :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl23_ru9g;

GHC.List.foldl1'1 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl24_ru9h;

lvl25_ru9i :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1"#;

lvl26_ru9j :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl25_ru9i;

GHC.List.foldl2 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl26_ru9j;

$wgo2_ru9k :: forall a b c. [(a, b, c)] -> (# [a], [b], [c] #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [w_sucp]
        case w_sucp of {
          [] -> (#,,#) [GHC.Types.[] GHC.Types.[] GHC.Types.[]];
          : y_sucr [Occ=Once!] ys_sucs [Occ=Once] ->
              case y_sucr of {
                (,,) a1_sucu [Occ=Once] b1_sucv [Occ=Once] c1_sucw [Occ=Once] ->
                    let {
                      ds_sucx [Dmd=<L,U(1*U,1*U,1*U)>] :: ([a_stLF], [b_stLG], [c_stLH])
                      [LclId] =
                          [ys_sucs] \u []
                              case $wgo2_ru9k ys_sucs of {
                                (#,,#) ww1_sucz [Occ=Once]
                                       ww2_sucA [Occ=Once]
                                       ww3_sucB [Occ=Once] ->
                                    (,,) [ww1_sucz ww2_sucA ww3_sucB];
                              }; } in
                    let {
                      sat_sucS [Occ=Once] :: [c_stLH]
                      [LclId] =
                          [ds_sucx] \u []
                              case ds_sucx of {
                                (,,) _ [Occ=Dead] _ [Occ=Dead] cs_sucR [Occ=Once] -> cs_sucR;
                              }; } in
                    let {
                      sat_sucT [Occ=Once] :: [c_stLH]
                      [LclId] =
                          CCCS :! [c1_sucw sat_sucS]; } in
                    let {
                      sat_sucM [Occ=Once] :: [b_stLG]
                      [LclId] =
                          [ds_sucx] \u []
                              case ds_sucx of {
                                (,,) _ [Occ=Dead] bs_sucK [Occ=Once] _ [Occ=Dead] -> bs_sucK;
                              }; } in
                    let {
                      sat_sucN [Occ=Once] :: [b_stLG]
                      [LclId] =
                          CCCS :! [b1_sucv sat_sucM]; } in
                    let {
                      sat_sucG [Occ=Once] :: [a_stLF]
                      [LclId] =
                          [ds_sucx] \u []
                              case ds_sucx of {
                                (,,) as_sucD [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> as_sucD;
                              }; } in
                    let {
                      sat_sucH [Occ=Once] :: [a_stLF]
                      [LclId] =
                          CCCS :! [a1_sucu sat_sucG];
                    } in  (#,,#) [sat_sucH sat_sucN sat_sucT];
              };
        };

go_ru9l :: forall a b c. [(a, b, c)] -> ([a], [b], [c])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    sat-only [] \r [w_sucU]
        case $wgo2_ru9k w_sucU of {
          (#,,#) ww1_sucW [Occ=Once]
                 ww2_sucX [Occ=Once]
                 ww3_sucY [Occ=Once] ->
              (,,) [ww1_sucW ww2_sucX ww3_sucY];
        };

GHC.List.unzip3 [InlPrag=INLINE (sat-args=0)]
  :: forall a b c. [(a, b, c)] -> ([a], [b], [c])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [eta_B1] go_ru9l eta_B1;

$wgo3_ru9m :: forall a b. [(a, b)] -> (# [a], [b] #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [w_sucZ]
        case w_sucZ of {
          [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
          : y_sud1 [Occ=Once!] ys_sud2 [Occ=Once] ->
              case y_sud1 of {
                (,) a1_sud4 [Occ=Once] b1_sud5 [Occ=Once] ->
                    let {
                      ds_sud6 [Dmd=<L,U(1*U,1*U)>] :: ([a_stLy], [b_stLz])
                      [LclId] =
                          [ys_sud2] \u []
                              case $wgo3_ru9m ys_sud2 of {
                                (#,#) ww1_sud8 [Occ=Once] ww2_sud9 [Occ=Once] ->
                                    (,) [ww1_sud8 ww2_sud9];
                              }; } in
                    let {
                      sat_sudi [Occ=Once] :: [b_stLz]
                      [LclId] =
                          [ds_sud6] \u []
                              case ds_sud6 of {
                                (,) _ [Occ=Dead] bs_sudh [Occ=Once] -> bs_sudh;
                              }; } in
                    let {
                      sat_sudj [Occ=Once] :: [b_stLz]
                      [LclId] =
                          CCCS :! [b1_sud5 sat_sudi]; } in
                    let {
                      sat_sudd [Occ=Once] :: [a_stLy]
                      [LclId] =
                          [ds_sud6] \u []
                              case ds_sud6 of {
                                (,) as_sudb [Occ=Once] _ [Occ=Dead] -> as_sudb;
                              }; } in
                    let {
                      sat_sude [Occ=Once] :: [a_stLy]
                      [LclId] =
                          CCCS :! [a1_sud4 sat_sudd];
                    } in  (#,#) [sat_sude sat_sudj];
              };
        };

go1_ru9n :: forall a b. [(a, b)] -> ([a], [b])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    sat-only [] \r [w_sudk]
        case $wgo3_ru9m w_sudk of {
          (#,#) ww1_sudm [Occ=Once] ww2_sudn [Occ=Once] ->
              (,) [ww1_sudm ww2_sudn];
        };

GHC.List.unzip [InlPrag=INLINE (sat-args=0)]
  :: forall a b. [(a, b)] -> ([a], [b])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [eta_B1] go1_ru9n eta_B1;

GHC.List.zipWith3
  :: forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><S,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [z_sudo eta_sudp eta1_sudq eta2_sudr]
        let {
          go2_suds [Occ=LoopBreaker]
            :: [a_asln] -> [b_aslo] -> [c_aslp] -> [d_aslq]
          [LclId, Arity=3, Str=<S,1*U><L,1*U><L,1*U>, Unf=OtherCon []] =
              sat-only [z_sudo go2_suds] \r [ds_sudt ds1_sudu ds2_sudv]
                  case ds_sudt of {
                    [] -> [] [];
                    : a1_sudx [Occ=Once] as_sudy [Occ=Once] ->
                        case ds1_sudu of {
                          [] -> [] [];
                          : b1_sudA [Occ=Once] bs_sudB [Occ=Once] ->
                              case ds2_sudv of {
                                [] -> [] [];
                                : c1_sudD [Occ=Once] cs_sudE [Occ=Once] ->
                                    let {
                                      sat_sudG [Occ=Once] :: [d_aslq]
                                      [LclId] =
                                          [go2_suds as_sudy bs_sudB cs_sudE] \u []
                                              go2_suds as_sudy bs_sudB cs_sudE; } in
                                    let {
                                      sat_sudF [Occ=Once] :: d_aslq
                                      [LclId] =
                                          [z_sudo a1_sudx b1_sudA c1_sudD] \u []
                                              z_sudo a1_sudx b1_sudA c1_sudD;
                                    } in  : [sat_sudF sat_sudG];
                              };
                        };
                  };
        } in  go2_suds eta_sudp eta1_sudq eta2_sudr;

GHC.List.zipWithFB [InlPrag=INLINE[0] (sat-args=2)]
  :: forall a b c d e.
     (a -> b -> c) -> (d -> e -> a) -> d -> e -> b -> c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [c1_sudH f_sudI x_sudJ y_sudK r_sudL]
        let {
          sat_sudM [Occ=Once] :: a_aslZ
          [LclId] =
              [f_sudI x_sudJ y_sudK] \u [] f_sudI x_sudJ y_sudK;
        } in  c1_sudH sat_sudM r_sudL;

GHC.List.zip3 [Occ=LoopBreaker]
  :: forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sudN ds1_sudO ds2_sudP]
        case ds_sudN of {
          [] -> [] [];
          : a1_sudR [Occ=Once] as_sudS [Occ=Once] ->
              case ds1_sudO of {
                [] -> [] [];
                : b1_sudU [Occ=Once] bs_sudV [Occ=Once] ->
                    case ds2_sudP of {
                      [] -> [] [];
                      : c1_sudX [Occ=Once] cs_sudY [Occ=Once] ->
                          let {
                            sat_sue0 [Occ=Once] :: [(a_asmz, b_asmA, c_asmB)]
                            [LclId] =
                                [as_sudS bs_sudV cs_sudY] \u []
                                    GHC.List.zip3 as_sudS bs_sudV cs_sudY; } in
                          let {
                            sat_sudZ [Occ=Once] :: (a_asmz, b_asmA, c_asmB)
                            [LclId] =
                                CCCS (,,)! [a1_sudR b1_sudU c1_sudX];
                          } in  : [sat_sudZ sat_sue0];
                    };
              };
        };

GHC.List.zipFB [InlPrag=INLINE[0] (sat-args=1)]
  :: forall a b c d. ((a, b) -> c -> d) -> a -> b -> c -> d
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [c1_sue1 x_sue2 y_sue3 r_sue4]
        let {
          sat_sue5 [Occ=Once] :: (a_asmK, b_asmL)
          [LclId] =
              CCCS (,)! [x_sue2 y_sue3];
        } in  c1_sue1 sat_sue5 r_sue4;

GHC.List.foldr2_left
  :: forall a b c d.
     (a -> b -> c -> d) -> d -> a -> ([b] -> c) -> [b] -> d
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><L,1*U><L,U><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [_k_sue6 z_sue7 _x_sue8 _r_sue9 ds_suea]
        case ds_suea of {
          [] -> z_sue7;
          : y_suec [Occ=Once] ys_sued [Occ=Once] ->
              let {
                sat_suee [Occ=Once] :: c_asmZ
                [LclId] =
                    [_r_sue9 ys_sued] \u [] _r_sue9 ys_sued;
              } in  _k_sue6 _x_sue8 y_suec sat_suee;
        };

GHC.List.zip [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a b. [a] -> [b] -> [(a, b)]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_suef _bs_sueg]
        case ds_suef of {
          [] -> [] [];
          : ipv_suei [Occ=Once] ipv1_suej [Occ=Once] ->
              case _bs_sueg of {
                [] -> [] [];
                : ipv2_suel [Occ=Once] ipv3_suem [Occ=Once] ->
                    let {
                      sat_sueo [Occ=Once] :: [(a_asmP, b_asmQ)]
                      [LclId] =
                          [ipv1_suej ipv3_suem] \u [] GHC.List.zip ipv1_suej ipv3_suem; } in
                    let {
                      sat_suen [Occ=Once] :: (a_asmP, b_asmQ)
                      [LclId] =
                          CCCS (,)! [ipv_suei ipv2_suel];
                    } in  : [sat_suen sat_sueo];
              };
        };
GHC.List.zipWith [InlPrag=NOINLINE[1], Occ=LoopBreaker!]
  :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_suep eta_sueq eta1_suer]
        let {
          go2_sues [Occ=LoopBreaker] :: [a_asm5] -> [b_asm6] -> [c_asm7]
          [LclId, Arity=2, Str=<S,1*U><L,1*U>, Unf=OtherCon []] =
              sat-only [f_suep go2_sues] \r [ds_suet ds1_sueu]
                  case ds_suet of {
                    [] -> [] [];
                    : ipv_suew [Occ=Once] ipv1_suex [Occ=Once] ->
                        case ds1_sueu of {
                          [] -> [] [];
                          : ipv2_suez [Occ=Once] ipv3_sueA [Occ=Once] ->
                              let {
                                sat_sueC [Occ=Once] :: [c_asm7]
                                [LclId] =
                                    [go2_sues ipv1_suex ipv3_sueA] \u []
                                        go2_sues ipv1_suex ipv3_sueA; } in
                              let {
                                sat_sueB [Occ=Once] :: c_asm7
                                [LclId] =
                                    [f_suep ipv_suew ipv2_suez] \u [] f_suep ipv_suew ipv2_suez;
                              } in  : [sat_sueB sat_sueC];
                        };
                  };
        } in  go2_sues eta_sueq eta1_suer;
GHC.List.foldr2 [InlPrag=INLINE[0] (sat-args=2), Occ=LoopBreaker!]
  :: forall a b c. (a -> b -> c -> c) -> c -> [a] -> [b] -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,U><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [k_sueD z_sueE eta_sueF eta1_sueG]
        let {
          go2_sueH [Occ=LoopBreaker] :: [a_asn2] -> [b_asn3] -> c_asn4
          [LclId, Arity=2, Str=<S,1*U><L,1*U>, Unf=OtherCon []] =
              sat-only [k_sueD z_sueE go2_sueH] \r [ds_sueI _ys_sueJ]
                  case ds_sueI of {
                    [] -> z_sueE;
                    : ipv_sueL [Occ=Once] ipv1_sueM [Occ=Once] ->
                        case _ys_sueJ of {
                          [] -> z_sueE;
                          : ipv2_sueO [Occ=Once] ipv3_sueP [Occ=Once] ->
                              let {
                                sat_sueQ [Occ=Once] :: c_asn4
                                [LclId] =
                                    [go2_sueH ipv1_sueM ipv3_sueP] \u []
                                        go2_sueH ipv1_sueM ipv3_sueP;
                              } in  k_sueD ipv_sueL ipv2_sueO sat_sueQ;
                        };
                  };
        } in  go2_sueH eta_sueF eta1_sueG;

GHC.List.concat_go [Occ=LoopBreaker] :: forall a. [[a]] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sueR]
        case ds_sueR of {
          [] -> [] [];
          : y_sueT [Occ=Once] ys_sueU [Occ=Once] ->
              let {
                sat_sueV [Occ=Once, Dmd=<L,1*U>] :: [a_asob]
                [LclId] =
                    [ys_sueU] \s [] GHC.List.concat_go ys_sueU;
              } in  GHC.Base.++ y_sueT sat_sueV;
        };

GHC.List.concat [InlPrag=NOINLINE[1]] :: forall a. [[a]] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1] GHC.List.concat_go eta_B1;

GHC.List.concatMap [InlPrag=NOINLINE[1]]
  :: forall a b. (a -> [b]) -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sueW eta_sueX]
        let {
          go2_sueY [Occ=LoopBreaker] :: [a_asog] -> [b_asoh]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [f_sueW go2_sueY] \r [ds_sueZ]
                  case ds_sueZ of {
                    [] -> [] [];
                    : y_suf1 [Occ=Once] ys_suf2 [Occ=Once] ->
                        let {
                          sat_suf4 [Occ=Once, Dmd=<L,1*U>] :: [b_asoh]
                          [LclId] =
                              [go2_sueY ys_suf2] \s [] go2_sueY ys_suf2;
                        } in 
                          case f_sueW y_suf1 of sat_suf3 {
                            __DEFAULT -> GHC.Base.++ sat_suf3 sat_suf4;
                          };
                  };
        } in  go2_sueY eta_sueX;

GHC.List.lookup [Occ=LoopBreaker]
  :: forall a b.
     GHC.Classes.Eq a =>
     a -> [(a, b)] -> GHC.Base.Maybe b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_suf5 _key_suf6 ds_suf7]
        case ds_suf7 of {
          [] -> GHC.Base.Nothing [];
          : ds1_suf9 [Occ=Once!] xys_sufa [Occ=Once] ->
              case ds1_suf9 of {
                (,) x_sufc [Occ=Once] y_sufd [Occ=Once] ->
                    case GHC.Classes.== $dEq_suf5 _key_suf6 x_sufc of {
                      GHC.Types.False -> GHC.List.lookup $dEq_suf5 _key_suf6 xys_sufa;
                      GHC.Types.True -> GHC.Base.Just [y_sufd];
                    };
              };
        };

GHC.List.notElem [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. GHC.Classes.Eq a => a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_suff ds_sufg ds1_sufh]
        case ds1_sufh of {
          [] -> GHC.Types.True [];
          : y_sufj [Occ=Once] ys_sufk [Occ=Once] ->
              case GHC.Classes./= $dEq_suff ds_sufg y_sufj of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> GHC.List.notElem $dEq_suff ds_sufg ys_sufk;
              };
        };

GHC.List.elem [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. GHC.Classes.Eq a => a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sufm ds_sufn ds1_sufo]
        case ds1_sufo of {
          [] -> GHC.Types.False [];
          : y_sufq [Occ=Once] ys_sufr [Occ=Once] ->
              case GHC.Classes.== $dEq_sufm ds_sufn y_sufq of {
                GHC.Types.False -> GHC.List.elem $dEq_sufm ds_sufn ys_sufr;
                GHC.Types.True -> GHC.Types.True [];
              };
        };

GHC.List.all [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_suft ds1_sufu]
        case ds1_sufu of {
          [] -> GHC.Types.True [];
          : x_sufw [Occ=Once] xs_sufx [Occ=Once] ->
              case ds_suft x_sufw of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> GHC.List.all ds_suft xs_sufx;
              };
        };

GHC.List.any [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sufz ds1_sufA]
        case ds1_sufA of {
          [] -> GHC.Types.False [];
          : x_sufC [Occ=Once] xs_sufD [Occ=Once] ->
              case ds_sufz x_sufC of {
                GHC.Types.False -> GHC.List.any ds_sufz xs_sufD;
                GHC.Types.True -> GHC.Types.True [];
              };
        };

GHC.List.or [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: [GHC.Types.Bool] -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sufF]
        case ds_sufF of {
          [] -> GHC.Types.False [];
          : x_sufH [Occ=Once!] xs_sufI [Occ=Once] ->
              case x_sufH of {
                GHC.Types.False -> GHC.List.or xs_sufI;
                GHC.Types.True -> GHC.Types.True [];
              };
        };

GHC.List.and [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: [GHC.Types.Bool] -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sufK]
        case ds_sufK of {
          [] -> GHC.Types.True [];
          : x_sufM [Occ=Once!] xs_sufN [Occ=Once] ->
              case x_sufM of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> GHC.List.and xs_sufN;
              };
        };

GHC.List.reverse1 [Occ=LoopBreaker] :: forall a. [a] -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sufP a1_sufQ]
        case ds_sufP of {
          [] -> a1_sufQ;
          : x_sufS [Occ=Once] xs_sufT [Occ=Once] ->
              let {
                sat_sufU [Occ=Once] :: [a_asp0]
                [LclId] =
                    CCCS :! [x_sufS a1_sufQ];
              } in  GHC.List.reverse1 xs_sufT sat_sufU;
        };

GHC.List.reverse :: forall a. [a] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [l_sufV] GHC.List.reverse1 l_sufV GHC.Types.[];

GHC.List.$wbreak [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> (# [a], [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sufW w1_sufX]
        case w1_sufX of wild_sufY {
          [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
          : x_sufZ xs'_sug0 [Occ=Once] ->
              case w_sufW x_sufZ of {
                GHC.Types.False ->
                    let {
                      ds_sug2 [Dmd=<L,U(1*U,1*U)>] :: ([a_stKr], [a_stKr])
                      [LclId] =
                          [w_sufW xs'_sug0] \u []
                              case GHC.List.$wbreak w_sufW xs'_sug0 of {
                                (#,#) ww1_sug4 [Occ=Once] ww2_sug5 [Occ=Once] ->
                                    (,) [ww1_sug4 ww2_sug5];
                              }; } in
                    let {
                      sat_suge [Occ=Once] :: [a_stKr]
                      [LclId] =
                          [ds_sug2] \u []
                              case ds_sug2 of {
                                (,) _ [Occ=Dead] zs_sugd [Occ=Once] -> zs_sugd;
                              }; } in
                    let {
                      sat_sug9 [Occ=Once] :: [a_stKr]
                      [LclId] =
                          [ds_sug2] \u []
                              case ds_sug2 of {
                                (,) ys_sug7 [Occ=Once] _ [Occ=Dead] -> ys_sug7;
                              }; } in
                    let {
                      sat_suga [Occ=Once] :: [a_stKr]
                      [LclId] =
                          CCCS :! [x_sufZ sat_sug9];
                    } in  (#,#) [sat_suga sat_suge];
                GHC.Types.True -> (#,#) [GHC.Types.[] wild_sufY];
              };
        };

GHC.List.break [InlPrag=NOUSERINLINE[0]]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>m,
 Unf=OtherCon []] =
    [] \r [w_sugf w1_sugg]
        case GHC.List.$wbreak w_sugf w1_sugg of {
          (#,#) ww1_sugi [Occ=Once] ww2_sugj [Occ=Once] ->
              (,) [ww1_sugi ww2_sugj];
        };

GHC.List.$wspan [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> (# [a], [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sugk w1_sugl]
        case w1_sugl of wild_sugm {
          [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
          : x_sugn xs'_sugo [Occ=Once] ->
              case w_sugk x_sugn of {
                GHC.Types.False -> (#,#) [GHC.Types.[] wild_sugm];
                GHC.Types.True ->
                    let {
                      ds_sugq [Dmd=<L,U(1*U,1*U)>] :: ([a_stKk], [a_stKk])
                      [LclId] =
                          [w_sugk xs'_sugo] \u []
                              case GHC.List.$wspan w_sugk xs'_sugo of {
                                (#,#) ww1_sugs [Occ=Once] ww2_sugt [Occ=Once] ->
                                    (,) [ww1_sugs ww2_sugt];
                              }; } in
                    let {
                      sat_sugC [Occ=Once] :: [a_stKk]
                      [LclId] =
                          [ds_sugq] \u []
                              case ds_sugq of {
                                (,) _ [Occ=Dead] zs_sugB [Occ=Once] -> zs_sugB;
                              }; } in
                    let {
                      sat_sugx [Occ=Once] :: [a_stKk]
                      [LclId] =
                          [ds_sugq] \u []
                              case ds_sugq of {
                                (,) ys_sugv [Occ=Once] _ [Occ=Dead] -> ys_sugv;
                              }; } in
                    let {
                      sat_sugy [Occ=Once] :: [a_stKk]
                      [LclId] =
                          CCCS :! [x_sugn sat_sugx];
                    } in  (#,#) [sat_sugy sat_sugC];
              };
        };

GHC.List.span [InlPrag=NOUSERINLINE[0]]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>m,
 Unf=OtherCon []] =
    [] \r [w_sugD w1_sugE]
        case GHC.List.$wspan w_sugD w1_sugE of {
          (#,#) ww1_sugG [Occ=Once] ww2_sugH [Occ=Once] ->
              (,) [ww1_sugG ww2_sugH];
        };

GHC.List.takeFB [InlPrag=INLINE[0] (sat-args=4)]
  :: forall a b.
     (a -> b -> b)
     -> b -> a -> (GHC.Types.Int -> b) -> GHC.Types.Int -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U><L,1*C1(U)><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_sugI eta1_sugJ eta2_sugK eta3_sugL m_sugM]
        case m_sugM of {
          GHC.Types.I# ds_sugO [Occ=Once!] ->
              case ds_sugO of ds1_sugP {
                __DEFAULT ->
                    let {
                      sat_sugS [Occ=Once] :: b_asro
                      [LclId] =
                          [eta3_sugL ds1_sugP] \u []
                              case -# [ds1_sugP 1#] of sat_sugQ {
                                __DEFAULT ->
                                    let {
                                      sat_sugR [Occ=Once] :: GHC.Types.Int
                                      [LclId] =
                                          CCCS GHC.Types.I#! [sat_sugQ];
                                    } in  eta3_sugL sat_sugR;
                              };
                    } in  eta_sugI eta2_sugK sat_sugS;
                1# -> eta_sugI eta2_sugK eta1_sugJ;
              };
        };

GHC.List.flipSeqTake [InlPrag=INLINE[0] (sat-args=2)]
  :: forall a. a -> GHC.Types.Int -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [x_sugT _n_sugU]
        case _n_sugU of { GHC.Types.I# _ [Occ=Dead] -> x_sugT; };

GHC.List.$wunsafeTake [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. GHC.Prim.Int# -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_sugX w_sugY]
        case w_sugY of {
          [] -> [] [];
          : ipv_suh0 [Occ=Once*] ipv1_suh1 [Occ=Once] ->
              case ww_sugX of ds_suh2 {
                __DEFAULT ->
                    let {
                      sat_suh4 [Occ=Once] :: [a_stK6]
                      [LclId] =
                          [ipv1_suh1 ds_suh2] \u []
                              case -# [ds_suh2 1#] of sat_suh3 {
                                __DEFAULT -> GHC.List.$wunsafeTake sat_suh3 ipv1_suh1;
                              };
                    } in  : [ipv_suh0 sat_suh4];
                1# -> : [ipv_suh0 GHC.Types.[]];
              };
        };

GHC.List.unsafeTake [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Types.Int -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_suh5 w1_suh6]
        case w_suh5 of {
          GHC.Types.I# ww1_suh8 [Occ=Once] ->
              GHC.List.$wunsafeTake ww1_suh8 w1_suh6;
        };

GHC.List.take [InlPrag=INLINE[1] (sat-args=2)]
  :: forall a. GHC.Types.Int -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_suh9 eta1_suha]
        case eta_suh9 of {
          GHC.Types.I# y_suhc ->
              case <# [0# y_suhc] of {
                __DEFAULT -> [] [];
                1# -> GHC.List.$wunsafeTake y_suhc eta1_suha;
              };
        };

GHC.List.dropWhile [Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_suhe ds1_suhf]
        case ds1_suhf of wild_suhg {
          [] -> [] [];
          : x_suhh [Occ=Once] xs'_suhi [Occ=Once] ->
              case ds_suhe x_suhh of {
                GHC.Types.False -> wild_suhg;
                GHC.Types.True -> GHC.List.dropWhile ds_suhe xs'_suhi;
              };
        };

GHC.List.takeWhileFB [InlPrag=INLINE[0] (sat-args=3),
                      Occ=LoopBreaker!]
  :: forall a b.
     (a -> GHC.Types.Bool) -> (a -> b -> b) -> b -> a -> b -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(C1(U))><L,1*U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [p_suhk c_suhl n_suhm x_suhn r_suho]
        case p_suhk x_suhn of {
          GHC.Types.False -> n_suhm;
          GHC.Types.True -> c_suhl x_suhn r_suho;
        };

GHC.List.takeWhile [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_suhq ds1_suhr]
        case ds1_suhr of {
          [] -> [] [];
          : x_suht xs_suhu [Occ=Once] ->
              case ds_suhq x_suht of {
                GHC.Types.False -> [] [];
                GHC.Types.True ->
                    let {
                      sat_suhw [Occ=Once] :: [a_ass4]
                      [LclId] =
                          [ds_suhq xs_suhu] \u [] GHC.List.takeWhile ds_suhq xs_suhu;
                    } in  : [x_suht sat_suhw];
              };
        };

GHC.List.repeat [InlPrag=INLINE[0] (sat-args=1), Occ=LoopBreaker!]
  :: forall a. a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>, Unf=OtherCon []] =
    [] \r [x_suhx]
        let {
          xs_suhy [Occ=LoopBreaker] :: [a_assp]
          [LclId, Unf=OtherCon []] =
              CCCS :! [x_suhx xs_suhy];
        } in  xs_suhy;
GHC.List.repeatFB [InlPrag=INLINE[0] (sat-args=2),
                   Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [c_suhz x_suhA]
        let {
          xs_suhB [Occ=LoopBreaker] :: b_assi
          [LclId] =
              [c_suhz x_suhA xs_suhB] \u [] c_suhz x_suhA xs_suhB;
        } in  xs_suhB;

GHC.List.replicate [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Types.Int -> a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [n_suhC x_suhD]
        case n_suhC of {
          GHC.Types.I# y_suhF ->
              case <# [0# y_suhF] of {
                __DEFAULT -> [] [];
                1# ->
                    let {
                      lvl31_suhH [Occ=OnceL] :: [a_assx]
                      [LclId, Unf=OtherCon []] =
                          CCCS :! [x_suhD GHC.Types.[]]; } in
                    let {
                      $wxs_suhI [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                        :: GHC.Prim.Int# -> [a_assx]
                      [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                          sat-only [x_suhD lvl31_suhH $wxs_suhI] \r [ww_suhJ]
                              case ww_suhJ of ds_suhK {
                                __DEFAULT ->
                                    let {
                                      sat_suhM [Occ=Once] :: [a_assx]
                                      [LclId] =
                                          [$wxs_suhI ds_suhK] \u []
                                              case -# [ds_suhK 1#] of sat_suhL {
                                                __DEFAULT -> $wxs_suhI sat_suhL;
                                              };
                                    } in  : [x_suhD sat_suhM];
                                1# -> lvl31_suhH;
                              };
                    } in  $wxs_suhI y_suhF;
              };
        };

GHC.List.$witerate' [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> a) -> a -> (# a, [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_suhN w1_suhO]
        case w_suhN w1_suhO of x'_suhP {
          __DEFAULT ->
              let {
                sat_suhT [Occ=Once] :: [a_stJT]
                [LclId] =
                    [w_suhN x'_suhP] \u []
                        case GHC.List.$witerate' w_suhN x'_suhP of {
                          (#,#) ww1_suhR [Occ=Once] ww2_suhS [Occ=Once] ->
                              : [ww1_suhR ww2_suhS];
                        };
              } in  (#,#) [w1_suhO sat_suhT];
        };

GHC.List.iterate'FB [InlPrag=INLINE[0] (sat-args=3),
                     Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> (a -> a) -> a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><C(S),C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [c_suhU f_suhV x0_suhW]
        let {
          go2_suhX [Occ=LoopBreaker] :: a_assB -> b_assC
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [c_suhU f_suhV go2_suhX] \r [x_suhY]
                  case f_suhV x_suhY of x'_suhZ {
                    __DEFAULT ->
                        let {
                          sat_sui0 [Occ=Once] :: b_assC
                          [LclId] =
                              [go2_suhX x'_suhZ] \u [] go2_suhX x'_suhZ;
                        } in  c_suhU x_suhY sat_sui0;
                  };
        } in  go2_suhX x0_suhW;
GHC.List.iterate' [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker!]
  :: forall a. (a -> a) -> a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U)><L,U>m2,
 Unf=OtherCon []] =
    [] \r [w_sui1 w1_sui2]
        case GHC.List.$witerate' w_sui1 w1_sui2 of {
          (#,#) ww1_sui4 [Occ=Once] ww2_sui5 [Occ=Once] ->
              : [ww1_sui4 ww2_sui5];
        };

GHC.List.$witerate [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> a) -> a -> (# a, [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sui6 w1_sui7]
        let {
          sat_suic [Occ=Once] :: [a_stJL]
          [LclId] =
              [w_sui6 w1_sui7] \u []
                  let {
                    sat_sui8 [Occ=Once] :: a_stJL
                    [LclId] =
                        [w_sui6 w1_sui7] \u [] w_sui6 w1_sui7;
                  } in 
                    case GHC.List.$witerate w_sui6 sat_sui8 of {
                      (#,#) ww1_suia [Occ=Once] ww2_suib [Occ=Once] ->
                          : [ww1_suia ww2_suib];
                    };
        } in  (#,#) [w1_sui7 sat_suic];

GHC.List.iterateFB [InlPrag=INLINE[0] (sat-args=3),
                    Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> (a -> a) -> a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [c_suid f_suie x0_suif]
        let {
          go2_suig [Occ=LoopBreaker] :: a_astf -> b_astg
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [c_suid f_suie go2_suig] \r [x_suih]
                  let {
                    sat_suij [Occ=Once] :: b_astg
                    [LclId] =
                        [f_suie go2_suig x_suih] \u []
                            let {
                              sat_suii [Occ=Once] :: a_astf
                              [LclId] =
                                  [f_suie x_suih] \u [] f_suie x_suih;
                            } in  go2_suig sat_suii;
                  } in  c_suid x_suih sat_suij;
        } in  go2_suig x0_suif;
GHC.List.iterate [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker!]
  :: forall a. (a -> a) -> a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U>m2,
 Unf=OtherCon []] =
    [] \r [w_suik w1_suil]
        case GHC.List.$witerate w_suik w1_suil of {
          (#,#) ww1_suin [Occ=Once] ww2_suio [Occ=Once] ->
              : [ww1_suin ww2_suio];
        };

lvl27_ru9o :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC/List.hs:411:34-55|qs@(q : _)"#;

lvl28_ru9p :: forall a. ([a], a)
[GblId, Str=x] =
    [] \u [] Control.Exception.Base.patError lvl27_ru9o;

GHC.List.scanr1 [Occ=LoopBreaker]
  :: forall a. (a -> a -> a) -> [a] -> [a]
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []] =
    [] \r [ds_suip ds1_suiq]
        case ds1_suiq of {
          [] -> [] [];
          : x_suis [Occ=Once*] ds2_suit [Occ=Once!] ->
              case ds2_suit of wild1_suiu {
                [] -> : [x_suis GHC.Types.[]];
                : _ [Occ=Dead] _ [Occ=Dead] ->
                    let {
                      ds3_suix [Dmd=<L,U(1*U,1*U)>] :: ([a_astA], a_astA)
                      [LclId] =
                          [ds_suip wild1_suiu] \u []
                              case GHC.List.scanr1 ds_suip wild1_suiu of wild2_suiy {
                                [] -> lvl28_ru9p;
                                : q_suiz [Occ=Once] _ [Occ=Dead] -> (,) [wild2_suiy q_suiz];
                              }; } in
                    let {
                      sat_suiJ [Occ=Once] :: [a_astA]
                      [LclId] =
                          [ds3_suix] \u []
                              case ds3_suix of {
                                (,) qs_suiH [Occ=Once] _ [Occ=Dead] -> qs_suiH;
                              }; } in
                    let {
                      sat_suiF [Occ=Once] :: a_astA
                      [LclId] =
                          [ds_suip x_suis ds3_suix] \u []
                              let {
                                sat_suiE [Occ=Once] :: a_astA
                                [LclId] =
                                    [ds3_suix] \u []
                                        case ds3_suix of {
                                          (,) _ [Occ=Dead] q_suiD [Occ=Once] -> q_suiD;
                                        };
                              } in  ds_suip x_suis sat_suiE;
                    } in  : [sat_suiF sat_suiJ];
              };
        };

GHC.List.scanrFB [InlPrag=INLINE[0] (sat-args=2)]
  :: forall a b c.
     (a -> b -> b) -> (b -> c -> c) -> a -> (b, c) -> (b, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_suiK c1_suiL x_suiM ds_suiN]
        case ds_suiN of {
          (,) r_suiP est_suiQ [Occ=Once] ->
              let {
                sat_suiS [Occ=Once] :: c_astR
                [LclId] =
                    [c1_suiL r_suiP est_suiQ] \u [] c1_suiL r_suiP est_suiQ; } in
              let {
                sat_suiR [Occ=Once] :: b_astQ
                [LclId] =
                    [f_suiK x_suiM r_suiP] \u [] f_suiK x_suiM r_suiP;
              } in  (,) [sat_suiR sat_suiS];
        };

GHC.List.$wscanr [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a b. (a -> b -> b) -> b -> [a] -> (# b, [b] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_suiT w1_suiU w2_suiV]
        case w2_suiV of {
          [] -> (#,#) [w1_suiU GHC.Types.[]];
          : x_suiX [Occ=Once] xs_suiY [Occ=Once] ->
              let {
                ds_suiZ [Dmd=<L,U(1*U,1*U)>] :: ([b_stJz], b_stJz)
                [LclId] =
                    [w_suiT w1_suiU xs_suiY] \u []
                        case GHC.List.$wscanr w_suiT w1_suiU xs_suiY of {
                          (#,#) ww1_suj1 ww2_suj2 [Occ=Once] ->
                              let {
                                sat_suj3 [Occ=Once] :: [b_stJz]
                                [LclId] =
                                    CCCS :! [ww1_suj1 ww2_suj2];
                              } in  (,) [sat_suj3 ww1_suj1];
                        }; } in
              let {
                sat_sujc [Occ=Once] :: [b_stJz]
                [LclId] =
                    [ds_suiZ] \u []
                        case ds_suiZ of {
                          (,) qs_suja [Occ=Once] _ [Occ=Dead] -> qs_suja;
                        }; } in
              let {
                sat_suj8 [Occ=Once] :: b_stJz
                [LclId] =
                    [w_suiT x_suiX ds_suiZ] \u []
                        let {
                          sat_suj7 [Occ=Once] :: b_stJz
                          [LclId] =
                              [ds_suiZ] \u []
                                  case ds_suiZ of { (,) _ [Occ=Dead] q_suj6 [Occ=Once] -> q_suj6; };
                        } in  w_suiT x_suiX sat_suj7;
              } in  (#,#) [sat_suj8 sat_sujc];
        };

GHC.List.strictUncurryScanr [InlPrag=INLINE[0] (sat-args=2),
                             Occ=LoopBreaker!]
  :: forall a b c. (a -> b -> c) -> (a, b) -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sujd pair_suje]
        case pair_suje of {
          (,) x_sujg [Occ=Once] y_sujh [Occ=Once] -> f_sujd x_sujg y_sujh;
        };
GHC.List.scanr [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> b -> [a] -> [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>m2,
 Unf=OtherCon []] =
    [] \r [w_suji w1_sujj w2_sujk]
        case GHC.List.$wscanr w_suji w1_sujj w2_sujk of {
          (#,#) ww1_sujm [Occ=Once] ww2_sujn [Occ=Once] ->
              : [ww1_sujm ww2_sujn];
        };

GHC.List.flipSeqScanl' [InlPrag=INLINE[0] (sat-args=2)]
  :: forall a b. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_sujo _b_sujp] case _b_sujp of { __DEFAULT -> a1_sujo; };

GHC.List.scanlFB' [InlPrag=INLINE[0] (sat-args=2)]
  :: forall b a c.
     (b -> a -> b) -> (b -> c -> c) -> a -> (b -> c) -> b -> c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sujr c1_sujs b1_sujt g_suju v_sujv]
        case f_sujr v_sujv b1_sujt of b'_sujw {
          __DEFAULT ->
              let {
                sat_sujx [Occ=Once] :: c_asuE
                [LclId] =
                    [g_suju b'_sujw] \u [] g_suju b'_sujw;
              } in  c1_sujs b'_sujw sat_sujx;
        };

GHC.List.$wscanlGo' [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall b1 a1 b2 a2.
     (b2 -> a2 -> b2) -> b2 -> [a2] -> (# b2, [b2] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sujy w1_sujz w2_sujA]
        case w1_sujz of q_sujB {
          __DEFAULT ->
              let {
                sat_sujJ [Occ=Once] :: [b1_stJp]
                [LclId] =
                    [w_sujy w2_sujA q_sujB] \u []
                        case w2_sujA of {
                          [] -> [] [];
                          : x_sujD [Occ=Once] xs_sujE [Occ=Once] ->
                              case w_sujy q_sujB x_sujD of sat_sujF {
                                __DEFAULT ->
                                    case GHC.List.$wscanlGo' w_sujy sat_sujF xs_sujE of {
                                      (#,#) ww1_sujH [Occ=Once] ww2_sujI [Occ=Once] ->
                                          : [ww1_sujH ww2_sujI];
                                    };
                              };
                        };
              } in  (#,#) [q_sujB sat_sujJ];
        };

GHC.List.scanl'_scanlGo' [InlPrag=NOUSERINLINE[0]]
  :: forall b1 a1 b2 a2. (b2 -> a2 -> b2) -> b2 -> [a2] -> [b2]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,1*U>m2,
 Unf=OtherCon []] =
    [] \r [w_sujK w1_sujL w2_sujM]
        case GHC.List.$wscanlGo' w_sujK w1_sujL w2_sujM of {
          (#,#) ww1_sujO [Occ=Once] ww2_sujP [Occ=Once] ->
              : [ww1_sujO ww2_sujP];
        };

GHC.List.scanl' [InlPrag=NOINLINE[1]]
  :: forall b a. (b -> a -> b) -> b -> [a] -> [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,1*U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.List.scanl'_scanlGo' eta_B3 eta_B2 eta_B1;

GHC.List.constScanl [InlPrag=INLINE[0] (sat-args=0)]
  :: forall a b. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.const eta_B2 eta_B1;

GHC.List.scanlFB [InlPrag=INLINE[0] (sat-args=2)]
  :: forall b a c.
     (b -> a -> b) -> (b -> c -> c) -> a -> (b -> c) -> b -> c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sujQ c1_sujR b1_sujS g_sujT v_sujU]
        let {
          b'_sujV :: b_asvy
          [LclId] =
              [f_sujQ b1_sujS v_sujU] \u [] f_sujQ v_sujU b1_sujS; } in
        let {
          sat_sujW [Occ=Once] :: c_asvA
          [LclId] =
              [g_sujT b'_sujV] \u [] g_sujT b'_sujV;
        } in  c1_sujR b'_sujV sat_sujW;

GHC.List.$wscanlGo [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall b1 a1 b2 a2.
     (b2 -> a2 -> b2) -> b2 -> [a2] -> (# b2, [b2] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sujX w1_sujY w2_sujZ]
        let {
          sat_suk7 [Occ=Once] :: [b1_stJe]
          [LclId] =
              [w_sujX w1_sujY w2_sujZ] \u []
                  case w2_sujZ of {
                    [] -> [] [];
                    : x_suk1 [Occ=Once] xs_suk2 [Occ=Once] ->
                        let {
                          sat_suk3 [Occ=Once] :: b1_stJe
                          [LclId] =
                              [w_sujX w1_sujY x_suk1] \u [] w_sujX w1_sujY x_suk1;
                        } in 
                          case GHC.List.$wscanlGo w_sujX sat_suk3 xs_suk2 of {
                            (#,#) ww1_suk5 [Occ=Once] ww2_suk6 [Occ=Once] ->
                                : [ww1_suk5 ww2_suk6];
                          };
                  };
        } in  (#,#) [w1_sujY sat_suk7];

GHC.List.scanl_scanlGo [InlPrag=NOUSERINLINE[0]]
  :: forall b1 a1 b2 a2. (b2 -> a2 -> b2) -> b2 -> [a2] -> [b2]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,1*U>m2,
 Unf=OtherCon []] =
    [] \r [w_suk8 w1_suk9 w2_suka]
        case GHC.List.$wscanlGo w_suk8 w1_suk9 w2_suka of {
          (#,#) ww1_sukc [Occ=Once] ww2_sukd [Occ=Once] ->
              : [ww1_sukc ww2_sukd];
        };

GHC.List.scanl [InlPrag=NOINLINE[1]]
  :: forall b a. (b -> a -> b) -> b -> [a] -> [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,1*U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.List.scanl_scanlGo eta_B3 eta_B2 eta_B1;

GHC.List.scanl1 :: forall a. (a -> a -> a) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_suke ds_sukf]
        case ds_sukf of {
          [] -> [] [];
          : x_sukh xs_suki [Occ=Once] ->
              let {
                sat_sukm [Occ=Once] :: [a_aswp]
                [LclId] =
                    [f_suke x_sukh xs_suki] \u []
                        case GHC.List.$wscanlGo f_suke x_sukh xs_suki of {
                          (#,#) _ [Occ=Dead] ww2_sukl [Occ=Once] -> ww2_sukl;
                        };
              } in  : [x_sukh sat_sukm];
        };

GHC.List.foldl' [InlPrag=INLINE (sat-args=3)]
  :: forall a b. (b -> a -> b) -> b -> [a] -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [k_sukn z0_suko xs_sukp]
        let-no-escape {
          go2_sukq [Occ=LoopBreakerT[2]] :: [a_aswt] -> b_aswu -> b_aswu
          [LclId[JoinId(2)], Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
              sat-only [k_sukn go2_sukq] \r [ds_sukr eta_suks]
                  case ds_sukr of {
                    [] -> eta_suks;
                    : y_suku [Occ=Once] ys_sukv [Occ=Once] ->
                        case eta_suks of z_sukw {
                          __DEFAULT ->
                              case k_sukn z_sukw y_suku of sat_sukx {
                                __DEFAULT -> go2_sukq ys_sukv sat_sukx;
                              };
                        };
                  };
        } in  go2_sukq xs_sukp z0_suko;

GHC.List.foldl1' :: forall a. (a -> a -> a) -> [a] -> a
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []] =
    [] \r [f_suky ds_sukz]
        case ds_sukz of {
          [] -> GHC.List.foldl1'1;
          : x_sukB [Occ=Once] xs_sukC [Occ=Once] ->
              GHC.List.foldl' f_suky x_sukB xs_sukC;
        };

sat_sukD :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_sukE :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sukD GHC.Types.[]];

lvl29_ru9q :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sukE;

lvl30_ru9r :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

GHC.List.foldl [InlPrag=INLINE (sat-args=3)]
  :: forall a b. (b -> a -> b) -> b -> [a] -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [k_sukF z0_sukG xs_sukH]
        let-no-escape {
          go2_sukI [Occ=LoopBreakerT[2]] :: [a_asx1] -> b_asx2 -> b_asx2
          [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
              sat-only [k_sukF go2_sukI] \r [ds_sukJ eta_sukK]
                  case ds_sukJ of {
                    [] -> eta_sukK;
                    : y_sukM [Occ=Once] ys_sukN [Occ=Once] ->
                        let {
                          sat_sukO [Occ=Once] :: b_asx2
                          [LclId] =
                              [k_sukF eta_sukK y_sukM] \u [] k_sukF eta_sukK y_sukM;
                        } in  go2_sukI ys_sukN sat_sukO;
                  };
        } in  go2_sukI xs_sukH z0_sukG;

GHC.List.sum [InlPrag=INLINE (sat-args=0)]
  :: forall a. GHC.Num.Num a => [a] -> a
[GblId,
 Arity=1,
 Str=<L,U(1*C(C1(U)),A,A,A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_sukP]
        let {
          sat_sukR [Occ=Once] :: a_asyo
          [LclId] =
              [$dNum_sukP] \u [] GHC.Num.fromInteger $dNum_sukP lvl30_ru9r; } in
        let {
          sat_sukQ [Occ=Once] :: a_asyo -> a_asyo -> a_asyo
          [LclId] =
              [$dNum_sukP] \u [] GHC.Num.+ $dNum_sukP;
        } in  GHC.List.foldl sat_sukQ sat_sukR;

GHC.List.product [InlPrag=INLINE (sat-args=0)]
  :: forall a. GHC.Num.Num a => [a] -> a
[GblId,
 Arity=1,
 Str=<L,U(A,A,1*C(C1(U)),A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_sukS]
        let {
          sat_sukU [Occ=Once] :: a_asyy
          [LclId] =
              [$dNum_sukS] \u [] GHC.Num.fromInteger $dNum_sukS lvl29_ru9q; } in
        let {
          sat_sukT [Occ=Once] :: a_asyy -> a_asyy -> a_asyy
          [LclId] =
              [$dNum_sukS] \u [] GHC.Num.* $dNum_sukS;
        } in  GHC.List.foldl sat_sukT sat_sukU;

GHC.List.foldl1 :: forall a. (a -> a -> a) -> [a] -> a
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []] =
    [] \r [f_sukV ds_sukW]
        case ds_sukW of {
          [] -> GHC.List.foldl2;
          : x_sukY [Occ=Once] xs_sukZ [Occ=Once] ->
              GHC.List.foldl f_sukV x_sukY xs_sukZ;
        };

GHC.List.filterFB [InlPrag=INLINE[0] (sat-args=4),
                   Occ=LoopBreaker!]
  :: forall a b.
     (a -> b -> b) -> (a -> GHC.Types.Bool) -> a -> b -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S),1*C1(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [c_sul0 p_sul1 x_sul2 r_sul3]
        case p_sul1 x_sul2 of {
          GHC.Types.False -> r_sul3;
          GHC.Types.True -> c_sul0 x_sul2 r_sul3;
        };

GHC.List.filter [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [_pred_sul5 ds_sul6]
        case ds_sul6 of {
          [] -> [] [];
          : x_sul8 xs_sul9 [Occ=Once*] ->
              case _pred_sul5 x_sul8 of {
                GHC.Types.False -> GHC.List.filter _pred_sul5 xs_sul9;
                GHC.Types.True ->
                    let {
                      sat_sulb [Occ=Once] :: [a_asyL]
                      [LclId] =
                          [_pred_sul5 xs_sul9] \u [] GHC.List.filter _pred_sul5 xs_sul9;
                    } in  : [x_sul8 sat_sulb];
              };
        };

GHC.List.idLength [InlPrag=INLINE[0] (sat-args=0)]
  :: GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Base.id eta_B1;

GHC.List.lengthFB [InlPrag=INLINE[0] (sat-args=2)]
  :: forall x.
     x
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [eta_sulc eta1_suld a_sule]
        case a_sule of {
          GHC.Types.I# ipv_sulg [Occ=Once] ->
              case +# [ipv_sulg 1#] of sat_sulh {
                __DEFAULT ->
                    let {
                      sat_suli [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [sat_sulh];
                    } in  eta1_suld sat_suli;
              };
        };

GHC.List.$wlenAcc [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. [a] -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sulj ww_sulk]
        case w_sulj of {
          [] -> ww_sulk;
          : _ [Occ=Dead] ys_suln [Occ=Once] ->
              case +# [ww_sulk 1#] of sat_sulo {
                __DEFAULT -> GHC.List.$wlenAcc ys_suln sat_sulo;
              };
        };

GHC.List.lenAcc [InlPrag=NOUSERINLINE[0]]
  :: forall a. [a] -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [w_sulp w1_sulq]
        case w1_sulq of {
          GHC.Types.I# ww1_suls [Occ=Once] ->
              case GHC.List.$wlenAcc w_sulp ww1_suls of ww2_sult {
                __DEFAULT -> GHC.Types.I# [ww2_sult];
              };
        };

GHC.List.length [InlPrag=NOUSERINLINE[0]]
  :: forall a. [a] -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [w_sulu]
        case GHC.List.$wlenAcc w_sulu 0# of ww_sulv {
          __DEFAULT -> GHC.Types.I# [ww_sulv];
        };

GHC.List.null :: forall a. [a] -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sulw]
        case ds_sulw of {
          [] -> GHC.Types.True [];
          : _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
        };

GHC.List.uncons :: forall a. [a] -> GHC.Base.Maybe (a, [a])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sulA]
        case ds_sulA of {
          [] -> GHC.Base.Nothing [];
          : x_sulC [Occ=Once] xs_sulD [Occ=Once] ->
              let {
                sat_sulE [Occ=Once] :: (a_aszT, [a_aszT])
                [LclId] =
                    CCCS (,)! [x_sulC xs_sulD];
              } in  GHC.Base.Just [sat_sulE];
        };


==================== STG syntax: ====================
2018-03-16 15:55:06.210651721 UTC

$wunsafeDrop_ru8P :: forall a. GHC.Prim.Int# -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    sat-only [] \r [ww_su9t w_su9u]
        case w_su9u of {
          [] -> [] [];
          : _ [Occ=Dead] ipv1_su9x [Occ=Once*] ->
              case ww_su9t of ds_su9y {
                __DEFAULT ->
                    case -# [ds_su9y 1#] of sat_su9z {
                      __DEFAULT -> $wunsafeDrop_ru8P sat_su9z ipv1_su9x;
                    };
                1# -> ipv1_su9x;
              };
        };

GHC.List.drop [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Types.Int -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_su9A eta1_su9B]
        case eta_su9A of {
          GHC.Types.I# x_su9D ->
              case <=# [x_su9D 0#] of {
                __DEFAULT -> $wunsafeDrop_ru8P x_su9D eta1_su9B;
                1# -> eta1_su9B;
              };
        };

GHC.List.$wsplitAt' [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. GHC.Types.Int -> [a] -> (# [a], [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_su9F w1_su9G]
        case w1_su9G of {
          [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
          : ipv_su9I [Occ=Once*] ipv1_su9J [Occ=Once*] ->
              case w_su9F of {
                GHC.Types.I# ds_su9L [Occ=Once!] ->
                    case ds_su9L of ds1_su9M {
                      __DEFAULT ->
                          let {
                            ds2_su9N [Dmd=<L,U(1*U,1*U)>] :: ([a_stMO], [a_stMO])
                            [LclId] =
                                [ipv1_su9J ds1_su9M] \u []
                                    case -# [ds1_su9M 1#] of sat_su9O {
                                      __DEFAULT ->
                                          let {
                                            sat_su9P [Occ=Once] :: GHC.Types.Int
                                            [LclId] =
                                                CCCS GHC.Types.I#! [sat_su9O];
                                          } in 
                                            case GHC.List.$wsplitAt' sat_su9P ipv1_su9J of {
                                              (#,#) ww1_su9R [Occ=Once] ww2_su9S [Occ=Once] ->
                                                  (,) [ww1_su9R ww2_su9S];
                                            };
                                    }; } in
                          let {
                            sat_sua1 [Occ=Once] :: [a_stMO]
                            [LclId] =
                                [ds2_su9N] \u []
                                    case ds2_su9N of {
                                      (,) _ [Occ=Dead] xs''_sua0 [Occ=Once] -> xs''_sua0;
                                    }; } in
                          let {
                            sat_su9W [Occ=Once] :: [a_stMO]
                            [LclId] =
                                [ds2_su9N] \u []
                                    case ds2_su9N of {
                                      (,) xs'_su9U [Occ=Once] _ [Occ=Dead] -> xs'_su9U;
                                    }; } in
                          let {
                            sat_su9X [Occ=Once] :: [a_stMO]
                            [LclId] =
                                CCCS :! [ipv_su9I sat_su9W];
                          } in  (#,#) [sat_su9X sat_sua1];
                      1# ->
                          let {
                            sat_sua2 [Occ=Once] :: [a_stMO]
                            [LclId] =
                                CCCS :! [ipv_su9I GHC.Types.[]];
                          } in  (#,#) [sat_sua2 ipv1_su9J];
                    };
              };
        };

GHC.List.splitAt_splitAt' [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Types.Int -> [a] -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U)><S,1*U>m,
 Unf=OtherCon []] =
    [] \r [w_sua3 w1_sua4]
        case GHC.List.$wsplitAt' w_sua3 w1_sua4 of {
          (#,#) ww1_sua6 [Occ=Once] ww2_sua7 [Occ=Once] ->
              (,) [ww1_sua6 ww2_sua7];
        };

GHC.List.splitAt :: forall a. GHC.Types.Int -> [a] -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U>m,
 Unf=OtherCon []] =
    [] \r [n_sua8 ls_sua9]
        case n_sua8 of wild_suaa {
          GHC.Types.I# x_suab [Occ=Once] ->
              case <=# [x_suab 0#] of {
                __DEFAULT ->
                    case GHC.List.$wsplitAt' wild_suaa ls_sua9 of {
                      (#,#) ww1_suae [Occ=Once] ww2_suaf [Occ=Once] ->
                          (,) [ww1_suae ww2_suaf];
                    };
                1# -> (,) [GHC.Types.[] ls_sua9];
              };
        };

GHC.List.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.List.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.List.$trModule4];

GHC.List.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.List"#;

GHC.List.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.List.$trModule2];

GHC.List.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.List.$trModule3
                                     GHC.List.$trModule1];

GHC.List.init1 [Occ=LoopBreaker] :: forall a. a -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_suag ds1_suah]
        case ds1_suah of {
          [] -> [] [];
          : z_suaj [Occ=Once] zs_suak [Occ=Once] ->
              let {
                sat_sual [Occ=Once] :: [a_aszc]
                [LclId] =
                    [z_suaj zs_suak] \u [] GHC.List.init1 z_suaj zs_suak;
              } in  : [ds_suag sat_sual];
        };

lvl_ru8Q :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ": empty list"#;

lvl1_ru8R :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl_ru8Q;

GHC.List.!!4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Prelude."#;

GHC.List.prel_list_str :: GHC.Base.String
[GblId] =
    [] \u [] GHC.CString.unpackCString# GHC.List.!!4;

GHC.List.errorEmptyList :: forall a. GHC.Base.String -> a
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []] =
    [] \r [fun_suam]
        let {
          sat_suan [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [fun_suam] \s [] GHC.Base.++ fun_suam lvl1_ru8R;
        } in 
          case GHC.Base.++ GHC.List.prel_list_str sat_suan of sat_suao {
            __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_suao;
          };

lvl2_ru8S :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "!!: negative index"#;

lvl3_ru8T :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl2_ru8S;

GHC.List.negIndex :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.Base.++ GHC.List.prel_list_str lvl3_ru8T of sat_suap {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_suap;
        };

GHC.List.!!3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "!!: index too large"#;

GHC.List.!!2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# GHC.List.!!3;

GHC.List.!!1 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.Base.++ GHC.List.prel_list_str GHC.List.!!2;

GHC.List.tooLarge :: forall a. GHC.Types.Int -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [ds_suaq] GHC.Err.errorWithoutStackTrace GHC.List.!!1;

poly_exit_ru8U :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace GHC.List.!!1;

poly_$wgo_ru8V :: forall a. [a] -> GHC.Prim.Int# -> a
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [w_suar ww_suas]
        case w_suar of {
          [] -> poly_exit_ru8U;
          : y_suau [Occ=Once] ys_suav [Occ=Once] ->
              case ww_suas of ds_suaw {
                __DEFAULT ->
                    case -# [ds_suaw 1#] of sat_suax {
                      __DEFAULT -> poly_$wgo_ru8V ys_suav sat_suax;
                    };
                0# -> y_suau;
              };
        };

GHC.List.$w!! [InlPrag=INLINABLE[0]]
  :: forall a. [a] -> GHC.Prim.Int# -> a
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [w_suay ww_suaz]
        case <# [ww_suaz 0#] of {
          __DEFAULT -> poly_$wgo_ru8V w_suay ww_suaz;
          1# -> GHC.List.negIndex;
        };

GHC.List.!! [InlPrag=NOUSERINLINE[0]]
  :: forall a. [a] -> GHC.Types.Int -> a
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [w_suaB w1_suaC]
        case w1_suaC of {
          GHC.Types.I# ww1_suaE [Occ=Once] -> GHC.List.$w!! w_suaB ww1_suaE;
        };

lvl4_ru8W :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "cycle"#;

lvl5_ru8X :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl4_ru8W;

GHC.List.cycle1 :: forall a. [a]
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl5_ru8X;

GHC.List.cycle :: forall a. [a] -> [a]
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_suaF]
        case ds_suaF of wild_suaG {
          [] -> GHC.List.cycle1;
          : _ [Occ=Dead] _ [Occ=Dead] ->
              let {
                xs'_suaJ [Occ=LoopBreaker] :: [a_ass8]
                [LclId] =
                    [wild_suaG xs'_suaJ] \u [] GHC.Base.++ wild_suaG xs'_suaJ;
              } in  xs'_suaJ;
        };

lvl6_ru8Y :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1"#;

lvl7_ru8Z :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl6_ru8Y;

lvl8_ru90 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl7_ru8Z;

GHC.List.foldr1 [InlPrag=INLINE[0] (sat-args=1)]
  :: forall a. (a -> a -> a) -> [a] -> a
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []] =
    [] \r [f_suaK eta_suaL]
        let {
          go2_suaM [Occ=LoopBreaker] :: [a_asug] -> a_asug
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [f_suaK go2_suaM] \r [ds_suaN]
                  case ds_suaN of {
                    [] -> lvl8_ru90;
                    : x_suaP [Occ=Once*] ds1_suaQ [Occ=Once!] ->
                        case ds1_suaQ of wild1_suaR {
                          [] -> x_suaP;
                          : _ [Occ=Dead] _ [Occ=Dead] ->
                              let {
                                sat_suaU [Occ=Once] :: a_asug
                                [LclId] =
                                    [go2_suaM wild1_suaR] \u [] go2_suaM wild1_suaR;
                              } in  f_suaK x_suaP sat_suaU;
                        };
                  };
        } in  go2_suaM eta_suaL;

lvl9_ru91 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "init"#;

lvl10_ru92 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl9_ru91;

GHC.List.init2 :: forall a. [a]
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl10_ru92;

GHC.List.init :: forall a. [a] -> [a]
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_suaV]
        case ds_suaV of {
          [] -> GHC.List.init2;
          : x_suaX [Occ=Once] xs_suaY [Occ=Once] ->
              GHC.List.init1 x_suaX xs_suaY;
        };

lvl11_ru93 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "last"#;

lvl12_ru94 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl11_ru93;

GHC.List.lastError :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl12_ru94;

poly_go_ru95 :: forall a. [a] -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    sat-only [] \r [ds_suaZ eta_sub0]
        case ds_suaZ of {
          [] -> eta_sub0;
          : y_sub2 [Occ=Once] ys_sub3 [Occ=Once] ->
              poly_go_ru95 ys_sub3 y_sub2;
        };

GHC.List.last [InlPrag=INLINE (sat-args=1)] :: forall a. [a] -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [xs_sub4] poly_go_ru95 xs_sub4 GHC.List.lastError;

lvl13_ru96 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "tail"#;

lvl14_ru97 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl13_ru96;

GHC.List.scanl2 :: forall a. [a]
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl14_ru97;

GHC.List.tail :: forall a. [a] -> [a]
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sub5]
        case ds_sub5 of {
          [] -> GHC.List.scanl2;
          : _ [Occ=Dead] xs_sub8 [Occ=Once] -> xs_sub8;
        };

lvl15_ru98 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "head"#;

lvl16_ru99 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl15_ru98;

GHC.List.badHead :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl16_ru99;

GHC.List.head [InlPrag=NOINLINE[1], Occ=LoopBreaker!]
  :: forall a. [a] -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sub9]
        case ds_sub9 of {
          [] -> GHC.List.badHead;
          : x_subb [Occ=Once] _ [Occ=Dead] -> x_subb;
        };

lvl17_ru9a :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum"#;

lvl18_ru9b :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl17_ru9a;

GHC.List.maximum1 :: GHC.Integer.Type.Integer
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl18_ru9b;

GHC.List.maximum2 :: GHC.Types.Int
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl18_ru9b;

lvl19_ru9c :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl18_ru9b;

GHC.List.maximum_go [Occ=LoopBreaker]
  :: [GHC.Integer.Type.Integer]
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [ds_subd eta_sube]
        case ds_subd of {
          [] -> eta_sube;
          : y_subg ys_subh [Occ=Once*] ->
              case GHC.Integer.Type.leInteger# eta_sube y_subg of {
                __DEFAULT -> GHC.List.maximum_go ys_subh eta_sube;
                1# -> GHC.List.maximum_go ys_subh y_subg;
              };
        };

GHC.List.maximum_$smaximum [InlPrag=INLINABLE]
  :: [GHC.Integer.Type.Integer] -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_subj]
        case ds_subj of {
          [] -> GHC.List.maximum1;
          : ipv_subl [Occ=Once] ipv1_subm [Occ=Once] ->
              GHC.List.maximum_go ipv1_subm ipv_subl;
        };

lvl20_ru9d :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum"#;

lvl21_ru9e :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl20_ru9d;

GHC.List.minimum1 :: GHC.Integer.Type.Integer
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl21_ru9e;

GHC.List.minimum2 :: GHC.Types.Int
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl21_ru9e;

lvl22_ru9f :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl21_ru9e;

GHC.List.minimum_go [Occ=LoopBreaker]
  :: [GHC.Integer.Type.Integer]
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [ds_subn eta_subo]
        case ds_subn of {
          [] -> eta_subo;
          : y_subq ys_subr [Occ=Once*] ->
              case GHC.Integer.Type.leInteger# eta_subo y_subq of {
                __DEFAULT -> GHC.List.minimum_go ys_subr y_subq;
                1# -> GHC.List.minimum_go ys_subr eta_subo;
              };
        };

GHC.List.minimum_$sminimum [InlPrag=INLINABLE]
  :: [GHC.Integer.Type.Integer] -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_subt]
        case ds_subt of {
          [] -> GHC.List.minimum1;
          : ipv_subv [Occ=Once] ipv1_subw [Occ=Once] ->
              GHC.List.minimum_go ipv1_subw ipv_subv;
        };

GHC.List.$wgo [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: [GHC.Types.Int] -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_subx ww_suby]
        case w_subx of {
          [] -> ww_suby;
          : y_subA [Occ=Once!] ys_subB [Occ=Once*] ->
              case y_subA of {
                GHC.Types.I# y1_subD ->
                    case <=# [ww_suby y1_subD] of {
                      __DEFAULT -> GHC.List.$wgo ys_subB ww_suby;
                      1# -> GHC.List.$wgo ys_subB y1_subD;
                    };
              };
        };

GHC.List.maximum_$smaximum1 [InlPrag=NOUSERINLINE[0]]
  :: [GHC.Types.Int] -> GHC.Types.Int
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [w_subF]
        case w_subF of {
          [] -> GHC.List.maximum2;
          : ipv_subH [Occ=Once!] ipv1_subI [Occ=Once] ->
              case ipv_subH of {
                GHC.Types.I# ww1_subK [Occ=Once] ->
                    case GHC.List.$wgo ipv1_subI ww1_subK of ww2_subL {
                      __DEFAULT -> GHC.Types.I# [ww2_subL];
                    };
              };
        };

GHC.List.maximum [InlPrag=INLINABLE]
  :: forall a. GHC.Classes.Ord a => [a] -> a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,A,A,A,C(C1(U)),A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_subM ds_subN]
        case ds_subN of {
          [] -> lvl19_ru9c;
          : ipv_subP [Occ=Once] ipv1_subQ [Occ=Once] ->
              let-no-escape {
                go2_subR [Occ=LoopBreakerT[2]] :: [a_asxy] -> a_asxy -> a_asxy
                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
                    sat-only [$dOrd_subM go2_subR] \r [ds1_subS eta_subT]
                        case ds1_subS of {
                          [] -> eta_subT;
                          : y_subV [Occ=Once] ys_subW [Occ=Once] ->
                              let {
                                sat_subX [Occ=Once] :: a_asxy
                                [LclId] =
                                    [$dOrd_subM eta_subT y_subV] \u []
                                        GHC.Classes.max $dOrd_subM eta_subT y_subV;
                              } in  go2_subR ys_subW sat_subX;
                        };
              } in  go2_subR ipv1_subQ ipv_subP;
        };

GHC.List.$wgo1 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: [GHC.Types.Int] -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_subY ww_subZ]
        case w_subY of {
          [] -> ww_subZ;
          : y_suc1 [Occ=Once!] ys_suc2 [Occ=Once*] ->
              case y_suc1 of {
                GHC.Types.I# y1_suc4 ->
                    case <=# [ww_subZ y1_suc4] of {
                      __DEFAULT -> GHC.List.$wgo1 ys_suc2 y1_suc4;
                      1# -> GHC.List.$wgo1 ys_suc2 ww_subZ;
                    };
              };
        };

GHC.List.minimum_$sminimum1 [InlPrag=NOUSERINLINE[0]]
  :: [GHC.Types.Int] -> GHC.Types.Int
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [w_suc6]
        case w_suc6 of {
          [] -> GHC.List.minimum2;
          : ipv_suc8 [Occ=Once!] ipv1_suc9 [Occ=Once] ->
              case ipv_suc8 of {
                GHC.Types.I# ww1_sucb [Occ=Once] ->
                    case GHC.List.$wgo1 ipv1_suc9 ww1_sucb of ww2_succ {
                      __DEFAULT -> GHC.Types.I# [ww2_succ];
                    };
              };
        };

GHC.List.minimum [InlPrag=INLINABLE]
  :: forall a. GHC.Classes.Ord a => [a] -> a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,A,A,A,A,C(C1(U)))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sucd ds_suce]
        case ds_suce of {
          [] -> lvl22_ru9f;
          : ipv_sucg [Occ=Once] ipv1_such [Occ=Once] ->
              let-no-escape {
                go2_suci [Occ=LoopBreakerT[2]] :: [a_asxY] -> a_asxY -> a_asxY
                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
                    sat-only [$dOrd_sucd go2_suci] \r [ds1_sucj eta_suck]
                        case ds1_sucj of {
                          [] -> eta_suck;
                          : y_sucm [Occ=Once] ys_sucn [Occ=Once] ->
                              let {
                                sat_suco [Occ=Once] :: a_asxY
                                [LclId] =
                                    [$dOrd_sucd eta_suck y_sucm] \u []
                                        GHC.Classes.min $dOrd_sucd eta_suck y_sucm;
                              } in  go2_suci ys_sucn sat_suco;
                        };
              } in  go2_suci ipv1_such ipv_sucg;
        };

lvl23_ru9g :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1'"#;

lvl24_ru9h :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl23_ru9g;

GHC.List.foldl1'1 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl24_ru9h;

lvl25_ru9i :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1"#;

lvl26_ru9j :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl25_ru9i;

GHC.List.foldl2 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl26_ru9j;

$wgo2_ru9k :: forall a b c. [(a, b, c)] -> (# [a], [b], [c] #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [w_sucp]
        case w_sucp of {
          [] -> (#,,#) [GHC.Types.[] GHC.Types.[] GHC.Types.[]];
          : y_sucr [Occ=Once!] ys_sucs [Occ=Once] ->
              case y_sucr of {
                (,,) a1_sucu [Occ=Once] b1_sucv [Occ=Once] c1_sucw [Occ=Once] ->
                    let {
                      ds_sucx [Dmd=<L,U(1*U,1*U,1*U)>] :: ([a_stLF], [b_stLG], [c_stLH])
                      [LclId] =
                          [ys_sucs] \u []
                              case $wgo2_ru9k ys_sucs of {
                                (#,,#) ww1_sucz [Occ=Once]
                                       ww2_sucA [Occ=Once]
                                       ww3_sucB [Occ=Once] ->
                                    (,,) [ww1_sucz ww2_sucA ww3_sucB];
                              }; } in
                    let {
                      sat_sucS [Occ=Once] :: [c_stLH]
                      [LclId] =
                          [ds_sucx] \u []
                              case ds_sucx of {
                                (,,) _ [Occ=Dead] _ [Occ=Dead] cs_sucR [Occ=Once] -> cs_sucR;
                              }; } in
                    let {
                      sat_sucT [Occ=Once] :: [c_stLH]
                      [LclId] =
                          CCCS :! [c1_sucw sat_sucS]; } in
                    let {
                      sat_sucM [Occ=Once] :: [b_stLG]
                      [LclId] =
                          [ds_sucx] \u []
                              case ds_sucx of {
                                (,,) _ [Occ=Dead] bs_sucK [Occ=Once] _ [Occ=Dead] -> bs_sucK;
                              }; } in
                    let {
                      sat_sucN [Occ=Once] :: [b_stLG]
                      [LclId] =
                          CCCS :! [b1_sucv sat_sucM]; } in
                    let {
                      sat_sucG [Occ=Once] :: [a_stLF]
                      [LclId] =
                          [ds_sucx] \u []
                              case ds_sucx of {
                                (,,) as_sucD [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> as_sucD;
                              }; } in
                    let {
                      sat_sucH [Occ=Once] :: [a_stLF]
                      [LclId] =
                          CCCS :! [a1_sucu sat_sucG];
                    } in  (#,,#) [sat_sucH sat_sucN sat_sucT];
              };
        };

go_ru9l :: forall a b c. [(a, b, c)] -> ([a], [b], [c])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    sat-only [] \r [w_sucU]
        case $wgo2_ru9k w_sucU of {
          (#,,#) ww1_sucW [Occ=Once]
                 ww2_sucX [Occ=Once]
                 ww3_sucY [Occ=Once] ->
              (,,) [ww1_sucW ww2_sucX ww3_sucY];
        };

GHC.List.unzip3 [InlPrag=INLINE (sat-args=0)]
  :: forall a b c. [(a, b, c)] -> ([a], [b], [c])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [eta_B1] go_ru9l eta_B1;

$wgo3_ru9m :: forall a b. [(a, b)] -> (# [a], [b] #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [w_sucZ]
        case w_sucZ of {
          [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
          : y_sud1 [Occ=Once!] ys_sud2 [Occ=Once] ->
              case y_sud1 of {
                (,) a1_sud4 [Occ=Once] b1_sud5 [Occ=Once] ->
                    let {
                      ds_sud6 [Dmd=<L,U(1*U,1*U)>] :: ([a_stLy], [b_stLz])
                      [LclId] =
                          [ys_sud2] \u []
                              case $wgo3_ru9m ys_sud2 of {
                                (#,#) ww1_sud8 [Occ=Once] ww2_sud9 [Occ=Once] ->
                                    (,) [ww1_sud8 ww2_sud9];
                              }; } in
                    let {
                      sat_sudi [Occ=Once] :: [b_stLz]
                      [LclId] =
                          [ds_sud6] \u []
                              case ds_sud6 of {
                                (,) _ [Occ=Dead] bs_sudh [Occ=Once] -> bs_sudh;
                              }; } in
                    let {
                      sat_sudj [Occ=Once] :: [b_stLz]
                      [LclId] =
                          CCCS :! [b1_sud5 sat_sudi]; } in
                    let {
                      sat_sudd [Occ=Once] :: [a_stLy]
                      [LclId] =
                          [ds_sud6] \u []
                              case ds_sud6 of {
                                (,) as_sudb [Occ=Once] _ [Occ=Dead] -> as_sudb;
                              }; } in
                    let {
                      sat_sude [Occ=Once] :: [a_stLy]
                      [LclId] =
                          CCCS :! [a1_sud4 sat_sudd];
                    } in  (#,#) [sat_sude sat_sudj];
              };
        };

go1_ru9n :: forall a b. [(a, b)] -> ([a], [b])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    sat-only [] \r [w_sudk]
        case $wgo3_ru9m w_sudk of {
          (#,#) ww1_sudm [Occ=Once] ww2_sudn [Occ=Once] ->
              (,) [ww1_sudm ww2_sudn];
        };

GHC.List.unzip [InlPrag=INLINE (sat-args=0)]
  :: forall a b. [(a, b)] -> ([a], [b])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [eta_B1] go1_ru9n eta_B1;

GHC.List.zipWith3
  :: forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><S,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [z_sudo eta_sudp eta1_sudq eta2_sudr]
        let {
          go2_suds [Occ=LoopBreaker]
            :: [a_asln] -> [b_aslo] -> [c_aslp] -> [d_aslq]
          [LclId, Arity=3, Str=<S,1*U><L,1*U><L,1*U>, Unf=OtherCon []] =
              sat-only [z_sudo go2_suds] \r [ds_sudt ds1_sudu ds2_sudv]
                  case ds_sudt of {
                    [] -> [] [];
                    : a1_sudx [Occ=Once] as_sudy [Occ=Once] ->
                        case ds1_sudu of {
                          [] -> [] [];
                          : b1_sudA [Occ=Once] bs_sudB [Occ=Once] ->
                              case ds2_sudv of {
                                [] -> [] [];
                                : c1_sudD [Occ=Once] cs_sudE [Occ=Once] ->
                                    let {
                                      sat_sudG [Occ=Once] :: [d_aslq]
                                      [LclId] =
                                          [go2_suds as_sudy bs_sudB cs_sudE] \u []
                                              go2_suds as_sudy bs_sudB cs_sudE; } in
                                    let {
                                      sat_sudF [Occ=Once] :: d_aslq
                                      [LclId] =
                                          [z_sudo a1_sudx b1_sudA c1_sudD] \u []
                                              z_sudo a1_sudx b1_sudA c1_sudD;
                                    } in  : [sat_sudF sat_sudG];
                              };
                        };
                  };
        } in  go2_suds eta_sudp eta1_sudq eta2_sudr;

GHC.List.zipWithFB [InlPrag=INLINE[0] (sat-args=2)]
  :: forall a b c d e.
     (a -> b -> c) -> (d -> e -> a) -> d -> e -> b -> c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [c1_sudH f_sudI x_sudJ y_sudK r_sudL]
        let {
          sat_sudM [Occ=Once] :: a_aslZ
          [LclId] =
              [f_sudI x_sudJ y_sudK] \u [] f_sudI x_sudJ y_sudK;
        } in  c1_sudH sat_sudM r_sudL;

GHC.List.zip3 [Occ=LoopBreaker]
  :: forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sudN ds1_sudO ds2_sudP]
        case ds_sudN of {
          [] -> [] [];
          : a1_sudR [Occ=Once] as_sudS [Occ=Once] ->
              case ds1_sudO of {
                [] -> [] [];
                : b1_sudU [Occ=Once] bs_sudV [Occ=Once] ->
                    case ds2_sudP of {
                      [] -> [] [];
                      : c1_sudX [Occ=Once] cs_sudY [Occ=Once] ->
                          let {
                            sat_sue0 [Occ=Once] :: [(a_asmz, b_asmA, c_asmB)]
                            [LclId] =
                                [as_sudS bs_sudV cs_sudY] \u []
                                    GHC.List.zip3 as_sudS bs_sudV cs_sudY; } in
                          let {
                            sat_sudZ [Occ=Once] :: (a_asmz, b_asmA, c_asmB)
                            [LclId] =
                                CCCS (,,)! [a1_sudR b1_sudU c1_sudX];
                          } in  : [sat_sudZ sat_sue0];
                    };
              };
        };

GHC.List.zipFB [InlPrag=INLINE[0] (sat-args=1)]
  :: forall a b c d. ((a, b) -> c -> d) -> a -> b -> c -> d
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [c1_sue1 x_sue2 y_sue3 r_sue4]
        let {
          sat_sue5 [Occ=Once] :: (a_asmK, b_asmL)
          [LclId] =
              CCCS (,)! [x_sue2 y_sue3];
        } in  c1_sue1 sat_sue5 r_sue4;

GHC.List.foldr2_left
  :: forall a b c d.
     (a -> b -> c -> d) -> d -> a -> ([b] -> c) -> [b] -> d
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><L,1*U><L,U><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [_k_sue6 z_sue7 _x_sue8 _r_sue9 ds_suea]
        case ds_suea of {
          [] -> z_sue7;
          : y_suec [Occ=Once] ys_sued [Occ=Once] ->
              let {
                sat_suee [Occ=Once] :: c_asmZ
                [LclId] =
                    [_r_sue9 ys_sued] \u [] _r_sue9 ys_sued;
              } in  _k_sue6 _x_sue8 y_suec sat_suee;
        };

GHC.List.zip [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a b. [a] -> [b] -> [(a, b)]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_suef _bs_sueg]
        case ds_suef of {
          [] -> [] [];
          : ipv_suei [Occ=Once] ipv1_suej [Occ=Once] ->
              case _bs_sueg of {
                [] -> [] [];
                : ipv2_suel [Occ=Once] ipv3_suem [Occ=Once] ->
                    let {
                      sat_sueo [Occ=Once] :: [(a_asmP, b_asmQ)]
                      [LclId] =
                          [ipv1_suej ipv3_suem] \u [] GHC.List.zip ipv1_suej ipv3_suem; } in
                    let {
                      sat_suen [Occ=Once] :: (a_asmP, b_asmQ)
                      [LclId] =
                          CCCS (,)! [ipv_suei ipv2_suel];
                    } in  : [sat_suen sat_sueo];
              };
        };
GHC.List.zipWith [InlPrag=NOINLINE[1], Occ=LoopBreaker!]
  :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_suep eta_sueq eta1_suer]
        let {
          go2_sues [Occ=LoopBreaker] :: [a_asm5] -> [b_asm6] -> [c_asm7]
          [LclId, Arity=2, Str=<S,1*U><L,1*U>, Unf=OtherCon []] =
              sat-only [f_suep go2_sues] \r [ds_suet ds1_sueu]
                  case ds_suet of {
                    [] -> [] [];
                    : ipv_suew [Occ=Once] ipv1_suex [Occ=Once] ->
                        case ds1_sueu of {
                          [] -> [] [];
                          : ipv2_suez [Occ=Once] ipv3_sueA [Occ=Once] ->
                              let {
                                sat_sueC [Occ=Once] :: [c_asm7]
                                [LclId] =
                                    [go2_sues ipv1_suex ipv3_sueA] \u []
                                        go2_sues ipv1_suex ipv3_sueA; } in
                              let {
                                sat_sueB [Occ=Once] :: c_asm7
                                [LclId] =
                                    [f_suep ipv_suew ipv2_suez] \u [] f_suep ipv_suew ipv2_suez;
                              } in  : [sat_sueB sat_sueC];
                        };
                  };
        } in  go2_sues eta_sueq eta1_suer;
GHC.List.foldr2 [InlPrag=INLINE[0] (sat-args=2), Occ=LoopBreaker!]
  :: forall a b c. (a -> b -> c -> c) -> c -> [a] -> [b] -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,U><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [k_sueD z_sueE eta_sueF eta1_sueG]
        let {
          go2_sueH [Occ=LoopBreaker] :: [a_asn2] -> [b_asn3] -> c_asn4
          [LclId, Arity=2, Str=<S,1*U><L,1*U>, Unf=OtherCon []] =
              sat-only [k_sueD z_sueE go2_sueH] \r [ds_sueI _ys_sueJ]
                  case ds_sueI of {
                    [] -> z_sueE;
                    : ipv_sueL [Occ=Once] ipv1_sueM [Occ=Once] ->
                        case _ys_sueJ of {
                          [] -> z_sueE;
                          : ipv2_sueO [Occ=Once] ipv3_sueP [Occ=Once] ->
                              let {
                                sat_sueQ [Occ=Once] :: c_asn4
                                [LclId] =
                                    [go2_sueH ipv1_sueM ipv3_sueP] \u []
                                        go2_sueH ipv1_sueM ipv3_sueP;
                              } in  k_sueD ipv_sueL ipv2_sueO sat_sueQ;
                        };
                  };
        } in  go2_sueH eta_sueF eta1_sueG;

GHC.List.concat_go [Occ=LoopBreaker] :: forall a. [[a]] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sueR]
        case ds_sueR of {
          [] -> [] [];
          : y_sueT [Occ=Once] ys_sueU [Occ=Once] ->
              let {
                sat_sueV [Occ=Once, Dmd=<L,1*U>] :: [a_asob]
                [LclId] =
                    [ys_sueU] \s [] GHC.List.concat_go ys_sueU;
              } in  GHC.Base.++ y_sueT sat_sueV;
        };

GHC.List.concat [InlPrag=NOINLINE[1]] :: forall a. [[a]] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1] GHC.List.concat_go eta_B1;

GHC.List.concatMap [InlPrag=NOINLINE[1]]
  :: forall a b. (a -> [b]) -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sueW eta_sueX]
        let {
          go2_sueY [Occ=LoopBreaker] :: [a_asog] -> [b_asoh]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [f_sueW go2_sueY] \r [ds_sueZ]
                  case ds_sueZ of {
                    [] -> [] [];
                    : y_suf1 [Occ=Once] ys_suf2 [Occ=Once] ->
                        let {
                          sat_suf4 [Occ=Once, Dmd=<L,1*U>] :: [b_asoh]
                          [LclId] =
                              [go2_sueY ys_suf2] \s [] go2_sueY ys_suf2;
                        } in 
                          case f_sueW y_suf1 of sat_suf3 {
                            __DEFAULT -> GHC.Base.++ sat_suf3 sat_suf4;
                          };
                  };
        } in  go2_sueY eta_sueX;

GHC.List.lookup [Occ=LoopBreaker]
  :: forall a b.
     GHC.Classes.Eq a =>
     a -> [(a, b)] -> GHC.Base.Maybe b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_suf5 _key_suf6 ds_suf7]
        case ds_suf7 of {
          [] -> GHC.Base.Nothing [];
          : ds1_suf9 [Occ=Once!] xys_sufa [Occ=Once] ->
              case ds1_suf9 of {
                (,) x_sufc [Occ=Once] y_sufd [Occ=Once] ->
                    case GHC.Classes.== $dEq_suf5 _key_suf6 x_sufc of {
                      GHC.Types.False -> GHC.List.lookup $dEq_suf5 _key_suf6 xys_sufa;
                      GHC.Types.True -> GHC.Base.Just [y_sufd];
                    };
              };
        };

GHC.List.notElem [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. GHC.Classes.Eq a => a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_suff ds_sufg ds1_sufh]
        case ds1_sufh of {
          [] -> GHC.Types.True [];
          : y_sufj [Occ=Once] ys_sufk [Occ=Once] ->
              case GHC.Classes./= $dEq_suff ds_sufg y_sufj of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> GHC.List.notElem $dEq_suff ds_sufg ys_sufk;
              };
        };

GHC.List.elem [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. GHC.Classes.Eq a => a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sufm ds_sufn ds1_sufo]
        case ds1_sufo of {
          [] -> GHC.Types.False [];
          : y_sufq [Occ=Once] ys_sufr [Occ=Once] ->
              case GHC.Classes.== $dEq_sufm ds_sufn y_sufq of {
                GHC.Types.False -> GHC.List.elem $dEq_sufm ds_sufn ys_sufr;
                GHC.Types.True -> GHC.Types.True [];
              };
        };

GHC.List.all [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_suft ds1_sufu]
        case ds1_sufu of {
          [] -> GHC.Types.True [];
          : x_sufw [Occ=Once] xs_sufx [Occ=Once] ->
              case ds_suft x_sufw of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> GHC.List.all ds_suft xs_sufx;
              };
        };

GHC.List.any [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sufz ds1_sufA]
        case ds1_sufA of {
          [] -> GHC.Types.False [];
          : x_sufC [Occ=Once] xs_sufD [Occ=Once] ->
              case ds_sufz x_sufC of {
                GHC.Types.False -> GHC.List.any ds_sufz xs_sufD;
                GHC.Types.True -> GHC.Types.True [];
              };
        };

GHC.List.or [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: [GHC.Types.Bool] -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sufF]
        case ds_sufF of {
          [] -> GHC.Types.False [];
          : x_sufH [Occ=Once!] xs_sufI [Occ=Once] ->
              case x_sufH of {
                GHC.Types.False -> GHC.List.or xs_sufI;
                GHC.Types.True -> GHC.Types.True [];
              };
        };

GHC.List.and [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: [GHC.Types.Bool] -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sufK]
        case ds_sufK of {
          [] -> GHC.Types.True [];
          : x_sufM [Occ=Once!] xs_sufN [Occ=Once] ->
              case x_sufM of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> GHC.List.and xs_sufN;
              };
        };

GHC.List.reverse1 [Occ=LoopBreaker] :: forall a. [a] -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sufP a1_sufQ]
        case ds_sufP of {
          [] -> a1_sufQ;
          : x_sufS [Occ=Once] xs_sufT [Occ=Once] ->
              let {
                sat_sufU [Occ=Once] :: [a_asp0]
                [LclId] =
                    CCCS :! [x_sufS a1_sufQ];
              } in  GHC.List.reverse1 xs_sufT sat_sufU;
        };

GHC.List.reverse :: forall a. [a] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [l_sufV] GHC.List.reverse1 l_sufV GHC.Types.[];

GHC.List.$wbreak [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> (# [a], [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sufW w1_sufX]
        case w1_sufX of wild_sufY {
          [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
          : x_sufZ xs'_sug0 [Occ=Once] ->
              case w_sufW x_sufZ of {
                GHC.Types.False ->
                    let {
                      ds_sug2 [Dmd=<L,U(1*U,1*U)>] :: ([a_stKr], [a_stKr])
                      [LclId] =
                          [w_sufW xs'_sug0] \u []
                              case GHC.List.$wbreak w_sufW xs'_sug0 of {
                                (#,#) ww1_sug4 [Occ=Once] ww2_sug5 [Occ=Once] ->
                                    (,) [ww1_sug4 ww2_sug5];
                              }; } in
                    let {
                      sat_suge [Occ=Once] :: [a_stKr]
                      [LclId] =
                          [ds_sug2] \u []
                              case ds_sug2 of {
                                (,) _ [Occ=Dead] zs_sugd [Occ=Once] -> zs_sugd;
                              }; } in
                    let {
                      sat_sug9 [Occ=Once] :: [a_stKr]
                      [LclId] =
                          [ds_sug2] \u []
                              case ds_sug2 of {
                                (,) ys_sug7 [Occ=Once] _ [Occ=Dead] -> ys_sug7;
                              }; } in
                    let {
                      sat_suga [Occ=Once] :: [a_stKr]
                      [LclId] =
                          CCCS :! [x_sufZ sat_sug9];
                    } in  (#,#) [sat_suga sat_suge];
                GHC.Types.True -> (#,#) [GHC.Types.[] wild_sufY];
              };
        };

GHC.List.break [InlPrag=NOUSERINLINE[0]]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>m,
 Unf=OtherCon []] =
    [] \r [w_sugf w1_sugg]
        case GHC.List.$wbreak w_sugf w1_sugg of {
          (#,#) ww1_sugi [Occ=Once] ww2_sugj [Occ=Once] ->
              (,) [ww1_sugi ww2_sugj];
        };

GHC.List.$wspan [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> (# [a], [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sugk w1_sugl]
        case w1_sugl of wild_sugm {
          [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
          : x_sugn xs'_sugo [Occ=Once] ->
              case w_sugk x_sugn of {
                GHC.Types.False -> (#,#) [GHC.Types.[] wild_sugm];
                GHC.Types.True ->
                    let {
                      ds_sugq [Dmd=<L,U(1*U,1*U)>] :: ([a_stKk], [a_stKk])
                      [LclId] =
                          [w_sugk xs'_sugo] \u []
                              case GHC.List.$wspan w_sugk xs'_sugo of {
                                (#,#) ww1_sugs [Occ=Once] ww2_sugt [Occ=Once] ->
                                    (,) [ww1_sugs ww2_sugt];
                              }; } in
                    let {
                      sat_sugC [Occ=Once] :: [a_stKk]
                      [LclId] =
                          [ds_sugq] \u []
                              case ds_sugq of {
                                (,) _ [Occ=Dead] zs_sugB [Occ=Once] -> zs_sugB;
                              }; } in
                    let {
                      sat_sugx [Occ=Once] :: [a_stKk]
                      [LclId] =
                          [ds_sugq] \u []
                              case ds_sugq of {
                                (,) ys_sugv [Occ=Once] _ [Occ=Dead] -> ys_sugv;
                              }; } in
                    let {
                      sat_sugy [Occ=Once] :: [a_stKk]
                      [LclId] =
                          CCCS :! [x_sugn sat_sugx];
                    } in  (#,#) [sat_sugy sat_sugC];
              };
        };

GHC.List.span [InlPrag=NOUSERINLINE[0]]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>m,
 Unf=OtherCon []] =
    [] \r [w_sugD w1_sugE]
        case GHC.List.$wspan w_sugD w1_sugE of {
          (#,#) ww1_sugG [Occ=Once] ww2_sugH [Occ=Once] ->
              (,) [ww1_sugG ww2_sugH];
        };

GHC.List.takeFB [InlPrag=INLINE[0] (sat-args=4)]
  :: forall a b.
     (a -> b -> b)
     -> b -> a -> (GHC.Types.Int -> b) -> GHC.Types.Int -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U><L,1*C1(U)><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_sugI eta1_sugJ eta2_sugK eta3_sugL m_sugM]
        case m_sugM of {
          GHC.Types.I# ds_sugO [Occ=Once!] ->
              case ds_sugO of ds1_sugP {
                __DEFAULT ->
                    let {
                      sat_sugS [Occ=Once] :: b_asro
                      [LclId] =
                          [eta3_sugL ds1_sugP] \u []
                              case -# [ds1_sugP 1#] of sat_sugQ {
                                __DEFAULT ->
                                    let {
                                      sat_sugR [Occ=Once] :: GHC.Types.Int
                                      [LclId] =
                                          CCCS GHC.Types.I#! [sat_sugQ];
                                    } in  eta3_sugL sat_sugR;
                              };
                    } in  eta_sugI eta2_sugK sat_sugS;
                1# -> eta_sugI eta2_sugK eta1_sugJ;
              };
        };

GHC.List.flipSeqTake [InlPrag=INLINE[0] (sat-args=2)]
  :: forall a. a -> GHC.Types.Int -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [x_sugT _n_sugU]
        case _n_sugU of { GHC.Types.I# _ [Occ=Dead] -> x_sugT; };

GHC.List.$wunsafeTake [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. GHC.Prim.Int# -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_sugX w_sugY]
        case w_sugY of {
          [] -> [] [];
          : ipv_suh0 [Occ=Once*] ipv1_suh1 [Occ=Once] ->
              case ww_sugX of ds_suh2 {
                __DEFAULT ->
                    let {
                      sat_suh4 [Occ=Once] :: [a_stK6]
                      [LclId] =
                          [ipv1_suh1 ds_suh2] \u []
                              case -# [ds_suh2 1#] of sat_suh3 {
                                __DEFAULT -> GHC.List.$wunsafeTake sat_suh3 ipv1_suh1;
                              };
                    } in  : [ipv_suh0 sat_suh4];
                1# -> : [ipv_suh0 GHC.Types.[]];
              };
        };

GHC.List.unsafeTake [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Types.Int -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_suh5 w1_suh6]
        case w_suh5 of {
          GHC.Types.I# ww1_suh8 [Occ=Once] ->
              GHC.List.$wunsafeTake ww1_suh8 w1_suh6;
        };

GHC.List.take [InlPrag=INLINE[1] (sat-args=2)]
  :: forall a. GHC.Types.Int -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_suh9 eta1_suha]
        case eta_suh9 of {
          GHC.Types.I# y_suhc ->
              case <# [0# y_suhc] of {
                __DEFAULT -> [] [];
                1# -> GHC.List.$wunsafeTake y_suhc eta1_suha;
              };
        };

GHC.List.dropWhile [Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_suhe ds1_suhf]
        case ds1_suhf of wild_suhg {
          [] -> [] [];
          : x_suhh [Occ=Once] xs'_suhi [Occ=Once] ->
              case ds_suhe x_suhh of {
                GHC.Types.False -> wild_suhg;
                GHC.Types.True -> GHC.List.dropWhile ds_suhe xs'_suhi;
              };
        };

GHC.List.takeWhileFB [InlPrag=INLINE[0] (sat-args=3),
                      Occ=LoopBreaker!]
  :: forall a b.
     (a -> GHC.Types.Bool) -> (a -> b -> b) -> b -> a -> b -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(C1(U))><L,1*U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [p_suhk c_suhl n_suhm x_suhn r_suho]
        case p_suhk x_suhn of {
          GHC.Types.False -> n_suhm;
          GHC.Types.True -> c_suhl x_suhn r_suho;
        };

GHC.List.takeWhile [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_suhq ds1_suhr]
        case ds1_suhr of {
          [] -> [] [];
          : x_suht xs_suhu [Occ=Once] ->
              case ds_suhq x_suht of {
                GHC.Types.False -> [] [];
                GHC.Types.True ->
                    let {
                      sat_suhw [Occ=Once] :: [a_ass4]
                      [LclId] =
                          [ds_suhq xs_suhu] \u [] GHC.List.takeWhile ds_suhq xs_suhu;
                    } in  : [x_suht sat_suhw];
              };
        };

GHC.List.repeat [InlPrag=INLINE[0] (sat-args=1), Occ=LoopBreaker!]
  :: forall a. a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>, Unf=OtherCon []] =
    [] \r [x_suhx]
        let {
          xs_suhy [Occ=LoopBreaker] :: [a_assp]
          [LclId, Unf=OtherCon []] =
              CCCS :! [x_suhx xs_suhy];
        } in  xs_suhy;
GHC.List.repeatFB [InlPrag=INLINE[0] (sat-args=2),
                   Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [c_suhz x_suhA]
        let {
          xs_suhB [Occ=LoopBreaker] :: b_assi
          [LclId] =
              [c_suhz x_suhA xs_suhB] \u [] c_suhz x_suhA xs_suhB;
        } in  xs_suhB;

GHC.List.replicate [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Types.Int -> a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [n_suhC x_suhD]
        case n_suhC of {
          GHC.Types.I# y_suhF ->
              case <# [0# y_suhF] of {
                __DEFAULT -> [] [];
                1# ->
                    let {
                      lvl31_suhH [Occ=OnceL] :: [a_assx]
                      [LclId, Unf=OtherCon []] =
                          CCCS :! [x_suhD GHC.Types.[]]; } in
                    let {
                      $wxs_suhI [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                        :: GHC.Prim.Int# -> [a_assx]
                      [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                          sat-only [x_suhD lvl31_suhH $wxs_suhI] \r [ww_suhJ]
                              case ww_suhJ of ds_suhK {
                                __DEFAULT ->
                                    let {
                                      sat_suhM [Occ=Once] :: [a_assx]
                                      [LclId] =
                                          [$wxs_suhI ds_suhK] \u []
                                              case -# [ds_suhK 1#] of sat_suhL {
                                                __DEFAULT -> $wxs_suhI sat_suhL;
                                              };
                                    } in  : [x_suhD sat_suhM];
                                1# -> lvl31_suhH;
                              };
                    } in  $wxs_suhI y_suhF;
              };
        };

GHC.List.$witerate' [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> a) -> a -> (# a, [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_suhN w1_suhO]
        case w_suhN w1_suhO of x'_suhP {
          __DEFAULT ->
              let {
                sat_suhT [Occ=Once] :: [a_stJT]
                [LclId] =
                    [w_suhN x'_suhP] \u []
                        case GHC.List.$witerate' w_suhN x'_suhP of {
                          (#,#) ww1_suhR [Occ=Once] ww2_suhS [Occ=Once] ->
                              : [ww1_suhR ww2_suhS];
                        };
              } in  (#,#) [w1_suhO sat_suhT];
        };

GHC.List.iterate'FB [InlPrag=INLINE[0] (sat-args=3),
                     Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> (a -> a) -> a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><C(S),C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [c_suhU f_suhV x0_suhW]
        let {
          go2_suhX [Occ=LoopBreaker] :: a_assB -> b_assC
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [c_suhU f_suhV go2_suhX] \r [x_suhY]
                  case f_suhV x_suhY of x'_suhZ {
                    __DEFAULT ->
                        let {
                          sat_sui0 [Occ=Once] :: b_assC
                          [LclId] =
                              [go2_suhX x'_suhZ] \u [] go2_suhX x'_suhZ;
                        } in  c_suhU x_suhY sat_sui0;
                  };
        } in  go2_suhX x0_suhW;
GHC.List.iterate' [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker!]
  :: forall a. (a -> a) -> a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U)><L,U>m2,
 Unf=OtherCon []] =
    [] \r [w_sui1 w1_sui2]
        case GHC.List.$witerate' w_sui1 w1_sui2 of {
          (#,#) ww1_sui4 [Occ=Once] ww2_sui5 [Occ=Once] ->
              : [ww1_sui4 ww2_sui5];
        };

GHC.List.$witerate [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> a) -> a -> (# a, [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sui6 w1_sui7]
        let {
          sat_suic [Occ=Once] :: [a_stJL]
          [LclId] =
              [w_sui6 w1_sui7] \u []
                  let {
                    sat_sui8 [Occ=Once] :: a_stJL
                    [LclId] =
                        [w_sui6 w1_sui7] \u [] w_sui6 w1_sui7;
                  } in 
                    case GHC.List.$witerate w_sui6 sat_sui8 of {
                      (#,#) ww1_suia [Occ=Once] ww2_suib [Occ=Once] ->
                          : [ww1_suia ww2_suib];
                    };
        } in  (#,#) [w1_sui7 sat_suic];

GHC.List.iterateFB [InlPrag=INLINE[0] (sat-args=3),
                    Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> (a -> a) -> a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [c_suid f_suie x0_suif]
        let {
          go2_suig [Occ=LoopBreaker] :: a_astf -> b_astg
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [c_suid f_suie go2_suig] \r [x_suih]
                  let {
                    sat_suij [Occ=Once] :: b_astg
                    [LclId] =
                        [f_suie go2_suig x_suih] \u []
                            let {
                              sat_suii [Occ=Once] :: a_astf
                              [LclId] =
                                  [f_suie x_suih] \u [] f_suie x_suih;
                            } in  go2_suig sat_suii;
                  } in  c_suid x_suih sat_suij;
        } in  go2_suig x0_suif;
GHC.List.iterate [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker!]
  :: forall a. (a -> a) -> a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U>m2,
 Unf=OtherCon []] =
    [] \r [w_suik w1_suil]
        case GHC.List.$witerate w_suik w1_suil of {
          (#,#) ww1_suin [Occ=Once] ww2_suio [Occ=Once] ->
              : [ww1_suin ww2_suio];
        };

lvl27_ru9o :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC/List.hs:411:34-55|qs@(q : _)"#;

lvl28_ru9p :: forall a. ([a], a)
[GblId, Str=x] =
    [] \u [] Control.Exception.Base.patError lvl27_ru9o;

GHC.List.scanr1 [Occ=LoopBreaker]
  :: forall a. (a -> a -> a) -> [a] -> [a]
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []] =
    [] \r [ds_suip ds1_suiq]
        case ds1_suiq of {
          [] -> [] [];
          : x_suis [Occ=Once*] ds2_suit [Occ=Once!] ->
              case ds2_suit of wild1_suiu {
                [] -> : [x_suis GHC.Types.[]];
                : _ [Occ=Dead] _ [Occ=Dead] ->
                    let {
                      ds3_suix [Dmd=<L,U(1*U,1*U)>] :: ([a_astA], a_astA)
                      [LclId] =
                          [ds_suip wild1_suiu] \u []
                              case GHC.List.scanr1 ds_suip wild1_suiu of wild2_suiy {
                                [] -> lvl28_ru9p;
                                : q_suiz [Occ=Once] _ [Occ=Dead] -> (,) [wild2_suiy q_suiz];
                              }; } in
                    let {
                      sat_suiJ [Occ=Once] :: [a_astA]
                      [LclId] =
                          [ds3_suix] \u []
                              case ds3_suix of {
                                (,) qs_suiH [Occ=Once] _ [Occ=Dead] -> qs_suiH;
                              }; } in
                    let {
                      sat_suiF [Occ=Once] :: a_astA
                      [LclId] =
                          [ds_suip x_suis ds3_suix] \u []
                              let {
                                sat_suiE [Occ=Once] :: a_astA
                                [LclId] =
                                    [ds3_suix] \u []
                                        case ds3_suix of {
                                          (,) _ [Occ=Dead] q_suiD [Occ=Once] -> q_suiD;
                                        };
                              } in  ds_suip x_suis sat_suiE;
                    } in  : [sat_suiF sat_suiJ];
              };
        };

GHC.List.scanrFB [InlPrag=INLINE[0] (sat-args=2)]
  :: forall a b c.
     (a -> b -> b) -> (b -> c -> c) -> a -> (b, c) -> (b, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_suiK c1_suiL x_suiM ds_suiN]
        case ds_suiN of {
          (,) r_suiP est_suiQ [Occ=Once] ->
              let {
                sat_suiS [Occ=Once] :: c_astR
                [LclId] =
                    [c1_suiL r_suiP est_suiQ] \u [] c1_suiL r_suiP est_suiQ; } in
              let {
                sat_suiR [Occ=Once] :: b_astQ
                [LclId] =
                    [f_suiK x_suiM r_suiP] \u [] f_suiK x_suiM r_suiP;
              } in  (,) [sat_suiR sat_suiS];
        };

GHC.List.$wscanr [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a b. (a -> b -> b) -> b -> [a] -> (# b, [b] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_suiT w1_suiU w2_suiV]
        case w2_suiV of {
          [] -> (#,#) [w1_suiU GHC.Types.[]];
          : x_suiX [Occ=Once] xs_suiY [Occ=Once] ->
              let {
                ds_suiZ [Dmd=<L,U(1*U,1*U)>] :: ([b_stJz], b_stJz)
                [LclId] =
                    [w_suiT w1_suiU xs_suiY] \u []
                        case GHC.List.$wscanr w_suiT w1_suiU xs_suiY of {
                          (#,#) ww1_suj1 ww2_suj2 [Occ=Once] ->
                              let {
                                sat_suj3 [Occ=Once] :: [b_stJz]
                                [LclId] =
                                    CCCS :! [ww1_suj1 ww2_suj2];
                              } in  (,) [sat_suj3 ww1_suj1];
                        }; } in
              let {
                sat_sujc [Occ=Once] :: [b_stJz]
                [LclId] =
                    [ds_suiZ] \u []
                        case ds_suiZ of {
                          (,) qs_suja [Occ=Once] _ [Occ=Dead] -> qs_suja;
                        }; } in
              let {
                sat_suj8 [Occ=Once] :: b_stJz
                [LclId] =
                    [w_suiT x_suiX ds_suiZ] \u []
                        let {
                          sat_suj7 [Occ=Once] :: b_stJz
                          [LclId] =
                              [ds_suiZ] \u []
                                  case ds_suiZ of { (,) _ [Occ=Dead] q_suj6 [Occ=Once] -> q_suj6; };
                        } in  w_suiT x_suiX sat_suj7;
              } in  (#,#) [sat_suj8 sat_sujc];
        };

GHC.List.strictUncurryScanr [InlPrag=INLINE[0] (sat-args=2),
                             Occ=LoopBreaker!]
  :: forall a b c. (a -> b -> c) -> (a, b) -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sujd pair_suje]
        case pair_suje of {
          (,) x_sujg [Occ=Once] y_sujh [Occ=Once] -> f_sujd x_sujg y_sujh;
        };
GHC.List.scanr [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> b -> [a] -> [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>m2,
 Unf=OtherCon []] =
    [] \r [w_suji w1_sujj w2_sujk]
        case GHC.List.$wscanr w_suji w1_sujj w2_sujk of {
          (#,#) ww1_sujm [Occ=Once] ww2_sujn [Occ=Once] ->
              : [ww1_sujm ww2_sujn];
        };

GHC.List.flipSeqScanl' [InlPrag=INLINE[0] (sat-args=2)]
  :: forall a b. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_sujo _b_sujp] case _b_sujp of { __DEFAULT -> a1_sujo; };

GHC.List.scanlFB' [InlPrag=INLINE[0] (sat-args=2)]
  :: forall b a c.
     (b -> a -> b) -> (b -> c -> c) -> a -> (b -> c) -> b -> c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sujr c1_sujs b1_sujt g_suju v_sujv]
        case f_sujr v_sujv b1_sujt of b'_sujw {
          __DEFAULT ->
              let {
                sat_sujx [Occ=Once] :: c_asuE
                [LclId] =
                    [g_suju b'_sujw] \u [] g_suju b'_sujw;
              } in  c1_sujs b'_sujw sat_sujx;
        };

GHC.List.$wscanlGo' [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall b1 a1 b2 a2.
     (b2 -> a2 -> b2) -> b2 -> [a2] -> (# b2, [b2] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sujy w1_sujz w2_sujA]
        case w1_sujz of q_sujB {
          __DEFAULT ->
              let {
                sat_sujJ [Occ=Once] :: [b1_stJp]
                [LclId] =
                    [w_sujy w2_sujA q_sujB] \u []
                        case w2_sujA of {
                          [] -> [] [];
                          : x_sujD [Occ=Once] xs_sujE [Occ=Once] ->
                              case w_sujy q_sujB x_sujD of sat_sujF {
                                __DEFAULT ->
                                    case GHC.List.$wscanlGo' w_sujy sat_sujF xs_sujE of {
                                      (#,#) ww1_sujH [Occ=Once] ww2_sujI [Occ=Once] ->
                                          : [ww1_sujH ww2_sujI];
                                    };
                              };
                        };
              } in  (#,#) [q_sujB sat_sujJ];
        };

GHC.List.scanl'_scanlGo' [InlPrag=NOUSERINLINE[0]]
  :: forall b1 a1 b2 a2. (b2 -> a2 -> b2) -> b2 -> [a2] -> [b2]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,1*U>m2,
 Unf=OtherCon []] =
    [] \r [w_sujK w1_sujL w2_sujM]
        case GHC.List.$wscanlGo' w_sujK w1_sujL w2_sujM of {
          (#,#) ww1_sujO [Occ=Once] ww2_sujP [Occ=Once] ->
              : [ww1_sujO ww2_sujP];
        };

GHC.List.scanl' [InlPrag=NOINLINE[1]]
  :: forall b a. (b -> a -> b) -> b -> [a] -> [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,1*U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.List.scanl'_scanlGo' eta_B3 eta_B2 eta_B1;

GHC.List.constScanl [InlPrag=INLINE[0] (sat-args=0)]
  :: forall a b. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.const eta_B2 eta_B1;

GHC.List.scanlFB [InlPrag=INLINE[0] (sat-args=2)]
  :: forall b a c.
     (b -> a -> b) -> (b -> c -> c) -> a -> (b -> c) -> b -> c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sujQ c1_sujR b1_sujS g_sujT v_sujU]
        let {
          b'_sujV :: b_asvy
          [LclId] =
              [f_sujQ b1_sujS v_sujU] \u [] f_sujQ v_sujU b1_sujS; } in
        let {
          sat_sujW [Occ=Once] :: c_asvA
          [LclId] =
              [g_sujT b'_sujV] \u [] g_sujT b'_sujV;
        } in  c1_sujR b'_sujV sat_sujW;

GHC.List.$wscanlGo [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall b1 a1 b2 a2.
     (b2 -> a2 -> b2) -> b2 -> [a2] -> (# b2, [b2] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sujX w1_sujY w2_sujZ]
        let {
          sat_suk7 [Occ=Once] :: [b1_stJe]
          [LclId] =
              [w_sujX w1_sujY w2_sujZ] \u []
                  case w2_sujZ of {
                    [] -> [] [];
                    : x_suk1 [Occ=Once] xs_suk2 [Occ=Once] ->
                        let {
                          sat_suk3 [Occ=Once] :: b1_stJe
                          [LclId] =
                              [w_sujX w1_sujY x_suk1] \u [] w_sujX w1_sujY x_suk1;
                        } in 
                          case GHC.List.$wscanlGo w_sujX sat_suk3 xs_suk2 of {
                            (#,#) ww1_suk5 [Occ=Once] ww2_suk6 [Occ=Once] ->
                                : [ww1_suk5 ww2_suk6];
                          };
                  };
        } in  (#,#) [w1_sujY sat_suk7];

GHC.List.scanl_scanlGo [InlPrag=NOUSERINLINE[0]]
  :: forall b1 a1 b2 a2. (b2 -> a2 -> b2) -> b2 -> [a2] -> [b2]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,1*U>m2,
 Unf=OtherCon []] =
    [] \r [w_suk8 w1_suk9 w2_suka]
        case GHC.List.$wscanlGo w_suk8 w1_suk9 w2_suka of {
          (#,#) ww1_sukc [Occ=Once] ww2_sukd [Occ=Once] ->
              : [ww1_sukc ww2_sukd];
        };

GHC.List.scanl [InlPrag=NOINLINE[1]]
  :: forall b a. (b -> a -> b) -> b -> [a] -> [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,1*U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.List.scanl_scanlGo eta_B3 eta_B2 eta_B1;

GHC.List.scanl1 :: forall a. (a -> a -> a) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_suke ds_sukf]
        case ds_sukf of {
          [] -> [] [];
          : x_sukh xs_suki [Occ=Once] ->
              let {
                sat_sukm [Occ=Once] :: [a_aswp]
                [LclId] =
                    [f_suke x_sukh xs_suki] \u []
                        case GHC.List.$wscanlGo f_suke x_sukh xs_suki of {
                          (#,#) _ [Occ=Dead] ww2_sukl [Occ=Once] -> ww2_sukl;
                        };
              } in  : [x_sukh sat_sukm];
        };

GHC.List.foldl' [InlPrag=INLINE (sat-args=3)]
  :: forall a b. (b -> a -> b) -> b -> [a] -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [k_sukn z0_suko xs_sukp]
        let-no-escape {
          go2_sukq [Occ=LoopBreakerT[2]] :: [a_aswt] -> b_aswu -> b_aswu
          [LclId[JoinId(2)], Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
              sat-only [k_sukn go2_sukq] \r [ds_sukr eta_suks]
                  case ds_sukr of {
                    [] -> eta_suks;
                    : y_suku [Occ=Once] ys_sukv [Occ=Once] ->
                        case eta_suks of z_sukw {
                          __DEFAULT ->
                              case k_sukn z_sukw y_suku of sat_sukx {
                                __DEFAULT -> go2_sukq ys_sukv sat_sukx;
                              };
                        };
                  };
        } in  go2_sukq xs_sukp z0_suko;

GHC.List.foldl1' :: forall a. (a -> a -> a) -> [a] -> a
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []] =
    [] \r [f_suky ds_sukz]
        case ds_sukz of {
          [] -> GHC.List.foldl1'1;
          : x_sukB [Occ=Once] xs_sukC [Occ=Once] ->
              GHC.List.foldl' f_suky x_sukB xs_sukC;
        };

sat_sukD :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_sukE :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sukD GHC.Types.[]];

lvl29_ru9q :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sukE;

lvl30_ru9r :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

GHC.List.foldl [InlPrag=INLINE (sat-args=3)]
  :: forall a b. (b -> a -> b) -> b -> [a] -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [k_sukF z0_sukG xs_sukH]
        let-no-escape {
          go2_sukI [Occ=LoopBreakerT[2]] :: [a_asx1] -> b_asx2 -> b_asx2
          [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
              sat-only [k_sukF go2_sukI] \r [ds_sukJ eta_sukK]
                  case ds_sukJ of {
                    [] -> eta_sukK;
                    : y_sukM [Occ=Once] ys_sukN [Occ=Once] ->
                        let {
                          sat_sukO [Occ=Once] :: b_asx2
                          [LclId] =
                              [k_sukF eta_sukK y_sukM] \u [] k_sukF eta_sukK y_sukM;
                        } in  go2_sukI ys_sukN sat_sukO;
                  };
        } in  go2_sukI xs_sukH z0_sukG;

GHC.List.sum [InlPrag=INLINE (sat-args=0)]
  :: forall a. GHC.Num.Num a => [a] -> a
[GblId,
 Arity=1,
 Str=<L,U(1*C(C1(U)),A,A,A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_sukP]
        let {
          sat_sukR [Occ=Once] :: a_asyo
          [LclId] =
              [$dNum_sukP] \u [] GHC.Num.fromInteger $dNum_sukP lvl30_ru9r; } in
        let {
          sat_sukQ [Occ=Once] :: a_asyo -> a_asyo -> a_asyo
          [LclId] =
              [$dNum_sukP] \u [] GHC.Num.+ $dNum_sukP;
        } in  GHC.List.foldl sat_sukQ sat_sukR;

GHC.List.product [InlPrag=INLINE (sat-args=0)]
  :: forall a. GHC.Num.Num a => [a] -> a
[GblId,
 Arity=1,
 Str=<L,U(A,A,1*C(C1(U)),A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_sukS]
        let {
          sat_sukU [Occ=Once] :: a_asyy
          [LclId] =
              [$dNum_sukS] \u [] GHC.Num.fromInteger $dNum_sukS lvl29_ru9q; } in
        let {
          sat_sukT [Occ=Once] :: a_asyy -> a_asyy -> a_asyy
          [LclId] =
              [$dNum_sukS] \u [] GHC.Num.* $dNum_sukS;
        } in  GHC.List.foldl sat_sukT sat_sukU;

GHC.List.foldl1 :: forall a. (a -> a -> a) -> [a] -> a
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []] =
    [] \r [f_sukV ds_sukW]
        case ds_sukW of {
          [] -> GHC.List.foldl2;
          : x_sukY [Occ=Once] xs_sukZ [Occ=Once] ->
              GHC.List.foldl f_sukV x_sukY xs_sukZ;
        };

GHC.List.filterFB [InlPrag=INLINE[0] (sat-args=4),
                   Occ=LoopBreaker!]
  :: forall a b.
     (a -> b -> b) -> (a -> GHC.Types.Bool) -> a -> b -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S),1*C1(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [c_sul0 p_sul1 x_sul2 r_sul3]
        case p_sul1 x_sul2 of {
          GHC.Types.False -> r_sul3;
          GHC.Types.True -> c_sul0 x_sul2 r_sul3;
        };

GHC.List.filter [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [_pred_sul5 ds_sul6]
        case ds_sul6 of {
          [] -> [] [];
          : x_sul8 xs_sul9 [Occ=Once*] ->
              case _pred_sul5 x_sul8 of {
                GHC.Types.False -> GHC.List.filter _pred_sul5 xs_sul9;
                GHC.Types.True ->
                    let {
                      sat_sulb [Occ=Once] :: [a_asyL]
                      [LclId] =
                          [_pred_sul5 xs_sul9] \u [] GHC.List.filter _pred_sul5 xs_sul9;
                    } in  : [x_sul8 sat_sulb];
              };
        };

GHC.List.idLength [InlPrag=INLINE[0] (sat-args=0)]
  :: GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Base.id eta_B1;

GHC.List.lengthFB [InlPrag=INLINE[0] (sat-args=2)]
  :: forall x.
     x
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [eta_sulc eta1_suld a_sule]
        case a_sule of {
          GHC.Types.I# ipv_sulg [Occ=Once] ->
              case +# [ipv_sulg 1#] of sat_sulh {
                __DEFAULT ->
                    let {
                      sat_suli [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [sat_sulh];
                    } in  eta1_suld sat_suli;
              };
        };

GHC.List.$wlenAcc [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. [a] -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sulj ww_sulk]
        case w_sulj of {
          [] -> ww_sulk;
          : _ [Occ=Dead] ys_suln [Occ=Once] ->
              case +# [ww_sulk 1#] of sat_sulo {
                __DEFAULT -> GHC.List.$wlenAcc ys_suln sat_sulo;
              };
        };

GHC.List.lenAcc [InlPrag=NOUSERINLINE[0]]
  :: forall a. [a] -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [w_sulp w1_sulq]
        case w1_sulq of {
          GHC.Types.I# ww1_suls [Occ=Once] ->
              case GHC.List.$wlenAcc w_sulp ww1_suls of ww2_sult {
                __DEFAULT -> GHC.Types.I# [ww2_sult];
              };
        };

GHC.List.length [InlPrag=NOUSERINLINE[0]]
  :: forall a. [a] -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [w_sulu]
        case GHC.List.$wlenAcc w_sulu 0# of ww_sulv {
          __DEFAULT -> GHC.Types.I# [ww_sulv];
        };

GHC.List.null :: forall a. [a] -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sulw]
        case ds_sulw of {
          [] -> GHC.Types.True [];
          : _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
        };

GHC.List.uncons :: forall a. [a] -> GHC.Base.Maybe (a, [a])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sulA]
        case ds_sulA of {
          [] -> GHC.Base.Nothing [];
          : x_sulC [Occ=Once] xs_sulD [Occ=Once] ->
              let {
                sat_sulE [Occ=Once] :: (a_aszT, [a_aszT])
                [LclId] =
                    CCCS (,)! [x_sulC xs_sulD];
              } in  GHC.Base.Just [sat_sulE];
        };


==================== Pre unarise: ====================
2018-03-16 15:55:10.78029815 UTC

$wunsafeDrop_ru8P :: forall a. GHC.Prim.Int# -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    sat-only [] \r [ww_sxow w_sxox]
        case w_sxox of {
          [] -> [] [];
          : _ [Occ=Dead] ipv1_sxoA [Occ=Once*] ->
              case ww_sxow of ds_sxoB {
                __DEFAULT ->
                    case -# [ds_sxoB 1#] of sat_sxoC {
                      __DEFAULT -> $wunsafeDrop_ru8P sat_sxoC ipv1_sxoA;
                    };
                1# -> ipv1_sxoA;
              };
        };

GHC.List.drop [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Types.Int -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_sxoD eta1_sxoE]
        case eta_sxoD of {
          GHC.Types.I# x_sxoG ->
              case <=# [x_sxoG 0#] of {
                __DEFAULT -> $wunsafeDrop_ru8P x_sxoG eta1_sxoE;
                1# -> eta1_sxoE;
              };
        };

GHC.List.$wsplitAt' [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. GHC.Types.Int -> [a] -> (# [a], [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sxoI w1_sxoJ]
        case w1_sxoJ of {
          [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
          : ipv_sxoL [Occ=Once*] ipv1_sxoM [Occ=Once*] ->
              case w_sxoI of {
                GHC.Types.I# ds_sxoO [Occ=Once!] ->
                    case ds_sxoO of ds1_sxoP {
                      __DEFAULT ->
                          let {
                            ds2_sxoQ [Dmd=<L,U(1*U,1*U)>] :: ([a_stMO], [a_stMO])
                            [LclId] =
                                [ipv1_sxoM ds1_sxoP] \u []
                                    case -# [ds1_sxoP 1#] of sat_sxoR {
                                      __DEFAULT ->
                                          let {
                                            sat_sxoS [Occ=Once] :: GHC.Types.Int
                                            [LclId] =
                                                CCCS GHC.Types.I#! [sat_sxoR];
                                          } in 
                                            case GHC.List.$wsplitAt' sat_sxoS ipv1_sxoM of {
                                              (#,#) ww1_sxoU [Occ=Once] ww2_sxoV [Occ=Once] ->
                                                  (,) [ww1_sxoU ww2_sxoV];
                                            };
                                    }; } in
                          let {
                            sat_sxp4 [Occ=Once] :: [a_stMO]
                            [LclId] =
                                [ds2_sxoQ] \u []
                                    case ds2_sxoQ of {
                                      (,) _ [Occ=Dead] xs''_sxp3 [Occ=Once] -> xs''_sxp3;
                                    }; } in
                          let {
                            sat_sxoZ [Occ=Once] :: [a_stMO]
                            [LclId] =
                                [ds2_sxoQ] \u []
                                    case ds2_sxoQ of {
                                      (,) xs'_sxoX [Occ=Once] _ [Occ=Dead] -> xs'_sxoX;
                                    }; } in
                          let {
                            sat_sxp0 [Occ=Once] :: [a_stMO]
                            [LclId] =
                                CCCS :! [ipv_sxoL sat_sxoZ];
                          } in  (#,#) [sat_sxp0 sat_sxp4];
                      1# ->
                          let {
                            sat_sxp5 [Occ=Once] :: [a_stMO]
                            [LclId] =
                                CCCS :! [ipv_sxoL GHC.Types.[]];
                          } in  (#,#) [sat_sxp5 ipv1_sxoM];
                    };
              };
        };

GHC.List.splitAt_splitAt' [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Types.Int -> [a] -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U)><S,1*U>m,
 Unf=OtherCon []] =
    [] \r [w_sxp6 w1_sxp7]
        case GHC.List.$wsplitAt' w_sxp6 w1_sxp7 of {
          (#,#) ww1_sxp9 [Occ=Once] ww2_sxpa [Occ=Once] ->
              (,) [ww1_sxp9 ww2_sxpa];
        };

GHC.List.splitAt :: forall a. GHC.Types.Int -> [a] -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U>m,
 Unf=OtherCon []] =
    [] \r [n_sxpb ls_sxpc]
        case n_sxpb of wild_sxpd {
          GHC.Types.I# x_sxpe [Occ=Once] ->
              case <=# [x_sxpe 0#] of {
                __DEFAULT ->
                    case GHC.List.$wsplitAt' wild_sxpd ls_sxpc of {
                      (#,#) ww1_sxph [Occ=Once] ww2_sxpi [Occ=Once] ->
                          (,) [ww1_sxph ww2_sxpi];
                    };
                1# -> (,) [GHC.Types.[] ls_sxpc];
              };
        };

GHC.List.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.List.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.List.$trModule4];

GHC.List.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.List"#;

GHC.List.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.List.$trModule2];

GHC.List.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.List.$trModule3
                                     GHC.List.$trModule1];

GHC.List.init1 [Occ=LoopBreaker] :: forall a. a -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sxpj ds1_sxpk]
        case ds1_sxpk of {
          [] -> [] [];
          : z_sxpm [Occ=Once] zs_sxpn [Occ=Once] ->
              let {
                sat_sxpo [Occ=Once] :: [a_aszc]
                [LclId] =
                    [z_sxpm zs_sxpn] \u [] GHC.List.init1 z_sxpm zs_sxpn;
              } in  : [ds_sxpj sat_sxpo];
        };

lvl_ru8Q :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ": empty list"#;

lvl1_ru8R :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl_ru8Q;

GHC.List.!!4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Prelude."#;

GHC.List.prel_list_str :: GHC.Base.String
[GblId] =
    [] \u [] GHC.CString.unpackCString# GHC.List.!!4;

GHC.List.errorEmptyList :: forall a. GHC.Base.String -> a
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []] =
    [] \r [fun_sxpp]
        let {
          sat_sxpq [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [fun_sxpp] \s [] GHC.Base.++ fun_sxpp lvl1_ru8R;
        } in 
          case GHC.Base.++ GHC.List.prel_list_str sat_sxpq of sat_sxpr {
            __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sxpr;
          };

lvl2_ru8S :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "!!: negative index"#;

lvl3_ru8T :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl2_ru8S;

GHC.List.negIndex :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.Base.++ GHC.List.prel_list_str lvl3_ru8T of sat_sxps {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sxps;
        };

GHC.List.!!3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "!!: index too large"#;

GHC.List.!!2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# GHC.List.!!3;

GHC.List.!!1 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.Base.++ GHC.List.prel_list_str GHC.List.!!2;

GHC.List.tooLarge :: forall a. GHC.Types.Int -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [ds_sxpt] GHC.Err.errorWithoutStackTrace GHC.List.!!1;

poly_exit_ru8U :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace GHC.List.!!1;

poly_$wgo_ru8V :: forall a. [a] -> GHC.Prim.Int# -> a
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [w_sxpu ww_sxpv]
        case w_sxpu of {
          [] -> poly_exit_ru8U;
          : y_sxpx [Occ=Once] ys_sxpy [Occ=Once] ->
              case ww_sxpv of ds_sxpz {
                __DEFAULT ->
                    case -# [ds_sxpz 1#] of sat_sxpA {
                      __DEFAULT -> poly_$wgo_ru8V ys_sxpy sat_sxpA;
                    };
                0# -> y_sxpx;
              };
        };

GHC.List.$w!! [InlPrag=INLINABLE[0]]
  :: forall a. [a] -> GHC.Prim.Int# -> a
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [w_sxpB ww_sxpC]
        case <# [ww_sxpC 0#] of {
          __DEFAULT -> poly_$wgo_ru8V w_sxpB ww_sxpC;
          1# -> GHC.List.negIndex;
        };

GHC.List.!! [InlPrag=NOUSERINLINE[0]]
  :: forall a. [a] -> GHC.Types.Int -> a
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [w_sxpE w1_sxpF]
        case w1_sxpF of {
          GHC.Types.I# ww1_sxpH [Occ=Once] -> GHC.List.$w!! w_sxpE ww1_sxpH;
        };

lvl4_ru8W :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "cycle"#;

lvl5_ru8X :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl4_ru8W;

GHC.List.cycle1 :: forall a. [a]
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl5_ru8X;

GHC.List.cycle :: forall a. [a] -> [a]
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxpI]
        case ds_sxpI of wild_sxpJ {
          [] -> GHC.List.cycle1;
          : _ [Occ=Dead] _ [Occ=Dead] ->
              let {
                xs'_sxpM [Occ=LoopBreaker] :: [a_ass8]
                [LclId] =
                    [wild_sxpJ xs'_sxpM] \u [] GHC.Base.++ wild_sxpJ xs'_sxpM;
              } in  xs'_sxpM;
        };

lvl6_ru8Y :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1"#;

lvl7_ru8Z :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl6_ru8Y;

lvl8_ru90 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl7_ru8Z;

GHC.List.foldr1 [InlPrag=INLINE[0] (sat-args=1)]
  :: forall a. (a -> a -> a) -> [a] -> a
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []] =
    [] \r [f_sxpN eta_sxpO]
        let {
          go2_sxpP [Occ=LoopBreaker] :: [a_asug] -> a_asug
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [f_sxpN go2_sxpP] \r [ds_sxpQ]
                  case ds_sxpQ of {
                    [] -> lvl8_ru90;
                    : x_sxpS [Occ=Once*] ds1_sxpT [Occ=Once!] ->
                        case ds1_sxpT of wild1_sxpU {
                          [] -> x_sxpS;
                          : _ [Occ=Dead] _ [Occ=Dead] ->
                              let {
                                sat_sxpX [Occ=Once] :: a_asug
                                [LclId] =
                                    [go2_sxpP wild1_sxpU] \u [] go2_sxpP wild1_sxpU;
                              } in  f_sxpN x_sxpS sat_sxpX;
                        };
                  };
        } in  go2_sxpP eta_sxpO;

lvl9_ru91 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "init"#;

lvl10_ru92 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl9_ru91;

GHC.List.init2 :: forall a. [a]
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl10_ru92;

GHC.List.init :: forall a. [a] -> [a]
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxpY]
        case ds_sxpY of {
          [] -> GHC.List.init2;
          : x_sxq0 [Occ=Once] xs_sxq1 [Occ=Once] ->
              GHC.List.init1 x_sxq0 xs_sxq1;
        };

lvl11_ru93 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "last"#;

lvl12_ru94 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl11_ru93;

GHC.List.lastError :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl12_ru94;

poly_go_ru95 :: forall a. [a] -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    sat-only [] \r [ds_sxq2 eta_sxq3]
        case ds_sxq2 of {
          [] -> eta_sxq3;
          : y_sxq5 [Occ=Once] ys_sxq6 [Occ=Once] ->
              poly_go_ru95 ys_sxq6 y_sxq5;
        };

GHC.List.last [InlPrag=INLINE (sat-args=1)] :: forall a. [a] -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [xs_sxq7] poly_go_ru95 xs_sxq7 GHC.List.lastError;

lvl13_ru96 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "tail"#;

lvl14_ru97 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl13_ru96;

GHC.List.scanl2 :: forall a. [a]
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl14_ru97;

GHC.List.tail :: forall a. [a] -> [a]
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxq8]
        case ds_sxq8 of {
          [] -> GHC.List.scanl2;
          : _ [Occ=Dead] xs_sxqb [Occ=Once] -> xs_sxqb;
        };

lvl15_ru98 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "head"#;

lvl16_ru99 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl15_ru98;

GHC.List.badHead :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl16_ru99;

GHC.List.head [InlPrag=NOINLINE[1], Occ=LoopBreaker!]
  :: forall a. [a] -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxqc]
        case ds_sxqc of {
          [] -> GHC.List.badHead;
          : x_sxqe [Occ=Once] _ [Occ=Dead] -> x_sxqe;
        };

lvl17_ru9a :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum"#;

lvl18_ru9b :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl17_ru9a;

GHC.List.maximum1 :: GHC.Integer.Type.Integer
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl18_ru9b;

GHC.List.maximum2 :: GHC.Types.Int
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl18_ru9b;

lvl19_ru9c :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl18_ru9b;

GHC.List.maximum_go [Occ=LoopBreaker]
  :: [GHC.Integer.Type.Integer]
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [ds_sxqg eta_sxqh]
        case ds_sxqg of {
          [] -> eta_sxqh;
          : y_sxqj ys_sxqk [Occ=Once*] ->
              case GHC.Integer.Type.leInteger# eta_sxqh y_sxqj of {
                __DEFAULT -> GHC.List.maximum_go ys_sxqk eta_sxqh;
                1# -> GHC.List.maximum_go ys_sxqk y_sxqj;
              };
        };

GHC.List.maximum_$smaximum [InlPrag=INLINABLE]
  :: [GHC.Integer.Type.Integer] -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxqm]
        case ds_sxqm of {
          [] -> GHC.List.maximum1;
          : ipv_sxqo [Occ=Once] ipv1_sxqp [Occ=Once] ->
              GHC.List.maximum_go ipv1_sxqp ipv_sxqo;
        };

lvl20_ru9d :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum"#;

lvl21_ru9e :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl20_ru9d;

GHC.List.minimum1 :: GHC.Integer.Type.Integer
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl21_ru9e;

GHC.List.minimum2 :: GHC.Types.Int
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl21_ru9e;

lvl22_ru9f :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl21_ru9e;

GHC.List.minimum_go [Occ=LoopBreaker]
  :: [GHC.Integer.Type.Integer]
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [ds_sxqq eta_sxqr]
        case ds_sxqq of {
          [] -> eta_sxqr;
          : y_sxqt ys_sxqu [Occ=Once*] ->
              case GHC.Integer.Type.leInteger# eta_sxqr y_sxqt of {
                __DEFAULT -> GHC.List.minimum_go ys_sxqu y_sxqt;
                1# -> GHC.List.minimum_go ys_sxqu eta_sxqr;
              };
        };

GHC.List.minimum_$sminimum [InlPrag=INLINABLE]
  :: [GHC.Integer.Type.Integer] -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxqw]
        case ds_sxqw of {
          [] -> GHC.List.minimum1;
          : ipv_sxqy [Occ=Once] ipv1_sxqz [Occ=Once] ->
              GHC.List.minimum_go ipv1_sxqz ipv_sxqy;
        };

GHC.List.$wgo [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: [GHC.Types.Int] -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sxqA ww_sxqB]
        case w_sxqA of {
          [] -> ww_sxqB;
          : y_sxqD [Occ=Once!] ys_sxqE [Occ=Once*] ->
              case y_sxqD of {
                GHC.Types.I# y1_sxqG ->
                    case <=# [ww_sxqB y1_sxqG] of {
                      __DEFAULT -> GHC.List.$wgo ys_sxqE ww_sxqB;
                      1# -> GHC.List.$wgo ys_sxqE y1_sxqG;
                    };
              };
        };

GHC.List.maximum_$smaximum1 [InlPrag=NOUSERINLINE[0]]
  :: [GHC.Types.Int] -> GHC.Types.Int
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [w_sxqI]
        case w_sxqI of {
          [] -> GHC.List.maximum2;
          : ipv_sxqK [Occ=Once!] ipv1_sxqL [Occ=Once] ->
              case ipv_sxqK of {
                GHC.Types.I# ww1_sxqN [Occ=Once] ->
                    case GHC.List.$wgo ipv1_sxqL ww1_sxqN of ww2_sxqO {
                      __DEFAULT -> GHC.Types.I# [ww2_sxqO];
                    };
              };
        };

GHC.List.maximum [InlPrag=INLINABLE]
  :: forall a. GHC.Classes.Ord a => [a] -> a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,A,A,A,C(C1(U)),A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sxqP ds_sxqQ]
        case ds_sxqQ of {
          [] -> lvl19_ru9c;
          : ipv_sxqS [Occ=Once] ipv1_sxqT [Occ=Once] ->
              let-no-escape {
                go2_sxqU [Occ=LoopBreakerT[2]] :: [a_asxy] -> a_asxy -> a_asxy
                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
                    sat-only [$dOrd_sxqP go2_sxqU] \r [ds1_sxqV eta_sxqW]
                        case ds1_sxqV of {
                          [] -> eta_sxqW;
                          : y_sxqY [Occ=Once] ys_sxqZ [Occ=Once] ->
                              let {
                                sat_sxr0 [Occ=Once] :: a_asxy
                                [LclId] =
                                    [$dOrd_sxqP eta_sxqW y_sxqY] \u []
                                        GHC.Classes.max $dOrd_sxqP eta_sxqW y_sxqY;
                              } in  go2_sxqU ys_sxqZ sat_sxr0;
                        };
              } in  go2_sxqU ipv1_sxqT ipv_sxqS;
        };

GHC.List.$wgo1 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: [GHC.Types.Int] -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sxr1 ww_sxr2]
        case w_sxr1 of {
          [] -> ww_sxr2;
          : y_sxr4 [Occ=Once!] ys_sxr5 [Occ=Once*] ->
              case y_sxr4 of {
                GHC.Types.I# y1_sxr7 ->
                    case <=# [ww_sxr2 y1_sxr7] of {
                      __DEFAULT -> GHC.List.$wgo1 ys_sxr5 y1_sxr7;
                      1# -> GHC.List.$wgo1 ys_sxr5 ww_sxr2;
                    };
              };
        };

GHC.List.minimum_$sminimum1 [InlPrag=NOUSERINLINE[0]]
  :: [GHC.Types.Int] -> GHC.Types.Int
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [w_sxr9]
        case w_sxr9 of {
          [] -> GHC.List.minimum2;
          : ipv_sxrb [Occ=Once!] ipv1_sxrc [Occ=Once] ->
              case ipv_sxrb of {
                GHC.Types.I# ww1_sxre [Occ=Once] ->
                    case GHC.List.$wgo1 ipv1_sxrc ww1_sxre of ww2_sxrf {
                      __DEFAULT -> GHC.Types.I# [ww2_sxrf];
                    };
              };
        };

GHC.List.minimum [InlPrag=INLINABLE]
  :: forall a. GHC.Classes.Ord a => [a] -> a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,A,A,A,A,C(C1(U)))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sxrg ds_sxrh]
        case ds_sxrh of {
          [] -> lvl22_ru9f;
          : ipv_sxrj [Occ=Once] ipv1_sxrk [Occ=Once] ->
              let-no-escape {
                go2_sxrl [Occ=LoopBreakerT[2]] :: [a_asxY] -> a_asxY -> a_asxY
                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
                    sat-only [$dOrd_sxrg go2_sxrl] \r [ds1_sxrm eta_sxrn]
                        case ds1_sxrm of {
                          [] -> eta_sxrn;
                          : y_sxrp [Occ=Once] ys_sxrq [Occ=Once] ->
                              let {
                                sat_sxrr [Occ=Once] :: a_asxY
                                [LclId] =
                                    [$dOrd_sxrg eta_sxrn y_sxrp] \u []
                                        GHC.Classes.min $dOrd_sxrg eta_sxrn y_sxrp;
                              } in  go2_sxrl ys_sxrq sat_sxrr;
                        };
              } in  go2_sxrl ipv1_sxrk ipv_sxrj;
        };

lvl23_ru9g :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1'"#;

lvl24_ru9h :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl23_ru9g;

GHC.List.foldl1'1 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl24_ru9h;

lvl25_ru9i :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1"#;

lvl26_ru9j :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl25_ru9i;

GHC.List.foldl2 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl26_ru9j;

$wgo2_ru9k :: forall a b c. [(a, b, c)] -> (# [a], [b], [c] #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [w_sxrs]
        case w_sxrs of {
          [] -> (#,,#) [GHC.Types.[] GHC.Types.[] GHC.Types.[]];
          : y_sxru [Occ=Once!] ys_sxrv [Occ=Once] ->
              case y_sxru of {
                (,,) a1_sxrx [Occ=Once] b1_sxry [Occ=Once] c1_sxrz [Occ=Once] ->
                    let {
                      ds_sxrA [Dmd=<L,U(1*U,1*U,1*U)>] :: ([a_stLF], [b_stLG], [c_stLH])
                      [LclId] =
                          [ys_sxrv] \u []
                              case $wgo2_ru9k ys_sxrv of {
                                (#,,#) ww1_sxrC [Occ=Once]
                                       ww2_sxrD [Occ=Once]
                                       ww3_sxrE [Occ=Once] ->
                                    (,,) [ww1_sxrC ww2_sxrD ww3_sxrE];
                              }; } in
                    let {
                      sat_sxrV [Occ=Once] :: [c_stLH]
                      [LclId] =
                          [ds_sxrA] \u []
                              case ds_sxrA of {
                                (,,) _ [Occ=Dead] _ [Occ=Dead] cs_sxrU [Occ=Once] -> cs_sxrU;
                              }; } in
                    let {
                      sat_sxrW [Occ=Once] :: [c_stLH]
                      [LclId] =
                          CCCS :! [c1_sxrz sat_sxrV]; } in
                    let {
                      sat_sxrP [Occ=Once] :: [b_stLG]
                      [LclId] =
                          [ds_sxrA] \u []
                              case ds_sxrA of {
                                (,,) _ [Occ=Dead] bs_sxrN [Occ=Once] _ [Occ=Dead] -> bs_sxrN;
                              }; } in
                    let {
                      sat_sxrQ [Occ=Once] :: [b_stLG]
                      [LclId] =
                          CCCS :! [b1_sxry sat_sxrP]; } in
                    let {
                      sat_sxrJ [Occ=Once] :: [a_stLF]
                      [LclId] =
                          [ds_sxrA] \u []
                              case ds_sxrA of {
                                (,,) as_sxrG [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> as_sxrG;
                              }; } in
                    let {
                      sat_sxrK [Occ=Once] :: [a_stLF]
                      [LclId] =
                          CCCS :! [a1_sxrx sat_sxrJ];
                    } in  (#,,#) [sat_sxrK sat_sxrQ sat_sxrW];
              };
        };

go_ru9l :: forall a b c. [(a, b, c)] -> ([a], [b], [c])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    sat-only [] \r [w_sxrX]
        case $wgo2_ru9k w_sxrX of {
          (#,,#) ww1_sxrZ [Occ=Once]
                 ww2_sxs0 [Occ=Once]
                 ww3_sxs1 [Occ=Once] ->
              (,,) [ww1_sxrZ ww2_sxs0 ww3_sxs1];
        };

GHC.List.unzip3 [InlPrag=INLINE (sat-args=0)]
  :: forall a b c. [(a, b, c)] -> ([a], [b], [c])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [eta_B1] go_ru9l eta_B1;

$wgo3_ru9m :: forall a b. [(a, b)] -> (# [a], [b] #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [w_sxs2]
        case w_sxs2 of {
          [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
          : y_sxs4 [Occ=Once!] ys_sxs5 [Occ=Once] ->
              case y_sxs4 of {
                (,) a1_sxs7 [Occ=Once] b1_sxs8 [Occ=Once] ->
                    let {
                      ds_sxs9 [Dmd=<L,U(1*U,1*U)>] :: ([a_stLy], [b_stLz])
                      [LclId] =
                          [ys_sxs5] \u []
                              case $wgo3_ru9m ys_sxs5 of {
                                (#,#) ww1_sxsb [Occ=Once] ww2_sxsc [Occ=Once] ->
                                    (,) [ww1_sxsb ww2_sxsc];
                              }; } in
                    let {
                      sat_sxsl [Occ=Once] :: [b_stLz]
                      [LclId] =
                          [ds_sxs9] \u []
                              case ds_sxs9 of {
                                (,) _ [Occ=Dead] bs_sxsk [Occ=Once] -> bs_sxsk;
                              }; } in
                    let {
                      sat_sxsm [Occ=Once] :: [b_stLz]
                      [LclId] =
                          CCCS :! [b1_sxs8 sat_sxsl]; } in
                    let {
                      sat_sxsg [Occ=Once] :: [a_stLy]
                      [LclId] =
                          [ds_sxs9] \u []
                              case ds_sxs9 of {
                                (,) as_sxse [Occ=Once] _ [Occ=Dead] -> as_sxse;
                              }; } in
                    let {
                      sat_sxsh [Occ=Once] :: [a_stLy]
                      [LclId] =
                          CCCS :! [a1_sxs7 sat_sxsg];
                    } in  (#,#) [sat_sxsh sat_sxsm];
              };
        };

go1_ru9n :: forall a b. [(a, b)] -> ([a], [b])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    sat-only [] \r [w_sxsn]
        case $wgo3_ru9m w_sxsn of {
          (#,#) ww1_sxsp [Occ=Once] ww2_sxsq [Occ=Once] ->
              (,) [ww1_sxsp ww2_sxsq];
        };

GHC.List.unzip [InlPrag=INLINE (sat-args=0)]
  :: forall a b. [(a, b)] -> ([a], [b])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [eta_B1] go1_ru9n eta_B1;

GHC.List.zipWith3
  :: forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><S,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [z_sxsr eta_sxss eta1_sxst eta2_sxsu]
        let {
          go2_sxsv [Occ=LoopBreaker]
            :: [a_asln] -> [b_aslo] -> [c_aslp] -> [d_aslq]
          [LclId, Arity=3, Str=<S,1*U><L,1*U><L,1*U>, Unf=OtherCon []] =
              sat-only [z_sxsr go2_sxsv] \r [ds_sxsw ds1_sxsx ds2_sxsy]
                  case ds_sxsw of {
                    [] -> [] [];
                    : a1_sxsA [Occ=Once] as_sxsB [Occ=Once] ->
                        case ds1_sxsx of {
                          [] -> [] [];
                          : b1_sxsD [Occ=Once] bs_sxsE [Occ=Once] ->
                              case ds2_sxsy of {
                                [] -> [] [];
                                : c1_sxsG [Occ=Once] cs_sxsH [Occ=Once] ->
                                    let {
                                      sat_sxsJ [Occ=Once] :: [d_aslq]
                                      [LclId] =
                                          [go2_sxsv as_sxsB bs_sxsE cs_sxsH] \u []
                                              go2_sxsv as_sxsB bs_sxsE cs_sxsH; } in
                                    let {
                                      sat_sxsI [Occ=Once] :: d_aslq
                                      [LclId] =
                                          [z_sxsr a1_sxsA b1_sxsD c1_sxsG] \u []
                                              z_sxsr a1_sxsA b1_sxsD c1_sxsG;
                                    } in  : [sat_sxsI sat_sxsJ];
                              };
                        };
                  };
        } in  go2_sxsv eta_sxss eta1_sxst eta2_sxsu;

GHC.List.zipWithFB [InlPrag=INLINE[0] (sat-args=2)]
  :: forall a b c d e.
     (a -> b -> c) -> (d -> e -> a) -> d -> e -> b -> c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [c1_sxsK f_sxsL x_sxsM y_sxsN r_sxsO]
        let {
          sat_sxsP [Occ=Once] :: a_aslZ
          [LclId] =
              [f_sxsL x_sxsM y_sxsN] \u [] f_sxsL x_sxsM y_sxsN;
        } in  c1_sxsK sat_sxsP r_sxsO;

GHC.List.zip3 [Occ=LoopBreaker]
  :: forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sxsQ ds1_sxsR ds2_sxsS]
        case ds_sxsQ of {
          [] -> [] [];
          : a1_sxsU [Occ=Once] as_sxsV [Occ=Once] ->
              case ds1_sxsR of {
                [] -> [] [];
                : b1_sxsX [Occ=Once] bs_sxsY [Occ=Once] ->
                    case ds2_sxsS of {
                      [] -> [] [];
                      : c1_sxt0 [Occ=Once] cs_sxt1 [Occ=Once] ->
                          let {
                            sat_sxt3 [Occ=Once] :: [(a_asmz, b_asmA, c_asmB)]
                            [LclId] =
                                [as_sxsV bs_sxsY cs_sxt1] \u []
                                    GHC.List.zip3 as_sxsV bs_sxsY cs_sxt1; } in
                          let {
                            sat_sxt2 [Occ=Once] :: (a_asmz, b_asmA, c_asmB)
                            [LclId] =
                                CCCS (,,)! [a1_sxsU b1_sxsX c1_sxt0];
                          } in  : [sat_sxt2 sat_sxt3];
                    };
              };
        };

GHC.List.zipFB [InlPrag=INLINE[0] (sat-args=1)]
  :: forall a b c d. ((a, b) -> c -> d) -> a -> b -> c -> d
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [c1_sxt4 x_sxt5 y_sxt6 r_sxt7]
        let {
          sat_sxt8 [Occ=Once] :: (a_asmK, b_asmL)
          [LclId] =
              CCCS (,)! [x_sxt5 y_sxt6];
        } in  c1_sxt4 sat_sxt8 r_sxt7;

GHC.List.foldr2_left
  :: forall a b c d.
     (a -> b -> c -> d) -> d -> a -> ([b] -> c) -> [b] -> d
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><L,1*U><L,U><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [_k_sxt9 z_sxta _x_sxtb _r_sxtc ds_sxtd]
        case ds_sxtd of {
          [] -> z_sxta;
          : y_sxtf [Occ=Once] ys_sxtg [Occ=Once] ->
              let {
                sat_sxth [Occ=Once] :: c_asmZ
                [LclId] =
                    [_r_sxtc ys_sxtg] \u [] _r_sxtc ys_sxtg;
              } in  _k_sxt9 _x_sxtb y_sxtf sat_sxth;
        };

GHC.List.zip [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a b. [a] -> [b] -> [(a, b)]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sxti _bs_sxtj]
        case ds_sxti of {
          [] -> [] [];
          : ipv_sxtl [Occ=Once] ipv1_sxtm [Occ=Once] ->
              case _bs_sxtj of {
                [] -> [] [];
                : ipv2_sxto [Occ=Once] ipv3_sxtp [Occ=Once] ->
                    let {
                      sat_sxtr [Occ=Once] :: [(a_asmP, b_asmQ)]
                      [LclId] =
                          [ipv1_sxtm ipv3_sxtp] \u [] GHC.List.zip ipv1_sxtm ipv3_sxtp; } in
                    let {
                      sat_sxtq [Occ=Once] :: (a_asmP, b_asmQ)
                      [LclId] =
                          CCCS (,)! [ipv_sxtl ipv2_sxto];
                    } in  : [sat_sxtq sat_sxtr];
              };
        };
GHC.List.zipWith [InlPrag=NOINLINE[1], Occ=LoopBreaker!]
  :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sxts eta_sxtt eta1_sxtu]
        let {
          go2_sxtv [Occ=LoopBreaker] :: [a_asm5] -> [b_asm6] -> [c_asm7]
          [LclId, Arity=2, Str=<S,1*U><L,1*U>, Unf=OtherCon []] =
              sat-only [f_sxts go2_sxtv] \r [ds_sxtw ds1_sxtx]
                  case ds_sxtw of {
                    [] -> [] [];
                    : ipv_sxtz [Occ=Once] ipv1_sxtA [Occ=Once] ->
                        case ds1_sxtx of {
                          [] -> [] [];
                          : ipv2_sxtC [Occ=Once] ipv3_sxtD [Occ=Once] ->
                              let {
                                sat_sxtF [Occ=Once] :: [c_asm7]
                                [LclId] =
                                    [go2_sxtv ipv1_sxtA ipv3_sxtD] \u []
                                        go2_sxtv ipv1_sxtA ipv3_sxtD; } in
                              let {
                                sat_sxtE [Occ=Once] :: c_asm7
                                [LclId] =
                                    [f_sxts ipv_sxtz ipv2_sxtC] \u [] f_sxts ipv_sxtz ipv2_sxtC;
                              } in  : [sat_sxtE sat_sxtF];
                        };
                  };
        } in  go2_sxtv eta_sxtt eta1_sxtu;
GHC.List.foldr2 [InlPrag=INLINE[0] (sat-args=2), Occ=LoopBreaker!]
  :: forall a b c. (a -> b -> c -> c) -> c -> [a] -> [b] -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,U><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [k_sxtG z_sxtH eta_sxtI eta1_sxtJ]
        let {
          go2_sxtK [Occ=LoopBreaker] :: [a_asn2] -> [b_asn3] -> c_asn4
          [LclId, Arity=2, Str=<S,1*U><L,1*U>, Unf=OtherCon []] =
              sat-only [k_sxtG z_sxtH go2_sxtK] \r [ds_sxtL _ys_sxtM]
                  case ds_sxtL of {
                    [] -> z_sxtH;
                    : ipv_sxtO [Occ=Once] ipv1_sxtP [Occ=Once] ->
                        case _ys_sxtM of {
                          [] -> z_sxtH;
                          : ipv2_sxtR [Occ=Once] ipv3_sxtS [Occ=Once] ->
                              let {
                                sat_sxtT [Occ=Once] :: c_asn4
                                [LclId] =
                                    [go2_sxtK ipv1_sxtP ipv3_sxtS] \u []
                                        go2_sxtK ipv1_sxtP ipv3_sxtS;
                              } in  k_sxtG ipv_sxtO ipv2_sxtR sat_sxtT;
                        };
                  };
        } in  go2_sxtK eta_sxtI eta1_sxtJ;

GHC.List.concat_go [Occ=LoopBreaker] :: forall a. [[a]] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxtU]
        case ds_sxtU of {
          [] -> [] [];
          : y_sxtW [Occ=Once] ys_sxtX [Occ=Once] ->
              let {
                sat_sxtY [Occ=Once, Dmd=<L,1*U>] :: [a_asob]
                [LclId] =
                    [ys_sxtX] \s [] GHC.List.concat_go ys_sxtX;
              } in  GHC.Base.++ y_sxtW sat_sxtY;
        };

GHC.List.concat [InlPrag=NOINLINE[1]] :: forall a. [[a]] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1] GHC.List.concat_go eta_B1;

GHC.List.concatMap [InlPrag=NOINLINE[1]]
  :: forall a b. (a -> [b]) -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sxtZ eta_sxu0]
        let {
          go2_sxu1 [Occ=LoopBreaker] :: [a_asog] -> [b_asoh]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [f_sxtZ go2_sxu1] \r [ds_sxu2]
                  case ds_sxu2 of {
                    [] -> [] [];
                    : y_sxu4 [Occ=Once] ys_sxu5 [Occ=Once] ->
                        let {
                          sat_sxu7 [Occ=Once, Dmd=<L,1*U>] :: [b_asoh]
                          [LclId] =
                              [go2_sxu1 ys_sxu5] \s [] go2_sxu1 ys_sxu5;
                        } in 
                          case f_sxtZ y_sxu4 of sat_sxu6 {
                            __DEFAULT -> GHC.Base.++ sat_sxu6 sat_sxu7;
                          };
                  };
        } in  go2_sxu1 eta_sxu0;

GHC.List.lookup [Occ=LoopBreaker]
  :: forall a b.
     GHC.Classes.Eq a =>
     a -> [(a, b)] -> GHC.Base.Maybe b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sxu8 _key_sxu9 ds_sxua]
        case ds_sxua of {
          [] -> GHC.Base.Nothing [];
          : ds1_sxuc [Occ=Once!] xys_sxud [Occ=Once] ->
              case ds1_sxuc of {
                (,) x_sxuf [Occ=Once] y_sxug [Occ=Once] ->
                    case GHC.Classes.== $dEq_sxu8 _key_sxu9 x_sxuf of {
                      GHC.Types.False -> GHC.List.lookup $dEq_sxu8 _key_sxu9 xys_sxud;
                      GHC.Types.True -> GHC.Base.Just [y_sxug];
                    };
              };
        };

GHC.List.notElem [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. GHC.Classes.Eq a => a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sxui ds_sxuj ds1_sxuk]
        case ds1_sxuk of {
          [] -> GHC.Types.True [];
          : y_sxum [Occ=Once] ys_sxun [Occ=Once] ->
              case GHC.Classes./= $dEq_sxui ds_sxuj y_sxum of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> GHC.List.notElem $dEq_sxui ds_sxuj ys_sxun;
              };
        };

GHC.List.elem [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. GHC.Classes.Eq a => a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sxup ds_sxuq ds1_sxur]
        case ds1_sxur of {
          [] -> GHC.Types.False [];
          : y_sxut [Occ=Once] ys_sxuu [Occ=Once] ->
              case GHC.Classes.== $dEq_sxup ds_sxuq y_sxut of {
                GHC.Types.False -> GHC.List.elem $dEq_sxup ds_sxuq ys_sxuu;
                GHC.Types.True -> GHC.Types.True [];
              };
        };

GHC.List.all [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sxuw ds1_sxux]
        case ds1_sxux of {
          [] -> GHC.Types.True [];
          : x_sxuz [Occ=Once] xs_sxuA [Occ=Once] ->
              case ds_sxuw x_sxuz of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> GHC.List.all ds_sxuw xs_sxuA;
              };
        };

GHC.List.any [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sxuC ds1_sxuD]
        case ds1_sxuD of {
          [] -> GHC.Types.False [];
          : x_sxuF [Occ=Once] xs_sxuG [Occ=Once] ->
              case ds_sxuC x_sxuF of {
                GHC.Types.False -> GHC.List.any ds_sxuC xs_sxuG;
                GHC.Types.True -> GHC.Types.True [];
              };
        };

GHC.List.or [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: [GHC.Types.Bool] -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxuI]
        case ds_sxuI of {
          [] -> GHC.Types.False [];
          : x_sxuK [Occ=Once!] xs_sxuL [Occ=Once] ->
              case x_sxuK of {
                GHC.Types.False -> GHC.List.or xs_sxuL;
                GHC.Types.True -> GHC.Types.True [];
              };
        };

GHC.List.and [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: [GHC.Types.Bool] -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxuN]
        case ds_sxuN of {
          [] -> GHC.Types.True [];
          : x_sxuP [Occ=Once!] xs_sxuQ [Occ=Once] ->
              case x_sxuP of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> GHC.List.and xs_sxuQ;
              };
        };

GHC.List.reverse1 [Occ=LoopBreaker] :: forall a. [a] -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sxuS a1_sxuT]
        case ds_sxuS of {
          [] -> a1_sxuT;
          : x_sxuV [Occ=Once] xs_sxuW [Occ=Once] ->
              let {
                sat_sxuX [Occ=Once] :: [a_asp0]
                [LclId] =
                    CCCS :! [x_sxuV a1_sxuT];
              } in  GHC.List.reverse1 xs_sxuW sat_sxuX;
        };

GHC.List.reverse :: forall a. [a] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [l_sxuY] GHC.List.reverse1 l_sxuY GHC.Types.[];

GHC.List.$wbreak [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> (# [a], [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sxuZ w1_sxv0]
        case w1_sxv0 of wild_sxv1 {
          [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
          : x_sxv2 xs'_sxv3 [Occ=Once] ->
              case w_sxuZ x_sxv2 of {
                GHC.Types.False ->
                    let {
                      ds_sxv5 [Dmd=<L,U(1*U,1*U)>] :: ([a_stKr], [a_stKr])
                      [LclId] =
                          [w_sxuZ xs'_sxv3] \u []
                              case GHC.List.$wbreak w_sxuZ xs'_sxv3 of {
                                (#,#) ww1_sxv7 [Occ=Once] ww2_sxv8 [Occ=Once] ->
                                    (,) [ww1_sxv7 ww2_sxv8];
                              }; } in
                    let {
                      sat_sxvh [Occ=Once] :: [a_stKr]
                      [LclId] =
                          [ds_sxv5] \u []
                              case ds_sxv5 of {
                                (,) _ [Occ=Dead] zs_sxvg [Occ=Once] -> zs_sxvg;
                              }; } in
                    let {
                      sat_sxvc [Occ=Once] :: [a_stKr]
                      [LclId] =
                          [ds_sxv5] \u []
                              case ds_sxv5 of {
                                (,) ys_sxva [Occ=Once] _ [Occ=Dead] -> ys_sxva;
                              }; } in
                    let {
                      sat_sxvd [Occ=Once] :: [a_stKr]
                      [LclId] =
                          CCCS :! [x_sxv2 sat_sxvc];
                    } in  (#,#) [sat_sxvd sat_sxvh];
                GHC.Types.True -> (#,#) [GHC.Types.[] wild_sxv1];
              };
        };

GHC.List.break [InlPrag=NOUSERINLINE[0]]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>m,
 Unf=OtherCon []] =
    [] \r [w_sxvi w1_sxvj]
        case GHC.List.$wbreak w_sxvi w1_sxvj of {
          (#,#) ww1_sxvl [Occ=Once] ww2_sxvm [Occ=Once] ->
              (,) [ww1_sxvl ww2_sxvm];
        };

GHC.List.$wspan [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> (# [a], [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sxvn w1_sxvo]
        case w1_sxvo of wild_sxvp {
          [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
          : x_sxvq xs'_sxvr [Occ=Once] ->
              case w_sxvn x_sxvq of {
                GHC.Types.False -> (#,#) [GHC.Types.[] wild_sxvp];
                GHC.Types.True ->
                    let {
                      ds_sxvt [Dmd=<L,U(1*U,1*U)>] :: ([a_stKk], [a_stKk])
                      [LclId] =
                          [w_sxvn xs'_sxvr] \u []
                              case GHC.List.$wspan w_sxvn xs'_sxvr of {
                                (#,#) ww1_sxvv [Occ=Once] ww2_sxvw [Occ=Once] ->
                                    (,) [ww1_sxvv ww2_sxvw];
                              }; } in
                    let {
                      sat_sxvF [Occ=Once] :: [a_stKk]
                      [LclId] =
                          [ds_sxvt] \u []
                              case ds_sxvt of {
                                (,) _ [Occ=Dead] zs_sxvE [Occ=Once] -> zs_sxvE;
                              }; } in
                    let {
                      sat_sxvA [Occ=Once] :: [a_stKk]
                      [LclId] =
                          [ds_sxvt] \u []
                              case ds_sxvt of {
                                (,) ys_sxvy [Occ=Once] _ [Occ=Dead] -> ys_sxvy;
                              }; } in
                    let {
                      sat_sxvB [Occ=Once] :: [a_stKk]
                      [LclId] =
                          CCCS :! [x_sxvq sat_sxvA];
                    } in  (#,#) [sat_sxvB sat_sxvF];
              };
        };

GHC.List.span [InlPrag=NOUSERINLINE[0]]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>m,
 Unf=OtherCon []] =
    [] \r [w_sxvG w1_sxvH]
        case GHC.List.$wspan w_sxvG w1_sxvH of {
          (#,#) ww1_sxvJ [Occ=Once] ww2_sxvK [Occ=Once] ->
              (,) [ww1_sxvJ ww2_sxvK];
        };

GHC.List.takeFB [InlPrag=INLINE[0] (sat-args=4)]
  :: forall a b.
     (a -> b -> b)
     -> b -> a -> (GHC.Types.Int -> b) -> GHC.Types.Int -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U><L,1*C1(U)><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_sxvL eta1_sxvM eta2_sxvN eta3_sxvO m_sxvP]
        case m_sxvP of {
          GHC.Types.I# ds_sxvR [Occ=Once!] ->
              case ds_sxvR of ds1_sxvS {
                __DEFAULT ->
                    let {
                      sat_sxvV [Occ=Once] :: b_asro
                      [LclId] =
                          [eta3_sxvO ds1_sxvS] \u []
                              case -# [ds1_sxvS 1#] of sat_sxvT {
                                __DEFAULT ->
                                    let {
                                      sat_sxvU [Occ=Once] :: GHC.Types.Int
                                      [LclId] =
                                          CCCS GHC.Types.I#! [sat_sxvT];
                                    } in  eta3_sxvO sat_sxvU;
                              };
                    } in  eta_sxvL eta2_sxvN sat_sxvV;
                1# -> eta_sxvL eta2_sxvN eta1_sxvM;
              };
        };

GHC.List.flipSeqTake [InlPrag=INLINE[0] (sat-args=2)]
  :: forall a. a -> GHC.Types.Int -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [x_sxvW _n_sxvX]
        case _n_sxvX of { GHC.Types.I# _ [Occ=Dead] -> x_sxvW; };

GHC.List.$wunsafeTake [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. GHC.Prim.Int# -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_sxw0 w_sxw1]
        case w_sxw1 of {
          [] -> [] [];
          : ipv_sxw3 [Occ=Once*] ipv1_sxw4 [Occ=Once] ->
              case ww_sxw0 of ds_sxw5 {
                __DEFAULT ->
                    let {
                      sat_sxw7 [Occ=Once] :: [a_stK6]
                      [LclId] =
                          [ipv1_sxw4 ds_sxw5] \u []
                              case -# [ds_sxw5 1#] of sat_sxw6 {
                                __DEFAULT -> GHC.List.$wunsafeTake sat_sxw6 ipv1_sxw4;
                              };
                    } in  : [ipv_sxw3 sat_sxw7];
                1# -> : [ipv_sxw3 GHC.Types.[]];
              };
        };

GHC.List.unsafeTake [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Types.Int -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sxw8 w1_sxw9]
        case w_sxw8 of {
          GHC.Types.I# ww1_sxwb [Occ=Once] ->
              GHC.List.$wunsafeTake ww1_sxwb w1_sxw9;
        };

GHC.List.take [InlPrag=INLINE[1] (sat-args=2)]
  :: forall a. GHC.Types.Int -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_sxwc eta1_sxwd]
        case eta_sxwc of {
          GHC.Types.I# y_sxwf ->
              case <# [0# y_sxwf] of {
                __DEFAULT -> [] [];
                1# -> GHC.List.$wunsafeTake y_sxwf eta1_sxwd;
              };
        };

GHC.List.dropWhile [Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sxwh ds1_sxwi]
        case ds1_sxwi of wild_sxwj {
          [] -> [] [];
          : x_sxwk [Occ=Once] xs'_sxwl [Occ=Once] ->
              case ds_sxwh x_sxwk of {
                GHC.Types.False -> wild_sxwj;
                GHC.Types.True -> GHC.List.dropWhile ds_sxwh xs'_sxwl;
              };
        };

GHC.List.takeWhileFB [InlPrag=INLINE[0] (sat-args=3),
                      Occ=LoopBreaker!]
  :: forall a b.
     (a -> GHC.Types.Bool) -> (a -> b -> b) -> b -> a -> b -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(C1(U))><L,1*U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [p_sxwn c_sxwo n_sxwp x_sxwq r_sxwr]
        case p_sxwn x_sxwq of {
          GHC.Types.False -> n_sxwp;
          GHC.Types.True -> c_sxwo x_sxwq r_sxwr;
        };

GHC.List.takeWhile [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sxwt ds1_sxwu]
        case ds1_sxwu of {
          [] -> [] [];
          : x_sxww xs_sxwx [Occ=Once] ->
              case ds_sxwt x_sxww of {
                GHC.Types.False -> [] [];
                GHC.Types.True ->
                    let {
                      sat_sxwz [Occ=Once] :: [a_ass4]
                      [LclId] =
                          [ds_sxwt xs_sxwx] \u [] GHC.List.takeWhile ds_sxwt xs_sxwx;
                    } in  : [x_sxww sat_sxwz];
              };
        };

GHC.List.repeat [InlPrag=INLINE[0] (sat-args=1), Occ=LoopBreaker!]
  :: forall a. a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>, Unf=OtherCon []] =
    [] \r [x_sxwA]
        let {
          xs_sxwB [Occ=LoopBreaker] :: [a_assp]
          [LclId, Unf=OtherCon []] =
              CCCS :! [x_sxwA xs_sxwB];
        } in  xs_sxwB;
GHC.List.repeatFB [InlPrag=INLINE[0] (sat-args=2),
                   Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [c_sxwC x_sxwD]
        let {
          xs_sxwE [Occ=LoopBreaker] :: b_assi
          [LclId] =
              [c_sxwC x_sxwD xs_sxwE] \u [] c_sxwC x_sxwD xs_sxwE;
        } in  xs_sxwE;

GHC.List.replicate [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Types.Int -> a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [n_sxwF x_sxwG]
        case n_sxwF of {
          GHC.Types.I# y_sxwI ->
              case <# [0# y_sxwI] of {
                __DEFAULT -> [] [];
                1# ->
                    let {
                      lvl31_sxwK [Occ=OnceL] :: [a_assx]
                      [LclId, Unf=OtherCon []] =
                          CCCS :! [x_sxwG GHC.Types.[]]; } in
                    let {
                      $wxs_sxwL [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                        :: GHC.Prim.Int# -> [a_assx]
                      [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                          sat-only [x_sxwG lvl31_sxwK $wxs_sxwL] \r [ww_sxwM]
                              case ww_sxwM of ds_sxwN {
                                __DEFAULT ->
                                    let {
                                      sat_sxwP [Occ=Once] :: [a_assx]
                                      [LclId] =
                                          [$wxs_sxwL ds_sxwN] \u []
                                              case -# [ds_sxwN 1#] of sat_sxwO {
                                                __DEFAULT -> $wxs_sxwL sat_sxwO;
                                              };
                                    } in  : [x_sxwG sat_sxwP];
                                1# -> lvl31_sxwK;
                              };
                    } in  $wxs_sxwL y_sxwI;
              };
        };

GHC.List.$witerate' [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> a) -> a -> (# a, [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sxwQ w1_sxwR]
        case w_sxwQ w1_sxwR of x'_sxwS {
          __DEFAULT ->
              let {
                sat_sxwW [Occ=Once] :: [a_stJT]
                [LclId] =
                    [w_sxwQ x'_sxwS] \u []
                        case GHC.List.$witerate' w_sxwQ x'_sxwS of {
                          (#,#) ww1_sxwU [Occ=Once] ww2_sxwV [Occ=Once] ->
                              : [ww1_sxwU ww2_sxwV];
                        };
              } in  (#,#) [w1_sxwR sat_sxwW];
        };

GHC.List.iterate'FB [InlPrag=INLINE[0] (sat-args=3),
                     Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> (a -> a) -> a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><C(S),C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [c_sxwX f_sxwY x0_sxwZ]
        let {
          go2_sxx0 [Occ=LoopBreaker] :: a_assB -> b_assC
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [c_sxwX f_sxwY go2_sxx0] \r [x_sxx1]
                  case f_sxwY x_sxx1 of x'_sxx2 {
                    __DEFAULT ->
                        let {
                          sat_sxx3 [Occ=Once] :: b_assC
                          [LclId] =
                              [go2_sxx0 x'_sxx2] \u [] go2_sxx0 x'_sxx2;
                        } in  c_sxwX x_sxx1 sat_sxx3;
                  };
        } in  go2_sxx0 x0_sxwZ;
GHC.List.iterate' [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker!]
  :: forall a. (a -> a) -> a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U)><L,U>m2,
 Unf=OtherCon []] =
    [] \r [w_sxx4 w1_sxx5]
        case GHC.List.$witerate' w_sxx4 w1_sxx5 of {
          (#,#) ww1_sxx7 [Occ=Once] ww2_sxx8 [Occ=Once] ->
              : [ww1_sxx7 ww2_sxx8];
        };

GHC.List.$witerate [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> a) -> a -> (# a, [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sxx9 w1_sxxa]
        let {
          sat_sxxf [Occ=Once] :: [a_stJL]
          [LclId] =
              [w_sxx9 w1_sxxa] \u []
                  let {
                    sat_sxxb [Occ=Once] :: a_stJL
                    [LclId] =
                        [w_sxx9 w1_sxxa] \u [] w_sxx9 w1_sxxa;
                  } in 
                    case GHC.List.$witerate w_sxx9 sat_sxxb of {
                      (#,#) ww1_sxxd [Occ=Once] ww2_sxxe [Occ=Once] ->
                          : [ww1_sxxd ww2_sxxe];
                    };
        } in  (#,#) [w1_sxxa sat_sxxf];

GHC.List.iterateFB [InlPrag=INLINE[0] (sat-args=3),
                    Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> (a -> a) -> a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [c_sxxg f_sxxh x0_sxxi]
        let {
          go2_sxxj [Occ=LoopBreaker] :: a_astf -> b_astg
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [c_sxxg f_sxxh go2_sxxj] \r [x_sxxk]
                  let {
                    sat_sxxm [Occ=Once] :: b_astg
                    [LclId] =
                        [f_sxxh go2_sxxj x_sxxk] \u []
                            let {
                              sat_sxxl [Occ=Once] :: a_astf
                              [LclId] =
                                  [f_sxxh x_sxxk] \u [] f_sxxh x_sxxk;
                            } in  go2_sxxj sat_sxxl;
                  } in  c_sxxg x_sxxk sat_sxxm;
        } in  go2_sxxj x0_sxxi;
GHC.List.iterate [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker!]
  :: forall a. (a -> a) -> a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U>m2,
 Unf=OtherCon []] =
    [] \r [w_sxxn w1_sxxo]
        case GHC.List.$witerate w_sxxn w1_sxxo of {
          (#,#) ww1_sxxq [Occ=Once] ww2_sxxr [Occ=Once] ->
              : [ww1_sxxq ww2_sxxr];
        };

lvl27_ru9o :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC/List.hs:411:34-55|qs@(q : _)"#;

lvl28_ru9p :: forall a. ([a], a)
[GblId, Str=x] =
    [] \u [] Control.Exception.Base.patError lvl27_ru9o;

GHC.List.scanr1 [Occ=LoopBreaker]
  :: forall a. (a -> a -> a) -> [a] -> [a]
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxxs ds1_sxxt]
        case ds1_sxxt of {
          [] -> [] [];
          : x_sxxv [Occ=Once*] ds2_sxxw [Occ=Once!] ->
              case ds2_sxxw of wild1_sxxx {
                [] -> : [x_sxxv GHC.Types.[]];
                : _ [Occ=Dead] _ [Occ=Dead] ->
                    let {
                      ds3_sxxA [Dmd=<L,U(1*U,1*U)>] :: ([a_astA], a_astA)
                      [LclId] =
                          [ds_sxxs wild1_sxxx] \u []
                              case GHC.List.scanr1 ds_sxxs wild1_sxxx of wild2_sxxB {
                                [] -> lvl28_ru9p;
                                : q_sxxC [Occ=Once] _ [Occ=Dead] -> (,) [wild2_sxxB q_sxxC];
                              }; } in
                    let {
                      sat_sxxM [Occ=Once] :: [a_astA]
                      [LclId] =
                          [ds3_sxxA] \u []
                              case ds3_sxxA of {
                                (,) qs_sxxK [Occ=Once] _ [Occ=Dead] -> qs_sxxK;
                              }; } in
                    let {
                      sat_sxxI [Occ=Once] :: a_astA
                      [LclId] =
                          [ds_sxxs x_sxxv ds3_sxxA] \u []
                              let {
                                sat_sxxH [Occ=Once] :: a_astA
                                [LclId] =
                                    [ds3_sxxA] \u []
                                        case ds3_sxxA of {
                                          (,) _ [Occ=Dead] q_sxxG [Occ=Once] -> q_sxxG;
                                        };
                              } in  ds_sxxs x_sxxv sat_sxxH;
                    } in  : [sat_sxxI sat_sxxM];
              };
        };

GHC.List.scanrFB [InlPrag=INLINE[0] (sat-args=2)]
  :: forall a b c.
     (a -> b -> b) -> (b -> c -> c) -> a -> (b, c) -> (b, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_sxxN c1_sxxO x_sxxP ds_sxxQ]
        case ds_sxxQ of {
          (,) r_sxxS est_sxxT [Occ=Once] ->
              let {
                sat_sxxV [Occ=Once] :: c_astR
                [LclId] =
                    [c1_sxxO r_sxxS est_sxxT] \u [] c1_sxxO r_sxxS est_sxxT; } in
              let {
                sat_sxxU [Occ=Once] :: b_astQ
                [LclId] =
                    [f_sxxN x_sxxP r_sxxS] \u [] f_sxxN x_sxxP r_sxxS;
              } in  (,) [sat_sxxU sat_sxxV];
        };

GHC.List.$wscanr [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a b. (a -> b -> b) -> b -> [a] -> (# b, [b] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sxxW w1_sxxX w2_sxxY]
        case w2_sxxY of {
          [] -> (#,#) [w1_sxxX GHC.Types.[]];
          : x_sxy0 [Occ=Once] xs_sxy1 [Occ=Once] ->
              let {
                ds_sxy2 [Dmd=<L,U(1*U,1*U)>] :: ([b_stJz], b_stJz)
                [LclId] =
                    [w_sxxW w1_sxxX xs_sxy1] \u []
                        case GHC.List.$wscanr w_sxxW w1_sxxX xs_sxy1 of {
                          (#,#) ww1_sxy4 ww2_sxy5 [Occ=Once] ->
                              let {
                                sat_sxy6 [Occ=Once] :: [b_stJz]
                                [LclId] =
                                    CCCS :! [ww1_sxy4 ww2_sxy5];
                              } in  (,) [sat_sxy6 ww1_sxy4];
                        }; } in
              let {
                sat_sxyf [Occ=Once] :: [b_stJz]
                [LclId] =
                    [ds_sxy2] \u []
                        case ds_sxy2 of {
                          (,) qs_sxyd [Occ=Once] _ [Occ=Dead] -> qs_sxyd;
                        }; } in
              let {
                sat_sxyb [Occ=Once] :: b_stJz
                [LclId] =
                    [w_sxxW x_sxy0 ds_sxy2] \u []
                        let {
                          sat_sxya [Occ=Once] :: b_stJz
                          [LclId] =
                              [ds_sxy2] \u []
                                  case ds_sxy2 of { (,) _ [Occ=Dead] q_sxy9 [Occ=Once] -> q_sxy9; };
                        } in  w_sxxW x_sxy0 sat_sxya;
              } in  (#,#) [sat_sxyb sat_sxyf];
        };

GHC.List.strictUncurryScanr [InlPrag=INLINE[0] (sat-args=2),
                             Occ=LoopBreaker!]
  :: forall a b c. (a -> b -> c) -> (a, b) -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sxyg pair_sxyh]
        case pair_sxyh of {
          (,) x_sxyj [Occ=Once] y_sxyk [Occ=Once] -> f_sxyg x_sxyj y_sxyk;
        };
GHC.List.scanr [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> b -> [a] -> [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>m2,
 Unf=OtherCon []] =
    [] \r [w_sxyl w1_sxym w2_sxyn]
        case GHC.List.$wscanr w_sxyl w1_sxym w2_sxyn of {
          (#,#) ww1_sxyp [Occ=Once] ww2_sxyq [Occ=Once] ->
              : [ww1_sxyp ww2_sxyq];
        };

GHC.List.flipSeqScanl' [InlPrag=INLINE[0] (sat-args=2)]
  :: forall a b. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_sxyr _b_sxys] case _b_sxys of { __DEFAULT -> a1_sxyr; };

GHC.List.scanlFB' [InlPrag=INLINE[0] (sat-args=2)]
  :: forall b a c.
     (b -> a -> b) -> (b -> c -> c) -> a -> (b -> c) -> b -> c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sxyu c1_sxyv b1_sxyw g_sxyx v_sxyy]
        case f_sxyu v_sxyy b1_sxyw of b'_sxyz {
          __DEFAULT ->
              let {
                sat_sxyA [Occ=Once] :: c_asuE
                [LclId] =
                    [g_sxyx b'_sxyz] \u [] g_sxyx b'_sxyz;
              } in  c1_sxyv b'_sxyz sat_sxyA;
        };

GHC.List.$wscanlGo' [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall b1 a1 b2 a2.
     (b2 -> a2 -> b2) -> b2 -> [a2] -> (# b2, [b2] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sxyB w1_sxyC w2_sxyD]
        case w1_sxyC of q_sxyE {
          __DEFAULT ->
              let {
                sat_sxyM [Occ=Once] :: [b1_stJp]
                [LclId] =
                    [w_sxyB w2_sxyD q_sxyE] \u []
                        case w2_sxyD of {
                          [] -> [] [];
                          : x_sxyG [Occ=Once] xs_sxyH [Occ=Once] ->
                              case w_sxyB q_sxyE x_sxyG of sat_sxyI {
                                __DEFAULT ->
                                    case GHC.List.$wscanlGo' w_sxyB sat_sxyI xs_sxyH of {
                                      (#,#) ww1_sxyK [Occ=Once] ww2_sxyL [Occ=Once] ->
                                          : [ww1_sxyK ww2_sxyL];
                                    };
                              };
                        };
              } in  (#,#) [q_sxyE sat_sxyM];
        };

GHC.List.scanl'_scanlGo' [InlPrag=NOUSERINLINE[0]]
  :: forall b1 a1 b2 a2. (b2 -> a2 -> b2) -> b2 -> [a2] -> [b2]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,1*U>m2,
 Unf=OtherCon []] =
    [] \r [w_sxyN w1_sxyO w2_sxyP]
        case GHC.List.$wscanlGo' w_sxyN w1_sxyO w2_sxyP of {
          (#,#) ww1_sxyR [Occ=Once] ww2_sxyS [Occ=Once] ->
              : [ww1_sxyR ww2_sxyS];
        };

GHC.List.scanl' [InlPrag=NOINLINE[1]]
  :: forall b a. (b -> a -> b) -> b -> [a] -> [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,1*U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.List.scanl'_scanlGo' eta_B3 eta_B2 eta_B1;

GHC.List.constScanl [InlPrag=INLINE[0] (sat-args=0)]
  :: forall a b. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.const eta_B2 eta_B1;

GHC.List.scanlFB [InlPrag=INLINE[0] (sat-args=2)]
  :: forall b a c.
     (b -> a -> b) -> (b -> c -> c) -> a -> (b -> c) -> b -> c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sxyT c1_sxyU b1_sxyV g_sxyW v_sxyX]
        let {
          b'_sxyY :: b_asvy
          [LclId] =
              [f_sxyT b1_sxyV v_sxyX] \u [] f_sxyT v_sxyX b1_sxyV; } in
        let {
          sat_sxyZ [Occ=Once] :: c_asvA
          [LclId] =
              [g_sxyW b'_sxyY] \u [] g_sxyW b'_sxyY;
        } in  c1_sxyU b'_sxyY sat_sxyZ;

GHC.List.$wscanlGo [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall b1 a1 b2 a2.
     (b2 -> a2 -> b2) -> b2 -> [a2] -> (# b2, [b2] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sxz0 w1_sxz1 w2_sxz2]
        let {
          sat_sxza [Occ=Once] :: [b1_stJe]
          [LclId] =
              [w_sxz0 w1_sxz1 w2_sxz2] \u []
                  case w2_sxz2 of {
                    [] -> [] [];
                    : x_sxz4 [Occ=Once] xs_sxz5 [Occ=Once] ->
                        let {
                          sat_sxz6 [Occ=Once] :: b1_stJe
                          [LclId] =
                              [w_sxz0 w1_sxz1 x_sxz4] \u [] w_sxz0 w1_sxz1 x_sxz4;
                        } in 
                          case GHC.List.$wscanlGo w_sxz0 sat_sxz6 xs_sxz5 of {
                            (#,#) ww1_sxz8 [Occ=Once] ww2_sxz9 [Occ=Once] ->
                                : [ww1_sxz8 ww2_sxz9];
                          };
                  };
        } in  (#,#) [w1_sxz1 sat_sxza];

GHC.List.scanl_scanlGo [InlPrag=NOUSERINLINE[0]]
  :: forall b1 a1 b2 a2. (b2 -> a2 -> b2) -> b2 -> [a2] -> [b2]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,1*U>m2,
 Unf=OtherCon []] =
    [] \r [w_sxzb w1_sxzc w2_sxzd]
        case GHC.List.$wscanlGo w_sxzb w1_sxzc w2_sxzd of {
          (#,#) ww1_sxzf [Occ=Once] ww2_sxzg [Occ=Once] ->
              : [ww1_sxzf ww2_sxzg];
        };

GHC.List.scanl [InlPrag=NOINLINE[1]]
  :: forall b a. (b -> a -> b) -> b -> [a] -> [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,1*U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.List.scanl_scanlGo eta_B3 eta_B2 eta_B1;

GHC.List.scanl1 :: forall a. (a -> a -> a) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sxzh ds_sxzi]
        case ds_sxzi of {
          [] -> [] [];
          : x_sxzk xs_sxzl [Occ=Once] ->
              let {
                sat_sxzp [Occ=Once] :: [a_aswp]
                [LclId] =
                    [f_sxzh x_sxzk xs_sxzl] \u []
                        case GHC.List.$wscanlGo f_sxzh x_sxzk xs_sxzl of {
                          (#,#) _ [Occ=Dead] ww2_sxzo [Occ=Once] -> ww2_sxzo;
                        };
              } in  : [x_sxzk sat_sxzp];
        };

GHC.List.foldl' [InlPrag=INLINE (sat-args=3)]
  :: forall a b. (b -> a -> b) -> b -> [a] -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [k_sxzq z0_sxzr xs_sxzs]
        let-no-escape {
          go2_sxzt [Occ=LoopBreakerT[2]] :: [a_aswt] -> b_aswu -> b_aswu
          [LclId[JoinId(2)], Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
              sat-only [k_sxzq go2_sxzt] \r [ds_sxzu eta_sxzv]
                  case ds_sxzu of {
                    [] -> eta_sxzv;
                    : y_sxzx [Occ=Once] ys_sxzy [Occ=Once] ->
                        case eta_sxzv of z_sxzz {
                          __DEFAULT ->
                              case k_sxzq z_sxzz y_sxzx of sat_sxzA {
                                __DEFAULT -> go2_sxzt ys_sxzy sat_sxzA;
                              };
                        };
                  };
        } in  go2_sxzt xs_sxzs z0_sxzr;

GHC.List.foldl1' :: forall a. (a -> a -> a) -> [a] -> a
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []] =
    [] \r [f_sxzB ds_sxzC]
        case ds_sxzC of {
          [] -> GHC.List.foldl1'1;
          : x_sxzE [Occ=Once] xs_sxzF [Occ=Once] ->
              GHC.List.foldl' f_sxzB x_sxzE xs_sxzF;
        };

sat_sxzG :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_sxzH :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sxzG GHC.Types.[]];

lvl29_ru9q :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sxzH;

lvl30_ru9r :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

GHC.List.foldl [InlPrag=INLINE (sat-args=3)]
  :: forall a b. (b -> a -> b) -> b -> [a] -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [k_sxzI z0_sxzJ xs_sxzK]
        let-no-escape {
          go2_sxzL [Occ=LoopBreakerT[2]] :: [a_asx1] -> b_asx2 -> b_asx2
          [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
              sat-only [k_sxzI go2_sxzL] \r [ds_sxzM eta_sxzN]
                  case ds_sxzM of {
                    [] -> eta_sxzN;
                    : y_sxzP [Occ=Once] ys_sxzQ [Occ=Once] ->
                        let {
                          sat_sxzR [Occ=Once] :: b_asx2
                          [LclId] =
                              [k_sxzI eta_sxzN y_sxzP] \u [] k_sxzI eta_sxzN y_sxzP;
                        } in  go2_sxzL ys_sxzQ sat_sxzR;
                  };
        } in  go2_sxzL xs_sxzK z0_sxzJ;

GHC.List.sum [InlPrag=INLINE (sat-args=0)]
  :: forall a. GHC.Num.Num a => [a] -> a
[GblId,
 Arity=1,
 Str=<L,U(1*C(C1(U)),A,A,A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_sxzS]
        let {
          sat_sxzU [Occ=Once] :: a_asyo
          [LclId] =
              [$dNum_sxzS] \u [] GHC.Num.fromInteger $dNum_sxzS lvl30_ru9r; } in
        let {
          sat_sxzT [Occ=Once] :: a_asyo -> a_asyo -> a_asyo
          [LclId] =
              [$dNum_sxzS] \u [] GHC.Num.+ $dNum_sxzS;
        } in  GHC.List.foldl sat_sxzT sat_sxzU;

GHC.List.product [InlPrag=INLINE (sat-args=0)]
  :: forall a. GHC.Num.Num a => [a] -> a
[GblId,
 Arity=1,
 Str=<L,U(A,A,1*C(C1(U)),A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_sxzV]
        let {
          sat_sxzX [Occ=Once] :: a_asyy
          [LclId] =
              [$dNum_sxzV] \u [] GHC.Num.fromInteger $dNum_sxzV lvl29_ru9q; } in
        let {
          sat_sxzW [Occ=Once] :: a_asyy -> a_asyy -> a_asyy
          [LclId] =
              [$dNum_sxzV] \u [] GHC.Num.* $dNum_sxzV;
        } in  GHC.List.foldl sat_sxzW sat_sxzX;

GHC.List.foldl1 :: forall a. (a -> a -> a) -> [a] -> a
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []] =
    [] \r [f_sxzY ds_sxzZ]
        case ds_sxzZ of {
          [] -> GHC.List.foldl2;
          : x_sxA1 [Occ=Once] xs_sxA2 [Occ=Once] ->
              GHC.List.foldl f_sxzY x_sxA1 xs_sxA2;
        };

GHC.List.filterFB [InlPrag=INLINE[0] (sat-args=4),
                   Occ=LoopBreaker!]
  :: forall a b.
     (a -> b -> b) -> (a -> GHC.Types.Bool) -> a -> b -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S),1*C1(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [c_sxA3 p_sxA4 x_sxA5 r_sxA6]
        case p_sxA4 x_sxA5 of {
          GHC.Types.False -> r_sxA6;
          GHC.Types.True -> c_sxA3 x_sxA5 r_sxA6;
        };

GHC.List.filter [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [_pred_sxA8 ds_sxA9]
        case ds_sxA9 of {
          [] -> [] [];
          : x_sxAb xs_sxAc [Occ=Once*] ->
              case _pred_sxA8 x_sxAb of {
                GHC.Types.False -> GHC.List.filter _pred_sxA8 xs_sxAc;
                GHC.Types.True ->
                    let {
                      sat_sxAe [Occ=Once] :: [a_asyL]
                      [LclId] =
                          [_pred_sxA8 xs_sxAc] \u [] GHC.List.filter _pred_sxA8 xs_sxAc;
                    } in  : [x_sxAb sat_sxAe];
              };
        };

GHC.List.idLength [InlPrag=INLINE[0] (sat-args=0)]
  :: GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Base.id eta_B1;

GHC.List.lengthFB [InlPrag=INLINE[0] (sat-args=2)]
  :: forall x.
     x
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [eta_sxAf eta1_sxAg a_sxAh]
        case a_sxAh of {
          GHC.Types.I# ipv_sxAj [Occ=Once] ->
              case +# [ipv_sxAj 1#] of sat_sxAk {
                __DEFAULT ->
                    let {
                      sat_sxAl [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [sat_sxAk];
                    } in  eta1_sxAg sat_sxAl;
              };
        };

GHC.List.$wlenAcc [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. [a] -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sxAm ww_sxAn]
        case w_sxAm of {
          [] -> ww_sxAn;
          : _ [Occ=Dead] ys_sxAq [Occ=Once] ->
              case +# [ww_sxAn 1#] of sat_sxAr {
                __DEFAULT -> GHC.List.$wlenAcc ys_sxAq sat_sxAr;
              };
        };

GHC.List.lenAcc [InlPrag=NOUSERINLINE[0]]
  :: forall a. [a] -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [w_sxAs w1_sxAt]
        case w1_sxAt of {
          GHC.Types.I# ww1_sxAv [Occ=Once] ->
              case GHC.List.$wlenAcc w_sxAs ww1_sxAv of ww2_sxAw {
                __DEFAULT -> GHC.Types.I# [ww2_sxAw];
              };
        };

GHC.List.length [InlPrag=NOUSERINLINE[0]]
  :: forall a. [a] -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [w_sxAx]
        case GHC.List.$wlenAcc w_sxAx 0# of ww_sxAy {
          __DEFAULT -> GHC.Types.I# [ww_sxAy];
        };

GHC.List.null :: forall a. [a] -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxAz]
        case ds_sxAz of {
          [] -> GHC.Types.True [];
          : _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
        };

GHC.List.uncons :: forall a. [a] -> GHC.Base.Maybe (a, [a])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxAD]
        case ds_sxAD of {
          [] -> GHC.Base.Nothing [];
          : x_sxAF [Occ=Once] xs_sxAG [Occ=Once] ->
              let {
                sat_sxAH [Occ=Once] :: (a_aszT, [a_aszT])
                [LclId] =
                    CCCS (,)! [x_sxAF xs_sxAG];
              } in  GHC.Base.Just [sat_sxAH];
        };


==================== STG syntax: ====================
2018-03-16 15:55:10.82011118 UTC

$wunsafeDrop_ru8P :: forall a. GHC.Prim.Int# -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    sat-only [] \r [ww_sxow w_sxox]
        case w_sxox of {
          [] -> [] [];
          : _ [Occ=Dead] ipv1_sxoA [Occ=Once*] ->
              case ww_sxow of ds_sxoB {
                __DEFAULT ->
                    case -# [ds_sxoB 1#] of sat_sxoC {
                      __DEFAULT -> $wunsafeDrop_ru8P sat_sxoC ipv1_sxoA;
                    };
                1# -> ipv1_sxoA;
              };
        };

GHC.List.drop [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Types.Int -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_sxoD eta1_sxoE]
        case eta_sxoD of {
          GHC.Types.I# x_sxoG ->
              case <=# [x_sxoG 0#] of {
                __DEFAULT -> $wunsafeDrop_ru8P x_sxoG eta1_sxoE;
                1# -> eta1_sxoE;
              };
        };

GHC.List.$wsplitAt' [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. GHC.Types.Int -> [a] -> (# [a], [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sxoI w1_sxoJ]
        case w1_sxoJ of {
          [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
          : ipv_sxoL [Occ=Once*] ipv1_sxoM [Occ=Once*] ->
              case w_sxoI of {
                GHC.Types.I# ds_sxoO [Occ=Once!] ->
                    case ds_sxoO of ds1_sxoP {
                      __DEFAULT ->
                          let {
                            ds2_sxoQ [Dmd=<L,U(1*U,1*U)>] :: ([a_stMO], [a_stMO])
                            [LclId] =
                                [ipv1_sxoM ds1_sxoP] \u []
                                    case -# [ds1_sxoP 1#] of sat_sxoR {
                                      __DEFAULT ->
                                          let {
                                            sat_sxoS [Occ=Once] :: GHC.Types.Int
                                            [LclId] =
                                                CCCS GHC.Types.I#! [sat_sxoR];
                                          } in 
                                            case GHC.List.$wsplitAt' sat_sxoS ipv1_sxoM of {
                                              (#,#) ww1_sxoU [Occ=Once] ww2_sxoV [Occ=Once] ->
                                                  (,) [ww1_sxoU ww2_sxoV];
                                            };
                                    }; } in
                          let {
                            sat_sxp4 [Occ=Once] :: [a_stMO]
                            [LclId] =
                                [ds2_sxoQ] \u []
                                    case ds2_sxoQ of {
                                      (,) _ [Occ=Dead] xs''_sxp3 [Occ=Once] -> xs''_sxp3;
                                    }; } in
                          let {
                            sat_sxoZ [Occ=Once] :: [a_stMO]
                            [LclId] =
                                [ds2_sxoQ] \u []
                                    case ds2_sxoQ of {
                                      (,) xs'_sxoX [Occ=Once] _ [Occ=Dead] -> xs'_sxoX;
                                    }; } in
                          let {
                            sat_sxp0 [Occ=Once] :: [a_stMO]
                            [LclId] =
                                CCCS :! [ipv_sxoL sat_sxoZ];
                          } in  (#,#) [sat_sxp0 sat_sxp4];
                      1# ->
                          let {
                            sat_sxp5 [Occ=Once] :: [a_stMO]
                            [LclId] =
                                CCCS :! [ipv_sxoL GHC.Types.[]];
                          } in  (#,#) [sat_sxp5 ipv1_sxoM];
                    };
              };
        };

GHC.List.splitAt_splitAt' [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Types.Int -> [a] -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U(1*U)><S,1*U>m,
 Unf=OtherCon []] =
    [] \r [w_sxp6 w1_sxp7]
        case GHC.List.$wsplitAt' w_sxp6 w1_sxp7 of {
          (#,#) ww1_sxp9 [Occ=Once] ww2_sxpa [Occ=Once] ->
              (,) [ww1_sxp9 ww2_sxpa];
        };

GHC.List.splitAt :: forall a. GHC.Types.Int -> [a] -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U>m,
 Unf=OtherCon []] =
    [] \r [n_sxpb ls_sxpc]
        case n_sxpb of wild_sxpd {
          GHC.Types.I# x_sxpe [Occ=Once] ->
              case <=# [x_sxpe 0#] of {
                __DEFAULT ->
                    case GHC.List.$wsplitAt' wild_sxpd ls_sxpc of {
                      (#,#) ww1_sxph [Occ=Once] ww2_sxpi [Occ=Once] ->
                          (,) [ww1_sxph ww2_sxpi];
                    };
                1# -> (,) [GHC.Types.[] ls_sxpc];
              };
        };

GHC.List.$trModule4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "base"#;

GHC.List.$trModule3 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.List.$trModule4];

GHC.List.$trModule2 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC.List"#;

GHC.List.$trModule1 :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=m1, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.TrNameS! [GHC.List.$trModule2];

GHC.List.$trModule :: GHC.Types.Module
[GblId, Caf=NoCafRefs, Str=m, Unf=OtherCon []] =
    CCS_DONT_CARE GHC.Types.Module! [GHC.List.$trModule3
                                     GHC.List.$trModule1];

GHC.List.init1 [Occ=LoopBreaker] :: forall a. a -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sxpj ds1_sxpk]
        case ds1_sxpk of {
          [] -> [] [];
          : z_sxpm [Occ=Once] zs_sxpn [Occ=Once] ->
              let {
                sat_sxpo [Occ=Once] :: [a_aszc]
                [LclId] =
                    [z_sxpm zs_sxpn] \u [] GHC.List.init1 z_sxpm zs_sxpn;
              } in  : [ds_sxpj sat_sxpo];
        };

lvl_ru8Q :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    ": empty list"#;

lvl1_ru8R :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl_ru8Q;

GHC.List.!!4 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "Prelude."#;

GHC.List.prel_list_str :: GHC.Base.String
[GblId] =
    [] \u [] GHC.CString.unpackCString# GHC.List.!!4;

GHC.List.errorEmptyList :: forall a. GHC.Base.String -> a
[GblId, Arity=1, Str=<B,1*U>x, Unf=OtherCon []] =
    [] \r [fun_sxpp]
        let {
          sat_sxpq [Occ=Once, Dmd=<L,1*U>] :: [GHC.Types.Char]
          [LclId] =
              [fun_sxpp] \s [] GHC.Base.++ fun_sxpp lvl1_ru8R;
        } in 
          case GHC.Base.++ GHC.List.prel_list_str sat_sxpq of sat_sxpr {
            __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sxpr;
          };

lvl2_ru8S :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "!!: negative index"#;

lvl3_ru8T :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl2_ru8S;

GHC.List.negIndex :: forall a. a
[GblId, Str=x] =
    [] \u []
        case GHC.Base.++ GHC.List.prel_list_str lvl3_ru8T of sat_sxps {
          __DEFAULT -> GHC.Err.errorWithoutStackTrace sat_sxps;
        };

GHC.List.!!3 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "!!: index too large"#;

GHC.List.!!2 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# GHC.List.!!3;

GHC.List.!!1 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.Base.++ GHC.List.prel_list_str GHC.List.!!2;

GHC.List.tooLarge :: forall a. GHC.Types.Int -> a
[GblId, Arity=1, Str=<B,A>x, Unf=OtherCon []] =
    [] \r [ds_sxpt] GHC.Err.errorWithoutStackTrace GHC.List.!!1;

poly_exit_ru8U :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.Err.errorWithoutStackTrace GHC.List.!!1;

poly_$wgo_ru8V :: forall a. [a] -> GHC.Prim.Int# -> a
[GblId, Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [w_sxpu ww_sxpv]
        case w_sxpu of {
          [] -> poly_exit_ru8U;
          : y_sxpx [Occ=Once] ys_sxpy [Occ=Once] ->
              case ww_sxpv of ds_sxpz {
                __DEFAULT ->
                    case -# [ds_sxpz 1#] of sat_sxpA {
                      __DEFAULT -> poly_$wgo_ru8V ys_sxpy sat_sxpA;
                    };
                0# -> y_sxpx;
              };
        };

GHC.List.$w!! [InlPrag=INLINABLE[0]]
  :: forall a. [a] -> GHC.Prim.Int# -> a
[GblId, Arity=2, Str=<S,1*U><S,U>, Unf=OtherCon []] =
    [] \r [w_sxpB ww_sxpC]
        case <# [ww_sxpC 0#] of {
          __DEFAULT -> poly_$wgo_ru8V w_sxpB ww_sxpC;
          1# -> GHC.List.negIndex;
        };

GHC.List.!! [InlPrag=NOUSERINLINE[0]]
  :: forall a. [a] -> GHC.Types.Int -> a
[GblId, Arity=2, Str=<S,1*U><S(S),1*U(U)>, Unf=OtherCon []] =
    [] \r [w_sxpE w1_sxpF]
        case w1_sxpF of {
          GHC.Types.I# ww1_sxpH [Occ=Once] -> GHC.List.$w!! w_sxpE ww1_sxpH;
        };

lvl4_ru8W :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "cycle"#;

lvl5_ru8X :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl4_ru8W;

GHC.List.cycle1 :: forall a. [a]
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl5_ru8X;

GHC.List.cycle :: forall a. [a] -> [a]
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxpI]
        case ds_sxpI of wild_sxpJ {
          [] -> GHC.List.cycle1;
          : _ [Occ=Dead] _ [Occ=Dead] ->
              let {
                xs'_sxpM [Occ=LoopBreaker] :: [a_ass8]
                [LclId] =
                    [wild_sxpJ xs'_sxpM] \u [] GHC.Base.++ wild_sxpJ xs'_sxpM;
              } in  xs'_sxpM;
        };

lvl6_ru8Y :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldr1"#;

lvl7_ru8Z :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl6_ru8Y;

lvl8_ru90 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl7_ru8Z;

GHC.List.foldr1 [InlPrag=INLINE[0] (sat-args=1)]
  :: forall a. (a -> a -> a) -> [a] -> a
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []] =
    [] \r [f_sxpN eta_sxpO]
        let {
          go2_sxpP [Occ=LoopBreaker] :: [a_asug] -> a_asug
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [f_sxpN go2_sxpP] \r [ds_sxpQ]
                  case ds_sxpQ of {
                    [] -> lvl8_ru90;
                    : x_sxpS [Occ=Once*] ds1_sxpT [Occ=Once!] ->
                        case ds1_sxpT of wild1_sxpU {
                          [] -> x_sxpS;
                          : _ [Occ=Dead] _ [Occ=Dead] ->
                              let {
                                sat_sxpX [Occ=Once] :: a_asug
                                [LclId] =
                                    [go2_sxpP wild1_sxpU] \u [] go2_sxpP wild1_sxpU;
                              } in  f_sxpN x_sxpS sat_sxpX;
                        };
                  };
        } in  go2_sxpP eta_sxpO;

lvl9_ru91 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "init"#;

lvl10_ru92 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl9_ru91;

GHC.List.init2 :: forall a. [a]
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl10_ru92;

GHC.List.init :: forall a. [a] -> [a]
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxpY]
        case ds_sxpY of {
          [] -> GHC.List.init2;
          : x_sxq0 [Occ=Once] xs_sxq1 [Occ=Once] ->
              GHC.List.init1 x_sxq0 xs_sxq1;
        };

lvl11_ru93 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "last"#;

lvl12_ru94 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl11_ru93;

GHC.List.lastError :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl12_ru94;

poly_go_ru95 :: forall a. [a] -> a -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    sat-only [] \r [ds_sxq2 eta_sxq3]
        case ds_sxq2 of {
          [] -> eta_sxq3;
          : y_sxq5 [Occ=Once] ys_sxq6 [Occ=Once] ->
              poly_go_ru95 ys_sxq6 y_sxq5;
        };

GHC.List.last [InlPrag=INLINE (sat-args=1)] :: forall a. [a] -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [xs_sxq7] poly_go_ru95 xs_sxq7 GHC.List.lastError;

lvl13_ru96 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "tail"#;

lvl14_ru97 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl13_ru96;

GHC.List.scanl2 :: forall a. [a]
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl14_ru97;

GHC.List.tail :: forall a. [a] -> [a]
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxq8]
        case ds_sxq8 of {
          [] -> GHC.List.scanl2;
          : _ [Occ=Dead] xs_sxqb [Occ=Once] -> xs_sxqb;
        };

lvl15_ru98 :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "head"#;

lvl16_ru99 :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl15_ru98;

GHC.List.badHead :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl16_ru99;

GHC.List.head [InlPrag=NOINLINE[1], Occ=LoopBreaker!]
  :: forall a. [a] -> a
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxqc]
        case ds_sxqc of {
          [] -> GHC.List.badHead;
          : x_sxqe [Occ=Once] _ [Occ=Dead] -> x_sxqe;
        };

lvl17_ru9a :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "maximum"#;

lvl18_ru9b :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl17_ru9a;

GHC.List.maximum1 :: GHC.Integer.Type.Integer
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl18_ru9b;

GHC.List.maximum2 :: GHC.Types.Int
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl18_ru9b;

lvl19_ru9c :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl18_ru9b;

GHC.List.maximum_go [Occ=LoopBreaker]
  :: [GHC.Integer.Type.Integer]
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [ds_sxqg eta_sxqh]
        case ds_sxqg of {
          [] -> eta_sxqh;
          : y_sxqj ys_sxqk [Occ=Once*] ->
              case GHC.Integer.Type.leInteger# eta_sxqh y_sxqj of {
                __DEFAULT -> GHC.List.maximum_go ys_sxqk eta_sxqh;
                1# -> GHC.List.maximum_go ys_sxqk y_sxqj;
              };
        };

GHC.List.maximum_$smaximum [InlPrag=INLINABLE]
  :: [GHC.Integer.Type.Integer] -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxqm]
        case ds_sxqm of {
          [] -> GHC.List.maximum1;
          : ipv_sxqo [Occ=Once] ipv1_sxqp [Occ=Once] ->
              GHC.List.maximum_go ipv1_sxqp ipv_sxqo;
        };

lvl20_ru9d :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "minimum"#;

lvl21_ru9e :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl20_ru9d;

GHC.List.minimum1 :: GHC.Integer.Type.Integer
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl21_ru9e;

GHC.List.minimum2 :: GHC.Types.Int
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl21_ru9e;

lvl22_ru9f :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl21_ru9e;

GHC.List.minimum_go [Occ=LoopBreaker]
  :: [GHC.Integer.Type.Integer]
     -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [ds_sxqq eta_sxqr]
        case ds_sxqq of {
          [] -> eta_sxqr;
          : y_sxqt ys_sxqu [Occ=Once*] ->
              case GHC.Integer.Type.leInteger# eta_sxqr y_sxqt of {
                __DEFAULT -> GHC.List.minimum_go ys_sxqu y_sxqt;
                1# -> GHC.List.minimum_go ys_sxqu eta_sxqr;
              };
        };

GHC.List.minimum_$sminimum [InlPrag=INLINABLE]
  :: [GHC.Integer.Type.Integer] -> GHC.Integer.Type.Integer
[GblId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxqw]
        case ds_sxqw of {
          [] -> GHC.List.minimum1;
          : ipv_sxqy [Occ=Once] ipv1_sxqz [Occ=Once] ->
              GHC.List.minimum_go ipv1_sxqz ipv_sxqy;
        };

GHC.List.$wgo [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: [GHC.Types.Int] -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sxqA ww_sxqB]
        case w_sxqA of {
          [] -> ww_sxqB;
          : y_sxqD [Occ=Once!] ys_sxqE [Occ=Once*] ->
              case y_sxqD of {
                GHC.Types.I# y1_sxqG ->
                    case <=# [ww_sxqB y1_sxqG] of {
                      __DEFAULT -> GHC.List.$wgo ys_sxqE ww_sxqB;
                      1# -> GHC.List.$wgo ys_sxqE y1_sxqG;
                    };
              };
        };

GHC.List.maximum_$smaximum1 [InlPrag=NOUSERINLINE[0]]
  :: [GHC.Types.Int] -> GHC.Types.Int
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [w_sxqI]
        case w_sxqI of {
          [] -> GHC.List.maximum2;
          : ipv_sxqK [Occ=Once!] ipv1_sxqL [Occ=Once] ->
              case ipv_sxqK of {
                GHC.Types.I# ww1_sxqN [Occ=Once] ->
                    case GHC.List.$wgo ipv1_sxqL ww1_sxqN of ww2_sxqO {
                      __DEFAULT -> GHC.Types.I# [ww2_sxqO];
                    };
              };
        };

GHC.List.maximum [InlPrag=INLINABLE]
  :: forall a. GHC.Classes.Ord a => [a] -> a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,A,A,A,C(C1(U)),A)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sxqP ds_sxqQ]
        case ds_sxqQ of {
          [] -> lvl19_ru9c;
          : ipv_sxqS [Occ=Once] ipv1_sxqT [Occ=Once] ->
              let-no-escape {
                go2_sxqU [Occ=LoopBreakerT[2]] :: [a_asxy] -> a_asxy -> a_asxy
                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
                    sat-only [$dOrd_sxqP go2_sxqU] \r [ds1_sxqV eta_sxqW]
                        case ds1_sxqV of {
                          [] -> eta_sxqW;
                          : y_sxqY [Occ=Once] ys_sxqZ [Occ=Once] ->
                              let {
                                sat_sxr0 [Occ=Once] :: a_asxy
                                [LclId] =
                                    [$dOrd_sxqP eta_sxqW y_sxqY] \u []
                                        GHC.Classes.max $dOrd_sxqP eta_sxqW y_sxqY;
                              } in  go2_sxqU ys_sxqZ sat_sxr0;
                        };
              } in  go2_sxqU ipv1_sxqT ipv_sxqS;
        };

GHC.List.$wgo1 [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: [GHC.Types.Int] -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sxr1 ww_sxr2]
        case w_sxr1 of {
          [] -> ww_sxr2;
          : y_sxr4 [Occ=Once!] ys_sxr5 [Occ=Once*] ->
              case y_sxr4 of {
                GHC.Types.I# y1_sxr7 ->
                    case <=# [ww_sxr2 y1_sxr7] of {
                      __DEFAULT -> GHC.List.$wgo1 ys_sxr5 y1_sxr7;
                      1# -> GHC.List.$wgo1 ys_sxr5 ww_sxr2;
                    };
              };
        };

GHC.List.minimum_$sminimum1 [InlPrag=NOUSERINLINE[0]]
  :: [GHC.Types.Int] -> GHC.Types.Int
[GblId, Arity=1, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [w_sxr9]
        case w_sxr9 of {
          [] -> GHC.List.minimum2;
          : ipv_sxrb [Occ=Once!] ipv1_sxrc [Occ=Once] ->
              case ipv_sxrb of {
                GHC.Types.I# ww1_sxre [Occ=Once] ->
                    case GHC.List.$wgo1 ipv1_sxrc ww1_sxre of ww2_sxrf {
                      __DEFAULT -> GHC.Types.I# [ww2_sxrf];
                    };
              };
        };

GHC.List.minimum [InlPrag=INLINABLE]
  :: forall a. GHC.Classes.Ord a => [a] -> a
[GblId,
 Arity=2,
 Str=<L,U(A,A,A,A,A,A,A,C(C1(U)))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dOrd_sxrg ds_sxrh]
        case ds_sxrh of {
          [] -> lvl22_ru9f;
          : ipv_sxrj [Occ=Once] ipv1_sxrk [Occ=Once] ->
              let-no-escape {
                go2_sxrl [Occ=LoopBreakerT[2]] :: [a_asxY] -> a_asxY -> a_asxY
                [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
                    sat-only [$dOrd_sxrg go2_sxrl] \r [ds1_sxrm eta_sxrn]
                        case ds1_sxrm of {
                          [] -> eta_sxrn;
                          : y_sxrp [Occ=Once] ys_sxrq [Occ=Once] ->
                              let {
                                sat_sxrr [Occ=Once] :: a_asxY
                                [LclId] =
                                    [$dOrd_sxrg eta_sxrn y_sxrp] \u []
                                        GHC.Classes.min $dOrd_sxrg eta_sxrn y_sxrp;
                              } in  go2_sxrl ys_sxrq sat_sxrr;
                        };
              } in  go2_sxrl ipv1_sxrk ipv_sxrj;
        };

lvl23_ru9g :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1'"#;

lvl24_ru9h :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl23_ru9g;

GHC.List.foldl1'1 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl24_ru9h;

lvl25_ru9i :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "foldl1"#;

lvl26_ru9j :: [GHC.Types.Char]
[GblId] =
    [] \u [] GHC.CString.unpackCString# lvl25_ru9i;

GHC.List.foldl2 :: forall a. a
[GblId, Str=x] =
    [] \u [] GHC.List.errorEmptyList lvl26_ru9j;

$wgo2_ru9k :: forall a b c. [(a, b, c)] -> (# [a], [b], [c] #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [w_sxrs]
        case w_sxrs of {
          [] -> (#,,#) [GHC.Types.[] GHC.Types.[] GHC.Types.[]];
          : y_sxru [Occ=Once!] ys_sxrv [Occ=Once] ->
              case y_sxru of {
                (,,) a1_sxrx [Occ=Once] b1_sxry [Occ=Once] c1_sxrz [Occ=Once] ->
                    let {
                      ds_sxrA [Dmd=<L,U(1*U,1*U,1*U)>] :: ([a_stLF], [b_stLG], [c_stLH])
                      [LclId] =
                          [ys_sxrv] \u []
                              case $wgo2_ru9k ys_sxrv of {
                                (#,,#) ww1_sxrC [Occ=Once]
                                       ww2_sxrD [Occ=Once]
                                       ww3_sxrE [Occ=Once] ->
                                    (,,) [ww1_sxrC ww2_sxrD ww3_sxrE];
                              }; } in
                    let {
                      sat_sxrV [Occ=Once] :: [c_stLH]
                      [LclId] =
                          [ds_sxrA] \u []
                              case ds_sxrA of {
                                (,,) _ [Occ=Dead] _ [Occ=Dead] cs_sxrU [Occ=Once] -> cs_sxrU;
                              }; } in
                    let {
                      sat_sxrW [Occ=Once] :: [c_stLH]
                      [LclId] =
                          CCCS :! [c1_sxrz sat_sxrV]; } in
                    let {
                      sat_sxrP [Occ=Once] :: [b_stLG]
                      [LclId] =
                          [ds_sxrA] \u []
                              case ds_sxrA of {
                                (,,) _ [Occ=Dead] bs_sxrN [Occ=Once] _ [Occ=Dead] -> bs_sxrN;
                              }; } in
                    let {
                      sat_sxrQ [Occ=Once] :: [b_stLG]
                      [LclId] =
                          CCCS :! [b1_sxry sat_sxrP]; } in
                    let {
                      sat_sxrJ [Occ=Once] :: [a_stLF]
                      [LclId] =
                          [ds_sxrA] \u []
                              case ds_sxrA of {
                                (,,) as_sxrG [Occ=Once] _ [Occ=Dead] _ [Occ=Dead] -> as_sxrG;
                              }; } in
                    let {
                      sat_sxrK [Occ=Once] :: [a_stLF]
                      [LclId] =
                          CCCS :! [a1_sxrx sat_sxrJ];
                    } in  (#,,#) [sat_sxrK sat_sxrQ sat_sxrW];
              };
        };

go_ru9l :: forall a b c. [(a, b, c)] -> ([a], [b], [c])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    sat-only [] \r [w_sxrX]
        case $wgo2_ru9k w_sxrX of {
          (#,,#) ww1_sxrZ [Occ=Once]
                 ww2_sxs0 [Occ=Once]
                 ww3_sxs1 [Occ=Once] ->
              (,,) [ww1_sxrZ ww2_sxs0 ww3_sxs1];
        };

GHC.List.unzip3 [InlPrag=INLINE (sat-args=0)]
  :: forall a b c. [(a, b, c)] -> ([a], [b], [c])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [eta_B1] go_ru9l eta_B1;

$wgo3_ru9m :: forall a b. [(a, b)] -> (# [a], [b] #)
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    sat-only [] \r [w_sxs2]
        case w_sxs2 of {
          [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
          : y_sxs4 [Occ=Once!] ys_sxs5 [Occ=Once] ->
              case y_sxs4 of {
                (,) a1_sxs7 [Occ=Once] b1_sxs8 [Occ=Once] ->
                    let {
                      ds_sxs9 [Dmd=<L,U(1*U,1*U)>] :: ([a_stLy], [b_stLz])
                      [LclId] =
                          [ys_sxs5] \u []
                              case $wgo3_ru9m ys_sxs5 of {
                                (#,#) ww1_sxsb [Occ=Once] ww2_sxsc [Occ=Once] ->
                                    (,) [ww1_sxsb ww2_sxsc];
                              }; } in
                    let {
                      sat_sxsl [Occ=Once] :: [b_stLz]
                      [LclId] =
                          [ds_sxs9] \u []
                              case ds_sxs9 of {
                                (,) _ [Occ=Dead] bs_sxsk [Occ=Once] -> bs_sxsk;
                              }; } in
                    let {
                      sat_sxsm [Occ=Once] :: [b_stLz]
                      [LclId] =
                          CCCS :! [b1_sxs8 sat_sxsl]; } in
                    let {
                      sat_sxsg [Occ=Once] :: [a_stLy]
                      [LclId] =
                          [ds_sxs9] \u []
                              case ds_sxs9 of {
                                (,) as_sxse [Occ=Once] _ [Occ=Dead] -> as_sxse;
                              }; } in
                    let {
                      sat_sxsh [Occ=Once] :: [a_stLy]
                      [LclId] =
                          CCCS :! [a1_sxs7 sat_sxsg];
                    } in  (#,#) [sat_sxsh sat_sxsm];
              };
        };

go1_ru9n :: forall a b. [(a, b)] -> ([a], [b])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    sat-only [] \r [w_sxsn]
        case $wgo3_ru9m w_sxsn of {
          (#,#) ww1_sxsp [Occ=Once] ww2_sxsq [Occ=Once] ->
              (,) [ww1_sxsp ww2_sxsq];
        };

GHC.List.unzip [InlPrag=INLINE (sat-args=0)]
  :: forall a b. [(a, b)] -> ([a], [b])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [eta_B1] go1_ru9n eta_B1;

GHC.List.zipWith3
  :: forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><S,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [z_sxsr eta_sxss eta1_sxst eta2_sxsu]
        let {
          go2_sxsv [Occ=LoopBreaker]
            :: [a_asln] -> [b_aslo] -> [c_aslp] -> [d_aslq]
          [LclId, Arity=3, Str=<S,1*U><L,1*U><L,1*U>, Unf=OtherCon []] =
              sat-only [z_sxsr go2_sxsv] \r [ds_sxsw ds1_sxsx ds2_sxsy]
                  case ds_sxsw of {
                    [] -> [] [];
                    : a1_sxsA [Occ=Once] as_sxsB [Occ=Once] ->
                        case ds1_sxsx of {
                          [] -> [] [];
                          : b1_sxsD [Occ=Once] bs_sxsE [Occ=Once] ->
                              case ds2_sxsy of {
                                [] -> [] [];
                                : c1_sxsG [Occ=Once] cs_sxsH [Occ=Once] ->
                                    let {
                                      sat_sxsJ [Occ=Once] :: [d_aslq]
                                      [LclId] =
                                          [go2_sxsv as_sxsB bs_sxsE cs_sxsH] \u []
                                              go2_sxsv as_sxsB bs_sxsE cs_sxsH; } in
                                    let {
                                      sat_sxsI [Occ=Once] :: d_aslq
                                      [LclId] =
                                          [z_sxsr a1_sxsA b1_sxsD c1_sxsG] \u []
                                              z_sxsr a1_sxsA b1_sxsD c1_sxsG;
                                    } in  : [sat_sxsI sat_sxsJ];
                              };
                        };
                  };
        } in  go2_sxsv eta_sxss eta1_sxst eta2_sxsu;

GHC.List.zipWithFB [InlPrag=INLINE[0] (sat-args=2)]
  :: forall a b c d e.
     (a -> b -> c) -> (d -> e -> a) -> d -> e -> b -> c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,1*C1(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [c1_sxsK f_sxsL x_sxsM y_sxsN r_sxsO]
        let {
          sat_sxsP [Occ=Once] :: a_aslZ
          [LclId] =
              [f_sxsL x_sxsM y_sxsN] \u [] f_sxsL x_sxsM y_sxsN;
        } in  c1_sxsK sat_sxsP r_sxsO;

GHC.List.zip3 [Occ=LoopBreaker]
  :: forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sxsQ ds1_sxsR ds2_sxsS]
        case ds_sxsQ of {
          [] -> [] [];
          : a1_sxsU [Occ=Once] as_sxsV [Occ=Once] ->
              case ds1_sxsR of {
                [] -> [] [];
                : b1_sxsX [Occ=Once] bs_sxsY [Occ=Once] ->
                    case ds2_sxsS of {
                      [] -> [] [];
                      : c1_sxt0 [Occ=Once] cs_sxt1 [Occ=Once] ->
                          let {
                            sat_sxt3 [Occ=Once] :: [(a_asmz, b_asmA, c_asmB)]
                            [LclId] =
                                [as_sxsV bs_sxsY cs_sxt1] \u []
                                    GHC.List.zip3 as_sxsV bs_sxsY cs_sxt1; } in
                          let {
                            sat_sxt2 [Occ=Once] :: (a_asmz, b_asmA, c_asmB)
                            [LclId] =
                                CCCS (,,)! [a1_sxsU b1_sxsX c1_sxt0];
                          } in  : [sat_sxt2 sat_sxt3];
                    };
              };
        };

GHC.List.zipFB [InlPrag=INLINE[0] (sat-args=1)]
  :: forall a b c d. ((a, b) -> c -> d) -> a -> b -> c -> d
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [c1_sxt4 x_sxt5 y_sxt6 r_sxt7]
        let {
          sat_sxt8 [Occ=Once] :: (a_asmK, b_asmL)
          [LclId] =
              CCCS (,)! [x_sxt5 y_sxt6];
        } in  c1_sxt4 sat_sxt8 r_sxt7;

GHC.List.foldr2_left
  :: forall a b c d.
     (a -> b -> c -> d) -> d -> a -> ([b] -> c) -> [b] -> d
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(C1(U)))><L,1*U><L,U><L,1*C1(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [_k_sxt9 z_sxta _x_sxtb _r_sxtc ds_sxtd]
        case ds_sxtd of {
          [] -> z_sxta;
          : y_sxtf [Occ=Once] ys_sxtg [Occ=Once] ->
              let {
                sat_sxth [Occ=Once] :: c_asmZ
                [LclId] =
                    [_r_sxtc ys_sxtg] \u [] _r_sxtc ys_sxtg;
              } in  _k_sxt9 _x_sxtb y_sxtf sat_sxth;
        };

GHC.List.zip [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a b. [a] -> [b] -> [(a, b)]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sxti _bs_sxtj]
        case ds_sxti of {
          [] -> [] [];
          : ipv_sxtl [Occ=Once] ipv1_sxtm [Occ=Once] ->
              case _bs_sxtj of {
                [] -> [] [];
                : ipv2_sxto [Occ=Once] ipv3_sxtp [Occ=Once] ->
                    let {
                      sat_sxtr [Occ=Once] :: [(a_asmP, b_asmQ)]
                      [LclId] =
                          [ipv1_sxtm ipv3_sxtp] \u [] GHC.List.zip ipv1_sxtm ipv3_sxtp; } in
                    let {
                      sat_sxtq [Occ=Once] :: (a_asmP, b_asmQ)
                      [LclId] =
                          CCCS (,)! [ipv_sxtl ipv2_sxto];
                    } in  : [sat_sxtq sat_sxtr];
              };
        };
GHC.List.zipWith [InlPrag=NOINLINE[1], Occ=LoopBreaker!]
  :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sxts eta_sxtt eta1_sxtu]
        let {
          go2_sxtv [Occ=LoopBreaker] :: [a_asm5] -> [b_asm6] -> [c_asm7]
          [LclId, Arity=2, Str=<S,1*U><L,1*U>, Unf=OtherCon []] =
              sat-only [f_sxts go2_sxtv] \r [ds_sxtw ds1_sxtx]
                  case ds_sxtw of {
                    [] -> [] [];
                    : ipv_sxtz [Occ=Once] ipv1_sxtA [Occ=Once] ->
                        case ds1_sxtx of {
                          [] -> [] [];
                          : ipv2_sxtC [Occ=Once] ipv3_sxtD [Occ=Once] ->
                              let {
                                sat_sxtF [Occ=Once] :: [c_asm7]
                                [LclId] =
                                    [go2_sxtv ipv1_sxtA ipv3_sxtD] \u []
                                        go2_sxtv ipv1_sxtA ipv3_sxtD; } in
                              let {
                                sat_sxtE [Occ=Once] :: c_asm7
                                [LclId] =
                                    [f_sxts ipv_sxtz ipv2_sxtC] \u [] f_sxts ipv_sxtz ipv2_sxtC;
                              } in  : [sat_sxtE sat_sxtF];
                        };
                  };
        } in  go2_sxtv eta_sxtt eta1_sxtu;
GHC.List.foldr2 [InlPrag=INLINE[0] (sat-args=2), Occ=LoopBreaker!]
  :: forall a b c. (a -> b -> c -> c) -> c -> [a] -> [b] -> c
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,C(C1(C1(U)))><L,U><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [k_sxtG z_sxtH eta_sxtI eta1_sxtJ]
        let {
          go2_sxtK [Occ=LoopBreaker] :: [a_asn2] -> [b_asn3] -> c_asn4
          [LclId, Arity=2, Str=<S,1*U><L,1*U>, Unf=OtherCon []] =
              sat-only [k_sxtG z_sxtH go2_sxtK] \r [ds_sxtL _ys_sxtM]
                  case ds_sxtL of {
                    [] -> z_sxtH;
                    : ipv_sxtO [Occ=Once] ipv1_sxtP [Occ=Once] ->
                        case _ys_sxtM of {
                          [] -> z_sxtH;
                          : ipv2_sxtR [Occ=Once] ipv3_sxtS [Occ=Once] ->
                              let {
                                sat_sxtT [Occ=Once] :: c_asn4
                                [LclId] =
                                    [go2_sxtK ipv1_sxtP ipv3_sxtS] \u []
                                        go2_sxtK ipv1_sxtP ipv3_sxtS;
                              } in  k_sxtG ipv_sxtO ipv2_sxtR sat_sxtT;
                        };
                  };
        } in  go2_sxtK eta_sxtI eta1_sxtJ;

GHC.List.concat_go [Occ=LoopBreaker] :: forall a. [[a]] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxtU]
        case ds_sxtU of {
          [] -> [] [];
          : y_sxtW [Occ=Once] ys_sxtX [Occ=Once] ->
              let {
                sat_sxtY [Occ=Once, Dmd=<L,1*U>] :: [a_asob]
                [LclId] =
                    [ys_sxtX] \s [] GHC.List.concat_go ys_sxtX;
              } in  GHC.Base.++ y_sxtW sat_sxtY;
        };

GHC.List.concat [InlPrag=NOINLINE[1]] :: forall a. [[a]] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1] GHC.List.concat_go eta_B1;

GHC.List.concatMap [InlPrag=NOINLINE[1]]
  :: forall a b. (a -> [b]) -> [a] -> [b]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sxtZ eta_sxu0]
        let {
          go2_sxu1 [Occ=LoopBreaker] :: [a_asog] -> [b_asoh]
          [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
              sat-only [f_sxtZ go2_sxu1] \r [ds_sxu2]
                  case ds_sxu2 of {
                    [] -> [] [];
                    : y_sxu4 [Occ=Once] ys_sxu5 [Occ=Once] ->
                        let {
                          sat_sxu7 [Occ=Once, Dmd=<L,1*U>] :: [b_asoh]
                          [LclId] =
                              [go2_sxu1 ys_sxu5] \s [] go2_sxu1 ys_sxu5;
                        } in 
                          case f_sxtZ y_sxu4 of sat_sxu6 {
                            __DEFAULT -> GHC.Base.++ sat_sxu6 sat_sxu7;
                          };
                  };
        } in  go2_sxu1 eta_sxu0;

GHC.List.lookup [Occ=LoopBreaker]
  :: forall a b.
     GHC.Classes.Eq a =>
     a -> [(a, b)] -> GHC.Base.Maybe b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sxu8 _key_sxu9 ds_sxua]
        case ds_sxua of {
          [] -> GHC.Base.Nothing [];
          : ds1_sxuc [Occ=Once!] xys_sxud [Occ=Once] ->
              case ds1_sxuc of {
                (,) x_sxuf [Occ=Once] y_sxug [Occ=Once] ->
                    case GHC.Classes.== $dEq_sxu8 _key_sxu9 x_sxuf of {
                      GHC.Types.False -> GHC.List.lookup $dEq_sxu8 _key_sxu9 xys_sxud;
                      GHC.Types.True -> GHC.Base.Just [y_sxug];
                    };
              };
        };

GHC.List.notElem [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. GHC.Classes.Eq a => a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(A,C(C1(U)))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sxui ds_sxuj ds1_sxuk]
        case ds1_sxuk of {
          [] -> GHC.Types.True [];
          : y_sxum [Occ=Once] ys_sxun [Occ=Once] ->
              case GHC.Classes./= $dEq_sxui ds_sxuj y_sxum of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> GHC.List.notElem $dEq_sxui ds_sxuj ys_sxun;
              };
        };

GHC.List.elem [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. GHC.Classes.Eq a => a -> [a] -> GHC.Types.Bool
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,U(C(C1(U)),A)><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [$dEq_sxup ds_sxuq ds1_sxur]
        case ds1_sxur of {
          [] -> GHC.Types.False [];
          : y_sxut [Occ=Once] ys_sxuu [Occ=Once] ->
              case GHC.Classes.== $dEq_sxup ds_sxuq y_sxut of {
                GHC.Types.False -> GHC.List.elem $dEq_sxup ds_sxuq ys_sxuu;
                GHC.Types.True -> GHC.Types.True [];
              };
        };

GHC.List.all [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sxuw ds1_sxux]
        case ds1_sxux of {
          [] -> GHC.Types.True [];
          : x_sxuz [Occ=Once] xs_sxuA [Occ=Once] ->
              case ds_sxuw x_sxuz of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> GHC.List.all ds_sxuw xs_sxuA;
              };
        };

GHC.List.any [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> GHC.Types.Bool
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sxuC ds1_sxuD]
        case ds1_sxuD of {
          [] -> GHC.Types.False [];
          : x_sxuF [Occ=Once] xs_sxuG [Occ=Once] ->
              case ds_sxuC x_sxuF of {
                GHC.Types.False -> GHC.List.any ds_sxuC xs_sxuG;
                GHC.Types.True -> GHC.Types.True [];
              };
        };

GHC.List.or [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: [GHC.Types.Bool] -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxuI]
        case ds_sxuI of {
          [] -> GHC.Types.False [];
          : x_sxuK [Occ=Once!] xs_sxuL [Occ=Once] ->
              case x_sxuK of {
                GHC.Types.False -> GHC.List.or xs_sxuL;
                GHC.Types.True -> GHC.Types.True [];
              };
        };

GHC.List.and [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: [GHC.Types.Bool] -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxuN]
        case ds_sxuN of {
          [] -> GHC.Types.True [];
          : x_sxuP [Occ=Once!] xs_sxuQ [Occ=Once] ->
              case x_sxuP of {
                GHC.Types.False -> GHC.Types.False [];
                GHC.Types.True -> GHC.List.and xs_sxuQ;
              };
        };

GHC.List.reverse1 [Occ=LoopBreaker] :: forall a. [a] -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,U>,
 Unf=OtherCon []] =
    [] \r [ds_sxuS a1_sxuT]
        case ds_sxuS of {
          [] -> a1_sxuT;
          : x_sxuV [Occ=Once] xs_sxuW [Occ=Once] ->
              let {
                sat_sxuX [Occ=Once] :: [a_asp0]
                [LclId] =
                    CCCS :! [x_sxuV a1_sxuT];
              } in  GHC.List.reverse1 xs_sxuW sat_sxuX;
        };

GHC.List.reverse :: forall a. [a] -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [l_sxuY] GHC.List.reverse1 l_sxuY GHC.Types.[];

GHC.List.$wbreak [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> (# [a], [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sxuZ w1_sxv0]
        case w1_sxv0 of wild_sxv1 {
          [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
          : x_sxv2 xs'_sxv3 [Occ=Once] ->
              case w_sxuZ x_sxv2 of {
                GHC.Types.False ->
                    let {
                      ds_sxv5 [Dmd=<L,U(1*U,1*U)>] :: ([a_stKr], [a_stKr])
                      [LclId] =
                          [w_sxuZ xs'_sxv3] \u []
                              case GHC.List.$wbreak w_sxuZ xs'_sxv3 of {
                                (#,#) ww1_sxv7 [Occ=Once] ww2_sxv8 [Occ=Once] ->
                                    (,) [ww1_sxv7 ww2_sxv8];
                              }; } in
                    let {
                      sat_sxvh [Occ=Once] :: [a_stKr]
                      [LclId] =
                          [ds_sxv5] \u []
                              case ds_sxv5 of {
                                (,) _ [Occ=Dead] zs_sxvg [Occ=Once] -> zs_sxvg;
                              }; } in
                    let {
                      sat_sxvc [Occ=Once] :: [a_stKr]
                      [LclId] =
                          [ds_sxv5] \u []
                              case ds_sxv5 of {
                                (,) ys_sxva [Occ=Once] _ [Occ=Dead] -> ys_sxva;
                              }; } in
                    let {
                      sat_sxvd [Occ=Once] :: [a_stKr]
                      [LclId] =
                          CCCS :! [x_sxv2 sat_sxvc];
                    } in  (#,#) [sat_sxvd sat_sxvh];
                GHC.Types.True -> (#,#) [GHC.Types.[] wild_sxv1];
              };
        };

GHC.List.break [InlPrag=NOUSERINLINE[0]]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>m,
 Unf=OtherCon []] =
    [] \r [w_sxvi w1_sxvj]
        case GHC.List.$wbreak w_sxvi w1_sxvj of {
          (#,#) ww1_sxvl [Occ=Once] ww2_sxvm [Occ=Once] ->
              (,) [ww1_sxvl ww2_sxvm];
        };

GHC.List.$wspan [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> (# [a], [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sxvn w1_sxvo]
        case w1_sxvo of wild_sxvp {
          [] -> (#,#) [GHC.Types.[] GHC.Types.[]];
          : x_sxvq xs'_sxvr [Occ=Once] ->
              case w_sxvn x_sxvq of {
                GHC.Types.False -> (#,#) [GHC.Types.[] wild_sxvp];
                GHC.Types.True ->
                    let {
                      ds_sxvt [Dmd=<L,U(1*U,1*U)>] :: ([a_stKk], [a_stKk])
                      [LclId] =
                          [w_sxvn xs'_sxvr] \u []
                              case GHC.List.$wspan w_sxvn xs'_sxvr of {
                                (#,#) ww1_sxvv [Occ=Once] ww2_sxvw [Occ=Once] ->
                                    (,) [ww1_sxvv ww2_sxvw];
                              }; } in
                    let {
                      sat_sxvF [Occ=Once] :: [a_stKk]
                      [LclId] =
                          [ds_sxvt] \u []
                              case ds_sxvt of {
                                (,) _ [Occ=Dead] zs_sxvE [Occ=Once] -> zs_sxvE;
                              }; } in
                    let {
                      sat_sxvA [Occ=Once] :: [a_stKk]
                      [LclId] =
                          [ds_sxvt] \u []
                              case ds_sxvt of {
                                (,) ys_sxvy [Occ=Once] _ [Occ=Dead] -> ys_sxvy;
                              }; } in
                    let {
                      sat_sxvB [Occ=Once] :: [a_stKk]
                      [LclId] =
                          CCCS :! [x_sxvq sat_sxvA];
                    } in  (#,#) [sat_sxvB sat_sxvF];
              };
        };

GHC.List.span [InlPrag=NOUSERINLINE[0]]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>m,
 Unf=OtherCon []] =
    [] \r [w_sxvG w1_sxvH]
        case GHC.List.$wspan w_sxvG w1_sxvH of {
          (#,#) ww1_sxvJ [Occ=Once] ww2_sxvK [Occ=Once] ->
              (,) [ww1_sxvJ ww2_sxvK];
        };

GHC.List.takeFB [InlPrag=INLINE[0] (sat-args=4)]
  :: forall a b.
     (a -> b -> b)
     -> b -> a -> (GHC.Types.Int -> b) -> GHC.Types.Int -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><L,U><L,U><L,1*C1(U)><S(S),1*U(1*U)>,
 Unf=OtherCon []] =
    [] \r [eta_sxvL eta1_sxvM eta2_sxvN eta3_sxvO m_sxvP]
        case m_sxvP of {
          GHC.Types.I# ds_sxvR [Occ=Once!] ->
              case ds_sxvR of ds1_sxvS {
                __DEFAULT ->
                    let {
                      sat_sxvV [Occ=Once] :: b_asro
                      [LclId] =
                          [eta3_sxvO ds1_sxvS] \u []
                              case -# [ds1_sxvS 1#] of sat_sxvT {
                                __DEFAULT ->
                                    let {
                                      sat_sxvU [Occ=Once] :: GHC.Types.Int
                                      [LclId] =
                                          CCCS GHC.Types.I#! [sat_sxvT];
                                    } in  eta3_sxvO sat_sxvU;
                              };
                    } in  eta_sxvL eta2_sxvN sat_sxvV;
                1# -> eta_sxvL eta2_sxvN eta1_sxvM;
              };
        };

GHC.List.flipSeqTake [InlPrag=INLINE[0] (sat-args=2)]
  :: forall a. a -> GHC.Types.Int -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*H>,
 Unf=OtherCon []] =
    [] \r [x_sxvW _n_sxvX]
        case _n_sxvX of { GHC.Types.I# _ [Occ=Dead] -> x_sxvW; };

GHC.List.$wunsafeTake [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. GHC.Prim.Int# -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ww_sxw0 w_sxw1]
        case w_sxw1 of {
          [] -> [] [];
          : ipv_sxw3 [Occ=Once*] ipv1_sxw4 [Occ=Once] ->
              case ww_sxw0 of ds_sxw5 {
                __DEFAULT ->
                    let {
                      sat_sxw7 [Occ=Once] :: [a_stK6]
                      [LclId] =
                          [ipv1_sxw4 ds_sxw5] \u []
                              case -# [ds_sxw5 1#] of sat_sxw6 {
                                __DEFAULT -> GHC.List.$wunsafeTake sat_sxw6 ipv1_sxw4;
                              };
                    } in  : [ipv_sxw3 sat_sxw7];
                1# -> : [ipv_sxw3 GHC.Types.[]];
              };
        };

GHC.List.unsafeTake [InlPrag=NOUSERINLINE[0]]
  :: forall a. GHC.Types.Int -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(1*U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sxw8 w1_sxw9]
        case w_sxw8 of {
          GHC.Types.I# ww1_sxwb [Occ=Once] ->
              GHC.List.$wunsafeTake ww1_sxwb w1_sxw9;
        };

GHC.List.take [InlPrag=INLINE[1] (sat-args=2)]
  :: forall a. GHC.Types.Int -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,1*U>,
 Unf=OtherCon []] =
    [] \r [eta_sxwc eta1_sxwd]
        case eta_sxwc of {
          GHC.Types.I# y_sxwf ->
              case <# [0# y_sxwf] of {
                __DEFAULT -> [] [];
                1# -> GHC.List.$wunsafeTake y_sxwf eta1_sxwd;
              };
        };

GHC.List.dropWhile [Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sxwh ds1_sxwi]
        case ds1_sxwi of wild_sxwj {
          [] -> [] [];
          : x_sxwk [Occ=Once] xs'_sxwl [Occ=Once] ->
              case ds_sxwh x_sxwk of {
                GHC.Types.False -> wild_sxwj;
                GHC.Types.True -> GHC.List.dropWhile ds_sxwh xs'_sxwl;
              };
        };

GHC.List.takeWhileFB [InlPrag=INLINE[0] (sat-args=3),
                      Occ=LoopBreaker!]
  :: forall a b.
     (a -> GHC.Types.Bool) -> (a -> b -> b) -> b -> a -> b -> b
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(S),1*C1(U)><L,1*C1(C1(U))><L,1*U><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [p_sxwn c_sxwo n_sxwp x_sxwq r_sxwr]
        case p_sxwn x_sxwq of {
          GHC.Types.False -> n_sxwp;
          GHC.Types.True -> c_sxwo x_sxwq r_sxwr;
        };

GHC.List.takeWhile [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [ds_sxwt ds1_sxwu]
        case ds1_sxwu of {
          [] -> [] [];
          : x_sxww xs_sxwx [Occ=Once] ->
              case ds_sxwt x_sxww of {
                GHC.Types.False -> [] [];
                GHC.Types.True ->
                    let {
                      sat_sxwz [Occ=Once] :: [a_ass4]
                      [LclId] =
                          [ds_sxwt xs_sxwx] \u [] GHC.List.takeWhile ds_sxwt xs_sxwx;
                    } in  : [x_sxww sat_sxwz];
              };
        };

GHC.List.repeat [InlPrag=INLINE[0] (sat-args=1), Occ=LoopBreaker!]
  :: forall a. a -> [a]
[GblId, Arity=1, Caf=NoCafRefs, Str=<L,U>, Unf=OtherCon []] =
    [] \r [x_sxwA]
        let {
          xs_sxwB [Occ=LoopBreaker] :: [a_assp]
          [LclId, Unf=OtherCon []] =
              CCCS :! [x_sxwA xs_sxwB];
        } in  xs_sxwB;
GHC.List.repeatFB [InlPrag=INLINE[0] (sat-args=2),
                   Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> a -> b
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,U>,
 Unf=OtherCon []] =
    [] \r [c_sxwC x_sxwD]
        let {
          xs_sxwE [Occ=LoopBreaker] :: b_assi
          [LclId] =
              [c_sxwC x_sxwD xs_sxwE] \u [] c_sxwC x_sxwD xs_sxwE;
        } in  xs_sxwE;

GHC.List.replicate [InlPrag=INLINE (sat-args=2)]
  :: forall a. GHC.Types.Int -> a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [n_sxwF x_sxwG]
        case n_sxwF of {
          GHC.Types.I# y_sxwI ->
              case <# [0# y_sxwI] of {
                __DEFAULT -> [] [];
                1# ->
                    let {
                      lvl31_sxwK [Occ=OnceL] :: [a_assx]
                      [LclId, Unf=OtherCon []] =
                          CCCS :! [x_sxwG GHC.Types.[]]; } in
                    let {
                      $wxs_sxwL [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
                        :: GHC.Prim.Int# -> [a_assx]
                      [LclId, Arity=1, Str=<S,1*U>, Unf=OtherCon []] =
                          sat-only [x_sxwG lvl31_sxwK $wxs_sxwL] \r [ww_sxwM]
                              case ww_sxwM of ds_sxwN {
                                __DEFAULT ->
                                    let {
                                      sat_sxwP [Occ=Once] :: [a_assx]
                                      [LclId] =
                                          [$wxs_sxwL ds_sxwN] \u []
                                              case -# [ds_sxwN 1#] of sat_sxwO {
                                                __DEFAULT -> $wxs_sxwL sat_sxwO;
                                              };
                                    } in  : [x_sxwG sat_sxwP];
                                1# -> lvl31_sxwK;
                              };
                    } in  $wxs_sxwL y_sxwI;
              };
        };

GHC.List.$witerate' [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> a) -> a -> (# a, [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sxwQ w1_sxwR]
        case w_sxwQ w1_sxwR of x'_sxwS {
          __DEFAULT ->
              let {
                sat_sxwW [Occ=Once] :: [a_stJT]
                [LclId] =
                    [w_sxwQ x'_sxwS] \u []
                        case GHC.List.$witerate' w_sxwQ x'_sxwS of {
                          (#,#) ww1_sxwU [Occ=Once] ww2_sxwV [Occ=Once] ->
                              : [ww1_sxwU ww2_sxwV];
                        };
              } in  (#,#) [w1_sxwR sat_sxwW];
        };

GHC.List.iterate'FB [InlPrag=INLINE[0] (sat-args=3),
                     Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> (a -> a) -> a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><C(S),C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [c_sxwX f_sxwY x0_sxwZ]
        let {
          go2_sxx0 [Occ=LoopBreaker] :: a_assB -> b_assC
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [c_sxwX f_sxwY go2_sxx0] \r [x_sxx1]
                  case f_sxwY x_sxx1 of x'_sxx2 {
                    __DEFAULT ->
                        let {
                          sat_sxx3 [Occ=Once] :: b_assC
                          [LclId] =
                              [go2_sxx0 x'_sxx2] \u [] go2_sxx0 x'_sxx2;
                        } in  c_sxwX x_sxx1 sat_sxx3;
                  };
        } in  go2_sxx0 x0_sxwZ;
GHC.List.iterate' [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker!]
  :: forall a. (a -> a) -> a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(S),C(U)><L,U>m2,
 Unf=OtherCon []] =
    [] \r [w_sxx4 w1_sxx5]
        case GHC.List.$witerate' w_sxx4 w1_sxx5 of {
          (#,#) ww1_sxx7 [Occ=Once] ww2_sxx8 [Occ=Once] ->
              : [ww1_sxx7 ww2_sxx8];
        };

GHC.List.$witerate [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> a) -> a -> (# a, [a] #)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [w_sxx9 w1_sxxa]
        let {
          sat_sxxf [Occ=Once] :: [a_stJL]
          [LclId] =
              [w_sxx9 w1_sxxa] \u []
                  let {
                    sat_sxxb [Occ=Once] :: a_stJL
                    [LclId] =
                        [w_sxx9 w1_sxxa] \u [] w_sxx9 w1_sxxa;
                  } in 
                    case GHC.List.$witerate w_sxx9 sat_sxxb of {
                      (#,#) ww1_sxxd [Occ=Once] ww2_sxxe [Occ=Once] ->
                          : [ww1_sxxd ww2_sxxe];
                    };
        } in  (#,#) [w1_sxxa sat_sxxf];

GHC.List.iterateFB [InlPrag=INLINE[0] (sat-args=3),
                    Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> (a -> a) -> a -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<C(C(S)),C(C1(U))><L,C(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [c_sxxg f_sxxh x0_sxxi]
        let {
          go2_sxxj [Occ=LoopBreaker] :: a_astf -> b_astg
          [LclId, Arity=1, Str=<L,U>, Unf=OtherCon []] =
              sat-only [c_sxxg f_sxxh go2_sxxj] \r [x_sxxk]
                  let {
                    sat_sxxm [Occ=Once] :: b_astg
                    [LclId] =
                        [f_sxxh go2_sxxj x_sxxk] \u []
                            let {
                              sat_sxxl [Occ=Once] :: a_astf
                              [LclId] =
                                  [f_sxxh x_sxxk] \u [] f_sxxh x_sxxk;
                            } in  go2_sxxj sat_sxxl;
                  } in  c_sxxg x_sxxk sat_sxxm;
        } in  go2_sxxj x0_sxxi;
GHC.List.iterate [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker!]
  :: forall a. (a -> a) -> a -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><L,U>m2,
 Unf=OtherCon []] =
    [] \r [w_sxxn w1_sxxo]
        case GHC.List.$witerate w_sxxn w1_sxxo of {
          (#,#) ww1_sxxq [Occ=Once] ww2_sxxr [Occ=Once] ->
              : [ww1_sxxq ww2_sxxr];
        };

lvl27_ru9o :: GHC.Prim.Addr#
[GblId, Caf=NoCafRefs, Unf=OtherCon []] =
    "GHC/List.hs:411:34-55|qs@(q : _)"#;

lvl28_ru9p :: forall a. ([a], a)
[GblId, Str=x] =
    [] \u [] Control.Exception.Base.patError lvl27_ru9o;

GHC.List.scanr1 [Occ=LoopBreaker]
  :: forall a. (a -> a -> a) -> [a] -> [a]
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxxs ds1_sxxt]
        case ds1_sxxt of {
          [] -> [] [];
          : x_sxxv [Occ=Once*] ds2_sxxw [Occ=Once!] ->
              case ds2_sxxw of wild1_sxxx {
                [] -> : [x_sxxv GHC.Types.[]];
                : _ [Occ=Dead] _ [Occ=Dead] ->
                    let {
                      ds3_sxxA [Dmd=<L,U(1*U,1*U)>] :: ([a_astA], a_astA)
                      [LclId] =
                          [ds_sxxs wild1_sxxx] \u []
                              case GHC.List.scanr1 ds_sxxs wild1_sxxx of wild2_sxxB {
                                [] -> lvl28_ru9p;
                                : q_sxxC [Occ=Once] _ [Occ=Dead] -> (,) [wild2_sxxB q_sxxC];
                              }; } in
                    let {
                      sat_sxxM [Occ=Once] :: [a_astA]
                      [LclId] =
                          [ds3_sxxA] \u []
                              case ds3_sxxA of {
                                (,) qs_sxxK [Occ=Once] _ [Occ=Dead] -> qs_sxxK;
                              }; } in
                    let {
                      sat_sxxI [Occ=Once] :: a_astA
                      [LclId] =
                          [ds_sxxs x_sxxv ds3_sxxA] \u []
                              let {
                                sat_sxxH [Occ=Once] :: a_astA
                                [LclId] =
                                    [ds3_sxxA] \u []
                                        case ds3_sxxA of {
                                          (,) _ [Occ=Dead] q_sxxG [Occ=Once] -> q_sxxG;
                                        };
                              } in  ds_sxxs x_sxxv sat_sxxH;
                    } in  : [sat_sxxI sat_sxxM];
              };
        };

GHC.List.scanrFB [InlPrag=INLINE[0] (sat-args=2)]
  :: forall a b c.
     (a -> b -> b) -> (b -> c -> c) -> a -> (b, c) -> (b, c)
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><L,1*C1(C1(U))><L,U><S,1*U(U,U)>m,
 Unf=OtherCon []] =
    [] \r [f_sxxN c1_sxxO x_sxxP ds_sxxQ]
        case ds_sxxQ of {
          (,) r_sxxS est_sxxT [Occ=Once] ->
              let {
                sat_sxxV [Occ=Once] :: c_astR
                [LclId] =
                    [c1_sxxO r_sxxS est_sxxT] \u [] c1_sxxO r_sxxS est_sxxT; } in
              let {
                sat_sxxU [Occ=Once] :: b_astQ
                [LclId] =
                    [f_sxxN x_sxxP r_sxxS] \u [] f_sxxN x_sxxP r_sxxS;
              } in  (,) [sat_sxxU sat_sxxV];
        };

GHC.List.$wscanr [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a b. (a -> b -> b) -> b -> [a] -> (# b, [b] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sxxW w1_sxxX w2_sxxY]
        case w2_sxxY of {
          [] -> (#,#) [w1_sxxX GHC.Types.[]];
          : x_sxy0 [Occ=Once] xs_sxy1 [Occ=Once] ->
              let {
                ds_sxy2 [Dmd=<L,U(1*U,1*U)>] :: ([b_stJz], b_stJz)
                [LclId] =
                    [w_sxxW w1_sxxX xs_sxy1] \u []
                        case GHC.List.$wscanr w_sxxW w1_sxxX xs_sxy1 of {
                          (#,#) ww1_sxy4 ww2_sxy5 [Occ=Once] ->
                              let {
                                sat_sxy6 [Occ=Once] :: [b_stJz]
                                [LclId] =
                                    CCCS :! [ww1_sxy4 ww2_sxy5];
                              } in  (,) [sat_sxy6 ww1_sxy4];
                        }; } in
              let {
                sat_sxyf [Occ=Once] :: [b_stJz]
                [LclId] =
                    [ds_sxy2] \u []
                        case ds_sxy2 of {
                          (,) qs_sxyd [Occ=Once] _ [Occ=Dead] -> qs_sxyd;
                        }; } in
              let {
                sat_sxyb [Occ=Once] :: b_stJz
                [LclId] =
                    [w_sxxW x_sxy0 ds_sxy2] \u []
                        let {
                          sat_sxya [Occ=Once] :: b_stJz
                          [LclId] =
                              [ds_sxy2] \u []
                                  case ds_sxy2 of { (,) _ [Occ=Dead] q_sxy9 [Occ=Once] -> q_sxy9; };
                        } in  w_sxxW x_sxy0 sat_sxya;
              } in  (#,#) [sat_sxyb sat_sxyf];
        };

GHC.List.strictUncurryScanr [InlPrag=INLINE[0] (sat-args=2),
                             Occ=LoopBreaker!]
  :: forall a b c. (a -> b -> c) -> (a, b) -> c
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><S,1*U(U,U)>,
 Unf=OtherCon []] =
    [] \r [f_sxyg pair_sxyh]
        case pair_sxyh of {
          (,) x_sxyj [Occ=Once] y_sxyk [Occ=Once] -> f_sxyg x_sxyj y_sxyk;
        };
GHC.List.scanr [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker!]
  :: forall a b. (a -> b -> b) -> b -> [a] -> [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>m2,
 Unf=OtherCon []] =
    [] \r [w_sxyl w1_sxym w2_sxyn]
        case GHC.List.$wscanr w_sxyl w1_sxym w2_sxyn of {
          (#,#) ww1_sxyp [Occ=Once] ww2_sxyq [Occ=Once] ->
              : [ww1_sxyp ww2_sxyq];
        };

GHC.List.flipSeqScanl' [InlPrag=INLINE[0] (sat-args=2)]
  :: forall a b. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [a1_sxyr _b_sxys] case _b_sxys of { __DEFAULT -> a1_sxyr; };

GHC.List.scanlFB' [InlPrag=INLINE[0] (sat-args=2)]
  :: forall b a c.
     (b -> a -> b) -> (b -> c -> c) -> a -> (b -> c) -> b -> c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<C(C(S)),1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sxyu c1_sxyv b1_sxyw g_sxyx v_sxyy]
        case f_sxyu v_sxyy b1_sxyw of b'_sxyz {
          __DEFAULT ->
              let {
                sat_sxyA [Occ=Once] :: c_asuE
                [LclId] =
                    [g_sxyx b'_sxyz] \u [] g_sxyx b'_sxyz;
              } in  c1_sxyv b'_sxyz sat_sxyA;
        };

GHC.List.$wscanlGo' [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall b1 a1 b2 a2.
     (b2 -> a2 -> b2) -> b2 -> [a2] -> (# b2, [b2] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sxyB w1_sxyC w2_sxyD]
        case w1_sxyC of q_sxyE {
          __DEFAULT ->
              let {
                sat_sxyM [Occ=Once] :: [b1_stJp]
                [LclId] =
                    [w_sxyB w2_sxyD q_sxyE] \u []
                        case w2_sxyD of {
                          [] -> [] [];
                          : x_sxyG [Occ=Once] xs_sxyH [Occ=Once] ->
                              case w_sxyB q_sxyE x_sxyG of sat_sxyI {
                                __DEFAULT ->
                                    case GHC.List.$wscanlGo' w_sxyB sat_sxyI xs_sxyH of {
                                      (#,#) ww1_sxyK [Occ=Once] ww2_sxyL [Occ=Once] ->
                                          : [ww1_sxyK ww2_sxyL];
                                    };
                              };
                        };
              } in  (#,#) [q_sxyE sat_sxyM];
        };

GHC.List.scanl'_scanlGo' [InlPrag=NOUSERINLINE[0]]
  :: forall b1 a1 b2 a2. (b2 -> a2 -> b2) -> b2 -> [a2] -> [b2]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,1*U>m2,
 Unf=OtherCon []] =
    [] \r [w_sxyN w1_sxyO w2_sxyP]
        case GHC.List.$wscanlGo' w_sxyN w1_sxyO w2_sxyP of {
          (#,#) ww1_sxyR [Occ=Once] ww2_sxyS [Occ=Once] ->
              : [ww1_sxyR ww2_sxyS];
        };

GHC.List.scanl' [InlPrag=NOINLINE[1]]
  :: forall b a. (b -> a -> b) -> b -> [a] -> [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><L,1*U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.List.scanl'_scanlGo' eta_B3 eta_B2 eta_B1;

GHC.List.constScanl [InlPrag=INLINE[0] (sat-args=0)]
  :: forall a b. a -> b -> a
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><L,A>,
 Unf=OtherCon []] =
    [] \r [eta_B2 eta_B1] GHC.Base.const eta_B2 eta_B1;

GHC.List.scanlFB [InlPrag=INLINE[0] (sat-args=2)]
  :: forall b a c.
     (b -> a -> b) -> (b -> c -> c) -> a -> (b -> c) -> b -> c
[GblId,
 Arity=5,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(C(S)),1*C1(C1(U))><L,U><L,1*C1(U)><L,U>,
 Unf=OtherCon []] =
    [] \r [f_sxyT c1_sxyU b1_sxyV g_sxyW v_sxyX]
        let {
          b'_sxyY :: b_asvy
          [LclId] =
              [f_sxyT b1_sxyV v_sxyX] \u [] f_sxyT v_sxyX b1_sxyV; } in
        let {
          sat_sxyZ [Occ=Once] :: c_asvA
          [LclId] =
              [g_sxyW b'_sxyY] \u [] g_sxyW b'_sxyY;
        } in  c1_sxyU b'_sxyY sat_sxyZ;

GHC.List.$wscanlGo [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall b1 a1 b2 a2.
     (b2 -> a2 -> b2) -> b2 -> [a2] -> (# b2, [b2] #)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,1*U>,
 Unf=OtherCon []] =
    [] \r [w_sxz0 w1_sxz1 w2_sxz2]
        let {
          sat_sxza [Occ=Once] :: [b1_stJe]
          [LclId] =
              [w_sxz0 w1_sxz1 w2_sxz2] \u []
                  case w2_sxz2 of {
                    [] -> [] [];
                    : x_sxz4 [Occ=Once] xs_sxz5 [Occ=Once] ->
                        let {
                          sat_sxz6 [Occ=Once] :: b1_stJe
                          [LclId] =
                              [w_sxz0 w1_sxz1 x_sxz4] \u [] w_sxz0 w1_sxz1 x_sxz4;
                        } in 
                          case GHC.List.$wscanlGo w_sxz0 sat_sxz6 xs_sxz5 of {
                            (#,#) ww1_sxz8 [Occ=Once] ww2_sxz9 [Occ=Once] ->
                                : [ww1_sxz8 ww2_sxz9];
                          };
                  };
        } in  (#,#) [w1_sxz1 sat_sxza];

GHC.List.scanl_scanlGo [InlPrag=NOUSERINLINE[0]]
  :: forall b1 a1 b2 a2. (b2 -> a2 -> b2) -> b2 -> [a2] -> [b2]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,1*U>m2,
 Unf=OtherCon []] =
    [] \r [w_sxzb w1_sxzc w2_sxzd]
        case GHC.List.$wscanlGo w_sxzb w1_sxzc w2_sxzd of {
          (#,#) ww1_sxzf [Occ=Once] ww2_sxzg [Occ=Once] ->
              : [ww1_sxzf ww2_sxzg];
        };

GHC.List.scanl [InlPrag=NOINLINE[1]]
  :: forall b a. (b -> a -> b) -> b -> [a] -> [b]
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><L,1*U>m2,
 Unf=OtherCon []] =
    [] \r [eta_B3 eta_B2 eta_B1]
        GHC.List.scanl_scanlGo eta_B3 eta_B2 eta_B1;

GHC.List.scanl1 :: forall a. (a -> a -> a) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U>,
 Unf=OtherCon []] =
    [] \r [f_sxzh ds_sxzi]
        case ds_sxzi of {
          [] -> [] [];
          : x_sxzk xs_sxzl [Occ=Once] ->
              let {
                sat_sxzp [Occ=Once] :: [a_aswp]
                [LclId] =
                    [f_sxzh x_sxzk xs_sxzl] \u []
                        case GHC.List.$wscanlGo f_sxzh x_sxzk xs_sxzl of {
                          (#,#) _ [Occ=Dead] ww2_sxzo [Occ=Once] -> ww2_sxzo;
                        };
              } in  : [x_sxzk sat_sxzp];
        };

GHC.List.foldl' [InlPrag=INLINE (sat-args=3)]
  :: forall a b. (b -> a -> b) -> b -> [a] -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><S,1*U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [k_sxzq z0_sxzr xs_sxzs]
        let-no-escape {
          go2_sxzt [Occ=LoopBreakerT[2]] :: [a_aswt] -> b_aswu -> b_aswu
          [LclId[JoinId(2)], Arity=2, Str=<S,1*U><S,1*U>, Unf=OtherCon []] =
              sat-only [k_sxzq go2_sxzt] \r [ds_sxzu eta_sxzv]
                  case ds_sxzu of {
                    [] -> eta_sxzv;
                    : y_sxzx [Occ=Once] ys_sxzy [Occ=Once] ->
                        case eta_sxzv of z_sxzz {
                          __DEFAULT ->
                              case k_sxzq z_sxzz y_sxzx of sat_sxzA {
                                __DEFAULT -> go2_sxzt ys_sxzy sat_sxzA;
                              };
                        };
                  };
        } in  go2_sxzt xs_sxzs z0_sxzr;

GHC.List.foldl1' :: forall a. (a -> a -> a) -> [a] -> a
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []] =
    [] \r [f_sxzB ds_sxzC]
        case ds_sxzC of {
          [] -> GHC.List.foldl1'1;
          : x_sxzE [Occ=Once] xs_sxzF [Occ=Once] ->
              GHC.List.foldl' f_sxzB x_sxzE xs_sxzF;
        };

sat_sxzG :: GHC.Types.Int
[LclId] =
    CCS_DONT_CARE GHC.Types.I#! [1#];

sat_sxzH :: [GHC.Types.Int]
[LclId] =
    CCS_DONT_CARE :! [sat_sxzG GHC.Types.[]];

lvl29_ru9q :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True sat_sxzH;

lvl30_ru9r :: GHC.Integer.Type.Integer
[GblId, Unf=OtherCon []] =
    [] \u [] GHC.Integer.Type.mkInteger GHC.Types.True GHC.Types.[];

GHC.List.foldl [InlPrag=INLINE (sat-args=3)]
  :: forall a b. (b -> a -> b) -> b -> [a] -> b
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,C(C1(U))><L,U><S,1*U>,
 Unf=OtherCon []] =
    [] \r [k_sxzI z0_sxzJ xs_sxzK]
        let-no-escape {
          go2_sxzL [Occ=LoopBreakerT[2]] :: [a_asx1] -> b_asx2 -> b_asx2
          [LclId[JoinId(2)], Arity=2, Str=<S,1*U><L,U>, Unf=OtherCon []] =
              sat-only [k_sxzI go2_sxzL] \r [ds_sxzM eta_sxzN]
                  case ds_sxzM of {
                    [] -> eta_sxzN;
                    : y_sxzP [Occ=Once] ys_sxzQ [Occ=Once] ->
                        let {
                          sat_sxzR [Occ=Once] :: b_asx2
                          [LclId] =
                              [k_sxzI eta_sxzN y_sxzP] \u [] k_sxzI eta_sxzN y_sxzP;
                        } in  go2_sxzL ys_sxzQ sat_sxzR;
                  };
        } in  go2_sxzL xs_sxzK z0_sxzJ;

GHC.List.sum [InlPrag=INLINE (sat-args=0)]
  :: forall a. GHC.Num.Num a => [a] -> a
[GblId,
 Arity=1,
 Str=<L,U(1*C(C1(U)),A,A,A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_sxzS]
        let {
          sat_sxzU [Occ=Once] :: a_asyo
          [LclId] =
              [$dNum_sxzS] \u [] GHC.Num.fromInteger $dNum_sxzS lvl30_ru9r; } in
        let {
          sat_sxzT [Occ=Once] :: a_asyo -> a_asyo -> a_asyo
          [LclId] =
              [$dNum_sxzS] \u [] GHC.Num.+ $dNum_sxzS;
        } in  GHC.List.foldl sat_sxzT sat_sxzU;

GHC.List.product [InlPrag=INLINE (sat-args=0)]
  :: forall a. GHC.Num.Num a => [a] -> a
[GblId,
 Arity=1,
 Str=<L,U(A,A,1*C(C1(U)),A,A,A,1*C1(U))>,
 Unf=OtherCon []] =
    [] \r [$dNum_sxzV]
        let {
          sat_sxzX [Occ=Once] :: a_asyy
          [LclId] =
              [$dNum_sxzV] \u [] GHC.Num.fromInteger $dNum_sxzV lvl29_ru9q; } in
        let {
          sat_sxzW [Occ=Once] :: a_asyy -> a_asyy -> a_asyy
          [LclId] =
              [$dNum_sxzV] \u [] GHC.Num.* $dNum_sxzV;
        } in  GHC.List.foldl sat_sxzW sat_sxzX;

GHC.List.foldl1 :: forall a. (a -> a -> a) -> [a] -> a
[GblId, Arity=2, Str=<L,C(C1(U))><S,1*U>, Unf=OtherCon []] =
    [] \r [f_sxzY ds_sxzZ]
        case ds_sxzZ of {
          [] -> GHC.List.foldl2;
          : x_sxA1 [Occ=Once] xs_sxA2 [Occ=Once] ->
              GHC.List.foldl f_sxzY x_sxA1 xs_sxA2;
        };

GHC.List.filterFB [InlPrag=INLINE[0] (sat-args=4),
                   Occ=LoopBreaker!]
  :: forall a b.
     (a -> b -> b) -> (a -> GHC.Types.Bool) -> a -> b -> b
[GblId,
 Arity=4,
 Caf=NoCafRefs,
 Str=<L,1*C1(C1(U))><C(S),1*C1(U)><L,U><L,U>,
 Unf=OtherCon []] =
    [] \r [c_sxA3 p_sxA4 x_sxA5 r_sxA6]
        case p_sxA4 x_sxA5 of {
          GHC.Types.False -> r_sxA6;
          GHC.Types.True -> c_sxA3 x_sxA5 r_sxA6;
        };

GHC.List.filter [InlPrag=NOINLINE[1], Occ=LoopBreaker]
  :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<L,C(U)><S,1*U>,
 Unf=OtherCon []] =
    [] \r [_pred_sxA8 ds_sxA9]
        case ds_sxA9 of {
          [] -> [] [];
          : x_sxAb xs_sxAc [Occ=Once*] ->
              case _pred_sxA8 x_sxAb of {
                GHC.Types.False -> GHC.List.filter _pred_sxA8 xs_sxAc;
                GHC.Types.True ->
                    let {
                      sat_sxAe [Occ=Once] :: [a_asyL]
                      [LclId] =
                          [_pred_sxA8 xs_sxAc] \u [] GHC.List.filter _pred_sxA8 xs_sxAc;
                    } in  : [x_sxAb sat_sxAe];
              };
        };

GHC.List.idLength [InlPrag=INLINE[0] (sat-args=0)]
  :: GHC.Types.Int -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [eta_B1] GHC.Base.id eta_B1;

GHC.List.lengthFB [InlPrag=INLINE[0] (sat-args=2)]
  :: forall x.
     x
     -> (GHC.Types.Int -> GHC.Types.Int)
     -> GHC.Types.Int
     -> GHC.Types.Int
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=<L,A><C(S),1*C1(U(U))><S,1*U(U)>,
 Unf=OtherCon []] =
    [] \r [eta_sxAf eta1_sxAg a_sxAh]
        case a_sxAh of {
          GHC.Types.I# ipv_sxAj [Occ=Once] ->
              case +# [ipv_sxAj 1#] of sat_sxAk {
                __DEFAULT ->
                    let {
                      sat_sxAl [Occ=Once] :: GHC.Types.Int
                      [LclId] =
                          CCCS GHC.Types.I#! [sat_sxAk];
                    } in  eta1_sxAg sat_sxAl;
              };
        };

GHC.List.$wlenAcc [InlPrag=NOUSERINLINE[0], Occ=LoopBreaker]
  :: forall a. [a] -> GHC.Prim.Int# -> GHC.Prim.Int#
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S,U>,
 Unf=OtherCon []] =
    [] \r [w_sxAm ww_sxAn]
        case w_sxAm of {
          [] -> ww_sxAn;
          : _ [Occ=Dead] ys_sxAq [Occ=Once] ->
              case +# [ww_sxAn 1#] of sat_sxAr {
                __DEFAULT -> GHC.List.$wlenAcc ys_sxAq sat_sxAr;
              };
        };

GHC.List.lenAcc [InlPrag=NOUSERINLINE[0]]
  :: forall a. [a] -> GHC.Types.Int -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=<S,1*U><S(S),1*U(U)>m,
 Unf=OtherCon []] =
    [] \r [w_sxAs w1_sxAt]
        case w1_sxAt of {
          GHC.Types.I# ww1_sxAv [Occ=Once] ->
              case GHC.List.$wlenAcc w_sxAs ww1_sxAv of ww2_sxAw {
                __DEFAULT -> GHC.Types.I# [ww2_sxAw];
              };
        };

GHC.List.length [InlPrag=NOUSERINLINE[0]]
  :: forall a. [a] -> GHC.Types.Int
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>m, Unf=OtherCon []] =
    [] \r [w_sxAx]
        case GHC.List.$wlenAcc w_sxAx 0# of ww_sxAy {
          __DEFAULT -> GHC.Types.I# [ww_sxAy];
        };

GHC.List.null :: forall a. [a] -> GHC.Types.Bool
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxAz]
        case ds_sxAz of {
          [] -> GHC.Types.True [];
          : _ [Occ=Dead] _ [Occ=Dead] -> GHC.Types.False [];
        };

GHC.List.uncons :: forall a. [a] -> GHC.Base.Maybe (a, [a])
[GblId, Arity=1, Caf=NoCafRefs, Str=<S,1*U>, Unf=OtherCon []] =
    [] \r [ds_sxAD]
        case ds_sxAD of {
          [] -> GHC.Base.Nothing [];
          : x_sxAF [Occ=Once] xs_sxAG [Occ=Once] ->
              let {
                sat_sxAH [Occ=Once] :: (a_aszT, [a_aszT])
                [LclId] =
                    CCCS (,)! [x_sxAF xs_sxAG];
              } in  GHC.Base.Just [sat_sxAH];
        };

