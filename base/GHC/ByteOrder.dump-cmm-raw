
==================== Raw Cmm ====================
2018-03-16 16:07:27.44665023 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:07:27.447781809 UTC

[section ""cstring" . GHC.ByteOrder.$fReadByteOrder11_bytes" {
     GHC.ByteOrder.$fReadByteOrder11_bytes:
         I8[] [66,105,103,69,110,100,105,97,110]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.450228917 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder10_closure" {
     GHC.ByteOrder.$fReadByteOrder10_closure:
         const GHC.ByteOrder.$fReadByteOrder10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder10_entry() //  [R1]
         { []
         }
     {offset
       cczr2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczr3; else goto cczr4;
       cczr3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczr4: // global
           (_cczqZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczqZ::I64 == 0) goto cczr1; else goto cczr0;
       cczr1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczr0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczqZ::I64;
           R2 = GHC.ByteOrder.$fReadByteOrder11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fReadByteOrder10_info" {
     GHC.ByteOrder.$fReadByteOrder10_info:
         const GHC.ByteOrder.$fReadByteOrder10_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.453946087 UTC

[section ""cstring" . GHC.ByteOrder.$fReadByteOrder7_bytes" {
     GHC.ByteOrder.$fReadByteOrder7_bytes:
         I8[] [76,105,116,116,108,101,69,110,100,105,97,110]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.456173064 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder6_closure" {
     GHC.ByteOrder.$fReadByteOrder6_closure:
         const GHC.ByteOrder.$fReadByteOrder6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder6_entry() //  [R1]
         { []
         }
     {offset
       cczrj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczrk; else goto cczrl;
       cczrk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczrl: // global
           (_cczrg::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczrg::I64 == 0) goto cczri; else goto cczrh;
       cczri: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczrh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczrg::I64;
           R2 = GHC.ByteOrder.$fReadByteOrder7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fReadByteOrder6_info" {
     GHC.ByteOrder.$fReadByteOrder6_info:
         const GHC.ByteOrder.$fReadByteOrder6_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.460732298 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure" {
     GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure:
         const GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cczrE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczrF; else goto cczrG;
       cczrF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cczrG: // global
           I64[Sp - 16] = block_cczrx_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczrN; else goto cczry;
       uczrN: // global
           call _cczrx(R1) args: 0, res: 0, upd: 0;
       cczry: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_info" {
     GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_info:
         const GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_entry;
         const 0;
         const 30064771086;
         const 12884901911;
         const ScypP_srt;
 },
 _cczrx() //  [R1]
         { []
         }
     {offset
       cczrx: // global
           _scykL::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczrB; else goto cczrC;
       cczrB: // global
           R3 = _scykL::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       cczrC: // global
           R3 = _scykL::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczrx_info" {
     block_cczrx_info:
         const _cczrx;
         const 1;
         const 12884901918;
         const ScypP_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.466793556 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_$cshow_closure" {
     GHC.ByteOrder.$fShowByteOrder_$cshow_closure:
         const GHC.ByteOrder.$fShowByteOrder_$cshow_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder_$cshow_entry() //  [R2]
         { []
         }
     {offset
       cczsa: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cczsb; else goto cczsc;
       cczsb: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fShowByteOrder_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczsc: // global
           I64[Sp - 8] = block_cczs3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uczsj; else goto cczs4;
       uczsj: // global
           call _cczs3(R1) args: 0, res: 0, upd: 0;
       cczs4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fShowByteOrder_$cshow_info" {
     GHC.ByteOrder.$fShowByteOrder_$cshow_info:
         const GHC.ByteOrder.$fShowByteOrder_$cshow_entry;
         const 0;
         const 47244640270;
         const 4294967301;
         const ScypP_srt;
 },
 _cczs3() //  [R1]
         { []
         }
     {offset
       cczs3: // global
           if (R1 & 7 == 1) goto cczs7; else goto cczs8;
       cczs7: // global
           R1 = GHC.ByteOrder.$fReadByteOrder10_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cczs8: // global
           R1 = GHC.ByteOrder.$fReadByteOrder6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczs3_info" {
     block_cczs3_info:
         const _cczs3;
         const 0;
         const 12884901918;
         const ScypP_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.472704518 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder1_closure" {
     GHC.ByteOrder.$fShowByteOrder1_closure:
         const GHC.ByteOrder.$fShowByteOrder1_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder1_entry() //  [R2, R3]
         { []
         }
     {offset
       cczsI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczsJ; else goto cczsK;
       cczsJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fShowByteOrder1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczsK: // global
           I64[Sp - 16] = block_cczsB_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczsR; else goto cczsC;
       uczsR: // global
           call _cczsB(R1) args: 0, res: 0, upd: 0;
       cczsC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fShowByteOrder1_info" {
     GHC.ByteOrder.$fShowByteOrder1_info:
         const GHC.ByteOrder.$fShowByteOrder1_entry;
         const 0;
         const 81604378638;
         const 8589934607;
         const ScypP_srt;
 },
 _cczsB() //  [R1]
         { []
         }
     {offset
       cczsB: // global
           _scykQ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczsF; else goto cczsG;
       cczsF: // global
           R3 = _scykQ::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       cczsG: // global
           R3 = _scykQ::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczsB_info" {
     block_cczsB_info:
         const _cczsB;
         const 1;
         const 12884901918;
         const ScypP_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.479990461 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_$cshowList_closure" {
     GHC.ByteOrder.$fShowByteOrder_$cshowList_closure:
         const GHC.ByteOrder.$fShowByteOrder_$cshowList_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       cczt7: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.ByteOrder.$fShowByteOrder1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fShowByteOrder_$cshowList_info" {
     GHC.ByteOrder.$fShowByteOrder_$cshowList_info:
         const GHC.ByteOrder.$fShowByteOrder_$cshowList_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const ScypP_srt+32;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.483143195 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_closure" {
     GHC.ByteOrder.$fShowByteOrder_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure+3;
         const GHC.ByteOrder.$fShowByteOrder_$cshow_closure+1;
         const GHC.ByteOrder.$fShowByteOrder_$cshowList_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.485161034 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder9_closure" {
     GHC.ByteOrder.$fReadByteOrder9_closure:
         const GHC.ByteOrder.$fReadByteOrder9_info;
 },
 GHC.ByteOrder.$fReadByteOrder9_entry() //  [R3]
         { []
         }
     {offset
       ccztj: // global
           R2 = GHC.ByteOrder.BigEndian_closure+1;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fReadByteOrder9_info" {
     GHC.ByteOrder.$fReadByteOrder9_info:
         const GHC.ByteOrder.$fReadByteOrder9_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.48861235 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder8_closure" {
     GHC.ByteOrder.$fReadByteOrder8_closure:
         const (,)_con_info;
         const GHC.ByteOrder.$fReadByteOrder10_closure;
         const GHC.ByteOrder.$fReadByteOrder9_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.490592848 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder5_closure" {
     GHC.ByteOrder.$fReadByteOrder5_closure:
         const GHC.ByteOrder.$fReadByteOrder5_info;
 },
 GHC.ByteOrder.$fReadByteOrder5_entry() //  [R3]
         { []
         }
     {offset
       ccztv: // global
           R2 = GHC.ByteOrder.LittleEndian_closure+2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fReadByteOrder5_info" {
     GHC.ByteOrder.$fReadByteOrder5_info:
         const GHC.ByteOrder.$fReadByteOrder5_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.493768561 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder4_closure" {
     GHC.ByteOrder.$fReadByteOrder4_closure:
         const (,)_con_info;
         const GHC.ByteOrder.$fReadByteOrder6_closure;
         const GHC.ByteOrder.$fReadByteOrder5_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.495506135 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder3_closure" {
     GHC.ByteOrder.$fReadByteOrder3_closure:
         const :_con_info;
         const GHC.ByteOrder.$fReadByteOrder4_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.49722103 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_sps_closure" {
     GHC.ByteOrder.$fReadByteOrder_sps_closure:
         const :_con_info;
         const GHC.ByteOrder.$fReadByteOrder8_closure+1;
         const GHC.ByteOrder.$fReadByteOrder3_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.499565655 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder2_closure" {
     GHC.ByteOrder.$fReadByteOrder2_closure:
         const GHC.ByteOrder.$fReadByteOrder2_info;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder2_entry() //  [R2]
         { []
         }
     {offset
       ccztJ: // global
           R3 = R2;
           R2 = GHC.ByteOrder.$fReadByteOrder_sps_closure+2;
           call GHC.Read.choose2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fReadByteOrder2_info" {
     GHC.ByteOrder.$fReadByteOrder2_info:
         const GHC.ByteOrder.$fReadByteOrder2_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const ScypP_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.502945358 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder1_closure" {
     GHC.ByteOrder.$fReadByteOrder1_closure:
         const GHC.ByteOrder.$fReadByteOrder1_info;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder1_entry() //  [R2, R3]
         { []
         }
     {offset
       ccztU: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.ByteOrder.$fReadByteOrder2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fReadByteOrder1_info" {
     GHC.ByteOrder.$fReadByteOrder1_info:
         const GHC.ByteOrder.$fReadByteOrder1_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const ScypP_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.507197645 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure" {
     GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure:
         const GHC.ByteOrder.$fReadByteOrder_$creadsPrec_info;
         const 0;
 },
 sat_scyl0_entry() //  [R1]
         { []
         }
     {offset
       cczu9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczua; else goto cczub;
       cczua: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczub: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.ByteOrder.$fReadByteOrder2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyl0_info" {
     sat_scyl0_info:
         const sat_scyl0_entry;
         const 1;
         const 12884901904;
         const ScypP_srt+56;
 },
 GHC.ByteOrder.$fReadByteOrder_$creadsPrec_entry() //  [R2]
         { []
         }
     {offset
       cczuc: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczug; else goto cczuf;
       cczug: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczuf: // global
           I64[Hp - 16] = sat_scyl0_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fReadByteOrder_$creadsPrec_info" {
     GHC.ByteOrder.$fReadByteOrder_$creadsPrec_info:
         const GHC.ByteOrder.$fReadByteOrder_$creadsPrec_entry;
         const 0;
         const 30064771086;
         const 4294967301;
         const ScypP_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.514087955 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure" {
     GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure:
         const GHC.ByteOrder.$fReadByteOrder_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder_$creadListPrec_entry() //  [R1]
         { []
         }
     {offset
       cczuv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczuw; else goto cczux;
       cczuw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczux: // global
           (_cczus::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczus::I64 == 0) goto cczuu; else goto cczut;
       cczuu: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczut: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczus::I64;
           R2 = GHC.ByteOrder.$fReadByteOrder1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fReadByteOrder_$creadListPrec_info" {
     GHC.ByteOrder.$fReadByteOrder_$creadListPrec_info:
         const GHC.ByteOrder.$fReadByteOrder_$creadListPrec_entry;
         const 0;
         const 12884901909;
         const ScypP_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.518275179 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder12_closure" {
     GHC.ByteOrder.$fReadByteOrder12_closure:
         const GHC.ByteOrder.$fReadByteOrder12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder12_entry() //  [R1]
         { []
         }
     {offset
       cczuL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczuM; else goto cczuN;
       cczuM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczuN: // global
           (_cczuI::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczuI::I64 == 0) goto cczuK; else goto cczuJ;
       cczuK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczuJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczuI::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fReadByteOrder12_info" {
     GHC.ByteOrder.$fReadByteOrder12_info:
         const GHC.ByteOrder.$fReadByteOrder12_entry;
         const 0;
         const 4294967317;
         const ScypP_srt+96;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.522207991 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_$creadList_closure" {
     GHC.ByteOrder.$fReadByteOrder_$creadList_closure:
         const GHC.ByteOrder.$fReadByteOrder_$creadList_info;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder_$creadList_entry() //  [R2]
         { []
         }
     {offset
       cczuZ: // global
           R3 = R2;
           R2 = GHC.ByteOrder.$fReadByteOrder12_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fReadByteOrder_$creadList_info" {
     GHC.ByteOrder.$fReadByteOrder_$creadList_info:
         const GHC.ByteOrder.$fReadByteOrder_$creadList_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const ScypP_srt+104;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.525964591 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_closure" {
     GHC.ByteOrder.$fReadByteOrder_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure+1;
         const GHC.ByteOrder.$fReadByteOrder_$creadList_closure+1;
         const GHC.ByteOrder.$fReadByteOrder1_closure+2;
         const GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.527834953 UTC

[section ""data" . GHC.ByteOrder.$fBoundedByteOrder_closure" {
     GHC.ByteOrder.$fBoundedByteOrder_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.ByteOrder.BigEndian_closure+1;
         const GHC.ByteOrder.LittleEndian_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.531044684 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c<_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c<_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c<_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c<_entry() //  [R2, R3]
         { []
         }
     {offset
       cczvj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczvk; else goto cczvl;
       cczvk: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczvl: // global
           I64[Sp - 16] = block_cczvc_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczvN; else goto cczvd;
       uczvN: // global
           call _cczvc(R1) args: 0, res: 0, upd: 0;
       cczvd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fOrdByteOrder_$c<_info" {
     GHC.ByteOrder.$fOrdByteOrder_$c<_info:
         const GHC.ByteOrder.$fOrdByteOrder_$c<_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cczvc() //  [R1]
         { []
         }
     {offset
       cczvc: // global
           _scyl2::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczvg; else goto cczvh;
       cczvg: // global
           I64[Sp + 8] = block_cczvo_info;
           R1 = _scyl2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczvL; else goto cczvq;
       uczvL: // global
           call _cczvo(R1) args: 0, res: 0, upd: 0;
       cczvq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cczvh: // global
           I64[Sp + 8] = block_cczvD_info;
           R1 = _scyl2::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczvM; else goto cczvF;
       uczvM: // global
           call _cczvD() args: 0, res: 0, upd: 0;
       cczvF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cczvc_info" {
     block_cczvc_info:
         const _cczvc;
         const 1;
         const 30;
 },
 _cczvo() //  [R1]
         { []
         }
     {offset
       cczvo: // global
           if (R1 & 7 == 1) goto cczvw; else goto cczvA;
       cczvw: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczvA: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczvo_info" {
     block_cczvo_info:
         const _cczvo;
         const 0;
         const 30;
 },
 _cczvD() //  []
         { []
         }
     {offset
       cczvD: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczvD_info" {
     block_cczvD_info:
         const _cczvD;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.541584561 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$ccompare_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       cczwn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczwo; else goto cczwp;
       cczwo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczwp: // global
           I64[Sp - 16] = block_cczwg_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczx0; else goto cczwh;
       uczx0: // global
           call _cczwg(R1) args: 0, res: 0, upd: 0;
       cczwh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fOrdByteOrder_$ccompare_info" {
     GHC.ByteOrder.$fOrdByteOrder_$ccompare_info:
         const GHC.ByteOrder.$fOrdByteOrder_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cczwg() //  [R1]
         { []
         }
     {offset
       cczwg: // global
           _scyl7::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczwk; else goto cczwl;
       cczwk: // global
           I64[Sp + 8] = block_cczws_info;
           R1 = _scyl7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczwY; else goto cczwu;
       uczwY: // global
           call _cczws(R1) args: 0, res: 0, upd: 0;
       cczwu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cczwl: // global
           I64[Sp + 8] = block_cczwH_info;
           R1 = _scyl7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczwZ; else goto cczwJ;
       uczwZ: // global
           call _cczwH(R1) args: 0, res: 0, upd: 0;
       cczwJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cczwg_info" {
     block_cczwg_info:
         const _cczwg;
         const 1;
         const 30;
 },
 _cczws() //  [R1]
         { []
         }
     {offset
       cczws: // global
           if (R1 & 7 == 1) goto uczwX; else goto cczwE;
       uczwX: // global
           Sp = Sp + 8;
           call _cczwT() args: 0, res: 0, upd: 0;
       cczwE: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczws_info" {
     block_cczws_info:
         const _cczws;
         const 0;
         const 30;
 },
 _cczwH() //  [R1]
         { []
         }
     {offset
       cczwH: // global
           if (R1 & 7 == 1) goto cczwP; else goto uczwW;
       cczwP: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       uczwW: // global
           Sp = Sp + 8;
           call _cczwT() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cczwH_info" {
     block_cczwH_info:
         const _cczwH;
         const 0;
         const 30;
 },
 _cczwT() //  []
         { []
         }
     {offset
       cczwT: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.553288386 UTC

[section ""data" . GHC.ByteOrder.$fEqByteOrder_$c==_closure" {
     GHC.ByteOrder.$fEqByteOrder_$c==_closure:
         const GHC.ByteOrder.$fEqByteOrder_$c==_info;
 },
 GHC.ByteOrder.$fEqByteOrder_$c==_entry() //  [R2, R3]
         { []
         }
     {offset
       cczxG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczxH; else goto cczxI;
       cczxH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEqByteOrder_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczxI: // global
           I64[Sp - 16] = block_cczxz_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczyl; else goto cczxA;
       uczyl: // global
           call _cczxz(R1) args: 0, res: 0, upd: 0;
       cczxA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEqByteOrder_$c==_info" {
     GHC.ByteOrder.$fEqByteOrder_$c==_info:
         const GHC.ByteOrder.$fEqByteOrder_$c==_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cczxz() //  [R1]
         { []
         }
     {offset
       cczxz: // global
           _scylc::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczxD; else goto cczxE;
       cczxD: // global
           I64[Sp + 8] = block_cczxL_info;
           R1 = _scylc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczyj; else goto cczxN;
       uczyj: // global
           call _cczxL(R1) args: 0, res: 0, upd: 0;
       cczxN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cczxE: // global
           I64[Sp + 8] = block_cczy0_info;
           R1 = _scylc::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczyk; else goto cczy2;
       uczyk: // global
           call _cczy0(R1) args: 0, res: 0, upd: 0;
       cczy2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cczxz_info" {
     block_cczxz_info:
         const _cczxz;
         const 1;
         const 30;
 },
 _cczxL() //  [R1]
         { []
         }
     {offset
       cczxL: // global
           if (R1 & 7 == 1) goto uczyh; else goto uczyi;
       uczyh: // global
           Sp = Sp + 8;
           call _cczyc() args: 0, res: 0, upd: 0;
       uczyi: // global
           Sp = Sp + 8;
           call _cczy8() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cczxL_info" {
     block_cczxL_info:
         const _cczxL;
         const 0;
         const 30;
 },
 _cczy0() //  [R1]
         { []
         }
     {offset
       cczy0: // global
           if (R1 & 7 == 1) goto uczyf; else goto uczyg;
       uczyf: // global
           Sp = Sp + 8;
           call _cczy8() args: 0, res: 0, upd: 0;
       uczyg: // global
           Sp = Sp + 8;
           call _cczyc() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cczy0_info" {
     block_cczy0_info:
         const _cczy0;
         const 0;
         const 30;
 },
 _cczy8() //  []
         { []
         }
     {offset
       cczy8: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cczyc() //  []
         { []
         }
     {offset
       cczyc: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.564766335 UTC

[section ""data" . GHC.ByteOrder.$fEqByteOrder_$c/=_closure" {
     GHC.ByteOrder.$fEqByteOrder_$c/=_closure:
         const GHC.ByteOrder.$fEqByteOrder_$c/=_info;
 },
 GHC.ByteOrder.$fEqByteOrder_$c/=_entry() //  [R2, R3]
         { []
         }
     {offset
       cczz4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczz5; else goto cczz6;
       cczz5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEqByteOrder_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczz6: // global
           I64[Sp - 16] = block_cczyX_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczzJ; else goto cczyY;
       uczzJ: // global
           call _cczyX(R1) args: 0, res: 0, upd: 0;
       cczyY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEqByteOrder_$c/=_info" {
     GHC.ByteOrder.$fEqByteOrder_$c/=_info:
         const GHC.ByteOrder.$fEqByteOrder_$c/=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cczyX() //  [R1]
         { []
         }
     {offset
       cczyX: // global
           _scylh::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczz1; else goto cczz2;
       cczz1: // global
           I64[Sp + 8] = block_cczz9_info;
           R1 = _scylh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczzH; else goto cczzb;
       uczzH: // global
           call _cczz9(R1) args: 0, res: 0, upd: 0;
       cczzb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cczz2: // global
           I64[Sp + 8] = block_cczzo_info;
           R1 = _scylh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczzI; else goto cczzq;
       uczzI: // global
           call _cczzo(R1) args: 0, res: 0, upd: 0;
       cczzq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cczyX_info" {
     block_cczyX_info:
         const _cczyX;
         const 1;
         const 30;
 },
 _cczz9() //  [R1]
         { []
         }
     {offset
       cczz9: // global
           if (R1 & 7 == 1) goto uczzF; else goto uczzG;
       uczzF: // global
           Sp = Sp + 8;
           call _cczzA() args: 0, res: 0, upd: 0;
       uczzG: // global
           Sp = Sp + 8;
           call _cczzw() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cczz9_info" {
     block_cczz9_info:
         const _cczz9;
         const 0;
         const 30;
 },
 _cczzo() //  [R1]
         { []
         }
     {offset
       cczzo: // global
           if (R1 & 7 == 1) goto uczzD; else goto uczzE;
       uczzD: // global
           Sp = Sp + 8;
           call _cczzw() args: 0, res: 0, upd: 0;
       uczzE: // global
           Sp = Sp + 8;
           call _cczzA() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cczzo_info" {
     block_cczzo_info:
         const _cczzo;
         const 0;
         const 30;
 },
 _cczzw() //  []
         { []
         }
     {offset
       cczzw: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cczzA() //  []
         { []
         }
     {offset
       cczzA: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.57483091 UTC

[section ""data" . GHC.ByteOrder.$fEqByteOrder_closure" {
     GHC.ByteOrder.$fEqByteOrder_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.ByteOrder.$fEqByteOrder_$c==_closure+2;
         const GHC.ByteOrder.$fEqByteOrder_$c/=_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.57917255 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c<=_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c<=_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c<=_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c<=_entry() //  [R2, R3]
         { []
         }
     {offset
       cczAt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczAu; else goto cczAv;
       cczAu: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczAv: // global
           I64[Sp - 16] = block_cczAm_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczAX; else goto cczAn;
       uczAX: // global
           call _cczAm(R1) args: 0, res: 0, upd: 0;
       cczAn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fOrdByteOrder_$c<=_info" {
     GHC.ByteOrder.$fOrdByteOrder_$c<=_info:
         const GHC.ByteOrder.$fOrdByteOrder_$c<=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cczAm() //  [R1]
         { []
         }
     {offset
       cczAm: // global
           _scyll::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczAq; else goto cczAr;
       cczAq: // global
           I64[Sp + 8] = block_cczAy_info;
           R1 = _scyll::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczAV; else goto cczAA;
       uczAV: // global
           call _cczAy(R1) args: 0, res: 0, upd: 0;
       cczAA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cczAr: // global
           I64[Sp + 8] = block_cczAN_info;
           R1 = _scyll::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczAW; else goto cczAP;
       uczAW: // global
           call _cczAN() args: 0, res: 0, upd: 0;
       cczAP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cczAm_info" {
     block_cczAm_info:
         const _cczAm;
         const 1;
         const 30;
 },
 _cczAy() //  [R1]
         { []
         }
     {offset
       cczAy: // global
           if (R1 & 7 == 1) goto cczAG; else goto cczAK;
       cczAG: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczAK: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczAy_info" {
     block_cczAy_info:
         const _cczAy;
         const 0;
         const 30;
 },
 _cczAN() //  []
         { []
         }
     {offset
       cczAN: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczAN_info" {
     block_cczAN_info:
         const _cczAN;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.58847095 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$cmax_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$cmax_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$cmax_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       cczBx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczBy; else goto cczBz;
       cczBy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczBz: // global
           I64[Sp - 16] = block_cczBq_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczBN; else goto cczBr;
       uczBN: // global
           call _cczBq(R1) args: 0, res: 0, upd: 0;
       cczBr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fOrdByteOrder_$cmax_info" {
     GHC.ByteOrder.$fOrdByteOrder_$cmax_info:
         const GHC.ByteOrder.$fOrdByteOrder_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cczBq() //  [R1]
         { []
         }
     {offset
       cczBq: // global
           _scylq::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczBu; else goto cczBv;
       cczBu: // global
           R1 = _scylq::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cczBv: // global
           I64[Sp + 8] = block_cczBF_info;
           R1 = _scylq::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczBM; else goto cczBH;
       uczBM: // global
           call _cczBF() args: 0, res: 0, upd: 0;
       cczBH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cczBq_info" {
     block_cczBq_info:
         const _cczBq;
         const 1;
         const 30;
 },
 _cczBF() //  []
         { []
         }
     {offset
       cczBF: // global
           R1 = GHC.ByteOrder.LittleEndian_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczBF_info" {
     block_cczBF_info:
         const _cczBF;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.596865904 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c>=_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c>=_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c>=_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c>=_entry() //  [R2, R3]
         { []
         }
     {offset
       cczCh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczCi; else goto cczCj;
       cczCi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczCj: // global
           I64[Sp - 16] = block_cczCa_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczCL; else goto cczCb;
       uczCL: // global
           call _cczCa(R1) args: 0, res: 0, upd: 0;
       cczCb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fOrdByteOrder_$c>=_info" {
     GHC.ByteOrder.$fOrdByteOrder_$c>=_info:
         const GHC.ByteOrder.$fOrdByteOrder_$c>=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cczCa() //  [R1]
         { []
         }
     {offset
       cczCa: // global
           _scylv::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczCe; else goto cczCf;
       cczCe: // global
           I64[Sp + 8] = block_cczCm_info;
           R1 = _scylv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczCJ; else goto cczCo;
       uczCJ: // global
           call _cczCm(R1) args: 0, res: 0, upd: 0;
       cczCo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cczCf: // global
           I64[Sp + 8] = block_cczCB_info;
           R1 = _scylv::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczCK; else goto cczCD;
       uczCK: // global
           call _cczCB() args: 0, res: 0, upd: 0;
       cczCD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cczCa_info" {
     block_cczCa_info:
         const _cczCa;
         const 1;
         const 30;
 },
 _cczCm() //  [R1]
         { []
         }
     {offset
       cczCm: // global
           if (R1 & 7 == 1) goto cczCu; else goto cczCy;
       cczCu: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczCy: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczCm_info" {
     block_cczCm_info:
         const _cczCm;
         const 0;
         const 30;
 },
 _cczCB() //  []
         { []
         }
     {offset
       cczCB: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczCB_info" {
     block_cczCB_info:
         const _cczCB;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.605754765 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c>_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c>_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c>_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c>_entry() //  [R2, R3]
         { []
         }
     {offset
       cczDe: // global
           _scylA::P64 = R3;
           R3 = R2;
           R2 = _scylA::P64;
           call GHC.ByteOrder.$fOrdByteOrder_$c<_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fOrdByteOrder_$c>_info" {
     GHC.ByteOrder.$fOrdByteOrder_$c>_info:
         const GHC.ByteOrder.$fOrdByteOrder_$c>_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.610611457 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$cmin_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$cmin_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$cmin_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       cczDw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczDx; else goto cczDy;
       cczDx: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczDy: // global
           I64[Sp - 16] = block_cczDp_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczDM; else goto cczDq;
       uczDM: // global
           call _cczDp(R1) args: 0, res: 0, upd: 0;
       cczDq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fOrdByteOrder_$cmin_info" {
     GHC.ByteOrder.$fOrdByteOrder_$cmin_info:
         const GHC.ByteOrder.$fOrdByteOrder_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cczDp() //  [R1]
         { []
         }
     {offset
       cczDp: // global
           _scylB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczDt; else goto cczDu;
       cczDt: // global
           I64[Sp + 8] = block_cczDB_info;
           R1 = _scylB::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto uczDL; else goto cczDD;
       uczDL: // global
           call _cczDB() args: 0, res: 0, upd: 0;
       cczDD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       cczDu: // global
           R1 = _scylB::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczDp_info" {
     block_cczDp_info:
         const _cczDp;
         const 1;
         const 30;
 },
 _cczDB() //  []
         { []
         }
     {offset
       cczDB: // global
           R1 = GHC.ByteOrder.BigEndian_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczDB_info" {
     block_cczDB_info:
         const _cczDB;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.617694825 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_closure" {
     GHC.ByteOrder.$fOrdByteOrder_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.ByteOrder.$fEqByteOrder_closure+1;
         const GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c<_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c<=_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c>_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c>=_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$cmax_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.619517541 UTC

[section ""data" . GHC.ByteOrder.targetByteOrder_closure" {
     GHC.ByteOrder.targetByteOrder_closure:
         const GHC.ByteOrder.LittleEndian_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.621228594 UTC

[section ""data" . lvl_rcykn_closure" {
     lvl_rcykn_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.62307832 UTC

[section ""data" . lvl1_rcyko_closure" {
     lvl1_rcyko_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.625760075 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_info;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_entry() //  [R2]
         { []
         }
     {offset
       cczEk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cczEl; else goto cczEm;
       cczEl: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczEm: // global
           I64[Sp - 8] = block_cczEd_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uczEt; else goto cczEe;
       uczEt: // global
           call _cczEd(R1) args: 0, res: 0, upd: 0;
       cczEe: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_info" {
     GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_info:
         const GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cczEd() //  [R1]
         { []
         }
     {offset
       cczEd: // global
           if (R1 & 7 == 1) goto cczEh; else goto cczEi;
       cczEh: // global
           R1 = lvl_rcykn_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczEi: // global
           R1 = lvl1_rcyko_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczEd_info" {
     block_cczEd_info:
         const _cczEd;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.631433331 UTC

[section ""cstring" . lvl2_rcykp_bytes" {
     lvl2_rcykp_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.633797794 UTC

[section ""data" . lvl3_rcykq_closure" {
     lvl3_rcykq_closure:
         const lvl3_rcykq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rcykq_entry() //  [R1]
         { []
         }
     {offset
       cczEO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczEP; else goto cczEQ;
       cczEP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczEQ: // global
           (_cczEL::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczEL::I64 == 0) goto cczEN; else goto cczEM;
       cczEN: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczEM: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczEL::I64;
           R2 = lvl2_rcykp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl3_rcykq_info" {
     lvl3_rcykq_info:
         const lvl3_rcykq_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.637551543 UTC

[section ""cstring" . GHC.ByteOrder.$trModule4_bytes" {
     GHC.ByteOrder.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.640474058 UTC

[section ""data" . lvl4_rcykr_closure" {
     lvl4_rcykr_closure:
         const lvl4_rcykr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_rcykr_entry() //  [R1]
         { []
         }
     {offset
       cczF5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczF6; else goto cczF7;
       cczF6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczF7: // global
           (_cczF2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczF2::I64 == 0) goto cczF4; else goto cczF3;
       cczF4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczF3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczF2::I64;
           R2 = GHC.ByteOrder.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl4_rcykr_info" {
     lvl4_rcykr_info:
         const lvl4_rcykr_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.644423039 UTC

[section ""cstring" . GHC.ByteOrder.$trModule2_bytes" {
     GHC.ByteOrder.$trModule2_bytes:
         I8[] [71,72,67,46,66,121,116,101,79,114,100,101,114]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.646701523 UTC

[section ""data" . lvl5_rcyks_closure" {
     lvl5_rcyks_closure:
         const lvl5_rcyks_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_rcyks_entry() //  [R1]
         { []
         }
     {offset
       cczFm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczFn; else goto cczFo;
       cczFn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczFo: // global
           (_cczFj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczFj::I64 == 0) goto cczFl; else goto cczFk;
       cczFl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczFk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczFj::I64;
           R2 = GHC.ByteOrder.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl5_rcyks_info" {
     lvl5_rcyks_info:
         const lvl5_rcyks_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.650201123 UTC

[section ""cstring" . lvl6_rcykt_bytes" {
     lvl6_rcykt_bytes:
         I8[] [46,47,71,72,67,47,66,121,116,101,79,114,100,101,114,46,104,115]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.652456852 UTC

[section ""data" . lvl7_rcyku_closure" {
     lvl7_rcyku_closure:
         const lvl7_rcyku_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_rcyku_entry() //  [R1]
         { []
         }
     {offset
       cczFD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczFE; else goto cczFF;
       cczFE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczFF: // global
           (_cczFA::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczFA::I64 == 0) goto cczFC; else goto cczFB;
       cczFC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczFB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczFA::I64;
           R2 = lvl6_rcykt_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl7_rcyku_info" {
     lvl7_rcyku_info:
         const lvl7_rcyku_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.656051125 UTC

[section ""data" . lvl8_rcykv_closure" {
     lvl8_rcykv_closure:
         const GHC.Types.I#_con_info;
         const 26;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.657774256 UTC

[section ""data" . lvl9_rcykw_closure" {
     lvl9_rcykw_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.659503051 UTC

[section ""data" . lvl10_rcykx_closure" {
     lvl10_rcykx_closure:
         const GHC.Types.I#_con_info;
         const 20;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.661595819 UTC

[section ""data" . lvl11_rcyky_closure" {
     lvl11_rcyky_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl4_rcykr_closure;
         const lvl5_rcyks_closure;
         const lvl7_rcyku_closure;
         const lvl8_rcykv_closure+1;
         const lvl9_rcykw_closure+1;
         const lvl8_rcykv_closure+1;
         const lvl10_rcykx_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.663429872 UTC

[section ""data" . lvl12_rcykz_closure" {
     lvl12_rcykz_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl3_rcykq_closure;
         const lvl11_rcyky_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.665274447 UTC

[section ""cstring" . lvl13_rcykA_bytes" {
     lvl13_rcykA_bytes:
         I8[] [112,114,101,100,123,66,121,116,101,79,114,100,101,114,125,58,32,116,114,105,101,100,32,116,111,32,116,97,107,101,32,96,112,114,101,100,39,32,111,102,32,102,105,114,115,116,32,116,97,103,32,105,110,32,101,110,117,109,101,114,97,116,105,111,110]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.667900665 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder3_closure" {
     GHC.ByteOrder.$fEnumByteOrder3_closure:
         const GHC.ByteOrder.$fEnumByteOrder3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder3_entry() //  [R1]
         { []
         }
     {offset
       cczG1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cczG2; else goto cczG3;
       cczG2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczG3: // global
           (_cczFW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczFW::I64 == 0) goto cczFY; else goto cczFX;
       cczFY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczFX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczFW::I64;
           I64[Sp - 24] = block_cczFZ_info;
           R2 = lvl13_rcykA_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder3_info" {
     GHC.ByteOrder.$fEnumByteOrder3_info:
         const GHC.ByteOrder.$fEnumByteOrder3_entry;
         const 0;
         const 12884901909;
         const ScypP_srt+112;
 },
 _cczFZ() //  [R1]
         { []
         }
     {offset
       cczFZ: // global
           R3 = R1;
           R2 = lvl12_rcykz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cczFZ_info" {
     block_cczFZ_info:
         const _cczFZ;
         const 0;
         const 12884901918;
         const ScypP_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.675206794 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cpred_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cpred_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cpred_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cpred_entry() //  [R2]
         { []
         }
     {offset
       cczGs: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cczGt; else goto cczGu;
       cczGt: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczGu: // global
           I64[Sp - 8] = block_cczGl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uczGB; else goto cczGm;
       uczGB: // global
           call _cczGl(R1) args: 0, res: 0, upd: 0;
       cczGm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_$cpred_info" {
     GHC.ByteOrder.$fEnumByteOrder_$cpred_info:
         const GHC.ByteOrder.$fEnumByteOrder_$cpred_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const ScypP_srt+128;
 },
 _cczGl() //  [R1]
         { []
         }
     {offset
       cczGl: // global
           if (R1 & 7 == 1) goto cczGp; else goto cczGq;
       cczGp: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cczGq: // global
           R1 = GHC.ByteOrder.BigEndian_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczGl_info" {
     block_cczGl_info:
         const _cczGl;
         const 0;
         const 4294967326;
         const ScypP_srt+136;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.680119277 UTC

[section ""cstring" . lvl14_rcykB_bytes" {
     lvl14_rcykB_bytes:
         I8[] [115,117,99,99,123,66,121,116,101,79,114,100,101,114,125,58,32,116,114,105,101,100,32,116,111,32,116,97,107,101,32,96,115,117,99,99,39,32,111,102,32,108,97,115,116,32,116,97,103,32,105,110,32,101,110,117,109,101,114,97,116,105,111,110]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.682843269 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder4_closure" {
     GHC.ByteOrder.$fEnumByteOrder4_closure:
         const GHC.ByteOrder.$fEnumByteOrder4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder4_entry() //  [R1]
         { []
         }
     {offset
       cczGY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cczGZ; else goto cczH0;
       cczGZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczH0: // global
           (_cczGT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczGT::I64 == 0) goto cczGV; else goto cczGU;
       cczGV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczGU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczGT::I64;
           I64[Sp - 24] = block_cczGW_info;
           R2 = lvl14_rcykB_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder4_info" {
     GHC.ByteOrder.$fEnumByteOrder4_info:
         const GHC.ByteOrder.$fEnumByteOrder4_entry;
         const 0;
         const 12884901909;
         const ScypP_srt+112;
 },
 _cczGW() //  [R1]
         { []
         }
     {offset
       cczGW: // global
           R3 = R1;
           R2 = lvl12_rcykz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cczGW_info" {
     block_cczGW_info:
         const _cczGW;
         const 0;
         const 12884901918;
         const ScypP_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.688676031 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$csucc_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$csucc_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$csucc_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$csucc_entry() //  [R2]
         { []
         }
     {offset
       cczHp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cczHq; else goto cczHr;
       cczHq: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczHr: // global
           I64[Sp - 8] = block_cczHi_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uczHy; else goto cczHj;
       uczHy: // global
           call _cczHi(R1) args: 0, res: 0, upd: 0;
       cczHj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_$csucc_info" {
     GHC.ByteOrder.$fEnumByteOrder_$csucc_info:
         const GHC.ByteOrder.$fEnumByteOrder_$csucc_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const ScypP_srt+144;
 },
 _cczHi() //  [R1]
         { []
         }
     {offset
       cczHi: // global
           if (R1 & 7 == 1) goto cczHm; else goto cczHn;
       cczHm: // global
           R1 = GHC.ByteOrder.LittleEndian_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczHn: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczHi_info" {
     block_cczHi_info:
         const _cczHi;
         const 0;
         const 4294967326;
         const ScypP_srt+152;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.693990633 UTC

[section ""cstring" . lvl15_rcykC_bytes" {
     lvl15_rcykC_bytes:
         I8[] [41,32,105,115,32,111,117,116,115,105,100,101,32,111,102,32,101,110,117,109,101,114,97,116,105,111,110,39,115,32,114,97,110,103,101,32,40,48,44]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.695680597 UTC

[section ""cstring" . lvl16_rcykD_bytes" {
     lvl16_rcykD_bytes:
         I8[] [41]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.697946647 UTC

[section ""data" . lvl17_rcykE_closure" {
     lvl17_rcykE_closure:
         const lvl17_rcykE_info;
         const 0;
         const 0;
         const 0;
 },
 lvl17_rcykE_entry() //  [R1]
         { []
         }
     {offset
       cczHU: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczHV; else goto cczHW;
       cczHV: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczHW: // global
           (_cczHR::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczHR::I64 == 0) goto cczHT; else goto cczHS;
       cczHT: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczHS: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczHR::I64;
           R2 = lvl16_rcykD_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl17_rcykE_info" {
     lvl17_rcykE_info:
         const lvl17_rcykE_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.702612251 UTC

[section ""data" . lvl18_rcykF_closure" {
     lvl18_rcykF_closure:
         const lvl18_rcykF_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_rcykF_entry() //  [R1]
         { []
         }
     {offset
       cczId: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cczIe; else goto cczIf;
       cczIe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczIf: // global
           (_cczI7::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczI7::I64 == 0) goto cczI9; else goto cczI8;
       cczI9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczI8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczI7::I64;
           I64[Sp - 24] = block_cczIa_info;
           R4 = lvl17_rcykE_closure;
           R3 = 1;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . lvl18_rcykF_info" {
     lvl18_rcykF_info:
         const lvl18_rcykF_entry;
         const 0;
         const 4294967317;
         const ScypP_srt+160;
 },
 _cczIa() //  [R1, R2]
         { []
         }
     {offset
       cczIa: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczIi; else goto cczIh;
       cczIi: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cczIh: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cczIa_info" {
     block_cczIa_info:
         const _cczIa;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.708929544 UTC

[section ""data" . lvl19_rcykG_closure" {
     lvl19_rcykG_closure:
         const lvl19_rcykG_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_rcykG_entry() //  [R1]
         { []
         }
     {offset
       cczIA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczIB; else goto cczIC;
       cczIB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczIC: // global
           (_cczIx::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczIx::I64 == 0) goto cczIz; else goto cczIy;
       cczIz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczIy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczIx::I64;
           R3 = lvl18_rcykF_closure;
           R2 = lvl15_rcykC_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl19_rcykG_info" {
     lvl19_rcykG_info:
         const lvl19_rcykG_entry;
         const 0;
         const 4294967317;
         const ScypP_srt+168;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.712774708 UTC

[section ""cstring" . lvl20_rcykH_bytes" {
     lvl20_rcykH_bytes:
         I8[] [116,111,69,110,117,109,123,66,121,116,101,79,114,100,101,114,125,58,32,116,97,103,32,40]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.717355389 UTC

[section ""data" . GHC.ByteOrder.$wlvl_closure" {
     GHC.ByteOrder.$wlvl_closure:
         const GHC.ByteOrder.$wlvl_info;
         const 0;
 },
 sat_scylU_entry() //  [R1]
         { []
         }
     {offset
       cczIW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cczIX; else goto cczIY;
       cczIX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczIY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cczIT_info;
           R4 = lvl19_rcykG_closure;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_scylU_info" {
     sat_scylU_info:
         const sat_scylU_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+176;
 },
 _cczIT() //  [R1, R2]
         { []
         }
     {offset
       cczIT: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczJ1; else goto cczJ0;
       cczJ1: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cczJ0: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cczIT_info" {
     block_cczIT_info:
         const _cczIT;
         const 0;
         const 30;
 },
 GHC.ByteOrder.$wlvl_entry() //  [R2]
         { []
         }
     {offset
       cczJ4: // global
           _scylQ::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cczJ5; else goto cczJ6;
       cczJ6: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczJ8; else goto cczJ7;
       cczJ8: // global
           HpAlloc = 24;
           goto cczJ5;
       cczJ5: // global
           R2 = _scylQ::I64;
           R1 = GHC.ByteOrder.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczJ7: // global
           I64[Hp - 16] = sat_scylU_info;
           I64[Hp] = _scylQ::I64;
           I64[Sp - 8] = block_cczJ2_info;
           R3 = Hp - 16;
           R2 = lvl20_rcykH_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$wlvl_info" {
     GHC.ByteOrder.$wlvl_info:
         const GHC.ByteOrder.$wlvl_entry;
         const 0;
         const 3311419785230;
         const 4294967300;
         const ScypP_srt+112;
 },
 _cczJ2() //  [R1]
         { []
         }
     {offset
       cczJ2: // global
           R3 = R1;
           R2 = lvl12_rcykz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczJ2_info" {
     block_cczJ2_info:
         const _cczJ2;
         const 0;
         const 12884901918;
         const ScypP_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.726473084 UTC

[section ""data" . GHC.ByteOrder.$w$ctoEnum_closure" {
     GHC.ByteOrder.$w$ctoEnum_closure:
         const GHC.ByteOrder.$w$ctoEnum_info;
         const 0;
 },
 GHC.ByteOrder.$w$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       cczJB: // global
           _scylW::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto cczJJ; else goto cczJA;
       cczJA: // global
           if (%MO_S_Gt_W64(_scylW::I64, 1)) goto cczJJ; else goto cczJK;
       cczJJ: // global
           R2 = _scylW::I64;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       cczJK: // global
           R1 = I64[(_scylW::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$w$ctoEnum_info" {
     GHC.ByteOrder.$w$ctoEnum_info:
         const GHC.ByteOrder.$w$ctoEnum_entry;
         const 0;
         const 4294967310;
         const 4294967300;
         const ScypP_srt+184;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.730638904 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       cczJY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cczJZ; else goto cczK0;
       cczJZ: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczK0: // global
           I64[Sp - 8] = block_cczJV_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uczK4; else goto cczJW;
       uczK4: // global
           call _cczJV(R1) args: 0, res: 0, upd: 0;
       cczJW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_info" {
     GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_info:
         const GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const ScypP_srt+192;
 },
 _cczJV() //  [R1]
         { []
         }
     {offset
       cczJV: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.ByteOrder.$w$ctoEnum_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczJV_info" {
     block_cczJV_info:
         const _cczJV;
         const 0;
         const 4294967326;
         const ScypP_srt+200;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.737716849 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_go2_closure" {
     GHC.ByteOrder.$fEnumByteOrder_go2_closure:
         const GHC.ByteOrder.$fEnumByteOrder_go2_info;
 },
 sat_scym6_entry() //  [R1]
         { []
         }
     {offset
       cczKq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczKr; else goto cczKs;
       cczKr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczKs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scym4::I64 = I64[R1 + 16];
           if (_scym4::I64 != 1) goto cczKo; else goto cczKp;
       cczKo: // global
           R2 = _scym4::I64 + 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go2_entry(R2) args: 24, res: 0, upd: 24;
       cczKp: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scym6_info" {
     sat_scym6_info:
         const sat_scym6_entry;
         const 4294967296;
         const 17;
 },
 sat_scym3_entry() //  [R1]
         { []
         }
     {offset
       cczKz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczKA; else goto cczKB;
       cczKA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczKB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scym3_info" {
     sat_scym3_info:
         const sat_scym3_entry;
         const 4294967296;
         const 17;
 },
 GHC.ByteOrder.$fEnumByteOrder_go2_entry() //  [R2]
         { []
         }
     {offset
       cczKD: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cczKH; else goto cczKG;
       cczKH: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_go2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczKG: // global
           I64[Hp - 64] = sat_scym6_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scym3_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_go2_info" {
     GHC.ByteOrder.$fEnumByteOrder_go2_info:
         const GHC.ByteOrder.$fEnumByteOrder_go2_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.746210358 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder2_closure" {
     GHC.ByteOrder.$fEnumByteOrder2_closure:
         const GHC.ByteOrder.$fEnumByteOrder2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder2_entry() //  [R1]
         { []
         }
     {offset
       cczL6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczL7; else goto cczL8;
       cczL7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczL8: // global
           (_cczL3::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczL3::I64 == 0) goto cczL5; else goto cczL4;
       cczL5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczL4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczL3::I64;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder2_info" {
     GHC.ByteOrder.$fEnumByteOrder2_info:
         const GHC.ByteOrder.$fEnumByteOrder2_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.750957434 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder1_closure" {
     GHC.ByteOrder.$fEnumByteOrder1_closure:
         const GHC.ByteOrder.$fEnumByteOrder1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder1_entry() //  [R1]
         { []
         }
     {offset
       cczLm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczLn; else goto cczLo;
       cczLn: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczLo: // global
           (_cczLj::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cczLj::I64 == 0) goto cczLl; else goto cczLk;
       cczLl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cczLk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cczLj::I64;
           R2 = 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder1_info" {
     GHC.ByteOrder.$fEnumByteOrder1_info:
         const GHC.ByteOrder.$fEnumByteOrder1_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.755327115 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_entry() //  [R2]
         { []
         }
     {offset
       cczLH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cczLI; else goto cczLJ;
       cczLI: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczLJ: // global
           I64[Sp - 8] = block_cczLA_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uczLQ; else goto cczLB;
       uczLQ: // global
           call _cczLA(R1) args: 0, res: 0, upd: 0;
       cczLB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_info" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_info:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_entry;
         const 0;
         const 30064771086;
         const 4294967301;
         const ScypP_srt+208;
 },
 _cczLA() //  [R1]
         { []
         }
     {offset
       cczLA: // global
           if (R1 & 7 == 1) goto cczLE; else goto cczLF;
       cczLE: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cczLF: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczLA_info" {
     block_cczLA_info:
         const _cczLA;
         const 0;
         const 12884901918;
         const ScypP_srt+216;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.77819091 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_info;
 },
 sat_scymq_entry() //  [R1]
         { []
         }
     {offset
       cczMP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczMQ; else goto cczMR;
       cczMQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczMR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scyml_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scymq_info" {
     sat_scymq_info:
         const sat_scymq_entry;
         const 8589934593;
         const 15;
 },
 sat_scymo_entry() //  [R1]
         { []
         }
     {offset
       cczMW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczMX; else goto cczMY;
       cczMX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczMY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scymo_info" {
     sat_scymo_info:
         const sat_scymo_entry;
         const 4294967296;
         const 17;
 },
 sat_scymr_entry() //  [R1]
         { []
         }
     {offset
       cczN4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczN5; else goto cczN6;
       cczN5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczN6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scymr_info" {
     sat_scymr_info:
         const sat_scymr_entry;
         const 4294967296;
         const 17;
 },
 go_dn_scyml_entry() //  [R1, R2]
         { []
         }
     {offset
       cczNa: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cczNe; else goto cczNd;
       cczNe: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczNd: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto cczN8; else goto cczN9;
       cczN8: // global
           _scymj::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scymq_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scymj::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scymo_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczN9: // global
           I64[Hp - 80] = sat_scymr_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _cczNg::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _cczNg::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_scyml_info" {
     go_dn_scyml_info:
         const go_dn_scyml_entry;
         const 8589934592;
         const 13;
         const 4294967300;
 },
 sat_scyms_entry() //  [R1]
         { []
         }
     {offset
       cczNh: // global
           _scyms::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cczNi; else goto cczNj;
       cczNj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczNl; else goto cczNk;
       cczNl: // global
           HpAlloc = 24;
           goto cczNi;
       cczNi: // global
           R1 = _scyms::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczNk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyms::P64;
           _scyme::I64 = I64[_scyms::P64 + 24];
           _scymj::I64 = _scyme::I64 - I64[_scyms::P64 + 16];
           I64[Hp - 16] = go_dn_scyml_info;
           I64[Hp - 8] = _scymj::I64;
           I64[Hp] = 1 - _scymj::I64;
           R2 = _scyme::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scyml_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyms_info" {
     sat_scyms_info:
         const sat_scyms_entry;
         const 8589934592;
         const 20;
 },
 sat_scymi_entry() //  [R1]
         { []
         }
     {offset
       cczNq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczNr; else goto cczNs;
       cczNr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczNs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scymi_info" {
     sat_scymi_info:
         const sat_scymi_entry;
         const 4294967296;
         const 17;
 },
 sat_scymu_entry() //  [R1]
         { []
         }
     {offset
       cczNB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczNC; else goto cczND;
       cczNC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczND: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scymu_info" {
     sat_scymu_info:
         const sat_scymu_entry;
         const 4294967296;
         const 17;
 },
 sat_scymE_entry() //  [R1]
         { []
         }
     {offset
       cczO6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczO7; else goto cczO8;
       cczO7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczO8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scymz_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scymE_info" {
     sat_scymE_info:
         const sat_scymE_entry;
         const 8589934593;
         const 15;
 },
 sat_scymC_entry() //  [R1]
         { []
         }
     {offset
       cczOd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczOe; else goto cczOf;
       cczOe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczOf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scymC_info" {
     sat_scymC_info:
         const sat_scymC_entry;
         const 4294967296;
         const 17;
 },
 sat_scymF_entry() //  [R1]
         { []
         }
     {offset
       cczOl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczOm; else goto cczOn;
       cczOm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczOn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scymF_info" {
     sat_scymF_info:
         const sat_scymF_entry;
         const 4294967296;
         const 17;
 },
 go_up_scymz_entry() //  [R1, R2]
         { []
         }
     {offset
       cczOr: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cczOv; else goto cczOu;
       cczOv: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczOu: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto cczOp; else goto cczOq;
       cczOp: // global
           _scymx::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scymE_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scymx::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scymC_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczOq: // global
           I64[Hp - 80] = sat_scymF_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _cczOx::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _cczOx::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_scymz_info" {
     go_up_scymz_info:
         const go_up_scymz_entry;
         const 8589934592;
         const 13;
         const 4294967300;
 },
 sat_scymG_entry() //  [R1]
         { []
         }
     {offset
       cczOy: // global
           _scymG::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cczOz; else goto cczOA;
       cczOA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczOC; else goto cczOB;
       cczOC: // global
           HpAlloc = 24;
           goto cczOz;
       cczOz: // global
           R1 = _scymG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczOB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scymG::P64;
           _scyme::I64 = I64[_scymG::P64 + 24];
           _scymx::I64 = _scyme::I64 - I64[_scymG::P64 + 16];
           I64[Hp - 16] = go_up_scymz_info;
           I64[Hp - 8] = _scymx::I64;
           I64[Hp] = 1 - _scymx::I64;
           R2 = _scyme::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scymz_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scymG_info" {
     sat_scymG_info:
         const sat_scymG_entry;
         const 8589934592;
         const 20;
 },
 sat_scymw_entry() //  [R1]
         { []
         }
     {offset
       cczOH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczOI; else goto cczOJ;
       cczOI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczOJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scymw_info" {
     sat_scymw_info:
         const sat_scymw_entry;
         const 4294967296;
         const 17;
 },
 sat_scymI_entry() //  [R1]
         { []
         }
     {offset
       cczOS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczOT; else goto cczOU;
       cczOT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczOU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scymI_info" {
     sat_scymI_info:
         const sat_scymI_entry;
         const 4294967296;
         const 17;
 },
 sat_scymT_entry() //  [R1]
         { []
         }
     {offset
       cczPq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczPr; else goto cczPs;
       cczPr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczPs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scymO_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scymT_info" {
     sat_scymT_info:
         const sat_scymT_entry;
         const 8589934593;
         const 15;
 },
 sat_scymR_entry() //  [R1]
         { []
         }
     {offset
       cczPx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczPy; else goto cczPz;
       cczPy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczPz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scymR_info" {
     sat_scymR_info:
         const sat_scymR_entry;
         const 4294967296;
         const 17;
 },
 sat_scymU_entry() //  [R1]
         { []
         }
     {offset
       cczPF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczPG; else goto cczPH;
       cczPG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczPH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scymU_info" {
     sat_scymU_info:
         const sat_scymU_entry;
         const 4294967296;
         const 17;
 },
 go_dn_scymO_entry() //  [R1, R2]
         { []
         }
     {offset
       cczPL: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cczPP; else goto cczPO;
       cczPP: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczPO: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto cczPJ; else goto cczPK;
       cczPJ: // global
           _scymM::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scymT_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scymM::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scymR_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczPK: // global
           I64[Hp - 80] = sat_scymU_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _cczPR::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _cczPR::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_scymO_info" {
     go_dn_scymO_info:
         const go_dn_scymO_entry;
         const 8589934592;
         const 13;
         const 4294967300;
 },
 sat_scymV_entry() //  [R1]
         { []
         }
     {offset
       cczPS: // global
           _scymV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cczPT; else goto cczPU;
       cczPU: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczPW; else goto cczPV;
       cczPW: // global
           HpAlloc = 24;
           goto cczPT;
       cczPT: // global
           R1 = _scymV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczPV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scymV::P64;
           _scyme::I64 = I64[_scymV::P64 + 24];
           _scymM::I64 = _scyme::I64 - I64[_scymV::P64 + 16];
           I64[Hp - 16] = go_dn_scymO_info;
           I64[Hp - 8] = _scymM::I64;
           I64[Hp] = 0 - _scymM::I64;
           R2 = _scyme::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scymO_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scymV_info" {
     sat_scymV_info:
         const sat_scymV_entry;
         const 8589934592;
         const 20;
 },
 sat_scymL_entry() //  [R1]
         { []
         }
     {offset
       cczQ1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczQ2; else goto cczQ3;
       cczQ2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczQ3: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scymL_info" {
     sat_scymL_info:
         const sat_scymL_entry;
         const 4294967296;
         const 17;
 },
 sat_scymX_entry() //  [R1]
         { []
         }
     {offset
       cczQc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczQd; else goto cczQe;
       cczQd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczQe: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scymX_info" {
     sat_scymX_info:
         const sat_scymX_entry;
         const 4294967296;
         const 17;
 },
 sat_scyn7_entry() //  [R1]
         { []
         }
     {offset
       cczQH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczQI; else goto cczQJ;
       cczQI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczQJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scyn2_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyn7_info" {
     sat_scyn7_info:
         const sat_scyn7_entry;
         const 8589934593;
         const 15;
 },
 sat_scyn5_entry() //  [R1]
         { []
         }
     {offset
       cczQO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczQP; else goto cczQQ;
       cczQP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczQQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyn5_info" {
     sat_scyn5_info:
         const sat_scyn5_entry;
         const 4294967296;
         const 17;
 },
 sat_scyn8_entry() //  [R1]
         { []
         }
     {offset
       cczQW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczQX; else goto cczQY;
       cczQX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczQY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyn8_info" {
     sat_scyn8_info:
         const sat_scyn8_entry;
         const 4294967296;
         const 17;
 },
 go_up_scyn2_entry() //  [R1, R2]
         { []
         }
     {offset
       cczR2: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto cczR6; else goto cczR5;
       cczR6: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczR5: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto cczR0; else goto cczR1;
       cczR0: // global
           _scyn0::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scyn7_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scyn0::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scyn5_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczR1: // global
           I64[Hp - 80] = sat_scyn8_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _cczR8::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _cczR8::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_scyn2_info" {
     go_up_scyn2_info:
         const go_up_scyn2_entry;
         const 8589934592;
         const 13;
         const 4294967300;
 },
 sat_scyn9_entry() //  [R1]
         { []
         }
     {offset
       cczR9: // global
           _scyn9::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cczRa; else goto cczRb;
       cczRb: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cczRd; else goto cczRc;
       cczRd: // global
           HpAlloc = 24;
           goto cczRa;
       cczRa: // global
           R1 = _scyn9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczRc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyn9::P64;
           _scyme::I64 = I64[_scyn9::P64 + 24];
           _scyn0::I64 = _scyme::I64 - I64[_scyn9::P64 + 16];
           I64[Hp - 16] = go_up_scyn2_info;
           I64[Hp - 8] = _scyn0::I64;
           I64[Hp] = 0 - _scyn0::I64;
           R2 = _scyme::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scyn2_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyn9_info" {
     sat_scyn9_info:
         const sat_scyn9_entry;
         const 8589934592;
         const 20;
 },
 sat_scymZ_entry() //  [R1]
         { []
         }
     {offset
       cczRi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczRj; else goto cczRk;
       cczRj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczRk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scymZ_info" {
     sat_scymZ_info:
         const sat_scymZ_entry;
         const 4294967296;
         const 17;
 },
 sat_scynb_entry() //  [R1]
         { []
         }
     {offset
       cczRt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczRu; else goto cczRv;
       cczRu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczRv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scynb_info" {
     sat_scynb_info:
         const sat_scynb_entry;
         const 4294967296;
         const 17;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_entry() //  [R2, R3]
         { []
         }
     {offset
       cczRD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczRE; else goto cczRF;
       cczRE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczRF: // global
           I64[Sp - 16] = block_cczRw_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczSN; else goto cczRx;
       uczSN: // global
           call _cczRw(R1) args: 0, res: 0, upd: 0;
       cczRx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_info" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_info:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cczRw() //  [R1]
         { []
         }
     {offset
       cczRw: // global
           _scyma::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczRA; else goto cczRB;
       cczRA: // global
           _scymc::I64 = 0;
           goto scymb;
       cczRB: // global
           _scymc::I64 = 1;
           goto scymb;
       scymb: // global
           I64[Sp] = block_cczRG_info;
           R1 = _scyma::P64;
           I64[Sp + 8] = _scymc::I64;
           if (R1 & 7 != 0) goto uczSM; else goto cczSq;
       uczSM: // global
           call _cczRG(R1) args: 0, res: 0, upd: 0;
       cczSq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cczRw_info" {
     block_cczRw_info:
         const _cczRw;
         const 1;
         const 30;
 },
 _cczRG() //  [R1]
         { []
         }
     {offset
       cczRG: // global
           if (R1 & 7 == 1) goto cczSw; else goto cczSA;
       cczSw: // global
           I64[Sp] = 0;
           goto uczSP;
       cczSA: // global
           I64[Sp] = 1;
           goto uczSP;
       uczSP: // global
           call _cczMg() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cczRG_info" {
     block_cczRG_info:
         const _cczRG;
         const 65;
         const 30;
 },
 _cczMg() //  []
         { []
         }
     {offset
       cczMg: // global
           Hp = Hp + 80;
           _scyme::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto cczRK; else goto cczRJ;
       cczRK: // global
           HpAlloc = 80;
           I64[Sp] = block_cczMf_info;
           R1 = _scyme::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cczRJ: // global
           _scymc::I64 = I64[Sp + 8];
           if (%MO_S_Le_W64(_scymc::I64,
                            _scyme::I64)) goto cczS5; else goto cczSp;
       cczS5: // global
           if (%MO_S_Lt_W64(_scyme::I64,
                            _scymc::I64)) goto cczRU; else goto cczS3;
       cczRU: // global
           if (%MO_S_Le_W64(1, _scyme::I64)) goto cczRN; else goto cczRS;
       cczRN: // global
           I64[Hp - 72] = sat_scyms_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = _scyme::I64;
           I64[Hp - 40] = sat_scymi_info;
           I64[Hp - 24] = _scymc::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczRS: // global
           if (%MO_S_Gt_W64(1, _scymc::I64)) goto cczSm; else goto cczRQ;
       cczRQ: // global
           I64[Hp - 72] = sat_scymu_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cczRO::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cczRO::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczS3: // global
           if (%MO_S_Ge_W64(1, _scyme::I64)) goto cczRX; else goto cczS2;
       cczRX: // global
           I64[Hp - 72] = sat_scymG_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = _scyme::I64;
           I64[Hp - 40] = sat_scymw_info;
           I64[Hp - 24] = _scymc::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczS2: // global
           if (%MO_S_Lt_W64(1, _scymc::I64)) goto cczSm; else goto cczS0;
       cczS0: // global
           I64[Hp - 72] = sat_scymI_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cczRY::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cczRY::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczSp: // global
           if (%MO_S_Lt_W64(_scyme::I64,
                            _scymc::I64)) goto cczSf; else goto cczSo;
       cczSf: // global
           if (%MO_S_Le_W64(0, _scyme::I64)) goto cczS8; else goto cczSd;
       cczS8: // global
           I64[Hp - 72] = sat_scymV_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = _scyme::I64;
           I64[Hp - 40] = sat_scymL_info;
           I64[Hp - 24] = _scymc::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczSd: // global
           if (%MO_S_Gt_W64(0, _scymc::I64)) goto cczSm; else goto cczSb;
       cczSb: // global
           I64[Hp - 72] = sat_scymX_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cczS9::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cczS9::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczSo: // global
           if (%MO_S_Ge_W64(0, _scyme::I64)) goto cczSi; else goto cczSn;
       cczSi: // global
           I64[Hp - 72] = sat_scyn9_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = _scyme::I64;
           I64[Hp - 40] = sat_scymZ_info;
           I64[Hp - 24] = _scymc::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczSn: // global
           if (%MO_S_Lt_W64(0, _scymc::I64)) goto cczSm; else goto cczSl;
       cczSm: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczSl: // global
           I64[Hp - 72] = sat_scynb_info;
           I64[Hp - 56] = _scymc::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cczSj::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cczSj::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _cczMf() //  [R1]
         { []
         }
     {offset
       cczMf: // global
           I64[Sp] = R1;
           call _cczMg() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cczMf_info" {
     block_cczMf_info:
         const _cczMf;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.843647414 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_go1_closure" {
     GHC.ByteOrder.$fEnumByteOrder_go1_closure:
         const GHC.ByteOrder.$fEnumByteOrder_go1_info;
         const 0;
 },
 sat_scynk_entry() //  [R1]
         { []
         }
     {offset
       cczWD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczWE; else goto cczWF;
       cczWE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczWF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyni::I64 = I64[R1 + 16];
           if (_scyni::I64 != 0) goto cczWB; else goto cczWC;
       cczWB: // global
           R2 = _scyni::I64 + 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go1_entry(R2) args: 24, res: 0, upd: 24;
       cczWC: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scynk_info" {
     sat_scynk_info:
         const sat_scynk_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+232;
 },
 sat_scynh_entry() //  [R1]
         { []
         }
     {offset
       cczWR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczWS; else goto cczX0;
       cczWS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczX0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyne::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyne::I64, 0)) goto cczWY; else goto cczWQ;
       cczWQ: // global
           if (%MO_S_Gt_W64(_scyne::I64, 1)) goto cczWY; else goto cczWZ;
       cczWY: // global
           R2 = _scyne::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczWZ: // global
           R1 = I64[(_scyne::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scynh_info" {
     sat_scynh_info:
         const sat_scynh_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+184;
 },
 GHC.ByteOrder.$fEnumByteOrder_go1_entry() //  [R2]
         { []
         }
     {offset
       cczX2: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cczX6; else goto cczX5;
       cczX6: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_go1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczX5: // global
           I64[Hp - 64] = sat_scynk_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scynh_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_go1_info" {
     GHC.ByteOrder.$fEnumByteOrder_go1_info:
         const GHC.ByteOrder.$fEnumByteOrder_go1_entry;
         const 0;
         const 279172874254;
         const 4294967300;
         const ScypP_srt+184;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.853001335 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_go_closure" {
     GHC.ByteOrder.$fEnumByteOrder_go_closure:
         const GHC.ByteOrder.$fEnumByteOrder_go_info;
         const 0;
 },
 sat_scynr_entry() //  [R1]
         { []
         }
     {offset
       cczXB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczXC; else goto cczXD;
       cczXC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczXD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynp::I64 = I64[R1 + 16];
           if (_scynp::I64 != 1) goto cczXz; else goto cczXA;
       cczXz: // global
           R2 = _scynp::I64 + 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go_entry(R2) args: 24, res: 0, upd: 24;
       cczXA: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scynr_info" {
     sat_scynr_info:
         const sat_scynr_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+240;
 },
 sat_scyno_entry() //  [R1]
         { []
         }
     {offset
       cczXP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczXQ; else goto cczXY;
       cczXQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cczXY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynl::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynl::I64, 0)) goto cczXW; else goto cczXO;
       cczXO: // global
           if (%MO_S_Gt_W64(_scynl::I64, 1)) goto cczXW; else goto cczXX;
       cczXW: // global
           R2 = _scynl::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       cczXX: // global
           R1 = I64[(_scynl::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyno_info" {
     sat_scyno_info:
         const sat_scyno_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+184;
 },
 GHC.ByteOrder.$fEnumByteOrder_go_entry() //  [R2]
         { []
         }
     {offset
       cczY0: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cczY4; else goto cczY3;
       cczY4: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cczY3: // global
           I64[Hp - 64] = sat_scynr_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scyno_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_go_info" {
     GHC.ByteOrder.$fEnumByteOrder_go_info:
         const GHC.ByteOrder.$fEnumByteOrder_go_entry;
         const 0;
         const 554050781198;
         const 4294967300;
         const ScypP_srt+184;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.862201411 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       cczYA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cczYB; else goto cczYC;
       cczYB: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cczYC: // global
           I64[Sp - 16] = block_cczYt_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uczZb; else goto cczYu;
       uczZb: // global
           call _cczYt(R1) args: 0, res: 0, upd: 0;
       cczYu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_info" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_info:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_entry;
         const 0;
         const 30064771086;
         const 8589934607;
         const ScypP_srt+232;
 },
 _cczYt() //  [R1]
         { []
         }
     {offset
       cczYt: // global
           _scynt::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cczYx; else goto cczYy;
       cczYx: // global
           _scynv::I64 = 0;
           goto scynu;
       cczYy: // global
           _scynv::I64 = 1;
           goto scynu;
       scynu: // global
           I64[Sp] = block_cczYG_info;
           R1 = _scynt::P64;
           I64[Sp + 8] = _scynv::I64;
           if (R1 & 7 != 0) goto uczZa; else goto cczYI;
       uczZa: // global
           call _cczYG(R1) args: 0, res: 0, upd: 0;
       cczYI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cczYt_info" {
     block_cczYt_info:
         const _cczYt;
         const 1;
         const 12884901918;
         const ScypP_srt+232;
 },
 _cczYG() //  [R1]
         { []
         }
     {offset
       cczYG: // global
           _scynv::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cczYT; else goto cczZ2;
       cczYT: // global
           if (%MO_S_Gt_W64(_scynv::I64, 0)) goto cczZ1; else goto cczYQ;
       cczYQ: // global
           R2 = _scynv::I64;
           Sp = Sp + 16;
           call GHC.ByteOrder.$fEnumByteOrder_go1_entry(R2) args: 8, res: 0, upd: 8;
       cczZ2: // global
           if (%MO_S_Gt_W64(_scynv::I64, 1)) goto cczZ1; else goto cczZ0;
       cczZ1: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cczZ0: // global
           R2 = _scynv::I64;
           Sp = Sp + 16;
           call GHC.ByteOrder.$fEnumByteOrder_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczYG_info" {
     block_cczYG_info:
         const _cczYG;
         const 65;
         const 12884901918;
         const ScypP_srt+232;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.891189051 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_info;
         const 0;
 },
 sat_scynW_entry() //  [R1]
         { []
         }
     {offset
       ccA0h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA0i; else goto ccA0j;
       ccA0i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA0j: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scynP_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scynW_info" {
     sat_scynW_info:
         const sat_scynW_entry;
         const 8589934593;
         const 4294967311;
         const ScypP_srt+184;
 },
 sat_scynU_entry() //  [R1]
         { []
         }
     {offset
       ccA0t: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA0u; else goto ccA0C;
       ccA0u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA0C: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynQ::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynQ::I64, 0)) goto ccA0A; else goto ccA0s;
       ccA0s: // global
           if (%MO_S_Gt_W64(_scynQ::I64, 1)) goto ccA0A; else goto ccA0B;
       ccA0A: // global
           R2 = _scynQ::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA0B: // global
           R1 = I64[(_scynQ::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scynU_info" {
     sat_scynU_info:
         const sat_scynU_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+184;
 },
 sat_scynZ_entry() //  [R1]
         { []
         }
     {offset
       ccA0N: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA0O; else goto ccA0W;
       ccA0O: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA0W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynQ::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynQ::I64, 0)) goto ccA0U; else goto ccA0M;
       ccA0M: // global
           if (%MO_S_Gt_W64(_scynQ::I64, 1)) goto ccA0U; else goto ccA0V;
       ccA0U: // global
           R2 = _scynQ::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA0V: // global
           R1 = I64[(_scynQ::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scynZ_info" {
     sat_scynZ_info:
         const sat_scynZ_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+184;
 },
 go_dn_scynP_entry() //  [R1, R2]
         { []
         }
     {offset
       ccA10: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccA14; else goto ccA13;
       ccA14: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccA13: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto ccA0Y; else goto ccA0Z;
       ccA0Y: // global
           _scynN::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scynW_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scynN::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scynU_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA0Z: // global
           I64[Hp - 80] = sat_scynZ_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccA16::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccA16::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_scynP_info" {
     go_dn_scynP_info:
         const go_dn_scynP_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const ScypP_srt+184;
 },
 sat_scyo0_entry() //  [R1]
         { []
         }
     {offset
       ccA17: // global
           _scyo0::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccA18; else goto ccA19;
       ccA19: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccA1b; else goto ccA1a;
       ccA1b: // global
           HpAlloc = 24;
           goto ccA18;
       ccA18: // global
           R1 = _scyo0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA1a: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyo0::P64;
           _scynG::I64 = I64[_scyo0::P64 + 24];
           _scynN::I64 = _scynG::I64 - I64[_scyo0::P64 + 16];
           I64[Hp - 16] = go_dn_scynP_info;
           I64[Hp - 8] = _scynN::I64;
           I64[Hp] = 0 - _scynN::I64;
           R2 = _scynG::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scynP_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyo0_info" {
     sat_scyo0_info:
         const sat_scyo0_entry;
         const 8589934592;
         const 4294967316;
         const ScypP_srt+184;
 },
 sat_scynM_entry() //  [R1]
         { []
         }
     {offset
       ccA1l: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA1m; else goto ccA1u;
       ccA1m: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA1u: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccA1s; else goto ccA1k;
       ccA1k: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccA1s; else goto ccA1t;
       ccA1s: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA1t: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scynM_info" {
     sat_scynM_info:
         const sat_scynM_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+184;
 },
 sat_scyo4_entry() //  [R1]
         { []
         }
     {offset
       ccA1I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA1J; else goto ccA1R;
       ccA1J: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA1R: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccA1P; else goto ccA1H;
       ccA1H: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccA1P; else goto ccA1Q;
       ccA1P: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA1Q: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyo4_info" {
     sat_scyo4_info:
         const sat_scyo4_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+184;
 },
 sat_scyoi_entry() //  [R1]
         { []
         }
     {offset
       ccA2k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA2l; else goto ccA2m;
       ccA2l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA2m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scyob_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyoi_info" {
     sat_scyoi_info:
         const sat_scyoi_entry;
         const 8589934593;
         const 4294967311;
         const ScypP_srt+184;
 },
 sat_scyog_entry() //  [R1]
         { []
         }
     {offset
       ccA2w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA2x; else goto ccA2F;
       ccA2x: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA2F: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoc::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoc::I64, 0)) goto ccA2D; else goto ccA2v;
       ccA2v: // global
           if (%MO_S_Gt_W64(_scyoc::I64, 1)) goto ccA2D; else goto ccA2E;
       ccA2D: // global
           R2 = _scyoc::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA2E: // global
           R1 = I64[(_scyoc::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyog_info" {
     sat_scyog_info:
         const sat_scyog_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+184;
 },
 sat_scyol_entry() //  [R1]
         { []
         }
     {offset
       ccA2Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA2R; else goto ccA2Z;
       ccA2R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA2Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoc::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoc::I64, 0)) goto ccA2X; else goto ccA2P;
       ccA2P: // global
           if (%MO_S_Gt_W64(_scyoc::I64, 1)) goto ccA2X; else goto ccA2Y;
       ccA2X: // global
           R2 = _scyoc::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA2Y: // global
           R1 = I64[(_scyoc::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyol_info" {
     sat_scyol_info:
         const sat_scyol_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+184;
 },
 go_up_scyob_entry() //  [R1, R2]
         { []
         }
     {offset
       ccA33: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccA37; else goto ccA36;
       ccA37: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccA36: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto ccA31; else goto ccA32;
       ccA31: // global
           _scyo9::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scyoi_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scyo9::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scyog_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA32: // global
           I64[Hp - 80] = sat_scyol_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccA39::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccA39::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_scyob_info" {
     go_up_scyob_info:
         const go_up_scyob_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const ScypP_srt+184;
 },
 sat_scyom_entry() //  [R1]
         { []
         }
     {offset
       ccA3a: // global
           _scyom::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccA3b; else goto ccA3c;
       ccA3c: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccA3e; else goto ccA3d;
       ccA3e: // global
           HpAlloc = 24;
           goto ccA3b;
       ccA3b: // global
           R1 = _scyom::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA3d: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyom::P64;
           _scynG::I64 = I64[_scyom::P64 + 24];
           _scyo9::I64 = _scynG::I64 - I64[_scyom::P64 + 16];
           I64[Hp - 16] = go_up_scyob_info;
           I64[Hp - 8] = _scyo9::I64;
           I64[Hp] = 0 - _scyo9::I64;
           R2 = _scynG::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scyob_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyom_info" {
     sat_scyom_info:
         const sat_scyom_entry;
         const 8589934592;
         const 4294967316;
         const ScypP_srt+184;
 },
 sat_scyo8_entry() //  [R1]
         { []
         }
     {offset
       ccA3o: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA3p; else goto ccA3x;
       ccA3p: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA3x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccA3v; else goto ccA3n;
       ccA3n: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccA3v; else goto ccA3w;
       ccA3v: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA3w: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyo8_info" {
     sat_scyo8_info:
         const sat_scyo8_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+184;
 },
 sat_scyoq_entry() //  [R1]
         { []
         }
     {offset
       ccA3L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA3M; else goto ccA3U;
       ccA3M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA3U: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccA3S; else goto ccA3K;
       ccA3K: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccA3S; else goto ccA3T;
       ccA3S: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA3T: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyoq_info" {
     sat_scyoq_info:
         const sat_scyoq_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+184;
 },
 sat_scyoF_entry() //  [R1]
         { []
         }
     {offset
       ccA4r: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA4s; else goto ccA4t;
       ccA4s: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA4t: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scyoy_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyoF_info" {
     sat_scyoF_info:
         const sat_scyoF_entry;
         const 8589934593;
         const 4294967311;
         const ScypP_srt+184;
 },
 sat_scyoD_entry() //  [R1]
         { []
         }
     {offset
       ccA4D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA4E; else goto ccA4M;
       ccA4E: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA4M: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoz::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoz::I64, 0)) goto ccA4K; else goto ccA4C;
       ccA4C: // global
           if (%MO_S_Gt_W64(_scyoz::I64, 1)) goto ccA4K; else goto ccA4L;
       ccA4K: // global
           R2 = _scyoz::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA4L: // global
           R1 = I64[(_scyoz::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyoD_info" {
     sat_scyoD_info:
         const sat_scyoD_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+184;
 },
 sat_scyoI_entry() //  [R1]
         { []
         }
     {offset
       ccA4X: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA4Y; else goto ccA56;
       ccA4Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA56: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoz::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoz::I64, 0)) goto ccA54; else goto ccA4W;
       ccA4W: // global
           if (%MO_S_Gt_W64(_scyoz::I64, 1)) goto ccA54; else goto ccA55;
       ccA54: // global
           R2 = _scyoz::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA55: // global
           R1 = I64[(_scyoz::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyoI_info" {
     sat_scyoI_info:
         const sat_scyoI_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+184;
 },
 go_dn_scyoy_entry() //  [R1, R2]
         { []
         }
     {offset
       ccA5a: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccA5e; else goto ccA5d;
       ccA5e: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccA5d: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto ccA58; else goto ccA59;
       ccA58: // global
           _scyow::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scyoF_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scyow::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scyoD_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA59: // global
           I64[Hp - 80] = sat_scyoI_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccA5g::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccA5g::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_scyoy_info" {
     go_dn_scyoy_info:
         const go_dn_scyoy_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const ScypP_srt+184;
 },
 sat_scyoJ_entry() //  [R1]
         { []
         }
     {offset
       ccA5h: // global
           _scyoJ::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccA5i; else goto ccA5j;
       ccA5j: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccA5l; else goto ccA5k;
       ccA5l: // global
           HpAlloc = 24;
           goto ccA5i;
       ccA5i: // global
           R1 = _scyoJ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA5k: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyoJ::P64;
           _scynG::I64 = I64[_scyoJ::P64 + 24];
           _scyow::I64 = _scynG::I64 - I64[_scyoJ::P64 + 16];
           I64[Hp - 16] = go_dn_scyoy_info;
           I64[Hp - 8] = _scyow::I64;
           I64[Hp] = 1 - _scyow::I64;
           R2 = _scynG::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scyoy_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyoJ_info" {
     sat_scyoJ_info:
         const sat_scyoJ_entry;
         const 8589934592;
         const 4294967316;
         const ScypP_srt+184;
 },
 sat_scyov_entry() //  [R1]
         { []
         }
     {offset
       ccA5v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA5w; else goto ccA5E;
       ccA5w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA5E: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccA5C; else goto ccA5u;
       ccA5u: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccA5C; else goto ccA5D;
       ccA5C: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA5D: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyov_info" {
     sat_scyov_info:
         const sat_scyov_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+184;
 },
 sat_scyoN_entry() //  [R1]
         { []
         }
     {offset
       ccA5S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA5T; else goto ccA61;
       ccA5T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA61: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccA5Z; else goto ccA5R;
       ccA5R: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccA5Z; else goto ccA60;
       ccA5Z: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA60: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyoN_info" {
     sat_scyoN_info:
         const sat_scyoN_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+184;
 },
 sat_scyp1_entry() //  [R1]
         { []
         }
     {offset
       ccA6u: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA6v; else goto ccA6w;
       ccA6v: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA6w: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scyoU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyp1_info" {
     sat_scyp1_info:
         const sat_scyp1_entry;
         const 8589934593;
         const 4294967311;
         const ScypP_srt+184;
 },
 sat_scyoZ_entry() //  [R1]
         { []
         }
     {offset
       ccA6G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA6H; else goto ccA6P;
       ccA6H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA6P: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoV::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoV::I64, 0)) goto ccA6N; else goto ccA6F;
       ccA6F: // global
           if (%MO_S_Gt_W64(_scyoV::I64, 1)) goto ccA6N; else goto ccA6O;
       ccA6N: // global
           R2 = _scyoV::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA6O: // global
           R1 = I64[(_scyoV::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyoZ_info" {
     sat_scyoZ_info:
         const sat_scyoZ_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+184;
 },
 sat_scyp4_entry() //  [R1]
         { []
         }
     {offset
       ccA70: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA71; else goto ccA79;
       ccA71: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA79: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scyoV::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scyoV::I64, 0)) goto ccA77; else goto ccA6Z;
       ccA6Z: // global
           if (%MO_S_Gt_W64(_scyoV::I64, 1)) goto ccA77; else goto ccA78;
       ccA77: // global
           R2 = _scyoV::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA78: // global
           R1 = I64[(_scyoV::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyp4_info" {
     sat_scyp4_info:
         const sat_scyp4_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+184;
 },
 go_up_scyoU_entry() //  [R1, R2]
         { []
         }
     {offset
       ccA7d: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccA7h; else goto ccA7g;
       ccA7h: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccA7g: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto ccA7b; else goto ccA7c;
       ccA7b: // global
           _scyoS::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scyp1_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scyoS::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scyoZ_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA7c: // global
           I64[Hp - 80] = sat_scyp4_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccA7j::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccA7j::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_scyoU_info" {
     go_up_scyoU_info:
         const go_up_scyoU_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const ScypP_srt+184;
 },
 sat_scyp5_entry() //  [R1]
         { []
         }
     {offset
       ccA7k: // global
           _scyp5::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccA7l; else goto ccA7m;
       ccA7m: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccA7o; else goto ccA7n;
       ccA7o: // global
           HpAlloc = 24;
           goto ccA7l;
       ccA7l: // global
           R1 = _scyp5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA7n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scyp5::P64;
           _scynG::I64 = I64[_scyp5::P64 + 24];
           _scyoS::I64 = _scynG::I64 - I64[_scyp5::P64 + 16];
           I64[Hp - 16] = go_up_scyoU_info;
           I64[Hp - 8] = _scyoS::I64;
           I64[Hp] = 1 - _scyoS::I64;
           R2 = _scynG::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scyoU_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyp5_info" {
     sat_scyp5_info:
         const sat_scyp5_entry;
         const 8589934592;
         const 4294967316;
         const ScypP_srt+184;
 },
 sat_scyoR_entry() //  [R1]
         { []
         }
     {offset
       ccA7y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA7z; else goto ccA7H;
       ccA7z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA7H: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccA7F; else goto ccA7x;
       ccA7x: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccA7F; else goto ccA7G;
       ccA7F: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA7G: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyoR_info" {
     sat_scyoR_info:
         const sat_scyoR_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+184;
 },
 sat_scyp9_entry() //  [R1]
         { []
         }
     {offset
       ccA7V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccA7W; else goto ccA84;
       ccA7W: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccA84: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scynE::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scynE::I64, 0)) goto ccA82; else goto ccA7U;
       ccA7U: // global
           if (%MO_S_Gt_W64(_scynE::I64, 1)) goto ccA82; else goto ccA83;
       ccA82: // global
           R2 = _scynE::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccA83: // global
           R1 = I64[(_scynE::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scyp9_info" {
     sat_scyp9_info:
         const sat_scyp9_entry;
         const 4294967296;
         const 4294967313;
         const ScypP_srt+184;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_entry() //  [R2, R3,
                                                             R4]
         { []
         }
     {offset
       ccA8c: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccA8d; else goto ccA8e;
       ccA8d: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccA8e: // global
           I64[Sp - 24] = block_ccA85_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucA9n; else goto ccA86;
       ucA9n: // global
           call _ccA85(R1) args: 0, res: 0, upd: 0;
       ccA86: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_info" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_info:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_entry;
         const 0;
         const 2203318222862;
         const 12884901911;
         const ScypP_srt+184;
 },
 _ccA85() //  [R1]
         { []
         }
     {offset
       ccA85: // global
           _scynB::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccA89; else goto ccA8a;
       ccA89: // global
           _scynE::I64 = 0;
           goto scynD;
       ccA8a: // global
           _scynE::I64 = 1;
           goto scynD;
       scynD: // global
           I64[Sp] = block_ccA8f_info;
           R1 = _scynB::P64;
           I64[Sp + 8] = _scynE::I64;
           if (R1 & 7 != 0) goto ucA9m; else goto ccA93;
       ucA9m: // global
           call _ccA8f(R1) args: 0, res: 0, upd: 0;
       ccA93: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccA85_info" {
     block_ccA85_info:
         const _ccA85;
         const 2;
         const 4294967326;
         const ScypP_srt+184;
 },
 _ccA8f() //  [R1]
         { []
         }
     {offset
       ccA8f: // global
           _scynC::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ccA99; else goto ccA9d;
       ccA99: // global
           _scynG::I64 = 0;
           goto scynF;
       ccA9d: // global
           _scynG::I64 = 1;
           goto scynF;
       scynF: // global
           I64[Sp] = block_cczZI_info;
           R1 = _scynC::P64;
           I64[Sp + 16] = _scynG::I64;
           if (R1 & 7 != 0) goto ucA9o; else goto cczZJ;
       ucA9o: // global
           call _cczZI(R1) args: 0, res: 0, upd: 0;
       cczZJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccA8f_info" {
     block_ccA8f_info:
         const _ccA8f;
         const 66;
         const 4294967326;
         const ScypP_srt+184;
 },
 _cczZI() //  [R1]
         { []
         }
     {offset
       cczZI: // global
           _scynE::I64 = I64[Sp + 8];
           _scynG::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto ccA8j; else goto ccA8G;
       ccA8j: // global
           Hp = Hp + 80;
           _scynH::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccA8J; else goto ccA8l;
       ccA8l: // global
           if (%MO_S_Lt_W64(_scynG::I64,
                            _scynE::I64)) goto ccA8w; else goto ccA8F;
       ccA8w: // global
           if (%MO_S_Le_W64(0, _scynG::I64)) goto ccA8p; else goto ccA8u;
       ccA8p: // global
           I64[Hp - 72] = sat_scyo0_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = _scynG::I64;
           I64[Hp - 40] = sat_scynM_info;
           I64[Hp - 24] = _scynE::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA8u: // global
           if (%MO_S_Gt_W64(0, _scynE::I64)) goto ccA90; else goto ccA8s;
       ccA8s: // global
           I64[Hp - 72] = sat_scyo4_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccA8q::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccA8q::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA8F: // global
           if (%MO_S_Ge_W64(0, _scynG::I64)) goto ccA8z; else goto ccA8E;
       ccA8z: // global
           I64[Hp - 72] = sat_scyom_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = _scynG::I64;
           I64[Hp - 40] = sat_scyo8_info;
           I64[Hp - 24] = _scynE::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA8E: // global
           if (%MO_S_Lt_W64(0, _scynE::I64)) goto ccA90; else goto ccA8C;
       ccA8C: // global
           I64[Hp - 72] = sat_scyoq_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccA8A::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccA8A::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA8G: // global
           Hp = Hp + 80;
           _scynH::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccA8J; else goto ccA8I;
       ccA8J: // global
           HpAlloc = 80;
           R1 = _scynH::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccA8I: // global
           if (%MO_S_Lt_W64(_scynG::I64,
                            _scynE::I64)) goto ccA8T; else goto ccA92;
       ccA8T: // global
           if (%MO_S_Le_W64(1, _scynG::I64)) goto ccA8M; else goto ccA8R;
       ccA8M: // global
           I64[Hp - 72] = sat_scyoJ_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = _scynG::I64;
           I64[Hp - 40] = sat_scyov_info;
           I64[Hp - 24] = _scynE::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA8R: // global
           if (%MO_S_Gt_W64(1, _scynE::I64)) goto ccA90; else goto ccA8P;
       ccA8P: // global
           I64[Hp - 72] = sat_scyoN_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccA8N::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccA8N::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA92: // global
           if (%MO_S_Ge_W64(1, _scynG::I64)) goto ccA8W; else goto ccA91;
       ccA8W: // global
           I64[Hp - 72] = sat_scyp5_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = _scynG::I64;
           I64[Hp - 40] = sat_scyoR_info;
           I64[Hp - 24] = _scynE::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA91: // global
           if (%MO_S_Lt_W64(1, _scynE::I64)) goto ccA90; else goto ccA8Z;
       ccA90: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccA8Z: // global
           I64[Hp - 72] = sat_scyp9_info;
           I64[Hp - 56] = _scynE::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccA8X::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccA8X::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cczZI_info" {
     block_cczZI_info:
         const _cczZI;
         const 194;
         const 4294967326;
         const ScypP_srt+184;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.95744018 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_closure" {
     GHC.ByteOrder.$fEnumByteOrder_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.ByteOrder.$fEnumByteOrder_$csucc_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cpred_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure+2;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure+2;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure+3;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.959221996 UTC

[section ""data" . GHC.ByteOrder.$trModule3_closure" {
     GHC.ByteOrder.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.960941496 UTC

[section ""data" . GHC.ByteOrder.$trModule1_closure" {
     GHC.ByteOrder.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.963125745 UTC

[section ""data" . GHC.ByteOrder.$trModule_closure" {
     GHC.ByteOrder.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.ByteOrder.$trModule3_closure+1;
         const GHC.ByteOrder.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.964866663 UTC

[section ""cstring" . GHC.ByteOrder.$tcByteOrder2_bytes" {
     GHC.ByteOrder.$tcByteOrder2_bytes:
         I8[] [66,121,116,101,79,114,100,101,114]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.96662729 UTC

[section ""data" . GHC.ByteOrder.$tcByteOrder1_closure" {
     GHC.ByteOrder.$tcByteOrder1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$tcByteOrder2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.968388701 UTC

[section ""data" . GHC.ByteOrder.$tcByteOrder_closure" {
     GHC.ByteOrder.$tcByteOrder_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.ByteOrder.$trModule_closure+1;
         const GHC.ByteOrder.$tcByteOrder1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16811050684449662084;
         const 17273005335247024091;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.970427793 UTC

[section ""data" . GHC.ByteOrder.$tc'BigEndian1_closure" {
     GHC.ByteOrder.$tc'BigEndian1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.ByteOrder.$tcByteOrder_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.972229831 UTC

[section ""cstring" . GHC.ByteOrder.$tc'BigEndian3_bytes" {
     GHC.ByteOrder.$tc'BigEndian3_bytes:
         I8[] [39,66,105,103,69,110,100,105,97,110]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.974026528 UTC

[section ""data" . GHC.ByteOrder.$tc'BigEndian2_closure" {
     GHC.ByteOrder.$tc'BigEndian2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$tc'BigEndian3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.97630417 UTC

[section ""data" . GHC.ByteOrder.$tc'BigEndian_closure" {
     GHC.ByteOrder.$tc'BigEndian_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.ByteOrder.$trModule_closure+1;
         const GHC.ByteOrder.$tc'BigEndian2_closure+1;
         const GHC.ByteOrder.$tc'BigEndian1_closure+1;
         const 2645192688778293591;
         const 7455668807059762078;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.978097336 UTC

[section ""cstring" . GHC.ByteOrder.$tc'LittleEndian2_bytes" {
     GHC.ByteOrder.$tc'LittleEndian2_bytes:
         I8[] [39,76,105,116,116,108,101,69,110,100,105,97,110]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.979723082 UTC

[section ""data" . GHC.ByteOrder.$tc'LittleEndian1_closure" {
     GHC.ByteOrder.$tc'LittleEndian1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$tc'LittleEndian2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.981795435 UTC

[section ""data" . GHC.ByteOrder.$tc'LittleEndian_closure" {
     GHC.ByteOrder.$tc'LittleEndian_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.ByteOrder.$trModule_closure+1;
         const GHC.ByteOrder.$tc'LittleEndian1_closure+1;
         const GHC.ByteOrder.$tc'BigEndian1_closure+1;
         const 8702700204875460152;
         const 10337679016369298147;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.983571795 UTC

[section ""data" . GHC.ByteOrder.BigEndian_closure" {
     GHC.ByteOrder.BigEndian_closure:
         const GHC.ByteOrder.BigEndian_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.985258603 UTC

[section ""data" . GHC.ByteOrder.LittleEndian_closure" {
     GHC.ByteOrder.LittleEndian_closure:
         const GHC.ByteOrder.LittleEndian_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.987005671 UTC

[section ""relreadonly" . GHC.ByteOrder.ByteOrder_closure_tbl" {
     GHC.ByteOrder.ByteOrder_closure_tbl:
         const GHC.ByteOrder.BigEndian_closure+1;
         const GHC.ByteOrder.LittleEndian_closure+2;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.989057158 UTC

[section ""cstring" . iczqS_str" {
     iczqS_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,121,116,101,79,114,100,101,114,46,66,105,103,69,110,100,105,97,110]
 },
 GHC.ByteOrder.BigEndian_con_entry() //  [R1]
         { []
         }
     {offset
       ccAdi: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.BigEndian_con_info" {
     GHC.ByteOrder.BigEndian_con_info:
         const GHC.ByteOrder.BigEndian_con_entry;
         const 4294967296;
         const 3;
         const iczqS_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.992318944 UTC

[section ""cstring" . iczqU_str" {
     iczqU_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,121,116,101,79,114,100,101,114,46,76,105,116,116,108,101,69,110,100,105,97,110]
 },
 GHC.ByteOrder.LittleEndian_con_entry() //  [R1]
         { []
         }
     {offset
       ccAdo: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.LittleEndian_con_info" {
     GHC.ByteOrder.LittleEndian_con_info:
         const GHC.ByteOrder.LittleEndian_con_entry;
         const 4294967296;
         const 4294967299;
         const iczqU_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:27.996040555 UTC

[section ""relreadonly" . ScypP_srt" {
     ScypP_srt:
         const GHC.ByteOrder.$fReadByteOrder6_closure;
         const GHC.ByteOrder.$fReadByteOrder10_closure;
         const GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure;
         const GHC.ByteOrder.$fShowByteOrder_$cshow_closure;
         const GHC.ByteOrder.$fShowByteOrder1_closure;
         const GHC.Read.choose2_closure;
         const GHC.ByteOrder.$fReadByteOrder_sps_closure;
         const GHC.Read.list3_closure;
         const GHC.ByteOrder.$fReadByteOrder2_closure;
         const GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.ByteOrder.$fReadByteOrder1_closure;
         const GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure;
         const GHC.ByteOrder.$fReadByteOrder12_closure;
         const GHC.Err.error_closure;
         const lvl12_rcykz_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cpred_closure;
         const GHC.ByteOrder.$fEnumByteOrder3_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$csucc_closure;
         const GHC.ByteOrder.$fEnumByteOrder4_closure;
         const lvl17_rcykE_closure;
         const lvl18_rcykF_closure;
         const lvl19_rcykG_closure;
         const GHC.ByteOrder.$wlvl_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure;
         const GHC.ByteOrder.$w$ctoEnum_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure;
         const GHC.ByteOrder.$fEnumByteOrder1_closure;
         const GHC.ByteOrder.$fEnumByteOrder2_closure;
         const GHC.ByteOrder.$fEnumByteOrder_go1_closure;
         const GHC.ByteOrder.$fEnumByteOrder_go_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.629998643 UTC

[]


==================== Raw Cmm ====================
2018-03-16 16:07:29.631073364 UTC

[section ""cstring" . GHC.ByteOrder.$fReadByteOrder11_bytes" {
     GHC.ByteOrder.$fReadByteOrder11_bytes:
         I8[] [66,105,103,69,110,100,105,97,110]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.633441188 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder10_closure" {
     GHC.ByteOrder.$fReadByteOrder10_closure:
         const GHC.ByteOrder.$fReadByteOrder10_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder10_entry() //  [R1]
         { []
         }
     {offset
       ccAi5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAi6; else goto ccAi7;
       ccAi6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAi7: // global
           (_ccAi2::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAi2::I64 == 0) goto ccAi4; else goto ccAi3;
       ccAi4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAi3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAi2::I64;
           R2 = GHC.ByteOrder.$fReadByteOrder11_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fReadByteOrder10_info" {
     GHC.ByteOrder.$fReadByteOrder10_info:
         const GHC.ByteOrder.$fReadByteOrder10_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.637121494 UTC

[section ""cstring" . GHC.ByteOrder.$fReadByteOrder7_bytes" {
     GHC.ByteOrder.$fReadByteOrder7_bytes:
         I8[] [76,105,116,116,108,101,69,110,100,105,97,110]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.639316748 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder6_closure" {
     GHC.ByteOrder.$fReadByteOrder6_closure:
         const GHC.ByteOrder.$fReadByteOrder6_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder6_entry() //  [R1]
         { []
         }
     {offset
       ccAin: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAio; else goto ccAip;
       ccAio: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAip: // global
           (_ccAik::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAik::I64 == 0) goto ccAim; else goto ccAil;
       ccAim: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAil: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAik::I64;
           R2 = GHC.ByteOrder.$fReadByteOrder7_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fReadByteOrder6_info" {
     GHC.ByteOrder.$fReadByteOrder6_info:
         const GHC.ByteOrder.$fReadByteOrder6_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.643864272 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure" {
     GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure:
         const GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       ccAiJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAiK; else goto ccAiL;
       ccAiK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAiL: // global
           I64[Sp - 16] = block_ccAiC_info;
           R1 = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucAiS; else goto ccAiD;
       ucAiS: // global
           call _ccAiC(R1) args: 0, res: 0, upd: 0;
       ccAiD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_info" {
     GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_info:
         const GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_entry;
         const 0;
         const 30064771086;
         const 12884901911;
         const ScAiT_srt;
 },
 _ccAiC() //  [R1]
         { []
         }
     {offset
       ccAiC: // global
           _scAdx::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAiG; else goto ccAiH;
       ccAiG: // global
           R3 = _scAdx::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ccAiH: // global
           R3 = _scAdx::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAiC_info" {
     block_ccAiC_info:
         const _ccAiC;
         const 1;
         const 12884901918;
         const ScAiT_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.649707139 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_$cshow_closure" {
     GHC.ByteOrder.$fShowByteOrder_$cshow_closure:
         const GHC.ByteOrder.$fShowByteOrder_$cshow_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder_$cshow_entry() //  [R2]
         { []
         }
     {offset
       ccAjh: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccAji; else goto ccAjj;
       ccAji: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fShowByteOrder_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAjj: // global
           I64[Sp - 8] = block_ccAja_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucAjq; else goto ccAjb;
       ucAjq: // global
           call _ccAja(R1) args: 0, res: 0, upd: 0;
       ccAjb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fShowByteOrder_$cshow_info" {
     GHC.ByteOrder.$fShowByteOrder_$cshow_info:
         const GHC.ByteOrder.$fShowByteOrder_$cshow_entry;
         const 0;
         const 47244640270;
         const 4294967301;
         const ScAiT_srt;
 },
 _ccAja() //  [R1]
         { []
         }
     {offset
       ccAja: // global
           if (R1 & 7 == 1) goto ccAje; else goto ccAjf;
       ccAje: // global
           R1 = GHC.ByteOrder.$fReadByteOrder10_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccAjf: // global
           R1 = GHC.ByteOrder.$fReadByteOrder6_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAja_info" {
     block_ccAja_info:
         const _ccAja;
         const 0;
         const 12884901918;
         const ScAiT_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.65550968 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder1_closure" {
     GHC.ByteOrder.$fShowByteOrder1_closure:
         const GHC.ByteOrder.$fShowByteOrder1_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder1_entry() //  [R2, R3]
         { []
         }
     {offset
       ccAjQ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAjR; else goto ccAjS;
       ccAjR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fShowByteOrder1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAjS: // global
           I64[Sp - 16] = block_ccAjJ_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucAjZ; else goto ccAjK;
       ucAjZ: // global
           call _ccAjJ(R1) args: 0, res: 0, upd: 0;
       ccAjK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fShowByteOrder1_info" {
     GHC.ByteOrder.$fShowByteOrder1_info:
         const GHC.ByteOrder.$fShowByteOrder1_entry;
         const 0;
         const 81604378638;
         const 8589934607;
         const ScAiT_srt;
 },
 _ccAjJ() //  [R1]
         { []
         }
     {offset
       ccAjJ: // global
           _scAdC::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAjN; else goto ccAjO;
       ccAjN: // global
           R3 = _scAdC::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder10_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
       ccAjO: // global
           R3 = _scAdC::P64;
           R2 = GHC.ByteOrder.$fReadByteOrder6_closure;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAjJ_info" {
     block_ccAjJ_info:
         const _ccAjJ;
         const 1;
         const 12884901918;
         const ScAiT_srt;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.661184974 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_$cshowList_closure" {
     GHC.ByteOrder.$fShowByteOrder_$cshowList_closure:
         const GHC.ByteOrder.$fShowByteOrder_$cshowList_info;
         const 0;
 },
 GHC.ByteOrder.$fShowByteOrder_$cshowList_entry() //  [R2, R3]
         { []
         }
     {offset
       ccAkg: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.ByteOrder.$fShowByteOrder1_closure+2;
           call GHC.Show.showList___entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fShowByteOrder_$cshowList_info" {
     GHC.ByteOrder.$fShowByteOrder_$cshowList_info:
         const GHC.ByteOrder.$fShowByteOrder_$cshowList_entry;
         const 0;
         const 4294967310;
         const 8589934607;
         const ScAiT_srt+32;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.665006363 UTC

[section ""data" . GHC.ByteOrder.$fShowByteOrder_closure" {
     GHC.ByteOrder.$fShowByteOrder_closure:
         const GHC.Show.C:Show_con_info;
         const GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure+3;
         const GHC.ByteOrder.$fShowByteOrder_$cshow_closure+1;
         const GHC.ByteOrder.$fShowByteOrder_$cshowList_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.667020185 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder9_closure" {
     GHC.ByteOrder.$fReadByteOrder9_closure:
         const GHC.ByteOrder.$fReadByteOrder9_info;
 },
 GHC.ByteOrder.$fReadByteOrder9_entry() //  [R3]
         { []
         }
     {offset
       ccAks: // global
           R2 = GHC.ByteOrder.BigEndian_closure+1;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fReadByteOrder9_info" {
     GHC.ByteOrder.$fReadByteOrder9_info:
         const GHC.ByteOrder.$fReadByteOrder9_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.670040869 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder8_closure" {
     GHC.ByteOrder.$fReadByteOrder8_closure:
         const (,)_con_info;
         const GHC.ByteOrder.$fReadByteOrder10_closure;
         const GHC.ByteOrder.$fReadByteOrder9_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.671962683 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder5_closure" {
     GHC.ByteOrder.$fReadByteOrder5_closure:
         const GHC.ByteOrder.$fReadByteOrder5_info;
 },
 GHC.ByteOrder.$fReadByteOrder5_entry() //  [R3]
         { []
         }
     {offset
       ccAkE: // global
           R2 = GHC.ByteOrder.LittleEndian_closure+2;
           R1 = R3;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fReadByteOrder5_info" {
     GHC.ByteOrder.$fReadByteOrder5_info:
         const GHC.ByteOrder.$fReadByteOrder5_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.675436172 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder4_closure" {
     GHC.ByteOrder.$fReadByteOrder4_closure:
         const (,)_con_info;
         const GHC.ByteOrder.$fReadByteOrder6_closure;
         const GHC.ByteOrder.$fReadByteOrder5_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.677183446 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder3_closure" {
     GHC.ByteOrder.$fReadByteOrder3_closure:
         const :_con_info;
         const GHC.ByteOrder.$fReadByteOrder4_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.67888426 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_sps_closure" {
     GHC.ByteOrder.$fReadByteOrder_sps_closure:
         const :_con_info;
         const GHC.ByteOrder.$fReadByteOrder8_closure+1;
         const GHC.ByteOrder.$fReadByteOrder3_closure+2;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.68087505 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder2_closure" {
     GHC.ByteOrder.$fReadByteOrder2_closure:
         const GHC.ByteOrder.$fReadByteOrder2_info;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder2_entry() //  [R2]
         { []
         }
     {offset
       ccAkS: // global
           R3 = R2;
           R2 = GHC.ByteOrder.$fReadByteOrder_sps_closure+2;
           call GHC.Read.choose2_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fReadByteOrder2_info" {
     GHC.ByteOrder.$fReadByteOrder2_info:
         const GHC.ByteOrder.$fReadByteOrder2_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const ScAiT_srt+40;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.684290593 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder1_closure" {
     GHC.ByteOrder.$fReadByteOrder1_closure:
         const GHC.ByteOrder.$fReadByteOrder1_info;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder1_entry() //  [R2, R3]
         { []
         }
     {offset
       ccAl3: // global
           R4 = R3;
           R3 = R2;
           R2 = GHC.ByteOrder.$fReadByteOrder2_closure+1;
           call GHC.Read.list3_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fReadByteOrder1_info" {
     GHC.ByteOrder.$fReadByteOrder1_info:
         const GHC.ByteOrder.$fReadByteOrder1_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const ScAiT_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.6882517 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure" {
     GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure:
         const GHC.ByteOrder.$fReadByteOrder_$creadsPrec_info;
         const 0;
 },
 sat_scAdM_entry() //  [R1]
         { []
         }
     {offset
       ccAli: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAlj; else goto ccAlk;
       ccAlj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAlk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R3 = P64[R1 + 16];
           R2 = GHC.ByteOrder.$fReadByteOrder2_closure+1;
           Sp = Sp - 16;
           call GHC.Read.list3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAdM_info" {
     sat_scAdM_info:
         const sat_scAdM_entry;
         const 1;
         const 12884901904;
         const ScAiT_srt+56;
 },
 GHC.ByteOrder.$fReadByteOrder_$creadsPrec_entry() //  [R2]
         { []
         }
     {offset
       ccAll: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccAlp; else goto ccAlo;
       ccAlp: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAlo: // global
           I64[Hp - 16] = sat_scAdM_info;
           P64[Hp] = R2;
           R2 = Hp - 16;
           R1 = Text.ParserCombinators.ReadP.run_closure+2;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fReadByteOrder_$creadsPrec_info" {
     GHC.ByteOrder.$fReadByteOrder_$creadsPrec_info:
         const GHC.ByteOrder.$fReadByteOrder_$creadsPrec_entry;
         const 0;
         const 30064771086;
         const 4294967301;
         const ScAiT_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.694848407 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure" {
     GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure:
         const GHC.ByteOrder.$fReadByteOrder_$creadListPrec_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder_$creadListPrec_entry() //  [R1]
         { []
         }
     {offset
       ccAlI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAlJ; else goto ccAlK;
       ccAlJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAlK: // global
           (_ccAlF::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAlF::I64 == 0) goto ccAlH; else goto ccAlG;
       ccAlH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAlG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAlF::I64;
           R2 = GHC.ByteOrder.$fReadByteOrder1_closure+2;
           Sp = Sp - 16;
           call GHC.Read.list_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fReadByteOrder_$creadListPrec_info" {
     GHC.ByteOrder.$fReadByteOrder_$creadListPrec_info:
         const GHC.ByteOrder.$fReadByteOrder_$creadListPrec_entry;
         const 0;
         const 12884901909;
         const ScAiT_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.698890344 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder12_closure" {
     GHC.ByteOrder.$fReadByteOrder12_closure:
         const GHC.ByteOrder.$fReadByteOrder12_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder12_entry() //  [R1]
         { []
         }
     {offset
       ccAlZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAm0; else goto ccAm1;
       ccAm0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAm1: // global
           (_ccAlW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAlW::I64 == 0) goto ccAlY; else goto ccAlX;
       ccAlY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAlX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAlW::I64;
           R3 = Text.ParserCombinators.ReadP.$fApplicativeP_$cpure_closure+1;
           R2 = GHC.Read.$fRead()7_closure;
           R1 = GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fReadByteOrder12_info" {
     GHC.ByteOrder.$fReadByteOrder12_info:
         const GHC.ByteOrder.$fReadByteOrder12_entry;
         const 0;
         const 4294967317;
         const ScAiT_srt+96;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.703281956 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_$creadList_closure" {
     GHC.ByteOrder.$fReadByteOrder_$creadList_closure:
         const GHC.ByteOrder.$fReadByteOrder_$creadList_info;
         const 0;
 },
 GHC.ByteOrder.$fReadByteOrder_$creadList_entry() //  [R2]
         { []
         }
     {offset
       ccAmf: // global
           R3 = R2;
           R2 = GHC.ByteOrder.$fReadByteOrder12_closure;
           call Text.ParserCombinators.ReadP.run_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fReadByteOrder_$creadList_info" {
     GHC.ByteOrder.$fReadByteOrder_$creadList_info:
         const GHC.ByteOrder.$fReadByteOrder_$creadList_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const ScAiT_srt+104;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.706437422 UTC

[section ""data" . GHC.ByteOrder.$fReadByteOrder_closure" {
     GHC.ByteOrder.$fReadByteOrder_closure:
         const GHC.Read.C:Read_con_info;
         const GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure+1;
         const GHC.ByteOrder.$fReadByteOrder_$creadList_closure+1;
         const GHC.ByteOrder.$fReadByteOrder1_closure+2;
         const GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.70821754 UTC

[section ""data" . GHC.ByteOrder.$fBoundedByteOrder_closure" {
     GHC.ByteOrder.$fBoundedByteOrder_closure:
         const GHC.Enum.C:Bounded_con_info;
         const GHC.ByteOrder.BigEndian_closure+1;
         const GHC.ByteOrder.LittleEndian_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.711265328 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c<_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c<_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c<_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c<_entry() //  [R2, R3]
         { []
         }
     {offset
       ccAmz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAmA; else goto ccAmB;
       ccAmA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$c<_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAmB: // global
           I64[Sp - 16] = block_ccAms_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucAn3; else goto ccAmt;
       ucAn3: // global
           call _ccAms(R1) args: 0, res: 0, upd: 0;
       ccAmt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fOrdByteOrder_$c<_info" {
     GHC.ByteOrder.$fOrdByteOrder_$c<_info:
         const GHC.ByteOrder.$fOrdByteOrder_$c<_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccAms() //  [R1]
         { []
         }
     {offset
       ccAms: // global
           _scAdO::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAmw; else goto ccAmx;
       ccAmw: // global
           I64[Sp + 8] = block_ccAmE_info;
           R1 = _scAdO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAn1; else goto ccAmG;
       ucAn1: // global
           call _ccAmE(R1) args: 0, res: 0, upd: 0;
       ccAmG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccAmx: // global
           I64[Sp + 8] = block_ccAmT_info;
           R1 = _scAdO::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAn2; else goto ccAmV;
       ucAn2: // global
           call _ccAmT() args: 0, res: 0, upd: 0;
       ccAmV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAms_info" {
     block_ccAms_info:
         const _ccAms;
         const 1;
         const 30;
 },
 _ccAmE() //  [R1]
         { []
         }
     {offset
       ccAmE: // global
           if (R1 & 7 == 1) goto ccAmM; else goto ccAmQ;
       ccAmM: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAmQ: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAmE_info" {
     block_ccAmE_info:
         const _ccAmE;
         const 0;
         const 30;
 },
 _ccAmT() //  []
         { []
         }
     {offset
       ccAmT: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAmT_info" {
     block_ccAmT_info:
         const _ccAmT;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.720910351 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$ccompare_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$ccompare_entry() //  [R2, R3]
         { []
         }
     {offset
       ccAnJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAnK; else goto ccAnL;
       ccAnK: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAnL: // global
           I64[Sp - 16] = block_ccAnC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucAom; else goto ccAnD;
       ucAom: // global
           call _ccAnC(R1) args: 0, res: 0, upd: 0;
       ccAnD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fOrdByteOrder_$ccompare_info" {
     GHC.ByteOrder.$fOrdByteOrder_$ccompare_info:
         const GHC.ByteOrder.$fOrdByteOrder_$ccompare_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccAnC() //  [R1]
         { []
         }
     {offset
       ccAnC: // global
           _scAdT::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAnG; else goto ccAnH;
       ccAnG: // global
           I64[Sp + 8] = block_ccAnO_info;
           R1 = _scAdT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAok; else goto ccAnQ;
       ucAok: // global
           call _ccAnO(R1) args: 0, res: 0, upd: 0;
       ccAnQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccAnH: // global
           I64[Sp + 8] = block_ccAo3_info;
           R1 = _scAdT::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAol; else goto ccAo5;
       ucAol: // global
           call _ccAo3(R1) args: 0, res: 0, upd: 0;
       ccAo5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAnC_info" {
     block_ccAnC_info:
         const _ccAnC;
         const 1;
         const 30;
 },
 _ccAnO() //  [R1]
         { []
         }
     {offset
       ccAnO: // global
           if (R1 & 7 == 1) goto ucAoj; else goto ccAo0;
       ucAoj: // global
           Sp = Sp + 8;
           call _ccAof() args: 0, res: 0, upd: 0;
       ccAo0: // global
           R1 = GHC.Types.LT_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAnO_info" {
     block_ccAnO_info:
         const _ccAnO;
         const 0;
         const 30;
 },
 _ccAo3() //  [R1]
         { []
         }
     {offset
       ccAo3: // global
           if (R1 & 7 == 1) goto ccAob; else goto ucAoi;
       ccAob: // global
           R1 = GHC.Types.GT_closure+3;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ucAoi: // global
           Sp = Sp + 8;
           call _ccAof() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ccAo3_info" {
     block_ccAo3_info:
         const _ccAo3;
         const 0;
         const 30;
 },
 _ccAof() //  []
         { []
         }
     {offset
       ccAof: // global
           R1 = GHC.Types.EQ_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.732246736 UTC

[section ""data" . GHC.ByteOrder.$fEqByteOrder_$c==_closure" {
     GHC.ByteOrder.$fEqByteOrder_$c==_closure:
         const GHC.ByteOrder.$fEqByteOrder_$c==_info;
 },
 GHC.ByteOrder.$fEqByteOrder_$c==_entry() //  [R2, R3]
         { []
         }
     {offset
       ccAp8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAp9; else goto ccApa;
       ccAp9: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEqByteOrder_$c==_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccApa: // global
           I64[Sp - 16] = block_ccAp1_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucApN; else goto ccAp2;
       ucApN: // global
           call _ccAp1(R1) args: 0, res: 0, upd: 0;
       ccAp2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEqByteOrder_$c==_info" {
     GHC.ByteOrder.$fEqByteOrder_$c==_info:
         const GHC.ByteOrder.$fEqByteOrder_$c==_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccAp1() //  [R1]
         { []
         }
     {offset
       ccAp1: // global
           _scAdY::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAp5; else goto ccAp6;
       ccAp5: // global
           I64[Sp + 8] = block_ccApd_info;
           R1 = _scAdY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucApL; else goto ccApf;
       ucApL: // global
           call _ccApd(R1) args: 0, res: 0, upd: 0;
       ccApf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccAp6: // global
           I64[Sp + 8] = block_ccAps_info;
           R1 = _scAdY::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucApM; else goto ccApu;
       ucApM: // global
           call _ccAps(R1) args: 0, res: 0, upd: 0;
       ccApu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAp1_info" {
     block_ccAp1_info:
         const _ccAp1;
         const 1;
         const 30;
 },
 _ccApd() //  [R1]
         { []
         }
     {offset
       ccApd: // global
           if (R1 & 7 == 1) goto ucApJ; else goto ucApK;
       ucApJ: // global
           Sp = Sp + 8;
           call _ccApE() args: 0, res: 0, upd: 0;
       ucApK: // global
           Sp = Sp + 8;
           call _ccApA() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ccApd_info" {
     block_ccApd_info:
         const _ccApd;
         const 0;
         const 30;
 },
 _ccAps() //  [R1]
         { []
         }
     {offset
       ccAps: // global
           if (R1 & 7 == 1) goto ucApH; else goto ucApI;
       ucApH: // global
           Sp = Sp + 8;
           call _ccApA() args: 0, res: 0, upd: 0;
       ucApI: // global
           Sp = Sp + 8;
           call _ccApE() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ccAps_info" {
     block_ccAps_info:
         const _ccAps;
         const 0;
         const 30;
 },
 _ccApA() //  []
         { []
         }
     {offset
       ccApA: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccApE() //  []
         { []
         }
     {offset
       ccApE: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.743753866 UTC

[section ""data" . GHC.ByteOrder.$fEqByteOrder_$c/=_closure" {
     GHC.ByteOrder.$fEqByteOrder_$c/=_closure:
         const GHC.ByteOrder.$fEqByteOrder_$c/=_info;
 },
 GHC.ByteOrder.$fEqByteOrder_$c/=_entry() //  [R2, R3]
         { []
         }
     {offset
       ccAqB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAqC; else goto ccAqD;
       ccAqC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEqByteOrder_$c/=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAqD: // global
           I64[Sp - 16] = block_ccAqu_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucArg; else goto ccAqv;
       ucArg: // global
           call _ccAqu(R1) args: 0, res: 0, upd: 0;
       ccAqv: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEqByteOrder_$c/=_info" {
     GHC.ByteOrder.$fEqByteOrder_$c/=_info:
         const GHC.ByteOrder.$fEqByteOrder_$c/=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccAqu() //  [R1]
         { []
         }
     {offset
       ccAqu: // global
           _scAe3::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAqy; else goto ccAqz;
       ccAqy: // global
           I64[Sp + 8] = block_ccAqG_info;
           R1 = _scAe3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAre; else goto ccAqI;
       ucAre: // global
           call _ccAqG(R1) args: 0, res: 0, upd: 0;
       ccAqI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccAqz: // global
           I64[Sp + 8] = block_ccAqV_info;
           R1 = _scAe3::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucArf; else goto ccAqX;
       ucArf: // global
           call _ccAqV(R1) args: 0, res: 0, upd: 0;
       ccAqX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAqu_info" {
     block_ccAqu_info:
         const _ccAqu;
         const 1;
         const 30;
 },
 _ccAqG() //  [R1]
         { []
         }
     {offset
       ccAqG: // global
           if (R1 & 7 == 1) goto ucArc; else goto ucArd;
       ucArc: // global
           Sp = Sp + 8;
           call _ccAr7() args: 0, res: 0, upd: 0;
       ucArd: // global
           Sp = Sp + 8;
           call _ccAr3() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ccAqG_info" {
     block_ccAqG_info:
         const _ccAqG;
         const 0;
         const 30;
 },
 _ccAqV() //  [R1]
         { []
         }
     {offset
       ccAqV: // global
           if (R1 & 7 == 1) goto ucAra; else goto ucArb;
       ucAra: // global
           Sp = Sp + 8;
           call _ccAr3() args: 0, res: 0, upd: 0;
       ucArb: // global
           Sp = Sp + 8;
           call _ccAr7() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ccAqV_info" {
     block_ccAqV_info:
         const _ccAqV;
         const 0;
         const 30;
 },
 _ccAr3() //  []
         { []
         }
     {offset
       ccAr3: // global
           R1 = GHC.Types.True_closure+2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccAr7() //  []
         { []
         }
     {offset
       ccAr7: // global
           R1 = GHC.Types.False_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.753458929 UTC

[section ""data" . GHC.ByteOrder.$fEqByteOrder_closure" {
     GHC.ByteOrder.$fEqByteOrder_closure:
         const GHC.Classes.C:Eq_con_info;
         const GHC.ByteOrder.$fEqByteOrder_$c==_closure+2;
         const GHC.ByteOrder.$fEqByteOrder_$c/=_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.756637657 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c<=_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c<=_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c<=_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c<=_entry() //  [R2, R3]
         { []
         }
     {offset
       ccAs5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAs6; else goto ccAs7;
       ccAs6: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$c<=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAs7: // global
           I64[Sp - 16] = block_ccArY_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucAsz; else goto ccArZ;
       ucAsz: // global
           call _ccArY(R1) args: 0, res: 0, upd: 0;
       ccArZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fOrdByteOrder_$c<=_info" {
     GHC.ByteOrder.$fOrdByteOrder_$c<=_info:
         const GHC.ByteOrder.$fOrdByteOrder_$c<=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccArY() //  [R1]
         { []
         }
     {offset
       ccArY: // global
           _scAe7::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAs2; else goto ccAs3;
       ccAs2: // global
           I64[Sp + 8] = block_ccAsa_info;
           R1 = _scAe7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAsx; else goto ccAsc;
       ucAsx: // global
           call _ccAsa(R1) args: 0, res: 0, upd: 0;
       ccAsc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccAs3: // global
           I64[Sp + 8] = block_ccAsp_info;
           R1 = _scAe7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAsy; else goto ccAsr;
       ucAsy: // global
           call _ccAsp() args: 0, res: 0, upd: 0;
       ccAsr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccArY_info" {
     block_ccArY_info:
         const _ccArY;
         const 1;
         const 30;
 },
 _ccAsa() //  [R1]
         { []
         }
     {offset
       ccAsa: // global
           if (R1 & 7 == 1) goto ccAsi; else goto ccAsm;
       ccAsi: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAsm: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAsa_info" {
     block_ccAsa_info:
         const _ccAsa;
         const 0;
         const 30;
 },
 _ccAsp() //  []
         { []
         }
     {offset
       ccAsp: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAsp_info" {
     block_ccAsp_info:
         const _ccAsp;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.766675401 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$cmax_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$cmax_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$cmax_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$cmax_entry() //  [R2, R3]
         { []
         }
     {offset
       ccAtf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAtg; else goto ccAth;
       ccAtg: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$cmax_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAth: // global
           I64[Sp - 16] = block_ccAt8_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucAtv; else goto ccAt9;
       ucAtv: // global
           call _ccAt8(R1) args: 0, res: 0, upd: 0;
       ccAt9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fOrdByteOrder_$cmax_info" {
     GHC.ByteOrder.$fOrdByteOrder_$cmax_info:
         const GHC.ByteOrder.$fOrdByteOrder_$cmax_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccAt8() //  [R1]
         { []
         }
     {offset
       ccAt8: // global
           _scAec::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAtc; else goto ccAtd;
       ccAtc: // global
           R1 = _scAec::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccAtd: // global
           I64[Sp + 8] = block_ccAtn_info;
           R1 = _scAec::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAtu; else goto ccAtp;
       ucAtu: // global
           call _ccAtn() args: 0, res: 0, upd: 0;
       ccAtp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAt8_info" {
     block_ccAt8_info:
         const _ccAt8;
         const 1;
         const 30;
 },
 _ccAtn() //  []
         { []
         }
     {offset
       ccAtn: // global
           R1 = GHC.ByteOrder.LittleEndian_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAtn_info" {
     block_ccAtn_info:
         const _ccAtn;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.774635634 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c>=_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c>=_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c>=_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c>=_entry() //  [R2, R3]
         { []
         }
     {offset
       ccAu1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAu2; else goto ccAu3;
       ccAu2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$c>=_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAu3: // global
           I64[Sp - 16] = block_ccAtU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucAuv; else goto ccAtV;
       ucAuv: // global
           call _ccAtU(R1) args: 0, res: 0, upd: 0;
       ccAtV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fOrdByteOrder_$c>=_info" {
     GHC.ByteOrder.$fOrdByteOrder_$c>=_info:
         const GHC.ByteOrder.$fOrdByteOrder_$c>=_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccAtU() //  [R1]
         { []
         }
     {offset
       ccAtU: // global
           _scAeh::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAtY; else goto ccAtZ;
       ccAtY: // global
           I64[Sp + 8] = block_ccAu6_info;
           R1 = _scAeh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAut; else goto ccAu8;
       ucAut: // global
           call _ccAu6(R1) args: 0, res: 0, upd: 0;
       ccAu8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccAtZ: // global
           I64[Sp + 8] = block_ccAul_info;
           R1 = _scAeh::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAuu; else goto ccAun;
       ucAuu: // global
           call _ccAul() args: 0, res: 0, upd: 0;
       ccAun: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAtU_info" {
     block_ccAtU_info:
         const _ccAtU;
         const 1;
         const 30;
 },
 _ccAu6() //  [R1]
         { []
         }
     {offset
       ccAu6: // global
           if (R1 & 7 == 1) goto ccAue; else goto ccAui;
       ccAue: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAui: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAu6_info" {
     block_ccAu6_info:
         const _ccAu6;
         const 0;
         const 30;
 },
 _ccAul() //  []
         { []
         }
     {offset
       ccAul: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAul_info" {
     block_ccAul_info:
         const _ccAul;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.782747611 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$c>_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$c>_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$c>_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$c>_entry() //  [R2, R3]
         { []
         }
     {offset
       ccAv4: // global
           _scAem::P64 = R3;
           R3 = R2;
           R2 = _scAem::P64;
           call GHC.ByteOrder.$fOrdByteOrder_$c<_entry(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fOrdByteOrder_$c>_info" {
     GHC.ByteOrder.$fOrdByteOrder_$c>_info:
         const GHC.ByteOrder.$fOrdByteOrder_$c>_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.787395769 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_$cmin_closure" {
     GHC.ByteOrder.$fOrdByteOrder_$cmin_closure:
         const GHC.ByteOrder.$fOrdByteOrder_$cmin_info;
 },
 GHC.ByteOrder.$fOrdByteOrder_$cmin_entry() //  [R2, R3]
         { []
         }
     {offset
       ccAvm: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAvn; else goto ccAvo;
       ccAvn: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fOrdByteOrder_$cmin_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAvo: // global
           I64[Sp - 16] = block_ccAvf_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucAvC; else goto ccAvg;
       ucAvC: // global
           call _ccAvf(R1) args: 0, res: 0, upd: 0;
       ccAvg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fOrdByteOrder_$cmin_info" {
     GHC.ByteOrder.$fOrdByteOrder_$cmin_info:
         const GHC.ByteOrder.$fOrdByteOrder_$cmin_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccAvf() //  [R1]
         { []
         }
     {offset
       ccAvf: // global
           _scAen::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAvj; else goto ccAvk;
       ccAvj: // global
           I64[Sp + 8] = block_ccAvr_info;
           R1 = _scAen::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ucAvB; else goto ccAvt;
       ucAvB: // global
           call _ccAvr() args: 0, res: 0, upd: 0;
       ccAvt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
       ccAvk: // global
           R1 = _scAen::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAvf_info" {
     block_ccAvf_info:
         const _ccAvf;
         const 1;
         const 30;
 },
 _ccAvr() //  []
         { []
         }
     {offset
       ccAvr: // global
           R1 = GHC.ByteOrder.BigEndian_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAvr_info" {
     block_ccAvr_info:
         const _ccAvr;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.794006057 UTC

[section ""data" . GHC.ByteOrder.$fOrdByteOrder_closure" {
     GHC.ByteOrder.$fOrdByteOrder_closure:
         const GHC.Classes.C:Ord_con_info;
         const GHC.ByteOrder.$fEqByteOrder_closure+1;
         const GHC.ByteOrder.$fOrdByteOrder_$ccompare_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c<_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c<=_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c>_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$c>=_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$cmax_closure+2;
         const GHC.ByteOrder.$fOrdByteOrder_$cmin_closure+2;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.795831929 UTC

[section ""data" . GHC.ByteOrder.targetByteOrder_closure" {
     GHC.ByteOrder.targetByteOrder_closure:
         const GHC.ByteOrder.LittleEndian_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.797849029 UTC

[section ""data" . lvl_rcykn_closure" {
     lvl_rcykn_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.800015599 UTC

[section ""data" . lvl1_rcyko_closure" {
     lvl1_rcyko_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.802448796 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_info;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_entry() //  [R2]
         { []
         }
     {offset
       ccAwc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccAwd; else goto ccAwe;
       ccAwd: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAwe: // global
           I64[Sp - 8] = block_ccAw5_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucAwl; else goto ccAw6;
       ucAwl: // global
           call _ccAw5(R1) args: 0, res: 0, upd: 0;
       ccAw6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_info" {
     GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_info:
         const GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _ccAw5() //  [R1]
         { []
         }
     {offset
       ccAw5: // global
           if (R1 & 7 == 1) goto ccAw9; else goto ccAwa;
       ccAw9: // global
           R1 = lvl_rcykn_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAwa: // global
           R1 = lvl1_rcyko_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAw5_info" {
     block_ccAw5_info:
         const _ccAw5;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.807560133 UTC

[section ""cstring" . lvl2_rcykp_bytes" {
     lvl2_rcykp_bytes:
         I8[] [101,114,114,111,114]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.809743956 UTC

[section ""data" . lvl3_rcykq_closure" {
     lvl3_rcykq_closure:
         const lvl3_rcykq_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_rcykq_entry() //  [R1]
         { []
         }
     {offset
       ccAwH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAwI; else goto ccAwJ;
       ccAwI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAwJ: // global
           (_ccAwE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAwE::I64 == 0) goto ccAwG; else goto ccAwF;
       ccAwG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAwF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAwE::I64;
           R2 = lvl2_rcykp_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl3_rcykq_info" {
     lvl3_rcykq_info:
         const lvl3_rcykq_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.813079265 UTC

[section ""cstring" . GHC.ByteOrder.$trModule4_bytes" {
     GHC.ByteOrder.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.815208787 UTC

[section ""data" . lvl4_rcykr_closure" {
     lvl4_rcykr_closure:
         const lvl4_rcykr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl4_rcykr_entry() //  [R1]
         { []
         }
     {offset
       ccAwZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAx0; else goto ccAx1;
       ccAx0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAx1: // global
           (_ccAwW::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAwW::I64 == 0) goto ccAwY; else goto ccAwX;
       ccAwY: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAwX: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAwW::I64;
           R2 = GHC.ByteOrder.$trModule4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl4_rcykr_info" {
     lvl4_rcykr_info:
         const lvl4_rcykr_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.818698569 UTC

[section ""cstring" . GHC.ByteOrder.$trModule2_bytes" {
     GHC.ByteOrder.$trModule2_bytes:
         I8[] [71,72,67,46,66,121,116,101,79,114,100,101,114]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.820850289 UTC

[section ""data" . lvl5_rcyks_closure" {
     lvl5_rcyks_closure:
         const lvl5_rcyks_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_rcyks_entry() //  [R1]
         { []
         }
     {offset
       ccAxh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAxi; else goto ccAxj;
       ccAxi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAxj: // global
           (_ccAxe::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAxe::I64 == 0) goto ccAxg; else goto ccAxf;
       ccAxg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAxf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAxe::I64;
           R2 = GHC.ByteOrder.$trModule2_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl5_rcyks_info" {
     lvl5_rcyks_info:
         const lvl5_rcyks_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.824379326 UTC

[section ""cstring" . lvl6_rcykt_bytes" {
     lvl6_rcykt_bytes:
         I8[] [46,47,71,72,67,47,66,121,116,101,79,114,100,101,114,46,104,115]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.826546217 UTC

[section ""data" . lvl7_rcyku_closure" {
     lvl7_rcyku_closure:
         const lvl7_rcyku_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_rcyku_entry() //  [R1]
         { []
         }
     {offset
       ccAxz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAxA; else goto ccAxB;
       ccAxA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAxB: // global
           (_ccAxw::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAxw::I64 == 0) goto ccAxy; else goto ccAxx;
       ccAxy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAxx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAxw::I64;
           R2 = lvl6_rcykt_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl7_rcyku_info" {
     lvl7_rcyku_info:
         const lvl7_rcyku_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.830890548 UTC

[section ""data" . lvl8_rcykv_closure" {
     lvl8_rcykv_closure:
         const GHC.Types.I#_con_info;
         const 26;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.832491406 UTC

[section ""data" . lvl9_rcykw_closure" {
     lvl9_rcykw_closure:
         const GHC.Types.I#_con_info;
         const 16;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.834128532 UTC

[section ""data" . lvl10_rcykx_closure" {
     lvl10_rcykx_closure:
         const GHC.Types.I#_con_info;
         const 20;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.835807253 UTC

[section ""data" . lvl11_rcyky_closure" {
     lvl11_rcyky_closure:
         const GHC.Stack.Types.SrcLoc_con_info;
         const lvl4_rcykr_closure;
         const lvl5_rcyks_closure;
         const lvl7_rcyku_closure;
         const lvl8_rcykv_closure+1;
         const lvl9_rcykw_closure+1;
         const lvl8_rcykv_closure+1;
         const lvl10_rcykx_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.837571988 UTC

[section ""data" . lvl12_rcykz_closure" {
     lvl12_rcykz_closure:
         const GHC.Stack.Types.PushCallStack_con_info;
         const lvl3_rcykq_closure;
         const lvl11_rcyky_closure+1;
         const GHC.Stack.Types.EmptyCallStack_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.839218799 UTC

[section ""cstring" . lvl13_rcykA_bytes" {
     lvl13_rcykA_bytes:
         I8[] [112,114,101,100,123,66,121,116,101,79,114,100,101,114,125,58,32,116,114,105,101,100,32,116,111,32,116,97,107,101,32,96,112,114,101,100,39,32,111,102,32,102,105,114,115,116,32,116,97,103,32,105,110,32,101,110,117,109,101,114,97,116,105,111,110]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.841749024 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder3_closure" {
     GHC.ByteOrder.$fEnumByteOrder3_closure:
         const GHC.ByteOrder.$fEnumByteOrder3_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder3_entry() //  [R1]
         { []
         }
     {offset
       ccAxY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccAxZ; else goto ccAy0;
       ccAxZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAy0: // global
           (_ccAxT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAxT::I64 == 0) goto ccAxV; else goto ccAxU;
       ccAxV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAxU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAxT::I64;
           I64[Sp - 24] = block_ccAxW_info;
           R2 = lvl13_rcykA_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder3_info" {
     GHC.ByteOrder.$fEnumByteOrder3_info:
         const GHC.ByteOrder.$fEnumByteOrder3_entry;
         const 0;
         const 12884901909;
         const ScAiT_srt+112;
 },
 _ccAxW() //  [R1]
         { []
         }
     {offset
       ccAxW: // global
           R3 = R1;
           R2 = lvl12_rcykz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccAxW_info" {
     block_ccAxW_info:
         const _ccAxW;
         const 0;
         const 12884901918;
         const ScAiT_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.847849527 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cpred_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cpred_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cpred_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cpred_entry() //  [R2]
         { []
         }
     {offset
       ccAyr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccAys; else goto ccAyt;
       ccAys: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cpred_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAyt: // global
           I64[Sp - 8] = block_ccAyk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucAyA; else goto ccAyl;
       ucAyA: // global
           call _ccAyk(R1) args: 0, res: 0, upd: 0;
       ccAyl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_$cpred_info" {
     GHC.ByteOrder.$fEnumByteOrder_$cpred_info:
         const GHC.ByteOrder.$fEnumByteOrder_$cpred_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const ScAiT_srt+128;
 },
 _ccAyk() //  [R1]
         { []
         }
     {offset
       ccAyk: // global
           if (R1 & 7 == 1) goto ccAyo; else goto ccAyp;
       ccAyo: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder3_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccAyp: // global
           R1 = GHC.ByteOrder.BigEndian_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAyk_info" {
     block_ccAyk_info:
         const _ccAyk;
         const 0;
         const 4294967326;
         const ScAiT_srt+136;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.852614036 UTC

[section ""cstring" . lvl14_rcykB_bytes" {
     lvl14_rcykB_bytes:
         I8[] [115,117,99,99,123,66,121,116,101,79,114,100,101,114,125,58,32,116,114,105,101,100,32,116,111,32,116,97,107,101,32,96,115,117,99,99,39,32,111,102,32,108,97,115,116,32,116,97,103,32,105,110,32,101,110,117,109,101,114,97,116,105,111,110]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.855587109 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder4_closure" {
     GHC.ByteOrder.$fEnumByteOrder4_closure:
         const GHC.ByteOrder.$fEnumByteOrder4_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder4_entry() //  [R1]
         { []
         }
     {offset
       ccAyY: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccAyZ; else goto ccAz0;
       ccAyZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAz0: // global
           (_ccAyT::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAyT::I64 == 0) goto ccAyV; else goto ccAyU;
       ccAyV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAyU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAyT::I64;
           I64[Sp - 24] = block_ccAyW_info;
           R2 = lvl14_rcykB_bytes;
           Sp = Sp - 24;
           call GHC.CString.unpackCString#_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder4_info" {
     GHC.ByteOrder.$fEnumByteOrder4_info:
         const GHC.ByteOrder.$fEnumByteOrder4_entry;
         const 0;
         const 12884901909;
         const ScAiT_srt+112;
 },
 _ccAyW() //  [R1]
         { []
         }
     {offset
       ccAyW: // global
           R3 = R1;
           R2 = lvl12_rcykz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccAyW_info" {
     block_ccAyW_info:
         const _ccAyW;
         const 0;
         const 12884901918;
         const ScAiT_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.861740341 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$csucc_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$csucc_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$csucc_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$csucc_entry() //  [R2]
         { []
         }
     {offset
       ccAzr: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccAzs; else goto ccAzt;
       ccAzs: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$csucc_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAzt: // global
           I64[Sp - 8] = block_ccAzk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucAzA; else goto ccAzl;
       ucAzA: // global
           call _ccAzk(R1) args: 0, res: 0, upd: 0;
       ccAzl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_$csucc_info" {
     GHC.ByteOrder.$fEnumByteOrder_$csucc_info:
         const GHC.ByteOrder.$fEnumByteOrder_$csucc_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const ScAiT_srt+144;
 },
 _ccAzk() //  [R1]
         { []
         }
     {offset
       ccAzk: // global
           if (R1 & 7 == 1) goto ccAzo; else goto ccAzp;
       ccAzo: // global
           R1 = GHC.ByteOrder.LittleEndian_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAzp: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder4_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAzk_info" {
     block_ccAzk_info:
         const _ccAzk;
         const 0;
         const 4294967326;
         const ScAiT_srt+152;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.866738125 UTC

[section ""cstring" . lvl15_rcykC_bytes" {
     lvl15_rcykC_bytes:
         I8[] [41,32,105,115,32,111,117,116,115,105,100,101,32,111,102,32,101,110,117,109,101,114,97,116,105,111,110,39,115,32,114,97,110,103,101,32,40,48,44]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.868262632 UTC

[section ""cstring" . lvl16_rcykD_bytes" {
     lvl16_rcykD_bytes:
         I8[] [41]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.870423757 UTC

[section ""data" . lvl17_rcykE_closure" {
     lvl17_rcykE_closure:
         const lvl17_rcykE_info;
         const 0;
         const 0;
         const 0;
 },
 lvl17_rcykE_entry() //  [R1]
         { []
         }
     {offset
       ccAzX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAzY; else goto ccAzZ;
       ccAzY: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAzZ: // global
           (_ccAzU::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAzU::I64 == 0) goto ccAzW; else goto ccAzV;
       ccAzW: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAzV: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAzU::I64;
           R2 = lvl16_rcykD_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl17_rcykE_info" {
     lvl17_rcykE_info:
         const lvl17_rcykE_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.875102892 UTC

[section ""data" . lvl18_rcykF_closure" {
     lvl18_rcykF_closure:
         const lvl18_rcykF_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_rcykF_entry() //  [R1]
         { []
         }
     {offset
       ccAAh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccAAi; else goto ccAAj;
       ccAAi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAAj: // global
           (_ccAAb::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAAb::I64 == 0) goto ccAAd; else goto ccAAc;
       ccAAd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAAc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAAb::I64;
           I64[Sp - 24] = block_ccAAe_info;
           R4 = lvl17_rcykE_closure;
           R3 = 1;
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . lvl18_rcykF_info" {
     lvl18_rcykF_info:
         const lvl18_rcykF_entry;
         const 0;
         const 4294967317;
         const ScAiT_srt+160;
 },
 _ccAAe() //  [R1, R2]
         { []
         }
     {offset
       ccAAe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccAAm; else goto ccAAl;
       ccAAm: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccAAl: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccAAe_info" {
     block_ccAAe_info:
         const _ccAAe;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.880715155 UTC

[section ""data" . lvl19_rcykG_closure" {
     lvl19_rcykG_closure:
         const lvl19_rcykG_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_rcykG_entry() //  [R1]
         { []
         }
     {offset
       ccAAH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAAI; else goto ccAAJ;
       ccAAI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAAJ: // global
           (_ccAAE::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccAAE::I64 == 0) goto ccAAG; else goto ccAAF;
       ccAAG: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccAAF: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccAAE::I64;
           R3 = lvl18_rcykF_closure;
           R2 = lvl15_rcykC_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl19_rcykG_info" {
     lvl19_rcykG_info:
         const lvl19_rcykG_entry;
         const 0;
         const 4294967317;
         const ScAiT_srt+168;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.88418351 UTC

[section ""cstring" . lvl20_rcykH_bytes" {
     lvl20_rcykH_bytes:
         I8[] [116,111,69,110,117,109,123,66,121,116,101,79,114,100,101,114,125,58,32,116,97,103,32,40]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.887580925 UTC

[section ""data" . GHC.ByteOrder.$wlvl_closure" {
     GHC.ByteOrder.$wlvl_closure:
         const GHC.ByteOrder.$wlvl_info;
         const 0;
 },
 sat_scAeG_entry() //  [R1]
         { []
         }
     {offset
       ccAB4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccAB5; else goto ccAB6;
       ccAB5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAB6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_ccAB1_info;
           R4 = lvl19_rcykG_closure;
           R3 = I64[R1 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_entry(R4,
                                               R3,
                                               R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAeG_info" {
     sat_scAeG_info:
         const sat_scAeG_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+176;
 },
 _ccAB1() //  [R1, R2]
         { []
         }
     {offset
       ccAB1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccAB9; else goto ccAB8;
       ccAB9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       ccAB8: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_ccAB1_info" {
     block_ccAB1_info:
         const _ccAB1;
         const 0;
         const 30;
 },
 GHC.ByteOrder.$wlvl_entry() //  [R2]
         { []
         }
     {offset
       ccABc: // global
           _scAeC::I64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto ccABd; else goto ccABe;
       ccABe: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccABg; else goto ccABf;
       ccABg: // global
           HpAlloc = 24;
           goto ccABd;
       ccABd: // global
           R2 = _scAeC::I64;
           R1 = GHC.ByteOrder.$wlvl_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccABf: // global
           I64[Hp - 16] = sat_scAeG_info;
           I64[Hp] = _scAeC::I64;
           I64[Sp - 8] = block_ccABa_info;
           R3 = Hp - 16;
           R2 = lvl20_rcykH_bytes;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_entry(R3,
                                                       R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$wlvl_info" {
     GHC.ByteOrder.$wlvl_info:
         const GHC.ByteOrder.$wlvl_entry;
         const 0;
         const 3311419785230;
         const 4294967300;
         const ScAiT_srt+112;
 },
 _ccABa() //  [R1]
         { []
         }
     {offset
       ccABa: // global
           R3 = R1;
           R2 = lvl12_rcykz_closure+2;
           Sp = Sp + 8;
           call GHC.Err.error_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccABa_info" {
     block_ccABa_info:
         const _ccABa;
         const 0;
         const 12884901918;
         const ScAiT_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.896609494 UTC

[section ""data" . GHC.ByteOrder.$w$ctoEnum_closure" {
     GHC.ByteOrder.$w$ctoEnum_closure:
         const GHC.ByteOrder.$w$ctoEnum_info;
         const 0;
 },
 GHC.ByteOrder.$w$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       ccABO: // global
           _scAeI::I64 = R2;
           if (%MO_S_Lt_W64(R2, 0)) goto ccABW; else goto ccABN;
       ccABN: // global
           if (%MO_S_Gt_W64(_scAeI::I64, 1)) goto ccABW; else goto ccABX;
       ccABW: // global
           R2 = _scAeI::I64;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 8, res: 0, upd: 8;
       ccABX: // global
           R1 = I64[(_scAeI::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$w$ctoEnum_info" {
     GHC.ByteOrder.$w$ctoEnum_info:
         const GHC.ByteOrder.$w$ctoEnum_entry;
         const 0;
         const 4294967310;
         const 4294967300;
         const ScAiT_srt+184;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.900817437 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_entry() //  [R2]
         { []
         }
     {offset
       ccACc: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccACd; else goto ccACe;
       ccACd: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccACe: // global
           I64[Sp - 8] = block_ccAC9_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucACi; else goto ccACa;
       ucACi: // global
           call _ccAC9(R1) args: 0, res: 0, upd: 0;
       ccACa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_info" {
     GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_info:
         const GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const ScAiT_srt+192;
 },
 _ccAC9() //  [R1]
         { []
         }
     {offset
       ccAC9: // global
           R2 = I64[R1 + 7];
           Sp = Sp + 8;
           call GHC.ByteOrder.$w$ctoEnum_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAC9_info" {
     block_ccAC9_info:
         const _ccAC9;
         const 0;
         const 4294967326;
         const ScAiT_srt+200;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.906807337 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_go2_closure" {
     GHC.ByteOrder.$fEnumByteOrder_go2_closure:
         const GHC.ByteOrder.$fEnumByteOrder_go2_info;
 },
 sat_scAeS_entry() //  [R1]
         { []
         }
     {offset
       ccACF: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccACG; else goto ccACH;
       ccACG: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccACH: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAeQ::I64 = I64[R1 + 16];
           if (_scAeQ::I64 != 1) goto ccACD; else goto ccACE;
       ccACD: // global
           R2 = _scAeQ::I64 + 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go2_entry(R2) args: 24, res: 0, upd: 24;
       ccACE: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAeS_info" {
     sat_scAeS_info:
         const sat_scAeS_entry;
         const 4294967296;
         const 17;
 },
 sat_scAeP_entry() //  [R1]
         { []
         }
     {offset
       ccACO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccACP; else goto ccACQ;
       ccACP: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccACQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAeP_info" {
     sat_scAeP_info:
         const sat_scAeP_entry;
         const 4294967296;
         const 17;
 },
 GHC.ByteOrder.$fEnumByteOrder_go2_entry() //  [R2]
         { []
         }
     {offset
       ccACS: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccACW; else goto ccACV;
       ccACW: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_go2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccACV: // global
           I64[Hp - 64] = sat_scAeS_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAeP_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_go2_info" {
     GHC.ByteOrder.$fEnumByteOrder_go2_info:
         const GHC.ByteOrder.$fEnumByteOrder_go2_entry;
         const 0;
         const 14;
         const 4294967300;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.914321045 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder2_closure" {
     GHC.ByteOrder.$fEnumByteOrder2_closure:
         const GHC.ByteOrder.$fEnumByteOrder2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder2_entry() //  [R1]
         { []
         }
     {offset
       ccADs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccADt; else goto ccADu;
       ccADt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccADu: // global
           (_ccADp::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccADp::I64 == 0) goto ccADr; else goto ccADq;
       ccADr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccADq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccADp::I64;
           R2 = 0;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder2_info" {
     GHC.ByteOrder.$fEnumByteOrder2_info:
         const GHC.ByteOrder.$fEnumByteOrder2_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.918233533 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder1_closure" {
     GHC.ByteOrder.$fEnumByteOrder1_closure:
         const GHC.ByteOrder.$fEnumByteOrder1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder1_entry() //  [R1]
         { []
         }
     {offset
       ccADJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccADK; else goto ccADL;
       ccADK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccADL: // global
           (_ccADG::I64) = call "ccall" arg hints:  [PtrHint,
                                                     PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_ccADG::I64 == 0) goto ccADI; else goto ccADH;
       ccADI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       ccADH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ccADG::I64;
           R2 = 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go2_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder1_info" {
     GHC.ByteOrder.$fEnumByteOrder1_info:
         const GHC.ByteOrder.$fEnumByteOrder1_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.922857745 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_entry() //  [R2]
         { []
         }
     {offset
       ccAE5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto ccAE6; else goto ccAE7;
       ccAE6: // global
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAE7: // global
           I64[Sp - 8] = block_ccADY_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ucAEe; else goto ccADZ;
       ucAEe: // global
           call _ccADY(R1) args: 0, res: 0, upd: 0;
       ccADZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_info" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_info:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_entry;
         const 0;
         const 30064771086;
         const 4294967301;
         const ScAiT_srt+208;
 },
 _ccADY() //  [R1]
         { []
         }
     {offset
       ccADY: // global
           if (R1 & 7 == 1) goto ccAE2; else goto ccAE3;
       ccAE2: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       ccAE3: // global
           R1 = GHC.ByteOrder.$fEnumByteOrder1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccADY_info" {
     block_ccADY_info:
         const _ccADY;
         const 0;
         const 12884901918;
         const ScAiT_srt+216;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:29.943323958 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_info;
 },
 sat_scAfc_entry() //  [R1]
         { []
         }
     {offset
       ccAFe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAFf; else goto ccAFg;
       ccAFf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAFg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scAf7_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfc_info" {
     sat_scAfc_info:
         const sat_scAfc_entry;
         const 8589934593;
         const 15;
 },
 sat_scAfa_entry() //  [R1]
         { []
         }
     {offset
       ccAFl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAFm; else goto ccAFn;
       ccAFm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAFn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfa_info" {
     sat_scAfa_info:
         const sat_scAfa_entry;
         const 4294967296;
         const 17;
 },
 sat_scAfd_entry() //  [R1]
         { []
         }
     {offset
       ccAFt: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAFu; else goto ccAFv;
       ccAFu: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAFv: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfd_info" {
     sat_scAfd_info:
         const sat_scAfd_entry;
         const 4294967296;
         const 17;
 },
 go_dn_scAf7_entry() //  [R1, R2]
         { []
         }
     {offset
       ccAFz: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccAFD; else goto ccAFC;
       ccAFD: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAFC: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto ccAFx; else goto ccAFy;
       ccAFx: // global
           _scAf5::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scAfc_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scAf5::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAfa_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAFy: // global
           I64[Hp - 80] = sat_scAfd_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccAFF::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccAFF::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_scAf7_info" {
     go_dn_scAf7_info:
         const go_dn_scAf7_entry;
         const 8589934592;
         const 13;
         const 4294967300;
 },
 sat_scAfe_entry() //  [R1]
         { []
         }
     {offset
       ccAFG: // global
           _scAfe::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccAFH; else goto ccAFI;
       ccAFI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccAFK; else goto ccAFJ;
       ccAFK: // global
           HpAlloc = 24;
           goto ccAFH;
       ccAFH: // global
           R1 = _scAfe::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAFJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scAfe::P64;
           _scAf0::I64 = I64[_scAfe::P64 + 24];
           _scAf5::I64 = _scAf0::I64 - I64[_scAfe::P64 + 16];
           I64[Hp - 16] = go_dn_scAf7_info;
           I64[Hp - 8] = _scAf5::I64;
           I64[Hp] = 1 - _scAf5::I64;
           R2 = _scAf0::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scAf7_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfe_info" {
     sat_scAfe_info:
         const sat_scAfe_entry;
         const 8589934592;
         const 20;
 },
 sat_scAf4_entry() //  [R1]
         { []
         }
     {offset
       ccAFP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAFQ; else goto ccAFR;
       ccAFQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAFR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAf4_info" {
     sat_scAf4_info:
         const sat_scAf4_entry;
         const 4294967296;
         const 17;
 },
 sat_scAfg_entry() //  [R1]
         { []
         }
     {offset
       ccAG0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAG1; else goto ccAG2;
       ccAG1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAG2: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfg_info" {
     sat_scAfg_info:
         const sat_scAfg_entry;
         const 4294967296;
         const 17;
 },
 sat_scAfq_entry() //  [R1]
         { []
         }
     {offset
       ccAGv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAGw; else goto ccAGx;
       ccAGw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAGx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scAfl_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfq_info" {
     sat_scAfq_info:
         const sat_scAfq_entry;
         const 8589934593;
         const 15;
 },
 sat_scAfo_entry() //  [R1]
         { []
         }
     {offset
       ccAGC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAGD; else goto ccAGE;
       ccAGD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAGE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfo_info" {
     sat_scAfo_info:
         const sat_scAfo_entry;
         const 4294967296;
         const 17;
 },
 sat_scAfr_entry() //  [R1]
         { []
         }
     {offset
       ccAGK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAGL; else goto ccAGM;
       ccAGL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAGM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfr_info" {
     sat_scAfr_info:
         const sat_scAfr_entry;
         const 4294967296;
         const 17;
 },
 go_up_scAfl_entry() //  [R1, R2]
         { []
         }
     {offset
       ccAGQ: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccAGU; else goto ccAGT;
       ccAGU: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAGT: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto ccAGO; else goto ccAGP;
       ccAGO: // global
           _scAfj::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scAfq_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scAfj::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAfo_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAGP: // global
           I64[Hp - 80] = sat_scAfr_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccAGW::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccAGW::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_scAfl_info" {
     go_up_scAfl_info:
         const go_up_scAfl_entry;
         const 8589934592;
         const 13;
         const 4294967300;
 },
 sat_scAfs_entry() //  [R1]
         { []
         }
     {offset
       ccAGX: // global
           _scAfs::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccAGY; else goto ccAGZ;
       ccAGZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccAH1; else goto ccAH0;
       ccAH1: // global
           HpAlloc = 24;
           goto ccAGY;
       ccAGY: // global
           R1 = _scAfs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAH0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scAfs::P64;
           _scAf0::I64 = I64[_scAfs::P64 + 24];
           _scAfj::I64 = _scAf0::I64 - I64[_scAfs::P64 + 16];
           I64[Hp - 16] = go_up_scAfl_info;
           I64[Hp - 8] = _scAfj::I64;
           I64[Hp] = 1 - _scAfj::I64;
           R2 = _scAf0::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scAfl_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfs_info" {
     sat_scAfs_info:
         const sat_scAfs_entry;
         const 8589934592;
         const 20;
 },
 sat_scAfi_entry() //  [R1]
         { []
         }
     {offset
       ccAH6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAH7; else goto ccAH8;
       ccAH7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAH8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfi_info" {
     sat_scAfi_info:
         const sat_scAfi_entry;
         const 4294967296;
         const 17;
 },
 sat_scAfu_entry() //  [R1]
         { []
         }
     {offset
       ccAHh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAHi; else goto ccAHj;
       ccAHi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAHj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfu_info" {
     sat_scAfu_info:
         const sat_scAfu_entry;
         const 4294967296;
         const 17;
 },
 sat_scAfF_entry() //  [R1]
         { []
         }
     {offset
       ccAHP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAHQ; else goto ccAHR;
       ccAHQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAHR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scAfA_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfF_info" {
     sat_scAfF_info:
         const sat_scAfF_entry;
         const 8589934593;
         const 15;
 },
 sat_scAfD_entry() //  [R1]
         { []
         }
     {offset
       ccAHW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAHX; else goto ccAHY;
       ccAHX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAHY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfD_info" {
     sat_scAfD_info:
         const sat_scAfD_entry;
         const 4294967296;
         const 17;
 },
 sat_scAfG_entry() //  [R1]
         { []
         }
     {offset
       ccAI4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAI5; else goto ccAI6;
       ccAI5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAI6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfG_info" {
     sat_scAfG_info:
         const sat_scAfG_entry;
         const 4294967296;
         const 17;
 },
 go_dn_scAfA_entry() //  [R1, R2]
         { []
         }
     {offset
       ccAIa: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccAIe; else goto ccAId;
       ccAIe: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAId: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto ccAI8; else goto ccAI9;
       ccAI8: // global
           _scAfy::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scAfF_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scAfy::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAfD_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAI9: // global
           I64[Hp - 80] = sat_scAfG_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccAIg::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccAIg::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_scAfA_info" {
     go_dn_scAfA_info:
         const go_dn_scAfA_entry;
         const 8589934592;
         const 13;
         const 4294967300;
 },
 sat_scAfH_entry() //  [R1]
         { []
         }
     {offset
       ccAIh: // global
           _scAfH::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccAIi; else goto ccAIj;
       ccAIj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccAIl; else goto ccAIk;
       ccAIl: // global
           HpAlloc = 24;
           goto ccAIi;
       ccAIi: // global
           R1 = _scAfH::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAIk: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scAfH::P64;
           _scAf0::I64 = I64[_scAfH::P64 + 24];
           _scAfy::I64 = _scAf0::I64 - I64[_scAfH::P64 + 16];
           I64[Hp - 16] = go_dn_scAfA_info;
           I64[Hp - 8] = _scAfy::I64;
           I64[Hp] = 0 - _scAfy::I64;
           R2 = _scAf0::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scAfA_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfH_info" {
     sat_scAfH_info:
         const sat_scAfH_entry;
         const 8589934592;
         const 20;
 },
 sat_scAfx_entry() //  [R1]
         { []
         }
     {offset
       ccAIq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAIr; else goto ccAIs;
       ccAIr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAIs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfx_info" {
     sat_scAfx_info:
         const sat_scAfx_entry;
         const 4294967296;
         const 17;
 },
 sat_scAfJ_entry() //  [R1]
         { []
         }
     {offset
       ccAIB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAIC; else goto ccAID;
       ccAIC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAID: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfJ_info" {
     sat_scAfJ_info:
         const sat_scAfJ_entry;
         const 4294967296;
         const 17;
 },
 sat_scAfT_entry() //  [R1]
         { []
         }
     {offset
       ccAJ6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAJ7; else goto ccAJ8;
       ccAJ7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAJ8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scAfO_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfT_info" {
     sat_scAfT_info:
         const sat_scAfT_entry;
         const 8589934593;
         const 15;
 },
 sat_scAfR_entry() //  [R1]
         { []
         }
     {offset
       ccAJd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAJe; else goto ccAJf;
       ccAJe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAJf: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfR_info" {
     sat_scAfR_info:
         const sat_scAfR_entry;
         const 4294967296;
         const 17;
 },
 sat_scAfU_entry() //  [R1]
         { []
         }
     {offset
       ccAJl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAJm; else goto ccAJn;
       ccAJm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAJn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfU_info" {
     sat_scAfU_info:
         const sat_scAfU_entry;
         const 4294967296;
         const 17;
 },
 go_up_scAfO_entry() //  [R1, R2]
         { []
         }
     {offset
       ccAJr: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccAJv; else goto ccAJu;
       ccAJv: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAJu: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto ccAJp; else goto ccAJq;
       ccAJp: // global
           _scAfM::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scAfT_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scAfM::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAfR_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAJq: // global
           I64[Hp - 80] = sat_scAfU_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccAJx::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccAJx::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_scAfO_info" {
     go_up_scAfO_info:
         const go_up_scAfO_entry;
         const 8589934592;
         const 13;
         const 4294967300;
 },
 sat_scAfV_entry() //  [R1]
         { []
         }
     {offset
       ccAJy: // global
           _scAfV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccAJz; else goto ccAJA;
       ccAJA: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccAJC; else goto ccAJB;
       ccAJC: // global
           HpAlloc = 24;
           goto ccAJz;
       ccAJz: // global
           R1 = _scAfV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAJB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scAfV::P64;
           _scAf0::I64 = I64[_scAfV::P64 + 24];
           _scAfM::I64 = _scAf0::I64 - I64[_scAfV::P64 + 16];
           I64[Hp - 16] = go_up_scAfO_info;
           I64[Hp - 8] = _scAfM::I64;
           I64[Hp] = 0 - _scAfM::I64;
           R2 = _scAf0::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scAfO_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfV_info" {
     sat_scAfV_info:
         const sat_scAfV_entry;
         const 8589934592;
         const 20;
 },
 sat_scAfL_entry() //  [R1]
         { []
         }
     {offset
       ccAJH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAJI; else goto ccAJJ;
       ccAJI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAJJ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfL_info" {
     sat_scAfL_info:
         const sat_scAfL_entry;
         const 4294967296;
         const 17;
 },
 sat_scAfX_entry() //  [R1]
         { []
         }
     {offset
       ccAJS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAJT; else goto ccAJU;
       ccAJT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAJU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R1 = I64[(I64[R1 + 16] << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAfX_info" {
     sat_scAfX_info:
         const sat_scAfX_entry;
         const 4294967296;
         const 17;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_entry() //  [R2, R3]
         { []
         }
     {offset
       ccAK2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAK3; else goto ccAK4;
       ccAK3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccAK4: // global
           I64[Sp - 16] = block_ccAJV_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucALc; else goto ccAJW;
       ucALc: // global
           call _ccAJV(R1) args: 0, res: 0, upd: 0;
       ccAJW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_info" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_info:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _ccAJV() //  [R1]
         { []
         }
     {offset
       ccAJV: // global
           _scAeW::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccAJZ; else goto ccAK0;
       ccAJZ: // global
           _scAeY::I64 = 0;
           goto scAeX;
       ccAK0: // global
           _scAeY::I64 = 1;
           goto scAeX;
       scAeX: // global
           I64[Sp] = block_ccAK5_info;
           R1 = _scAeW::P64;
           I64[Sp + 8] = _scAeY::I64;
           if (R1 & 7 != 0) goto ucALb; else goto ccAKP;
       ucALb: // global
           call _ccAK5(R1) args: 0, res: 0, upd: 0;
       ccAKP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAJV_info" {
     block_ccAJV_info:
         const _ccAJV;
         const 1;
         const 30;
 },
 _ccAK5() //  [R1]
         { []
         }
     {offset
       ccAK5: // global
           if (R1 & 7 == 1) goto ccAKV; else goto ccAKZ;
       ccAKV: // global
           I64[Sp] = 0;
           goto ucALe;
       ccAKZ: // global
           I64[Sp] = 1;
           goto ucALe;
       ucALe: // global
           call _ccAEF() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ccAK5_info" {
     block_ccAK5_info:
         const _ccAK5;
         const 65;
         const 30;
 },
 _ccAEF() //  []
         { []
         }
     {offset
       ccAEF: // global
           Hp = Hp + 80;
           _scAf0::I64 = I64[Sp];
           if (Hp > HpLim) (likely: False) goto ccAK9; else goto ccAK8;
       ccAK9: // global
           HpAlloc = 80;
           I64[Sp] = block_ccAEE_info;
           R1 = _scAf0::I64;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       ccAK8: // global
           _scAeY::I64 = I64[Sp + 8];
           if (%MO_S_Le_W64(_scAeY::I64,
                            _scAf0::I64)) goto ccAKu; else goto ccAKO;
       ccAKu: // global
           if (%MO_S_Lt_W64(_scAf0::I64,
                            _scAeY::I64)) goto ccAKj; else goto ccAKs;
       ccAKj: // global
           if (%MO_S_Le_W64(1, _scAf0::I64)) goto ccAKc; else goto ccAKh;
       ccAKc: // global
           I64[Hp - 72] = sat_scAfe_info;
           I64[Hp - 56] = _scAeY::I64;
           I64[Hp - 48] = _scAf0::I64;
           I64[Hp - 40] = sat_scAf4_info;
           I64[Hp - 24] = _scAeY::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAKh: // global
           if (%MO_S_Gt_W64(1, _scAeY::I64)) goto ccAKL; else goto ccAKf;
       ccAKf: // global
           I64[Hp - 72] = sat_scAfg_info;
           I64[Hp - 56] = _scAeY::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccAKd::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccAKd::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAKs: // global
           if (%MO_S_Ge_W64(1, _scAf0::I64)) goto ccAKm; else goto ccAKr;
       ccAKm: // global
           I64[Hp - 72] = sat_scAfs_info;
           I64[Hp - 56] = _scAeY::I64;
           I64[Hp - 48] = _scAf0::I64;
           I64[Hp - 40] = sat_scAfi_info;
           I64[Hp - 24] = _scAeY::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAKr: // global
           if (%MO_S_Lt_W64(1, _scAeY::I64)) goto ccAKL; else goto ccAKp;
       ccAKp: // global
           I64[Hp - 72] = sat_scAfu_info;
           I64[Hp - 56] = _scAeY::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccAKn::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccAKn::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAKO: // global
           if (%MO_S_Lt_W64(_scAf0::I64,
                            _scAeY::I64)) goto ccAKE; else goto ccAKN;
       ccAKE: // global
           if (%MO_S_Le_W64(0, _scAf0::I64)) goto ccAKx; else goto ccAKC;
       ccAKx: // global
           I64[Hp - 72] = sat_scAfH_info;
           I64[Hp - 56] = _scAeY::I64;
           I64[Hp - 48] = _scAf0::I64;
           I64[Hp - 40] = sat_scAfx_info;
           I64[Hp - 24] = _scAeY::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAKC: // global
           if (%MO_S_Gt_W64(0, _scAeY::I64)) goto ccAKL; else goto ccAKA;
       ccAKA: // global
           I64[Hp - 72] = sat_scAfJ_info;
           I64[Hp - 56] = _scAeY::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccAKy::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccAKy::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAKN: // global
           if (%MO_S_Ge_W64(0, _scAf0::I64)) goto ccAKH; else goto ccAKM;
       ccAKH: // global
           I64[Hp - 72] = sat_scAfV_info;
           I64[Hp - 56] = _scAeY::I64;
           I64[Hp - 48] = _scAf0::I64;
           I64[Hp - 40] = sat_scAfL_info;
           I64[Hp - 24] = _scAeY::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAKM: // global
           if (%MO_S_Lt_W64(0, _scAeY::I64)) goto ccAKL; else goto ccAKK;
       ccAKL: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAKK: // global
           I64[Hp - 72] = sat_scAfX_info;
           I64[Hp - 56] = _scAeY::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccAKI::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccAKI::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 _ccAEE() //  [R1]
         { []
         }
     {offset
       ccAEE: // global
           I64[Sp] = R1;
           call _ccAEF() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_ccAEE_info" {
     block_ccAEE_info:
         const _ccAEE;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.00660912 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_go1_closure" {
     GHC.ByteOrder.$fEnumByteOrder_go1_closure:
         const GHC.ByteOrder.$fEnumByteOrder_go1_info;
         const 0;
 },
 sat_scAg6_entry() //  [R1]
         { []
         }
     {offset
       ccAQI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAQJ; else goto ccAQK;
       ccAQJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAQK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAg4::I64 = I64[R1 + 16];
           if (_scAg4::I64 != 0) goto ccAQG; else goto ccAQH;
       ccAQG: // global
           R2 = _scAg4::I64 + 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go1_entry(R2) args: 24, res: 0, upd: 24;
       ccAQH: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAg6_info" {
     sat_scAg6_info:
         const sat_scAg6_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+232;
 },
 sat_scAg3_entry() //  [R1]
         { []
         }
     {offset
       ccAQW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAQX; else goto ccAR5;
       ccAQX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAR5: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAg0::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAg0::I64, 0)) goto ccAR3; else goto ccAQV;
       ccAQV: // global
           if (%MO_S_Gt_W64(_scAg0::I64, 1)) goto ccAR3; else goto ccAR4;
       ccAR3: // global
           R2 = _scAg0::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAR4: // global
           R1 = I64[(_scAg0::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAg3_info" {
     sat_scAg3_info:
         const sat_scAg3_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+184;
 },
 GHC.ByteOrder.$fEnumByteOrder_go1_entry() //  [R2]
         { []
         }
     {offset
       ccAR7: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccARb; else goto ccARa;
       ccARb: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_go1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccARa: // global
           I64[Hp - 64] = sat_scAg6_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAg3_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_go1_info" {
     GHC.ByteOrder.$fEnumByteOrder_go1_info:
         const GHC.ByteOrder.$fEnumByteOrder_go1_entry;
         const 0;
         const 279172874254;
         const 4294967300;
         const ScAiT_srt+184;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.015018988 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_go_closure" {
     GHC.ByteOrder.$fEnumByteOrder_go_closure:
         const GHC.ByteOrder.$fEnumByteOrder_go_info;
         const 0;
 },
 sat_scAgd_entry() //  [R1]
         { []
         }
     {offset
       ccARN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccARO; else goto ccARP;
       ccARO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccARP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgb::I64 = I64[R1 + 16];
           if (_scAgb::I64 != 1) goto ccARL; else goto ccARM;
       ccARL: // global
           R2 = _scAgb::I64 + 1;
           Sp = Sp - 16;
           call GHC.ByteOrder.$fEnumByteOrder_go_entry(R2) args: 24, res: 0, upd: 24;
       ccARM: // global
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAgd_info" {
     sat_scAgd_info:
         const sat_scAgd_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+240;
 },
 sat_scAga_entry() //  [R1]
         { []
         }
     {offset
       ccAS1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAS2; else goto ccASa;
       ccAS2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccASa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAg7::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAg7::I64, 0)) goto ccAS8; else goto ccAS0;
       ccAS0: // global
           if (%MO_S_Gt_W64(_scAg7::I64, 1)) goto ccAS8; else goto ccAS9;
       ccAS8: // global
           R2 = _scAg7::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAS9: // global
           R1 = I64[(_scAg7::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAga_info" {
     sat_scAga_info:
         const sat_scAga_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+184;
 },
 GHC.ByteOrder.$fEnumByteOrder_go_entry() //  [R2]
         { []
         }
     {offset
       ccASc: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto ccASg; else goto ccASf;
       ccASg: // global
           HpAlloc = 72;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccASf: // global
           I64[Hp - 64] = sat_scAgd_info;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAga_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 64;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_go_info" {
     GHC.ByteOrder.$fEnumByteOrder_go_info:
         const GHC.ByteOrder.$fEnumByteOrder_go_entry;
         const 0;
         const 554050781198;
         const 4294967300;
         const ScAiT_srt+184;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.023784742 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_info;
         const 0;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_entry() //  [R2, R3]
         { []
         }
     {offset
       ccAST: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccASU; else goto ccASV;
       ccASU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ccASV: // global
           I64[Sp - 16] = block_ccASM_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ucATu; else goto ccASN;
       ucATu: // global
           call _ccASM(R1) args: 0, res: 0, upd: 0;
       ccASN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_info" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_info:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_entry;
         const 0;
         const 30064771086;
         const 8589934607;
         const ScAiT_srt+232;
 },
 _ccASM() //  [R1]
         { []
         }
     {offset
       ccASM: // global
           _scAgf::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccASQ; else goto ccASR;
       ccASQ: // global
           _scAgh::I64 = 0;
           goto scAgg;
       ccASR: // global
           _scAgh::I64 = 1;
           goto scAgg;
       scAgg: // global
           I64[Sp] = block_ccASZ_info;
           R1 = _scAgf::P64;
           I64[Sp + 8] = _scAgh::I64;
           if (R1 & 7 != 0) goto ucATt; else goto ccAT1;
       ucATt: // global
           call _ccASZ(R1) args: 0, res: 0, upd: 0;
       ccAT1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccASM_info" {
     block_ccASM_info:
         const _ccASM;
         const 1;
         const 12884901918;
         const ScAiT_srt+232;
 },
 _ccASZ() //  [R1]
         { []
         }
     {offset
       ccASZ: // global
           _scAgh::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto ccATc; else goto ccATl;
       ccATc: // global
           if (%MO_S_Gt_W64(_scAgh::I64, 0)) goto ccATk; else goto ccAT9;
       ccAT9: // global
           R2 = _scAgh::I64;
           Sp = Sp + 16;
           call GHC.ByteOrder.$fEnumByteOrder_go1_entry(R2) args: 8, res: 0, upd: 8;
       ccATl: // global
           if (%MO_S_Gt_W64(_scAgh::I64, 1)) goto ccATk; else goto ccATj;
       ccATk: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccATj: // global
           R2 = _scAgh::I64;
           Sp = Sp + 16;
           call GHC.ByteOrder.$fEnumByteOrder_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccASZ_info" {
     block_ccASZ_info:
         const _ccASZ;
         const 65;
         const 12884901918;
         const ScAiT_srt+232;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.0506796 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_info;
         const 0;
 },
 sat_scAgI_entry() //  [R1]
         { []
         }
     {offset
       ccAUD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAUE; else goto ccAUF;
       ccAUE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAUF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scAgB_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAgI_info" {
     sat_scAgI_info:
         const sat_scAgI_entry;
         const 8589934593;
         const 4294967311;
         const ScAiT_srt+184;
 },
 sat_scAgG_entry() //  [R1]
         { []
         }
     {offset
       ccAUP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAUQ; else goto ccAUY;
       ccAUQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAUY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgC::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgC::I64, 0)) goto ccAUW; else goto ccAUO;
       ccAUO: // global
           if (%MO_S_Gt_W64(_scAgC::I64, 1)) goto ccAUW; else goto ccAUX;
       ccAUW: // global
           R2 = _scAgC::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAUX: // global
           R1 = I64[(_scAgC::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAgG_info" {
     sat_scAgG_info:
         const sat_scAgG_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+184;
 },
 sat_scAgL_entry() //  [R1]
         { []
         }
     {offset
       ccAV9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAVa; else goto ccAVi;
       ccAVa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAVi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgC::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgC::I64, 0)) goto ccAVg; else goto ccAV8;
       ccAV8: // global
           if (%MO_S_Gt_W64(_scAgC::I64, 1)) goto ccAVg; else goto ccAVh;
       ccAVg: // global
           R2 = _scAgC::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAVh: // global
           R1 = I64[(_scAgC::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAgL_info" {
     sat_scAgL_info:
         const sat_scAgL_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+184;
 },
 go_dn_scAgB_entry() //  [R1, R2]
         { []
         }
     {offset
       ccAVm: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccAVq; else goto ccAVp;
       ccAVq: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAVp: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto ccAVk; else goto ccAVl;
       ccAVk: // global
           _scAgz::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scAgI_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scAgz::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAgG_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAVl: // global
           I64[Hp - 80] = sat_scAgL_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccAVs::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccAVs::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_scAgB_info" {
     go_dn_scAgB_info:
         const go_dn_scAgB_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const ScAiT_srt+184;
 },
 sat_scAgM_entry() //  [R1]
         { []
         }
     {offset
       ccAVt: // global
           _scAgM::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccAVu; else goto ccAVv;
       ccAVv: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccAVx; else goto ccAVw;
       ccAVx: // global
           HpAlloc = 24;
           goto ccAVu;
       ccAVu: // global
           R1 = _scAgM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAVw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scAgM::P64;
           _scAgs::I64 = I64[_scAgM::P64 + 24];
           _scAgz::I64 = _scAgs::I64 - I64[_scAgM::P64 + 16];
           I64[Hp - 16] = go_dn_scAgB_info;
           I64[Hp - 8] = _scAgz::I64;
           I64[Hp] = 0 - _scAgz::I64;
           R2 = _scAgs::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scAgB_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAgM_info" {
     sat_scAgM_info:
         const sat_scAgM_entry;
         const 8589934592;
         const 4294967316;
         const ScAiT_srt+184;
 },
 sat_scAgy_entry() //  [R1]
         { []
         }
     {offset
       ccAVH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAVI; else goto ccAVQ;
       ccAVI: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAVQ: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgq::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgq::I64, 0)) goto ccAVO; else goto ccAVG;
       ccAVG: // global
           if (%MO_S_Gt_W64(_scAgq::I64, 1)) goto ccAVO; else goto ccAVP;
       ccAVO: // global
           R2 = _scAgq::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAVP: // global
           R1 = I64[(_scAgq::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAgy_info" {
     sat_scAgy_info:
         const sat_scAgy_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+184;
 },
 sat_scAgQ_entry() //  [R1]
         { []
         }
     {offset
       ccAW4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAW5; else goto ccAWd;
       ccAW5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAWd: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgq::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgq::I64, 0)) goto ccAWb; else goto ccAW3;
       ccAW3: // global
           if (%MO_S_Gt_W64(_scAgq::I64, 1)) goto ccAWb; else goto ccAWc;
       ccAWb: // global
           R2 = _scAgq::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAWc: // global
           R1 = I64[(_scAgq::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAgQ_info" {
     sat_scAgQ_info:
         const sat_scAgQ_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+184;
 },
 sat_scAh4_entry() //  [R1]
         { []
         }
     {offset
       ccAWG: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAWH; else goto ccAWI;
       ccAWH: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAWI: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scAgX_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAh4_info" {
     sat_scAh4_info:
         const sat_scAh4_entry;
         const 8589934593;
         const 4294967311;
         const ScAiT_srt+184;
 },
 sat_scAh2_entry() //  [R1]
         { []
         }
     {offset
       ccAWS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAWT; else goto ccAX1;
       ccAWT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAX1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgY::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgY::I64, 0)) goto ccAWZ; else goto ccAWR;
       ccAWR: // global
           if (%MO_S_Gt_W64(_scAgY::I64, 1)) goto ccAWZ; else goto ccAX0;
       ccAWZ: // global
           R2 = _scAgY::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAX0: // global
           R1 = I64[(_scAgY::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAh2_info" {
     sat_scAh2_info:
         const sat_scAh2_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+184;
 },
 sat_scAh7_entry() //  [R1]
         { []
         }
     {offset
       ccAXc: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAXd; else goto ccAXl;
       ccAXd: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAXl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgY::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgY::I64, 0)) goto ccAXj; else goto ccAXb;
       ccAXb: // global
           if (%MO_S_Gt_W64(_scAgY::I64, 1)) goto ccAXj; else goto ccAXk;
       ccAXj: // global
           R2 = _scAgY::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAXk: // global
           R1 = I64[(_scAgY::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAh7_info" {
     sat_scAh7_info:
         const sat_scAh7_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+184;
 },
 go_up_scAgX_entry() //  [R1, R2]
         { []
         }
     {offset
       ccAXp: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccAXt; else goto ccAXs;
       ccAXt: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAXs: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto ccAXn; else goto ccAXo;
       ccAXn: // global
           _scAgV::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scAh4_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scAgV::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAh2_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAXo: // global
           I64[Hp - 80] = sat_scAh7_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccAXv::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccAXv::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_scAgX_info" {
     go_up_scAgX_info:
         const go_up_scAgX_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const ScAiT_srt+184;
 },
 sat_scAh8_entry() //  [R1]
         { []
         }
     {offset
       ccAXw: // global
           _scAh8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccAXx; else goto ccAXy;
       ccAXy: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccAXA; else goto ccAXz;
       ccAXA: // global
           HpAlloc = 24;
           goto ccAXx;
       ccAXx: // global
           R1 = _scAh8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAXz: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scAh8::P64;
           _scAgs::I64 = I64[_scAh8::P64 + 24];
           _scAgV::I64 = _scAgs::I64 - I64[_scAh8::P64 + 16];
           I64[Hp - 16] = go_up_scAgX_info;
           I64[Hp - 8] = _scAgV::I64;
           I64[Hp] = 0 - _scAgV::I64;
           R2 = _scAgs::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scAgX_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAh8_info" {
     sat_scAh8_info:
         const sat_scAh8_entry;
         const 8589934592;
         const 4294967316;
         const ScAiT_srt+184;
 },
 sat_scAgU_entry() //  [R1]
         { []
         }
     {offset
       ccAXK: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAXL; else goto ccAXT;
       ccAXL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAXT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgq::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgq::I64, 0)) goto ccAXR; else goto ccAXJ;
       ccAXJ: // global
           if (%MO_S_Gt_W64(_scAgq::I64, 1)) goto ccAXR; else goto ccAXS;
       ccAXR: // global
           R2 = _scAgq::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAXS: // global
           R1 = I64[(_scAgq::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAgU_info" {
     sat_scAgU_info:
         const sat_scAgU_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+184;
 },
 sat_scAhc_entry() //  [R1]
         { []
         }
     {offset
       ccAY7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAY8; else goto ccAYg;
       ccAY8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAYg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgq::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgq::I64, 0)) goto ccAYe; else goto ccAY6;
       ccAY6: // global
           if (%MO_S_Gt_W64(_scAgq::I64, 1)) goto ccAYe; else goto ccAYf;
       ccAYe: // global
           R2 = _scAgq::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAYf: // global
           R1 = I64[(_scAgq::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAhc_info" {
     sat_scAhc_info:
         const sat_scAhc_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+184;
 },
 sat_scAhr_entry() //  [R1]
         { []
         }
     {offset
       ccAYN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAYO; else goto ccAYP;
       ccAYO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAYP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_dn_scAhk_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAhr_info" {
     sat_scAhr_info:
         const sat_scAhr_entry;
         const 8589934593;
         const 4294967311;
         const ScAiT_srt+184;
 },
 sat_scAhp_entry() //  [R1]
         { []
         }
     {offset
       ccAYZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAZ0; else goto ccAZ8;
       ccAZ0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAZ8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAhl::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAhl::I64, 0)) goto ccAZ6; else goto ccAYY;
       ccAYY: // global
           if (%MO_S_Gt_W64(_scAhl::I64, 1)) goto ccAZ6; else goto ccAZ7;
       ccAZ6: // global
           R2 = _scAhl::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAZ7: // global
           R1 = I64[(_scAhl::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAhp_info" {
     sat_scAhp_info:
         const sat_scAhp_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+184;
 },
 sat_scAhu_entry() //  [R1]
         { []
         }
     {offset
       ccAZj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAZk; else goto ccAZs;
       ccAZk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAZs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAhl::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAhl::I64, 0)) goto ccAZq; else goto ccAZi;
       ccAZi: // global
           if (%MO_S_Gt_W64(_scAhl::I64, 1)) goto ccAZq; else goto ccAZr;
       ccAZq: // global
           R2 = _scAhl::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAZr: // global
           R1 = I64[(_scAhl::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAhu_info" {
     sat_scAhu_info:
         const sat_scAhu_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+184;
 },
 go_dn_scAhk_entry() //  [R1, R2]
         { []
         }
     {offset
       ccAZw: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccAZA; else goto ccAZz;
       ccAZA: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccAZz: // global
           if (%MO_S_Ge_W64(R2, I64[R1 + 15])) goto ccAZu; else goto ccAZv;
       ccAZu: // global
           _scAhi::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scAhr_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scAhi::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAhp_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccAZv: // global
           I64[Hp - 80] = sat_scAhu_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccAZC::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccAZC::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_dn_scAhk_info" {
     go_dn_scAhk_info:
         const go_dn_scAhk_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const ScAiT_srt+184;
 },
 sat_scAhv_entry() //  [R1]
         { []
         }
     {offset
       ccAZD: // global
           _scAhv::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccAZE; else goto ccAZF;
       ccAZF: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccAZH; else goto ccAZG;
       ccAZH: // global
           HpAlloc = 24;
           goto ccAZE;
       ccAZE: // global
           R1 = _scAhv::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccAZG: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scAhv::P64;
           _scAgs::I64 = I64[_scAhv::P64 + 24];
           _scAhi::I64 = _scAgs::I64 - I64[_scAhv::P64 + 16];
           I64[Hp - 16] = go_dn_scAhk_info;
           I64[Hp - 8] = _scAhi::I64;
           I64[Hp] = 1 - _scAhi::I64;
           R2 = _scAgs::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_dn_scAhk_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAhv_info" {
     sat_scAhv_info:
         const sat_scAhv_entry;
         const 8589934592;
         const 4294967316;
         const ScAiT_srt+184;
 },
 sat_scAhh_entry() //  [R1]
         { []
         }
     {offset
       ccAZR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccAZS; else goto ccB00;
       ccAZS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccB00: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgq::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgq::I64, 0)) goto ccAZY; else goto ccAZQ;
       ccAZQ: // global
           if (%MO_S_Gt_W64(_scAgq::I64, 1)) goto ccAZY; else goto ccAZZ;
       ccAZY: // global
           R2 = _scAgq::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccAZZ: // global
           R1 = I64[(_scAgq::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAhh_info" {
     sat_scAhh_info:
         const sat_scAhh_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+184;
 },
 sat_scAhz_entry() //  [R1]
         { []
         }
     {offset
       ccB0e: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccB0f; else goto ccB0n;
       ccB0f: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccB0n: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgq::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgq::I64, 0)) goto ccB0l; else goto ccB0d;
       ccB0d: // global
           if (%MO_S_Gt_W64(_scAgq::I64, 1)) goto ccB0l; else goto ccB0m;
       ccB0l: // global
           R2 = _scAgq::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccB0m: // global
           R1 = I64[(_scAgq::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAhz_info" {
     sat_scAhz_info:
         const sat_scAhz_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+184;
 },
 sat_scAhN_entry() //  [R1]
         { []
         }
     {offset
       ccB0Q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccB0R; else goto ccB0S;
       ccB0R: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccB0S: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 32] + I64[R1 + 24];
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call go_up_scAhG_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAhN_info" {
     sat_scAhN_info:
         const sat_scAhN_entry;
         const 8589934593;
         const 4294967311;
         const ScAiT_srt+184;
 },
 sat_scAhL_entry() //  [R1]
         { []
         }
     {offset
       ccB12: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccB13; else goto ccB1b;
       ccB13: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccB1b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAhH::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAhH::I64, 0)) goto ccB19; else goto ccB11;
       ccB11: // global
           if (%MO_S_Gt_W64(_scAhH::I64, 1)) goto ccB19; else goto ccB1a;
       ccB19: // global
           R2 = _scAhH::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccB1a: // global
           R1 = I64[(_scAhH::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAhL_info" {
     sat_scAhL_info:
         const sat_scAhL_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+184;
 },
 sat_scAhQ_entry() //  [R1]
         { []
         }
     {offset
       ccB1m: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccB1n; else goto ccB1v;
       ccB1n: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccB1v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAhH::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAhH::I64, 0)) goto ccB1t; else goto ccB1l;
       ccB1l: // global
           if (%MO_S_Gt_W64(_scAhH::I64, 1)) goto ccB1t; else goto ccB1u;
       ccB1t: // global
           R2 = _scAhH::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccB1u: // global
           R1 = I64[(_scAhH::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAhQ_info" {
     sat_scAhQ_info:
         const sat_scAhQ_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+184;
 },
 go_up_scAhG_entry() //  [R1, R2]
         { []
         }
     {offset
       ccB1z: // global
           Hp = Hp + 88;
           if (Hp > HpLim) (likely: False) goto ccB1D; else goto ccB1C;
       ccB1D: // global
           HpAlloc = 88;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ccB1C: // global
           if (%MO_S_Le_W64(R2, I64[R1 + 15])) goto ccB1x; else goto ccB1y;
       ccB1x: // global
           _scAhE::I64 = I64[R1 + 7];
           I64[Hp - 80] = sat_scAhN_info;
           P64[Hp - 64] = R1;
           I64[Hp - 56] = _scAhE::I64;
           I64[Hp - 48] = R2;
           I64[Hp - 40] = sat_scAhL_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccB1y: // global
           I64[Hp - 80] = sat_scAhQ_info;
           I64[Hp - 64] = R2;
           I64[Hp - 56] = :_con_info;
           P64[Hp - 48] = Hp - 80;
           P64[Hp - 40] = GHC.Types.[]_closure+1;
           _ccB1F::P64 = Hp - 54;
           Hp = Hp - 40;
           R1 = _ccB1F::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go_up_scAhG_info" {
     go_up_scAhG_info:
         const go_up_scAhG_entry;
         const 8589934592;
         const 4294967309;
         const 4294967300;
         const ScAiT_srt+184;
 },
 sat_scAhR_entry() //  [R1]
         { []
         }
     {offset
       ccB1G: // global
           _scAhR::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto ccB1H; else goto ccB1I;
       ccB1I: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto ccB1K; else goto ccB1J;
       ccB1K: // global
           HpAlloc = 24;
           goto ccB1H;
       ccB1H: // global
           R1 = _scAhR::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccB1J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _scAhR::P64;
           _scAgs::I64 = I64[_scAhR::P64 + 24];
           _scAhE::I64 = _scAgs::I64 - I64[_scAhR::P64 + 16];
           I64[Hp - 16] = go_up_scAhG_info;
           I64[Hp - 8] = _scAhE::I64;
           I64[Hp] = 1 - _scAhE::I64;
           R2 = _scAgs::I64;
           R1 = Hp - 15;
           Sp = Sp - 16;
           call go_up_scAhG_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAhR_info" {
     sat_scAhR_info:
         const sat_scAhR_entry;
         const 8589934592;
         const 4294967316;
         const ScAiT_srt+184;
 },
 sat_scAhD_entry() //  [R1]
         { []
         }
     {offset
       ccB1U: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccB1V; else goto ccB23;
       ccB1V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccB23: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgq::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgq::I64, 0)) goto ccB21; else goto ccB1T;
       ccB1T: // global
           if (%MO_S_Gt_W64(_scAgq::I64, 1)) goto ccB21; else goto ccB22;
       ccB21: // global
           R2 = _scAgq::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccB22: // global
           R1 = I64[(_scAgq::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAhD_info" {
     sat_scAhD_info:
         const sat_scAhD_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+184;
 },
 sat_scAhV_entry() //  [R1]
         { []
         }
     {offset
       ccB2h: // global
           if ((Sp + -16) < SpLim) (likely: False) goto ccB2i; else goto ccB2q;
       ccB2i: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ccB2q: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           _scAgq::I64 = I64[R1 + 16];
           if (%MO_S_Lt_W64(_scAgq::I64, 0)) goto ccB2o; else goto ccB2g;
       ccB2g: // global
           if (%MO_S_Gt_W64(_scAgq::I64, 1)) goto ccB2o; else goto ccB2p;
       ccB2o: // global
           R2 = _scAgq::I64;
           Sp = Sp - 16;
           call GHC.ByteOrder.$wlvl_entry(R2) args: 24, res: 0, upd: 24;
       ccB2p: // global
           R1 = I64[(_scAgq::I64 << 3) + GHC.ByteOrder.ByteOrder_closure_tbl];
           Sp = Sp - 16;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_scAhV_info" {
     sat_scAhV_info:
         const sat_scAhV_entry;
         const 4294967296;
         const 4294967313;
         const ScAiT_srt+184;
 },
 GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_entry() //  [R2, R3,
                                                             R4]
         { []
         }
     {offset
       ccB2y: // global
           if ((Sp + -24) < SpLim) (likely: False) goto ccB2z; else goto ccB2A;
       ccB2z: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ccB2A: // global
           I64[Sp - 24] = block_ccB2r_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ucB3J; else goto ccB2s;
       ucB3J: // global
           call _ccB2r(R1) args: 0, res: 0, upd: 0;
       ccB2s: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_info" {
     GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_info:
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_entry;
         const 0;
         const 2203318222862;
         const 12884901911;
         const ScAiT_srt+184;
 },
 _ccB2r() //  [R1]
         { []
         }
     {offset
       ccB2r: // global
           _scAgn::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto ccB2v; else goto ccB2w;
       ccB2v: // global
           _scAgq::I64 = 0;
           goto scAgp;
       ccB2w: // global
           _scAgq::I64 = 1;
           goto scAgp;
       scAgp: // global
           I64[Sp] = block_ccB2B_info;
           R1 = _scAgn::P64;
           I64[Sp + 8] = _scAgq::I64;
           if (R1 & 7 != 0) goto ucB3I; else goto ccB3p;
       ucB3I: // global
           call _ccB2B(R1) args: 0, res: 0, upd: 0;
       ccB3p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccB2r_info" {
     block_ccB2r_info:
         const _ccB2r;
         const 2;
         const 4294967326;
         const ScAiT_srt+184;
 },
 _ccB2B() //  [R1]
         { []
         }
     {offset
       ccB2B: // global
           _scAgo::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto ccB3v; else goto ccB3z;
       ccB3v: // global
           _scAgs::I64 = 0;
           goto scAgr;
       ccB3z: // global
           _scAgs::I64 = 1;
           goto scAgr;
       scAgr: // global
           I64[Sp] = block_ccAU4_info;
           R1 = _scAgo::P64;
           I64[Sp + 16] = _scAgs::I64;
           if (R1 & 7 != 0) goto ucB3K; else goto ccAU5;
       ucB3K: // global
           call _ccAU4(R1) args: 0, res: 0, upd: 0;
       ccAU5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_ccB2B_info" {
     block_ccB2B_info:
         const _ccB2B;
         const 66;
         const 4294967326;
         const ScAiT_srt+184;
 },
 _ccAU4() //  [R1]
         { []
         }
     {offset
       ccAU4: // global
           _scAgq::I64 = I64[Sp + 8];
           _scAgs::I64 = I64[Sp + 16];
           if (R1 & 7 == 1) goto ccB2F; else goto ccB32;
       ccB2F: // global
           Hp = Hp + 80;
           _scAgt::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccB35; else goto ccB2H;
       ccB2H: // global
           if (%MO_S_Lt_W64(_scAgs::I64,
                            _scAgq::I64)) goto ccB2S; else goto ccB31;
       ccB2S: // global
           if (%MO_S_Le_W64(0, _scAgs::I64)) goto ccB2L; else goto ccB2Q;
       ccB2L: // global
           I64[Hp - 72] = sat_scAgM_info;
           I64[Hp - 56] = _scAgq::I64;
           I64[Hp - 48] = _scAgs::I64;
           I64[Hp - 40] = sat_scAgy_info;
           I64[Hp - 24] = _scAgq::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccB2Q: // global
           if (%MO_S_Gt_W64(0, _scAgq::I64)) goto ccB3m; else goto ccB2O;
       ccB2O: // global
           I64[Hp - 72] = sat_scAgQ_info;
           I64[Hp - 56] = _scAgq::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccB2M::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccB2M::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccB31: // global
           if (%MO_S_Ge_W64(0, _scAgs::I64)) goto ccB2V; else goto ccB30;
       ccB2V: // global
           I64[Hp - 72] = sat_scAh8_info;
           I64[Hp - 56] = _scAgq::I64;
           I64[Hp - 48] = _scAgs::I64;
           I64[Hp - 40] = sat_scAgU_info;
           I64[Hp - 24] = _scAgq::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccB30: // global
           if (%MO_S_Lt_W64(0, _scAgq::I64)) goto ccB3m; else goto ccB2Y;
       ccB2Y: // global
           I64[Hp - 72] = sat_scAhc_info;
           I64[Hp - 56] = _scAgq::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccB2W::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccB2W::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccB32: // global
           Hp = Hp + 80;
           _scAgt::P64 = R1;
           if (Hp > HpLim) (likely: False) goto ccB35; else goto ccB34;
       ccB35: // global
           HpAlloc = 80;
           R1 = _scAgt::P64;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       ccB34: // global
           if (%MO_S_Lt_W64(_scAgs::I64,
                            _scAgq::I64)) goto ccB3f; else goto ccB3o;
       ccB3f: // global
           if (%MO_S_Le_W64(1, _scAgs::I64)) goto ccB38; else goto ccB3d;
       ccB38: // global
           I64[Hp - 72] = sat_scAhv_info;
           I64[Hp - 56] = _scAgq::I64;
           I64[Hp - 48] = _scAgs::I64;
           I64[Hp - 40] = sat_scAhh_info;
           I64[Hp - 24] = _scAgq::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccB3d: // global
           if (%MO_S_Gt_W64(1, _scAgq::I64)) goto ccB3m; else goto ccB3b;
       ccB3b: // global
           I64[Hp - 72] = sat_scAhz_info;
           I64[Hp - 56] = _scAgq::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccB39::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccB39::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccB3o: // global
           if (%MO_S_Ge_W64(1, _scAgs::I64)) goto ccB3i; else goto ccB3n;
       ccB3i: // global
           I64[Hp - 72] = sat_scAhR_info;
           I64[Hp - 56] = _scAgq::I64;
           I64[Hp - 48] = _scAgs::I64;
           I64[Hp - 40] = sat_scAhD_info;
           I64[Hp - 24] = _scAgq::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccB3n: // global
           if (%MO_S_Lt_W64(1, _scAgq::I64)) goto ccB3m; else goto ccB3l;
       ccB3m: // global
           Hp = Hp - 80;
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       ccB3l: // global
           I64[Hp - 72] = sat_scAhV_info;
           I64[Hp - 56] = _scAgq::I64;
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = Hp - 72;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _ccB3j::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _ccB3j::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_ccAU4_info" {
     block_ccAU4_info:
         const _ccAU4;
         const 194;
         const 4294967326;
         const ScAiT_srt+184;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.115520329 UTC

[section ""data" . GHC.ByteOrder.$fEnumByteOrder_closure" {
     GHC.ByteOrder.$fEnumByteOrder_closure:
         const GHC.Enum.C:Enum_con_info;
         const GHC.ByteOrder.$fEnumByteOrder_$csucc_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cpred_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cfromEnum_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure+1;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThen_closure+2;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure+2;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure+3;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.117746888 UTC

[section ""data" . GHC.ByteOrder.$trModule3_closure" {
     GHC.ByteOrder.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.119398412 UTC

[section ""data" . GHC.ByteOrder.$trModule1_closure" {
     GHC.ByteOrder.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.121112807 UTC

[section ""data" . GHC.ByteOrder.$trModule_closure" {
     GHC.ByteOrder.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.ByteOrder.$trModule3_closure+1;
         const GHC.ByteOrder.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.123470844 UTC

[section ""cstring" . GHC.ByteOrder.$tcByteOrder2_bytes" {
     GHC.ByteOrder.$tcByteOrder2_bytes:
         I8[] [66,121,116,101,79,114,100,101,114]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.125107982 UTC

[section ""data" . GHC.ByteOrder.$tcByteOrder1_closure" {
     GHC.ByteOrder.$tcByteOrder1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$tcByteOrder2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.12711144 UTC

[section ""data" . GHC.ByteOrder.$tcByteOrder_closure" {
     GHC.ByteOrder.$tcByteOrder_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.ByteOrder.$trModule_closure+1;
         const GHC.ByteOrder.$tcByteOrder1_closure+1;
         const GHC.Types.krep$*_closure;
         const 16811050684449662084;
         const 17273005335247024091;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.128843175 UTC

[section ""data" . GHC.ByteOrder.$tc'BigEndian1_closure" {
     GHC.ByteOrder.$tc'BigEndian1_closure:
         const GHC.Types.KindRepTyConApp_con_info;
         const GHC.ByteOrder.$tcByteOrder_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.13050971 UTC

[section ""cstring" . GHC.ByteOrder.$tc'BigEndian3_bytes" {
     GHC.ByteOrder.$tc'BigEndian3_bytes:
         I8[] [39,66,105,103,69,110,100,105,97,110]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.132189587 UTC

[section ""data" . GHC.ByteOrder.$tc'BigEndian2_closure" {
     GHC.ByteOrder.$tc'BigEndian2_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$tc'BigEndian3_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.133962755 UTC

[section ""data" . GHC.ByteOrder.$tc'BigEndian_closure" {
     GHC.ByteOrder.$tc'BigEndian_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.ByteOrder.$trModule_closure+1;
         const GHC.ByteOrder.$tc'BigEndian2_closure+1;
         const GHC.ByteOrder.$tc'BigEndian1_closure+1;
         const 2645192688778293591;
         const 7455668807059762078;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.135649748 UTC

[section ""cstring" . GHC.ByteOrder.$tc'LittleEndian2_bytes" {
     GHC.ByteOrder.$tc'LittleEndian2_bytes:
         I8[] [39,76,105,116,116,108,101,69,110,100,105,97,110]
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.137276913 UTC

[section ""data" . GHC.ByteOrder.$tc'LittleEndian1_closure" {
     GHC.ByteOrder.$tc'LittleEndian1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.ByteOrder.$tc'LittleEndian2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.139092808 UTC

[section ""data" . GHC.ByteOrder.$tc'LittleEndian_closure" {
     GHC.ByteOrder.$tc'LittleEndian_closure:
         const GHC.Types.TyCon_con_info;
         const GHC.ByteOrder.$trModule_closure+1;
         const GHC.ByteOrder.$tc'LittleEndian1_closure+1;
         const GHC.ByteOrder.$tc'BigEndian1_closure+1;
         const 8702700204875460152;
         const 10337679016369298147;
         const 0;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.140849252 UTC

[section ""data" . GHC.ByteOrder.BigEndian_closure" {
     GHC.ByteOrder.BigEndian_closure:
         const GHC.ByteOrder.BigEndian_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.142777343 UTC

[section ""data" . GHC.ByteOrder.LittleEndian_closure" {
     GHC.ByteOrder.LittleEndian_closure:
         const GHC.ByteOrder.LittleEndian_con_info;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.144378335 UTC

[section ""relreadonly" . GHC.ByteOrder.ByteOrder_closure_tbl" {
     GHC.ByteOrder.ByteOrder_closure_tbl:
         const GHC.ByteOrder.BigEndian_closure+1;
         const GHC.ByteOrder.LittleEndian_closure+2;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.146378334 UTC

[section ""cstring" . icB9l_str" {
     icB9l_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,121,116,101,79,114,100,101,114,46,66,105,103,69,110,100,105,97,110]
 },
 GHC.ByteOrder.BigEndian_con_entry() //  [R1]
         { []
         }
     {offset
       ccB9k: // global
           R1 = R1 + 1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.BigEndian_con_info" {
     GHC.ByteOrder.BigEndian_con_info:
         const GHC.ByteOrder.BigEndian_con_entry;
         const 4294967296;
         const 3;
         const icB9l_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.150127103 UTC

[section ""cstring" . icB9s_str" {
     icB9s_str:
         I8[] [98,97,115,101,58,71,72,67,46,66,121,116,101,79,114,100,101,114,46,76,105,116,116,108,101,69,110,100,105,97,110]
 },
 GHC.ByteOrder.LittleEndian_con_entry() //  [R1]
         { []
         }
     {offset
       ccB9r: // global
           R1 = R1 + 2;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.ByteOrder.LittleEndian_con_info" {
     GHC.ByteOrder.LittleEndian_con_info:
         const GHC.ByteOrder.LittleEndian_con_entry;
         const 4294967296;
         const 4294967299;
         const icB9s_str;
 }]


==================== Raw Cmm ====================
2018-03-16 16:07:30.153847736 UTC

[section ""relreadonly" . ScAiT_srt" {
     ScAiT_srt:
         const GHC.ByteOrder.$fReadByteOrder6_closure;
         const GHC.ByteOrder.$fReadByteOrder10_closure;
         const GHC.ByteOrder.$fShowByteOrder_$cshowsPrec_closure;
         const GHC.ByteOrder.$fShowByteOrder_$cshow_closure;
         const GHC.ByteOrder.$fShowByteOrder1_closure;
         const GHC.Read.choose2_closure;
         const GHC.ByteOrder.$fReadByteOrder_sps_closure;
         const GHC.Read.list3_closure;
         const GHC.ByteOrder.$fReadByteOrder2_closure;
         const GHC.ByteOrder.$fReadByteOrder_$creadsPrec_closure;
         const GHC.Read.list_closure;
         const GHC.ByteOrder.$fReadByteOrder1_closure;
         const GHC.ByteOrder.$fReadByteOrder_$creadListPrec_closure;
         const GHC.ByteOrder.$fReadByteOrder12_closure;
         const GHC.Err.error_closure;
         const lvl12_rcykz_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cpred_closure;
         const GHC.ByteOrder.$fEnumByteOrder3_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$csucc_closure;
         const GHC.ByteOrder.$fEnumByteOrder4_closure;
         const lvl17_rcykE_closure;
         const lvl18_rcykF_closure;
         const lvl19_rcykG_closure;
         const GHC.ByteOrder.$wlvl_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$ctoEnum_closure;
         const GHC.ByteOrder.$w$ctoEnum_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFrom_closure;
         const GHC.ByteOrder.$fEnumByteOrder1_closure;
         const GHC.ByteOrder.$fEnumByteOrder2_closure;
         const GHC.ByteOrder.$fEnumByteOrder_go1_closure;
         const GHC.ByteOrder.$fEnumByteOrder_go_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromTo_closure;
         const GHC.ByteOrder.$fEnumByteOrder_$cenumFromThenTo_closure;
 }]

