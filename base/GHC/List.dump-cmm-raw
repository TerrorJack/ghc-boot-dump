
==================== Raw Cmm ====================
2018-03-16 15:55:06.80586402 UTC

[]


==================== Raw Cmm ====================
2018-03-16 15:55:06.808171228 UTC

[section ""data" . $wunsafeDrop_ru8P_closure" {
     $wunsafeDrop_ru8P_closure:
         const $wunsafeDrop_ru8P_info;
 },
 $wunsafeDrop_ru8P_entry() //  [R2, R3]
         { []
         }
     {offset
       cw39: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cw3a; else goto uw3o;
       cw3a: // global
           R3 = R3;
           R2 = R2;
           R1 = $wunsafeDrop_ru8P_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uw3o: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cw2Z() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . $wunsafeDrop_ru8P_info" {
     $wunsafeDrop_ru8P_info:
         const $wunsafeDrop_ru8P_entry;
         const 0;
         const 14;
         const 8589934605;
 },
 _cw2Z() //  []
         { []
         }
     {offset
       cw2Z: // global
           I64[Sp - 8] = block_cw32_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uw3q; else goto cw33;
       uw3q: // global
           call _cw32(R1) args: 0, res: 0, upd: 0;
       cw33: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cw32() //  [R1]
         { []
         }
     {offset
       cw32: // global
           if (R1 & 7 == 1) goto cw36; else goto cw37;
       cw36: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cw37: // global
           _su9x::P64 = P64[R1 + 14];
           _su9y::I64 = I64[Sp + 8];
           if (_su9y::I64 != 1) goto cw3k; else goto cw3l;
       cw3k: // global
           I64[Sp + 8] = _su9y::I64 - 1;
           P64[Sp + 16] = _su9x::P64;
           Sp = Sp + 8;
           call _cw2Z() args: 0, res: 0, upd: 0;
       cw3l: // global
           R1 = _su9x::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cw32_info" {
     block_cw32_info:
         const _cw32;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.816097097 UTC

[section ""data" . GHC.List.drop_closure" {
     GHC.List.drop_closure:
         const GHC.List.drop_info;
 },
 GHC.List.drop_entry() //  [R2, R3]
         { []
         }
     {offset
       cw3R: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw3S; else goto cw3T;
       cw3S: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.drop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cw3T: // global
           I64[Sp - 16] = block_cw3O_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uw42; else goto cw3P;
       uw42: // global
           call _cw3O(R1) args: 0, res: 0, upd: 0;
       cw3P: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.drop_info" {
     GHC.List.drop_info:
         const GHC.List.drop_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cw3O() //  [R1]
         { []
         }
     {offset
       cw3O: // global
           _su9B::P64 = P64[Sp + 8];
           _su9D::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_su9D::I64, 0)) goto cw40; else goto cw41;
       cw40: // global
           R3 = _su9B::P64;
           R2 = _su9D::I64;
           Sp = Sp + 16;
           call $wunsafeDrop_ru8P_entry(R3, R2) args: 8, res: 0, upd: 8;
       cw41: // global
           R1 = _su9B::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cw3O_info" {
     block_cw3O_info:
         const _cw3O;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.823693299 UTC

[section ""data" . GHC.List.$wsplitAt'_closure" {
     GHC.List.$wsplitAt'_closure:
         const GHC.List.$wsplitAt'_info;
 },
 ds2_su9N_entry() //  [R1]
         { []
         }
     {offset
       cw4B: // global
           _su9N::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cw4H; else goto cw4I;
       cw4I: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cw4K; else goto cw4J;
       cw4K: // global
           HpAlloc = 16;
           goto cw4H;
       cw4H: // global
           R1 = _su9N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cw4J: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _su9N::P64;
           _su9J::P64 = P64[_su9N::P64 + 16];
           _su9O::I64 = I64[_su9N::P64 + 24] - 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _su9O::I64;
           I64[Sp - 24] = block_cw4E_info;
           R3 = _su9J::P64;
           R2 = Hp - 7;
           Sp = Sp - 24;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ds2_su9N_info" {
     ds2_su9N_info:
         const ds2_su9N_entry;
         const 4294967297;
         const 19;
 },
 _cw4E() //  [R1, R2]
         { []
         }
     {offset
       cw4E: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cw4N; else goto cw4M;
       cw4N: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cw4M: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cw4E_info" {
     block_cw4E_info:
         const _cw4E;
         const 0;
         const 30;
 },
 GHC.List.$wsplitAt'_entry() //  [R2, R3]
         { []
         }
     {offset
       cw4S: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cw4T; else goto cw4U;
       cw4T: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wsplitAt'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cw4U: // global
           I64[Sp - 16] = block_cw4i_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uw5a; else goto cw4j;
       uw5a: // global
           call _cw4i(R1) args: 0, res: 0, upd: 0;
       cw4j: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.$wsplitAt'_info" {
     GHC.List.$wsplitAt'_info:
         const GHC.List.$wsplitAt'_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cw4i() //  [R1]
         { []
         }
     {offset
       cw4i: // global
           if (R1 & 7 == 1) goto cw4P; else goto cw4Q;
       cw4P: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cw4Q: // global
           I64[Sp - 8] = block_cw4o_info;
           _su9I::P64 = P64[R1 + 6];
           _su9J::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _su9J::P64;
           P64[Sp + 8] = _su9I::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uw59; else goto cw4p;
       uw59: // global
           call _cw4o(R1) args: 0, res: 0, upd: 0;
       cw4p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cw4i_info" {
     block_cw4i_info:
         const _cw4i;
         const 1;
         const 30;
 },
 _cw4o() //  [R1]
         { []
         }
     {offset
       cw4o: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cw50; else goto cw4Z;
       cw50: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cw4Z: // global
           _su9I::P64 = P64[Sp + 16];
           _su9J::P64 = P64[Sp + 8];
           _su9M::I64 = I64[R1 + 7];
           if (_su9M::I64 != 1) goto cw55; else goto cw58;
       cw55: // global
           I64[Hp - 96] = ds2_su9N_info;
           P64[Hp - 80] = _su9J::P64;
           I64[Hp - 72] = _su9M::I64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cw4v::P64 = Hp - 96;
           P64[Hp - 48] = _cw4v::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cw4v::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _su9I::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cw58: // global
           I64[Hp - 96] = :_con_info;
           P64[Hp - 88] = _su9I::P64;
           P64[Hp - 80] = GHC.Types.[]_closure+1;
           _cw57::P64 = Hp - 94;
           Hp = Hp - 80;
           R2 = _su9J::P64;
           R1 = _cw57::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cw4o_info" {
     block_cw4o_info:
         const _cw4o;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.835989353 UTC

[section ""data" . GHC.List.splitAt_splitAt'_closure" {
     GHC.List.splitAt_splitAt'_closure:
         const GHC.List.splitAt_splitAt'_info;
 },
 GHC.List.splitAt_splitAt'_entry() //  [R2, R3]
         { []
         }
     {offset
       cw5K: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cw5L; else goto cw5M;
       cw5L: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.splitAt_splitAt'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cw5M: // global
           I64[Sp - 8] = block_cw5H_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.splitAt_splitAt'_info" {
     GHC.List.splitAt_splitAt'_info:
         const GHC.List.splitAt_splitAt'_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cw5H() //  [R1, R2]
         { []
         }
     {offset
       cw5H: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cw5P; else goto cw5O;
       cw5P: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cw5O: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cw5H_info" {
     block_cw5H_info:
         const _cw5H;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.842921969 UTC

[section ""data" . GHC.List.splitAt_closure" {
     GHC.List.splitAt_closure:
         const GHC.List.splitAt_info;
 },
 GHC.List.splitAt_entry() //  [R2, R3]
         { []
         }
     {offset
       cw66: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw67; else goto cw68;
       cw67: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.splitAt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cw68: // global
           I64[Sp - 16] = block_cw63_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uw6s; else goto cw64;
       uw6s: // global
           call _cw63(R1) args: 0, res: 0, upd: 0;
       cw64: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.splitAt_info" {
     GHC.List.splitAt_info:
         const GHC.List.splitAt_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cw63() //  [R1]
         { []
         }
     {offset
       cw63: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cw6d; else goto cw6c;
       cw6d: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cw6c: // global
           _sua9::P64 = P64[Sp + 8];
           if (%MO_S_Gt_W64(I64[R1 + 7], 0)) goto cw6l; else goto cw6r;
       cw6l: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_cw6h_info;
           R3 = _sua9::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 8;
       cw6r: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = _sua9::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cw63_info" {
     block_cw63_info:
         const _cw63;
         const 1;
         const 30;
 },
 _cw6h() //  [R1, R2]
         { []
         }
     {offset
       cw6h: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cw6o; else goto cw6n;
       cw6o: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cw6n: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cw6h_info" {
     block_cw6h_info:
         const _cw6h;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.84970798 UTC

[section ""cstring" . GHC.List.$trModule4_bytes" {
     GHC.List.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.851365703 UTC

[section ""data" . GHC.List.$trModule3_closure" {
     GHC.List.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.List.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.853411193 UTC

[section ""cstring" . GHC.List.$trModule2_bytes" {
     GHC.List.$trModule2_bytes:
         I8[] [71,72,67,46,76,105,115,116]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.854954675 UTC

[section ""data" . GHC.List.$trModule1_closure" {
     GHC.List.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.List.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.856583733 UTC

[section ""data" . GHC.List.$trModule_closure" {
     GHC.List.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.List.$trModule3_closure+1;
         const GHC.List.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.860159888 UTC

[section ""data" . GHC.List.init1_closure" {
     GHC.List.init1_closure:
         const GHC.List.init1_info;
 },
 sat_sual_entry() //  [R1]
         { []
         }
     {offset
       cw70: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw71; else goto cw72;
       cw71: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cw72: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.init1_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sual_info" {
     sat_sual_info:
         const sat_sual_entry;
         const 2;
         const 18;
 },
 GHC.List.init1_entry() //  [R2, R3]
         { []
         }
     {offset
       cw77: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw78; else goto cw79;
       cw78: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.init1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cw79: // global
           I64[Sp - 16] = block_cw6Q_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uw7g; else goto cw6R;
       uw7g: // global
           call _cw6Q(R1) args: 0, res: 0, upd: 0;
       cw6R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.init1_info" {
     GHC.List.init1_info:
         const GHC.List.init1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cw6Q() //  [R1]
         { []
         }
     {offset
       cw6Q: // global
           if (R1 & 7 == 1) goto cw74; else goto cw75;
       cw74: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cw75: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cw7f; else goto cw7e;
       cw7f: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cw7e: // global
           _suaj::P64 = P64[R1 + 6];
           _suak::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_sual_info;
           P64[Hp - 32] = _suaj::P64;
           P64[Hp - 24] = _suak::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cw6Q_info" {
     block_cw6Q_info:
         const _cw6Q;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.867363395 UTC

[section ""cstring" . lvl_ru8Q_bytes" {
     lvl_ru8Q_bytes:
         I8[] [58,32,101,109,112,116,121,32,108,105,115,116]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.870562785 UTC

[section ""data" . lvl1_ru8R_closure" {
     lvl1_ru8R_closure:
         const lvl1_ru8R_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_ru8R_entry() //  [R1]
         { []
         }
     {offset
       cw7H: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw7I; else goto cw7J;
       cw7I: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cw7J: // global
           (_cw7E::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cw7E::I64 == 0) goto cw7G; else goto cw7F;
       cw7G: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cw7F: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cw7E::I64;
           R2 = lvl_ru8Q_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl1_ru8R_info" {
     lvl1_ru8R_info:
         const lvl1_ru8R_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.873977245 UTC

[section ""cstring" . GHC.List.!!4_bytes" {
     GHC.List.!!4_bytes:
         I8[] [80,114,101,108,117,100,101,46]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.876110578 UTC

[section ""data" . GHC.List.prel_list_str_closure" {
     GHC.List.prel_list_str_closure:
         const GHC.List.prel_list_str_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.prel_list_str_entry() //  [R1]
         { []
         }
     {offset
       cw7Y: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw7Z; else goto cw80;
       cw7Z: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cw80: // global
           (_cw7V::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cw7V::I64 == 0) goto cw7X; else goto cw7W;
       cw7X: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cw7W: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cw7V::I64;
           R2 = GHC.List.!!4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.prel_list_str_info" {
     GHC.List.prel_list_str_info:
         const GHC.List.prel_list_str_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.881570744 UTC

[section ""data" . GHC.List.errorEmptyList_closure" {
     GHC.List.errorEmptyList_closure:
         const GHC.List.errorEmptyList_info;
         const 0;
 },
 sat_suan_entry() //  [R1]
         { []
         }
     {offset
       cw8g: // global
           R3 = lvl1_ru8R_closure;
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_suan_info" {
     sat_suan_info:
         const sat_suan_entry;
         const 1;
         const 4294967312;
         const Supf_srt;
 },
 GHC.List.errorEmptyList_entry() //  [R2]
         { []
         }
     {offset
       cw8l: // global
           _suam::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cw8m; else goto cw8n;
       cw8n: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cw8p; else goto cw8o;
       cw8p: // global
           HpAlloc = 24;
           goto cw8m;
       cw8m: // global
           R2 = _suam::P64;
           R1 = GHC.List.errorEmptyList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cw8o: // global
           I64[Hp - 16] = sat_suan_info;
           P64[Hp] = _suam::P64;
           I64[Sp - 8] = block_cw8j_info;
           R3 = Hp - 16;
           R2 = GHC.List.prel_list_str_closure;
           Sp = Sp - 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.errorEmptyList_info" {
     GHC.List.errorEmptyList_info:
         const GHC.List.errorEmptyList_entry;
         const 0;
         const 64424509454;
         const 4294967301;
         const Supf_srt;
 },
 _cw8j() //  [R1]
         { []
         }
     {offset
       cw8j: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cw8j_info" {
     block_cw8j_info:
         const _cw8j;
         const 0;
         const 4294967326;
         const Supf_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.887543078 UTC

[section ""cstring" . lvl2_ru8S_bytes" {
     lvl2_ru8S_bytes:
         I8[] [33,33,58,32,110,101,103,97,116,105,118,101,32,105,110,100,101,120]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.889882237 UTC

[section ""data" . lvl3_ru8T_closure" {
     lvl3_ru8T_closure:
         const lvl3_ru8T_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_ru8T_entry() //  [R1]
         { []
         }
     {offset
       cw8L: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw8M; else goto cw8N;
       cw8M: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cw8N: // global
           (_cw8I::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cw8I::I64 == 0) goto cw8K; else goto cw8J;
       cw8K: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cw8J: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cw8I::I64;
           R2 = lvl2_ru8S_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl3_ru8T_info" {
     lvl3_ru8T_info:
         const lvl3_ru8T_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.894695606 UTC

[section ""data" . GHC.List.negIndex_closure" {
     GHC.List.negIndex_closure:
         const GHC.List.negIndex_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.negIndex_entry() //  [R1]
         { []
         }
     {offset
       cw93: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cw94; else goto cw95;
       cw94: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cw95: // global
           (_cw8Y::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cw8Y::I64 == 0) goto cw90; else goto cw8Z;
       cw90: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cw8Z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cw8Y::I64;
           I64[Sp - 24] = block_cw91_info;
           R3 = lvl3_ru8T_closure;
           R2 = GHC.List.prel_list_str_closure;
           Sp = Sp - 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.negIndex_info" {
     GHC.List.negIndex_info:
         const GHC.List.negIndex_entry;
         const 0;
         const 55834574869;
         const Supf_srt+8;
 },
 _cw91() //  [R1]
         { []
         }
     {offset
       cw91: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cw91_info" {
     block_cw91_info:
         const _cw91;
         const 0;
         const 4294967326;
         const Supf_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.899534013 UTC

[section ""cstring" . GHC.List.!!3_bytes" {
     GHC.List.!!3_bytes:
         I8[] [33,33,58,32,105,110,100,101,120,32,116,111,111,32,108,97,114,103,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.90188169 UTC

[section ""data" . GHC.List.!!2_closure" {
     GHC.List.!!2_closure:
         const GHC.List.!!2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.!!2_entry() //  [R1]
         { []
         }
     {offset
       cw9q: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw9r; else goto cw9s;
       cw9r: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cw9s: // global
           (_cw9n::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cw9n::I64 == 0) goto cw9p; else goto cw9o;
       cw9p: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cw9o: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cw9n::I64;
           R2 = GHC.List.!!3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.!!2_info" {
     GHC.List.!!2_info:
         const GHC.List.!!2_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.906605772 UTC

[section ""data" . GHC.List.!!1_closure" {
     GHC.List.!!1_closure:
         const GHC.List.!!1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.!!1_entry() //  [R1]
         { []
         }
     {offset
       cw9G: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cw9H; else goto cw9I;
       cw9H: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cw9I: // global
           (_cw9D::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cw9D::I64 == 0) goto cw9F; else goto cw9E;
       cw9F: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cw9E: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cw9D::I64;
           R3 = GHC.List.!!2_closure;
           R2 = GHC.List.prel_list_str_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.!!1_info" {
     GHC.List.!!1_info:
         const GHC.List.!!1_entry;
         const 0;
         const 21474836501;
         const Supf_srt+24;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.910745292 UTC

[section ""data" . GHC.List.tooLarge_closure" {
     GHC.List.tooLarge_closure:
         const GHC.List.tooLarge_info;
         const 0;
 },
 GHC.List.tooLarge_entry() //  []
         { []
         }
     {offset
       cw9U: // global
           R2 = GHC.List.!!1_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.tooLarge_info" {
     GHC.List.tooLarge_info:
         const GHC.List.tooLarge_entry;
         const 0;
         const 141733920782;
         const 4294967301;
         const Supf_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.914290375 UTC

[section ""data" . poly_exit_ru8U_closure" {
     poly_exit_ru8U_closure:
         const poly_exit_ru8U_info;
         const 0;
         const 0;
         const 0;
 },
 poly_exit_ru8U_entry() //  [R1]
         { []
         }
     {offset
       cwa7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwa8; else goto cwa9;
       cwa8: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwa9: // global
           (_cwa4::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwa4::I64 == 0) goto cwa6; else goto cwa5;
       cwa6: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwa5: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwa4::I64;
           R2 = GHC.List.!!1_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . poly_exit_ru8U_info" {
     poly_exit_ru8U_info:
         const poly_exit_ru8U_entry;
         const 0;
         const 141733920789;
         const Supf_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.918834878 UTC

[section ""data" . poly_$wgo_ru8V_closure" {
     poly_$wgo_ru8V_closure:
         const poly_$wgo_ru8V_info;
         const 0;
 },
 poly_$wgo_ru8V_entry() //  [R2, R3]
         { []
         }
     {offset
       cwas: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwat; else goto uwaH;
       cwat: // global
           R3 = R3;
           R2 = R2;
           R1 = poly_$wgo_ru8V_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uwaH: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cwai() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . poly_$wgo_ru8V_info" {
     poly_$wgo_ru8V_info:
         const poly_$wgo_ru8V_entry;
         const 0;
         const 12884901902;
         const 8589934606;
         const Supf_srt+56;
 },
 _cwai() //  []
         { []
         }
     {offset
       cwai: // global
           _suar::P64 = P64[Sp];
           I64[Sp] = block_cwal_info;
           R1 = _suar::P64;
           if (R1 & 7 != 0) goto uwaJ; else goto cwam;
       uwaJ: // global
           call _cwal(R1) args: 0, res: 0, upd: 0;
       cwam: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwal() //  [R1]
         { []
         }
     {offset
       cwal: // global
           if (R1 & 7 == 1) goto cwap; else goto cwaq;
       cwap: // global
           R1 = poly_exit_ru8U_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwaq: // global
           _suaw::I64 = I64[Sp + 8];
           if (_suaw::I64 != 0) goto cwaD; else goto cwaE;
       cwaD: // global
           P64[Sp] = P64[R1 + 14];
           I64[Sp + 8] = _suaw::I64 - 1;
           call _cwai() args: 0, res: 0, upd: 0;
       cwaE: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwal_info" {
     block_cwal_info:
         const _cwal;
         const 65;
         const 4294967326;
         const Supf_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.925624167 UTC

[section ""data" . GHC.List.$w!!_closure" {
     GHC.List.$w!!_closure:
         const GHC.List.$w!!_info;
         const 0;
 },
 GHC.List.$w!!_entry() //  [R2, R3]
         { []
         }
     {offset
       cwba: // global
           if (%MO_S_Ge_W64(R3, 0)) goto cwb8; else goto cwb9;
       cwb8: // global
           R3 = R3;
           R2 = R2;
           call poly_$wgo_ru8V_entry(R3, R2) args: 8, res: 0, upd: 8;
       cwb9: // global
           R1 = GHC.List.negIndex_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.$w!!_info" {
     GHC.List.$w!!_info:
         const GHC.List.$w!!_entry;
         const 0;
         const 12884901902;
         const 8589934606;
         const Supf_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.929579537 UTC

[section ""data" . GHC.List.!!_closure" {
     GHC.List.!!_closure:
         const GHC.List.!!_info;
         const 0;
 },
 GHC.List.!!_entry() //  [R2, R3]
         { []
         }
     {offset
       cwbo: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwbp; else goto cwbq;
       cwbp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.!!_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwbq: // global
           I64[Sp - 16] = block_cwbl_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwbu; else goto cwbm;
       uwbu: // global
           call _cwbl(R1) args: 0, res: 0, upd: 0;
       cwbm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.!!_info" {
     GHC.List.!!_info:
         const GHC.List.!!_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const Supf_srt+80;
 },
 _cwbl() //  [R1]
         { []
         }
     {offset
       cwbl: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.$w!!_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwbl_info" {
     block_cwbl_info:
         const _cwbl;
         const 1;
         const 4294967326;
         const Supf_srt+88;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.934276857 UTC

[section ""cstring" . lvl4_ru8W_bytes" {
     lvl4_ru8W_bytes:
         I8[] [99,121,99,108,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.936930237 UTC

[section ""data" . lvl5_ru8X_closure" {
     lvl5_ru8X_closure:
         const lvl5_ru8X_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_ru8X_entry() //  [R1]
         { []
         }
     {offset
       cwbL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwbM; else goto cwbN;
       cwbM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwbN: // global
           (_cwbI::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwbI::I64 == 0) goto cwbK; else goto cwbJ;
       cwbK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwbJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwbI::I64;
           R2 = lvl4_ru8W_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl5_ru8X_info" {
     lvl5_ru8X_info:
         const lvl5_ru8X_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.940865206 UTC

[section ""data" . GHC.List.cycle1_closure" {
     GHC.List.cycle1_closure:
         const GHC.List.cycle1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.cycle1_entry() //  [R1]
         { []
         }
     {offset
       cwc1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwc2; else goto cwc3;
       cwc2: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwc3: // global
           (_cwbY::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwbY::I64 == 0) goto cwc0; else goto cwbZ;
       cwc0: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwbZ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwbY::I64;
           R2 = lvl5_ru8X_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.cycle1_info" {
     GHC.List.cycle1_info:
         const GHC.List.cycle1_entry;
         const 0;
         const 4402341478421;
         const Supf_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.945625736 UTC

[section ""data" . GHC.List.cycle_closure" {
     GHC.List.cycle_closure:
         const GHC.List.cycle_info;
         const 0;
 },
 xs'_suaJ_entry() //  [R1]
         { []
         }
     {offset
       cwcp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwcq; else goto cwcr;
       cwcq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwcr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . xs'_suaJ_info" {
     xs'_suaJ_info:
         const xs'_suaJ_entry;
         const 1;
         const 16;
 },
 GHC.List.cycle_entry() //  [R2]
         { []
         }
     {offset
       cwcw: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwcx; else goto cwcy;
       cwcx: // global
           R2 = R2;
           R1 = GHC.List.cycle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwcy: // global
           I64[Sp - 8] = block_cwcf_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwcE; else goto cwcg;
       uwcE: // global
           call _cwcf(R1) args: 0, res: 0, upd: 0;
       cwcg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.cycle_info" {
     GHC.List.cycle_info:
         const GHC.List.cycle_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const Supf_srt+104;
 },
 _cwcf() //  [R1]
         { []
         }
     {offset
       cwcf: // global
           if (R1 & 7 == 1) goto cwct; else goto cwcu;
       cwct: // global
           R1 = GHC.List.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwcu: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwcD; else goto cwcC;
       cwcD: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwcC: // global
           I64[Hp - 16] = xs'_suaJ_info;
           P64[Hp] = R1;
           R1 = (Hp + -16) & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwcf_info" {
     block_cwcf_info:
         const _cwcf;
         const 0;
         const 4294967326;
         const Supf_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.953413898 UTC

[section ""cstring" . lvl6_ru8Y_bytes" {
     lvl6_ru8Y_bytes:
         I8[] [102,111,108,100,114,49]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.955665755 UTC

[section ""data" . lvl7_ru8Z_closure" {
     lvl7_ru8Z_closure:
         const lvl7_ru8Z_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_ru8Z_entry() //  [R1]
         { []
         }
     {offset
       cwd4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwd5; else goto cwd6;
       cwd5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwd6: // global
           (_cwd1::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwd1::I64 == 0) goto cwd3; else goto cwd2;
       cwd3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwd2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwd1::I64;
           R2 = lvl6_ru8Y_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl7_ru8Z_info" {
     lvl7_ru8Z_info:
         const lvl7_ru8Z_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.959585865 UTC

[section ""data" . lvl8_ru90_closure" {
     lvl8_ru90_closure:
         const lvl8_ru90_info;
         const 0;
         const 0;
         const 0;
 },
 lvl8_ru90_entry() //  [R1]
         { []
         }
     {offset
       cwdk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwdl; else goto cwdm;
       cwdl: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwdm: // global
           (_cwdh::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwdh::I64 == 0) goto cwdj; else goto cwdi;
       cwdj: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwdi: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwdh::I64;
           R2 = lvl7_ru8Z_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl8_ru90_info" {
     lvl8_ru90_info:
         const lvl8_ru90_entry;
         const 0;
         const 35188667056149;
         const Supf_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.965922492 UTC

[section ""data" . GHC.List.foldr1_closure" {
     GHC.List.foldr1_closure:
         const GHC.List.foldr1_info;
         const 0;
 },
 go2_suaM_entry() //  [R1, R2]
         { []
         }
     {offset
       cwdK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cwdL; else goto cwdM;
       cwdL: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwdM: // global
           I64[Sp - 24] = block_cwdD_info;
           _suaM::P64 = R1;
           _suaK::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _suaK::P64;
           P64[Sp - 8] = _suaM::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uwea; else goto cwdE;
       uwea: // global
           call _cwdD(R1) args: 0, res: 0, upd: 0;
       cwdE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go2_suaM_info" {
     go2_suaM_info:
         const go2_suaM_entry;
         const 1;
         const 4294967305;
         const 4294967301;
         const Supf_srt+128;
 },
 _cwdD() //  [R1]
         { []
         }
     {offset
       cwdD: // global
           if (R1 & 7 == 1) goto cwdH; else goto cwdI;
       cwdH: // global
           R1 = lvl8_ru90_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwdI: // global
           I64[Sp - 8] = block_cwdS_info;
           _suaP::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _suaP::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwe9; else goto cwdU;
       uwe9: // global
           call _cwdS(R1) args: 0, res: 0, upd: 0;
       cwdU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwdD_info" {
     block_cwdD_info:
         const _cwdD;
         const 2;
         const 4294967326;
         const Supf_srt+128;
 },
 _cwdS() //  [R1]
         { []
         }
     {offset
       cwdS: // global
           _suaP::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cwe0; else goto cwe4;
       cwe0: // global
           R1 = _suaP::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwe4: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cwe7; else goto cwe6;
       cwe7: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwe6: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = _suaP::P64;
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwdS_info" {
     block_cwdS_info:
         const _cwdS;
         const 3;
         const 30;
 },
 GHC.List.foldr1_entry() //  [R2, R3]
         { []
         }
     {offset
       cweb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cwef; else goto cwee;
       cwef: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwee: // global
           I64[Hp - 8] = go2_suaM_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go2_suaM_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.foldr1_info" {
     GHC.List.foldr1_info:
         const GHC.List.foldr1_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const Supf_srt+128;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.974324822 UTC

[section ""cstring" . lvl9_ru91_bytes" {
     lvl9_ru91_bytes:
         I8[] [105,110,105,116]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.976689635 UTC

[section ""data" . lvl10_ru92_closure" {
     lvl10_ru92_closure:
         const lvl10_ru92_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_ru92_entry() //  [R1]
         { []
         }
     {offset
       cweI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cweJ; else goto cweK;
       cweJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cweK: // global
           (_cweF::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cweF::I64 == 0) goto cweH; else goto cweG;
       cweH: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cweG: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cweF::I64;
           R2 = lvl9_ru91_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl10_ru92_info" {
     lvl10_ru92_info:
         const lvl10_ru92_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.98110476 UTC

[section ""data" . GHC.List.init2_closure" {
     GHC.List.init2_closure:
         const GHC.List.init2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.init2_entry() //  [R1]
         { []
         }
     {offset
       cweY: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cweZ; else goto cwf0;
       cweZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwf0: // global
           (_cweV::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cweV::I64 == 0) goto cweX; else goto cweW;
       cweX: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cweW: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cweV::I64;
           R2 = lvl10_ru92_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.init2_info" {
     GHC.List.init2_info:
         const GHC.List.init2_entry;
         const 0;
         const 281479271677973;
         const Supf_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.985761974 UTC

[section ""data" . GHC.List.init_closure" {
     GHC.List.init_closure:
         const GHC.List.init_info;
         const 0;
 },
 GHC.List.init_entry() //  [R2]
         { []
         }
     {offset
       cwfj: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwfk; else goto cwfl;
       cwfk: // global
           R2 = R2;
           R1 = GHC.List.init_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwfl: // global
           I64[Sp - 8] = block_cwfc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwfs; else goto cwfd;
       uwfs: // global
           call _cwfc(R1) args: 0, res: 0, upd: 0;
       cwfd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.init_info" {
     GHC.List.init_info:
         const GHC.List.init_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const Supf_srt+152;
 },
 _cwfc() //  [R1]
         { []
         }
     {offset
       cwfc: // global
           if (R1 & 7 == 1) goto cwfg; else goto cwfh;
       cwfg: // global
           R1 = GHC.List.init2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwfh: // global
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           Sp = Sp + 8;
           call GHC.List.init1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwfc_info" {
     block_cwfc_info:
         const _cwfc;
         const 0;
         const 4294967326;
         const Supf_srt+160;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.990742735 UTC

[section ""cstring" . lvl11_ru93_bytes" {
     lvl11_ru93_bytes:
         I8[] [108,97,115,116]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.994014129 UTC

[section ""data" . lvl12_ru94_closure" {
     lvl12_ru94_closure:
         const lvl12_ru94_info;
         const 0;
         const 0;
         const 0;
 },
 lvl12_ru94_entry() //  [R1]
         { []
         }
     {offset
       cwfM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwfN; else goto cwfO;
       cwfN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwfO: // global
           (_cwfJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwfJ::I64 == 0) goto cwfL; else goto cwfK;
       cwfL: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwfK: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwfJ::I64;
           R2 = lvl11_ru93_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl12_ru94_info" {
     lvl12_ru94_info:
         const lvl12_ru94_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:06.998078416 UTC

[section ""data" . GHC.List.lastError_closure" {
     GHC.List.lastError_closure:
         const GHC.List.lastError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.lastError_entry() //  [R1]
         { []
         }
     {offset
       cwg2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwg3; else goto cwg4;
       cwg3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwg4: // global
           (_cwfZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwfZ::I64 == 0) goto cwg1; else goto cwg0;
       cwg1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwg0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwfZ::I64;
           R2 = lvl12_ru94_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.lastError_info" {
     GHC.List.lastError_info:
         const GHC.List.lastError_entry;
         const 0;
         const 2251804108652565;
         const Supf_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.002479719 UTC

[section ""data" . poly_go_ru95_closure" {
     poly_go_ru95_closure:
         const poly_go_ru95_info;
 },
 poly_go_ru95_entry() //  [R2, R3]
         { []
         }
     {offset
       cwgn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwgo; else goto uwgw;
       cwgo: // global
           R3 = R3;
           R2 = R2;
           R1 = poly_go_ru95_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uwgw: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cwgd() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . poly_go_ru95_info" {
     poly_go_ru95_info:
         const poly_go_ru95_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cwgd() //  []
         { []
         }
     {offset
       cwgd: // global
           _suaZ::P64 = P64[Sp];
           I64[Sp] = block_cwgg_info;
           R1 = _suaZ::P64;
           if (R1 & 7 != 0) goto uwgy; else goto cwgh;
       uwgy: // global
           call _cwgg(R1) args: 0, res: 0, upd: 0;
       cwgh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwgg() //  [R1]
         { []
         }
     {offset
       cwgg: // global
           if (R1 & 7 == 1) goto cwgk; else goto cwgl;
       cwgk: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwgl: // global
           P64[Sp] = P64[R1 + 14];
           P64[Sp + 8] = P64[R1 + 6];
           call _cwgd() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cwgg_info" {
     block_cwgg_info:
         const _cwgg;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.008816482 UTC

[section ""data" . GHC.List.last_closure" {
     GHC.List.last_closure:
         const GHC.List.last_info;
         const 0;
 },
 GHC.List.last_entry() //  [R2]
         { []
         }
     {offset
       cwgU: // global
           R3 = GHC.List.lastError_closure;
           R2 = R2;
           call poly_go_ru95_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.last_info" {
     GHC.List.last_info:
         const GHC.List.last_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const Supf_srt+176;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.011892764 UTC

[section ""cstring" . lvl13_ru96_bytes" {
     lvl13_ru96_bytes:
         I8[] [116,97,105,108]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.014101984 UTC

[section ""data" . lvl14_ru97_closure" {
     lvl14_ru97_closure:
         const lvl14_ru97_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_ru97_entry() //  [R1]
         { []
         }
     {offset
       cwh8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwh9; else goto cwha;
       cwh9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwha: // global
           (_cwh5::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwh5::I64 == 0) goto cwh7; else goto cwh6;
       cwh7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwh6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwh5::I64;
           R2 = lvl13_ru96_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl14_ru97_info" {
     lvl14_ru97_info:
         const lvl14_ru97_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.018329506 UTC

[section ""data" . GHC.List.scanl2_closure" {
     GHC.List.scanl2_closure:
         const GHC.List.scanl2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.scanl2_entry() //  [R1]
         { []
         }
     {offset
       cwho: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwhp; else goto cwhq;
       cwhp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwhq: // global
           (_cwhl::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwhl::I64 == 0) goto cwhn; else goto cwhm;
       cwhn: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwhm: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwhl::I64;
           R2 = lvl14_ru97_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.scanl2_info" {
     GHC.List.scanl2_info:
         const GHC.List.scanl2_entry;
         const 0;
         const 9007203549708309;
         const Supf_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.023070119 UTC

[section ""data" . GHC.List.tail_closure" {
     GHC.List.tail_closure:
         const GHC.List.tail_info;
         const 0;
 },
 GHC.List.tail_entry() //  [R2]
         { []
         }
     {offset
       cwhJ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwhK; else goto cwhL;
       cwhK: // global
           R2 = R2;
           R1 = GHC.List.tail_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwhL: // global
           I64[Sp - 8] = block_cwhC_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwhS; else goto cwhD;
       uwhS: // global
           call _cwhC(R1) args: 0, res: 0, upd: 0;
       cwhD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.tail_info" {
     GHC.List.tail_info:
         const GHC.List.tail_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const Supf_srt+192;
 },
 _cwhC() //  [R1]
         { []
         }
     {offset
       cwhC: // global
           if (R1 & 7 == 1) goto cwhG; else goto cwhH;
       cwhG: // global
           R1 = GHC.List.scanl2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwhH: // global
           R1 = P64[R1 + 14] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwhC_info" {
     block_cwhC_info:
         const _cwhC;
         const 0;
         const 4294967326;
         const Supf_srt+200;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.027827248 UTC

[section ""cstring" . lvl15_ru98_bytes" {
     lvl15_ru98_bytes:
         I8[] [104,101,97,100]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.030093345 UTC

[section ""data" . lvl16_ru99_closure" {
     lvl16_ru99_closure:
         const lvl16_ru99_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_ru99_entry() //  [R1]
         { []
         }
     {offset
       cwie: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwif; else goto cwig;
       cwif: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwig: // global
           (_cwib::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwib::I64 == 0) goto cwid; else goto cwic;
       cwid: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwic: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwib::I64;
           R2 = lvl15_ru98_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl16_ru99_info" {
     lvl16_ru99_info:
         const lvl16_ru99_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.034143331 UTC

[section ""data" . GHC.List.badHead_closure" {
     GHC.List.badHead_closure:
         const GHC.List.badHead_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.badHead_entry() //  [R1]
         { []
         }
     {offset
       cwiu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwiv; else goto cwiw;
       cwiv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwiw: // global
           (_cwir::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwir::I64 == 0) goto cwit; else goto cwis;
       cwit: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwis: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwir::I64;
           R2 = lvl16_ru99_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.badHead_info" {
     GHC.List.badHead_info:
         const GHC.List.badHead_entry;
         const 0;
         const 72057598332895253;
         const Supf_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.039188067 UTC

[section ""data" . GHC.List.head_closure" {
     GHC.List.head_closure:
         const GHC.List.head_info;
         const 0;
 },
 GHC.List.head_entry() //  [R2]
         { []
         }
     {offset
       cwiP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwiQ; else goto cwiR;
       cwiQ: // global
           R2 = R2;
           R1 = GHC.List.head_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwiR: // global
           I64[Sp - 8] = block_cwiI_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwiY; else goto cwiJ;
       uwiY: // global
           call _cwiI(R1) args: 0, res: 0, upd: 0;
       cwiJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.head_info" {
     GHC.List.head_info:
         const GHC.List.head_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const Supf_srt+216;
 },
 _cwiI() //  [R1]
         { []
         }
     {offset
       cwiI: // global
           if (R1 & 7 == 1) goto cwiM; else goto cwiN;
       cwiM: // global
           R1 = GHC.List.badHead_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwiN: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwiI_info" {
     block_cwiI_info:
         const _cwiI;
         const 0;
         const 4294967326;
         const Supf_srt+224;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.043973933 UTC

[section ""cstring" . lvl17_ru9a_bytes" {
     lvl17_ru9a_bytes:
         I8[] [109,97,120,105,109,117,109]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.046398973 UTC

[section ""data" . lvl18_ru9b_closure" {
     lvl18_ru9b_closure:
         const lvl18_ru9b_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_ru9b_entry() //  [R1]
         { []
         }
     {offset
       cwjh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwji; else goto cwjj;
       cwji: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwjj: // global
           (_cwje::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwje::I64 == 0) goto cwjg; else goto cwjf;
       cwjg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwjf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwje::I64;
           R2 = lvl17_ru9a_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl18_ru9b_info" {
     lvl18_ru9b_info:
         const lvl18_ru9b_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.050788353 UTC

[section ""data" . GHC.List.maximum1_closure" {
     GHC.List.maximum1_closure:
         const GHC.List.maximum1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.maximum1_entry() //  [R1]
         { []
         }
     {offset
       cwjx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwjy; else goto cwjz;
       cwjy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwjz: // global
           (_cwju::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwju::I64 == 0) goto cwjw; else goto cwjv;
       cwjw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwjv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwju::I64;
           R2 = lvl18_ru9b_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.maximum1_info" {
     GHC.List.maximum1_info:
         const GHC.List.maximum1_entry;
         const 0;
         const 576460756598390805;
         const Supf_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.055262668 UTC

[section ""data" . GHC.List.maximum2_closure" {
     GHC.List.maximum2_closure:
         const GHC.List.maximum2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.maximum2_entry() //  [R1]
         { []
         }
     {offset
       cwjN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwjO; else goto cwjP;
       cwjO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwjP: // global
           (_cwjK::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwjK::I64 == 0) goto cwjM; else goto cwjL;
       cwjM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwjL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwjK::I64;
           R2 = lvl18_ru9b_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.maximum2_info" {
     GHC.List.maximum2_info:
         const GHC.List.maximum2_entry;
         const 0;
         const 576460756598390805;
         const Supf_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.059208944 UTC

[section ""data" . lvl19_ru9c_closure" {
     lvl19_ru9c_closure:
         const lvl19_ru9c_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_ru9c_entry() //  [R1]
         { []
         }
     {offset
       cwk3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwk4; else goto cwk5;
       cwk4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwk5: // global
           (_cwk0::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwk0::I64 == 0) goto cwk2; else goto cwk1;
       cwk2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwk1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwk0::I64;
           R2 = lvl18_ru9b_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl19_ru9c_info" {
     lvl19_ru9c_info:
         const lvl19_ru9c_entry;
         const 0;
         const 576460756598390805;
         const Supf_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.063911697 UTC

[section ""data" . GHC.List.maximum_go_closure" {
     GHC.List.maximum_go_closure:
         const GHC.List.maximum_go_info;
 },
 GHC.List.maximum_go_entry() //  [R2, R3]
         { []
         }
     {offset
       cwko: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cwkp; else goto uwkI;
       cwkp: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.maximum_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uwkI: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cwke() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.maximum_go_info" {
     GHC.List.maximum_go_info:
         const GHC.List.maximum_go_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cwke() //  []
         { []
         }
     {offset
       cwke: // global
           _subd::P64 = P64[Sp];
           I64[Sp] = block_cwkh_info;
           R1 = _subd::P64;
           if (R1 & 7 != 0) goto uwkL; else goto cwki;
       uwkL: // global
           call _cwkh(R1) args: 0, res: 0, upd: 0;
       cwki: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwkh() //  [R1]
         { []
         }
     {offset
       cwkh: // global
           _sube::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cwkl; else goto cwkm;
       cwkl: // global
           R1 = _sube::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwkm: // global
           I64[Sp - 16] = block_cwkw_info;
           _subg::P64 = P64[R1 + 6];
           R3 = _subg::P64;
           R2 = _sube::P64;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = _subg::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwkh_info" {
     block_cwkh_info:
         const _cwkh;
         const 1;
         const 30;
 },
 _cwkw() //  [R1]
         { []
         }
     {offset
       cwkw: // global
           _subh::P64 = P64[Sp + 8];
           if (R1 == 1) goto cwkH; else goto cwkD;
       cwkH: // global
           _sube::P64 = P64[Sp + 16];
           P64[Sp + 16] = _subh::P64;
           P64[Sp + 24] = _sube::P64;
           Sp = Sp + 16;
           goto uwkO;
       cwkD: // global
           P64[Sp + 16] = _subh::P64;
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 16;
           goto uwkO;
       uwkO: // global
           call _cwke() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cwkw_info" {
     block_cwkw_info:
         const _cwkw;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.072614369 UTC

[section ""data" . GHC.List.maximum_$smaximum_closure" {
     GHC.List.maximum_$smaximum_closure:
         const GHC.List.maximum_$smaximum_info;
         const 0;
 },
 GHC.List.maximum_$smaximum_entry() //  [R2]
         { []
         }
     {offset
       cwlk: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwll; else goto cwlm;
       cwll: // global
           R2 = R2;
           R1 = GHC.List.maximum_$smaximum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwlm: // global
           I64[Sp - 8] = block_cwld_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwlt; else goto cwle;
       uwlt: // global
           call _cwld(R1) args: 0, res: 0, upd: 0;
       cwle: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.maximum_$smaximum_info" {
     GHC.List.maximum_$smaximum_info:
         const GHC.List.maximum_$smaximum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const Supf_srt+240;
 },
 _cwld() //  [R1]
         { []
         }
     {offset
       cwld: // global
           if (R1 & 7 == 1) goto cwlh; else goto cwli;
       cwlh: // global
           R1 = GHC.List.maximum1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwli: // global
           R3 = P64[R1 + 6];
           R2 = P64[R1 + 14];
           Sp = Sp + 8;
           call GHC.List.maximum_go_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwld_info" {
     block_cwld_info:
         const _cwld;
         const 0;
         const 4294967326;
         const Supf_srt+248;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.077406321 UTC

[section ""cstring" . lvl20_ru9d_bytes" {
     lvl20_ru9d_bytes:
         I8[] [109,105,110,105,109,117,109]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.079989805 UTC

[section ""data" . lvl21_ru9e_closure" {
     lvl21_ru9e_closure:
         const lvl21_ru9e_info;
         const 0;
         const 0;
         const 0;
 },
 lvl21_ru9e_entry() //  [R1]
         { []
         }
     {offset
       cwlN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwlO; else goto cwlP;
       cwlO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwlP: // global
           (_cwlK::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwlK::I64 == 0) goto cwlM; else goto cwlL;
       cwlM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwlL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwlK::I64;
           R2 = lvl20_ru9d_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl21_ru9e_info" {
     lvl21_ru9e_info:
         const lvl21_ru9e_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.08375857 UTC

[section ""data" . GHC.List.minimum1_closure" {
     GHC.List.minimum1_closure:
         const GHC.List.minimum1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.minimum1_entry() //  [R1]
         { []
         }
     {offset
       cwm3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwm4; else goto cwm5;
       cwm4: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwm5: // global
           (_cwm0::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwm0::I64 == 0) goto cwm2; else goto cwm1;
       cwm2: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwm1: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwm0::I64;
           R2 = lvl21_ru9e_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.minimum1_info" {
     GHC.List.minimum1_info:
         const GHC.List.minimum1_entry;
         const 0;
         const 4611686022722355221;
         const Supf_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.088128584 UTC

[section ""data" . GHC.List.minimum2_closure" {
     GHC.List.minimum2_closure:
         const GHC.List.minimum2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.minimum2_entry() //  [R1]
         { []
         }
     {offset
       cwmj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwmk; else goto cwml;
       cwmk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwml: // global
           (_cwmg::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwmg::I64 == 0) goto cwmi; else goto cwmh;
       cwmi: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwmh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwmg::I64;
           R2 = lvl21_ru9e_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.minimum2_info" {
     GHC.List.minimum2_info:
         const GHC.List.minimum2_entry;
         const 0;
         const 4611686022722355221;
         const Supf_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.092120802 UTC

[section ""data" . lvl22_ru9f_closure" {
     lvl22_ru9f_closure:
         const lvl22_ru9f_info;
         const 0;
         const 0;
         const 0;
 },
 lvl22_ru9f_entry() //  [R1]
         { []
         }
     {offset
       cwmz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwmA; else goto cwmB;
       cwmA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwmB: // global
           (_cwmw::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwmw::I64 == 0) goto cwmy; else goto cwmx;
       cwmy: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwmx: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwmw::I64;
           R2 = lvl21_ru9e_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl22_ru9f_info" {
     lvl22_ru9f_info:
         const lvl22_ru9f_entry;
         const 0;
         const 4611686022722355221;
         const Supf_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.097525441 UTC

[section ""data" . GHC.List.minimum_go_closure" {
     GHC.List.minimum_go_closure:
         const GHC.List.minimum_go_info;
 },
 GHC.List.minimum_go_entry() //  [R2, R3]
         { []
         }
     {offset
       cwmU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cwmV; else goto uwne;
       cwmV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.minimum_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uwne: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cwmK() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.minimum_go_info" {
     GHC.List.minimum_go_info:
         const GHC.List.minimum_go_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cwmK() //  []
         { []
         }
     {offset
       cwmK: // global
           _subn::P64 = P64[Sp];
           I64[Sp] = block_cwmN_info;
           R1 = _subn::P64;
           if (R1 & 7 != 0) goto uwnh; else goto cwmO;
       uwnh: // global
           call _cwmN(R1) args: 0, res: 0, upd: 0;
       cwmO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwmN() //  [R1]
         { []
         }
     {offset
       cwmN: // global
           _subo::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cwmR; else goto cwmS;
       cwmR: // global
           R1 = _subo::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwmS: // global
           I64[Sp - 16] = block_cwn2_info;
           _subq::P64 = P64[R1 + 6];
           R3 = _subq::P64;
           R2 = _subo::P64;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = _subq::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwmN_info" {
     block_cwmN_info:
         const _cwmN;
         const 1;
         const 30;
 },
 _cwn2() //  [R1]
         { []
         }
     {offset
       cwn2: // global
           _subr::P64 = P64[Sp + 8];
           if (R1 == 1) goto cwnd; else goto cwn9;
       cwnd: // global
           P64[Sp + 16] = _subr::P64;
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 16;
           goto uwnk;
       cwn9: // global
           _subo::P64 = P64[Sp + 16];
           P64[Sp + 16] = _subr::P64;
           P64[Sp + 24] = _subo::P64;
           Sp = Sp + 16;
           goto uwnk;
       uwnk: // global
           call _cwmK() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cwn2_info" {
     block_cwn2_info:
         const _cwn2;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.106150801 UTC

[section ""data" . GHC.List.minimum_$sminimum_closure" {
     GHC.List.minimum_$sminimum_closure:
         const GHC.List.minimum_$sminimum_info;
         const 0;
 },
 GHC.List.minimum_$sminimum_entry() //  [R2]
         { []
         }
     {offset
       cwnQ: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwnR; else goto cwnS;
       cwnR: // global
           R2 = R2;
           R1 = GHC.List.minimum_$sminimum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwnS: // global
           I64[Sp - 8] = block_cwnJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwnZ; else goto cwnK;
       uwnZ: // global
           call _cwnJ(R1) args: 0, res: 0, upd: 0;
       cwnK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.minimum_$sminimum_info" {
     GHC.List.minimum_$sminimum_info:
         const GHC.List.minimum_$sminimum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const Supf_srt+264;
 },
 _cwnJ() //  [R1]
         { []
         }
     {offset
       cwnJ: // global
           if (R1 & 7 == 1) goto cwnN; else goto cwnO;
       cwnN: // global
           R1 = GHC.List.minimum1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwnO: // global
           R3 = P64[R1 + 6];
           R2 = P64[R1 + 14];
           Sp = Sp + 8;
           call GHC.List.minimum_go_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwnJ_info" {
     block_cwnJ_info:
         const _cwnJ;
         const 0;
         const 4294967326;
         const Supf_srt+272;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.112875155 UTC

[section ""data" . GHC.List.$wgo_closure" {
     GHC.List.$wgo_closure:
         const GHC.List.$wgo_info;
 },
 GHC.List.$wgo_entry() //  [R2, R3]
         { []
         }
     {offset
       cwon: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cwoo; else goto uwoH;
       cwoo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wgo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uwoH: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cwod() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.$wgo_info" {
     GHC.List.$wgo_info:
         const GHC.List.$wgo_entry;
         const 0;
         const 14;
         const 8589934606;
 },
 _cwod() //  []
         { []
         }
     {offset
       cwod: // global
           _subx::P64 = P64[Sp];
           I64[Sp] = block_cwog_info;
           R1 = _subx::P64;
           if (R1 & 7 != 0) goto uwoK; else goto cwoh;
       uwoK: // global
           call _cwog(R1) args: 0, res: 0, upd: 0;
       cwoh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwog() //  [R1]
         { []
         }
     {offset
       cwog: // global
           if (R1 & 7 == 1) goto cwok; else goto cwol;
       cwok: // global
           R1 = I64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwol: // global
           I64[Sp - 8] = block_cwov_info;
           _subB::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _subB::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwoL; else goto cwox;
       uwoL: // global
           call _cwov(R1) args: 0, res: 0, upd: 0;
       cwox: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwog_info" {
     block_cwog_info:
         const _cwog;
         const 65;
         const 30;
 },
 _cwov() //  [R1]
         { []
         }
     {offset
       cwov: // global
           _suby::I64 = I64[Sp + 16];
           _subB::P64 = P64[Sp + 8];
           _subD::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_suby::I64,
                            _subD::I64)) goto cwoF; else goto cwoG;
       cwoF: // global
           P64[Sp + 8] = _subB::P64;
           I64[Sp + 16] = _suby::I64;
           Sp = Sp + 8;
           goto uwoO;
       cwoG: // global
           P64[Sp + 8] = _subB::P64;
           I64[Sp + 16] = _subD::I64;
           Sp = Sp + 8;
           goto uwoO;
       uwoO: // global
           call _cwod() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cwov_info" {
     block_cwov_info:
         const _cwov;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.122816655 UTC

[section ""data" . GHC.List.maximum_$smaximum1_closure" {
     GHC.List.maximum_$smaximum1_closure:
         const GHC.List.maximum_$smaximum1_info;
         const 0;
 },
 GHC.List.maximum_$smaximum1_entry() //  [R2]
         { []
         }
     {offset
       cwpi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwpj; else goto cwpk;
       cwpj: // global
           R2 = R2;
           R1 = GHC.List.maximum_$smaximum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwpk: // global
           I64[Sp - 8] = block_cwpb_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwpG; else goto cwpc;
       uwpG: // global
           call _cwpb(R1) args: 0, res: 0, upd: 0;
       cwpc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.maximum_$smaximum1_info" {
     GHC.List.maximum_$smaximum1_info:
         const GHC.List.maximum_$smaximum1_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const Supf_srt+280;
 },
 _cwpb() //  [R1]
         { []
         }
     {offset
       cwpb: // global
           if (R1 & 7 == 1) goto cwpf; else goto cwpg;
       cwpf: // global
           R1 = GHC.List.maximum2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwpg: // global
           I64[Sp - 8] = block_cwpq_info;
           _subI::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _subI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwpF; else goto cwpr;
       uwpF: // global
           call _cwpq(R1) args: 0, res: 0, upd: 0;
       cwpr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwpb_info" {
     block_cwpb_info:
         const _cwpb;
         const 0;
         const 4294967326;
         const Supf_srt+288;
 },
 _cwpq() //  [R1]
         { []
         }
     {offset
       cwpq: // global
           _subI::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cwpv_info;
           R3 = I64[R1 + 7];
           R2 = _subI::P64;
           Sp = Sp + 8;
           call GHC.List.$wgo_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwpq_info" {
     block_cwpq_info:
         const _cwpq;
         const 1;
         const 30;
 },
 _cwpv() //  [R1]
         { []
         }
     {offset
       cwpv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cwpE; else goto cwpD;
       cwpE: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cwpD: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwpv_info" {
     block_cwpv_info:
         const _cwpv;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.133086721 UTC

[section ""data" . GHC.List.maximum_closure" {
     GHC.List.maximum_closure:
         const GHC.List.maximum_info;
         const 0;
 },
 sat_subX_entry() //  [R1]
         { []
         }
     {offset
       cwqq: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cwqr; else goto cwqs;
       cwqr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwqs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Classes.max_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_subX_info" {
     sat_subX_info:
         const sat_subX_entry;
         const 3;
         const 15;
 },
 GHC.List.maximum_entry() //  [R2, R3]
         { []
         }
     {offset
       cwqx: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cwqy; else goto cwqz;
       cwqy: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.maximum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwqz: // global
           I64[Sp - 16] = block_cwq5_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwqS; else goto cwq6;
       uwqS: // global
           call _cwq5(R1) args: 0, res: 0, upd: 0;
       cwq6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.maximum_info" {
     GHC.List.maximum_info:
         const GHC.List.maximum_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const Supf_srt+296;
 },
 _cwq5() //  [R1]
         { []
         }
     {offset
       cwq5: // global
           if (R1 & 7 == 1) goto cwqu; else goto cwqv;
       cwqu: // global
           R1 = lvl19_ru9c_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwqv: // global
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[R1 + 14];
           Sp = Sp - 8;
           call _cwqe() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cwq5_info" {
     block_cwq5_info:
         const _cwq5;
         const 1;
         const 4294967326;
         const Supf_srt+304;
 },
 _cwqe() //  []
         { []
         }
     {offset
       cwqe: // global
           I64[Sp - 8] = block_cwqg_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwqQ; else goto cwqh;
       uwqQ: // global
           call _cwqg(R1) args: 0, res: 0, upd: 0;
       cwqh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwqg() //  [R1]
         { []
         }
     {offset
       cwqg: // global
           _subT::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cwqH; else goto cwqI;
       cwqH: // global
           R1 = _subT::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwqI: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cwqL; else goto cwqK;
       cwqL: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwqK: // global
           _subV::P64 = P64[R1 + 6];
           _subW::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_subX_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _subT::P64;
           P64[Hp] = _subV::P64;
           P64[Sp + 16] = _subW::P64;
           P64[Sp + 8] = Hp - 32;
           Sp = Sp + 8;
           call _cwqe() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cwqg_info" {
     block_cwqg_info:
         const _cwqg;
         const 131;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.144541446 UTC

[section ""data" . GHC.List.$wgo1_closure" {
     GHC.List.$wgo1_closure:
         const GHC.List.$wgo1_info;
 },
 GHC.List.$wgo1_entry() //  [R2, R3]
         { []
         }
     {offset
       cwrx: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cwry; else goto uwrR;
       cwry: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wgo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uwrR: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cwrn() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.$wgo1_info" {
     GHC.List.$wgo1_info:
         const GHC.List.$wgo1_entry;
         const 0;
         const 14;
         const 8589934606;
 },
 _cwrn() //  []
         { []
         }
     {offset
       cwrn: // global
           _subY::P64 = P64[Sp];
           I64[Sp] = block_cwrq_info;
           R1 = _subY::P64;
           if (R1 & 7 != 0) goto uwrU; else goto cwrr;
       uwrU: // global
           call _cwrq(R1) args: 0, res: 0, upd: 0;
       cwrr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwrq() //  [R1]
         { []
         }
     {offset
       cwrq: // global
           if (R1 & 7 == 1) goto cwru; else goto cwrv;
       cwru: // global
           R1 = I64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwrv: // global
           I64[Sp - 8] = block_cwrF_info;
           _suc2::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _suc2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwrV; else goto cwrH;
       uwrV: // global
           call _cwrF(R1) args: 0, res: 0, upd: 0;
       cwrH: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwrq_info" {
     block_cwrq_info:
         const _cwrq;
         const 65;
         const 30;
 },
 _cwrF() //  [R1]
         { []
         }
     {offset
       cwrF: // global
           _subZ::I64 = I64[Sp + 16];
           _suc2::P64 = P64[Sp + 8];
           _suc4::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_subZ::I64,
                            _suc4::I64)) goto cwrP; else goto cwrQ;
       cwrP: // global
           P64[Sp + 8] = _suc2::P64;
           I64[Sp + 16] = _suc4::I64;
           Sp = Sp + 8;
           goto uwrY;
       cwrQ: // global
           P64[Sp + 8] = _suc2::P64;
           I64[Sp + 16] = _subZ::I64;
           Sp = Sp + 8;
           goto uwrY;
       uwrY: // global
           call _cwrn() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cwrF_info" {
     block_cwrF_info:
         const _cwrF;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.153778803 UTC

[section ""data" . GHC.List.minimum_$sminimum1_closure" {
     GHC.List.minimum_$sminimum1_closure:
         const GHC.List.minimum_$sminimum1_info;
         const 0;
 },
 GHC.List.minimum_$sminimum1_entry() //  [R2]
         { []
         }
     {offset
       cwss: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwst; else goto cwsu;
       cwst: // global
           R2 = R2;
           R1 = GHC.List.minimum_$sminimum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwsu: // global
           I64[Sp - 8] = block_cwsl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwsQ; else goto cwsm;
       uwsQ: // global
           call _cwsl(R1) args: 0, res: 0, upd: 0;
       cwsm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.minimum_$sminimum1_info" {
     GHC.List.minimum_$sminimum1_info:
         const GHC.List.minimum_$sminimum1_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const Supf_srt+312;
 },
 _cwsl() //  [R1]
         { []
         }
     {offset
       cwsl: // global
           if (R1 & 7 == 1) goto cwsp; else goto cwsq;
       cwsp: // global
           R1 = GHC.List.minimum2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwsq: // global
           I64[Sp - 8] = block_cwsA_info;
           _suc9::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _suc9::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwsP; else goto cwsB;
       uwsP: // global
           call _cwsA(R1) args: 0, res: 0, upd: 0;
       cwsB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwsl_info" {
     block_cwsl_info:
         const _cwsl;
         const 0;
         const 4294967326;
         const Supf_srt+320;
 },
 _cwsA() //  [R1]
         { []
         }
     {offset
       cwsA: // global
           _suc9::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cwsF_info;
           R3 = I64[R1 + 7];
           R2 = _suc9::P64;
           Sp = Sp + 8;
           call GHC.List.$wgo1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwsA_info" {
     block_cwsA_info:
         const _cwsA;
         const 1;
         const 30;
 },
 _cwsF() //  [R1]
         { []
         }
     {offset
       cwsF: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cwsO; else goto cwsN;
       cwsO: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cwsN: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwsF_info" {
     block_cwsF_info:
         const _cwsF;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.164025112 UTC

[section ""data" . GHC.List.minimum_closure" {
     GHC.List.minimum_closure:
         const GHC.List.minimum_info;
         const 0;
 },
 sat_suco_entry() //  [R1]
         { []
         }
     {offset
       cwtA: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cwtB; else goto cwtC;
       cwtB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwtC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Classes.min_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_suco_info" {
     sat_suco_info:
         const sat_suco_entry;
         const 3;
         const 15;
 },
 GHC.List.minimum_entry() //  [R2, R3]
         { []
         }
     {offset
       cwtH: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cwtI; else goto cwtJ;
       cwtI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.minimum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwtJ: // global
           I64[Sp - 16] = block_cwtf_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwu2; else goto cwtg;
       uwu2: // global
           call _cwtf(R1) args: 0, res: 0, upd: 0;
       cwtg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.minimum_info" {
     GHC.List.minimum_info:
         const GHC.List.minimum_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const Supf_srt+328;
 },
 _cwtf() //  [R1]
         { []
         }
     {offset
       cwtf: // global
           if (R1 & 7 == 1) goto cwtE; else goto cwtF;
       cwtE: // global
           R1 = lvl22_ru9f_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwtF: // global
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[R1 + 14];
           Sp = Sp - 8;
           call _cwto() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cwtf_info" {
     block_cwtf_info:
         const _cwtf;
         const 1;
         const 4294967326;
         const Supf_srt+336;
 },
 _cwto() //  []
         { []
         }
     {offset
       cwto: // global
           I64[Sp - 8] = block_cwtq_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwu0; else goto cwtr;
       uwu0: // global
           call _cwtq(R1) args: 0, res: 0, upd: 0;
       cwtr: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwtq() //  [R1]
         { []
         }
     {offset
       cwtq: // global
           _suck::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cwtR; else goto cwtS;
       cwtR: // global
           R1 = _suck::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwtS: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cwtV; else goto cwtU;
       cwtV: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwtU: // global
           _sucm::P64 = P64[R1 + 6];
           _sucn::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_suco_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _suck::P64;
           P64[Hp] = _sucm::P64;
           P64[Sp + 16] = _sucn::P64;
           P64[Sp + 8] = Hp - 32;
           Sp = Sp + 8;
           call _cwto() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cwtq_info" {
     block_cwtq_info:
         const _cwtq;
         const 131;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.174617412 UTC

[section ""cstring" . lvl23_ru9g_bytes" {
     lvl23_ru9g_bytes:
         I8[] [102,111,108,100,108,49,39]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.176937756 UTC

[section ""data" . lvl24_ru9h_closure" {
     lvl24_ru9h_closure:
         const lvl24_ru9h_info;
         const 0;
         const 0;
         const 0;
 },
 lvl24_ru9h_entry() //  [R1]
         { []
         }
     {offset
       cwuD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwuE; else goto cwuF;
       cwuE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwuF: // global
           (_cwuA::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwuA::I64 == 0) goto cwuC; else goto cwuB;
       cwuC: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwuB: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwuA::I64;
           R2 = lvl23_ru9g_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl24_ru9h_info" {
     lvl24_ru9h_info:
         const lvl24_ru9h_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.181422266 UTC

[section ""data" . GHC.List.foldl1'1_closure" {
     GHC.List.foldl1'1_closure:
         const GHC.List.foldl1'1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.foldl1'1_entry() //  [R1]
         { []
         }
     {offset
       cwuT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwuU; else goto cwuV;
       cwuU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwuV: // global
           (_cwuQ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwuQ::I64 == 0) goto cwuS; else goto cwuR;
       cwuS: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwuR: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwuQ::I64;
           R2 = lvl24_ru9h_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.foldl1'1_info" {
     GHC.List.foldl1'1_info:
         const GHC.List.foldl1'1_entry;
         const 0;
         const 12884901909;
         const Supf_srt+344;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.184791348 UTC

[section ""cstring" . lvl25_ru9i_bytes" {
     lvl25_ru9i_bytes:
         I8[] [102,111,108,100,108,49]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.187162806 UTC

[section ""data" . lvl26_ru9j_closure" {
     lvl26_ru9j_closure:
         const lvl26_ru9j_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_ru9j_entry() //  [R1]
         { []
         }
     {offset
       cwva: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwvb; else goto cwvc;
       cwvb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwvc: // global
           (_cwv7::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwv7::I64 == 0) goto cwv9; else goto cwv8;
       cwv9: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwv8: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwv7::I64;
           R2 = lvl25_ru9i_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl26_ru9j_info" {
     lvl26_ru9j_info:
         const lvl26_ru9j_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.191185459 UTC

[section ""data" . GHC.List.foldl2_closure" {
     GHC.List.foldl2_closure:
         const GHC.List.foldl2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.foldl2_entry() //  [R1]
         { []
         }
     {offset
       cwvq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwvr; else goto cwvs;
       cwvr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwvs: // global
           (_cwvn::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cwvn::I64 == 0) goto cwvp; else goto cwvo;
       cwvp: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cwvo: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cwvn::I64;
           R2 = lvl26_ru9j_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.foldl2_info" {
     GHC.List.foldl2_info:
         const GHC.List.foldl2_entry;
         const 0;
         const 12884901909;
         const Supf_srt+352;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.197414578 UTC

[section ""data" . $wgo2_ru9k_closure" {
     $wgo2_ru9k_closure:
         const $wgo2_ru9k_info;
 },
 ds_sucx_entry() //  [R1]
         { []
         }
     {offset
       cwvW: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cwvX; else goto cwvY;
       cwvX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwvY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cwvT_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgo2_ru9k_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ds_sucx_info" {
     ds_sucx_info:
         const ds_sucx_entry;
         const 1;
         const 16;
 },
 _cwvT() //  [R1, R2, R3]
         { []
         }
     {offset
       cwvT: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cww1; else goto cww0;
       cww1: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 24;
       cww0: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cwvT_info" {
     block_cwvT_info:
         const _cwvT;
         const 0;
         const 30;
 },
 $wgo2_ru9k_entry() //  [R2]
         { []
         }
     {offset
       cww6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cww7; else goto cww8;
       cww7: // global
           R2 = R2;
           R1 = $wgo2_ru9k_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cww8: // global
           I64[Sp - 8] = block_cwvE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwwm; else goto cwvF;
       uwwm: // global
           call _cwvE(R1) args: 0, res: 0, upd: 0;
       cwvF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . $wgo2_ru9k_info" {
     $wgo2_ru9k_info:
         const $wgo2_ru9k_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cwvE() //  [R1]
         { []
         }
     {offset
       cwvE: // global
           if (R1 & 7 == 1) goto cww3; else goto cww4;
       cww3: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       cww4: // global
           I64[Sp - 8] = block_cwvK_info;
           _sucs::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sucs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwwl; else goto cwvL;
       uwwl: // global
           call _cwvK(R1) args: 0, res: 0, upd: 0;
       cwvL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwvE_info" {
     block_cwvE_info:
         const _cwvE;
         const 0;
         const 30;
 },
 _cwvK() //  [R1]
         { []
         }
     {offset
       cwvK: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cwwk; else goto cwwj;
       cwwk: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwwj: // global
           _sucu::P64 = P64[R1 + 7];
           _sucv::P64 = P64[R1 + 15];
           _sucw::P64 = P64[R1 + 23];
           I64[Hp - 160] = ds_sucx_info;
           P64[Hp - 144] = P64[Sp + 8];
           I64[Hp - 136] = stg_sel_2_upd_info;
           _cwvP::P64 = Hp - 160;
           P64[Hp - 120] = _cwvP::P64;
           I64[Hp - 112] = :_con_info;
           P64[Hp - 104] = _sucw::P64;
           P64[Hp - 96] = Hp - 136;
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _cwvP::P64;
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = _sucv::P64;
           P64[Hp - 48] = Hp - 88;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cwvP::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sucu::P64;
           P64[Hp] = Hp - 40;
           R3 = Hp - 110;
           R2 = Hp - 62;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwvK_info" {
     block_cwvK_info:
         const _cwvK;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.208980607 UTC

[section ""data" . go_ru9l_closure" {
     go_ru9l_closure:
         const go_ru9l_info;
 },
 go_ru9l_entry() //  [R2]
         { []
         }
     {offset
       cwwX: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwwY; else goto cwwZ;
       cwwY: // global
           R2 = R2;
           R1 = go_ru9l_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwwZ: // global
           I64[Sp - 8] = block_cwwU_info;
           R2 = R2;
           Sp = Sp - 8;
           call $wgo2_ru9k_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_ru9l_info" {
     go_ru9l_info:
         const go_ru9l_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cwwU() //  [R1, R2, R3]
         { []
         }
     {offset
       cwwU: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cwx2; else goto cwx1;
       cwx2: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       cwx1: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwwU_info" {
     block_cwwU_info:
         const _cwwU;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.214016213 UTC

[section ""data" . GHC.List.unzip3_closure" {
     GHC.List.unzip3_closure:
         const GHC.List.unzip3_info;
 },
 GHC.List.unzip3_entry() //  [R2]
         { []
         }
     {offset
       cwxg: // global
           R2 = R2;
           call go_ru9l_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.unzip3_info" {
     GHC.List.unzip3_info:
         const GHC.List.unzip3_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.220050089 UTC

[section ""data" . $wgo3_ru9m_closure" {
     $wgo3_ru9m_closure:
         const $wgo3_ru9m_info;
 },
 ds_sud6_entry() //  [R1]
         { []
         }
     {offset
       cwxJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cwxK; else goto cwxL;
       cwxK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwxL: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cwxG_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgo3_ru9m_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ds_sud6_info" {
     ds_sud6_info:
         const ds_sud6_entry;
         const 1;
         const 16;
 },
 _cwxG() //  [R1, R2]
         { []
         }
     {offset
       cwxG: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwxO; else goto cwxN;
       cwxO: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cwxN: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cwxG_info" {
     block_cwxG_info:
         const _cwxG;
         const 0;
         const 30;
 },
 $wgo3_ru9m_entry() //  [R2]
         { []
         }
     {offset
       cwxT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwxU; else goto cwxV;
       cwxU: // global
           R2 = R2;
           R1 = $wgo3_ru9m_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwxV: // global
           I64[Sp - 8] = block_cwxr_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwy7; else goto cwxs;
       uwy7: // global
           call _cwxr(R1) args: 0, res: 0, upd: 0;
       cwxs: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . $wgo3_ru9m_info" {
     $wgo3_ru9m_info:
         const $wgo3_ru9m_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cwxr() //  [R1]
         { []
         }
     {offset
       cwxr: // global
           if (R1 & 7 == 1) goto cwxQ; else goto cwxR;
       cwxQ: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cwxR: // global
           I64[Sp - 8] = block_cwxx_info;
           _sud2::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sud2::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwy6; else goto cwxy;
       uwy6: // global
           call _cwxx(R1) args: 0, res: 0, upd: 0;
       cwxy: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwxr_info" {
     block_cwxr_info:
         const _cwxr;
         const 0;
         const 30;
 },
 _cwxx() //  [R1]
         { []
         }
     {offset
       cwxx: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cwy5; else goto cwy4;
       cwy5: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwy4: // global
           _sud4::P64 = P64[R1 + 7];
           _sud5::P64 = P64[R1 + 15];
           I64[Hp - 112] = ds_sud6_info;
           P64[Hp - 96] = P64[Sp + 8];
           I64[Hp - 88] = stg_sel_1_upd_info;
           _cwxC::P64 = Hp - 112;
           P64[Hp - 72] = _cwxC::P64;
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = _sud5::P64;
           P64[Hp - 48] = Hp - 88;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cwxC::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sud4::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 62;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwxx_info" {
     block_cwxx_info:
         const _cwxx;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.231278942 UTC

[section ""data" . go1_ru9n_closure" {
     go1_ru9n_closure:
         const go1_ru9n_info;
 },
 go1_ru9n_entry() //  [R2]
         { []
         }
     {offset
       cwyH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwyI; else goto cwyJ;
       cwyI: // global
           R2 = R2;
           R1 = go1_ru9n_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwyJ: // global
           I64[Sp - 8] = block_cwyE_info;
           R2 = R2;
           Sp = Sp - 8;
           call $wgo3_ru9m_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go1_ru9n_info" {
     go1_ru9n_info:
         const go1_ru9n_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cwyE() //  [R1, R2]
         { []
         }
     {offset
       cwyE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwyM; else goto cwyL;
       cwyM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cwyL: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwyE_info" {
     block_cwyE_info:
         const _cwyE;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.23684532 UTC

[section ""data" . GHC.List.unzip_closure" {
     GHC.List.unzip_closure:
         const GHC.List.unzip_info;
 },
 GHC.List.unzip_entry() //  [R2]
         { []
         }
     {offset
       cwz0: // global
           R2 = R2;
           call go1_ru9n_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.unzip_info" {
     GHC.List.unzip_info:
         const GHC.List.unzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.242624994 UTC

[section ""data" . GHC.List.zipWith3_closure" {
     GHC.List.zipWith3_closure:
         const GHC.List.zipWith3_info;
 },
 go2_suds_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cwzn: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cwzo; else goto cwzp;
       cwzo: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cwzp: // global
           I64[Sp - 40] = block_cwzg_info;
           _suds::P64 = R1;
           _sudo::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 32] = _sudo::P64;
           P64[Sp - 24] = _suds::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uwA6; else goto cwzh;
       uwA6: // global
           call _cwzg(R1) args: 0, res: 0, upd: 0;
       cwzh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go2_suds_info" {
     go2_suds_info:
         const go2_suds_entry;
         const 1;
         const 9;
         const 12884901911;
 },
 _cwzg() //  [R1]
         { []
         }
     {offset
       cwzg: // global
           if (R1 & 7 == 1) goto uwA1; else goto cwzl;
       uwA1: // global
           Sp = Sp + 40;
           call _cwzP() args: 0, res: 0, upd: 0;
       cwzl: // global
           I64[Sp - 8] = block_cwzv_info;
           _sudx::P64 = P64[R1 + 6];
           _sudy::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _sudy::P64;
           P64[Sp + 24] = _sudx::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwA4; else goto cwzx;
       uwA4: // global
           call _cwzv(R1) args: 0, res: 0, upd: 0;
       cwzx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwzg_info" {
     block_cwzg_info:
         const _cwzg;
         const 4;
         const 30;
 },
 _cwzv() //  [R1]
         { []
         }
     {offset
       cwzv: // global
           if (R1 & 7 == 1) goto uwA2; else goto cwzI;
       uwA2: // global
           Sp = Sp + 48;
           call _cwzP() args: 0, res: 0, upd: 0;
       cwzI: // global
           I64[Sp - 8] = block_cwzG_info;
           _sudA::P64 = P64[R1 + 6];
           _sudB::P64 = P64[R1 + 14];
           R1 = P64[Sp + 40];
           P64[Sp] = _sudB::P64;
           P64[Sp + 40] = _sudA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwA7; else goto cwzJ;
       uwA7: // global
           call _cwzG(R1) args: 0, res: 0, upd: 0;
       cwzJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwzv_info" {
     block_cwzv_info:
         const _cwzv;
         const 5;
         const 30;
 },
 _cwzG() //  [R1]
         { []
         }
     {offset
       cwzG: // global
           if (R1 & 7 == 1) goto uwA3; else goto cwzV;
       uwA3: // global
           Sp = Sp + 56;
           call _cwzP() args: 0, res: 0, upd: 0;
       cwzV: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cwzY; else goto cwzX;
       cwzY: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwzX: // global
           _sudD::P64 = P64[R1 + 6];
           _sudE::P64 = P64[R1 + 14];
           I64[Hp - 112] = stg_ap_4_upd_info;
           P64[Hp - 96] = P64[Sp + 32];
           P64[Hp - 88] = P64[Sp + 16];
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _sudE::P64;
           I64[Hp - 64] = stg_ap_4_upd_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 48];
           P64[Hp - 24] = _sudD::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 14;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwzG_info" {
     block_cwzG_info:
         const _cwzG;
         const 6;
         const 30;
 },
 _cwzP() //  []
         { []
         }
     {offset
       cwzP: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.zipWith3_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cwAa: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cwAe; else goto cwAd;
       cwAe: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipWith3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cwAd: // global
           I64[Hp - 8] = go2_suds_info;
           P64[Hp] = R2;
           _sudq::P64 = R4;
           R4 = R5;
           _sudp::P64 = R3;
           R3 = _sudq::P64;
           R2 = _sudp::P64;
           R1 = Hp - 5;
           call go2_suds_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.zipWith3_info" {
     GHC.List.zipWith3_info:
         const GHC.List.zipWith3_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.255537939 UTC

[section ""data" . GHC.List.zipWithFB_closure" {
     GHC.List.zipWithFB_closure:
         const GHC.List.zipWithFB_info;
 },
 GHC.List.zipWithFB_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cwAW: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cwB0; else goto cwAZ;
       cwB0: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipWithFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cwAZ: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R3 = R6;
           _sudH::P64 = R2;
           R2 = Hp - 32;
           R1 = _sudH::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.zipWithFB_info" {
     GHC.List.zipWithFB_info:
         const GHC.List.zipWithFB_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.261533966 UTC

[section ""data" . GHC.List.zip3_closure" {
     GHC.List.zip3_closure:
         const GHC.List.zip3_info;
 },
 sat_sue0_entry() //  [R1]
         { []
         }
     {offset
       cwBv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwBw; else goto cwBx;
       cwBw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwBx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.zip3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sue0_info" {
     sat_sue0_info:
         const sat_sue0_entry;
         const 3;
         const 15;
 },
 GHC.List.zip3_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cwBC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cwBD; else goto cwBE;
       cwBD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zip3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cwBE: // global
           I64[Sp - 24] = block_cwB9_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uwC8; else goto cwBa;
       uwC8: // global
           call _cwB9(R1) args: 0, res: 0, upd: 0;
       cwBa: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.zip3_info" {
     GHC.List.zip3_info:
         const GHC.List.zip3_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cwB9() //  [R1]
         { []
         }
     {offset
       cwB9: // global
           if (R1 & 7 == 1) goto uwC0; else goto cwBA;
       uwC0: // global
           Sp = Sp + 24;
           call _cwBR() args: 0, res: 0, upd: 0;
       cwBA: // global
           I64[Sp - 8] = block_cwBf_info;
           _sudR::P64 = P64[R1 + 6];
           _sudS::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sudS::P64;
           P64[Sp + 8] = _sudR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwC3; else goto cwBg;
       uwC3: // global
           call _cwBf(R1) args: 0, res: 0, upd: 0;
       cwBg: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwB9_info" {
     block_cwB9_info:
         const _cwB9;
         const 2;
         const 30;
 },
 _cwBf() //  [R1]
         { []
         }
     {offset
       cwBf: // global
           if (R1 & 7 == 1) goto uwC1; else goto cwBN;
       uwC1: // global
           Sp = Sp + 32;
           call _cwBR() args: 0, res: 0, upd: 0;
       cwBN: // global
           I64[Sp - 8] = block_cwBl_info;
           _sudU::P64 = P64[R1 + 6];
           _sudV::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _sudV::P64;
           P64[Sp + 24] = _sudU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwC5; else goto cwBm;
       uwC5: // global
           call _cwBl(R1) args: 0, res: 0, upd: 0;
       cwBm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwBf_info" {
     block_cwBf_info:
         const _cwBf;
         const 3;
         const 30;
 },
 _cwBl() //  [R1]
         { []
         }
     {offset
       cwBl: // global
           if (R1 & 7 == 1) goto uwC2; else goto cwBU;
       uwC2: // global
           Sp = Sp + 40;
           call _cwBR() args: 0, res: 0, upd: 0;
       cwBU: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cwBX; else goto cwBW;
       cwBX: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwBW: // global
           _sudX::P64 = P64[R1 + 6];
           _sudY::P64 = P64[R1 + 14];
           I64[Hp - 88] = sat_sue0_info;
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = _sudY::P64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sudX::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 47;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwBl_info" {
     block_cwBl_info:
         const _cwBl;
         const 4;
         const 30;
 },
 _cwBR() //  []
         { []
         }
     {offset
       cwBR: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.273982098 UTC

[section ""data" . GHC.List.zipFB_closure" {
     GHC.List.zipFB_closure:
         const GHC.List.zipFB_info;
 },
 GHC.List.zipFB_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cwCP: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwCT; else goto cwCS;
       cwCT: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cwCS: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = R5;
           _sue1::P64 = R2;
           R2 = Hp - 15;
           R1 = _sue1::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.zipFB_info" {
     GHC.List.zipFB_info:
         const GHC.List.zipFB_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.278800545 UTC

[section ""data" . GHC.List.foldr2_left_closure" {
     GHC.List.foldr2_left_closure:
         const GHC.List.foldr2_left_info;
 },
 GHC.List.foldr2_left_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cwD9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cwDa; else goto cwDb;
       cwDa: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldr2_left_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cwDb: // global
           I64[Sp - 40] = block_cwD2_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uwDl; else goto cwD3;
       uwDl: // global
           call _cwD2(R1) args: 0, res: 0, upd: 0;
       cwD3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.foldr2_left_info" {
     GHC.List.foldr2_left_info:
         const GHC.List.foldr2_left_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cwD2() //  [R1]
         { []
         }
     {offset
       cwD2: // global
           if (R1 & 7 == 1) goto cwD6; else goto cwD7;
       cwD6: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwD7: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cwDk; else goto cwDj;
       cwDk: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwDj: // global
           _suec::P64 = P64[R1 + 6];
           _sued::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sued::P64;
           R4 = Hp - 24;
           R3 = _suec::P64;
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwD2_info" {
     block_cwD2_info:
         const _cwD2;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.291483376 UTC

[section ""data" . GHC.List.zip_closure" {
     GHC.List.zip_closure:
         const GHC.List.zip_info;
 },
 sat_sueo_entry() //  [R1]
         { []
         }
     {offset
       cwDS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwDT; else goto cwDU;
       cwDT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwDU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.zip_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sueo_info" {
     sat_sueo_info:
         const sat_sueo_entry;
         const 2;
         const 18;
 },
 GHC.List.zip_entry() //  [R2, R3]
         { []
         }
     {offset
       cwDZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cwE0; else goto cwE1;
       cwE0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwE1: // global
           I64[Sp - 16] = block_cwDC_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwEl; else goto cwDD;
       uwEl: // global
           call _cwDC(R1) args: 0, res: 0, upd: 0;
       cwDD: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.zip_info" {
     GHC.List.zip_info:
         const GHC.List.zip_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cwDC() //  [R1]
         { []
         }
     {offset
       cwDC: // global
           if (R1 & 7 == 1) goto uwEg; else goto cwDX;
       uwEg: // global
           Sp = Sp + 16;
           call _cwE8() args: 0, res: 0, upd: 0;
       cwDX: // global
           I64[Sp - 8] = block_cwDI_info;
           _suei::P64 = P64[R1 + 6];
           _suej::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _suej::P64;
           P64[Sp + 8] = _suei::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwEi; else goto cwDJ;
       uwEi: // global
           call _cwDI(R1) args: 0, res: 0, upd: 0;
       cwDJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwDC_info" {
     block_cwDC_info:
         const _cwDC;
         const 1;
         const 30;
 },
 _cwDI() //  [R1]
         { []
         }
     {offset
       cwDI: // global
           if (R1 & 7 == 1) goto uwEh; else goto cwEb;
       uwEh: // global
           Sp = Sp + 24;
           call _cwE8() args: 0, res: 0, upd: 0;
       cwEb: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cwEe; else goto cwEd;
       cwEe: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwEd: // global
           _suel::P64 = P64[R1 + 6];
           _suem::P64 = P64[R1 + 14];
           I64[Hp - 72] = sat_sueo_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _suem::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _suel::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwDI_info" {
     block_cwDI_info:
         const _cwDI;
         const 2;
         const 30;
 },
 _cwE8() //  []
         { []
         }
     {offset
       cwE8: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.zipWith_closure" {
     GHC.List.zipWith_closure:
         const GHC.List.zipWith_info;
 },
 go2_sues_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cwEC: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cwED; else goto cwEE;
       cwED: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwEE: // global
           I64[Sp - 32] = block_cwEv_info;
           _sues::P64 = R1;
           _suep::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 24] = _suep::P64;
           P64[Sp - 16] = _sues::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uwF7; else goto cwEw;
       uwF7: // global
           call _cwEv(R1) args: 0, res: 0, upd: 0;
       cwEw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go2_sues_info" {
     go2_sues_info:
         const go2_sues_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 _cwEv() //  [R1]
         { []
         }
     {offset
       cwEv: // global
           if (R1 & 7 == 1) goto uwF3; else goto cwEA;
       uwF3: // global
           Sp = Sp + 32;
           call _cwES() args: 0, res: 0, upd: 0;
       cwEA: // global
           I64[Sp - 8] = block_cwEK_info;
           _suew::P64 = P64[R1 + 6];
           _suex::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _suex::P64;
           P64[Sp + 24] = _suew::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwF5; else goto cwEM;
       uwF5: // global
           call _cwEK(R1) args: 0, res: 0, upd: 0;
       cwEM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwEv_info" {
     block_cwEv_info:
         const _cwEv;
         const 3;
         const 30;
 },
 _cwEK() //  [R1]
         { []
         }
     {offset
       cwEK: // global
           if (R1 & 7 == 1) goto uwF4; else goto cwEY;
       uwF4: // global
           Sp = Sp + 40;
           call _cwES() args: 0, res: 0, upd: 0;
       cwEY: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cwF1; else goto cwF0;
       cwF1: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwF0: // global
           _suez::P64 = P64[R1 + 6];
           _sueA::P64 = P64[R1 + 14];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sueA::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _suez::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwEK_info" {
     block_cwEK_info:
         const _cwEK;
         const 4;
         const 30;
 },
 _cwES() //  []
         { []
         }
     {offset
       cwES: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.zipWith_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cwF9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cwFd; else goto cwFc;
       cwFd: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cwFc: // global
           I64[Hp - 8] = go2_sues_info;
           P64[Hp] = R2;
           _sueq::P64 = R3;
           R3 = R4;
           R2 = _sueq::P64;
           R1 = Hp - 6;
           call go2_sues_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.zipWith_info" {
     GHC.List.zipWith_info:
         const GHC.List.zipWith_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 section ""data" . GHC.List.foldr2_closure" {
     GHC.List.foldr2_closure:
         const GHC.List.foldr2_info;
 },
 go2_sueH_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cwFu: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cwFv; else goto cwFw;
       cwFv: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwFw: // global
           I64[Sp - 40] = block_cwFn_info;
           _sueH::P64 = R1;
           _sueD::P64 = P64[R1 + 6];
           _sueE::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 32] = _sueD::P64;
           P64[Sp - 24] = _sueE::P64;
           P64[Sp - 16] = _sueH::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uwFX; else goto cwFo;
       uwFX: // global
           call _cwFn(R1) args: 0, res: 0, upd: 0;
       cwFo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go2_sueH_info" {
     go2_sueH_info:
         const go2_sueH_entry;
         const 2;
         const 11;
         const 8589934607;
 },
 _cwFn() //  [R1]
         { []
         }
     {offset
       cwFn: // global
           if (R1 & 7 == 1) goto uwFT; else goto cwFs;
       uwFT: // global
           Sp = Sp + 16;
           call _cwFK() args: 0, res: 0, upd: 0;
       cwFs: // global
           I64[Sp - 8] = block_cwFC_info;
           _sueL::P64 = P64[R1 + 6];
           _sueM::P64 = P64[R1 + 14];
           R1 = P64[Sp + 32];
           P64[Sp] = _sueM::P64;
           P64[Sp + 32] = _sueL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwFV; else goto cwFE;
       uwFV: // global
           call _cwFC(R1) args: 0, res: 0, upd: 0;
       cwFE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwFn_info" {
     block_cwFn_info:
         const _cwFn;
         const 4;
         const 30;
 },
 _cwFC() //  [R1]
         { []
         }
     {offset
       cwFC: // global
           if (R1 & 7 == 1) goto uwFU; else goto cwFO;
       uwFU: // global
           Sp = Sp + 24;
           call _cwFK() args: 0, res: 0, upd: 0;
       cwFO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cwFR; else goto cwFQ;
       cwFR: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwFQ: // global
           _sueO::P64 = P64[R1 + 6];
           _sueP::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sueP::P64;
           R4 = Hp - 32;
           R3 = _sueO::P64;
           R2 = P64[Sp + 40];
           R1 = P64[Sp + 16];
           Sp = Sp + 48;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwFC_info" {
     block_cwFC_info:
         const _cwFC;
         const 5;
         const 30;
 },
 _cwFK() //  []
         { []
         }
     {offset
       cwFK: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.foldr2_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cwFZ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwG3; else goto cwG2;
       cwG3: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldr2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cwG2: // global
           I64[Hp - 16] = go2_sueH_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = R5;
           R2 = R4;
           R1 = Hp - 14;
           call go2_sueH_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.foldr2_info" {
     GHC.List.foldr2_info:
         const GHC.List.foldr2_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.319528229 UTC

[section ""data" . GHC.List.concat_go_closure" {
     GHC.List.concat_go_closure:
         const GHC.List.concat_go_info;
 },
 sat_sueV_entry() //  [R1]
         { []
         }
     {offset
       cwHD: // global
           R2 = P64[R1 + 16];
           call GHC.List.concat_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sueV_info" {
     sat_sueV_info:
         const sat_sueV_entry;
         const 1;
         const 16;
 },
 GHC.List.concat_go_entry() //  [R2]
         { []
         }
     {offset
       cwHK: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwHL; else goto cwHM;
       cwHL: // global
           R2 = R2;
           R1 = GHC.List.concat_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwHM: // global
           I64[Sp - 8] = block_cwHt_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwHS; else goto cwHu;
       uwHS: // global
           call _cwHt(R1) args: 0, res: 0, upd: 0;
       cwHu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.concat_go_info" {
     GHC.List.concat_go_info:
         const GHC.List.concat_go_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cwHt() //  [R1]
         { []
         }
     {offset
       cwHt: // global
           if (R1 & 7 == 1) goto cwHH; else goto cwHI;
       cwHH: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwHI: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwHR; else goto cwHQ;
       cwHR: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwHQ: // global
           _sueT::P64 = P64[R1 + 6];
           _sueU::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sueV_info;
           P64[Hp] = _sueU::P64;
           R3 = Hp - 16;
           R2 = _sueT::P64;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwHt_info" {
     block_cwHt_info:
         const _cwHt;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.326658798 UTC

[section ""data" . GHC.List.concat_closure" {
     GHC.List.concat_closure:
         const GHC.List.concat_info;
 },
 GHC.List.concat_entry() //  [R2]
         { []
         }
     {offset
       cwIc: // global
           R2 = R2;
           call GHC.List.concat_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.concat_info" {
     GHC.List.concat_info:
         const GHC.List.concat_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.332005874 UTC

[section ""data" . GHC.List.concatMap_closure" {
     GHC.List.concatMap_closure:
         const GHC.List.concatMap_info;
 },
 sat_suf4_entry() //  [R1]
         { []
         }
     {offset
       cwIC: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go2_sueY_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_suf4_info" {
     sat_suf4_info:
         const sat_suf4_entry;
         const 2;
         const 18;
 },
 go2_sueY_entry() //  [R1, R2]
         { []
         }
     {offset
       cwIJ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cwIK; else goto cwIL;
       cwIK: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cwIL: // global
           I64[Sp - 24] = block_cwIs_info;
           _sueY::P64 = R1;
           _sueW::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sueW::P64;
           P64[Sp - 8] = _sueY::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uwIW; else goto cwIt;
       uwIW: // global
           call _cwIs(R1) args: 0, res: 0, upd: 0;
       cwIt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go2_sueY_info" {
     go2_sueY_info:
         const go2_sueY_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _cwIs() //  [R1]
         { []
         }
     {offset
       cwIs: // global
           if (R1 & 7 == 1) goto cwIG; else goto cwIH;
       cwIG: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwIH: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cwIR; else goto cwIQ;
       cwIR: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwIQ: // global
           _suf1::P64 = P64[R1 + 6];
           _suf2::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_suf4_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _suf2::P64;
           _sueW::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cwIO_info;
           R2 = _suf1::P64;
           R1 = _sueW::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwIs_info" {
     block_cwIs_info:
         const _cwIs;
         const 2;
         const 30;
 },
 _cwIO() //  [R1]
         { []
         }
     {offset
       cwIO: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwIO_info" {
     block_cwIO_info:
         const _cwIO;
         const 1;
         const 30;
 },
 GHC.List.concatMap_entry() //  [R2, R3]
         { []
         }
     {offset
       cwIX: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cwJ1; else goto cwJ0;
       cwJ1: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.concatMap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwJ0: // global
           I64[Hp - 8] = go2_sueY_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go2_sueY_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.concatMap_info" {
     GHC.List.concatMap_info:
         const GHC.List.concatMap_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.344096112 UTC

[section ""data" . GHC.List.lookup_closure" {
     GHC.List.lookup_closure:
         const GHC.List.lookup_info;
 },
 GHC.List.lookup_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cwJA: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cwJB; else goto uwK4;
       cwJB: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.lookup_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uwK4: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cwJq() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.lookup_info" {
     GHC.List.lookup_info:
         const GHC.List.lookup_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cwJq() //  []
         { []
         }
     {offset
       cwJq: // global
           I64[Sp - 8] = block_cwJt_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwK6; else goto cwJu;
       uwK6: // global
           call _cwJt(R1) args: 0, res: 0, upd: 0;
       cwJu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwJt() //  [R1]
         { []
         }
     {offset
       cwJt: // global
           if (R1 & 7 == 1) goto cwJx; else goto cwJy;
       cwJx: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwJy: // global
           I64[Sp] = block_cwJI_info;
           _sufa::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _sufa::P64;
           if (R1 & 7 != 0) goto uwK7; else goto cwJK;
       uwK7: // global
           call _cwJI(R1) args: 0, res: 0, upd: 0;
       cwJK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwJt_info" {
     block_cwJt_info:
         const _cwJt;
         const 259;
         const 30;
 },
 _cwJI() //  [R1]
         { []
         }
     {offset
       cwJI: // global
           I64[Sp - 8] = block_cwJO_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwJI_info" {
     block_cwJI_info:
         const _cwJI;
         const 3;
         const 30;
 },
 _cwJO() //  [R1]
         { []
         }
     {offset
       cwJO: // global
           if (R1 & 7 == 1) goto cwJV; else goto cwJZ;
       cwJV: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           P64[Sp + 32] = P64[Sp + 32];
           Sp = Sp + 16;
           call _cwJq() args: 0, res: 0, upd: 0;
       cwJZ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cwK2; else goto cwK1;
       cwK2: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwK1: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwJO_info" {
     block_cwJO_info:
         const _cwJO;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.354972316 UTC

[section ""data" . GHC.List.notElem_closure" {
     GHC.List.notElem_closure:
         const GHC.List.notElem_info;
 },
 GHC.List.notElem_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cwKQ: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cwKR; else goto uwLb;
       cwKR: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.notElem_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uwLb: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cwKG() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.notElem_info" {
     GHC.List.notElem_info:
         const GHC.List.notElem_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cwKG() //  []
         { []
         }
     {offset
       cwKG: // global
           I64[Sp - 8] = block_cwKJ_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwLd; else goto cwKK;
       uwLd: // global
           call _cwKJ(R1) args: 0, res: 0, upd: 0;
       cwKK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwKJ() //  [R1]
         { []
         }
     {offset
       cwKJ: // global
           if (R1 & 7 == 1) goto cwKN; else goto cwKO;
       cwKN: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwKO: // global
           I64[Sp] = block_cwKY_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp + 24] = P64[R1 + 14];
           Sp = Sp - 24;
           call GHC.Classes./=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwKJ_info" {
     block_cwKJ_info:
         const _cwKJ;
         const 259;
         const 30;
 },
 _cwKY() //  [R1]
         { []
         }
     {offset
       cwKY: // global
           if (R1 & 7 == 1) goto cwL5; else goto cwL9;
       cwL5: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwL9: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cwKG() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cwKY_info" {
     block_cwKY_info:
         const _cwKY;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.36458338 UTC

[section ""data" . GHC.List.elem_closure" {
     GHC.List.elem_closure:
         const GHC.List.elem_info;
 },
 GHC.List.elem_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cwLR: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cwLS; else goto uwMc;
       cwLS: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.elem_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uwMc: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cwLH() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.elem_info" {
     GHC.List.elem_info:
         const GHC.List.elem_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cwLH() //  []
         { []
         }
     {offset
       cwLH: // global
           I64[Sp - 8] = block_cwLK_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwMe; else goto cwLL;
       uwMe: // global
           call _cwLK(R1) args: 0, res: 0, upd: 0;
       cwLL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwLK() //  [R1]
         { []
         }
     {offset
       cwLK: // global
           if (R1 & 7 == 1) goto cwLO; else goto cwLP;
       cwLO: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwLP: // global
           I64[Sp] = block_cwLZ_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp + 24] = P64[R1 + 14];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwLK_info" {
     block_cwLK_info:
         const _cwLK;
         const 259;
         const 30;
 },
 _cwLZ() //  [R1]
         { []
         }
     {offset
       cwLZ: // global
           if (R1 & 7 == 1) goto cwM6; else goto cwMa;
       cwM6: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cwLH() args: 0, res: 0, upd: 0;
       cwMa: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwLZ_info" {
     block_cwLZ_info:
         const _cwLZ;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.37402893 UTC

[section ""data" . GHC.List.all_closure" {
     GHC.List.all_closure:
         const GHC.List.all_info;
 },
 GHC.List.all_entry() //  [R2, R3]
         { []
         }
     {offset
       cwMS: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cwMT; else goto uwNd;
       cwMT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.all_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uwNd: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cwMI() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.all_info" {
     GHC.List.all_info:
         const GHC.List.all_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cwMI() //  []
         { []
         }
     {offset
       cwMI: // global
           I64[Sp - 8] = block_cwML_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwNf; else goto cwMM;
       uwNf: // global
           call _cwML(R1) args: 0, res: 0, upd: 0;
       cwMM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwML() //  [R1]
         { []
         }
     {offset
       cwML: // global
           if (R1 & 7 == 1) goto cwMP; else goto cwMQ;
       cwMP: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwMQ: // global
           I64[Sp] = block_cwN0_info;
           R2 = P64[R1 + 6];
           _sufx::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sufx::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwML_info" {
     block_cwML_info:
         const _cwML;
         const 130;
         const 30;
 },
 _cwN0() //  [R1]
         { []
         }
     {offset
       cwN0: // global
           if (R1 & 7 == 1) goto cwN7; else goto cwNb;
       cwN7: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwNb: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _cwMI() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cwN0_info" {
     block_cwN0_info:
         const _cwN0;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.38299001 UTC

[section ""data" . GHC.List.any_closure" {
     GHC.List.any_closure:
         const GHC.List.any_info;
 },
 GHC.List.any_entry() //  [R2, R3]
         { []
         }
     {offset
       cwNP: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cwNQ; else goto uwOa;
       cwNQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.any_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uwOa: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cwNF() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.any_info" {
     GHC.List.any_info:
         const GHC.List.any_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cwNF() //  []
         { []
         }
     {offset
       cwNF: // global
           I64[Sp - 8] = block_cwNI_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwOc; else goto cwNJ;
       uwOc: // global
           call _cwNI(R1) args: 0, res: 0, upd: 0;
       cwNJ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwNI() //  [R1]
         { []
         }
     {offset
       cwNI: // global
           if (R1 & 7 == 1) goto cwNM; else goto cwNN;
       cwNM: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwNN: // global
           I64[Sp] = block_cwNX_info;
           R2 = P64[R1 + 6];
           _sufD::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sufD::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwNI_info" {
     block_cwNI_info:
         const _cwNI;
         const 130;
         const 30;
 },
 _cwNX() //  [R1]
         { []
         }
     {offset
       cwNX: // global
           if (R1 & 7 == 1) goto cwO4; else goto cwO8;
       cwO4: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _cwNF() args: 0, res: 0, upd: 0;
       cwO8: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwNX_info" {
     block_cwNX_info:
         const _cwNX;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.391894892 UTC

[section ""data" . GHC.List.or_closure" {
     GHC.List.or_closure:
         const GHC.List.or_info;
 },
 GHC.List.or_entry() //  [R2]
         { []
         }
     {offset
       cwOM: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwON; else goto uwP8;
       cwON: // global
           R2 = R2;
           R1 = GHC.List.or_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uwP8: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cwOC() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.or_info" {
     GHC.List.or_info:
         const GHC.List.or_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cwOC() //  []
         { []
         }
     {offset
       cwOC: // global
           _sufF::P64 = P64[Sp];
           I64[Sp] = block_cwOF_info;
           R1 = _sufF::P64;
           if (R1 & 7 != 0) goto uwPa; else goto cwOG;
       uwPa: // global
           call _cwOF(R1) args: 0, res: 0, upd: 0;
       cwOG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwOF() //  [R1]
         { []
         }
     {offset
       cwOF: // global
           if (R1 & 7 == 1) goto cwOJ; else goto cwOK;
       cwOJ: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwOK: // global
           I64[Sp - 8] = block_cwOU_info;
           _sufI::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sufI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwPb; else goto cwOW;
       uwPb: // global
           call _cwOU(R1) args: 0, res: 0, upd: 0;
       cwOW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwOF_info" {
     block_cwOF_info:
         const _cwOF;
         const 0;
         const 30;
 },
 _cwOU() //  [R1]
         { []
         }
     {offset
       cwOU: // global
           if (R1 & 7 == 1) goto cwP2; else goto cwP6;
       cwP2: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cwOC() args: 0, res: 0, upd: 0;
       cwP6: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwOU_info" {
     block_cwOU_info:
         const _cwOU;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.400715361 UTC

[section ""data" . GHC.List.and_closure" {
     GHC.List.and_closure:
         const GHC.List.and_info;
 },
 GHC.List.and_entry() //  [R2]
         { []
         }
     {offset
       cwPL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwPM; else goto uwQ7;
       cwPM: // global
           R2 = R2;
           R1 = GHC.List.and_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uwQ7: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cwPB() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.and_info" {
     GHC.List.and_info:
         const GHC.List.and_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cwPB() //  []
         { []
         }
     {offset
       cwPB: // global
           _sufK::P64 = P64[Sp];
           I64[Sp] = block_cwPE_info;
           R1 = _sufK::P64;
           if (R1 & 7 != 0) goto uwQ9; else goto cwPF;
       uwQ9: // global
           call _cwPE(R1) args: 0, res: 0, upd: 0;
       cwPF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwPE() //  [R1]
         { []
         }
     {offset
       cwPE: // global
           if (R1 & 7 == 1) goto cwPI; else goto cwPJ;
       cwPI: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwPJ: // global
           I64[Sp - 8] = block_cwPT_info;
           _sufN::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sufN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwQa; else goto cwPV;
       uwQa: // global
           call _cwPT(R1) args: 0, res: 0, upd: 0;
       cwPV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwPE_info" {
     block_cwPE_info:
         const _cwPE;
         const 0;
         const 30;
 },
 _cwPT() //  [R1]
         { []
         }
     {offset
       cwPT: // global
           if (R1 & 7 == 1) goto cwQ1; else goto cwQ5;
       cwQ1: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwQ5: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cwPB() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cwPT_info" {
     block_cwPT_info:
         const _cwPT;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.410138233 UTC

[section ""data" . GHC.List.reverse1_closure" {
     GHC.List.reverse1_closure:
         const GHC.List.reverse1_info;
 },
 GHC.List.reverse1_entry() //  [R2, R3]
         { []
         }
     {offset
       cwQO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwQP; else goto uwQW;
       cwQP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.reverse1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uwQW: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cwQA() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.reverse1_info" {
     GHC.List.reverse1_info:
         const GHC.List.reverse1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cwQA() //  []
         { []
         }
     {offset
       cwQA: // global
           _sufP::P64 = P64[Sp];
           I64[Sp] = block_cwQD_info;
           R1 = _sufP::P64;
           if (R1 & 7 != 0) goto uwQY; else goto cwQE;
       uwQY: // global
           call _cwQD(R1) args: 0, res: 0, upd: 0;
       cwQE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwQD() //  [R1]
         { []
         }
     {offset
       cwQD: // global
           _sufQ::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cwQL; else goto cwQM;
       cwQL: // global
           R1 = _sufQ::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwQM: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwQV; else goto cwQU;
       cwQV: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwQU: // global
           _sufS::P64 = P64[R1 + 6];
           _sufT::P64 = P64[R1 + 14];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sufS::P64;
           P64[Hp] = _sufQ::P64;
           P64[Sp] = _sufT::P64;
           P64[Sp + 8] = Hp - 14;
           call _cwQA() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cwQD_info" {
     block_cwQD_info:
         const _cwQD;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.41636606 UTC

[section ""data" . GHC.List.reverse_closure" {
     GHC.List.reverse_closure:
         const GHC.List.reverse_info;
 },
 GHC.List.reverse_entry() //  [R2]
         { []
         }
     {offset
       cwRl: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = R2;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.reverse_info" {
     GHC.List.reverse_info:
         const GHC.List.reverse_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.422355921 UTC

[section ""data" . GHC.List.$wbreak_closure" {
     GHC.List.$wbreak_closure:
         const GHC.List.$wbreak_info;
 },
 ds_sug2_entry() //  [R1]
         { []
         }
     {offset
       cwRN: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cwRO; else goto cwRP;
       cwRO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwRP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cwRK_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wbreak_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ds_sug2_info" {
     ds_sug2_info:
         const ds_sug2_entry;
         const 2;
         const 18;
 },
 _cwRK() //  [R1, R2]
         { []
         }
     {offset
       cwRK: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwRS; else goto cwRR;
       cwRS: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cwRR: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cwRK_info" {
     block_cwRK_info:
         const _cwRK;
         const 0;
         const 30;
 },
 GHC.List.$wbreak_entry() //  [R2, R3]
         { []
         }
     {offset
       cwRX: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cwRY; else goto cwRZ;
       cwRY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wbreak_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwRZ: // global
           I64[Sp - 16] = block_cwRw_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwSg; else goto cwRx;
       uwSg: // global
           call _cwRw(R1) args: 0, res: 0, upd: 0;
       cwRx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.$wbreak_info" {
     GHC.List.$wbreak_info:
         const GHC.List.$wbreak_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cwRw() //  [R1]
         { []
         }
     {offset
       cwRw: // global
           if (R1 & 7 == 1) goto cwRU; else goto cwRV;
       cwRU: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cwRV: // global
           I64[Sp - 24] = block_cwRC_info;
           _sufZ::P64 = P64[R1 + 6];
           R2 = _sufZ::P64;
           _sufY::P64 = R1;
           _sug0::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp - 16] = _sufZ::P64;
           P64[Sp - 8] = _sug0::P64;
           P64[Sp] = _sufY::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwRw_info" {
     block_cwRw_info:
         const _cwRw;
         const 1;
         const 30;
 },
 _cwRC() //  [R1]
         { []
         }
     {offset
       cwRC: // global
           if (R1 & 7 == 1) goto cwS7; else goto cwSe;
       cwS7: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cwSa; else goto cwS9;
       cwSa: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwS9: // global
           I64[Hp - 96] = ds_sug2_info;
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 16];
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cwRG::P64 = Hp - 96;
           P64[Hp - 48] = _cwRG::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cwRG::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cwSe: // global
           R2 = P64[Sp + 24];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwRC_info" {
     block_cwRC_info:
         const _cwRC;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.43410953 UTC

[section ""data" . GHC.List.break_closure" {
     GHC.List.break_closure:
         const GHC.List.break_info;
 },
 GHC.List.break_entry() //  [R2, R3]
         { []
         }
     {offset
       cwST: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwSU; else goto cwSV;
       cwSU: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.break_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwSV: // global
           I64[Sp - 8] = block_cwSQ_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wbreak_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.break_info" {
     GHC.List.break_info:
         const GHC.List.break_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cwSQ() //  [R1, R2]
         { []
         }
     {offset
       cwSQ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwSY; else goto cwSX;
       cwSY: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cwSX: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwSQ_info" {
     block_cwSQ_info:
         const _cwSQ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.441664849 UTC

[section ""data" . GHC.List.$wspan_closure" {
     GHC.List.$wspan_closure:
         const GHC.List.$wspan_info;
 },
 ds_sugq_entry() //  [R1]
         { []
         }
     {offset
       cwTu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cwTv; else goto cwTw;
       cwTv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwTw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cwTr_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ds_sugq_info" {
     ds_sugq_info:
         const ds_sugq_entry;
         const 2;
         const 18;
 },
 _cwTr() //  [R1, R2]
         { []
         }
     {offset
       cwTr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwTz; else goto cwTy;
       cwTz: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cwTy: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cwTr_info" {
     block_cwTr_info:
         const _cwTr;
         const 0;
         const 30;
 },
 GHC.List.$wspan_entry() //  [R2, R3]
         { []
         }
     {offset
       cwTE: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cwTF; else goto cwTG;
       cwTF: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wspan_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwTG: // global
           I64[Sp - 16] = block_cwTc_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwTW; else goto cwTd;
       uwTW: // global
           call _cwTc(R1) args: 0, res: 0, upd: 0;
       cwTd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.$wspan_info" {
     GHC.List.$wspan_info:
         const GHC.List.$wspan_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cwTc() //  [R1]
         { []
         }
     {offset
       cwTc: // global
           if (R1 & 7 == 1) goto cwTB; else goto cwTC;
       cwTB: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cwTC: // global
           I64[Sp - 24] = block_cwTi_info;
           _sugn::P64 = P64[R1 + 6];
           R2 = _sugn::P64;
           _sugm::P64 = R1;
           _sugo::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp - 16] = _sugn::P64;
           P64[Sp - 8] = _sugo::P64;
           P64[Sp] = _sugm::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwTc_info" {
     block_cwTc_info:
         const _cwTc;
         const 1;
         const 30;
 },
 _cwTi() //  [R1]
         { []
         }
     {offset
       cwTi: // global
           if (R1 & 7 == 1) goto cwTN; else goto cwTR;
       cwTN: // global
           R2 = P64[Sp + 24];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cwTR: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cwTU; else goto cwTT;
       cwTU: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwTT: // global
           I64[Hp - 96] = ds_sugq_info;
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 16];
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cwTn::P64 = Hp - 96;
           P64[Hp - 48] = _cwTn::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cwTn::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwTi_info" {
     block_cwTi_info:
         const _cwTi;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.453474375 UTC

[section ""data" . GHC.List.span_closure" {
     GHC.List.span_closure:
         const GHC.List.span_info;
 },
 GHC.List.span_entry() //  [R2, R3]
         { []
         }
     {offset
       cwUz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cwUA; else goto cwUB;
       cwUA: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.span_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwUB: // global
           I64[Sp - 8] = block_cwUw_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.span_info" {
     GHC.List.span_info:
         const GHC.List.span_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cwUw() //  [R1, R2]
         { []
         }
     {offset
       cwUw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cwUE; else goto cwUD;
       cwUE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cwUD: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwUw_info" {
     block_cwUw_info:
         const _cwUw;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.459977429 UTC

[section ""data" . GHC.List.takeFB_closure" {
     GHC.List.takeFB_closure:
         const GHC.List.takeFB_info;
 },
 sat_sugS_entry() //  [R1]
         { []
         }
     {offset
       cwV5: // global
           _sugS::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cwV8; else goto cwV9;
       cwV9: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cwVb; else goto cwVa;
       cwVb: // global
           HpAlloc = 16;
           goto cwV8;
       cwV8: // global
           R1 = _sugS::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwVa: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sugS::P64;
           _sugL::P64 = P64[_sugS::P64 + 16];
           _sugQ::I64 = I64[_sugS::P64 + 24] - 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sugQ::I64;
           R2 = Hp - 7;
           R1 = _sugL::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sugS_info" {
     sat_sugS_info:
         const sat_sugS_entry;
         const 4294967297;
         const 19;
 },
 GHC.List.takeFB_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cwVc: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cwVd; else goto cwVe;
       cwVd: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.takeFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cwVe: // global
           I64[Sp - 40] = block_cwUS_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uwVl; else goto cwUT;
       uwVl: // global
           call _cwUS(R1) args: 0, res: 0, upd: 0;
       cwUT: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.takeFB_info" {
     GHC.List.takeFB_info:
         const GHC.List.takeFB_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cwUS() //  [R1]
         { []
         }
     {offset
       cwUS: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cwVh; else goto cwVg;
       cwVh: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwVg: // global
           _sugI::P64 = P64[Sp + 8];
           _sugK::P64 = P64[Sp + 24];
           _sugP::I64 = I64[R1 + 7];
           if (_sugP::I64 != 1) goto cwVj; else goto cwVk;
       cwVj: // global
           I64[Hp - 24] = sat_sugS_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = _sugP::I64;
           R3 = Hp - 24;
           R2 = _sugK::P64;
           R1 = _sugI::P64;
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwVk: // global
           Hp = Hp - 32;
           R3 = P64[Sp + 16];
           R2 = _sugK::P64;
           R1 = _sugI::P64;
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwUS_info" {
     block_cwUS_info:
         const _cwUS;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.468506028 UTC

[section ""data" . GHC.List.flipSeqTake_closure" {
     GHC.List.flipSeqTake_closure:
         const GHC.List.flipSeqTake_info;
 },
 GHC.List.flipSeqTake_entry() //  [R2, R3]
         { []
         }
     {offset
       cwVI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwVJ; else goto cwVK;
       cwVJ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.flipSeqTake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwVK: // global
           I64[Sp - 16] = block_cwVF_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwVO; else goto cwVG;
       uwVO: // global
           call _cwVF() args: 0, res: 0, upd: 0;
       cwVG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.flipSeqTake_info" {
     GHC.List.flipSeqTake_info:
         const GHC.List.flipSeqTake_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cwVF() //  []
         { []
         }
     {offset
       cwVF: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwVF_info" {
     block_cwVF_info:
         const _cwVF;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.47519546 UTC

[section ""data" . GHC.List.$wunsafeTake_closure" {
     GHC.List.$wunsafeTake_closure:
         const GHC.List.$wunsafeTake_info;
 },
 sat_suh4_entry() //  [R1]
         { []
         }
     {offset
       cwWg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwWh; else goto cwWi;
       cwWh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwWi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24] - 1;
           Sp = Sp - 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_suh4_info" {
     sat_suh4_info:
         const sat_suh4_entry;
         const 4294967297;
         const 19;
 },
 GHC.List.$wunsafeTake_entry() //  [R2, R3]
         { []
         }
     {offset
       cwWn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwWo; else goto cwWp;
       cwWo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wunsafeTake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwWp: // global
           I64[Sp - 16] = block_cwW2_info;
           R1 = R3;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwWB; else goto cwW3;
       uwWB: // global
           call _cwW2(R1) args: 0, res: 0, upd: 0;
       cwW3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.$wunsafeTake_info" {
     GHC.List.$wunsafeTake_info:
         const GHC.List.$wunsafeTake_entry;
         const 0;
         const 14;
         const 8589934605;
 },
 _cwW2() //  [R1]
         { []
         }
     {offset
       cwW2: // global
           if (R1 & 7 == 1) goto cwWk; else goto cwWl;
       cwWk: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwWl: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cwWu; else goto cwWt;
       cwWu: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwWt: // global
           _suh0::P64 = P64[R1 + 6];
           _suh2::I64 = I64[Sp + 8];
           if (_suh2::I64 != 1) goto cwWx; else goto cwWA;
       cwWx: // global
           _suh1::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_suh4_info;
           P64[Hp - 32] = _suh1::P64;
           I64[Hp - 24] = _suh2::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _suh0::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwWA: // global
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = _suh0::P64;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cwWz::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cwWz::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwW2_info" {
     block_cwW2_info:
         const _cwW2;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.483400125 UTC

[section ""data" . GHC.List.unsafeTake_closure" {
     GHC.List.unsafeTake_closure:
         const GHC.List.unsafeTake_info;
 },
 GHC.List.unsafeTake_entry() //  [R2, R3]
         { []
         }
     {offset
       cwX3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwX4; else goto cwX5;
       cwX4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.unsafeTake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwX5: // global
           I64[Sp - 16] = block_cwX0_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwX9; else goto cwX1;
       uwX9: // global
           call _cwX0(R1) args: 0, res: 0, upd: 0;
       cwX1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.unsafeTake_info" {
     GHC.List.unsafeTake_info:
         const GHC.List.unsafeTake_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cwX0() //  [R1]
         { []
         }
     {offset
       cwX0: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwX0_info" {
     block_cwX0_info:
         const _cwX0;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.488853221 UTC

[section ""data" . GHC.List.take_closure" {
     GHC.List.take_closure:
         const GHC.List.take_info;
 },
 GHC.List.take_entry() //  [R2, R3]
         { []
         }
     {offset
       cwXq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwXr; else goto cwXs;
       cwXr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.take_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwXs: // global
           I64[Sp - 16] = block_cwXn_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwXB; else goto cwXo;
       uwXB: // global
           call _cwXn(R1) args: 0, res: 0, upd: 0;
       cwXo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.take_info" {
     GHC.List.take_info:
         const GHC.List.take_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cwXn() //  [R1]
         { []
         }
     {offset
       cwXn: // global
           _suhc::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(0, _suhc::I64)) goto cwXz; else goto cwXA;
       cwXz: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwXA: // global
           R3 = P64[Sp + 8];
           R2 = _suhc::I64;
           Sp = Sp + 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwXn_info" {
     block_cwXn_info:
         const _cwXn;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.495944507 UTC

[section ""data" . GHC.List.dropWhile_closure" {
     GHC.List.dropWhile_closure:
         const GHC.List.dropWhile_info;
 },
 GHC.List.dropWhile_entry() //  [R2, R3]
         { []
         }
     {offset
       cwXX: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cwXY; else goto uwYi;
       cwXY: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.dropWhile_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uwYi: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cwXN() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.dropWhile_info" {
     GHC.List.dropWhile_info:
         const GHC.List.dropWhile_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cwXN() //  []
         { []
         }
     {offset
       cwXN: // global
           I64[Sp - 8] = block_cwXQ_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uwYk; else goto cwXR;
       uwYk: // global
           call _cwXQ(R1) args: 0, res: 0, upd: 0;
       cwXR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cwXQ() //  [R1]
         { []
         }
     {offset
       cwXQ: // global
           if (R1 & 7 == 1) goto cwXU; else goto cwXV;
       cwXU: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cwXV: // global
           I64[Sp - 8] = block_cwY5_info;
           R2 = P64[R1 + 6];
           _suhg::P64 = R1;
           _suhi::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _suhi::P64;
           P64[Sp + 16] = _suhg::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwXQ_info" {
     block_cwXQ_info:
         const _cwXQ;
         const 130;
         const 30;
 },
 _cwY5() //  [R1]
         { []
         }
     {offset
       cwY5: // global
           if (R1 & 7 == 1) goto cwYc; else goto cwYg;
       cwYc: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cwYg: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cwXN() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cwY5_info" {
     block_cwY5_info:
         const _cwY5;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.504236702 UTC

[section ""data" . GHC.List.takeWhileFB_closure" {
     GHC.List.takeWhileFB_closure:
         const GHC.List.takeWhileFB_info;
 },
 GHC.List.takeWhileFB_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cwYU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cwYV; else goto cwYW;
       cwYV: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.takeWhileFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cwYW: // global
           I64[Sp - 40] = block_cwYO_info;
           _suhk::P64 = R2;
           R2 = R5;
           R1 = _suhk::P64;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.takeWhileFB_info" {
     GHC.List.takeWhileFB_info:
         const GHC.List.takeWhileFB_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cwYO() //  [R1]
         { []
         }
     {offset
       cwYO: // global
           if (R1 & 7 == 1) goto cwYR; else goto cwYS;
       cwYR: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cwYS: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwYO_info" {
     block_cwYO_info:
         const _cwYO;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.511496518 UTC

[section ""data" . GHC.List.takeWhile_closure" {
     GHC.List.takeWhile_closure:
         const GHC.List.takeWhile_info;
 },
 sat_suhw_entry() //  [R1]
         { []
         }
     {offset
       cwZw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cwZx; else goto cwZy;
       cwZx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cwZy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.takeWhile_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_suhw_info" {
     sat_suhw_info:
         const sat_suhw_entry;
         const 2;
         const 18;
 },
 GHC.List.takeWhile_entry() //  [R2, R3]
         { []
         }
     {offset
       cwZD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cwZE; else goto cwZF;
       cwZE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.takeWhile_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cwZF: // global
           I64[Sp - 16] = block_cwZh_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uwZX; else goto cwZi;
       uwZX: // global
           call _cwZh(R1) args: 0, res: 0, upd: 0;
       cwZi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.takeWhile_info" {
     GHC.List.takeWhile_info:
         const GHC.List.takeWhile_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cwZh() //  [R1]
         { []
         }
     {offset
       cwZh: // global
           if (R1 & 7 == 1) goto uwZT; else goto cwZB;
       uwZT: // global
           Sp = Sp + 16;
           call _cwZM() args: 0, res: 0, upd: 0;
       cwZB: // global
           I64[Sp - 16] = block_cwZn_info;
           _suht::P64 = P64[R1 + 6];
           R2 = _suht::P64;
           _suhu::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _suhu::P64;
           P64[Sp] = _suht::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cwZh_info" {
     block_cwZh_info:
         const _cwZh;
         const 1;
         const 30;
 },
 _cwZn() //  [R1]
         { []
         }
     {offset
       cwZn: // global
           if (R1 & 7 == 1) goto uwZU; else goto cwZO;
       uwZU: // global
           Sp = Sp + 32;
           call _cwZM() args: 0, res: 0, upd: 0;
       cwZO: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cwZR; else goto cwZQ;
       cwZR: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cwZQ: // global
           I64[Hp - 48] = sat_suhw_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cwZn_info" {
     block_cwZn_info:
         const _cwZn;
         const 3;
         const 30;
 },
 _cwZM() //  []
         { []
         }
     {offset
       cwZM: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.52143195 UTC

[section ""data" . GHC.List.repeat_closure" {
     GHC.List.repeat_closure:
         const GHC.List.repeat_info;
 },
 GHC.List.repeat_entry() //  [R2]
         { []
         }
     {offset
       cx0v: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx0z; else goto cx0y;
       cx0z: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.List.repeat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cx0y: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           _cx0u::P64 = Hp - 14;
           P64[Hp] = _cx0u::P64;
           R1 = _cx0u::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.repeat_info" {
     GHC.List.repeat_info:
         const GHC.List.repeat_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 section ""data" . GHC.List.repeatFB_closure" {
     GHC.List.repeatFB_closure:
         const GHC.List.repeatFB_info;
 },
 GHC.List.repeatFB_entry() //  [R2, R3]
         { []
         }
     {offset
       cx0F: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cx0J; else goto cx0I;
       cx0J: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.repeatFB_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cx0I: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           _cx0E::P64 = Hp - 32;
           P64[Hp] = _cx0E::P64;
           R1 = _cx0E::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.repeatFB_info" {
     GHC.List.repeatFB_info:
         const GHC.List.repeatFB_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.529819196 UTC

[section ""data" . GHC.List.replicate_closure" {
     GHC.List.replicate_closure:
         const GHC.List.replicate_info;
 },
 sat_suhM_entry() //  [R1]
         { []
         }
     {offset
       cx1k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cx1l; else goto cx1m;
       cx1l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cx1m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_suhI_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_suhM_info" {
     sat_suhM_info:
         const sat_suhM_entry;
         const 4294967297;
         const 19;
 },
 $wxs_suhI_entry() //  [R1, R2]
         { []
         }
     {offset
       cx1q: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cx1u; else goto cx1t;
       cx1u: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cx1t: // global
           if (R2 == 1) goto cx1p; else goto cx1o;
       cx1p: // global
           _suhH::P64 = P64[R1 + 15];
           Hp = Hp - 56;
           R1 = _suhH::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cx1o: // global
           _suhD::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_suhM_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _suhD::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . $wxs_suhI_info" {
     $wxs_suhI_info:
         const $wxs_suhI_entry;
         const 2;
         const 11;
         const 4294967300;
 },
 GHC.List.replicate_entry() //  [R2, R3]
         { []
         }
     {offset
       cx1w: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cx1x; else goto cx1y;
       cx1x: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.replicate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cx1y: // global
           I64[Sp - 16] = block_cx0X_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ux1F; else goto cx0Y;
       ux1F: // global
           call _cx0X(R1) args: 0, res: 0, upd: 0;
       cx0Y: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.replicate_info" {
     GHC.List.replicate_info:
         const GHC.List.replicate_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cx0X() //  [R1]
         { []
         }
     {offset
       cx0X: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cx1B; else goto cx1A;
       cx1B: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cx1A: // global
           _suhF::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(0, _suhF::I64)) goto cx1D; else goto cx1E;
       cx1D: // global
           Hp = Hp - 48;
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cx1E: // global
           I64[Hp - 40] = :_con_info;
           _suhD::P64 = P64[Sp + 8];
           P64[Hp - 32] = _suhD::P64;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           I64[Hp - 16] = $wxs_suhI_info;
           P64[Hp - 8] = _suhD::P64;
           P64[Hp] = Hp - 38;
           R2 = _suhF::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call $wxs_suhI_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cx0X_info" {
     block_cx0X_info:
         const _cx0X;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.540630667 UTC

[section ""data" . GHC.List.$witerate'_closure" {
     GHC.List.$witerate'_closure:
         const GHC.List.$witerate'_info;
 },
 sat_suhT_entry() //  [R1]
         { []
         }
     {offset
       cx2f: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cx2g; else goto cx2h;
       cx2g: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cx2h: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cx2c_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$witerate'_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_suhT_info" {
     sat_suhT_info:
         const sat_suhT_entry;
         const 2;
         const 18;
 },
 _cx2c() //  [R1, R2]
         { []
         }
     {offset
       cx2c: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx2k; else goto cx2j;
       cx2k: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cx2j: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cx2c_info" {
     block_cx2c_info:
         const _cx2c;
         const 0;
         const 30;
 },
 GHC.List.$witerate'_entry() //  [R2, R3]
         { []
         }
     {offset
       cx2l: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cx2m; else goto cx2n;
       cx2m: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$witerate'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cx2n: // global
           I64[Sp - 24] = block_cx26_info;
           _suhN::P64 = R2;
           R2 = R3;
           R1 = _suhN::P64;
           P64[Sp - 16] = _suhN::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.$witerate'_info" {
     GHC.List.$witerate'_info:
         const GHC.List.$witerate'_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cx26() //  [R1]
         { []
         }
     {offset
       cx26: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cx2q; else goto cx2p;
       cx2q: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cx2p: // global
           I64[Hp - 24] = sat_suhT_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = Hp - 24;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cx26_info" {
     block_cx26_info:
         const _cx26;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.552060531 UTC

[section ""data" . GHC.List.iterate'FB_closure" {
     GHC.List.iterate'FB_closure:
         const GHC.List.iterate'FB_info;
 },
 go2_suhX_entry() //  [R1, R2]
         { []
         }
     {offset
       cx2V: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cx2W; else goto cx2X;
       cx2W: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cx2X: // global
           I64[Sp - 32] = block_cx2S_info;
           _suhY::P64 = R2;
           R2 = R2;
           _suhX::P64 = R1;
           _suhU::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp - 24] = _suhU::P64;
           P64[Sp - 16] = _suhX::P64;
           P64[Sp - 8] = _suhY::P64;
           Sp = Sp - 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go2_suhX_info" {
     go2_suhX_info:
         const go2_suhX_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _cx2S() //  [R1]
         { []
         }
     {offset
       cx2S: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cx30; else goto cx2Z;
       cx30: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cx2Z: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cx2S_info" {
     block_cx2S_info:
         const _cx2S;
         const 3;
         const 30;
 },
 GHC.List.iterate'FB_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cx31: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx35; else goto cx34;
       cx35: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterate'FB_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cx34: // global
           I64[Hp - 16] = go2_suhX_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = R4;
           R1 = Hp - 15;
           call go2_suhX_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.iterate'FB_info" {
     GHC.List.iterate'FB_info:
         const GHC.List.iterate'FB_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 section ""data" . GHC.List.iterate'_closure" {
     GHC.List.iterate'_closure:
         const GHC.List.iterate'_info;
 },
 GHC.List.iterate'_entry() //  [R2, R3]
         { []
         }
     {offset
       cx3d: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cx3e; else goto cx3f;
       cx3e: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterate'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cx3f: // global
           I64[Sp - 8] = block_cx3a_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$witerate'_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.iterate'_info" {
     GHC.List.iterate'_info:
         const GHC.List.iterate'_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cx3a() //  [R1, R2]
         { []
         }
     {offset
       cx3a: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx3i; else goto cx3h;
       cx3i: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cx3h: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cx3a_info" {
     block_cx3a_info:
         const _cx3a;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.564049942 UTC

[section ""data" . GHC.List.$witerate_closure" {
     GHC.List.$witerate_closure:
         const GHC.List.$witerate_info;
 },
 sat_suic_entry() //  [R1]
         { []
         }
     {offset
       cx3Q: // global
           _suic::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cx3R; else goto cx3S;
       cx3S: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cx3U; else goto cx3T;
       cx3U: // global
           HpAlloc = 32;
           goto cx3R;
       cx3R: // global
           R1 = _suic::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cx3T: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _suic::P64;
           _sui6::P64 = P64[_suic::P64 + 16];
           _sui7::P64 = P64[_suic::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sui6::P64;
           P64[Hp] = _sui7::P64;
           I64[Sp - 24] = block_cx3N_info;
           R3 = Hp - 24;
           R2 = _sui6::P64;
           Sp = Sp - 24;
           call GHC.List.$witerate_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_suic_info" {
     sat_suic_info:
         const sat_suic_entry;
         const 2;
         const 18;
 },
 _cx3N() //  [R1, R2]
         { []
         }
     {offset
       cx3N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx3X; else goto cx3W;
       cx3X: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cx3W: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cx3N_info" {
     block_cx3N_info:
         const _cx3N;
         const 0;
         const 30;
 },
 GHC.List.$witerate_entry() //  [R2, R3]
         { []
         }
     {offset
       cx3Y: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cx42; else goto cx41;
       cx42: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$witerate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cx41: // global
           I64[Hp - 24] = sat_suic_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = R3;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.$witerate_info" {
     GHC.List.$witerate_info:
         const GHC.List.$witerate_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.573663521 UTC

[section ""data" . GHC.List.iterateFB_closure" {
     GHC.List.iterateFB_closure:
         const GHC.List.iterateFB_info;
 },
 sat_suij_entry() //  [R1]
         { []
         }
     {offset
       cx4u: // global
           _suij::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cx4v; else goto cx4w;
       cx4w: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cx4y; else goto cx4x;
       cx4y: // global
           HpAlloc = 32;
           goto cx4v;
       cx4v: // global
           R1 = _suij::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cx4x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _suij::P64;
           _suie::P64 = P64[_suij::P64 + 16];
           _suig::P64 = P64[_suij::P64 + 24];
           _suih::P64 = P64[_suij::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _suie::P64;
           P64[Hp] = _suih::P64;
           R2 = Hp - 24;
           R1 = _suig::P64;
           Sp = Sp - 16;
           call go2_suig_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_suij_info" {
     sat_suij_info:
         const sat_suij_entry;
         const 3;
         const 15;
 },
 go2_suig_entry() //  [R1, R2]
         { []
         }
     {offset
       cx4z: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cx4D; else goto cx4C;
       cx4D: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cx4C: // global
           _suid::P64 = P64[R1 + 7];
           _suie::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_suij_info;
           P64[Hp - 16] = _suie::P64;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 32;
           R2 = R2;
           R1 = _suid::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go2_suig_info" {
     go2_suig_info:
         const go2_suig_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 GHC.List.iterateFB_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cx4E: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx4I; else goto cx4H;
       cx4I: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterateFB_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cx4H: // global
           I64[Hp - 16] = go2_suig_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = R4;
           R1 = Hp - 15;
           call go2_suig_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.iterateFB_info" {
     GHC.List.iterateFB_info:
         const GHC.List.iterateFB_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 section ""data" . GHC.List.iterate_closure" {
     GHC.List.iterate_closure:
         const GHC.List.iterate_info;
 },
 GHC.List.iterate_entry() //  [R2, R3]
         { []
         }
     {offset
       cx4Q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cx4R; else goto cx4S;
       cx4R: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cx4S: // global
           I64[Sp - 8] = block_cx4N_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$witerate_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.iterate_info" {
     GHC.List.iterate_info:
         const GHC.List.iterate_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cx4N() //  [R1, R2]
         { []
         }
     {offset
       cx4N: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx4V; else goto cx4U;
       cx4V: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cx4U: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cx4N_info" {
     block_cx4N_info:
         const _cx4N;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.585155583 UTC

[section ""cstring" . lvl27_ru9o_bytes" {
     lvl27_ru9o_bytes:
         I8[] [71,72,67,47,76,105,115,116,46,104,115,58,52,49,49,58,51,52,45,53,53,124,113,115,64,40,113,32,58,32,95,41]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.587582596 UTC

[section ""data" . lvl28_ru9p_closure" {
     lvl28_ru9p_closure:
         const lvl28_ru9p_info;
         const 0;
         const 0;
         const 0;
 },
 lvl28_ru9p_entry() //  [R1]
         { []
         }
     {offset
       cx5n: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cx5o; else goto cx5p;
       cx5o: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cx5p: // global
           (_cx5k::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cx5k::I64 == 0) goto cx5m; else goto cx5l;
       cx5m: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cx5l: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cx5k::I64;
           R2 = lvl27_ru9o_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl28_ru9p_info" {
     lvl28_ru9p_info:
         const lvl28_ru9p_entry;
         const 0;
         const 4294967317;
         const Supf_srt+368;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.595400402 UTC

[section ""data" . GHC.List.scanr1_closure" {
     GHC.List.scanr1_closure:
         const GHC.List.scanr1_info;
         const 0;
 },
 ds3_suix_entry() //  [R1]
         { []
         }
     {offset
       cx5X: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cx5Y; else goto cx5Z;
       cx5Y: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cx5Z: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cx5R_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.scanr1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ds3_suix_info" {
     ds3_suix_info:
         const ds3_suix_entry;
         const 2;
         const 12884901906;
         const Supf_srt+376;
 },
 _cx5R() //  [R1]
         { []
         }
     {offset
       cx5R: // global
           if (R1 & 7 == 1) goto cx5U; else goto cx5V;
       cx5U: // global
           R1 = lvl28_ru9p_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cx5V: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx68; else goto cx67;
       cx68: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cx67: // global
           _suiz::P64 = P64[R1 + 6];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = _suiz::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cx5R_info" {
     block_cx5R_info:
         const _cx5R;
         const 0;
         const 4294967326;
         const Supf_srt+384;
 },
 sat_suiF_entry() //  [R1]
         { []
         }
     {offset
       cx6f: // global
           _suiF::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cx6g; else goto cx6h;
       cx6h: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx6j; else goto cx6i;
       cx6j: // global
           HpAlloc = 24;
           goto cx6g;
       cx6g: // global
           R1 = _suiF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cx6i: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _suiF::P64;
           _suip::P64 = P64[_suiF::P64 + 16];
           _suis::P64 = P64[_suiF::P64 + 24];
           _suix::P64 = P64[_suiF::P64 + 32];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _suix::P64;
           R3 = Hp - 16;
           R2 = _suis::P64;
           R1 = _suip::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_suiF_info" {
     sat_suiF_info:
         const sat_suiF_entry;
         const 3;
         const 15;
 },
 GHC.List.scanr1_entry() //  [R2, R3]
         { []
         }
     {offset
       cx6o: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cx6p; else goto cx6q;
       cx6p: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cx6q: // global
           I64[Sp - 16] = block_cx5B_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ux6I; else goto cx5C;
       ux6I: // global
           call _cx5B(R1) args: 0, res: 0, upd: 0;
       cx5C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.scanr1_info" {
     GHC.List.scanr1_info:
         const GHC.List.scanr1_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const Supf_srt+376;
 },
 _cx5B() //  [R1]
         { []
         }
     {offset
       cx5B: // global
           if (R1 & 7 == 1) goto cx6l; else goto cx6m;
       cx6l: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cx6m: // global
           I64[Sp - 8] = block_cx5H_info;
           _suis::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _suis::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ux6H; else goto cx5I;
       ux6H: // global
           call _cx5H(R1) args: 0, res: 0, upd: 0;
       cx5I: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cx5B_info" {
     block_cx5B_info:
         const _cx5B;
         const 1;
         const 12884901918;
         const Supf_srt+376;
 },
 _cx5H() //  [R1]
         { []
         }
     {offset
       cx5H: // global
           _suis::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cx6x; else goto cx6C;
       cx6x: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx6A; else goto cx6z;
       cx6A: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cx6z: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _suis::P64;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cx6C: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cx6F; else goto cx6E;
       cx6F: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cx6E: // global
           I64[Hp - 112] = ds3_suix_info;
           _suip::P64 = P64[Sp + 16];
           P64[Hp - 96] = _suip::P64;
           P64[Hp - 88] = R1;
           I64[Hp - 80] = stg_sel_0_upd_info;
           _cx5N::P64 = Hp - 112;
           P64[Hp - 64] = _cx5N::P64;
           I64[Hp - 56] = sat_suiF_info;
           P64[Hp - 40] = _suip::P64;
           P64[Hp - 32] = _suis::P64;
           P64[Hp - 24] = _cx5N::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cx5H_info" {
     block_cx5H_info:
         const _cx5H;
         const 2;
         const 12884901918;
         const Supf_srt+376;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.60963908 UTC

[section ""data" . GHC.List.scanrFB_closure" {
     GHC.List.scanrFB_closure:
         const GHC.List.scanrFB_info;
 },
 GHC.List.scanrFB_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cx7r: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cx7x; else goto cx7y;
       cx7x: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanrFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cx7y: // global
           I64[Sp - 32] = block_cx7o_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ux7C; else goto cx7p;
       ux7C: // global
           call _cx7o(R1) args: 0, res: 0, upd: 0;
       cx7p: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.scanrFB_info" {
     GHC.List.scanrFB_info:
         const GHC.List.scanrFB_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _cx7o() //  [R1]
         { []
         }
     {offset
       cx7o: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cx7B; else goto cx7A;
       cx7B: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cx7A: // global
           _suiP::P64 = P64[R1 + 7];
           _suiQ::P64 = P64[R1 + 15];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _suiP::P64;
           P64[Hp - 64] = _suiQ::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _suiP::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cx7o_info" {
     block_cx7o_info:
         const _cx7o;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.617968265 UTC

[section ""data" . GHC.List.$wscanr_closure" {
     GHC.List.$wscanr_closure:
         const GHC.List.$wscanr_info;
 },
 ds_suiZ_entry() //  [R1]
         { []
         }
     {offset
       cx8a: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cx8b; else goto cx8c;
       cx8b: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cx8c: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cx86_info;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wscanr_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ds_suiZ_info" {
     ds_suiZ_info:
         const ds_suiZ_entry;
         const 3;
         const 15;
 },
 _cx86() //  [R1, R2]
         { []
         }
     {offset
       cx86: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cx8f; else goto cx8e;
       cx8f: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cx8e: // global
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cx86_info" {
     block_cx86_info:
         const _cx86;
         const 0;
         const 30;
 },
 sat_suj8_entry() //  [R1]
         { []
         }
     {offset
       cx8m: // global
           _suj8::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cx8n; else goto cx8o;
       cx8o: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx8q; else goto cx8p;
       cx8q: // global
           HpAlloc = 24;
           goto cx8n;
       cx8n: // global
           R1 = _suj8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cx8p: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _suj8::P64;
           _suiT::P64 = P64[_suj8::P64 + 16];
           _suiX::P64 = P64[_suj8::P64 + 24];
           _suiZ::P64 = P64[_suj8::P64 + 32];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _suiZ::P64;
           R3 = Hp - 16;
           R2 = _suiX::P64;
           R1 = _suiT::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_suj8_info" {
     sat_suj8_info:
         const sat_suj8_entry;
         const 3;
         const 15;
 },
 GHC.List.$wscanr_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cx8v: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cx8w; else goto cx8x;
       cx8w: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wscanr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cx8x: // global
           I64[Sp - 24] = block_cx7W_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ux8D; else goto cx7X;
       ux8D: // global
           call _cx7W(R1) args: 0, res: 0, upd: 0;
       cx7X: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.$wscanr_info" {
     GHC.List.$wscanr_info:
         const GHC.List.$wscanr_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cx7W() //  [R1]
         { []
         }
     {offset
       cx7W: // global
           _suiU::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cx8s; else goto cx8t;
       cx8s: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = _suiU::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cx8t: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cx8C; else goto cx8B;
       cx8C: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cx8B: // global
           _suiX::P64 = P64[R1 + 6];
           _suiY::P64 = P64[R1 + 14];
           I64[Hp - 96] = ds_suiZ_info;
           _suiT::P64 = P64[Sp + 8];
           P64[Hp - 80] = _suiT::P64;
           P64[Hp - 72] = _suiU::P64;
           P64[Hp - 64] = _suiY::P64;
           I64[Hp - 56] = stg_sel_0_upd_info;
           _cx82::P64 = Hp - 96;
           P64[Hp - 40] = _cx82::P64;
           I64[Hp - 32] = sat_suj8_info;
           P64[Hp - 16] = _suiT::P64;
           P64[Hp - 8] = _suiX::P64;
           P64[Hp] = _cx82::P64;
           R2 = Hp - 56;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cx7W_info" {
     block_cx7W_info:
         const _cx7W;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.631020237 UTC

[section ""data" . GHC.List.strictUncurryScanr_closure" {
     GHC.List.strictUncurryScanr_closure:
         const GHC.List.strictUncurryScanr_info;
 },
 GHC.List.strictUncurryScanr_entry() //  [R2, R3]
         { []
         }
     {offset
       cx9b: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cx9c; else goto cx9d;
       cx9c: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.strictUncurryScanr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cx9d: // global
           I64[Sp - 16] = block_cx98_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ux9h; else goto cx99;
       ux9h: // global
           call _cx98(R1) args: 0, res: 0, upd: 0;
       cx99: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.strictUncurryScanr_info" {
     GHC.List.strictUncurryScanr_info:
         const GHC.List.strictUncurryScanr_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cx98() //  [R1]
         { []
         }
     {offset
       cx98: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cx98_info" {
     block_cx98_info:
         const _cx98;
         const 1;
         const 30;
 },
 section ""data" . GHC.List.scanr_closure" {
     GHC.List.scanr_closure:
         const GHC.List.scanr_info;
 },
 GHC.List.scanr_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cx9p: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cx9q; else goto cx9r;
       cx9q: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cx9r: // global
           I64[Sp - 8] = block_cx9m_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wscanr_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.scanr_info" {
     GHC.List.scanr_info:
         const GHC.List.scanr_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cx9m() //  [R1, R2]
         { []
         }
     {offset
       cx9m: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cx9u; else goto cx9t;
       cx9u: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cx9t: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cx9m_info" {
     block_cx9m_info:
         const _cx9m;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.640668589 UTC

[section ""data" . GHC.List.flipSeqScanl'_closure" {
     GHC.List.flipSeqScanl'_closure:
         const GHC.List.flipSeqScanl'_info;
 },
 GHC.List.flipSeqScanl'_entry() //  [R2, R3]
         { []
         }
     {offset
       cx9T: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cx9U; else goto cx9V;
       cx9U: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.flipSeqScanl'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cx9V: // global
           I64[Sp - 16] = block_cx9R_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.flipSeqScanl'_info" {
     GHC.List.flipSeqScanl'_info:
         const GHC.List.flipSeqScanl'_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cx9R() //  []
         { []
         }
     {offset
       cx9R: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cx9R_info" {
     block_cx9R_info:
         const _cx9R;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.646467236 UTC

[section ""data" . GHC.List.scanlFB'_closure" {
     GHC.List.scanlFB'_closure:
         const GHC.List.scanlFB'_info;
 },
 GHC.List.scanlFB'_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cxac: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cxad; else goto cxae;
       cxad: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanlFB'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cxae: // global
           I64[Sp - 24] = block_cxa9_info;
           _sujs::P64 = R3;
           R3 = R4;
           _sujr::P64 = R2;
           R2 = R6;
           R1 = _sujr::P64;
           P64[Sp - 16] = _sujs::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.scanlFB'_info" {
     GHC.List.scanlFB'_info:
         const GHC.List.scanlFB'_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cxa9() //  [R1]
         { []
         }
     {offset
       cxa9: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cxah; else goto cxag;
       cxah: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxag: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxa9_info" {
     block_cxa9_info:
         const _cxa9;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.654314872 UTC

[section ""data" . GHC.List.$wscanlGo'_closure" {
     GHC.List.$wscanlGo'_closure:
         const GHC.List.$wscanlGo'_info;
 },
 sat_sujJ_entry() //  [R1]
         { []
         }
     {offset
       cxaI: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cxaJ; else goto cxaK;
       cxaJ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxaK: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cxaB_info;
           _sujy::P64 = P64[R1 + 16];
           _sujB::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sujy::P64;
           P64[Sp - 24] = _sujB::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uxb0; else goto cxaC;
       uxb0: // global
           call _cxaB(R1) args: 0, res: 0, upd: 0;
       cxaC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sujJ_info" {
     sat_sujJ_info:
         const sat_sujJ_entry;
         const 3;
         const 15;
 },
 _cxaB() //  [R1]
         { []
         }
     {offset
       cxaB: // global
           if (R1 & 7 == 1) goto cxaF; else goto cxaG;
       cxaF: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cxaG: // global
           I64[Sp] = block_cxaQ_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           _sujE::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sujE::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cxaB_info" {
     block_cxaB_info:
         const _cxaB;
         const 2;
         const 30;
 },
 _cxaQ() //  [R1]
         { []
         }
     {offset
       cxaQ: // global
           _sujE::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cxaS_info;
           R4 = _sujE::P64;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.$wscanlGo'_entry(R4,
                                          R3,
                                          R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cxaQ_info" {
     block_cxaQ_info:
         const _cxaQ;
         const 2;
         const 30;
 },
 _cxaS() //  [R1, R2]
         { []
         }
     {offset
       cxaS: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cxaZ; else goto cxaY;
       cxaZ: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cxaY: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cxaS_info" {
     block_cxaS_info:
         const _cxaS;
         const 0;
         const 30;
 },
 GHC.List.$wscanlGo'_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cxb1: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cxb2; else goto cxb3;
       cxb2: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wscanlGo'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cxb3: // global
           I64[Sp - 24] = block_cxav_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.$wscanlGo'_info" {
     GHC.List.$wscanlGo'_info:
         const GHC.List.$wscanlGo'_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cxav() //  [R1]
         { []
         }
     {offset
       cxav: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cxb6; else goto cxb5;
       cxb6: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxb5: // global
           I64[Hp - 32] = sat_sujJ_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R2 = Hp - 32;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxav_info" {
     block_cxav_info:
         const _cxav;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.667672907 UTC

[section ""data" . GHC.List.scanl'_scanlGo'_closure" {
     GHC.List.scanl'_scanlGo'_closure:
         const GHC.List.scanl'_scanlGo'_info;
 },
 GHC.List.scanl'_scanlGo'_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cxbH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxbI; else goto cxbJ;
       cxbI: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanl'_scanlGo'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cxbJ: // global
           I64[Sp - 8] = block_cxbE_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wscanlGo'_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.scanl'_scanlGo'_info" {
     GHC.List.scanl'_scanlGo'_info:
         const GHC.List.scanl'_scanlGo'_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cxbE() //  [R1, R2]
         { []
         }
     {offset
       cxbE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cxbM; else goto cxbL;
       cxbM: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cxbL: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxbE_info" {
     block_cxbE_info:
         const _cxbE;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.673122721 UTC

[section ""data" . GHC.List.scanl'_closure" {
     GHC.List.scanl'_closure:
         const GHC.List.scanl'_info;
 },
 GHC.List.scanl'_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cxc0: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.List.scanl'_scanlGo'_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.scanl'_info" {
     GHC.List.scanl'_info:
         const GHC.List.scanl'_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.676358099 UTC

[section ""data" . GHC.List.constScanl_closure" {
     GHC.List.constScanl_closure:
         const GHC.List.constScanl_info;
 },
 GHC.List.constScanl_entry() //  [R2, R3]
         { []
         }
     {offset
       cxcb: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.const_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.constScanl_info" {
     GHC.List.constScanl_info:
         const GHC.List.constScanl_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.680545397 UTC

[section ""data" . GHC.List.scanlFB_closure" {
     GHC.List.scanlFB_closure:
         const GHC.List.scanlFB_info;
 },
 GHC.List.scanlFB_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cxco: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cxcs; else goto cxcr;
       cxcs: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanlFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cxcr: // global
           I64[Hp - 64] = stg_ap_3_upd_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R6;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R5;
           _cxcm::P64 = Hp - 64;
           P64[Hp] = _cxcm::P64;
           _sujR::P64 = R3;
           R3 = Hp - 24;
           R2 = _cxcm::P64;
           R1 = _sujR::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.scanlFB_info" {
     GHC.List.scanlFB_info:
         const GHC.List.scanlFB_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.686265012 UTC

[section ""data" . GHC.List.$wscanlGo_closure" {
     GHC.List.$wscanlGo_closure:
         const GHC.List.$wscanlGo_info;
 },
 sat_suk7_entry() //  [R1]
         { []
         }
     {offset
       cxcM: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cxcN; else goto cxcO;
       cxcN: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxcO: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cxcF_info;
           _sujX::P64 = P64[R1 + 16];
           _sujY::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sujX::P64;
           P64[Sp - 24] = _sujY::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uxd4; else goto cxcG;
       uxd4: // global
           call _cxcF(R1) args: 0, res: 0, upd: 0;
       cxcG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_suk7_info" {
     sat_suk7_info:
         const sat_suk7_entry;
         const 3;
         const 15;
 },
 _cxcF() //  [R1]
         { []
         }
     {offset
       cxcF: // global
           if (R1 & 7 == 1) goto cxcJ; else goto cxcK;
       cxcJ: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cxcK: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cxd0; else goto cxcZ;
       cxd0: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cxcZ: // global
           _suk1::P64 = P64[R1 + 6];
           _suk2::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           _sujX::P64 = P64[Sp + 8];
           P64[Hp - 16] = _sujX::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _suk1::P64;
           I64[Sp + 16] = block_cxcV_info;
           R4 = _suk2::P64;
           R3 = Hp - 32;
           R2 = _sujX::P64;
           Sp = Sp + 16;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cxcF_info" {
     block_cxcF_info:
         const _cxcF;
         const 2;
         const 30;
 },
 _cxcV() //  [R1, R2]
         { []
         }
     {offset
       cxcV: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cxd3; else goto cxd2;
       cxd3: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cxd2: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cxcV_info" {
     block_cxcV_info:
         const _cxcV;
         const 0;
         const 30;
 },
 GHC.List.$wscanlGo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cxd5: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cxd9; else goto cxd8;
       cxd9: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wscanlGo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cxd8: // global
           I64[Hp - 32] = sat_suk7_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = R3;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.$wscanlGo_info" {
     GHC.List.$wscanlGo_info:
         const GHC.List.$wscanlGo_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.696581387 UTC

[section ""data" . GHC.List.scanl_scanlGo_closure" {
     GHC.List.scanl_scanlGo_closure:
         const GHC.List.scanl_scanlGo_info;
 },
 GHC.List.scanl_scanlGo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cxdC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxdD; else goto cxdE;
       cxdD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanl_scanlGo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cxdE: // global
           I64[Sp - 8] = block_cxdz_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.scanl_scanlGo_info" {
     GHC.List.scanl_scanlGo_info:
         const GHC.List.scanl_scanlGo_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cxdz() //  [R1, R2]
         { []
         }
     {offset
       cxdz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cxdH; else goto cxdG;
       cxdH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cxdG: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxdz_info" {
     block_cxdz_info:
         const _cxdz;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.701816036 UTC

[section ""data" . GHC.List.scanl_closure" {
     GHC.List.scanl_closure:
         const GHC.List.scanl_info;
 },
 GHC.List.scanl_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cxdV: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.List.scanl_scanlGo_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.scanl_info" {
     GHC.List.scanl_info:
         const GHC.List.scanl_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.707815347 UTC

[section ""data" . GHC.List.scanl1_closure" {
     GHC.List.scanl1_closure:
         const GHC.List.scanl1_info;
 },
 sat_sukm_entry() //  [R1]
         { []
         }
     {offset
       cxei: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cxej; else goto cxek;
       cxej: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxek: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cxeg_info;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sukm_info" {
     sat_sukm_info:
         const sat_sukm_entry;
         const 3;
         const 15;
 },
 _cxeg() //  [R2]
         { []
         }
     {offset
       cxeg: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cxeg_info" {
     block_cxeg_info:
         const _cxeg;
         const 0;
         const 30;
 },
 GHC.List.scanl1_entry() //  [R2, R3]
         { []
         }
     {offset
       cxeq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxer; else goto cxes;
       cxer: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanl1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxes: // global
           I64[Sp - 16] = block_cxe6_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uxez; else goto cxe7;
       uxez: // global
           call _cxe6(R1) args: 0, res: 0, upd: 0;
       cxe7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.scanl1_info" {
     GHC.List.scanl1_info:
         const GHC.List.scanl1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cxe6() //  [R1]
         { []
         }
     {offset
       cxe6: // global
           if (R1 & 7 == 1) goto cxen; else goto cxeo;
       cxen: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cxeo: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cxey; else goto cxex;
       cxey: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxex: // global
           _sukh::P64 = P64[R1 + 6];
           _suki::P64 = P64[R1 + 14];
           I64[Hp - 56] = sat_sukm_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sukh::P64;
           P64[Hp - 24] = _suki::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sukh::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxe6_info" {
     block_cxe6_info:
         const _cxe6;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.717676721 UTC

[section ""data" . GHC.List.foldl'_closure" {
     GHC.List.foldl'_closure:
         const GHC.List.foldl'_info;
 },
 GHC.List.foldl'_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cxf4: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cxf5; else goto cxf6;
       cxf5: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cxf6: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cxf8() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.foldl'_info" {
     GHC.List.foldl'_info:
         const GHC.List.foldl'_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cxf8() //  []
         { []
         }
     {offset
       cxf8: // global
           I64[Sp - 8] = block_cxfa_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxfx; else goto cxfc;
       uxfx: // global
           call _cxfa(R1) args: 0, res: 0, upd: 0;
       cxfc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxfa() //  [R1]
         { []
         }
     {offset
       cxfa: // global
           _suks::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cxfi; else goto cxfp;
       cxfi: // global
           R1 = _suks::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxfp: // global
           I64[Sp] = block_cxfl_info;
           _suku::P64 = P64[R1 + 6];
           _sukv::P64 = P64[R1 + 14];
           R1 = _suks::P64;
           P64[Sp + 16] = _sukv::P64;
           P64[Sp + 24] = _suku::P64;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cxfa_info" {
     block_cxfa_info:
         const _cxfa;
         const 131;
         const 30;
 },
 _cxfl() //  [R1]
         { []
         }
     {offset
       cxfl: // global
           I64[Sp] = block_cxfn_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           R1 = P64[Sp + 8];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cxfl_info" {
     block_cxfl_info:
         const _cxfl;
         const 3;
         const 30;
 },
 _cxfn() //  [R1]
         { []
         }
     {offset
       cxfn: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cxf8() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cxfn_info" {
     block_cxfn_info:
         const _cxfn;
         const 259;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.727704954 UTC

[section ""data" . GHC.List.foldl1'_closure" {
     GHC.List.foldl1'_closure:
         const GHC.List.foldl1'_info;
         const 0;
 },
 GHC.List.foldl1'_entry() //  [R2, R3]
         { []
         }
     {offset
       cxg4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxg5; else goto cxg6;
       cxg5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl1'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxg6: // global
           I64[Sp - 16] = block_cxfX_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uxgd; else goto cxfY;
       uxgd: // global
           call _cxfX(R1) args: 0, res: 0, upd: 0;
       cxfY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.foldl1'_info" {
     GHC.List.foldl1'_info:
         const GHC.List.foldl1'_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const Supf_srt+392;
 },
 _cxfX() //  [R1]
         { []
         }
     {offset
       cxfX: // global
           if (R1 & 7 == 1) goto cxg1; else goto cxg2;
       cxg1: // global
           R1 = GHC.List.foldl1'1_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxg2: // global
           R4 = P64[R1 + 14];
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.foldl'_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxfX_info" {
     block_cxfX_info:
         const _cxfX;
         const 1;
         const 4294967326;
         const Supf_srt+400;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.733413701 UTC

[section ""data" . sat_sukD_closure" {
     sat_sukD_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.735475435 UTC

[section ""data" . sat_sukE_closure" {
     sat_sukE_closure:
         const :_con_info;
         const sat_sukD_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.738448843 UTC

[section ""data" . lvl29_ru9q_closure" {
     lvl29_ru9q_closure:
         const lvl29_ru9q_info;
         const 0;
         const 0;
         const 0;
 },
 lvl29_ru9q_entry() //  [R1]
         { []
         }
     {offset
       cxgx: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxgy; else goto cxgz;
       cxgy: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxgz: // global
           (_cxgu::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxgu::I64 == 0) goto cxgw; else goto cxgv;
       cxgw: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxgv: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxgu::I64;
           R3 = sat_sukE_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl29_ru9q_info" {
     lvl29_ru9q_info:
         const lvl29_ru9q_entry;
         const 0;
         const 4294967317;
         const Supf_srt+408;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.742738977 UTC

[section ""data" . lvl30_ru9r_closure" {
     lvl30_ru9r_closure:
         const lvl30_ru9r_info;
         const 0;
         const 0;
         const 0;
 },
 lvl30_ru9r_entry() //  [R1]
         { []
         }
     {offset
       cxgN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxgO; else goto cxgP;
       cxgO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxgP: // global
           (_cxgK::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxgK::I64 == 0) goto cxgM; else goto cxgL;
       cxgM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxgL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxgK::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl30_ru9r_info" {
     lvl30_ru9r_info:
         const lvl30_ru9r_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.748758205 UTC

[section ""data" . GHC.List.foldl_closure" {
     GHC.List.foldl_closure:
         const GHC.List.foldl_info;
 },
 GHC.List.foldl_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cxhd: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cxhe; else goto cxhf;
       cxhe: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cxhf: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cxh4() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.foldl_info" {
     GHC.List.foldl_info:
         const GHC.List.foldl_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cxh4() //  []
         { []
         }
     {offset
       cxh4: // global
           I64[Sp - 8] = block_cxh6_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxhs; else goto cxh7;
       uxhs: // global
           call _cxh6(R1) args: 0, res: 0, upd: 0;
       cxh7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxh6() //  [R1]
         { []
         }
     {offset
       cxh6: // global
           _sukK::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cxhk; else goto cxhl;
       cxhk: // global
           R1 = _sukK::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxhl: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cxho; else goto cxhn;
       cxho: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxhn: // global
           _sukM::P64 = P64[R1 + 6];
           _sukN::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sukK::P64;
           P64[Hp] = _sukM::P64;
           P64[Sp + 16] = _sukN::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call _cxh4() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cxh6_info" {
     block_cxh6_info:
         const _cxh6;
         const 131;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.757506646 UTC

[section ""data" . GHC.List.sum_closure" {
     GHC.List.sum_closure:
         const GHC.List.sum_info;
         const 0;
 },
 sat_sukR_entry() //  [R1]
         { []
         }
     {offset
       cxhS: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cxhT; else goto cxhU;
       cxhT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxhU: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl30_ru9r_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sukR_info" {
     sat_sukR_info:
         const sat_sukR_entry;
         const 1;
         const 4294967312;
         const Supf_srt+416;
 },
 sat_sukQ_entry() //  [R1]
         { []
         }
     {offset
       cxhZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxi0; else goto cxi1;
       cxi0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxi1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sukQ_info" {
     sat_sukQ_info:
         const sat_sukQ_entry;
         const 1;
         const 16;
 },
 GHC.List.sum_entry() //  [R2]
         { []
         }
     {offset
       cxi2: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cxi6; else goto cxi5;
       cxi6: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.List.sum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxi5: // global
           I64[Hp - 40] = sat_sukR_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sukQ_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = GHC.List.foldl_closure+3;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.sum_info" {
     GHC.List.sum_info:
         const GHC.List.sum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const Supf_srt+416;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.766054169 UTC

[section ""data" . GHC.List.product_closure" {
     GHC.List.product_closure:
         const GHC.List.product_info;
         const 0;
 },
 sat_sukU_entry() //  [R1]
         { []
         }
     {offset
       cxir: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cxis; else goto cxit;
       cxis: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxit: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl29_ru9q_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sukU_info" {
     sat_sukU_info:
         const sat_sukU_entry;
         const 1;
         const 4294967312;
         const Supf_srt+432;
 },
 sat_sukT_entry() //  [R1]
         { []
         }
     {offset
       cxiy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxiz; else goto cxiA;
       cxiz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxiA: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sukT_info" {
     sat_sukT_info:
         const sat_sukT_entry;
         const 1;
         const 16;
 },
 GHC.List.product_entry() //  [R2]
         { []
         }
     {offset
       cxiB: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cxiF; else goto cxiE;
       cxiF: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.List.product_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxiE: // global
           I64[Hp - 40] = sat_sukU_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sukT_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = GHC.List.foldl_closure+3;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.product_info" {
     GHC.List.product_info:
         const GHC.List.product_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const Supf_srt+432;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.776522918 UTC

[section ""data" . GHC.List.foldl1_closure" {
     GHC.List.foldl1_closure:
         const GHC.List.foldl1_info;
         const 0;
 },
 GHC.List.foldl1_entry() //  [R2, R3]
         { []
         }
     {offset
       cxj3: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxj4; else goto cxj5;
       cxj4: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxj5: // global
           I64[Sp - 16] = block_cxiW_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uxjc; else goto cxiX;
       uxjc: // global
           call _cxiW(R1) args: 0, res: 0, upd: 0;
       cxiX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.foldl1_info" {
     GHC.List.foldl1_info:
         const GHC.List.foldl1_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const Supf_srt+448;
 },
 _cxiW() //  [R1]
         { []
         }
     {offset
       cxiW: // global
           if (R1 & 7 == 1) goto cxj0; else goto cxj1;
       cxj0: // global
           R1 = GHC.List.foldl2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxj1: // global
           R4 = P64[R1 + 14];
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.foldl_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxiW_info" {
     block_cxiW_info:
         const _cxiW;
         const 1;
         const 4294967326;
         const Supf_srt+456;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.784614896 UTC

[section ""data" . GHC.List.filterFB_closure" {
     GHC.List.filterFB_closure:
         const GHC.List.filterFB_info;
 },
 GHC.List.filterFB_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cxjy: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cxjz; else goto cxjA;
       cxjz: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.filterFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cxjA: // global
           I64[Sp - 32] = block_cxjs_info;
           _sul0::P64 = R2;
           R2 = R4;
           R1 = R3;
           P64[Sp - 24] = _sul0::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.filterFB_info" {
     GHC.List.filterFB_info:
         const GHC.List.filterFB_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _cxjs() //  [R1]
         { []
         }
     {offset
       cxjs: // global
           _sul3::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cxjv; else goto cxjw;
       cxjv: // global
           R1 = _sul3::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxjw: // global
           R3 = _sul3::P64;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxjs_info" {
     block_cxjs_info:
         const _cxjs;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.793088791 UTC

[section ""data" . GHC.List.filter_closure" {
     GHC.List.filter_closure:
         const GHC.List.filter_info;
 },
 sat_sulb_entry() //  [R1]
         { []
         }
     {offset
       cxka: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxkb; else goto cxkc;
       cxkb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxkc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.filter_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sulb_info" {
     sat_sulb_info:
         const sat_sulb_entry;
         const 2;
         const 18;
 },
 GHC.List.filter_entry() //  [R2, R3]
         { []
         }
     {offset
       cxkh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cxki; else goto uxkx;
       cxki: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.filter_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uxkx: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cxjS() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.filter_info" {
     GHC.List.filter_info:
         const GHC.List.filter_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cxjS() //  []
         { []
         }
     {offset
       cxjS: // global
           I64[Sp - 8] = block_cxjV_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxkz; else goto cxjW;
       uxkz: // global
           call _cxjV(R1) args: 0, res: 0, upd: 0;
       cxjW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxjV() //  [R1]
         { []
         }
     {offset
       cxjV: // global
           if (R1 & 7 == 1) goto cxke; else goto cxkf;
       cxke: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cxkf: // global
           I64[Sp - 8] = block_cxk1_info;
           _sul8::P64 = P64[R1 + 6];
           R2 = _sul8::P64;
           _sul9::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sul9::P64;
           P64[Sp + 16] = _sul8::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cxjV_info" {
     block_cxjV_info:
         const _cxjV;
         const 130;
         const 30;
 },
 _cxk1() //  [R1]
         { []
         }
     {offset
       cxk1: // global
           _sul5::P64 = P64[Sp + 16];
           _sul9::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cxkq; else goto cxks;
       cxkq: // global
           P64[Sp + 16] = _sul5::P64;
           P64[Sp + 24] = _sul9::P64;
           Sp = Sp + 16;
           call _cxjS() args: 0, res: 0, upd: 0;
       cxks: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cxkv; else goto cxku;
       cxkv: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxku: // global
           I64[Hp - 48] = sat_sulb_info;
           P64[Hp - 32] = _sul5::P64;
           P64[Hp - 24] = _sul9::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxk1_info" {
     block_cxk1_info:
         const _cxk1;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.80331873 UTC

[section ""data" . GHC.List.idLength_closure" {
     GHC.List.idLength_closure:
         const GHC.List.idLength_info;
 },
 GHC.List.idLength_entry() //  [R2]
         { []
         }
     {offset
       cxl6: // global
           R2 = R2;
           call GHC.Base.id_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.idLength_info" {
     GHC.List.idLength_info:
         const GHC.List.idLength_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.807305609 UTC

[section ""data" . GHC.List.lengthFB_closure" {
     GHC.List.lengthFB_closure:
         const GHC.List.lengthFB_info;
 },
 GHC.List.lengthFB_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cxlk: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxlr; else goto cxls;
       cxlr: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.lengthFB_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cxls: // global
           I64[Sp - 16] = block_cxlh_info;
           R1 = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uxlw; else goto cxli;
       uxlw: // global
           call _cxlh(R1) args: 0, res: 0, upd: 0;
       cxli: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.lengthFB_info" {
     GHC.List.lengthFB_info:
         const GHC.List.lengthFB_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cxlh() //  [R1]
         { []
         }
     {offset
       cxlh: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cxlv; else goto cxlu;
       cxlv: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxlu: // global
           _sulh::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sulh::I64;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxlh_info" {
     block_cxlh_info:
         const _cxlh;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.813813938 UTC

[section ""data" . GHC.List.$wlenAcc_closure" {
     GHC.List.$wlenAcc_closure:
         const GHC.List.$wlenAcc_info;
 },
 GHC.List.$wlenAcc_entry() //  [R2, R3]
         { []
         }
     {offset
       cxlS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxlT; else goto uxm2;
       cxlT: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wlenAcc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uxm2: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cxlI() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.$wlenAcc_info" {
     GHC.List.$wlenAcc_info:
         const GHC.List.$wlenAcc_entry;
         const 0;
         const 14;
         const 8589934606;
 },
 _cxlI() //  []
         { []
         }
     {offset
       cxlI: // global
           _sulj::P64 = P64[Sp];
           I64[Sp] = block_cxlL_info;
           R1 = _sulj::P64;
           if (R1 & 7 != 0) goto uxm4; else goto cxlM;
       uxm4: // global
           call _cxlL(R1) args: 0, res: 0, upd: 0;
       cxlM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxlL() //  [R1]
         { []
         }
     {offset
       cxlL: // global
           _sulk::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cxlP; else goto cxlQ;
       cxlP: // global
           R1 = _sulk::I64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cxlQ: // global
           P64[Sp] = P64[R1 + 14];
           I64[Sp + 8] = _sulk::I64 + 1;
           call _cxlI() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cxlL_info" {
     block_cxlL_info:
         const _cxlL;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.820710066 UTC

[section ""data" . GHC.List.lenAcc_closure" {
     GHC.List.lenAcc_closure:
         const GHC.List.lenAcc_info;
 },
 GHC.List.lenAcc_entry() //  [R2, R3]
         { []
         }
     {offset
       cxmu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxmC; else goto cxmD;
       cxmC: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.lenAcc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxmD: // global
           I64[Sp - 16] = block_cxmr_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uxmI; else goto cxms;
       uxmI: // global
           call _cxmr(R1) args: 0, res: 0, upd: 0;
       cxms: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.lenAcc_info" {
     GHC.List.lenAcc_info:
         const GHC.List.lenAcc_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cxmr() //  [R1]
         { []
         }
     {offset
       cxmr: // global
           _sulp::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cxmx_info;
           R3 = I64[R1 + 7];
           R2 = _sulp::P64;
           Sp = Sp + 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cxmr_info" {
     block_cxmr_info:
         const _cxmr;
         const 1;
         const 30;
 },
 _cxmx() //  [R1]
         { []
         }
     {offset
       cxmx: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cxmH; else goto cxmG;
       cxmH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cxmG: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxmx_info" {
     block_cxmx_info:
         const _cxmx;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.828435662 UTC

[section ""data" . GHC.List.length_closure" {
     GHC.List.length_closure:
         const GHC.List.length_info;
 },
 GHC.List.length_entry() //  [R2]
         { []
         }
     {offset
       cxn2: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxn6; else goto cxn7;
       cxn6: // global
           R2 = R2;
           R1 = GHC.List.length_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxn7: // global
           I64[Sp - 8] = block_cxn0_info;
           R3 = 0;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.length_info" {
     GHC.List.length_info:
         const GHC.List.length_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cxn0() //  [R1]
         { []
         }
     {offset
       cxn0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cxna; else goto cxn9;
       cxna: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cxn9: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxn0_info" {
     block_cxn0_info:
         const _cxn0;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.834046989 UTC

[section ""data" . GHC.List.null_closure" {
     GHC.List.null_closure:
         const GHC.List.null_info;
 },
 GHC.List.null_entry() //  [R2]
         { []
         }
     {offset
       cxnv: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxnw; else goto cxnx;
       cxnw: // global
           R2 = R2;
           R1 = GHC.List.null_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxnx: // global
           I64[Sp - 8] = block_cxno_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxnE; else goto cxnp;
       uxnE: // global
           call _cxno(R1) args: 0, res: 0, upd: 0;
       cxnp: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.null_info" {
     GHC.List.null_info:
         const GHC.List.null_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cxno() //  [R1]
         { []
         }
     {offset
       cxno: // global
           if (R1 & 7 == 1) goto cxns; else goto cxnt;
       cxns: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cxnt: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxno_info" {
     block_cxno_info:
         const _cxno;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.840447886 UTC

[section ""data" . GHC.List.uncons_closure" {
     GHC.List.uncons_closure:
         const GHC.List.uncons_info;
 },
 GHC.List.uncons_entry() //  [R2]
         { []
         }
     {offset
       cxo3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxo4; else goto cxo5;
       cxo4: // global
           R2 = R2;
           R1 = GHC.List.uncons_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxo5: // global
           I64[Sp - 8] = block_cxnW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxog; else goto cxnX;
       uxog: // global
           call _cxnW(R1) args: 0, res: 0, upd: 0;
       cxnX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.uncons_info" {
     GHC.List.uncons_info:
         const GHC.List.uncons_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cxnW() //  [R1]
         { []
         }
     {offset
       cxnW: // global
           if (R1 & 7 == 1) goto cxo0; else goto cxo1;
       cxo0: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cxo1: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cxof; else goto cxoe;
       cxof: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxoe: // global
           _sulC::P64 = P64[R1 + 6];
           _sulD::P64 = P64[R1 + 14];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = _sulC::P64;
           P64[Hp - 16] = _sulD::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxnW_info" {
     block_cxnW_info:
         const _cxnW;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:07.846867528 UTC

[section ""relreadonly" . Supf_srt" {
     Supf_srt:
         const lvl1_ru8R_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.List.errorEmptyList_closure;
         const GHC.List.prel_list_str_closure;
         const lvl3_ru8T_closure;
         const GHC.List.!!2_closure;
         const GHC.List.!!1_closure;
         const poly_exit_ru8U_closure;
         const poly_$wgo_ru8V_closure;
         const GHC.List.negIndex_closure;
         const GHC.List.!!_closure;
         const GHC.List.$w!!_closure;
         const lvl5_ru8X_closure;
         const GHC.List.cycle_closure;
         const GHC.List.cycle1_closure;
         const lvl7_ru8Z_closure;
         const lvl8_ru90_closure;
         const GHC.List.foldr1_closure;
         const lvl10_ru92_closure;
         const GHC.List.init_closure;
         const GHC.List.init2_closure;
         const lvl12_ru94_closure;
         const GHC.List.lastError_closure;
         const lvl14_ru97_closure;
         const GHC.List.tail_closure;
         const GHC.List.scanl2_closure;
         const lvl16_ru99_closure;
         const GHC.List.head_closure;
         const GHC.List.badHead_closure;
         const lvl18_ru9b_closure;
         const GHC.List.maximum_$smaximum_closure;
         const GHC.List.maximum1_closure;
         const lvl21_ru9e_closure;
         const GHC.List.minimum_$sminimum_closure;
         const GHC.List.minimum1_closure;
         const GHC.List.maximum_$smaximum1_closure;
         const GHC.List.maximum2_closure;
         const GHC.List.maximum_closure;
         const lvl19_ru9c_closure;
         const GHC.List.minimum_$sminimum1_closure;
         const GHC.List.minimum2_closure;
         const GHC.List.minimum_closure;
         const lvl22_ru9f_closure;
         const lvl24_ru9h_closure;
         const GHC.List.errorEmptyList_closure;
         const lvl26_ru9j_closure;
         const Control.Exception.Base.patError_closure;
         const GHC.List.scanr1_closure;
         const lvl28_ru9p_closure;
         const GHC.List.foldl1'_closure;
         const GHC.List.foldl1'1_closure;
         const sat_sukE_closure;
         const lvl30_ru9r_closure;
         const GHC.List.sum_closure;
         const lvl29_ru9q_closure;
         const GHC.List.product_closure;
         const GHC.List.foldl1_closure;
         const GHC.List.foldl2_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.852860568 UTC

[]


==================== Raw Cmm ====================
2018-03-16 15:55:10.855357036 UTC

[section ""data" . $wunsafeDrop_ru8P_closure" {
     $wunsafeDrop_ru8P_closure:
         const $wunsafeDrop_ru8P_info;
 },
 $wunsafeDrop_ru8P_entry() //  [R2, R3]
         { []
         }
     {offset
       cxAT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cxAU; else goto uxB8;
       cxAU: // global
           R3 = R3;
           R2 = R2;
           R1 = $wunsafeDrop_ru8P_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uxB8: // global
           I64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cxAJ() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . $wunsafeDrop_ru8P_info" {
     $wunsafeDrop_ru8P_info:
         const $wunsafeDrop_ru8P_entry;
         const 0;
         const 14;
         const 8589934605;
 },
 _cxAJ() //  []
         { []
         }
     {offset
       cxAJ: // global
           I64[Sp - 8] = block_cxAM_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxBa; else goto cxAN;
       uxBa: // global
           call _cxAM(R1) args: 0, res: 0, upd: 0;
       cxAN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxAM() //  [R1]
         { []
         }
     {offset
       cxAM: // global
           if (R1 & 7 == 1) goto cxAQ; else goto cxAR;
       cxAQ: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cxAR: // global
           _sxoA::P64 = P64[R1 + 14];
           _sxoB::I64 = I64[Sp + 8];
           if (_sxoB::I64 != 1) goto cxB4; else goto cxB5;
       cxB4: // global
           I64[Sp + 8] = _sxoB::I64 - 1;
           P64[Sp + 16] = _sxoA::P64;
           Sp = Sp + 8;
           call _cxAJ() args: 0, res: 0, upd: 0;
       cxB5: // global
           R1 = _sxoA::P64 & (-8);
           Sp = Sp + 24;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxAM_info" {
     block_cxAM_info:
         const _cxAM;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.862375279 UTC

[section ""data" . GHC.List.drop_closure" {
     GHC.List.drop_closure:
         const GHC.List.drop_info;
 },
 GHC.List.drop_entry() //  [R2, R3]
         { []
         }
     {offset
       cxBD: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxBE; else goto cxBF;
       cxBE: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.drop_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxBF: // global
           I64[Sp - 16] = block_cxBA_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uxBO; else goto cxBB;
       uxBO: // global
           call _cxBA(R1) args: 0, res: 0, upd: 0;
       cxBB: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.drop_info" {
     GHC.List.drop_info:
         const GHC.List.drop_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cxBA() //  [R1]
         { []
         }
     {offset
       cxBA: // global
           _sxoE::P64 = P64[Sp + 8];
           _sxoG::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_sxoG::I64, 0)) goto cxBM; else goto cxBN;
       cxBM: // global
           R3 = _sxoE::P64;
           R2 = _sxoG::I64;
           Sp = Sp + 16;
           call $wunsafeDrop_ru8P_entry(R3, R2) args: 8, res: 0, upd: 8;
       cxBN: // global
           R1 = _sxoE::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxBA_info" {
     block_cxBA_info:
         const _cxBA;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.870110824 UTC

[section ""data" . GHC.List.$wsplitAt'_closure" {
     GHC.List.$wsplitAt'_closure:
         const GHC.List.$wsplitAt'_info;
 },
 ds2_sxoQ_entry() //  [R1]
         { []
         }
     {offset
       cxCo: // global
           _sxoQ::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cxCu; else goto cxCv;
       cxCv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cxCx; else goto cxCw;
       cxCx: // global
           HpAlloc = 16;
           goto cxCu;
       cxCu: // global
           R1 = _sxoQ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxCw: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sxoQ::P64;
           _sxoM::P64 = P64[_sxoQ::P64 + 16];
           _sxoR::I64 = I64[_sxoQ::P64 + 24] - 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sxoR::I64;
           I64[Sp - 24] = block_cxCr_info;
           R3 = _sxoM::P64;
           R2 = Hp - 7;
           Sp = Sp - 24;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ds2_sxoQ_info" {
     ds2_sxoQ_info:
         const ds2_sxoQ_entry;
         const 4294967297;
         const 19;
 },
 _cxCr() //  [R1, R2]
         { []
         }
     {offset
       cxCr: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cxCA; else goto cxCz;
       cxCA: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cxCz: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cxCr_info" {
     block_cxCr_info:
         const _cxCr;
         const 0;
         const 30;
 },
 GHC.List.$wsplitAt'_entry() //  [R2, R3]
         { []
         }
     {offset
       cxCF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cxCG; else goto cxCH;
       cxCG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wsplitAt'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxCH: // global
           I64[Sp - 16] = block_cxC5_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uxCX; else goto cxC6;
       uxCX: // global
           call _cxC5(R1) args: 0, res: 0, upd: 0;
       cxC6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.$wsplitAt'_info" {
     GHC.List.$wsplitAt'_info:
         const GHC.List.$wsplitAt'_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cxC5() //  [R1]
         { []
         }
     {offset
       cxC5: // global
           if (R1 & 7 == 1) goto cxCC; else goto cxCD;
       cxCC: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cxCD: // global
           I64[Sp - 8] = block_cxCb_info;
           _sxoL::P64 = P64[R1 + 6];
           _sxoM::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sxoM::P64;
           P64[Sp + 8] = _sxoL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxCW; else goto cxCc;
       uxCW: // global
           call _cxCb(R1) args: 0, res: 0, upd: 0;
       cxCc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cxC5_info" {
     block_cxC5_info:
         const _cxC5;
         const 1;
         const 30;
 },
 _cxCb() //  [R1]
         { []
         }
     {offset
       cxCb: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cxCN; else goto cxCM;
       cxCN: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxCM: // global
           _sxoL::P64 = P64[Sp + 16];
           _sxoM::P64 = P64[Sp + 8];
           _sxoP::I64 = I64[R1 + 7];
           if (_sxoP::I64 != 1) goto cxCS; else goto cxCV;
       cxCS: // global
           I64[Hp - 96] = ds2_sxoQ_info;
           P64[Hp - 80] = _sxoM::P64;
           I64[Hp - 72] = _sxoP::I64;
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cxCi::P64 = Hp - 96;
           P64[Hp - 48] = _cxCi::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cxCi::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sxoL::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cxCV: // global
           I64[Hp - 96] = :_con_info;
           P64[Hp - 88] = _sxoL::P64;
           P64[Hp - 80] = GHC.Types.[]_closure+1;
           _cxCU::P64 = Hp - 94;
           Hp = Hp - 80;
           R2 = _sxoM::P64;
           R1 = _cxCU::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxCb_info" {
     block_cxCb_info:
         const _cxCb;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.882695767 UTC

[section ""data" . GHC.List.splitAt_splitAt'_closure" {
     GHC.List.splitAt_splitAt'_closure:
         const GHC.List.splitAt_splitAt'_info;
 },
 GHC.List.splitAt_splitAt'_entry() //  [R2, R3]
         { []
         }
     {offset
       cxDM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxDN; else goto cxDO;
       cxDN: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.splitAt_splitAt'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxDO: // global
           I64[Sp - 8] = block_cxDJ_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.splitAt_splitAt'_info" {
     GHC.List.splitAt_splitAt'_info:
         const GHC.List.splitAt_splitAt'_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cxDJ() //  [R1, R2]
         { []
         }
     {offset
       cxDJ: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cxDR; else goto cxDQ;
       cxDR: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cxDQ: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxDJ_info" {
     block_cxDJ_info:
         const _cxDJ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.889219788 UTC

[section ""data" . GHC.List.splitAt_closure" {
     GHC.List.splitAt_closure:
         const GHC.List.splitAt_info;
 },
 GHC.List.splitAt_entry() //  [R2, R3]
         { []
         }
     {offset
       cxEa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxEb; else goto cxEc;
       cxEb: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.splitAt_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxEc: // global
           I64[Sp - 16] = block_cxE7_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uxEw; else goto cxE8;
       uxEw: // global
           call _cxE7(R1) args: 0, res: 0, upd: 0;
       cxE8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.splitAt_info" {
     GHC.List.splitAt_info:
         const GHC.List.splitAt_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cxE7() //  [R1]
         { []
         }
     {offset
       cxE7: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cxEh; else goto cxEg;
       cxEh: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxEg: // global
           _sxpc::P64 = P64[Sp + 8];
           if (%MO_S_Gt_W64(I64[R1 + 7], 0)) goto cxEp; else goto cxEv;
       cxEp: // global
           Hp = Hp - 24;
           I64[Sp + 8] = block_cxEl_info;
           R3 = _sxpc::P64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.List.$wsplitAt'_entry(R3, R2) args: 8, res: 8, upd: 8;
       cxEv: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = GHC.Types.[]_closure+1;
           P64[Hp] = _sxpc::P64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxE7_info" {
     block_cxE7_info:
         const _cxE7;
         const 1;
         const 30;
 },
 _cxEl() //  [R1, R2]
         { []
         }
     {offset
       cxEl: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cxEs; else goto cxEr;
       cxEs: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cxEr: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxEl_info" {
     block_cxEl_info:
         const _cxEl;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.896545242 UTC

[section ""cstring" . GHC.List.$trModule4_bytes" {
     GHC.List.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.898255405 UTC

[section ""data" . GHC.List.$trModule3_closure" {
     GHC.List.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.List.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.8998926 UTC

[section ""cstring" . GHC.List.$trModule2_bytes" {
     GHC.List.$trModule2_bytes:
         I8[] [71,72,67,46,76,105,115,116]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.901459871 UTC

[section ""data" . GHC.List.$trModule1_closure" {
     GHC.List.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.List.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.903120324 UTC

[section ""data" . GHC.List.$trModule_closure" {
     GHC.List.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.List.$trModule3_closure+1;
         const GHC.List.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.906717049 UTC

[section ""data" . GHC.List.init1_closure" {
     GHC.List.init1_closure:
         const GHC.List.init1_info;
 },
 sat_sxpo_entry() //  [R1]
         { []
         }
     {offset
       cxFa: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxFb; else goto cxFc;
       cxFb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxFc: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.init1_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxpo_info" {
     sat_sxpo_info:
         const sat_sxpo_entry;
         const 2;
         const 18;
 },
 GHC.List.init1_entry() //  [R2, R3]
         { []
         }
     {offset
       cxFh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxFi; else goto cxFj;
       cxFi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.init1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxFj: // global
           I64[Sp - 16] = block_cxF0_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uxFq; else goto cxF1;
       uxFq: // global
           call _cxF0(R1) args: 0, res: 0, upd: 0;
       cxF1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.init1_info" {
     GHC.List.init1_info:
         const GHC.List.init1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cxF0() //  [R1]
         { []
         }
     {offset
       cxF0: // global
           if (R1 & 7 == 1) goto cxFe; else goto cxFf;
       cxFe: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cxFf: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cxFp; else goto cxFo;
       cxFp: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxFo: // global
           _sxpm::P64 = P64[R1 + 6];
           _sxpn::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_sxpo_info;
           P64[Hp - 32] = _sxpm::P64;
           P64[Hp - 24] = _sxpn::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxF0_info" {
     block_cxF0_info:
         const _cxF0;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.914079426 UTC

[section ""cstring" . lvl_ru8Q_bytes" {
     lvl_ru8Q_bytes:
         I8[] [58,32,101,109,112,116,121,32,108,105,115,116]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.916333052 UTC

[section ""data" . lvl1_ru8R_closure" {
     lvl1_ru8R_closure:
         const lvl1_ru8R_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_ru8R_entry() //  [R1]
         { []
         }
     {offset
       cxFW: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxFX; else goto cxFY;
       cxFX: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxFY: // global
           (_cxFT::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxFT::I64 == 0) goto cxFV; else goto cxFU;
       cxFV: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxFU: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxFT::I64;
           R2 = lvl_ru8Q_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl1_ru8R_info" {
     lvl1_ru8R_info:
         const lvl1_ru8R_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.919865782 UTC

[section ""cstring" . GHC.List.!!4_bytes" {
     GHC.List.!!4_bytes:
         I8[] [80,114,101,108,117,100,101,46]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.922159709 UTC

[section ""data" . GHC.List.prel_list_str_closure" {
     GHC.List.prel_list_str_closure:
         const GHC.List.prel_list_str_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.prel_list_str_entry() //  [R1]
         { []
         }
     {offset
       cxGe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxGf; else goto cxGg;
       cxGf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxGg: // global
           (_cxGb::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxGb::I64 == 0) goto cxGd; else goto cxGc;
       cxGd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxGc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxGb::I64;
           R2 = GHC.List.!!4_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.prel_list_str_info" {
     GHC.List.prel_list_str_info:
         const GHC.List.prel_list_str_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.926667274 UTC

[section ""data" . GHC.List.errorEmptyList_closure" {
     GHC.List.errorEmptyList_closure:
         const GHC.List.errorEmptyList_info;
         const 0;
 },
 sat_sxpq_entry() //  [R1]
         { []
         }
     {offset
       cxGx: // global
           R3 = lvl1_ru8R_closure;
           R2 = P64[R1 + 16];
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sxpq_info" {
     sat_sxpq_info:
         const sat_sxpq_entry;
         const 1;
         const 4294967312;
         const SxGK_srt;
 },
 GHC.List.errorEmptyList_entry() //  [R2]
         { []
         }
     {offset
       cxGC: // global
           _sxpp::P64 = R2;
           if ((Sp + -8) < SpLim) (likely: False) goto cxGD; else goto cxGE;
       cxGE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cxGG; else goto cxGF;
       cxGG: // global
           HpAlloc = 24;
           goto cxGD;
       cxGD: // global
           R2 = _sxpp::P64;
           R1 = GHC.List.errorEmptyList_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxGF: // global
           I64[Hp - 16] = sat_sxpq_info;
           P64[Hp] = _sxpp::P64;
           I64[Sp - 8] = block_cxGA_info;
           R3 = Hp - 16;
           R2 = GHC.List.prel_list_str_closure;
           Sp = Sp - 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.errorEmptyList_info" {
     GHC.List.errorEmptyList_info:
         const GHC.List.errorEmptyList_entry;
         const 0;
         const 64424509454;
         const 4294967301;
         const SxGK_srt;
 },
 _cxGA() //  [R1]
         { []
         }
     {offset
       cxGA: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxGA_info" {
     block_cxGA_info:
         const _cxGA;
         const 0;
         const 4294967326;
         const SxGK_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.933209296 UTC

[section ""cstring" . lvl2_ru8S_bytes" {
     lvl2_ru8S_bytes:
         I8[] [33,33,58,32,110,101,103,97,116,105,118,101,32,105,110,100,101,120]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.935494688 UTC

[section ""data" . lvl3_ru8T_closure" {
     lvl3_ru8T_closure:
         const lvl3_ru8T_info;
         const 0;
         const 0;
         const 0;
 },
 lvl3_ru8T_entry() //  [R1]
         { []
         }
     {offset
       cxH5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxH6; else goto cxH7;
       cxH6: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxH7: // global
           (_cxH2::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxH2::I64 == 0) goto cxH4; else goto cxH3;
       cxH4: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxH3: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxH2::I64;
           R2 = lvl2_ru8S_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl3_ru8T_info" {
     lvl3_ru8T_info:
         const lvl3_ru8T_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.939655466 UTC

[section ""data" . GHC.List.negIndex_closure" {
     GHC.List.negIndex_closure:
         const GHC.List.negIndex_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.negIndex_entry() //  [R1]
         { []
         }
     {offset
       cxHo: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cxHp; else goto cxHq;
       cxHp: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxHq: // global
           (_cxHj::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxHj::I64 == 0) goto cxHl; else goto cxHk;
       cxHl: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxHk: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxHj::I64;
           I64[Sp - 24] = block_cxHm_info;
           R3 = lvl3_ru8T_closure;
           R2 = GHC.List.prel_list_str_closure;
           Sp = Sp - 24;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.negIndex_info" {
     GHC.List.negIndex_info:
         const GHC.List.negIndex_entry;
         const 0;
         const 55834574869;
         const SxGK_srt+8;
 },
 _cxHm() //  [R1]
         { []
         }
     {offset
       cxHm: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cxHm_info" {
     block_cxHm_info:
         const _cxHm;
         const 0;
         const 4294967326;
         const SxGK_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.945340696 UTC

[section ""cstring" . GHC.List.!!3_bytes" {
     GHC.List.!!3_bytes:
         I8[] [33,33,58,32,105,110,100,101,120,32,116,111,111,32,108,97,114,103,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.947655386 UTC

[section ""data" . GHC.List.!!2_closure" {
     GHC.List.!!2_closure:
         const GHC.List.!!2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.!!2_entry() //  [R1]
         { []
         }
     {offset
       cxHN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxHO; else goto cxHP;
       cxHO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxHP: // global
           (_cxHK::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxHK::I64 == 0) goto cxHM; else goto cxHL;
       cxHM: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxHL: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxHK::I64;
           R2 = GHC.List.!!3_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.!!2_info" {
     GHC.List.!!2_info:
         const GHC.List.!!2_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.951566682 UTC

[section ""data" . GHC.List.!!1_closure" {
     GHC.List.!!1_closure:
         const GHC.List.!!1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.!!1_entry() //  [R1]
         { []
         }
     {offset
       cxI4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxI5; else goto cxI6;
       cxI5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxI6: // global
           (_cxI1::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxI1::I64 == 0) goto cxI3; else goto cxI2;
       cxI3: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxI2: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxI1::I64;
           R3 = GHC.List.!!2_closure;
           R2 = GHC.List.prel_list_str_closure;
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.!!1_info" {
     GHC.List.!!1_info:
         const GHC.List.!!1_entry;
         const 0;
         const 21474836501;
         const SxGK_srt+24;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.955589459 UTC

[section ""data" . GHC.List.tooLarge_closure" {
     GHC.List.tooLarge_closure:
         const GHC.List.tooLarge_info;
         const 0;
 },
 GHC.List.tooLarge_entry() //  []
         { []
         }
     {offset
       cxIj: // global
           R2 = GHC.List.!!1_closure;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.tooLarge_info" {
     GHC.List.tooLarge_info:
         const GHC.List.tooLarge_entry;
         const 0;
         const 141733920782;
         const 4294967301;
         const SxGK_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.959081233 UTC

[section ""data" . poly_exit_ru8U_closure" {
     poly_exit_ru8U_closure:
         const poly_exit_ru8U_info;
         const 0;
         const 0;
         const 0;
 },
 poly_exit_ru8U_entry() //  [R1]
         { []
         }
     {offset
       cxIw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxIx; else goto cxIy;
       cxIx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxIy: // global
           (_cxIt::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxIt::I64 == 0) goto cxIv; else goto cxIu;
       cxIv: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxIu: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxIt::I64;
           R2 = GHC.List.!!1_closure;
           Sp = Sp - 16;
           call GHC.Err.errorWithoutStackTrace_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . poly_exit_ru8U_info" {
     poly_exit_ru8U_info:
         const poly_exit_ru8U_entry;
         const 0;
         const 141733920789;
         const SxGK_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.963727084 UTC

[section ""data" . poly_$wgo_ru8V_closure" {
     poly_$wgo_ru8V_closure:
         const poly_$wgo_ru8V_info;
         const 0;
 },
 poly_$wgo_ru8V_entry() //  [R2, R3]
         { []
         }
     {offset
       cxIS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxIT; else goto uxJ7;
       cxIT: // global
           R3 = R3;
           R2 = R2;
           R1 = poly_$wgo_ru8V_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uxJ7: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cxII() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . poly_$wgo_ru8V_info" {
     poly_$wgo_ru8V_info:
         const poly_$wgo_ru8V_entry;
         const 0;
         const 12884901902;
         const 8589934606;
         const SxGK_srt+56;
 },
 _cxII() //  []
         { []
         }
     {offset
       cxII: // global
           _sxpu::P64 = P64[Sp];
           I64[Sp] = block_cxIL_info;
           R1 = _sxpu::P64;
           if (R1 & 7 != 0) goto uxJ9; else goto cxIM;
       uxJ9: // global
           call _cxIL(R1) args: 0, res: 0, upd: 0;
       cxIM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxIL() //  [R1]
         { []
         }
     {offset
       cxIL: // global
           if (R1 & 7 == 1) goto cxIP; else goto cxIQ;
       cxIP: // global
           R1 = poly_exit_ru8U_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxIQ: // global
           _sxpz::I64 = I64[Sp + 8];
           if (_sxpz::I64 != 0) goto cxJ3; else goto cxJ4;
       cxJ3: // global
           P64[Sp] = P64[R1 + 14];
           I64[Sp + 8] = _sxpz::I64 - 1;
           call _cxII() args: 0, res: 0, upd: 0;
       cxJ4: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxIL_info" {
     block_cxIL_info:
         const _cxIL;
         const 65;
         const 4294967326;
         const SxGK_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.970326352 UTC

[section ""data" . GHC.List.$w!!_closure" {
     GHC.List.$w!!_closure:
         const GHC.List.$w!!_info;
         const 0;
 },
 GHC.List.$w!!_entry() //  [R2, R3]
         { []
         }
     {offset
       cxJB: // global
           if (%MO_S_Ge_W64(R3, 0)) goto cxJz; else goto cxJA;
       cxJz: // global
           R3 = R3;
           R2 = R2;
           call poly_$wgo_ru8V_entry(R3, R2) args: 8, res: 0, upd: 8;
       cxJA: // global
           R1 = GHC.List.negIndex_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.$w!!_info" {
     GHC.List.$w!!_info:
         const GHC.List.$w!!_entry;
         const 0;
         const 12884901902;
         const 8589934606;
         const SxGK_srt+64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.974816171 UTC

[section ""data" . GHC.List.!!_closure" {
     GHC.List.!!_closure:
         const GHC.List.!!_info;
         const 0;
 },
 GHC.List.!!_entry() //  [R2, R3]
         { []
         }
     {offset
       cxJP: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxJQ; else goto cxJR;
       cxJQ: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.!!_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxJR: // global
           I64[Sp - 16] = block_cxJM_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uxJV; else goto cxJN;
       uxJV: // global
           call _cxJM(R1) args: 0, res: 0, upd: 0;
       cxJN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.!!_info" {
     GHC.List.!!_info:
         const GHC.List.!!_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const SxGK_srt+80;
 },
 _cxJM() //  [R1]
         { []
         }
     {offset
       cxJM: // global
           R3 = I64[R1 + 7];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.$w!!_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxJM_info" {
     block_cxJM_info:
         const _cxJM;
         const 1;
         const 4294967326;
         const SxGK_srt+88;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.97983953 UTC

[section ""cstring" . lvl4_ru8W_bytes" {
     lvl4_ru8W_bytes:
         I8[] [99,121,99,108,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.982079336 UTC

[section ""data" . lvl5_ru8X_closure" {
     lvl5_ru8X_closure:
         const lvl5_ru8X_info;
         const 0;
         const 0;
         const 0;
 },
 lvl5_ru8X_entry() //  [R1]
         { []
         }
     {offset
       cxKd: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxKe; else goto cxKf;
       cxKe: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxKf: // global
           (_cxKa::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxKa::I64 == 0) goto cxKc; else goto cxKb;
       cxKc: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxKb: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxKa::I64;
           R2 = lvl4_ru8W_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl5_ru8X_info" {
     lvl5_ru8X_info:
         const lvl5_ru8X_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.98629118 UTC

[section ""data" . GHC.List.cycle1_closure" {
     GHC.List.cycle1_closure:
         const GHC.List.cycle1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.cycle1_entry() //  [R1]
         { []
         }
     {offset
       cxKu: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxKv; else goto cxKw;
       cxKv: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxKw: // global
           (_cxKr::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxKr::I64 == 0) goto cxKt; else goto cxKs;
       cxKt: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxKs: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxKr::I64;
           R2 = lvl5_ru8X_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.cycle1_info" {
     GHC.List.cycle1_info:
         const GHC.List.cycle1_entry;
         const 0;
         const 4402341478421;
         const SxGK_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.991046532 UTC

[section ""data" . GHC.List.cycle_closure" {
     GHC.List.cycle_closure:
         const GHC.List.cycle_info;
         const 0;
 },
 xs'_sxpM_entry() //  [R1]
         { []
         }
     {offset
       cxKT: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxKU; else goto cxKV;
       cxKU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxKV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Base.++_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . xs'_sxpM_info" {
     xs'_sxpM_info:
         const xs'_sxpM_entry;
         const 1;
         const 16;
 },
 GHC.List.cycle_entry() //  [R2]
         { []
         }
     {offset
       cxL0: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxL1; else goto cxL2;
       cxL1: // global
           R2 = R2;
           R1 = GHC.List.cycle_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxL2: // global
           I64[Sp - 8] = block_cxKJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxL8; else goto cxKK;
       uxL8: // global
           call _cxKJ(R1) args: 0, res: 0, upd: 0;
       cxKK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.cycle_info" {
     GHC.List.cycle_info:
         const GHC.List.cycle_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const SxGK_srt+104;
 },
 _cxKJ() //  [R1]
         { []
         }
     {offset
       cxKJ: // global
           if (R1 & 7 == 1) goto cxKX; else goto cxKY;
       cxKX: // global
           R1 = GHC.List.cycle1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cxKY: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cxL7; else goto cxL6;
       cxL7: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxL6: // global
           I64[Hp - 16] = xs'_sxpM_info;
           P64[Hp] = R1;
           R1 = (Hp + -16) & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxKJ_info" {
     block_cxKJ_info:
         const _cxKJ;
         const 0;
         const 4294967326;
         const SxGK_srt+112;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:10.997945469 UTC

[section ""cstring" . lvl6_ru8Y_bytes" {
     lvl6_ru8Y_bytes:
         I8[] [102,111,108,100,114,49]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.000145672 UTC

[section ""data" . lvl7_ru8Z_closure" {
     lvl7_ru8Z_closure:
         const lvl7_ru8Z_info;
         const 0;
         const 0;
         const 0;
 },
 lvl7_ru8Z_entry() //  [R1]
         { []
         }
     {offset
       cxLB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxLC; else goto cxLD;
       cxLC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxLD: // global
           (_cxLy::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxLy::I64 == 0) goto cxLA; else goto cxLz;
       cxLA: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxLz: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxLy::I64;
           R2 = lvl6_ru8Y_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl7_ru8Z_info" {
     lvl7_ru8Z_info:
         const lvl7_ru8Z_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.00447638 UTC

[section ""data" . lvl8_ru90_closure" {
     lvl8_ru90_closure:
         const lvl8_ru90_info;
         const 0;
         const 0;
         const 0;
 },
 lvl8_ru90_entry() //  [R1]
         { []
         }
     {offset
       cxLS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxLT; else goto cxLU;
       cxLT: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxLU: // global
           (_cxLP::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxLP::I64 == 0) goto cxLR; else goto cxLQ;
       cxLR: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxLQ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxLP::I64;
           R2 = lvl7_ru8Z_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl8_ru90_info" {
     lvl8_ru90_info:
         const lvl8_ru90_entry;
         const 0;
         const 35188667056149;
         const SxGK_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.010116893 UTC

[section ""data" . GHC.List.foldr1_closure" {
     GHC.List.foldr1_closure:
         const GHC.List.foldr1_info;
         const 0;
 },
 go2_sxpP_entry() //  [R1, R2]
         { []
         }
     {offset
       cxMj: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cxMk; else goto cxMl;
       cxMk: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxMl: // global
           I64[Sp - 24] = block_cxMc_info;
           _sxpP::P64 = R1;
           _sxpN::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sxpN::P64;
           P64[Sp - 8] = _sxpP::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uxMJ; else goto cxMd;
       uxMJ: // global
           call _cxMc(R1) args: 0, res: 0, upd: 0;
       cxMd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go2_sxpP_info" {
     go2_sxpP_info:
         const go2_sxpP_entry;
         const 1;
         const 4294967305;
         const 4294967301;
         const SxGK_srt+128;
 },
 _cxMc() //  [R1]
         { []
         }
     {offset
       cxMc: // global
           if (R1 & 7 == 1) goto cxMg; else goto cxMh;
       cxMg: // global
           R1 = lvl8_ru90_closure;
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxMh: // global
           I64[Sp - 8] = block_cxMr_info;
           _sxpS::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sxpS::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxMI; else goto cxMt;
       uxMI: // global
           call _cxMr(R1) args: 0, res: 0, upd: 0;
       cxMt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cxMc_info" {
     block_cxMc_info:
         const _cxMc;
         const 2;
         const 4294967326;
         const SxGK_srt+128;
 },
 _cxMr() //  [R1]
         { []
         }
     {offset
       cxMr: // global
           _sxpS::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cxMz; else goto cxMD;
       cxMz: // global
           R1 = _sxpS::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxMD: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cxMG; else goto cxMF;
       cxMG: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxMF: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = _sxpS::P64;
           R1 = P64[Sp + 16];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxMr_info" {
     block_cxMr_info:
         const _cxMr;
         const 3;
         const 30;
 },
 GHC.List.foldr1_entry() //  [R2, R3]
         { []
         }
     {offset
       cxMK: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cxMO; else goto cxMN;
       cxMO: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxMN: // global
           I64[Hp - 8] = go2_sxpP_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go2_sxpP_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.foldr1_info" {
     GHC.List.foldr1_info:
         const GHC.List.foldr1_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const SxGK_srt+128;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.01847135 UTC

[section ""cstring" . lvl9_ru91_bytes" {
     lvl9_ru91_bytes:
         I8[] [105,110,105,116]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.020707761 UTC

[section ""data" . lvl10_ru92_closure" {
     lvl10_ru92_closure:
         const lvl10_ru92_info;
         const 0;
         const 0;
         const 0;
 },
 lvl10_ru92_entry() //  [R1]
         { []
         }
     {offset
       cxNl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxNm; else goto cxNn;
       cxNm: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxNn: // global
           (_cxNi::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxNi::I64 == 0) goto cxNk; else goto cxNj;
       cxNk: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxNj: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxNi::I64;
           R2 = lvl9_ru91_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl10_ru92_info" {
     lvl10_ru92_info:
         const lvl10_ru92_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.025201337 UTC

[section ""data" . GHC.List.init2_closure" {
     GHC.List.init2_closure:
         const GHC.List.init2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.init2_entry() //  [R1]
         { []
         }
     {offset
       cxNC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxND; else goto cxNE;
       cxND: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxNE: // global
           (_cxNz::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxNz::I64 == 0) goto cxNB; else goto cxNA;
       cxNB: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxNA: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxNz::I64;
           R2 = lvl10_ru92_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.init2_info" {
     GHC.List.init2_info:
         const GHC.List.init2_entry;
         const 0;
         const 281479271677973;
         const SxGK_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.02975469 UTC

[section ""data" . GHC.List.init_closure" {
     GHC.List.init_closure:
         const GHC.List.init_info;
         const 0;
 },
 GHC.List.init_entry() //  [R2]
         { []
         }
     {offset
       cxNY: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxNZ; else goto cxO0;
       cxNZ: // global
           R2 = R2;
           R1 = GHC.List.init_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxO0: // global
           I64[Sp - 8] = block_cxNR_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxO7; else goto cxNS;
       uxO7: // global
           call _cxNR(R1) args: 0, res: 0, upd: 0;
       cxNS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.init_info" {
     GHC.List.init_info:
         const GHC.List.init_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const SxGK_srt+152;
 },
 _cxNR() //  [R1]
         { []
         }
     {offset
       cxNR: // global
           if (R1 & 7 == 1) goto cxNV; else goto cxNW;
       cxNV: // global
           R1 = GHC.List.init2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cxNW: // global
           R3 = P64[R1 + 14];
           R2 = P64[R1 + 6];
           Sp = Sp + 8;
           call GHC.List.init1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxNR_info" {
     block_cxNR_info:
         const _cxNR;
         const 0;
         const 4294967326;
         const SxGK_srt+160;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.035571428 UTC

[section ""cstring" . lvl11_ru93_bytes" {
     lvl11_ru93_bytes:
         I8[] [108,97,115,116]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.037933258 UTC

[section ""data" . lvl12_ru94_closure" {
     lvl12_ru94_closure:
         const lvl12_ru94_info;
         const 0;
         const 0;
         const 0;
 },
 lvl12_ru94_entry() //  [R1]
         { []
         }
     {offset
       cxOs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxOt; else goto cxOu;
       cxOt: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxOu: // global
           (_cxOp::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxOp::I64 == 0) goto cxOr; else goto cxOq;
       cxOr: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxOq: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxOp::I64;
           R2 = lvl11_ru93_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl12_ru94_info" {
     lvl12_ru94_info:
         const lvl12_ru94_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.042075065 UTC

[section ""data" . GHC.List.lastError_closure" {
     GHC.List.lastError_closure:
         const GHC.List.lastError_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.lastError_entry() //  [R1]
         { []
         }
     {offset
       cxOJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxOK; else goto cxOL;
       cxOK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxOL: // global
           (_cxOG::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxOG::I64 == 0) goto cxOI; else goto cxOH;
       cxOI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxOH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxOG::I64;
           R2 = lvl12_ru94_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.lastError_info" {
     GHC.List.lastError_info:
         const GHC.List.lastError_entry;
         const 0;
         const 2251804108652565;
         const SxGK_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.047719865 UTC

[section ""data" . poly_go_ru95_closure" {
     poly_go_ru95_closure:
         const poly_go_ru95_info;
 },
 poly_go_ru95_entry() //  [R2, R3]
         { []
         }
     {offset
       cxP5: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxP6; else goto uxPe;
       cxP6: // global
           R3 = R3;
           R2 = R2;
           R1 = poly_go_ru95_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uxPe: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cxOV() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . poly_go_ru95_info" {
     poly_go_ru95_info:
         const poly_go_ru95_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cxOV() //  []
         { []
         }
     {offset
       cxOV: // global
           _sxq2::P64 = P64[Sp];
           I64[Sp] = block_cxOY_info;
           R1 = _sxq2::P64;
           if (R1 & 7 != 0) goto uxPg; else goto cxOZ;
       uxPg: // global
           call _cxOY(R1) args: 0, res: 0, upd: 0;
       cxOZ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxOY() //  [R1]
         { []
         }
     {offset
       cxOY: // global
           if (R1 & 7 == 1) goto cxP2; else goto cxP3;
       cxP2: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxP3: // global
           P64[Sp] = P64[R1 + 14];
           P64[Sp + 8] = P64[R1 + 6];
           call _cxOV() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cxOY_info" {
     block_cxOY_info:
         const _cxOY;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.053738998 UTC

[section ""data" . GHC.List.last_closure" {
     GHC.List.last_closure:
         const GHC.List.last_info;
         const 0;
 },
 GHC.List.last_entry() //  [R2]
         { []
         }
     {offset
       cxPD: // global
           R3 = GHC.List.lastError_closure;
           R2 = R2;
           call poly_go_ru95_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.last_info" {
     GHC.List.last_info:
         const GHC.List.last_entry;
         const 0;
         const 4294967310;
         const 4294967301;
         const SxGK_srt+176;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.056655007 UTC

[section ""cstring" . lvl13_ru96_bytes" {
     lvl13_ru96_bytes:
         I8[] [116,97,105,108]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.058966503 UTC

[section ""data" . lvl14_ru97_closure" {
     lvl14_ru97_closure:
         const lvl14_ru97_info;
         const 0;
         const 0;
         const 0;
 },
 lvl14_ru97_entry() //  [R1]
         { []
         }
     {offset
       cxPR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxPS; else goto cxPT;
       cxPS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxPT: // global
           (_cxPO::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxPO::I64 == 0) goto cxPQ; else goto cxPP;
       cxPQ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxPP: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxPO::I64;
           R2 = lvl13_ru96_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl14_ru97_info" {
     lvl14_ru97_info:
         const lvl14_ru97_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.063321378 UTC

[section ""data" . GHC.List.scanl2_closure" {
     GHC.List.scanl2_closure:
         const GHC.List.scanl2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.scanl2_entry() //  [R1]
         { []
         }
     {offset
       cxQ8: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxQ9; else goto cxQa;
       cxQ9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxQa: // global
           (_cxQ5::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxQ5::I64 == 0) goto cxQ7; else goto cxQ6;
       cxQ7: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxQ6: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxQ5::I64;
           R2 = lvl14_ru97_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.scanl2_info" {
     GHC.List.scanl2_info:
         const GHC.List.scanl2_entry;
         const 0;
         const 9007203549708309;
         const SxGK_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.068258449 UTC

[section ""data" . GHC.List.tail_closure" {
     GHC.List.tail_closure:
         const GHC.List.tail_info;
         const 0;
 },
 GHC.List.tail_entry() //  [R2]
         { []
         }
     {offset
       cxQu: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxQv; else goto cxQw;
       cxQv: // global
           R2 = R2;
           R1 = GHC.List.tail_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxQw: // global
           I64[Sp - 8] = block_cxQn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxQD; else goto cxQo;
       uxQD: // global
           call _cxQn(R1) args: 0, res: 0, upd: 0;
       cxQo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.tail_info" {
     GHC.List.tail_info:
         const GHC.List.tail_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const SxGK_srt+192;
 },
 _cxQn() //  [R1]
         { []
         }
     {offset
       cxQn: // global
           if (R1 & 7 == 1) goto cxQr; else goto cxQs;
       cxQr: // global
           R1 = GHC.List.scanl2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cxQs: // global
           R1 = P64[R1 + 14] & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxQn_info" {
     block_cxQn_info:
         const _cxQn;
         const 0;
         const 4294967326;
         const SxGK_srt+200;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.07314744 UTC

[section ""cstring" . lvl15_ru98_bytes" {
     lvl15_ru98_bytes:
         I8[] [104,101,97,100]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.075584653 UTC

[section ""data" . lvl16_ru99_closure" {
     lvl16_ru99_closure:
         const lvl16_ru99_info;
         const 0;
         const 0;
         const 0;
 },
 lvl16_ru99_entry() //  [R1]
         { []
         }
     {offset
       cxR0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxR1; else goto cxR2;
       cxR1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxR2: // global
           (_cxQX::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxQX::I64 == 0) goto cxQZ; else goto cxQY;
       cxQZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxQY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxQX::I64;
           R2 = lvl15_ru98_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl16_ru99_info" {
     lvl16_ru99_info:
         const lvl16_ru99_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.079813697 UTC

[section ""data" . GHC.List.badHead_closure" {
     GHC.List.badHead_closure:
         const GHC.List.badHead_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.badHead_entry() //  [R1]
         { []
         }
     {offset
       cxRh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxRi; else goto cxRj;
       cxRi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxRj: // global
           (_cxRe::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxRe::I64 == 0) goto cxRg; else goto cxRf;
       cxRg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxRf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxRe::I64;
           R2 = lvl16_ru99_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.badHead_info" {
     GHC.List.badHead_info:
         const GHC.List.badHead_entry;
         const 0;
         const 72057598332895253;
         const SxGK_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.084154589 UTC

[section ""data" . GHC.List.head_closure" {
     GHC.List.head_closure:
         const GHC.List.head_info;
         const 0;
 },
 GHC.List.head_entry() //  [R2]
         { []
         }
     {offset
       cxRD: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxRE; else goto cxRF;
       cxRE: // global
           R2 = R2;
           R1 = GHC.List.head_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxRF: // global
           I64[Sp - 8] = block_cxRw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxRM; else goto cxRx;
       uxRM: // global
           call _cxRw(R1) args: 0, res: 0, upd: 0;
       cxRx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.head_info" {
     GHC.List.head_info:
         const GHC.List.head_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const SxGK_srt+216;
 },
 _cxRw() //  [R1]
         { []
         }
     {offset
       cxRw: // global
           if (R1 & 7 == 1) goto cxRA; else goto cxRB;
       cxRA: // global
           R1 = GHC.List.badHead_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxRB: // global
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxRw_info" {
     block_cxRw_info:
         const _cxRw;
         const 0;
         const 4294967326;
         const SxGK_srt+224;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.089053261 UTC

[section ""cstring" . lvl17_ru9a_bytes" {
     lvl17_ru9a_bytes:
         I8[] [109,97,120,105,109,117,109]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.091416434 UTC

[section ""data" . lvl18_ru9b_closure" {
     lvl18_ru9b_closure:
         const lvl18_ru9b_info;
         const 0;
         const 0;
         const 0;
 },
 lvl18_ru9b_entry() //  [R1]
         { []
         }
     {offset
       cxS6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxS7; else goto cxS8;
       cxS7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxS8: // global
           (_cxS3::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxS3::I64 == 0) goto cxS5; else goto cxS4;
       cxS5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxS4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxS3::I64;
           R2 = lvl17_ru9a_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl18_ru9b_info" {
     lvl18_ru9b_info:
         const lvl18_ru9b_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.095791635 UTC

[section ""data" . GHC.List.maximum1_closure" {
     GHC.List.maximum1_closure:
         const GHC.List.maximum1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.maximum1_entry() //  [R1]
         { []
         }
     {offset
       cxSn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxSo; else goto cxSp;
       cxSo: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxSp: // global
           (_cxSk::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxSk::I64 == 0) goto cxSm; else goto cxSl;
       cxSm: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxSl: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxSk::I64;
           R2 = lvl18_ru9b_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.maximum1_info" {
     GHC.List.maximum1_info:
         const GHC.List.maximum1_entry;
         const 0;
         const 576460756598390805;
         const SxGK_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.100530882 UTC

[section ""data" . GHC.List.maximum2_closure" {
     GHC.List.maximum2_closure:
         const GHC.List.maximum2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.maximum2_entry() //  [R1]
         { []
         }
     {offset
       cxSE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxSF; else goto cxSG;
       cxSF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxSG: // global
           (_cxSB::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxSB::I64 == 0) goto cxSD; else goto cxSC;
       cxSD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxSC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxSB::I64;
           R2 = lvl18_ru9b_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.maximum2_info" {
     GHC.List.maximum2_info:
         const GHC.List.maximum2_entry;
         const 0;
         const 576460756598390805;
         const SxGK_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.104587004 UTC

[section ""data" . lvl19_ru9c_closure" {
     lvl19_ru9c_closure:
         const lvl19_ru9c_info;
         const 0;
         const 0;
         const 0;
 },
 lvl19_ru9c_entry() //  [R1]
         { []
         }
     {offset
       cxSV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxSW; else goto cxSX;
       cxSW: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxSX: // global
           (_cxSS::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxSS::I64 == 0) goto cxSU; else goto cxST;
       cxSU: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxST: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxSS::I64;
           R2 = lvl18_ru9b_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl19_ru9c_info" {
     lvl19_ru9c_info:
         const lvl19_ru9c_entry;
         const 0;
         const 576460756598390805;
         const SxGK_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.109555238 UTC

[section ""data" . GHC.List.maximum_go_closure" {
     GHC.List.maximum_go_closure:
         const GHC.List.maximum_go_info;
 },
 GHC.List.maximum_go_entry() //  [R2, R3]
         { []
         }
     {offset
       cxTh: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cxTi; else goto uxTB;
       cxTi: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.maximum_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uxTB: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cxT7() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.maximum_go_info" {
     GHC.List.maximum_go_info:
         const GHC.List.maximum_go_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cxT7() //  []
         { []
         }
     {offset
       cxT7: // global
           _sxqg::P64 = P64[Sp];
           I64[Sp] = block_cxTa_info;
           R1 = _sxqg::P64;
           if (R1 & 7 != 0) goto uxTE; else goto cxTb;
       uxTE: // global
           call _cxTa(R1) args: 0, res: 0, upd: 0;
       cxTb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxTa() //  [R1]
         { []
         }
     {offset
       cxTa: // global
           _sxqh::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cxTe; else goto cxTf;
       cxTe: // global
           R1 = _sxqh::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cxTf: // global
           I64[Sp - 16] = block_cxTp_info;
           _sxqj::P64 = P64[R1 + 6];
           R3 = _sxqj::P64;
           R2 = _sxqh::P64;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = _sxqj::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cxTa_info" {
     block_cxTa_info:
         const _cxTa;
         const 1;
         const 30;
 },
 _cxTp() //  [R1]
         { []
         }
     {offset
       cxTp: // global
           _sxqk::P64 = P64[Sp + 8];
           if (R1 == 1) goto cxTA; else goto cxTw;
       cxTA: // global
           _sxqh::P64 = P64[Sp + 16];
           P64[Sp + 16] = _sxqk::P64;
           P64[Sp + 24] = _sxqh::P64;
           Sp = Sp + 16;
           goto uxTH;
       cxTw: // global
           P64[Sp + 16] = _sxqk::P64;
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 16;
           goto uxTH;
       uxTH: // global
           call _cxT7() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cxTp_info" {
     block_cxTp_info:
         const _cxTp;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.11771676 UTC

[section ""data" . GHC.List.maximum_$smaximum_closure" {
     GHC.List.maximum_$smaximum_closure:
         const GHC.List.maximum_$smaximum_info;
         const 0;
 },
 GHC.List.maximum_$smaximum_entry() //  [R2]
         { []
         }
     {offset
       cxUf: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxUg; else goto cxUh;
       cxUg: // global
           R2 = R2;
           R1 = GHC.List.maximum_$smaximum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxUh: // global
           I64[Sp - 8] = block_cxU8_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxUo; else goto cxU9;
       uxUo: // global
           call _cxU8(R1) args: 0, res: 0, upd: 0;
       cxU9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.maximum_$smaximum_info" {
     GHC.List.maximum_$smaximum_info:
         const GHC.List.maximum_$smaximum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const SxGK_srt+240;
 },
 _cxU8() //  [R1]
         { []
         }
     {offset
       cxU8: // global
           if (R1 & 7 == 1) goto cxUc; else goto cxUd;
       cxUc: // global
           R1 = GHC.List.maximum1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cxUd: // global
           R3 = P64[R1 + 6];
           R2 = P64[R1 + 14];
           Sp = Sp + 8;
           call GHC.List.maximum_go_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxU8_info" {
     block_cxU8_info:
         const _cxU8;
         const 0;
         const 4294967326;
         const SxGK_srt+248;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.122448551 UTC

[section ""cstring" . lvl20_ru9d_bytes" {
     lvl20_ru9d_bytes:
         I8[] [109,105,110,105,109,117,109]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.124737822 UTC

[section ""data" . lvl21_ru9e_closure" {
     lvl21_ru9e_closure:
         const lvl21_ru9e_info;
         const 0;
         const 0;
         const 0;
 },
 lvl21_ru9e_entry() //  [R1]
         { []
         }
     {offset
       cxUJ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxUK; else goto cxUL;
       cxUK: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxUL: // global
           (_cxUG::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxUG::I64 == 0) goto cxUI; else goto cxUH;
       cxUI: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxUH: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxUG::I64;
           R2 = lvl20_ru9d_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl21_ru9e_info" {
     lvl21_ru9e_info:
         const lvl21_ru9e_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.129577045 UTC

[section ""data" . GHC.List.minimum1_closure" {
     GHC.List.minimum1_closure:
         const GHC.List.minimum1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.minimum1_entry() //  [R1]
         { []
         }
     {offset
       cxV0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxV1; else goto cxV2;
       cxV1: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxV2: // global
           (_cxUX::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxUX::I64 == 0) goto cxUZ; else goto cxUY;
       cxUZ: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxUY: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxUX::I64;
           R2 = lvl21_ru9e_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.minimum1_info" {
     GHC.List.minimum1_info:
         const GHC.List.minimum1_entry;
         const 0;
         const 4611686022722355221;
         const SxGK_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.133701112 UTC

[section ""data" . GHC.List.minimum2_closure" {
     GHC.List.minimum2_closure:
         const GHC.List.minimum2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.minimum2_entry() //  [R1]
         { []
         }
     {offset
       cxVh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxVi; else goto cxVj;
       cxVi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxVj: // global
           (_cxVe::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxVe::I64 == 0) goto cxVg; else goto cxVf;
       cxVg: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxVf: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxVe::I64;
           R2 = lvl21_ru9e_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.minimum2_info" {
     GHC.List.minimum2_info:
         const GHC.List.minimum2_entry;
         const 0;
         const 4611686022722355221;
         const SxGK_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.13811385 UTC

[section ""data" . lvl22_ru9f_closure" {
     lvl22_ru9f_closure:
         const lvl22_ru9f_info;
         const 0;
         const 0;
         const 0;
 },
 lvl22_ru9f_entry() //  [R1]
         { []
         }
     {offset
       cxVy: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxVz; else goto cxVA;
       cxVz: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxVA: // global
           (_cxVv::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cxVv::I64 == 0) goto cxVx; else goto cxVw;
       cxVx: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cxVw: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cxVv::I64;
           R2 = lvl21_ru9e_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl22_ru9f_info" {
     lvl22_ru9f_info:
         const lvl22_ru9f_entry;
         const 0;
         const 4611686022722355221;
         const SxGK_srt+16;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.143159121 UTC

[section ""data" . GHC.List.minimum_go_closure" {
     GHC.List.minimum_go_closure:
         const GHC.List.minimum_go_info;
 },
 GHC.List.minimum_go_entry() //  [R2, R3]
         { []
         }
     {offset
       cxVU: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cxVV; else goto uxWe;
       cxVV: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.minimum_go_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uxWe: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cxVK() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.minimum_go_info" {
     GHC.List.minimum_go_info:
         const GHC.List.minimum_go_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cxVK() //  []
         { []
         }
     {offset
       cxVK: // global
           _sxqq::P64 = P64[Sp];
           I64[Sp] = block_cxVN_info;
           R1 = _sxqq::P64;
           if (R1 & 7 != 0) goto uxWh; else goto cxVO;
       uxWh: // global
           call _cxVN(R1) args: 0, res: 0, upd: 0;
       cxVO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxVN() //  [R1]
         { []
         }
     {offset
       cxVN: // global
           _sxqr::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cxVR; else goto cxVS;
       cxVR: // global
           R1 = _sxqr::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cxVS: // global
           I64[Sp - 16] = block_cxW2_info;
           _sxqt::P64 = P64[R1 + 6];
           R3 = _sxqt::P64;
           R2 = _sxqr::P64;
           P64[Sp - 8] = P64[R1 + 14];
           P64[Sp] = _sxqt::P64;
           Sp = Sp - 16;
           call GHC.Integer.Type.leInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cxVN_info" {
     block_cxVN_info:
         const _cxVN;
         const 1;
         const 30;
 },
 _cxW2() //  [R1]
         { []
         }
     {offset
       cxW2: // global
           _sxqu::P64 = P64[Sp + 8];
           if (R1 == 1) goto cxWd; else goto cxW9;
       cxWd: // global
           P64[Sp + 16] = _sxqu::P64;
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 16;
           goto uxWk;
       cxW9: // global
           _sxqr::P64 = P64[Sp + 16];
           P64[Sp + 16] = _sxqu::P64;
           P64[Sp + 24] = _sxqr::P64;
           Sp = Sp + 16;
           goto uxWk;
       uxWk: // global
           call _cxVK() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cxW2_info" {
     block_cxW2_info:
         const _cxW2;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.151933866 UTC

[section ""data" . GHC.List.minimum_$sminimum_closure" {
     GHC.List.minimum_$sminimum_closure:
         const GHC.List.minimum_$sminimum_info;
         const 0;
 },
 GHC.List.minimum_$sminimum_entry() //  [R2]
         { []
         }
     {offset
       cxWS: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cxWT; else goto cxWU;
       cxWT: // global
           R2 = R2;
           R1 = GHC.List.minimum_$sminimum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxWU: // global
           I64[Sp - 8] = block_cxWL_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxX1; else goto cxWM;
       uxX1: // global
           call _cxWL(R1) args: 0, res: 0, upd: 0;
       cxWM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.minimum_$sminimum_info" {
     GHC.List.minimum_$sminimum_info:
         const GHC.List.minimum_$sminimum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const SxGK_srt+264;
 },
 _cxWL() //  [R1]
         { []
         }
     {offset
       cxWL: // global
           if (R1 & 7 == 1) goto cxWP; else goto cxWQ;
       cxWP: // global
           R1 = GHC.List.minimum1_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cxWQ: // global
           R3 = P64[R1 + 6];
           R2 = P64[R1 + 14];
           Sp = Sp + 8;
           call GHC.List.minimum_go_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxWL_info" {
     block_cxWL_info:
         const _cxWL;
         const 0;
         const 4294967326;
         const SxGK_srt+272;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.159667444 UTC

[section ""data" . GHC.List.$wgo_closure" {
     GHC.List.$wgo_closure:
         const GHC.List.$wgo_info;
 },
 GHC.List.$wgo_entry() //  [R2, R3]
         { []
         }
     {offset
       cxXq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cxXr; else goto uxXK;
       cxXr: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wgo_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uxXK: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cxXg() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.$wgo_info" {
     GHC.List.$wgo_info:
         const GHC.List.$wgo_entry;
         const 0;
         const 14;
         const 8589934606;
 },
 _cxXg() //  []
         { []
         }
     {offset
       cxXg: // global
           _sxqA::P64 = P64[Sp];
           I64[Sp] = block_cxXj_info;
           R1 = _sxqA::P64;
           if (R1 & 7 != 0) goto uxXN; else goto cxXk;
       uxXN: // global
           call _cxXj(R1) args: 0, res: 0, upd: 0;
       cxXk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxXj() //  [R1]
         { []
         }
     {offset
       cxXj: // global
           if (R1 & 7 == 1) goto cxXn; else goto cxXo;
       cxXn: // global
           R1 = I64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cxXo: // global
           I64[Sp - 8] = block_cxXy_info;
           _sxqE::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sxqE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxXO; else goto cxXA;
       uxXO: // global
           call _cxXy(R1) args: 0, res: 0, upd: 0;
       cxXA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cxXj_info" {
     block_cxXj_info:
         const _cxXj;
         const 65;
         const 30;
 },
 _cxXy() //  [R1]
         { []
         }
     {offset
       cxXy: // global
           _sxqB::I64 = I64[Sp + 16];
           _sxqE::P64 = P64[Sp + 8];
           _sxqG::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_sxqB::I64,
                            _sxqG::I64)) goto cxXI; else goto cxXJ;
       cxXI: // global
           P64[Sp + 8] = _sxqE::P64;
           I64[Sp + 16] = _sxqB::I64;
           Sp = Sp + 8;
           goto uxXR;
       cxXJ: // global
           P64[Sp + 8] = _sxqE::P64;
           I64[Sp + 16] = _sxqG::I64;
           Sp = Sp + 8;
           goto uxXR;
       uxXR: // global
           call _cxXg() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cxXy_info" {
     block_cxXy_info:
         const _cxXy;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.169163492 UTC

[section ""data" . GHC.List.maximum_$smaximum1_closure" {
     GHC.List.maximum_$smaximum1_closure:
         const GHC.List.maximum_$smaximum1_info;
         const 0;
 },
 GHC.List.maximum_$smaximum1_entry() //  [R2]
         { []
         }
     {offset
       cxYn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cxYo; else goto cxYp;
       cxYo: // global
           R2 = R2;
           R1 = GHC.List.maximum_$smaximum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cxYp: // global
           I64[Sp - 8] = block_cxYg_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxYL; else goto cxYh;
       uxYL: // global
           call _cxYg(R1) args: 0, res: 0, upd: 0;
       cxYh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.maximum_$smaximum1_info" {
     GHC.List.maximum_$smaximum1_info:
         const GHC.List.maximum_$smaximum1_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const SxGK_srt+280;
 },
 _cxYg() //  [R1]
         { []
         }
     {offset
       cxYg: // global
           if (R1 & 7 == 1) goto cxYk; else goto cxYl;
       cxYk: // global
           R1 = GHC.List.maximum2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cxYl: // global
           I64[Sp - 8] = block_cxYv_info;
           _sxqL::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sxqL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxYK; else goto cxYw;
       uxYK: // global
           call _cxYv(R1) args: 0, res: 0, upd: 0;
       cxYw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cxYg_info" {
     block_cxYg_info:
         const _cxYg;
         const 0;
         const 4294967326;
         const SxGK_srt+288;
 },
 _cxYv() //  [R1]
         { []
         }
     {offset
       cxYv: // global
           _sxqL::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cxYA_info;
           R3 = I64[R1 + 7];
           R2 = _sxqL::P64;
           Sp = Sp + 8;
           call GHC.List.$wgo_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cxYv_info" {
     block_cxYv_info:
         const _cxYv;
         const 1;
         const 30;
 },
 _cxYA() //  [R1]
         { []
         }
     {offset
       cxYA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cxYJ; else goto cxYI;
       cxYJ: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cxYI: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cxYA_info" {
     block_cxYA_info:
         const _cxYA;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.179769394 UTC

[section ""data" . GHC.List.maximum_closure" {
     GHC.List.maximum_closure:
         const GHC.List.maximum_info;
         const 0;
 },
 sat_sxr0_entry() //  [R1]
         { []
         }
     {offset
       cxZz: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cxZA; else goto cxZB;
       cxZA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cxZB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Classes.max_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxr0_info" {
     sat_sxr0_info:
         const sat_sxr0_entry;
         const 3;
         const 15;
 },
 GHC.List.maximum_entry() //  [R2, R3]
         { []
         }
     {offset
       cxZG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cxZH; else goto cxZI;
       cxZH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.maximum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cxZI: // global
           I64[Sp - 16] = block_cxZe_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uy01; else goto cxZf;
       uy01: // global
           call _cxZe(R1) args: 0, res: 0, upd: 0;
       cxZf: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.maximum_info" {
     GHC.List.maximum_info:
         const GHC.List.maximum_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const SxGK_srt+296;
 },
 _cxZe() //  [R1]
         { []
         }
     {offset
       cxZe: // global
           if (R1 & 7 == 1) goto cxZD; else goto cxZE;
       cxZD: // global
           R1 = lvl19_ru9c_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxZE: // global
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[R1 + 14];
           Sp = Sp - 8;
           call _cxZn() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cxZe_info" {
     block_cxZe_info:
         const _cxZe;
         const 1;
         const 4294967326;
         const SxGK_srt+304;
 },
 _cxZn() //  []
         { []
         }
     {offset
       cxZn: // global
           I64[Sp - 8] = block_cxZp_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uxZZ; else goto cxZq;
       uxZZ: // global
           call _cxZp(R1) args: 0, res: 0, upd: 0;
       cxZq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cxZp() //  [R1]
         { []
         }
     {offset
       cxZp: // global
           _sxqW::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cxZQ; else goto cxZR;
       cxZQ: // global
           R1 = _sxqW::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cxZR: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cxZU; else goto cxZT;
       cxZU: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cxZT: // global
           _sxqY::P64 = P64[R1 + 6];
           _sxqZ::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_sxr0_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _sxqW::P64;
           P64[Hp] = _sxqY::P64;
           P64[Sp + 16] = _sxqZ::P64;
           P64[Sp + 8] = Hp - 32;
           Sp = Sp + 8;
           call _cxZn() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cxZp_info" {
     block_cxZp_info:
         const _cxZp;
         const 131;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.191377655 UTC

[section ""data" . GHC.List.$wgo1_closure" {
     GHC.List.$wgo1_closure:
         const GHC.List.$wgo1_info;
 },
 GHC.List.$wgo1_entry() //  [R2, R3]
         { []
         }
     {offset
       cy0L: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cy0M; else goto uy15;
       cy0M: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wgo1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uy15: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cy0B() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.$wgo1_info" {
     GHC.List.$wgo1_info:
         const GHC.List.$wgo1_entry;
         const 0;
         const 14;
         const 8589934606;
 },
 _cy0B() //  []
         { []
         }
     {offset
       cy0B: // global
           _sxr1::P64 = P64[Sp];
           I64[Sp] = block_cy0E_info;
           R1 = _sxr1::P64;
           if (R1 & 7 != 0) goto uy18; else goto cy0F;
       uy18: // global
           call _cy0E(R1) args: 0, res: 0, upd: 0;
       cy0F: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cy0E() //  [R1]
         { []
         }
     {offset
       cy0E: // global
           if (R1 & 7 == 1) goto cy0I; else goto cy0J;
       cy0I: // global
           R1 = I64[Sp + 8];
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cy0J: // global
           I64[Sp - 8] = block_cy0T_info;
           _sxr5::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sxr5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uy19; else goto cy0V;
       uy19: // global
           call _cy0T(R1) args: 0, res: 0, upd: 0;
       cy0V: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cy0E_info" {
     block_cy0E_info:
         const _cy0E;
         const 65;
         const 30;
 },
 _cy0T() //  [R1]
         { []
         }
     {offset
       cy0T: // global
           _sxr2::I64 = I64[Sp + 16];
           _sxr5::P64 = P64[Sp + 8];
           _sxr7::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_sxr2::I64,
                            _sxr7::I64)) goto cy13; else goto cy14;
       cy13: // global
           P64[Sp + 8] = _sxr5::P64;
           I64[Sp + 16] = _sxr7::I64;
           Sp = Sp + 8;
           goto uy1c;
       cy14: // global
           P64[Sp + 8] = _sxr5::P64;
           I64[Sp + 16] = _sxr2::I64;
           Sp = Sp + 8;
           goto uy1c;
       uy1c: // global
           call _cy0B() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cy0T_info" {
     block_cy0T_info:
         const _cy0T;
         const 130;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.201317611 UTC

[section ""data" . GHC.List.minimum_$sminimum1_closure" {
     GHC.List.minimum_$sminimum1_closure:
         const GHC.List.minimum_$sminimum1_info;
         const 0;
 },
 GHC.List.minimum_$sminimum1_entry() //  [R2]
         { []
         }
     {offset
       cy1I: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cy1J; else goto cy1K;
       cy1J: // global
           R2 = R2;
           R1 = GHC.List.minimum_$sminimum1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cy1K: // global
           I64[Sp - 8] = block_cy1B_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uy26; else goto cy1C;
       uy26: // global
           call _cy1B(R1) args: 0, res: 0, upd: 0;
       cy1C: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.minimum_$sminimum1_info" {
     GHC.List.minimum_$sminimum1_info:
         const GHC.List.minimum_$sminimum1_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const SxGK_srt+312;
 },
 _cy1B() //  [R1]
         { []
         }
     {offset
       cy1B: // global
           if (R1 & 7 == 1) goto cy1F; else goto cy1G;
       cy1F: // global
           R1 = GHC.List.minimum2_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cy1G: // global
           I64[Sp - 8] = block_cy1Q_info;
           _sxrc::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sxrc::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uy25; else goto cy1R;
       uy25: // global
           call _cy1Q(R1) args: 0, res: 0, upd: 0;
       cy1R: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cy1B_info" {
     block_cy1B_info:
         const _cy1B;
         const 0;
         const 4294967326;
         const SxGK_srt+320;
 },
 _cy1Q() //  [R1]
         { []
         }
     {offset
       cy1Q: // global
           _sxrc::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cy1V_info;
           R3 = I64[R1 + 7];
           R2 = _sxrc::P64;
           Sp = Sp + 8;
           call GHC.List.$wgo1_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cy1Q_info" {
     block_cy1Q_info:
         const _cy1Q;
         const 1;
         const 30;
 },
 _cy1V() //  [R1]
         { []
         }
     {offset
       cy1V: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cy24; else goto cy23;
       cy24: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cy23: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cy1V_info" {
     block_cy1V_info:
         const _cy1V;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.212208237 UTC

[section ""data" . GHC.List.minimum_closure" {
     GHC.List.minimum_closure:
         const GHC.List.minimum_info;
         const 0;
 },
 sat_sxrr_entry() //  [R1]
         { []
         }
     {offset
       cy2U: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cy2V; else goto cy2W;
       cy2V: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cy2W: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 40] = stg_ap_pp_info;
           P64[Sp - 32] = P64[R1 + 24];
           P64[Sp - 24] = P64[R1 + 32];
           Sp = Sp - 40;
           call GHC.Classes.min_entry(R2) args: 48, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxrr_info" {
     sat_sxrr_info:
         const sat_sxrr_entry;
         const 3;
         const 15;
 },
 GHC.List.minimum_entry() //  [R2, R3]
         { []
         }
     {offset
       cy31: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cy32; else goto cy33;
       cy32: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.minimum_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cy33: // global
           I64[Sp - 16] = block_cy2z_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uy3m; else goto cy2A;
       uy3m: // global
           call _cy2z(R1) args: 0, res: 0, upd: 0;
       cy2A: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.minimum_info" {
     GHC.List.minimum_info:
         const GHC.List.minimum_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const SxGK_srt+328;
 },
 _cy2z() //  [R1]
         { []
         }
     {offset
       cy2z: // global
           if (R1 & 7 == 1) goto cy2Y; else goto cy2Z;
       cy2Y: // global
           R1 = lvl22_ru9f_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cy2Z: // global
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[R1 + 14];
           Sp = Sp - 8;
           call _cy2I() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cy2z_info" {
     block_cy2z_info:
         const _cy2z;
         const 1;
         const 4294967326;
         const SxGK_srt+336;
 },
 _cy2I() //  []
         { []
         }
     {offset
       cy2I: // global
           I64[Sp - 8] = block_cy2K_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uy3k; else goto cy2L;
       uy3k: // global
           call _cy2K(R1) args: 0, res: 0, upd: 0;
       cy2L: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cy2K() //  [R1]
         { []
         }
     {offset
       cy2K: // global
           _sxrn::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cy3b; else goto cy3c;
       cy3b: // global
           R1 = _sxrn::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cy3c: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cy3f; else goto cy3e;
       cy3f: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cy3e: // global
           _sxrp::P64 = P64[R1 + 6];
           _sxrq::P64 = P64[R1 + 14];
           I64[Hp - 32] = sat_sxrr_info;
           P64[Hp - 16] = P64[Sp + 24];
           P64[Hp - 8] = _sxrn::P64;
           P64[Hp] = _sxrp::P64;
           P64[Sp + 16] = _sxrq::P64;
           P64[Sp + 8] = Hp - 32;
           Sp = Sp + 8;
           call _cy2I() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cy2K_info" {
     block_cy2K_info:
         const _cy2K;
         const 131;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.221814834 UTC

[section ""cstring" . lvl23_ru9g_bytes" {
     lvl23_ru9g_bytes:
         I8[] [102,111,108,100,108,49,39]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.224646525 UTC

[section ""data" . lvl24_ru9h_closure" {
     lvl24_ru9h_closure:
         const lvl24_ru9h_info;
         const 0;
         const 0;
         const 0;
 },
 lvl24_ru9h_entry() //  [R1]
         { []
         }
     {offset
       cy42: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cy43; else goto cy44;
       cy43: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cy44: // global
           (_cy3Z::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cy3Z::I64 == 0) goto cy41; else goto cy40;
       cy41: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cy40: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cy3Z::I64;
           R2 = lvl23_ru9g_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl24_ru9h_info" {
     lvl24_ru9h_info:
         const lvl24_ru9h_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.228878008 UTC

[section ""data" . GHC.List.foldl1'1_closure" {
     GHC.List.foldl1'1_closure:
         const GHC.List.foldl1'1_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.foldl1'1_entry() //  [R1]
         { []
         }
     {offset
       cy4j: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cy4k; else goto cy4l;
       cy4k: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cy4l: // global
           (_cy4g::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cy4g::I64 == 0) goto cy4i; else goto cy4h;
       cy4i: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cy4h: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cy4g::I64;
           R2 = lvl24_ru9h_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.foldl1'1_info" {
     GHC.List.foldl1'1_info:
         const GHC.List.foldl1'1_entry;
         const 0;
         const 12884901909;
         const SxGK_srt+344;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.232402572 UTC

[section ""cstring" . lvl25_ru9i_bytes" {
     lvl25_ru9i_bytes:
         I8[] [102,111,108,100,108,49]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.234654496 UTC

[section ""data" . lvl26_ru9j_closure" {
     lvl26_ru9j_closure:
         const lvl26_ru9j_info;
         const 0;
         const 0;
         const 0;
 },
 lvl26_ru9j_entry() //  [R1]
         { []
         }
     {offset
       cy4B: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cy4C; else goto cy4D;
       cy4C: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cy4D: // global
           (_cy4y::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cy4y::I64 == 0) goto cy4A; else goto cy4z;
       cy4A: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cy4z: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cy4y::I64;
           R2 = lvl25_ru9i_bytes;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl26_ru9j_info" {
     lvl26_ru9j_info:
         const lvl26_ru9j_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.238704801 UTC

[section ""data" . GHC.List.foldl2_closure" {
     GHC.List.foldl2_closure:
         const GHC.List.foldl2_info;
         const 0;
         const 0;
         const 0;
 },
 GHC.List.foldl2_entry() //  [R1]
         { []
         }
     {offset
       cy4S: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cy4T; else goto cy4U;
       cy4T: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cy4U: // global
           (_cy4P::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cy4P::I64 == 0) goto cy4R; else goto cy4Q;
       cy4R: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cy4Q: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cy4P::I64;
           R2 = lvl26_ru9j_closure;
           Sp = Sp - 16;
           call GHC.List.errorEmptyList_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . GHC.List.foldl2_info" {
     GHC.List.foldl2_info:
         const GHC.List.foldl2_entry;
         const 0;
         const 12884901909;
         const SxGK_srt+352;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.244728467 UTC

[section ""data" . $wgo2_ru9k_closure" {
     $wgo2_ru9k_closure:
         const $wgo2_ru9k_info;
 },
 ds_sxrA_entry() //  [R1]
         { []
         }
     {offset
       cy5p: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cy5q; else goto cy5r;
       cy5q: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cy5r: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cy5m_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgo2_ru9k_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ds_sxrA_info" {
     ds_sxrA_info:
         const ds_sxrA_entry;
         const 1;
         const 16;
 },
 _cy5m() //  [R1, R2, R3]
         { []
         }
     {offset
       cy5m: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cy5u; else goto cy5t;
       cy5u: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 24;
       cy5t: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cy5m_info" {
     block_cy5m_info:
         const _cy5m;
         const 0;
         const 30;
 },
 $wgo2_ru9k_entry() //  [R2]
         { []
         }
     {offset
       cy5z: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cy5A; else goto cy5B;
       cy5A: // global
           R2 = R2;
           R1 = $wgo2_ru9k_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cy5B: // global
           I64[Sp - 8] = block_cy57_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uy5P; else goto cy58;
       uy5P: // global
           call _cy57(R1) args: 0, res: 0, upd: 0;
       cy58: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . $wgo2_ru9k_info" {
     $wgo2_ru9k_info:
         const $wgo2_ru9k_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cy57() //  [R1]
         { []
         }
     {offset
       cy57: // global
           if (R1 & 7 == 1) goto cy5w; else goto cy5x;
       cy5w: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
       cy5x: // global
           I64[Sp - 8] = block_cy5d_info;
           _sxrv::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sxrv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uy5O; else goto cy5e;
       uy5O: // global
           call _cy5d(R1) args: 0, res: 0, upd: 0;
       cy5e: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cy57_info" {
     block_cy57_info:
         const _cy57;
         const 0;
         const 30;
 },
 _cy5d() //  [R1]
         { []
         }
     {offset
       cy5d: // global
           Hp = Hp + 168;
           if (Hp > HpLim) (likely: False) goto cy5N; else goto cy5M;
       cy5N: // global
           HpAlloc = 168;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cy5M: // global
           _sxrx::P64 = P64[R1 + 7];
           _sxry::P64 = P64[R1 + 15];
           _sxrz::P64 = P64[R1 + 23];
           I64[Hp - 160] = ds_sxrA_info;
           P64[Hp - 144] = P64[Sp + 8];
           I64[Hp - 136] = stg_sel_2_upd_info;
           _cy5i::P64 = Hp - 160;
           P64[Hp - 120] = _cy5i::P64;
           I64[Hp - 112] = :_con_info;
           P64[Hp - 104] = _sxrz::P64;
           P64[Hp - 96] = Hp - 136;
           I64[Hp - 88] = stg_sel_1_upd_info;
           P64[Hp - 72] = _cy5i::P64;
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = _sxry::P64;
           P64[Hp - 48] = Hp - 88;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cy5i::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sxrx::P64;
           P64[Hp] = Hp - 40;
           R3 = Hp - 110;
           R2 = Hp - 62;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cy5d_info" {
     block_cy5d_info:
         const _cy5d;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.256826693 UTC

[section ""data" . go_ru9l_closure" {
     go_ru9l_closure:
         const go_ru9l_info;
 },
 go_ru9l_entry() //  [R2]
         { []
         }
     {offset
       cy6F: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cy6G; else goto cy6H;
       cy6G: // global
           R2 = R2;
           R1 = go_ru9l_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cy6H: // global
           I64[Sp - 8] = block_cy6C_info;
           R2 = R2;
           Sp = Sp - 8;
           call $wgo2_ru9k_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go_ru9l_info" {
     go_ru9l_info:
         const go_ru9l_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cy6C() //  [R1, R2, R3]
         { []
         }
     {offset
       cy6C: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cy6K; else goto cy6J;
       cy6K: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call stg_gc_ppp(R3, R2, R1) args: 8, res: 8, upd: 8;
       cy6J: // global
           I64[Hp - 24] = (,,)_con_info;
           P64[Hp - 16] = R1;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R1 = Hp - 23;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cy6C_info" {
     block_cy6C_info:
         const _cy6C;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.262369434 UTC

[section ""data" . GHC.List.unzip3_closure" {
     GHC.List.unzip3_closure:
         const GHC.List.unzip3_info;
 },
 GHC.List.unzip3_entry() //  [R2]
         { []
         }
     {offset
       cy70: // global
           R2 = R2;
           call go_ru9l_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.unzip3_info" {
     GHC.List.unzip3_info:
         const GHC.List.unzip3_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.267691818 UTC

[section ""data" . $wgo3_ru9m_closure" {
     $wgo3_ru9m_closure:
         const $wgo3_ru9m_info;
 },
 ds_sxs9_entry() //  [R1]
         { []
         }
     {offset
       cy7t: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cy7u; else goto cy7v;
       cy7u: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cy7v: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cy7q_info;
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call $wgo3_ru9m_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ds_sxs9_info" {
     ds_sxs9_info:
         const ds_sxs9_entry;
         const 1;
         const 16;
 },
 _cy7q() //  [R1, R2]
         { []
         }
     {offset
       cy7q: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cy7y; else goto cy7x;
       cy7y: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cy7x: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cy7q_info" {
     block_cy7q_info:
         const _cy7q;
         const 0;
         const 30;
 },
 $wgo3_ru9m_entry() //  [R2]
         { []
         }
     {offset
       cy7D: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cy7E; else goto cy7F;
       cy7E: // global
           R2 = R2;
           R1 = $wgo3_ru9m_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cy7F: // global
           I64[Sp - 8] = block_cy7b_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uy7R; else goto cy7c;
       uy7R: // global
           call _cy7b(R1) args: 0, res: 0, upd: 0;
       cy7c: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . $wgo3_ru9m_info" {
     $wgo3_ru9m_info:
         const $wgo3_ru9m_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cy7b() //  [R1]
         { []
         }
     {offset
       cy7b: // global
           if (R1 & 7 == 1) goto cy7A; else goto cy7B;
       cy7A: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cy7B: // global
           I64[Sp - 8] = block_cy7h_info;
           _sxs5::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sxs5::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uy7Q; else goto cy7i;
       uy7Q: // global
           call _cy7h(R1) args: 0, res: 0, upd: 0;
       cy7i: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cy7b_info" {
     block_cy7b_info:
         const _cy7b;
         const 0;
         const 30;
 },
 _cy7h() //  [R1]
         { []
         }
     {offset
       cy7h: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cy7P; else goto cy7O;
       cy7P: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cy7O: // global
           _sxs7::P64 = P64[R1 + 7];
           _sxs8::P64 = P64[R1 + 15];
           I64[Hp - 112] = ds_sxs9_info;
           P64[Hp - 96] = P64[Sp + 8];
           I64[Hp - 88] = stg_sel_1_upd_info;
           _cy7m::P64 = Hp - 112;
           P64[Hp - 72] = _cy7m::P64;
           I64[Hp - 64] = :_con_info;
           P64[Hp - 56] = _sxs8::P64;
           P64[Hp - 48] = Hp - 88;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cy7m::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sxs7::P64;
           P64[Hp] = Hp - 40;
           R2 = Hp - 62;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cy7h_info" {
     block_cy7h_info:
         const _cy7h;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.279044911 UTC

[section ""data" . go1_ru9n_closure" {
     go1_ru9n_closure:
         const go1_ru9n_info;
 },
 go1_ru9n_entry() //  [R2]
         { []
         }
     {offset
       cy8D: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cy8E; else goto cy8F;
       cy8E: // global
           R2 = R2;
           R1 = go1_ru9n_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cy8F: // global
           I64[Sp - 8] = block_cy8A_info;
           R2 = R2;
           Sp = Sp - 8;
           call $wgo3_ru9m_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go1_ru9n_info" {
     go1_ru9n_info:
         const go1_ru9n_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cy8A() //  [R1, R2]
         { []
         }
     {offset
       cy8A: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cy8I; else goto cy8H;
       cy8I: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cy8H: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cy8A_info" {
     block_cy8A_info:
         const _cy8A;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.284297651 UTC

[section ""data" . GHC.List.unzip_closure" {
     GHC.List.unzip_closure:
         const GHC.List.unzip_info;
 },
 GHC.List.unzip_entry() //  [R2]
         { []
         }
     {offset
       cy8Y: // global
           R2 = R2;
           call go1_ru9n_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.unzip_info" {
     GHC.List.unzip_info:
         const GHC.List.unzip_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.291051832 UTC

[section ""data" . GHC.List.zipWith3_closure" {
     GHC.List.zipWith3_closure:
         const GHC.List.zipWith3_info;
 },
 go2_sxsv_entry() //  [R1, R2, R3, R4]
         { []
         }
     {offset
       cy9l: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cy9m; else goto cy9n;
       cy9m: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cy9n: // global
           I64[Sp - 40] = block_cy9e_info;
           _sxsv::P64 = R1;
           _sxsr::P64 = P64[R1 + 5];
           R1 = R2;
           P64[Sp - 32] = _sxsr::P64;
           P64[Sp - 24] = _sxsv::P64;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uya4; else goto cy9f;
       uya4: // global
           call _cy9e(R1) args: 0, res: 0, upd: 0;
       cy9f: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go2_sxsv_info" {
     go2_sxsv_info:
         const go2_sxsv_entry;
         const 1;
         const 9;
         const 12884901911;
 },
 _cy9e() //  [R1]
         { []
         }
     {offset
       cy9e: // global
           if (R1 & 7 == 1) goto uy9Z; else goto cy9j;
       uy9Z: // global
           Sp = Sp + 40;
           call _cy9N() args: 0, res: 0, upd: 0;
       cy9j: // global
           I64[Sp - 8] = block_cy9t_info;
           _sxsA::P64 = P64[R1 + 6];
           _sxsB::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _sxsB::P64;
           P64[Sp + 24] = _sxsA::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uya2; else goto cy9v;
       uya2: // global
           call _cy9t(R1) args: 0, res: 0, upd: 0;
       cy9v: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cy9e_info" {
     block_cy9e_info:
         const _cy9e;
         const 4;
         const 30;
 },
 _cy9t() //  [R1]
         { []
         }
     {offset
       cy9t: // global
           if (R1 & 7 == 1) goto uya0; else goto cy9G;
       uya0: // global
           Sp = Sp + 48;
           call _cy9N() args: 0, res: 0, upd: 0;
       cy9G: // global
           I64[Sp - 8] = block_cy9E_info;
           _sxsD::P64 = P64[R1 + 6];
           _sxsE::P64 = P64[R1 + 14];
           R1 = P64[Sp + 40];
           P64[Sp] = _sxsE::P64;
           P64[Sp + 40] = _sxsD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uya5; else goto cy9H;
       uya5: // global
           call _cy9E(R1) args: 0, res: 0, upd: 0;
       cy9H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cy9t_info" {
     block_cy9t_info:
         const _cy9t;
         const 5;
         const 30;
 },
 _cy9E() //  [R1]
         { []
         }
     {offset
       cy9E: // global
           if (R1 & 7 == 1) goto uya1; else goto cy9T;
       uya1: // global
           Sp = Sp + 56;
           call _cy9N() args: 0, res: 0, upd: 0;
       cy9T: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cy9W; else goto cy9V;
       cy9W: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cy9V: // global
           _sxsG::P64 = P64[R1 + 6];
           _sxsH::P64 = P64[R1 + 14];
           I64[Hp - 112] = stg_ap_4_upd_info;
           P64[Hp - 96] = P64[Sp + 32];
           P64[Hp - 88] = P64[Sp + 16];
           P64[Hp - 80] = P64[Sp + 8];
           P64[Hp - 72] = _sxsH::P64;
           I64[Hp - 64] = stg_ap_4_upd_info;
           P64[Hp - 48] = P64[Sp + 24];
           P64[Hp - 40] = P64[Sp + 40];
           P64[Hp - 32] = P64[Sp + 48];
           P64[Hp - 24] = _sxsG::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 64;
           P64[Hp] = Hp - 112;
           R1 = Hp - 14;
           Sp = Sp + 56;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cy9E_info" {
     block_cy9E_info:
         const _cy9E;
         const 6;
         const 30;
 },
 _cy9N() //  []
         { []
         }
     {offset
       cy9N: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.zipWith3_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cya8: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cyac; else goto cyab;
       cyac: // global
           HpAlloc = 16;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipWith3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyab: // global
           I64[Hp - 8] = go2_sxsv_info;
           P64[Hp] = R2;
           _sxst::P64 = R4;
           R4 = R5;
           _sxss::P64 = R3;
           R3 = _sxst::P64;
           R2 = _sxss::P64;
           R1 = Hp - 5;
           call go2_sxsv_entry(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.zipWith3_info" {
     GHC.List.zipWith3_info:
         const GHC.List.zipWith3_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.303646564 UTC

[section ""data" . GHC.List.zipWithFB_closure" {
     GHC.List.zipWithFB_closure:
         const GHC.List.zipWithFB_info;
 },
 GHC.List.zipWithFB_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cyb2: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cyb6; else goto cyb5;
       cyb6: // global
           HpAlloc = 40;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipWithFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyb5: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R3;
           P64[Hp - 8] = R4;
           P64[Hp] = R5;
           R3 = R6;
           _sxsK::P64 = R2;
           R2 = Hp - 32;
           R1 = _sxsK::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.zipWithFB_info" {
     GHC.List.zipWithFB_info:
         const GHC.List.zipWithFB_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.309991809 UTC

[section ""data" . GHC.List.zip3_closure" {
     GHC.List.zip3_closure:
         const GHC.List.zip3_info;
 },
 sat_sxt3_entry() //  [R1]
         { []
         }
     {offset
       cybC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cybD; else goto cybE;
       cybD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cybE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.zip3_entry(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxt3_info" {
     sat_sxt3_info:
         const sat_sxt3_entry;
         const 3;
         const 15;
 },
 GHC.List.zip3_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cybJ: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cybK; else goto cybL;
       cybK: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zip3_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cybL: // global
           I64[Sp - 24] = block_cybg_info;
           R1 = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uycf; else goto cybh;
       uycf: // global
           call _cybg(R1) args: 0, res: 0, upd: 0;
       cybh: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.zip3_info" {
     GHC.List.zip3_info:
         const GHC.List.zip3_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cybg() //  [R1]
         { []
         }
     {offset
       cybg: // global
           if (R1 & 7 == 1) goto uyc7; else goto cybH;
       uyc7: // global
           Sp = Sp + 24;
           call _cybY() args: 0, res: 0, upd: 0;
       cybH: // global
           I64[Sp - 8] = block_cybm_info;
           _sxsU::P64 = P64[R1 + 6];
           _sxsV::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sxsV::P64;
           P64[Sp + 8] = _sxsU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyca; else goto cybn;
       uyca: // global
           call _cybm(R1) args: 0, res: 0, upd: 0;
       cybn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cybg_info" {
     block_cybg_info:
         const _cybg;
         const 2;
         const 30;
 },
 _cybm() //  [R1]
         { []
         }
     {offset
       cybm: // global
           if (R1 & 7 == 1) goto uyc8; else goto cybU;
       uyc8: // global
           Sp = Sp + 32;
           call _cybY() args: 0, res: 0, upd: 0;
       cybU: // global
           I64[Sp - 8] = block_cybs_info;
           _sxsX::P64 = P64[R1 + 6];
           _sxsY::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _sxsY::P64;
           P64[Sp + 24] = _sxsX::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uycc; else goto cybt;
       uycc: // global
           call _cybs(R1) args: 0, res: 0, upd: 0;
       cybt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cybm_info" {
     block_cybm_info:
         const _cybm;
         const 3;
         const 30;
 },
 _cybs() //  [R1]
         { []
         }
     {offset
       cybs: // global
           if (R1 & 7 == 1) goto uyc9; else goto cyc1;
       uyc9: // global
           Sp = Sp + 40;
           call _cybY() args: 0, res: 0, upd: 0;
       cyc1: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cyc4; else goto cyc3;
       cyc4: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyc3: // global
           _sxt0::P64 = P64[R1 + 6];
           _sxt1::P64 = P64[R1 + 14];
           I64[Hp - 88] = sat_sxt3_info;
           P64[Hp - 72] = P64[Sp + 16];
           P64[Hp - 64] = P64[Sp + 8];
           P64[Hp - 56] = _sxt1::P64;
           I64[Hp - 48] = (,,)_con_info;
           P64[Hp - 40] = P64[Sp + 24];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sxt0::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 47;
           P64[Hp] = Hp - 88;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cybs_info" {
     block_cybs_info:
         const _cybs;
         const 4;
         const 30;
 },
 _cybY() //  []
         { []
         }
     {offset
       cybY: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.322694703 UTC

[section ""data" . GHC.List.zipFB_closure" {
     GHC.List.zipFB_closure:
         const GHC.List.zipFB_info;
 },
 GHC.List.zipFB_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cyd4: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyd8; else goto cyd7;
       cyd8: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyd7: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R3 = R5;
           _sxt4::P64 = R2;
           R2 = Hp - 15;
           R1 = _sxt4::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.zipFB_info" {
     GHC.List.zipFB_info:
         const GHC.List.zipFB_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.327553299 UTC

[section ""data" . GHC.List.foldr2_left_closure" {
     GHC.List.foldr2_left_closure:
         const GHC.List.foldr2_left_info;
 },
 GHC.List.foldr2_left_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cydp: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cydq; else goto cydr;
       cydq: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldr2_left_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cydr: // global
           I64[Sp - 40] = block_cydi_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uydB; else goto cydj;
       uydB: // global
           call _cydi(R1) args: 0, res: 0, upd: 0;
       cydj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.foldr2_left_info" {
     GHC.List.foldr2_left_info:
         const GHC.List.foldr2_left_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cydi() //  [R1]
         { []
         }
     {offset
       cydi: // global
           if (R1 & 7 == 1) goto cydm; else goto cydn;
       cydm: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cydn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cydA; else goto cydz;
       cydA: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cydz: // global
           _sxtf::P64 = P64[R1 + 6];
           _sxtg::P64 = P64[R1 + 14];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 32];
           P64[Hp] = _sxtg::P64;
           R4 = Hp - 24;
           R3 = _sxtf::P64;
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cydi_info" {
     block_cydi_info:
         const _cydi;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.339836086 UTC

[section ""data" . GHC.List.zip_closure" {
     GHC.List.zip_closure:
         const GHC.List.zip_info;
 },
 sat_sxtr_entry() //  [R1]
         { []
         }
     {offset
       cyea: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyeb; else goto cyec;
       cyeb: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyec: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.zip_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxtr_info" {
     sat_sxtr_info:
         const sat_sxtr_entry;
         const 2;
         const 18;
 },
 GHC.List.zip_entry() //  [R2, R3]
         { []
         }
     {offset
       cyeh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyei; else goto cyej;
       cyei: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zip_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyej: // global
           I64[Sp - 16] = block_cydU_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyeD; else goto cydV;
       uyeD: // global
           call _cydU(R1) args: 0, res: 0, upd: 0;
       cydV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.zip_info" {
     GHC.List.zip_info:
         const GHC.List.zip_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cydU() //  [R1]
         { []
         }
     {offset
       cydU: // global
           if (R1 & 7 == 1) goto uyey; else goto cyef;
       uyey: // global
           Sp = Sp + 16;
           call _cyeq() args: 0, res: 0, upd: 0;
       cyef: // global
           I64[Sp - 8] = block_cye0_info;
           _sxtl::P64 = P64[R1 + 6];
           _sxtm::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sxtm::P64;
           P64[Sp + 8] = _sxtl::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyeA; else goto cye1;
       uyeA: // global
           call _cye0(R1) args: 0, res: 0, upd: 0;
       cye1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cydU_info" {
     block_cydU_info:
         const _cydU;
         const 1;
         const 30;
 },
 _cye0() //  [R1]
         { []
         }
     {offset
       cye0: // global
           if (R1 & 7 == 1) goto uyez; else goto cyet;
       uyez: // global
           Sp = Sp + 24;
           call _cyeq() args: 0, res: 0, upd: 0;
       cyet: // global
           Hp = Hp + 80;
           if (Hp > HpLim) (likely: False) goto cyew; else goto cyev;
       cyew: // global
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyev: // global
           _sxto::P64 = P64[R1 + 6];
           _sxtp::P64 = P64[R1 + 14];
           I64[Hp - 72] = sat_sxtr_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = _sxtp::P64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = _sxto::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cye0_info" {
     block_cye0_info:
         const _cye0;
         const 2;
         const 30;
 },
 _cyeq() //  []
         { []
         }
     {offset
       cyeq: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""data" . GHC.List.zipWith_closure" {
     GHC.List.zipWith_closure:
         const GHC.List.zipWith_info;
 },
 go2_sxtv_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cyeU: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cyeV; else goto cyeW;
       cyeV: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyeW: // global
           I64[Sp - 32] = block_cyeN_info;
           _sxtv::P64 = R1;
           _sxts::P64 = P64[R1 + 6];
           R1 = R2;
           P64[Sp - 24] = _sxts::P64;
           P64[Sp - 16] = _sxtv::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uyfp; else goto cyeO;
       uyfp: // global
           call _cyeN(R1) args: 0, res: 0, upd: 0;
       cyeO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go2_sxtv_info" {
     go2_sxtv_info:
         const go2_sxtv_entry;
         const 1;
         const 9;
         const 8589934607;
 },
 _cyeN() //  [R1]
         { []
         }
     {offset
       cyeN: // global
           if (R1 & 7 == 1) goto uyfl; else goto cyeS;
       uyfl: // global
           Sp = Sp + 32;
           call _cyfa() args: 0, res: 0, upd: 0;
       cyeS: // global
           I64[Sp - 8] = block_cyf2_info;
           _sxtz::P64 = P64[R1 + 6];
           _sxtA::P64 = P64[R1 + 14];
           R1 = P64[Sp + 24];
           P64[Sp] = _sxtA::P64;
           P64[Sp + 24] = _sxtz::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyfn; else goto cyf4;
       uyfn: // global
           call _cyf2(R1) args: 0, res: 0, upd: 0;
       cyf4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cyeN_info" {
     block_cyeN_info:
         const _cyeN;
         const 3;
         const 30;
 },
 _cyf2() //  [R1]
         { []
         }
     {offset
       cyf2: // global
           if (R1 & 7 == 1) goto uyfm; else goto cyfg;
       uyfm: // global
           Sp = Sp + 40;
           call _cyfa() args: 0, res: 0, upd: 0;
       cyfg: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cyfj; else goto cyfi;
       cyfj: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyfi: // global
           _sxtC::P64 = P64[R1 + 6];
           _sxtD::P64 = P64[R1 + 14];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = P64[Sp + 24];
           P64[Hp - 72] = P64[Sp + 8];
           P64[Hp - 64] = _sxtD::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 32];
           P64[Hp - 24] = _sxtC::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyf2_info" {
     block_cyf2_info:
         const _cyf2;
         const 4;
         const 30;
 },
 _cyfa() //  []
         { []
         }
     {offset
       cyfa: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.zipWith_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cyfr: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cyfv; else goto cyfu;
       cyfv: // global
           HpAlloc = 16;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.zipWith_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyfu: // global
           I64[Hp - 8] = go2_sxtv_info;
           P64[Hp] = R2;
           _sxtt::P64 = R3;
           R3 = R4;
           R2 = _sxtt::P64;
           R1 = Hp - 6;
           call go2_sxtv_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.zipWith_info" {
     GHC.List.zipWith_info:
         const GHC.List.zipWith_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 section ""data" . GHC.List.foldr2_closure" {
     GHC.List.foldr2_closure:
         const GHC.List.foldr2_info;
 },
 go2_sxtK_entry() //  [R1, R2, R3]
         { []
         }
     {offset
       cyfM: // global
           if ((Sp + -48) < SpLim) (likely: False) goto cyfN; else goto cyfO;
       cyfN: // global
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyfO: // global
           I64[Sp - 40] = block_cyfF_info;
           _sxtK::P64 = R1;
           _sxtG::P64 = P64[R1 + 6];
           _sxtH::P64 = P64[R1 + 14];
           R1 = R2;
           P64[Sp - 32] = _sxtG::P64;
           P64[Sp - 24] = _sxtH::P64;
           P64[Sp - 16] = _sxtK::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uygf; else goto cyfG;
       uygf: // global
           call _cyfF(R1) args: 0, res: 0, upd: 0;
       cyfG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go2_sxtK_info" {
     go2_sxtK_info:
         const go2_sxtK_entry;
         const 2;
         const 11;
         const 8589934607;
 },
 _cyfF() //  [R1]
         { []
         }
     {offset
       cyfF: // global
           if (R1 & 7 == 1) goto uygb; else goto cyfK;
       uygb: // global
           Sp = Sp + 16;
           call _cyg2() args: 0, res: 0, upd: 0;
       cyfK: // global
           I64[Sp - 8] = block_cyfU_info;
           _sxtO::P64 = P64[R1 + 6];
           _sxtP::P64 = P64[R1 + 14];
           R1 = P64[Sp + 32];
           P64[Sp] = _sxtP::P64;
           P64[Sp + 32] = _sxtO::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uygd; else goto cyfW;
       uygd: // global
           call _cyfU(R1) args: 0, res: 0, upd: 0;
       cyfW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cyfF_info" {
     block_cyfF_info:
         const _cyfF;
         const 4;
         const 30;
 },
 _cyfU() //  [R1]
         { []
         }
     {offset
       cyfU: // global
           if (R1 & 7 == 1) goto uygc; else goto cyg6;
       uygc: // global
           Sp = Sp + 24;
           call _cyg2() args: 0, res: 0, upd: 0;
       cyg6: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cyg9; else goto cyg8;
       cyg9: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyg8: // global
           _sxtR::P64 = P64[R1 + 6];
           _sxtS::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sxtS::P64;
           R4 = Hp - 32;
           R3 = _sxtR::P64;
           R2 = P64[Sp + 40];
           R1 = P64[Sp + 16];
           Sp = Sp + 48;
           call stg_ap_ppp_fast(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyfU_info" {
     block_cyfU_info:
         const _cyfU;
         const 5;
         const 30;
 },
 _cyg2() //  []
         { []
         }
     {offset
       cyg2: // global
           R1 = P64[Sp];
           Sp = Sp + 24;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 GHC.List.foldr2_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cygh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cygl; else goto cygk;
       cygl: // global
           HpAlloc = 24;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldr2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cygk: // global
           I64[Hp - 16] = go2_sxtK_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R3 = R5;
           R2 = R4;
           R1 = Hp - 14;
           call go2_sxtK_entry(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.foldr2_info" {
     GHC.List.foldr2_info:
         const GHC.List.foldr2_entry;
         const 0;
         const 14;
         const 17179869208;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.369811674 UTC

[section ""data" . GHC.List.concat_go_closure" {
     GHC.List.concat_go_closure:
         const GHC.List.concat_go_info;
 },
 sat_sxtY_entry() //  [R1]
         { []
         }
     {offset
       cyid: // global
           R2 = P64[R1 + 16];
           call GHC.List.concat_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sxtY_info" {
     sat_sxtY_info:
         const sat_sxtY_entry;
         const 1;
         const 16;
 },
 GHC.List.concat_go_entry() //  [R2]
         { []
         }
     {offset
       cyik: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cyil; else goto cyim;
       cyil: // global
           R2 = R2;
           R1 = GHC.List.concat_go_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cyim: // global
           I64[Sp - 8] = block_cyi3_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyis; else goto cyi4;
       uyis: // global
           call _cyi3(R1) args: 0, res: 0, upd: 0;
       cyi4: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.concat_go_info" {
     GHC.List.concat_go_info:
         const GHC.List.concat_go_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cyi3() //  [R1]
         { []
         }
     {offset
       cyi3: // global
           if (R1 & 7 == 1) goto cyih; else goto cyii;
       cyih: // global
           R1 = []_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyii: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyir; else goto cyiq;
       cyir: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyiq: // global
           _sxtW::P64 = P64[R1 + 6];
           _sxtX::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sxtY_info;
           P64[Hp] = _sxtX::P64;
           R3 = Hp - 16;
           R2 = _sxtW::P64;
           Sp = Sp + 8;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyi3_info" {
     block_cyi3_info:
         const _cyi3;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.376792008 UTC

[section ""data" . GHC.List.concat_closure" {
     GHC.List.concat_closure:
         const GHC.List.concat_info;
 },
 GHC.List.concat_entry() //  [R2]
         { []
         }
     {offset
       cyiP: // global
           R2 = R2;
           call GHC.List.concat_go_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.concat_info" {
     GHC.List.concat_info:
         const GHC.List.concat_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.382204113 UTC

[section ""data" . GHC.List.concatMap_closure" {
     GHC.List.concatMap_closure:
         const GHC.List.concatMap_info;
 },
 sat_sxu7_entry() //  [R1]
         { []
         }
     {offset
       cyjf: // global
           R2 = P64[R1 + 24];
           R1 = P64[R1 + 16];
           call go2_sxu1_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . sat_sxu7_info" {
     sat_sxu7_info:
         const sat_sxu7_entry;
         const 2;
         const 18;
 },
 go2_sxu1_entry() //  [R1, R2]
         { []
         }
     {offset
       cyjm: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyjn; else goto cyjo;
       cyjn: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cyjo: // global
           I64[Sp - 24] = block_cyj5_info;
           _sxu1::P64 = R1;
           _sxtZ::P64 = P64[R1 + 7];
           R1 = R2;
           P64[Sp - 16] = _sxtZ::P64;
           P64[Sp - 8] = _sxu1::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uyjz; else goto cyj6;
       uyjz: // global
           call _cyj5(R1) args: 0, res: 0, upd: 0;
       cyj6: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go2_sxu1_info" {
     go2_sxu1_info:
         const go2_sxu1_entry;
         const 1;
         const 9;
         const 4294967301;
 },
 _cyj5() //  [R1]
         { []
         }
     {offset
       cyj5: // global
           if (R1 & 7 == 1) goto cyjj; else goto cyjk;
       cyjj: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyjk: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cyju; else goto cyjt;
       cyju: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyjt: // global
           _sxu4::P64 = P64[R1 + 6];
           _sxu5::P64 = P64[R1 + 14];
           I64[Hp - 24] = sat_sxu7_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sxu5::P64;
           _sxtZ::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cyjr_info;
           R2 = _sxu4::P64;
           R1 = _sxtZ::P64;
           P64[Sp + 16] = Hp - 24;
           Sp = Sp + 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cyj5_info" {
     block_cyj5_info:
         const _cyj5;
         const 2;
         const 30;
 },
 _cyjr() //  [R1]
         { []
         }
     {offset
       cyjr: // global
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyjr_info" {
     block_cyjr_info:
         const _cyjr;
         const 1;
         const 30;
 },
 GHC.List.concatMap_entry() //  [R2, R3]
         { []
         }
     {offset
       cyjA: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cyjE; else goto cyjD;
       cyjE: // global
           HpAlloc = 16;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.concatMap_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyjD: // global
           I64[Hp - 8] = go2_sxu1_info;
           P64[Hp] = R2;
           R2 = R3;
           R1 = Hp - 7;
           call go2_sxu1_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.concatMap_info" {
     GHC.List.concatMap_info:
         const GHC.List.concatMap_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.395027355 UTC

[section ""data" . GHC.List.lookup_closure" {
     GHC.List.lookup_closure:
         const GHC.List.lookup_info;
 },
 GHC.List.lookup_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cyki: // global
           if ((Sp + -64) < SpLim) (likely: False) goto cykj; else goto uykM;
       cykj: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.lookup_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uykM: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cyk8() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.lookup_info" {
     GHC.List.lookup_info:
         const GHC.List.lookup_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cyk8() //  []
         { []
         }
     {offset
       cyk8: // global
           I64[Sp - 8] = block_cykb_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uykO; else goto cykc;
       uykO: // global
           call _cykb(R1) args: 0, res: 0, upd: 0;
       cykc: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cykb() //  [R1]
         { []
         }
     {offset
       cykb: // global
           if (R1 & 7 == 1) goto cykf; else goto cykg;
       cykf: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cykg: // global
           I64[Sp] = block_cykq_info;
           _sxud::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 24] = _sxud::P64;
           if (R1 & 7 != 0) goto uykP; else goto cyks;
       uykP: // global
           call _cykq(R1) args: 0, res: 0, upd: 0;
       cyks: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cykb_info" {
     block_cykb_info:
         const _cykb;
         const 259;
         const 30;
 },
 _cykq() //  [R1]
         { []
         }
     {offset
       cykq: // global
           I64[Sp - 8] = block_cykw_info;
           R2 = P64[Sp + 8];
           I64[Sp - 32] = stg_ap_pp_info;
           P64[Sp - 24] = P64[Sp + 16];
           P64[Sp - 16] = P64[R1 + 7];
           P64[Sp] = P64[R1 + 15];
           Sp = Sp - 32;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cykq_info" {
     block_cykq_info:
         const _cykq;
         const 3;
         const 30;
 },
 _cykw() //  [R1]
         { []
         }
     {offset
       cykw: // global
           if (R1 & 7 == 1) goto cykD; else goto cykH;
       cykD: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           P64[Sp + 32] = P64[Sp + 32];
           Sp = Sp + 16;
           call _cyk8() args: 0, res: 0, upd: 0;
       cykH: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cykK; else goto cykJ;
       cykK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cykJ: // global
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 6;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cykw_info" {
     block_cykw_info:
         const _cykw;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.406127392 UTC

[section ""data" . GHC.List.notElem_closure" {
     GHC.List.notElem_closure:
         const GHC.List.notElem_info;
 },
 GHC.List.notElem_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cylE: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cylF; else goto uylZ;
       cylF: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.notElem_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uylZ: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cylu() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.notElem_info" {
     GHC.List.notElem_info:
         const GHC.List.notElem_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cylu() //  []
         { []
         }
     {offset
       cylu: // global
           I64[Sp - 8] = block_cylx_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uym1; else goto cyly;
       uym1: // global
           call _cylx(R1) args: 0, res: 0, upd: 0;
       cyly: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cylx() //  [R1]
         { []
         }
     {offset
       cylx: // global
           if (R1 & 7 == 1) goto cylB; else goto cylC;
       cylB: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cylC: // global
           I64[Sp] = block_cylM_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp + 24] = P64[R1 + 14];
           Sp = Sp - 24;
           call GHC.Classes./=_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cylx_info" {
     block_cylx_info:
         const _cylx;
         const 259;
         const 30;
 },
 _cylM() //  [R1]
         { []
         }
     {offset
       cylM: // global
           if (R1 & 7 == 1) goto cylT; else goto cylX;
       cylT: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cylX: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cylu() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cylM_info" {
     block_cylM_info:
         const _cylM;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.417007664 UTC

[section ""data" . GHC.List.elem_closure" {
     GHC.List.elem_closure:
         const GHC.List.elem_info;
 },
 GHC.List.elem_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cymK: // global
           if ((Sp + -56) < SpLim) (likely: False) goto cymL; else goto uyn5;
       cymL: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.elem_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       uyn5: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call _cymA() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.elem_info" {
     GHC.List.elem_info:
         const GHC.List.elem_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cymA() //  []
         { []
         }
     {offset
       cymA: // global
           I64[Sp - 8] = block_cymD_info;
           R1 = P64[Sp + 16];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyn7; else goto cymE;
       uyn7: // global
           call _cymD(R1) args: 0, res: 0, upd: 0;
       cymE: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cymD() //  [R1]
         { []
         }
     {offset
       cymD: // global
           if (R1 & 7 == 1) goto cymH; else goto cymI;
       cymH: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cymI: // global
           I64[Sp] = block_cymS_info;
           R2 = P64[Sp + 8];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp + 24] = P64[R1 + 14];
           Sp = Sp - 24;
           call GHC.Classes.==_entry(R2) args: 32, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cymD_info" {
     block_cymD_info:
         const _cymD;
         const 259;
         const 30;
 },
 _cymS() //  [R1]
         { []
         }
     {offset
       cymS: // global
           if (R1 & 7 == 1) goto cymZ; else goto cyn3;
       cymZ: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 24];
           Sp = Sp + 8;
           call _cymA() args: 0, res: 0, upd: 0;
       cyn3: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cymS_info" {
     block_cymS_info:
         const _cymS;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.426304433 UTC

[section ""data" . GHC.List.all_closure" {
     GHC.List.all_closure:
         const GHC.List.all_info;
 },
 GHC.List.all_entry() //  [R2, R3]
         { []
         }
     {offset
       cynQ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cynR; else goto uyob;
       cynR: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.all_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uyob: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cynG() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.all_info" {
     GHC.List.all_info:
         const GHC.List.all_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cynG() //  []
         { []
         }
     {offset
       cynG: // global
           I64[Sp - 8] = block_cynJ_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyod; else goto cynK;
       uyod: // global
           call _cynJ(R1) args: 0, res: 0, upd: 0;
       cynK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cynJ() //  [R1]
         { []
         }
     {offset
       cynJ: // global
           if (R1 & 7 == 1) goto cynN; else goto cynO;
       cynN: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cynO: // global
           I64[Sp] = block_cynY_info;
           R2 = P64[R1 + 6];
           _sxuA::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sxuA::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cynJ_info" {
     block_cynJ_info:
         const _cynJ;
         const 130;
         const 30;
 },
 _cynY() //  [R1]
         { []
         }
     {offset
       cynY: // global
           if (R1 & 7 == 1) goto cyo5; else goto cyo9;
       cyo5: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyo9: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _cynG() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cynY_info" {
     block_cynY_info:
         const _cynY;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.435233012 UTC

[section ""data" . GHC.List.any_closure" {
     GHC.List.any_closure:
         const GHC.List.any_info;
 },
 GHC.List.any_entry() //  [R2, R3]
         { []
         }
     {offset
       cyoR: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyoS; else goto uypc;
       cyoS: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.any_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uypc: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cyoH() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.any_info" {
     GHC.List.any_info:
         const GHC.List.any_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cyoH() //  []
         { []
         }
     {offset
       cyoH: // global
           I64[Sp - 8] = block_cyoK_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uype; else goto cyoL;
       uype: // global
           call _cyoK(R1) args: 0, res: 0, upd: 0;
       cyoL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyoK() //  [R1]
         { []
         }
     {offset
       cyoK: // global
           if (R1 & 7 == 1) goto cyoO; else goto cyoP;
       cyoO: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyoP: // global
           I64[Sp] = block_cyoZ_info;
           R2 = P64[R1 + 6];
           _sxuG::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sxuG::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cyoK_info" {
     block_cyoK_info:
         const _cyoK;
         const 130;
         const 30;
 },
 _cyoZ() //  [R1]
         { []
         }
     {offset
       cyoZ: // global
           if (R1 & 7 == 1) goto cyp6; else goto cypa;
       cyp6: // global
           P64[Sp + 8] = P64[Sp + 8];
           P64[Sp + 16] = P64[Sp + 16];
           Sp = Sp + 8;
           call _cyoH() args: 0, res: 0, upd: 0;
       cypa: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyoZ_info" {
     block_cyoZ_info:
         const _cyoZ;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.444141947 UTC

[section ""data" . GHC.List.or_closure" {
     GHC.List.or_closure:
         const GHC.List.or_info;
 },
 GHC.List.or_entry() //  [R2]
         { []
         }
     {offset
       cypS: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cypT; else goto uyqe;
       cypT: // global
           R2 = R2;
           R1 = GHC.List.or_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uyqe: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cypI() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.or_info" {
     GHC.List.or_info:
         const GHC.List.or_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cypI() //  []
         { []
         }
     {offset
       cypI: // global
           _sxuI::P64 = P64[Sp];
           I64[Sp] = block_cypL_info;
           R1 = _sxuI::P64;
           if (R1 & 7 != 0) goto uyqg; else goto cypM;
       uyqg: // global
           call _cypL(R1) args: 0, res: 0, upd: 0;
       cypM: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cypL() //  [R1]
         { []
         }
     {offset
       cypL: // global
           if (R1 & 7 == 1) goto cypP; else goto cypQ;
       cypP: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cypQ: // global
           I64[Sp - 8] = block_cyq0_info;
           _sxuL::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sxuL::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyqh; else goto cyq2;
       uyqh: // global
           call _cyq0(R1) args: 0, res: 0, upd: 0;
       cyq2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cypL_info" {
     block_cypL_info:
         const _cypL;
         const 0;
         const 30;
 },
 _cyq0() //  [R1]
         { []
         }
     {offset
       cyq0: // global
           if (R1 & 7 == 1) goto cyq8; else goto cyqc;
       cyq8: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cypI() args: 0, res: 0, upd: 0;
       cyqc: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyq0_info" {
     block_cyq0_info:
         const _cyq0;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.453729984 UTC

[section ""data" . GHC.List.and_closure" {
     GHC.List.and_closure:
         const GHC.List.and_info;
 },
 GHC.List.and_entry() //  [R2]
         { []
         }
     {offset
       cyqV: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyqW; else goto uyrh;
       cyqW: // global
           R2 = R2;
           R1 = GHC.List.and_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       uyrh: // global
           P64[Sp - 8] = R2;
           Sp = Sp - 8;
           call _cyqL() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.and_info" {
     GHC.List.and_info:
         const GHC.List.and_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cyqL() //  []
         { []
         }
     {offset
       cyqL: // global
           _sxuN::P64 = P64[Sp];
           I64[Sp] = block_cyqO_info;
           R1 = _sxuN::P64;
           if (R1 & 7 != 0) goto uyrj; else goto cyqP;
       uyrj: // global
           call _cyqO(R1) args: 0, res: 0, upd: 0;
       cyqP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyqO() //  [R1]
         { []
         }
     {offset
       cyqO: // global
           if (R1 & 7 == 1) goto cyqS; else goto cyqT;
       cyqS: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyqT: // global
           I64[Sp - 8] = block_cyr3_info;
           _sxuQ::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sxuQ::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyrk; else goto cyr5;
       uyrk: // global
           call _cyr3(R1) args: 0, res: 0, upd: 0;
       cyr5: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cyqO_info" {
     block_cyqO_info:
         const _cyqO;
         const 0;
         const 30;
 },
 _cyr3() //  [R1]
         { []
         }
     {offset
       cyr3: // global
           if (R1 & 7 == 1) goto cyrb; else goto cyrf;
       cyrb: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyrf: // global
           P64[Sp + 8] = P64[Sp + 8];
           Sp = Sp + 8;
           call _cyqL() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cyr3_info" {
     block_cyr3_info:
         const _cyr3;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.46254069 UTC

[section ""data" . GHC.List.reverse1_closure" {
     GHC.List.reverse1_closure:
         const GHC.List.reverse1_info;
 },
 GHC.List.reverse1_entry() //  [R2, R3]
         { []
         }
     {offset
       cys2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cys3; else goto uysa;
       cys3: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.reverse1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uysa: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cyrO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.reverse1_info" {
     GHC.List.reverse1_info:
         const GHC.List.reverse1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cyrO() //  []
         { []
         }
     {offset
       cyrO: // global
           _sxuS::P64 = P64[Sp];
           I64[Sp] = block_cyrR_info;
           R1 = _sxuS::P64;
           if (R1 & 7 != 0) goto uysc; else goto cyrS;
       uysc: // global
           call _cyrR(R1) args: 0, res: 0, upd: 0;
       cyrS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyrR() //  [R1]
         { []
         }
     {offset
       cyrR: // global
           _sxuT::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cyrZ; else goto cys0;
       cyrZ: // global
           R1 = _sxuT::P64 & (-8);
           Sp = Sp + 16;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cys0: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cys9; else goto cys8;
       cys9: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cys8: // global
           _sxuV::P64 = P64[R1 + 6];
           _sxuW::P64 = P64[R1 + 14];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sxuV::P64;
           P64[Hp] = _sxuT::P64;
           P64[Sp] = _sxuW::P64;
           P64[Sp + 8] = Hp - 14;
           call _cyrO() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cyrR_info" {
     block_cyrR_info:
         const _cyrR;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.470085437 UTC

[section ""data" . GHC.List.reverse_closure" {
     GHC.List.reverse_closure:
         const GHC.List.reverse_info;
 },
 GHC.List.reverse_entry() //  [R2]
         { []
         }
     {offset
       cysB: // global
           R3 = GHC.Types.[]_closure+1;
           R2 = R2;
           call GHC.List.reverse1_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.reverse_info" {
     GHC.List.reverse_info:
         const GHC.List.reverse_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.475582971 UTC

[section ""data" . GHC.List.$wbreak_closure" {
     GHC.List.$wbreak_closure:
         const GHC.List.$wbreak_info;
 },
 ds_sxv5_entry() //  [R1]
         { []
         }
     {offset
       cyt4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyt5; else goto cyt6;
       cyt5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyt6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cyt1_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wbreak_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ds_sxv5_info" {
     ds_sxv5_info:
         const ds_sxv5_entry;
         const 2;
         const 18;
 },
 _cyt1() //  [R1, R2]
         { []
         }
     {offset
       cyt1: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyt9; else goto cyt8;
       cyt9: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cyt8: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cyt1_info" {
     block_cyt1_info:
         const _cyt1;
         const 0;
         const 30;
 },
 GHC.List.$wbreak_entry() //  [R2, R3]
         { []
         }
     {offset
       cyte: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cytf; else goto cytg;
       cytf: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wbreak_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cytg: // global
           I64[Sp - 16] = block_cysN_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uytx; else goto cysO;
       uytx: // global
           call _cysN(R1) args: 0, res: 0, upd: 0;
       cysO: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.$wbreak_info" {
     GHC.List.$wbreak_info:
         const GHC.List.$wbreak_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cysN() //  [R1]
         { []
         }
     {offset
       cysN: // global
           if (R1 & 7 == 1) goto cytb; else goto cytc;
       cytb: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cytc: // global
           I64[Sp - 24] = block_cysT_info;
           _sxv2::P64 = P64[R1 + 6];
           R2 = _sxv2::P64;
           _sxv1::P64 = R1;
           _sxv3::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp - 16] = _sxv2::P64;
           P64[Sp - 8] = _sxv3::P64;
           P64[Sp] = _sxv1::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cysN_info" {
     block_cysN_info:
         const _cysN;
         const 1;
         const 30;
 },
 _cysT() //  [R1]
         { []
         }
     {offset
       cysT: // global
           if (R1 & 7 == 1) goto cyto; else goto cytv;
       cyto: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cytr; else goto cytq;
       cytr: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cytq: // global
           I64[Hp - 96] = ds_sxv5_info;
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 16];
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cysX::P64 = Hp - 96;
           P64[Hp - 48] = _cysX::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cysX::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cytv: // global
           R2 = P64[Sp + 24];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cysT_info" {
     block_cysT_info:
         const _cysT;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.487729057 UTC

[section ""data" . GHC.List.break_closure" {
     GHC.List.break_closure:
         const GHC.List.break_info;
 },
 GHC.List.break_entry() //  [R2, R3]
         { []
         }
     {offset
       cyum: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cyun; else goto cyuo;
       cyun: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.break_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyuo: // global
           I64[Sp - 8] = block_cyuj_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wbreak_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.break_info" {
     GHC.List.break_info:
         const GHC.List.break_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cyuj() //  [R1, R2]
         { []
         }
     {offset
       cyuj: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyur; else goto cyuq;
       cyur: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cyuq: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyuj_info" {
     block_cyuj_info:
         const _cyuj;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.496039473 UTC

[section ""data" . GHC.List.$wspan_closure" {
     GHC.List.$wspan_closure:
         const GHC.List.$wspan_info;
 },
 ds_sxvt_entry() //  [R1]
         { []
         }
     {offset
       cyuZ: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyv0; else goto cyv1;
       cyv0: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyv1: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cyuW_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ds_sxvt_info" {
     ds_sxvt_info:
         const ds_sxvt_entry;
         const 2;
         const 18;
 },
 _cyuW() //  [R1, R2]
         { []
         }
     {offset
       cyuW: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyv4; else goto cyv3;
       cyv4: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cyv3: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cyuW_info" {
     block_cyuW_info:
         const _cyuW;
         const 0;
         const 30;
 },
 GHC.List.$wspan_entry() //  [R2, R3]
         { []
         }
     {offset
       cyv9: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cyva; else goto cyvb;
       cyva: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wspan_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyvb: // global
           I64[Sp - 16] = block_cyuH_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyvr; else goto cyuI;
       uyvr: // global
           call _cyuH(R1) args: 0, res: 0, upd: 0;
       cyuI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.$wspan_info" {
     GHC.List.$wspan_info:
         const GHC.List.$wspan_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cyuH() //  [R1]
         { []
         }
     {offset
       cyuH: // global
           if (R1 & 7 == 1) goto cyv6; else goto cyv7;
       cyv6: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cyv7: // global
           I64[Sp - 24] = block_cyuN_info;
           _sxvq::P64 = P64[R1 + 6];
           R2 = _sxvq::P64;
           _sxvp::P64 = R1;
           _sxvr::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp - 16] = _sxvq::P64;
           P64[Sp - 8] = _sxvr::P64;
           P64[Sp] = _sxvp::P64;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cyuH_info" {
     block_cyuH_info:
         const _cyuH;
         const 1;
         const 30;
 },
 _cyuN() //  [R1]
         { []
         }
     {offset
       cyuN: // global
           if (R1 & 7 == 1) goto cyvi; else goto cyvm;
       cyvi: // global
           R2 = P64[Sp + 24];
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cyvm: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cyvp; else goto cyvo;
       cyvp: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyvo: // global
           I64[Hp - 96] = ds_sxvt_info;
           P64[Hp - 80] = P64[Sp + 32];
           P64[Hp - 72] = P64[Sp + 16];
           I64[Hp - 64] = stg_sel_1_upd_info;
           _cyuS::P64 = Hp - 96;
           P64[Hp - 48] = _cyuS::P64;
           I64[Hp - 40] = stg_sel_0_upd_info;
           P64[Hp - 24] = _cyuS::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 40;
           R2 = Hp - 64;
           R1 = Hp - 14;
           Sp = Sp + 40;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyuN_info" {
     block_cyuN_info:
         const _cyuN;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.507685196 UTC

[section ""data" . GHC.List.span_closure" {
     GHC.List.span_closure:
         const GHC.List.span_info;
 },
 GHC.List.span_entry() //  [R2, R3]
         { []
         }
     {offset
       cywg: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cywh; else goto cywi;
       cywh: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.span_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cywi: // global
           I64[Sp - 8] = block_cywd_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wspan_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.span_info" {
     GHC.List.span_info:
         const GHC.List.span_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cywd() //  [R1, R2]
         { []
         }
     {offset
       cywd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cywl; else goto cywk;
       cywl: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cywk: // global
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cywd_info" {
     block_cywd_info:
         const _cywd;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.515309497 UTC

[section ""data" . GHC.List.takeFB_closure" {
     GHC.List.takeFB_closure:
         const GHC.List.takeFB_info;
 },
 sat_sxvV_entry() //  [R1]
         { []
         }
     {offset
       cywO: // global
           _sxvV::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cywR; else goto cywS;
       cywS: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cywU; else goto cywT;
       cywU: // global
           HpAlloc = 16;
           goto cywR;
       cywR: // global
           R1 = _sxvV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cywT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sxvV::P64;
           _sxvO::P64 = P64[_sxvV::P64 + 16];
           _sxvT::I64 = I64[_sxvV::P64 + 24] - 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sxvT::I64;
           R2 = Hp - 7;
           R1 = _sxvO::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxvV_info" {
     sat_sxvV_info:
         const sat_sxvV_entry;
         const 4294967297;
         const 19;
 },
 GHC.List.takeFB_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cywV: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cywW; else goto cywX;
       cywW: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.takeFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cywX: // global
           I64[Sp - 40] = block_cywB_info;
           R1 = R6;
           P64[Sp - 32] = R2;
           P64[Sp - 24] = R3;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uyx4; else goto cywC;
       uyx4: // global
           call _cywB(R1) args: 0, res: 0, upd: 0;
       cywC: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.takeFB_info" {
     GHC.List.takeFB_info:
         const GHC.List.takeFB_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cywB() //  [R1]
         { []
         }
     {offset
       cywB: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cyx0; else goto cywZ;
       cyx0: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cywZ: // global
           _sxvL::P64 = P64[Sp + 8];
           _sxvN::P64 = P64[Sp + 24];
           _sxvS::I64 = I64[R1 + 7];
           if (_sxvS::I64 != 1) goto cyx2; else goto cyx3;
       cyx2: // global
           I64[Hp - 24] = sat_sxvV_info;
           P64[Hp - 8] = P64[Sp + 32];
           I64[Hp] = _sxvS::I64;
           R3 = Hp - 24;
           R2 = _sxvN::P64;
           R1 = _sxvL::P64;
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyx3: // global
           Hp = Hp - 32;
           R3 = P64[Sp + 16];
           R2 = _sxvN::P64;
           R1 = _sxvL::P64;
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cywB_info" {
     block_cywB_info:
         const _cywB;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.523361206 UTC

[section ""data" . GHC.List.flipSeqTake_closure" {
     GHC.List.flipSeqTake_closure:
         const GHC.List.flipSeqTake_info;
 },
 GHC.List.flipSeqTake_entry() //  [R2, R3]
         { []
         }
     {offset
       cyxv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyxw; else goto cyxx;
       cyxw: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.flipSeqTake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyxx: // global
           I64[Sp - 16] = block_cyxs_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyxB; else goto cyxt;
       uyxB: // global
           call _cyxs() args: 0, res: 0, upd: 0;
       cyxt: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.flipSeqTake_info" {
     GHC.List.flipSeqTake_info:
         const GHC.List.flipSeqTake_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cyxs() //  []
         { []
         }
     {offset
       cyxs: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyxs_info" {
     block_cyxs_info:
         const _cyxs;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.531121197 UTC

[section ""data" . GHC.List.$wunsafeTake_closure" {
     GHC.List.$wunsafeTake_closure:
         const GHC.List.$wunsafeTake_info;
 },
 sat_sxw7_entry() //  [R1]
         { []
         }
     {offset
       cyy4: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyy5; else goto cyy6;
       cyy5: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyy6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 16];
           R2 = I64[R1 + 24] - 1;
           Sp = Sp - 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxw7_info" {
     sat_sxw7_info:
         const sat_sxw7_entry;
         const 4294967297;
         const 19;
 },
 GHC.List.$wunsafeTake_entry() //  [R2, R3]
         { []
         }
     {offset
       cyyb: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyyc; else goto cyyd;
       cyyc: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wunsafeTake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyyd: // global
           I64[Sp - 16] = block_cyxQ_info;
           R1 = R3;
           I64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyyp; else goto cyxR;
       uyyp: // global
           call _cyxQ(R1) args: 0, res: 0, upd: 0;
       cyxR: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.$wunsafeTake_info" {
     GHC.List.$wunsafeTake_info:
         const GHC.List.$wunsafeTake_entry;
         const 0;
         const 14;
         const 8589934605;
 },
 _cyxQ() //  [R1]
         { []
         }
     {offset
       cyxQ: // global
           if (R1 & 7 == 1) goto cyy8; else goto cyy9;
       cyy8: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyy9: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cyyi; else goto cyyh;
       cyyi: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyyh: // global
           _sxw3::P64 = P64[R1 + 6];
           _sxw5::I64 = I64[Sp + 8];
           if (_sxw5::I64 != 1) goto cyyl; else goto cyyo;
       cyyl: // global
           _sxw4::P64 = P64[R1 + 14];
           I64[Hp - 48] = sat_sxw7_info;
           P64[Hp - 32] = _sxw4::P64;
           I64[Hp - 24] = _sxw5::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sxw3::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyyo: // global
           I64[Hp - 48] = :_con_info;
           P64[Hp - 40] = _sxw3::P64;
           P64[Hp - 32] = GHC.Types.[]_closure+1;
           _cyyn::P64 = Hp - 46;
           Hp = Hp - 32;
           R1 = _cyyn::P64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyxQ_info" {
     block_cyxQ_info:
         const _cyxQ;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.539272426 UTC

[section ""data" . GHC.List.unsafeTake_closure" {
     GHC.List.unsafeTake_closure:
         const GHC.List.unsafeTake_info;
 },
 GHC.List.unsafeTake_entry() //  [R2, R3]
         { []
         }
     {offset
       cyyZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyz0; else goto cyz1;
       cyz0: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.unsafeTake_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyz1: // global
           I64[Sp - 16] = block_cyyW_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyz5; else goto cyyX;
       uyz5: // global
           call _cyyW(R1) args: 0, res: 0, upd: 0;
       cyyX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.unsafeTake_info" {
     GHC.List.unsafeTake_info:
         const GHC.List.unsafeTake_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cyyW() //  [R1]
         { []
         }
     {offset
       cyyW: // global
           R3 = P64[Sp + 8];
           R2 = I64[R1 + 7];
           Sp = Sp + 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyyW_info" {
     block_cyyW_info:
         const _cyyW;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.545728841 UTC

[section ""data" . GHC.List.take_closure" {
     GHC.List.take_closure:
         const GHC.List.take_info;
 },
 GHC.List.take_entry() //  [R2, R3]
         { []
         }
     {offset
       cyzn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyzo; else goto cyzp;
       cyzo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.take_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyzp: // global
           I64[Sp - 16] = block_cyzk_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyzy; else goto cyzl;
       uyzy: // global
           call _cyzk(R1) args: 0, res: 0, upd: 0;
       cyzl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.take_info" {
     GHC.List.take_info:
         const GHC.List.take_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cyzk() //  [R1]
         { []
         }
     {offset
       cyzk: // global
           _sxwf::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(0, _sxwf::I64)) goto cyzw; else goto cyzx;
       cyzw: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyzx: // global
           R3 = P64[Sp + 8];
           R2 = _sxwf::I64;
           Sp = Sp + 16;
           call GHC.List.$wunsafeTake_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyzk_info" {
     block_cyzk_info:
         const _cyzk;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.552318033 UTC

[section ""data" . GHC.List.dropWhile_closure" {
     GHC.List.dropWhile_closure:
         const GHC.List.dropWhile_info;
 },
 GHC.List.dropWhile_entry() //  [R2, R3]
         { []
         }
     {offset
       cyzW: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cyzX; else goto uyAh;
       cyzX: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.dropWhile_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uyAh: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cyzM() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.dropWhile_info" {
     GHC.List.dropWhile_info:
         const GHC.List.dropWhile_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cyzM() //  []
         { []
         }
     {offset
       cyzM: // global
           I64[Sp - 8] = block_cyzP_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyAj; else goto cyzQ;
       uyAj: // global
           call _cyzP(R1) args: 0, res: 0, upd: 0;
       cyzQ: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyzP() //  [R1]
         { []
         }
     {offset
       cyzP: // global
           if (R1 & 7 == 1) goto cyzT; else goto cyzU;
       cyzT: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyzU: // global
           I64[Sp - 8] = block_cyA4_info;
           R2 = P64[R1 + 6];
           _sxwj::P64 = R1;
           _sxwl::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sxwl::P64;
           P64[Sp + 16] = _sxwj::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cyzP_info" {
     block_cyzP_info:
         const _cyzP;
         const 130;
         const 30;
 },
 _cyA4() //  [R1]
         { []
         }
     {offset
       cyA4: // global
           if (R1 & 7 == 1) goto cyAb; else goto cyAf;
       cyAb: // global
           R1 = P64[Sp + 24] & (-8);
           Sp = Sp + 32;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cyAf: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = P64[Sp + 8];
           Sp = Sp + 16;
           call _cyzM() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cyA4_info" {
     block_cyA4_info:
         const _cyA4;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.560810108 UTC

[section ""data" . GHC.List.takeWhileFB_closure" {
     GHC.List.takeWhileFB_closure:
         const GHC.List.takeWhileFB_info;
 },
 GHC.List.takeWhileFB_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cyAW: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cyAX; else goto cyAY;
       cyAX: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.takeWhileFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyAY: // global
           I64[Sp - 40] = block_cyAQ_info;
           _sxwn::P64 = R2;
           R2 = R5;
           R1 = _sxwn::P64;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.takeWhileFB_info" {
     GHC.List.takeWhileFB_info:
         const GHC.List.takeWhileFB_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cyAQ() //  [R1]
         { []
         }
     {offset
       cyAQ: // global
           if (R1 & 7 == 1) goto cyAT; else goto cyAU;
       cyAT: // global
           R1 = P64[Sp + 16];
           Sp = Sp + 40;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cyAU: // global
           R3 = P64[Sp + 32];
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 40;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyAQ_info" {
     block_cyAQ_info:
         const _cyAQ;
         const 4;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.567927362 UTC

[section ""data" . GHC.List.takeWhile_closure" {
     GHC.List.takeWhile_closure:
         const GHC.List.takeWhile_info;
 },
 sat_sxwz_entry() //  [R1]
         { []
         }
     {offset
       cyBz: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyBA; else goto cyBB;
       cyBA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyBB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.takeWhile_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxwz_info" {
     sat_sxwz_info:
         const sat_sxwz_entry;
         const 2;
         const 18;
 },
 GHC.List.takeWhile_entry() //  [R2, R3]
         { []
         }
     {offset
       cyBG: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cyBH; else goto cyBI;
       cyBH: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.takeWhile_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyBI: // global
           I64[Sp - 16] = block_cyBk_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyC0; else goto cyBl;
       uyC0: // global
           call _cyBk(R1) args: 0, res: 0, upd: 0;
       cyBl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.takeWhile_info" {
     GHC.List.takeWhile_info:
         const GHC.List.takeWhile_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cyBk() //  [R1]
         { []
         }
     {offset
       cyBk: // global
           if (R1 & 7 == 1) goto uyBW; else goto cyBE;
       uyBW: // global
           Sp = Sp + 16;
           call _cyBP() args: 0, res: 0, upd: 0;
       cyBE: // global
           I64[Sp - 16] = block_cyBq_info;
           _sxww::P64 = P64[R1 + 6];
           R2 = _sxww::P64;
           _sxwx::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp - 8] = _sxwx::P64;
           P64[Sp] = _sxww::P64;
           Sp = Sp - 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cyBk_info" {
     block_cyBk_info:
         const _cyBk;
         const 1;
         const 30;
 },
 _cyBq() //  [R1]
         { []
         }
     {offset
       cyBq: // global
           if (R1 & 7 == 1) goto uyBX; else goto cyBR;
       uyBX: // global
           Sp = Sp + 32;
           call _cyBP() args: 0, res: 0, upd: 0;
       cyBR: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cyBU; else goto cyBT;
       cyBU: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyBT: // global
           I64[Hp - 48] = sat_sxwz_info;
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyBq_info" {
     block_cyBq_info:
         const _cyBq;
         const 3;
         const 30;
 },
 _cyBP() //  []
         { []
         }
     {offset
       cyBP: // global
           R1 = []_closure+1;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.579030377 UTC

[section ""data" . GHC.List.repeat_closure" {
     GHC.List.repeat_closure:
         const GHC.List.repeat_info;
 },
 GHC.List.repeat_entry() //  [R2]
         { []
         }
     {offset
       cyCE: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyCI; else goto cyCH;
       cyCI: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = GHC.List.repeat_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cyCH: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R2;
           _cyCD::P64 = Hp - 14;
           P64[Hp] = _cyCD::P64;
           R1 = _cyCD::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.repeat_info" {
     GHC.List.repeat_info:
         const GHC.List.repeat_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 section ""data" . GHC.List.repeatFB_closure" {
     GHC.List.repeatFB_closure:
         const GHC.List.repeatFB_info;
 },
 GHC.List.repeatFB_entry() //  [R2, R3]
         { []
         }
     {offset
       cyCO: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cyCS; else goto cyCR;
       cyCS: // global
           HpAlloc = 40;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.repeatFB_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyCR: // global
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           _cyCN::P64 = Hp - 32;
           P64[Hp] = _cyCN::P64;
           R1 = _cyCN::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.repeatFB_info" {
     GHC.List.repeatFB_info:
         const GHC.List.repeatFB_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.587330739 UTC

[section ""data" . GHC.List.replicate_closure" {
     GHC.List.replicate_closure:
         const GHC.List.replicate_info;
 },
 sat_sxwP_entry() //  [R1]
         { []
         }
     {offset
       cyDv: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyDw; else goto cyDx;
       cyDw: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyDx: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 24] - 1;
           R1 = P64[R1 + 16];
           Sp = Sp - 16;
           call $wxs_sxwL_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxwP_info" {
     sat_sxwP_info:
         const sat_sxwP_entry;
         const 4294967297;
         const 19;
 },
 $wxs_sxwL_entry() //  [R1, R2]
         { []
         }
     {offset
       cyDB: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cyDF; else goto cyDE;
       cyDF: // global
           HpAlloc = 56;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cyDE: // global
           if (R2 == 1) goto cyDA; else goto cyDz;
       cyDA: // global
           _sxwK::P64 = P64[R1 + 15];
           Hp = Hp - 56;
           R1 = _sxwK::P64;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyDz: // global
           _sxwG::P64 = P64[R1 + 7];
           I64[Hp - 48] = sat_sxwP_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sxwG::P64;
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . $wxs_sxwL_info" {
     $wxs_sxwL_info:
         const $wxs_sxwL_entry;
         const 2;
         const 11;
         const 4294967300;
 },
 GHC.List.replicate_entry() //  [R2, R3]
         { []
         }
     {offset
       cyDH: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyDI; else goto cyDJ;
       cyDI: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.replicate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyDJ: // global
           I64[Sp - 16] = block_cyD8_info;
           R1 = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyDQ; else goto cyD9;
       uyDQ: // global
           call _cyD8(R1) args: 0, res: 0, upd: 0;
       cyD9: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.replicate_info" {
     GHC.List.replicate_info:
         const GHC.List.replicate_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cyD8() //  [R1]
         { []
         }
     {offset
       cyD8: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cyDM; else goto cyDL;
       cyDM: // global
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyDL: // global
           _sxwI::I64 = I64[R1 + 7];
           if (%MO_S_Ge_W64(0, _sxwI::I64)) goto cyDO; else goto cyDP;
       cyDO: // global
           Hp = Hp - 48;
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyDP: // global
           I64[Hp - 40] = :_con_info;
           _sxwG::P64 = P64[Sp + 8];
           P64[Hp - 32] = _sxwG::P64;
           P64[Hp - 24] = GHC.Types.[]_closure+1;
           I64[Hp - 16] = $wxs_sxwL_info;
           P64[Hp - 8] = _sxwG::P64;
           P64[Hp] = Hp - 38;
           R2 = _sxwI::I64;
           R1 = Hp - 15;
           Sp = Sp + 16;
           call $wxs_sxwL_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyD8_info" {
     block_cyD8_info:
         const _cyD8;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.598562619 UTC

[section ""data" . GHC.List.$witerate'_closure" {
     GHC.List.$witerate'_closure:
         const GHC.List.$witerate'_info;
 },
 sat_sxwW_entry() //  [R1]
         { []
         }
     {offset
       cyEz: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyEA; else goto cyEB;
       cyEA: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyEB: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cyEw_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$witerate'_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxwW_info" {
     sat_sxwW_info:
         const sat_sxwW_entry;
         const 2;
         const 18;
 },
 _cyEw() //  [R1, R2]
         { []
         }
     {offset
       cyEw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyEE; else goto cyED;
       cyEE: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cyED: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cyEw_info" {
     block_cyEw_info:
         const _cyEw;
         const 0;
         const 30;
 },
 GHC.List.$witerate'_entry() //  [R2, R3]
         { []
         }
     {offset
       cyEF: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyEG; else goto cyEH;
       cyEG: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$witerate'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyEH: // global
           I64[Sp - 24] = block_cyEq_info;
           _sxwQ::P64 = R2;
           R2 = R3;
           R1 = _sxwQ::P64;
           P64[Sp - 16] = _sxwQ::P64;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.$witerate'_info" {
     GHC.List.$witerate'_info:
         const GHC.List.$witerate'_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cyEq() //  [R1]
         { []
         }
     {offset
       cyEq: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cyEK; else goto cyEJ;
       cyEK: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyEJ: // global
           I64[Hp - 24] = sat_sxwW_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R2 = Hp - 24;
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyEq_info" {
     block_cyEq_info:
         const _cyEq;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.609915352 UTC

[section ""data" . GHC.List.iterate'FB_closure" {
     GHC.List.iterate'FB_closure:
         const GHC.List.iterate'FB_info;
 },
 go2_sxx0_entry() //  [R1, R2]
         { []
         }
     {offset
       cyFk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cyFl; else goto cyFm;
       cyFl: // global
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cyFm: // global
           I64[Sp - 32] = block_cyFh_info;
           _sxx1::P64 = R2;
           R2 = R2;
           _sxx0::P64 = R1;
           _sxwX::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp - 24] = _sxwX::P64;
           P64[Sp - 16] = _sxx0::P64;
           P64[Sp - 8] = _sxx1::P64;
           Sp = Sp - 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . go2_sxx0_info" {
     go2_sxx0_info:
         const go2_sxx0_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 _cyFh() //  [R1]
         { []
         }
     {offset
       cyFh: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cyFp; else goto cyFo;
       cyFp: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyFo: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = P64[Sp + 24];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyFh_info" {
     block_cyFh_info:
         const _cyFh;
         const 3;
         const 30;
 },
 GHC.List.iterate'FB_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cyFq: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyFu; else goto cyFt;
       cyFu: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterate'FB_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyFt: // global
           I64[Hp - 16] = go2_sxx0_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = R4;
           R1 = Hp - 15;
           call go2_sxx0_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.iterate'FB_info" {
     GHC.List.iterate'FB_info:
         const GHC.List.iterate'FB_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 section ""data" . GHC.List.iterate'_closure" {
     GHC.List.iterate'_closure:
         const GHC.List.iterate'_info;
 },
 GHC.List.iterate'_entry() //  [R2, R3]
         { []
         }
     {offset
       cyFC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cyFD; else goto cyFE;
       cyFD: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterate'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyFE: // global
           I64[Sp - 8] = block_cyFz_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$witerate'_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.iterate'_info" {
     GHC.List.iterate'_info:
         const GHC.List.iterate'_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cyFz() //  [R1, R2]
         { []
         }
     {offset
       cyFz: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyFH; else goto cyFG;
       cyFH: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cyFG: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyFz_info" {
     block_cyFz_info:
         const _cyFz;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.621907461 UTC

[section ""data" . GHC.List.$witerate_closure" {
     GHC.List.$witerate_closure:
         const GHC.List.$witerate_info;
 },
 sat_sxxf_entry() //  [R1]
         { []
         }
     {offset
       cyGk: // global
           _sxxf::P64 = R1;
           if ((Sp + -24) < SpLim) (likely: False) goto cyGl; else goto cyGm;
       cyGm: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cyGo; else goto cyGn;
       cyGo: // global
           HpAlloc = 32;
           goto cyGl;
       cyGl: // global
           R1 = _sxxf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyGn: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sxxf::P64;
           _sxx9::P64 = P64[_sxxf::P64 + 16];
           _sxxa::P64 = P64[_sxxf::P64 + 24];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sxx9::P64;
           P64[Hp] = _sxxa::P64;
           I64[Sp - 24] = block_cyGh_info;
           R3 = Hp - 24;
           R2 = _sxx9::P64;
           Sp = Sp - 24;
           call GHC.List.$witerate_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxxf_info" {
     sat_sxxf_info:
         const sat_sxxf_entry;
         const 2;
         const 18;
 },
 _cyGh() //  [R1, R2]
         { []
         }
     {offset
       cyGh: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyGr; else goto cyGq;
       cyGr: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cyGq: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cyGh_info" {
     block_cyGh_info:
         const _cyGh;
         const 0;
         const 30;
 },
 GHC.List.$witerate_entry() //  [R2, R3]
         { []
         }
     {offset
       cyGs: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cyGw; else goto cyGv;
       cyGw: // global
           HpAlloc = 32;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$witerate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyGv: // global
           I64[Hp - 24] = sat_sxxf_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = Hp - 24;
           R1 = R3;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.$witerate_info" {
     GHC.List.$witerate_info:
         const GHC.List.$witerate_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.631182126 UTC

[section ""data" . GHC.List.iterateFB_closure" {
     GHC.List.iterateFB_closure:
         const GHC.List.iterateFB_info;
 },
 sat_sxxm_entry() //  [R1]
         { []
         }
     {offset
       cyH3: // global
           _sxxm::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cyH4; else goto cyH5;
       cyH5: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cyH7; else goto cyH6;
       cyH7: // global
           HpAlloc = 32;
           goto cyH4;
       cyH4: // global
           R1 = _sxxm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyH6: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sxxm::P64;
           _sxxh::P64 = P64[_sxxm::P64 + 16];
           _sxxj::P64 = P64[_sxxm::P64 + 24];
           _sxxk::P64 = P64[_sxxm::P64 + 32];
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = _sxxh::P64;
           P64[Hp] = _sxxk::P64;
           R2 = Hp - 24;
           R1 = _sxxj::P64;
           Sp = Sp - 16;
           call go2_sxxj_entry(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxxm_info" {
     sat_sxxm_info:
         const sat_sxxm_entry;
         const 3;
         const 15;
 },
 go2_sxxj_entry() //  [R1, R2]
         { []
         }
     {offset
       cyH8: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cyHc; else goto cyHb;
       cyHc: // global
           HpAlloc = 40;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cyHb: // global
           _sxxg::P64 = P64[R1 + 7];
           _sxxh::P64 = P64[R1 + 15];
           I64[Hp - 32] = sat_sxxm_info;
           P64[Hp - 16] = _sxxh::P64;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 32;
           R2 = R2;
           R1 = _sxxg::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . go2_sxxj_info" {
     go2_sxxj_info:
         const go2_sxxj_entry;
         const 2;
         const 11;
         const 4294967301;
 },
 GHC.List.iterateFB_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cyHd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyHh; else goto cyHg;
       cyHh: // global
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterateFB_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyHg: // global
           I64[Hp - 16] = go2_sxxj_info;
           P64[Hp - 8] = R2;
           P64[Hp] = R3;
           R2 = R4;
           R1 = Hp - 15;
           call go2_sxxj_entry(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.iterateFB_info" {
     GHC.List.iterateFB_info:
         const GHC.List.iterateFB_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 section ""data" . GHC.List.iterate_closure" {
     GHC.List.iterate_closure:
         const GHC.List.iterate_info;
 },
 GHC.List.iterate_entry() //  [R2, R3]
         { []
         }
     {offset
       cyHp: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cyHq; else goto cyHr;
       cyHq: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.iterate_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyHr: // global
           I64[Sp - 8] = block_cyHm_info;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$witerate_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.iterate_info" {
     GHC.List.iterate_info:
         const GHC.List.iterate_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cyHm() //  [R1, R2]
         { []
         }
     {offset
       cyHm: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyHu; else goto cyHt;
       cyHu: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cyHt: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyHm_info" {
     block_cyHm_info:
         const _cyHm;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.642710211 UTC

[section ""cstring" . lvl27_ru9o_bytes" {
     lvl27_ru9o_bytes:
         I8[] [71,72,67,47,76,105,115,116,46,104,115,58,52,49,49,58,51,52,45,53,53,124,113,115,64,40,113,32,58,32,95,41]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.644989327 UTC

[section ""data" . lvl28_ru9p_closure" {
     lvl28_ru9p_closure:
         const lvl28_ru9p_info;
         const 0;
         const 0;
         const 0;
 },
 lvl28_ru9p_entry() //  [R1]
         { []
         }
     {offset
       cyI2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyI3; else goto cyI4;
       cyI3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyI4: // global
           (_cyHZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cyHZ::I64 == 0) goto cyI1; else goto cyI0;
       cyI1: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cyI0: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cyHZ::I64;
           R2 = lvl27_ru9o_bytes;
           Sp = Sp - 16;
           call Control.Exception.Base.patError_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl28_ru9p_info" {
     lvl28_ru9p_info:
         const lvl28_ru9p_entry;
         const 0;
         const 4294967317;
         const SxGK_srt+368;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.651864949 UTC

[section ""data" . GHC.List.scanr1_closure" {
     GHC.List.scanr1_closure:
         const GHC.List.scanr1_info;
         const 0;
 },
 ds3_sxxA_entry() //  [R1]
         { []
         }
     {offset
       cyID: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyIE; else goto cyIF;
       cyIE: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyIF: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cyIx_info;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.scanr1_entry(R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ds3_sxxA_info" {
     ds3_sxxA_info:
         const ds3_sxxA_entry;
         const 2;
         const 12884901906;
         const SxGK_srt+376;
 },
 _cyIx() //  [R1]
         { []
         }
     {offset
       cyIx: // global
           if (R1 & 7 == 1) goto cyIA; else goto cyIB;
       cyIA: // global
           R1 = lvl28_ru9p_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
       cyIB: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyIO; else goto cyIN;
       cyIO: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cyIN: // global
           _sxxC::P64 = P64[R1 + 6];
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = _sxxC::P64;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cyIx_info" {
     block_cyIx_info:
         const _cyIx;
         const 0;
         const 4294967326;
         const SxGK_srt+384;
 },
 sat_sxxI_entry() //  [R1]
         { []
         }
     {offset
       cyIV: // global
           _sxxI::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cyIW; else goto cyIX;
       cyIX: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyIZ; else goto cyIY;
       cyIZ: // global
           HpAlloc = 24;
           goto cyIW;
       cyIW: // global
           R1 = _sxxI::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyIY: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sxxI::P64;
           _sxxs::P64 = P64[_sxxI::P64 + 16];
           _sxxv::P64 = P64[_sxxI::P64 + 24];
           _sxxA::P64 = P64[_sxxI::P64 + 32];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sxxA::P64;
           R3 = Hp - 16;
           R2 = _sxxv::P64;
           R1 = _sxxs::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxxI_info" {
     sat_sxxI_info:
         const sat_sxxI_entry;
         const 3;
         const 15;
 },
 GHC.List.scanr1_entry() //  [R2, R3]
         { []
         }
     {offset
       cyJ4: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyJ5; else goto cyJ6;
       cyJ5: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanr1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyJ6: // global
           I64[Sp - 16] = block_cyIh_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyJo; else goto cyIi;
       uyJo: // global
           call _cyIh(R1) args: 0, res: 0, upd: 0;
       cyIi: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.scanr1_info" {
     GHC.List.scanr1_info:
         const GHC.List.scanr1_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const SxGK_srt+376;
 },
 _cyIh() //  [R1]
         { []
         }
     {offset
       cyIh: // global
           if (R1 & 7 == 1) goto cyJ1; else goto cyJ2;
       cyJ1: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyJ2: // global
           I64[Sp - 8] = block_cyIn_info;
           _sxxv::P64 = P64[R1 + 6];
           R1 = P64[R1 + 14];
           P64[Sp] = _sxxv::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyJn; else goto cyIo;
       uyJn: // global
           call _cyIn(R1) args: 0, res: 0, upd: 0;
       cyIo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cyIh_info" {
     block_cyIh_info:
         const _cyIh;
         const 1;
         const 12884901918;
         const SxGK_srt+376;
 },
 _cyIn() //  [R1]
         { []
         }
     {offset
       cyIn: // global
           _sxxv::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cyJd; else goto cyJi;
       cyJd: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyJg; else goto cyJf;
       cyJg: // global
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyJf: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sxxv::P64;
           P64[Hp] = GHC.Types.[]_closure+1;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyJi: // global
           Hp = Hp + 120;
           if (Hp > HpLim) (likely: False) goto cyJl; else goto cyJk;
       cyJl: // global
           HpAlloc = 120;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyJk: // global
           I64[Hp - 112] = ds3_sxxA_info;
           _sxxs::P64 = P64[Sp + 16];
           P64[Hp - 96] = _sxxs::P64;
           P64[Hp - 88] = R1;
           I64[Hp - 80] = stg_sel_0_upd_info;
           _cyIt::P64 = Hp - 112;
           P64[Hp - 64] = _cyIt::P64;
           I64[Hp - 56] = sat_sxxI_info;
           P64[Hp - 40] = _sxxs::P64;
           P64[Hp - 32] = _sxxv::P64;
           P64[Hp - 24] = _cyIt::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 80;
           R1 = Hp - 14;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyIn_info" {
     block_cyIn_info:
         const _cyIn;
         const 2;
         const 12884901918;
         const SxGK_srt+376;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.667229092 UTC

[section ""data" . GHC.List.scanrFB_closure" {
     GHC.List.scanrFB_closure:
         const GHC.List.scanrFB_info;
 },
 GHC.List.scanrFB_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cyKm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cyKs; else goto cyKt;
       cyKs: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanrFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyKt: // global
           I64[Sp - 32] = block_cyKj_info;
           R1 = R5;
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R3;
           P64[Sp - 8] = R4;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto uyKx; else goto cyKk;
       uyKx: // global
           call _cyKj(R1) args: 0, res: 0, upd: 0;
       cyKk: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.scanrFB_info" {
     GHC.List.scanrFB_info:
         const GHC.List.scanrFB_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _cyKj() //  [R1]
         { []
         }
     {offset
       cyKj: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cyKw; else goto cyKv;
       cyKw: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyKv: // global
           _sxxS::P64 = P64[R1 + 7];
           _sxxT::P64 = P64[R1 + 15];
           I64[Hp - 96] = stg_ap_3_upd_info;
           P64[Hp - 80] = P64[Sp + 16];
           P64[Hp - 72] = _sxxS::P64;
           P64[Hp - 64] = _sxxT::P64;
           I64[Hp - 56] = stg_ap_3_upd_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = _sxxS::P64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 56;
           P64[Hp] = Hp - 96;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyKj_info" {
     block_cyKj_info:
         const _cyKj;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.675783628 UTC

[section ""data" . GHC.List.$wscanr_closure" {
     GHC.List.$wscanr_closure:
         const GHC.List.$wscanr_info;
 },
 ds_sxy2_entry() //  [R1]
         { []
         }
     {offset
       cyL9: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyLa; else goto cyLb;
       cyLa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyLb: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cyL5_info;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wscanr_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . ds_sxy2_info" {
     ds_sxy2_info:
         const ds_sxy2_entry;
         const 3;
         const 15;
 },
 _cyL5() //  [R1, R2]
         { []
         }
     {offset
       cyL5: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cyLe; else goto cyLd;
       cyLe: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cyLd: // global
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = R1;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 38;
           P64[Hp] = R1;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cyL5_info" {
     block_cyL5_info:
         const _cyL5;
         const 0;
         const 30;
 },
 sat_sxyb_entry() //  [R1]
         { []
         }
     {offset
       cyLl: // global
           _sxyb::P64 = R1;
           if ((Sp + -16) < SpLim) (likely: False) goto cyLm; else goto cyLn;
       cyLn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyLp; else goto cyLo;
       cyLp: // global
           HpAlloc = 24;
           goto cyLm;
       cyLm: // global
           R1 = _sxyb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyLo: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sxyb::P64;
           _sxxW::P64 = P64[_sxyb::P64 + 16];
           _sxy0::P64 = P64[_sxyb::P64 + 24];
           _sxy2::P64 = P64[_sxyb::P64 + 32];
           I64[Hp - 16] = stg_sel_1_upd_info;
           P64[Hp] = _sxy2::P64;
           R3 = Hp - 16;
           R2 = _sxy0::P64;
           R1 = _sxxW::P64;
           Sp = Sp - 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxyb_info" {
     sat_sxyb_info:
         const sat_sxyb_entry;
         const 3;
         const 15;
 },
 GHC.List.$wscanr_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cyLu: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyLv; else goto cyLw;
       cyLv: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wscanr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyLw: // global
           I64[Sp - 24] = block_cyKV_info;
           R1 = R4;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto uyLC; else goto cyKW;
       uyLC: // global
           call _cyKV(R1) args: 0, res: 0, upd: 0;
       cyKW: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.$wscanr_info" {
     GHC.List.$wscanr_info:
         const GHC.List.$wscanr_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cyKV() //  [R1]
         { []
         }
     {offset
       cyKV: // global
           _sxxX::P64 = P64[Sp + 16];
           if (R1 & 7 == 1) goto cyLr; else goto cyLs;
       cyLr: // global
           R2 = GHC.Types.[]_closure+1;
           R1 = _sxxX::P64;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
       cyLs: // global
           Hp = Hp + 104;
           if (Hp > HpLim) (likely: False) goto cyLB; else goto cyLA;
       cyLB: // global
           HpAlloc = 104;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyLA: // global
           _sxy0::P64 = P64[R1 + 6];
           _sxy1::P64 = P64[R1 + 14];
           I64[Hp - 96] = ds_sxy2_info;
           _sxxW::P64 = P64[Sp + 8];
           P64[Hp - 80] = _sxxW::P64;
           P64[Hp - 72] = _sxxX::P64;
           P64[Hp - 64] = _sxy1::P64;
           I64[Hp - 56] = stg_sel_0_upd_info;
           _cyL1::P64 = Hp - 96;
           P64[Hp - 40] = _cyL1::P64;
           I64[Hp - 32] = sat_sxyb_info;
           P64[Hp - 16] = _sxxW::P64;
           P64[Hp - 8] = _sxy0::P64;
           P64[Hp] = _cyL1::P64;
           R2 = Hp - 56;
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyKV_info" {
     block_cyKV_info:
         const _cyKV;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.68816513 UTC

[section ""data" . GHC.List.strictUncurryScanr_closure" {
     GHC.List.strictUncurryScanr_closure:
         const GHC.List.strictUncurryScanr_info;
 },
 GHC.List.strictUncurryScanr_entry() //  [R2, R3]
         { []
         }
     {offset
       cyMl: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyMm; else goto cyMn;
       cyMm: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.strictUncurryScanr_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyMn: // global
           I64[Sp - 16] = block_cyMi_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyMr; else goto cyMj;
       uyMr: // global
           call _cyMi(R1) args: 0, res: 0, upd: 0;
       cyMj: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.strictUncurryScanr_info" {
     GHC.List.strictUncurryScanr_info:
         const GHC.List.strictUncurryScanr_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cyMi() //  [R1]
         { []
         }
     {offset
       cyMi: // global
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyMi_info" {
     block_cyMi_info:
         const _cyMi;
         const 1;
         const 30;
 },
 section ""data" . GHC.List.scanr_closure" {
     GHC.List.scanr_closure:
         const GHC.List.scanr_info;
 },
 GHC.List.scanr_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cyMz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cyMA; else goto cyMB;
       cyMA: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanr_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyMB: // global
           I64[Sp - 8] = block_cyMw_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wscanr_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.scanr_info" {
     GHC.List.scanr_info:
         const GHC.List.scanr_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cyMw() //  [R1, R2]
         { []
         }
     {offset
       cyMw: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyME; else goto cyMD;
       cyME: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cyMD: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyMw_info" {
     block_cyMw_info:
         const _cyMw;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.697773916 UTC

[section ""data" . GHC.List.flipSeqScanl'_closure" {
     GHC.List.flipSeqScanl'_closure:
         const GHC.List.flipSeqScanl'_info;
 },
 GHC.List.flipSeqScanl'_entry() //  [R2, R3]
         { []
         }
     {offset
       cyN6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyN7; else goto cyN8;
       cyN7: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.flipSeqScanl'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyN8: // global
           I64[Sp - 16] = block_cyN4_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.flipSeqScanl'_info" {
     GHC.List.flipSeqScanl'_info:
         const GHC.List.flipSeqScanl'_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cyN4() //  []
         { []
         }
     {offset
       cyN4: // global
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyN4_info" {
     block_cyN4_info:
         const _cyN4;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.703857694 UTC

[section ""data" . GHC.List.scanlFB'_closure" {
     GHC.List.scanlFB'_closure:
         const GHC.List.scanlFB'_info;
 },
 GHC.List.scanlFB'_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cyNq: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyNr; else goto cyNs;
       cyNr: // global
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanlFB'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyNs: // global
           I64[Sp - 24] = block_cyNn_info;
           _sxyv::P64 = R3;
           R3 = R4;
           _sxyu::P64 = R2;
           R2 = R6;
           R1 = _sxyu::P64;
           P64[Sp - 16] = _sxyv::P64;
           P64[Sp - 8] = R5;
           Sp = Sp - 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.scanlFB'_info" {
     GHC.List.scanlFB'_info:
         const GHC.List.scanlFB'_entry;
         const 0;
         const 14;
         const 21474836505;
 },
 _cyNn() //  [R1]
         { []
         }
     {offset
       cyNn: // global
           Hp = Hp + 32;
           if (Hp > HpLim) (likely: False) goto cyNv; else goto cyNu;
       cyNv: // global
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyNu: // global
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R3 = Hp - 24;
           R2 = R1;
           R1 = P64[Sp + 8];
           Sp = Sp + 24;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyNn_info" {
     block_cyNn_info:
         const _cyNn;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.711523834 UTC

[section ""data" . GHC.List.$wscanlGo'_closure" {
     GHC.List.$wscanlGo'_closure:
         const GHC.List.$wscanlGo'_info;
 },
 sat_sxyM_entry() //  [R1]
         { []
         }
     {offset
       cyNY: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cyNZ; else goto cyO0;
       cyNZ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyO0: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cyNR_info;
           _sxyB::P64 = P64[R1 + 16];
           _sxyE::P64 = P64[R1 + 32];
           R1 = P64[R1 + 24];
           P64[Sp - 32] = _sxyB::P64;
           P64[Sp - 24] = _sxyE::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uyOg; else goto cyNS;
       uyOg: // global
           call _cyNR(R1) args: 0, res: 0, upd: 0;
       cyNS: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxyM_info" {
     sat_sxyM_info:
         const sat_sxyM_entry;
         const 3;
         const 15;
 },
 _cyNR() //  [R1]
         { []
         }
     {offset
       cyNR: // global
           if (R1 & 7 == 1) goto cyNV; else goto cyNW;
       cyNV: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cyNW: // global
           I64[Sp] = block_cyO6_info;
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 16];
           _sxyH::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp + 16] = _sxyH::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cyNR_info" {
     block_cyNR_info:
         const _cyNR;
         const 2;
         const 30;
 },
 _cyO6() //  [R1]
         { []
         }
     {offset
       cyO6: // global
           _sxyH::P64 = P64[Sp + 16];
           I64[Sp + 16] = block_cyO8_info;
           R4 = _sxyH::P64;
           R3 = R1;
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.$wscanlGo'_entry(R4,
                                          R3,
                                          R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cyO6_info" {
     block_cyO6_info:
         const _cyO6;
         const 2;
         const 30;
 },
 _cyO8() //  [R1, R2]
         { []
         }
     {offset
       cyO8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyOf; else goto cyOe;
       cyOf: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cyOe: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cyO8_info" {
     block_cyO8_info:
         const _cyO8;
         const 0;
         const 30;
 },
 GHC.List.$wscanlGo'_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cyOh: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyOi; else goto cyOj;
       cyOi: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wscanlGo'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyOj: // global
           I64[Sp - 24] = block_cyNL_info;
           R1 = R3;
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R4;
           Sp = Sp - 24;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.$wscanlGo'_info" {
     GHC.List.$wscanlGo'_info:
         const GHC.List.$wscanlGo'_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cyNL() //  [R1]
         { []
         }
     {offset
       cyNL: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cyOm; else goto cyOl;
       cyOm: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyOl: // global
           I64[Hp - 32] = sat_sxyM_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = R1;
           R2 = Hp - 32;
           R1 = R1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyNL_info" {
     block_cyNL_info:
         const _cyNL;
         const 2;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.72403823 UTC

[section ""data" . GHC.List.scanl'_scanlGo'_closure" {
     GHC.List.scanl'_scanlGo'_closure:
         const GHC.List.scanl'_scanlGo'_info;
 },
 GHC.List.scanl'_scanlGo'_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cyP5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cyP6; else goto cyP7;
       cyP6: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanl'_scanlGo'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyP7: // global
           I64[Sp - 8] = block_cyP2_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wscanlGo'_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.scanl'_scanlGo'_info" {
     GHC.List.scanl'_scanlGo'_info:
         const GHC.List.scanl'_scanlGo'_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cyP2() //  [R1, R2]
         { []
         }
     {offset
       cyP2: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyPa; else goto cyP9;
       cyPa: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cyP9: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyP2_info" {
     block_cyP2_info:
         const _cyP2;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.729465916 UTC

[section ""data" . GHC.List.scanl'_closure" {
     GHC.List.scanl'_closure:
         const GHC.List.scanl'_info;
 },
 GHC.List.scanl'_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cyPq: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.List.scanl'_scanlGo'_entry(R4,
                                               R3,
                                               R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.scanl'_info" {
     GHC.List.scanl'_info:
         const GHC.List.scanl'_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.733461691 UTC

[section ""data" . GHC.List.constScanl_closure" {
     GHC.List.constScanl_closure:
         const GHC.List.constScanl_info;
 },
 GHC.List.constScanl_entry() //  [R2, R3]
         { []
         }
     {offset
       cyPB: // global
           R3 = R3;
           R2 = R2;
           call GHC.Base.const_entry(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.constScanl_info" {
     GHC.List.constScanl_info:
         const GHC.List.constScanl_entry;
         const 0;
         const 14;
         const 8589934607;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.737230338 UTC

[section ""data" . GHC.List.scanlFB_closure" {
     GHC.List.scanlFB_closure:
         const GHC.List.scanlFB_info;
 },
 GHC.List.scanlFB_entry() //  [R2, R3, R4, R5, R6]
         { []
         }
     {offset
       cyPO: // global
           Hp = Hp + 72;
           if (Hp > HpLim) (likely: False) goto cyPS; else goto cyPR;
       cyPS: // global
           HpAlloc = 72;
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanlFB_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyPR: // global
           I64[Hp - 64] = stg_ap_3_upd_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R6;
           P64[Hp - 32] = R4;
           I64[Hp - 24] = stg_ap_2_upd_info;
           P64[Hp - 8] = R5;
           _cyPM::P64 = Hp - 64;
           P64[Hp] = _cyPM::P64;
           _sxyU::P64 = R3;
           R3 = Hp - 24;
           R2 = _cyPM::P64;
           R1 = _sxyU::P64;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.scanlFB_info" {
     GHC.List.scanlFB_info:
         const GHC.List.scanlFB_entry;
         const 0;
         const 14;
         const 21474836505;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.742874944 UTC

[section ""data" . GHC.List.$wscanlGo_closure" {
     GHC.List.$wscanlGo_closure:
         const GHC.List.$wscanlGo_info;
 },
 sat_sxza_entry() //  [R1]
         { []
         }
     {offset
       cyQe: // global
           if ((Sp + -40) < SpLim) (likely: False) goto cyQf; else goto cyQg;
       cyQf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyQg: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 40] = block_cyQ7_info;
           _sxz0::P64 = P64[R1 + 16];
           _sxz1::P64 = P64[R1 + 24];
           R1 = P64[R1 + 32];
           P64[Sp - 32] = _sxz0::P64;
           P64[Sp - 24] = _sxz1::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto uyQw; else goto cyQ8;
       uyQw: // global
           call _cyQ7(R1) args: 0, res: 0, upd: 0;
       cyQ8: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxza_info" {
     sat_sxza_info:
         const sat_sxza_entry;
         const 3;
         const 15;
 },
 _cyQ7() //  [R1]
         { []
         }
     {offset
       cyQ7: // global
           if (R1 & 7 == 1) goto cyQb; else goto cyQc;
       cyQb: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
       cyQc: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cyQs; else goto cyQr;
       cyQs: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 24;
       cyQr: // global
           _sxz4::P64 = P64[R1 + 6];
           _sxz5::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           _sxz0::P64 = P64[Sp + 8];
           P64[Hp - 16] = _sxz0::P64;
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = _sxz4::P64;
           I64[Sp + 16] = block_cyQn_info;
           R4 = _sxz5::P64;
           R3 = Hp - 32;
           R2 = _sxz0::P64;
           Sp = Sp + 16;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cyQ7_info" {
     block_cyQ7_info:
         const _cyQ7;
         const 2;
         const 30;
 },
 _cyQn() //  [R1, R2]
         { []
         }
     {offset
       cyQn: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyQv; else goto cyQu;
       cyQv: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 24;
       cyQu: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cyQn_info" {
     block_cyQn_info:
         const _cyQn;
         const 0;
         const 30;
 },
 GHC.List.$wscanlGo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cyQx: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cyQB; else goto cyQA;
       cyQB: // global
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wscanlGo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyQA: // global
           I64[Hp - 32] = sat_sxza_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R2 = Hp - 32;
           R1 = R3;
           call (I64[P64[Sp]])(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.$wscanlGo_info" {
     GHC.List.$wscanlGo_info:
         const GHC.List.$wscanlGo_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.752520499 UTC

[section ""data" . GHC.List.scanl_scanlGo_closure" {
     GHC.List.scanl_scanlGo_closure:
         const GHC.List.scanl_scanlGo_info;
 },
 GHC.List.scanl_scanlGo_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cyRb: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cyRc; else goto cyRd;
       cyRc: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanl_scanlGo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyRd: // global
           I64[Sp - 8] = block_cyR8_info;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.scanl_scanlGo_info" {
     GHC.List.scanl_scanlGo_info:
         const GHC.List.scanl_scanlGo_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cyR8() //  [R1, R2]
         { []
         }
     {offset
       cyR8: // global
           Hp = Hp + 24;
           if (Hp > HpLim) (likely: False) goto cyRg; else goto cyRf;
       cyRg: // global
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) args: 8, res: 8, upd: 8;
       cyRf: // global
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyR8_info" {
     block_cyR8_info:
         const _cyR8;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.758940395 UTC

[section ""data" . GHC.List.scanl_closure" {
     GHC.List.scanl_closure:
         const GHC.List.scanl_info;
 },
 GHC.List.scanl_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cyRw: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call GHC.List.scanl_scanlGo_entry(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.scanl_info" {
     GHC.List.scanl_info:
         const GHC.List.scanl_entry;
         const 0;
         const 14;
         const 12884901911;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.764337372 UTC

[section ""data" . GHC.List.scanl1_closure" {
     GHC.List.scanl1_closure:
         const GHC.List.scanl1_info;
 },
 sat_sxzp_entry() //  [R1]
         { []
         }
     {offset
       cyRT: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cyRU; else goto cyRV;
       cyRU: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyRV: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 24] = block_cyRR_info;
           R4 = P64[R1 + 32];
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 24;
           call GHC.List.$wscanlGo_entry(R4, R3, R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxzp_info" {
     sat_sxzp_info:
         const sat_sxzp_entry;
         const 3;
         const 15;
 },
 _cyRR() //  [R2]
         { []
         }
     {offset
       cyRR: // global
           R1 = R2 & (-8);
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cyRR_info" {
     block_cyRR_info:
         const _cyRR;
         const 0;
         const 30;
 },
 GHC.List.scanl1_entry() //  [R2, R3]
         { []
         }
     {offset
       cyS1: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyS2; else goto cyS3;
       cyS2: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.scanl1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyS3: // global
           I64[Sp - 16] = block_cyRH_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uySa; else goto cyRI;
       uySa: // global
           call _cyRH(R1) args: 0, res: 0, upd: 0;
       cyRI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.scanl1_info" {
     GHC.List.scanl1_info:
         const GHC.List.scanl1_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cyRH() //  [R1]
         { []
         }
     {offset
       cyRH: // global
           if (R1 & 7 == 1) goto cyRY; else goto cyRZ;
       cyRY: // global
           R1 = []_closure+1;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyRZ: // global
           Hp = Hp + 64;
           if (Hp > HpLim) (likely: False) goto cyS9; else goto cyS8;
       cyS9: // global
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyS8: // global
           _sxzk::P64 = P64[R1 + 6];
           _sxzl::P64 = P64[R1 + 14];
           I64[Hp - 56] = sat_sxzp_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sxzk::P64;
           P64[Hp - 24] = _sxzl::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sxzk::P64;
           P64[Hp] = Hp - 56;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyRH_info" {
     block_cyRH_info:
         const _cyRH;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.774297054 UTC

[section ""data" . GHC.List.foldl'_closure" {
     GHC.List.foldl'_closure:
         const GHC.List.foldl'_info;
 },
 GHC.List.foldl'_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cySL: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cySM; else goto cySN;
       cySM: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl'_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cySN: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cySP() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.foldl'_info" {
     GHC.List.foldl'_info:
         const GHC.List.foldl'_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cySP() //  []
         { []
         }
     {offset
       cySP: // global
           I64[Sp - 8] = block_cySR_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyTe; else goto cyST;
       uyTe: // global
           call _cySR(R1) args: 0, res: 0, upd: 0;
       cyST: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cySR() //  [R1]
         { []
         }
     {offset
       cySR: // global
           _sxzv::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cySZ; else goto cyT6;
       cySZ: // global
           R1 = _sxzv::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cyT6: // global
           I64[Sp] = block_cyT2_info;
           _sxzx::P64 = P64[R1 + 6];
           _sxzy::P64 = P64[R1 + 14];
           R1 = _sxzv::P64;
           P64[Sp + 16] = _sxzy::P64;
           P64[Sp + 24] = _sxzx::P64;
           call stg_ap_0_fast(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cySR_info" {
     block_cySR_info:
         const _cySR;
         const 131;
         const 30;
 },
 _cyT2() //  [R1]
         { []
         }
     {offset
       cyT2: // global
           I64[Sp] = block_cyT4_info;
           R3 = P64[Sp + 24];
           R2 = R1;
           R1 = P64[Sp + 8];
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cyT2_info" {
     block_cyT2_info:
         const _cyT2;
         const 3;
         const 30;
 },
 _cyT4() //  [R1]
         { []
         }
     {offset
       cyT4: // global
           P64[Sp + 16] = P64[Sp + 16];
           P64[Sp + 24] = R1;
           Sp = Sp + 8;
           call _cySP() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cyT4_info" {
     block_cyT4_info:
         const _cyT4;
         const 259;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.784910303 UTC

[section ""data" . GHC.List.foldl1'_closure" {
     GHC.List.foldl1'_closure:
         const GHC.List.foldl1'_info;
         const 0;
 },
 GHC.List.foldl1'_entry() //  [R2, R3]
         { []
         }
     {offset
       cyTO: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyTP; else goto cyTQ;
       cyTP: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl1'_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyTQ: // global
           I64[Sp - 16] = block_cyTH_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyTX; else goto cyTI;
       uyTX: // global
           call _cyTH(R1) args: 0, res: 0, upd: 0;
       cyTI: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.foldl1'_info" {
     GHC.List.foldl1'_info:
         const GHC.List.foldl1'_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const SxGK_srt+392;
 },
 _cyTH() //  [R1]
         { []
         }
     {offset
       cyTH: // global
           if (R1 & 7 == 1) goto cyTL; else goto cyTM;
       cyTL: // global
           R1 = GHC.List.foldl1'1_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cyTM: // global
           R4 = P64[R1 + 14];
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.foldl'_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyTH_info" {
     block_cyTH_info:
         const _cyTH;
         const 1;
         const 4294967326;
         const SxGK_srt+400;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.790156725 UTC

[section ""data" . sat_sxzG_closure" {
     sat_sxzG_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.791836453 UTC

[section ""data" . sat_sxzH_closure" {
     sat_sxzH_closure:
         const :_con_info;
         const sat_sxzG_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.794304984 UTC

[section ""data" . lvl29_ru9q_closure" {
     lvl29_ru9q_closure:
         const lvl29_ru9q_info;
         const 0;
         const 0;
         const 0;
 },
 lvl29_ru9q_entry() //  [R1]
         { []
         }
     {offset
       cyUi: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyUj; else goto cyUk;
       cyUj: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyUk: // global
           (_cyUf::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cyUf::I64 == 0) goto cyUh; else goto cyUg;
       cyUh: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cyUg: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cyUf::I64;
           R3 = sat_sxzH_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl29_ru9q_info" {
     lvl29_ru9q_info:
         const lvl29_ru9q_entry;
         const 0;
         const 4294967317;
         const SxGK_srt+408;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.799334602 UTC

[section ""data" . lvl30_ru9r_closure" {
     lvl30_ru9r_closure:
         const lvl30_ru9r_info;
         const 0;
         const 0;
         const 0;
 },
 lvl30_ru9r_entry() //  [R1]
         { []
         }
     {offset
       cyUA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyUB; else goto cyUC;
       cyUB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyUC: // global
           (_cyUx::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cyUx::I64 == 0) goto cyUz; else goto cyUy;
       cyUz: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cyUy: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cyUx::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl30_ru9r_info" {
     lvl30_ru9r_info:
         const lvl30_ru9r_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.804329818 UTC

[section ""data" . GHC.List.foldl_closure" {
     GHC.List.foldl_closure:
         const GHC.List.foldl_info;
 },
 GHC.List.foldl_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cyV3: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cyV4; else goto cyV5;
       cyV4: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyV5: // global
           P64[Sp - 24] = R2;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 24;
           call _cyUU() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.foldl_info" {
     GHC.List.foldl_info:
         const GHC.List.foldl_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cyUU() //  []
         { []
         }
     {offset
       cyUU: // global
           I64[Sp - 8] = block_cyUW_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyVi; else goto cyUX;
       uyVi: // global
           call _cyUW(R1) args: 0, res: 0, upd: 0;
       cyUX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyUW() //  [R1]
         { []
         }
     {offset
       cyUW: // global
           _sxzN::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cyVa; else goto cyVb;
       cyVa: // global
           R1 = _sxzN::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cyVb: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cyVe; else goto cyVd;
       cyVe: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyVd: // global
           _sxzP::P64 = P64[R1 + 6];
           _sxzQ::P64 = P64[R1 + 14];
           I64[Hp - 32] = stg_ap_3_upd_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = _sxzN::P64;
           P64[Hp] = _sxzP::P64;
           P64[Sp + 16] = _sxzQ::P64;
           P64[Sp + 24] = Hp - 32;
           Sp = Sp + 8;
           call _cyUU() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cyUW_info" {
     block_cyUW_info:
         const _cyUW;
         const 131;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.81182895 UTC

[section ""data" . GHC.List.sum_closure" {
     GHC.List.sum_closure:
         const GHC.List.sum_info;
         const 0;
 },
 sat_sxzU_entry() //  [R1]
         { []
         }
     {offset
       cyVK: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cyVL; else goto cyVM;
       cyVL: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyVM: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl30_ru9r_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxzU_info" {
     sat_sxzU_info:
         const sat_sxzU_entry;
         const 1;
         const 4294967312;
         const SxGK_srt+416;
 },
 sat_sxzT_entry() //  [R1]
         { []
         }
     {offset
       cyVR: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyVS; else goto cyVT;
       cyVS: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyVT: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.+_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxzT_info" {
     sat_sxzT_info:
         const sat_sxzT_entry;
         const 1;
         const 16;
 },
 GHC.List.sum_entry() //  [R2]
         { []
         }
     {offset
       cyVU: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cyVY; else goto cyVX;
       cyVY: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.List.sum_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cyVX: // global
           I64[Hp - 40] = sat_sxzU_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sxzT_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = GHC.List.foldl_closure+3;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.sum_info" {
     GHC.List.sum_info:
         const GHC.List.sum_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const SxGK_srt+416;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.82060294 UTC

[section ""data" . GHC.List.product_closure" {
     GHC.List.product_closure:
         const GHC.List.product_info;
         const 0;
 },
 sat_sxzX_entry() //  [R1]
         { []
         }
     {offset
       cyWp: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cyWq; else goto cyWr;
       cyWq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyWr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = lvl29_ru9q_closure;
           Sp = Sp - 32;
           call GHC.Num.fromInteger_entry(R2) args: 40, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxzX_info" {
     sat_sxzX_info:
         const sat_sxzX_entry;
         const 1;
         const 4294967312;
         const SxGK_srt+432;
 },
 sat_sxzW_entry() //  [R1]
         { []
         }
     {offset
       cyWw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyWx; else goto cyWy;
       cyWx: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyWy: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Num.*_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxzW_info" {
     sat_sxzW_info:
         const sat_sxzW_entry;
         const 1;
         const 16;
 },
 GHC.List.product_entry() //  [R2]
         { []
         }
     {offset
       cyWz: // global
           Hp = Hp + 48;
           if (Hp > HpLim) (likely: False) goto cyWD; else goto cyWC;
       cyWD: // global
           HpAlloc = 48;
           R2 = R2;
           R1 = GHC.List.product_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cyWC: // global
           I64[Hp - 40] = sat_sxzX_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = sat_sxzW_info;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 16;
           R1 = GHC.List.foldl_closure+3;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.product_info" {
     GHC.List.product_info:
         const GHC.List.product_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const SxGK_srt+432;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.829015713 UTC

[section ""data" . GHC.List.foldl1_closure" {
     GHC.List.foldl1_closure:
         const GHC.List.foldl1_info;
         const 0;
 },
 GHC.List.foldl1_entry() //  [R2, R3]
         { []
         }
     {offset
       cyX7: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyX8; else goto cyX9;
       cyX8: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.foldl1_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cyX9: // global
           I64[Sp - 16] = block_cyX0_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyXg; else goto cyX1;
       uyXg: // global
           call _cyX0(R1) args: 0, res: 0, upd: 0;
       cyX1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.foldl1_info" {
     GHC.List.foldl1_info:
         const GHC.List.foldl1_entry;
         const 0;
         const 12884901902;
         const 8589934607;
         const SxGK_srt+448;
 },
 _cyX0() //  [R1]
         { []
         }
     {offset
       cyX0: // global
           if (R1 & 7 == 1) goto cyX4; else goto cyX5;
       cyX4: // global
           R1 = GHC.List.foldl2_closure;
           Sp = Sp + 16;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cyX5: // global
           R4 = P64[R1 + 14];
           R3 = P64[R1 + 6];
           R2 = P64[Sp + 8];
           Sp = Sp + 16;
           call GHC.List.foldl_entry(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyX0_info" {
     block_cyX0_info:
         const _cyX0;
         const 1;
         const 4294967326;
         const SxGK_srt+456;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.835026826 UTC

[section ""data" . GHC.List.filterFB_closure" {
     GHC.List.filterFB_closure:
         const GHC.List.filterFB_info;
 },
 GHC.List.filterFB_entry() //  [R2, R3, R4, R5]
         { []
         }
     {offset
       cyXD: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cyXE; else goto cyXF;
       cyXE: // global
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.filterFB_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyXF: // global
           I64[Sp - 32] = block_cyXx_info;
           _sxA3::P64 = R2;
           R2 = R4;
           R1 = R3;
           P64[Sp - 24] = _sxA3::P64;
           P64[Sp - 16] = R4;
           P64[Sp - 8] = R5;
           Sp = Sp - 32;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.filterFB_info" {
     GHC.List.filterFB_info:
         const GHC.List.filterFB_entry;
         const 0;
         const 14;
         const 17179869208;
 },
 _cyXx() //  [R1]
         { []
         }
     {offset
       cyXx: // global
           _sxA6::P64 = P64[Sp + 24];
           if (R1 & 7 == 1) goto cyXA; else goto cyXB;
       cyXA: // global
           R1 = _sxA6::P64;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cyXB: // global
           R3 = _sxA6::P64;
           R2 = P64[Sp + 16];
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call stg_ap_pp_fast(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyXx_info" {
     block_cyXx_info:
         const _cyXx;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.842169792 UTC

[section ""data" . GHC.List.filter_closure" {
     GHC.List.filter_closure:
         const GHC.List.filter_info;
 },
 sat_sxAe_entry() //  [R1]
         { []
         }
     {offset
       cyYg: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyYh; else goto cyYi;
       cyYh: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cyYi: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = P64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.List.filter_entry(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_sxAe_info" {
     sat_sxAe_info:
         const sat_sxAe_entry;
         const 2;
         const 18;
 },
 GHC.List.filter_entry() //  [R2, R3]
         { []
         }
     {offset
       cyYn: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cyYo; else goto uyYD;
       cyYo: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.filter_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uyYD: // global
           P64[Sp - 16] = R2;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cyXY() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.filter_info" {
     GHC.List.filter_info:
         const GHC.List.filter_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cyXY() //  []
         { []
         }
     {offset
       cyXY: // global
           I64[Sp - 8] = block_cyY1_info;
           R1 = P64[Sp + 8];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uyYF; else goto cyY2;
       uyYF: // global
           call _cyY1(R1) args: 0, res: 0, upd: 0;
       cyY2: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyY1() //  [R1]
         { []
         }
     {offset
       cyY1: // global
           if (R1 & 7 == 1) goto cyYk; else goto cyYl;
       cyYk: // global
           R1 = []_closure+1;
           Sp = Sp + 24;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cyYl: // global
           I64[Sp - 8] = block_cyY7_info;
           _sxAb::P64 = P64[R1 + 6];
           R2 = _sxAb::P64;
           _sxAc::P64 = P64[R1 + 14];
           R1 = P64[Sp + 8];
           P64[Sp] = _sxAc::P64;
           P64[Sp + 16] = _sxAb::P64;
           Sp = Sp - 8;
           call stg_ap_p_fast(R2, R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cyY1_info" {
     block_cyY1_info:
         const _cyY1;
         const 130;
         const 30;
 },
 _cyY7() //  [R1]
         { []
         }
     {offset
       cyY7: // global
           _sxA8::P64 = P64[Sp + 16];
           _sxAc::P64 = P64[Sp + 8];
           if (R1 & 7 == 1) goto cyYw; else goto cyYy;
       cyYw: // global
           P64[Sp + 16] = _sxA8::P64;
           P64[Sp + 24] = _sxAc::P64;
           Sp = Sp + 16;
           call _cyXY() args: 0, res: 0, upd: 0;
       cyYy: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cyYB; else goto cyYA;
       cyYB: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyYA: // global
           I64[Hp - 48] = sat_sxAe_info;
           P64[Hp - 32] = _sxA8::P64;
           P64[Hp - 24] = _sxAc::P64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 24];
           P64[Hp] = Hp - 48;
           R1 = Hp - 14;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyY7_info" {
     block_cyY7_info:
         const _cyY7;
         const 3;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.851733867 UTC

[section ""data" . GHC.List.idLength_closure" {
     GHC.List.idLength_closure:
         const GHC.List.idLength_info;
 },
 GHC.List.idLength_entry() //  [R2]
         { []
         }
     {offset
       cyZi: // global
           R2 = R2;
           call GHC.Base.id_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.idLength_info" {
     GHC.List.idLength_info:
         const GHC.List.idLength_entry;
         const 0;
         const 14;
         const 4294967301;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.855691765 UTC

[section ""data" . GHC.List.lengthFB_closure" {
     GHC.List.lengthFB_closure:
         const GHC.List.lengthFB_info;
 },
 GHC.List.lengthFB_entry() //  [R2, R3, R4]
         { []
         }
     {offset
       cyZw: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cyZD; else goto cyZE;
       cyZD: // global
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.lengthFB_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cyZE: // global
           I64[Sp - 16] = block_cyZt_info;
           R1 = R4;
           P64[Sp - 8] = R3;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uyZI; else goto cyZu;
       uyZI: // global
           call _cyZt(R1) args: 0, res: 0, upd: 0;
       cyZu: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.lengthFB_info" {
     GHC.List.lengthFB_info:
         const GHC.List.lengthFB_entry;
         const 0;
         const 14;
         const 12884901911;
 },
 _cyZt() //  [R1]
         { []
         }
     {offset
       cyZt: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cyZH; else goto cyZG;
       cyZH: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cyZG: // global
           _sxAk::I64 = I64[R1 + 7] + 1;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sxAk::I64;
           R2 = Hp - 7;
           R1 = P64[Sp + 8];
           Sp = Sp + 16;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cyZt_info" {
     block_cyZt_info:
         const _cyZt;
         const 1;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.863472799 UTC

[section ""data" . GHC.List.$wlenAcc_closure" {
     GHC.List.$wlenAcc_closure:
         const GHC.List.$wlenAcc_info;
 },
 GHC.List.$wlenAcc_entry() //  [R2, R3]
         { []
         }
     {offset
       cz06: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cz07; else goto uz0g;
       cz07: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.$wlenAcc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       uz0g: // global
           P64[Sp - 16] = R2;
           I64[Sp - 8] = R3;
           Sp = Sp - 16;
           call _cyZW() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . GHC.List.$wlenAcc_info" {
     GHC.List.$wlenAcc_info:
         const GHC.List.$wlenAcc_entry;
         const 0;
         const 14;
         const 8589934606;
 },
 _cyZW() //  []
         { []
         }
     {offset
       cyZW: // global
           _sxAm::P64 = P64[Sp];
           I64[Sp] = block_cyZZ_info;
           R1 = _sxAm::P64;
           if (R1 & 7 != 0) goto uz0i; else goto cz00;
       uz0i: // global
           call _cyZZ(R1) args: 0, res: 0, upd: 0;
       cz00: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 _cyZZ() //  [R1]
         { []
         }
     {offset
       cyZZ: // global
           _sxAn::I64 = I64[Sp + 8];
           if (R1 & 7 == 1) goto cz03; else goto cz04;
       cz03: // global
           R1 = _sxAn::I64;
           Sp = Sp + 16;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cz04: // global
           P64[Sp] = P64[R1 + 14];
           I64[Sp + 8] = _sxAn::I64 + 1;
           call _cyZW() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cyZZ_info" {
     block_cyZZ_info:
         const _cyZZ;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.870270375 UTC

[section ""data" . GHC.List.lenAcc_closure" {
     GHC.List.lenAcc_closure:
         const GHC.List.lenAcc_info;
 },
 GHC.List.lenAcc_entry() //  [R2, R3]
         { []
         }
     {offset
       cz0J: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cz0R; else goto cz0S;
       cz0R: // global
           R3 = R3;
           R2 = R2;
           R1 = GHC.List.lenAcc_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cz0S: // global
           I64[Sp - 16] = block_cz0G_info;
           R1 = R3;
           P64[Sp - 8] = R2;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto uz0X; else goto cz0H;
       uz0X: // global
           call _cz0G(R1) args: 0, res: 0, upd: 0;
       cz0H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.lenAcc_info" {
     GHC.List.lenAcc_info:
         const GHC.List.lenAcc_entry;
         const 0;
         const 14;
         const 8589934607;
 },
 _cz0G() //  [R1]
         { []
         }
     {offset
       cz0G: // global
           _sxAs::P64 = P64[Sp + 8];
           I64[Sp + 8] = block_cz0M_info;
           R3 = I64[R1 + 7];
           R2 = _sxAs::P64;
           Sp = Sp + 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cz0G_info" {
     block_cz0G_info:
         const _cz0G;
         const 1;
         const 30;
 },
 _cz0M() //  [R1]
         { []
         }
     {offset
       cz0M: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cz0W; else goto cz0V;
       cz0W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cz0V: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cz0M_info" {
     block_cz0M_info:
         const _cz0M;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.877221814 UTC

[section ""data" . GHC.List.length_closure" {
     GHC.List.length_closure:
         const GHC.List.length_info;
 },
 GHC.List.length_entry() //  [R2]
         { []
         }
     {offset
       cz1k: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cz1o; else goto cz1p;
       cz1o: // global
           R2 = R2;
           R1 = GHC.List.length_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cz1p: // global
           I64[Sp - 8] = block_cz1i_info;
           R3 = 0;
           R2 = R2;
           Sp = Sp - 8;
           call GHC.List.$wlenAcc_entry(R3, R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.length_info" {
     GHC.List.length_info:
         const GHC.List.length_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cz1i() //  [R1]
         { []
         }
     {offset
       cz1i: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cz1s; else goto cz1r;
       cz1s: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cz1r: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cz1i_info" {
     block_cz1i_info:
         const _cz1i;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.882935427 UTC

[section ""data" . GHC.List.null_closure" {
     GHC.List.null_closure:
         const GHC.List.null_info;
 },
 GHC.List.null_entry() //  [R2]
         { []
         }
     {offset
       cz1P: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cz1Q; else goto cz1R;
       cz1Q: // global
           R2 = R2;
           R1 = GHC.List.null_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cz1R: // global
           I64[Sp - 8] = block_cz1I_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uz1Y; else goto cz1J;
       uz1Y: // global
           call _cz1I(R1) args: 0, res: 0, upd: 0;
       cz1J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.null_info" {
     GHC.List.null_info:
         const GHC.List.null_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cz1I() //  [R1]
         { []
         }
     {offset
       cz1I: // global
           if (R1 & 7 == 1) goto cz1M; else goto cz1N;
       cz1M: // global
           R1 = GHC.Types.True_closure+2;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cz1N: // global
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cz1I_info" {
     block_cz1I_info:
         const _cz1I;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.888926276 UTC

[section ""data" . GHC.List.uncons_closure" {
     GHC.List.uncons_closure:
         const GHC.List.uncons_info;
 },
 GHC.List.uncons_entry() //  [R2]
         { []
         }
     {offset
       cz2q: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cz2r; else goto cz2s;
       cz2r: // global
           R2 = R2;
           R1 = GHC.List.uncons_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cz2s: // global
           I64[Sp - 8] = block_cz2j_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uz2D; else goto cz2k;
       uz2D: // global
           call _cz2j(R1) args: 0, res: 0, upd: 0;
       cz2k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.List.uncons_info" {
     GHC.List.uncons_info:
         const GHC.List.uncons_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cz2j() //  [R1]
         { []
         }
     {offset
       cz2j: // global
           if (R1 & 7 == 1) goto cz2n; else goto cz2o;
       cz2n: // global
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cz2o: // global
           Hp = Hp + 40;
           if (Hp > HpLim) (likely: False) goto cz2C; else goto cz2B;
       cz2C: // global
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cz2B: // global
           _sxAF::P64 = P64[R1 + 6];
           _sxAG::P64 = P64[R1 + 14];
           I64[Hp - 32] = (,)_con_info;
           P64[Hp - 24] = _sxAF::P64;
           P64[Hp - 16] = _sxAG::P64;
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = Hp - 31;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cz2j_info" {
     block_cz2j_info:
         const _cz2j;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:11.895096775 UTC

[section ""relreadonly" . SxGK_srt" {
     SxGK_srt:
         const lvl1_ru8R_closure;
         const GHC.Err.errorWithoutStackTrace_closure;
         const GHC.List.errorEmptyList_closure;
         const GHC.List.prel_list_str_closure;
         const lvl3_ru8T_closure;
         const GHC.List.!!2_closure;
         const GHC.List.!!1_closure;
         const poly_exit_ru8U_closure;
         const poly_$wgo_ru8V_closure;
         const GHC.List.negIndex_closure;
         const GHC.List.!!_closure;
         const GHC.List.$w!!_closure;
         const lvl5_ru8X_closure;
         const GHC.List.cycle_closure;
         const GHC.List.cycle1_closure;
         const lvl7_ru8Z_closure;
         const lvl8_ru90_closure;
         const GHC.List.foldr1_closure;
         const lvl10_ru92_closure;
         const GHC.List.init_closure;
         const GHC.List.init2_closure;
         const lvl12_ru94_closure;
         const GHC.List.lastError_closure;
         const lvl14_ru97_closure;
         const GHC.List.tail_closure;
         const GHC.List.scanl2_closure;
         const lvl16_ru99_closure;
         const GHC.List.head_closure;
         const GHC.List.badHead_closure;
         const lvl18_ru9b_closure;
         const GHC.List.maximum_$smaximum_closure;
         const GHC.List.maximum1_closure;
         const lvl21_ru9e_closure;
         const GHC.List.minimum_$sminimum_closure;
         const GHC.List.minimum1_closure;
         const GHC.List.maximum_$smaximum1_closure;
         const GHC.List.maximum2_closure;
         const GHC.List.maximum_closure;
         const lvl19_ru9c_closure;
         const GHC.List.minimum_$sminimum1_closure;
         const GHC.List.minimum2_closure;
         const GHC.List.minimum_closure;
         const lvl22_ru9f_closure;
         const lvl24_ru9h_closure;
         const GHC.List.errorEmptyList_closure;
         const lvl26_ru9j_closure;
         const Control.Exception.Base.patError_closure;
         const GHC.List.scanr1_closure;
         const lvl28_ru9p_closure;
         const GHC.List.foldl1'_closure;
         const GHC.List.foldl1'1_closure;
         const sat_sxzH_closure;
         const lvl30_ru9r_closure;
         const GHC.List.sum_closure;
         const lvl29_ru9q_closure;
         const GHC.List.product_closure;
         const GHC.List.foldl1_closure;
         const GHC.List.foldl2_closure;
 }]

