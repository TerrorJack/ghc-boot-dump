
==================== Tidy Core ====================
2018-03-16 15:55:02.386068457 UTC

Result size of Tidy Core
  = {terms: 721, types: 334, coercions: 0, joins: 0/18}

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.RealFracMethods.properFractionDoubleInt3 :: Int
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.RealFracMethods.properFractionDoubleInt3
  = GHC.Types.I# 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.RealFracMethods.properFractionFloatInt2 :: Float
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.RealFracMethods.properFractionFloatInt2
  = GHC.Types.F# 0.0#

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
GHC.Float.RealFracMethods.properFractionFloatInt1 :: (Int, Float)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.Float.RealFracMethods.properFractionFloatInt1
  = (GHC.Float.RealFracMethods.properFractionDoubleInt3,
     GHC.Float.RealFracMethods.properFractionFloatInt2)

-- RHS size: {terms: 22, types: 7, coercions: 0, joins: 0/1}
properFractionFloatInt :: Float -> (Int, Float)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dofU [Occ=Once!] :: Float) ->
                 case ds_dofU of { F# x_ao8f ->
                 case eqFloat# x_ao8f 0.0# of {
                   __DEFAULT ->
                     let {
                       n_sopr :: Int#
                       [LclId]
                       n_sopr = float2Int# x_ao8f } in
                     (GHC.Types.I# n_sopr,
                      GHC.Types.F# (minusFloat# x_ao8f (int2Float# n_sopr)));
                   1# -> GHC.Float.RealFracMethods.properFractionFloatInt1
                 }
                 }}]
properFractionFloatInt
  = \ (ds_dofU :: Float) ->
      case ds_dofU of { F# x_ao8f ->
      case eqFloat# x_ao8f 0.0# of {
        __DEFAULT ->
          let {
            n_sopr :: Int#
            [LclId]
            n_sopr = float2Int# x_ao8f } in
          (GHC.Types.I# n_sopr,
           GHC.Types.F# (minusFloat# x_ao8f (int2Float# n_sopr)));
        1# -> GHC.Float.RealFracMethods.properFractionFloatInt1
      }
      }

-- RHS size: {terms: 20, types: 5, coercions: 0, joins: 0/1}
floorFloatInt :: Float -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dofN [Occ=Once!] :: Float) ->
                 case ds_dofN of { F# x_ao8h ->
                 let {
                   n_sopp :: Int#
                   [LclId]
                   n_sopp = float2Int# x_ao8h } in
                 case ltFloat# x_ao8h (int2Float# n_sopp) of {
                   __DEFAULT -> GHC.Types.I# n_sopp;
                   1# -> GHC.Types.I# (-# n_sopp 1#)
                 }
                 }}]
floorFloatInt
  = \ (ds_dofN :: Float) ->
      case ds_dofN of { F# x_ao8h ->
      let {
        n_sopp [Dmd=<S,U>] :: Int#
        [LclId]
        n_sopp = float2Int# x_ao8h } in
      case ltFloat# x_ao8h (int2Float# n_sopp) of {
        __DEFAULT -> GHC.Types.I# n_sopp;
        1# -> GHC.Types.I# (-# n_sopp 1#)
      }
      }

-- RHS size: {terms: 20, types: 5, coercions: 0, joins: 0/1}
ceilingFloatInt :: Float -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_dofG [Occ=Once!] :: Float) ->
                 case ds_dofG of { F# x_ao8j ->
                 let {
                   n_sopn :: Int#
                   [LclId]
                   n_sopn = float2Int# x_ao8j } in
                 case ltFloat# (int2Float# n_sopn) x_ao8j of {
                   __DEFAULT -> GHC.Types.I# n_sopn;
                   1# -> GHC.Types.I# (+# n_sopn 1#)
                 }
                 }}]
ceilingFloatInt
  = \ (ds_dofG :: Float) ->
      case ds_dofG of { F# x_ao8j ->
      let {
        n_sopn [Dmd=<S,U>] :: Int#
        [LclId]
        n_sopn = float2Int# x_ao8j } in
      case ltFloat# (int2Float# n_sopn) x_ao8j of {
        __DEFAULT -> GHC.Types.I# n_sopn;
        1# -> GHC.Types.I# (+# n_sopn 1#)
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl_roLO :: Integer
[GblId, Unf=OtherCon []]
lvl_roLO = 0

-- RHS size: {terms: 78, types: 26, coercions: 0, joins: 0/3}
properFractionFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: Float -> (Integer, Float)
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (v_ao8m [Occ=Once!] :: Float) ->
                 case v_ao8m of wild_Xx { F# x_ao8n [Occ=Once] ->
                 case decodeFloat_Int# x_ao8n of { (# ipv_sohW, ipv1_sohX #) ->
                 case <# ipv1_sohX 0# of {
                   __DEFAULT ->
                     (shiftLInteger (smallInteger ipv_sohW) ipv1_sohX,
                      GHC.Types.F# 0.0#);
                   1# ->
                     let {
                       s_ao8q :: Int#
                       [LclId]
                       s_ao8q = negateInt# ipv1_sohX } in
                     case ># s_ao8q 23# of {
                       __DEFAULT ->
                         case <# ipv_sohW 0# of {
                           __DEFAULT ->
                             let {
                               k_ao8t :: Int#
                               [LclId]
                               k_ao8t = uncheckedIShiftRL# ipv_sohW s_ao8q } in
                             (smallInteger k_ao8t,
                              case encodeFloatInteger
                                     (smallInteger (-# ipv_sohW (uncheckedIShiftL# k_ao8t s_ao8q)))
                                     ipv1_sohX
                              of wild1_Xd
                              { __DEFAULT ->
                              GHC.Types.F# wild1_Xd
                              });
                           1# ->
                             let {
                               k_ao8r :: Int#
                               [LclId]
                               k_ao8r
                                 = negateInt# (uncheckedIShiftRA# (negateInt# ipv_sohW) s_ao8q) } in
                             (smallInteger k_ao8r,
                              case encodeFloatInteger
                                     (smallInteger (-# ipv_sohW (uncheckedIShiftL# k_ao8r s_ao8q)))
                                     ipv1_sohX
                              of wild1_Xd
                              { __DEFAULT ->
                              GHC.Types.F# wild1_Xd
                              })
                         };
                       1# -> (0, wild_Xx)
                     }
                 }
                 }
                 }}]
properFractionFloatInteger
  = \ (v_ao8m :: Float) ->
      case v_ao8m of wild_Xx { F# x_ao8n ->
      case decodeFloat_Int# x_ao8n of { (# ipv_sohJ, ipv1_sohK #) ->
      case <# ipv1_sohK 0# of {
        __DEFAULT ->
          (shiftLInteger (smallInteger ipv_sohJ) ipv1_sohK,
           GHC.Float.RealFracMethods.properFractionFloatInt2);
        1# ->
          let {
            s_sopj [Dmd=<S,U>] :: Int#
            [LclId]
            s_sopj = negateInt# ipv1_sohK } in
          case ># s_sopj 23# of {
            __DEFAULT ->
              case <# ipv_sohJ 0# of {
                __DEFAULT ->
                  let {
                    k_sopi :: Int#
                    [LclId]
                    k_sopi = uncheckedIShiftRL# ipv_sohJ s_sopj } in
                  (smallInteger k_sopi,
                   case encodeFloatInteger
                          (smallInteger (-# ipv_sohJ (uncheckedIShiftL# k_sopi s_sopj)))
                          ipv1_sohK
                   of wild1_Xh
                   { __DEFAULT ->
                   GHC.Types.F# wild1_Xh
                   });
                1# ->
                  let {
                    k_sopl :: Int#
                    [LclId]
                    k_sopl
                      = negateInt# (uncheckedIShiftRA# (negateInt# ipv_sohJ) s_sopj) } in
                  (smallInteger k_sopl,
                   case encodeFloatInteger
                          (smallInteger (-# ipv_sohJ (uncheckedIShiftL# k_sopl s_sopj)))
                          ipv1_sohK
                   of wild1_Xh
                   { __DEFAULT ->
                   GHC.Types.F# wild1_Xh
                   })
              };
            1# -> (lvl_roLO, wild_Xx)
          }
      }
      }
      }

-- RHS size: {terms: 44, types: 14, coercions: 0, joins: 0/1}
truncateFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: Float -> Integer
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_ao8v [Occ=Once!] :: Float) ->
                 case x_ao8v of { F# x1_ao8n [Occ=Once] ->
                 case decodeFloat_Int# x1_ao8n of { (# ipv_sohW, ipv1_sohX #) ->
                 case <# ipv1_sohX 0# of {
                   __DEFAULT -> shiftLInteger (smallInteger ipv_sohW) ipv1_sohX;
                   1# ->
                     let {
                       s_ao8q :: Int#
                       [LclId]
                       s_ao8q = negateInt# ipv1_sohX } in
                     case ># s_ao8q 23# of {
                       __DEFAULT ->
                         case <# ipv_sohW 0# of {
                           __DEFAULT -> smallInteger (uncheckedIShiftRL# ipv_sohW s_ao8q);
                           1# ->
                             smallInteger
                               (negateInt# (uncheckedIShiftRA# (negateInt# ipv_sohW) s_ao8q))
                         };
                       1# -> 0
                     }
                 }
                 }
                 }}]
truncateFloatInteger
  = \ (x_ao8v :: Float) ->
      case x_ao8v of { F# x1_ao8n ->
      case decodeFloat_Int# x1_ao8n of { (# ipv_sohW, ipv1_sohX #) ->
      case <# ipv1_sohX 0# of {
        __DEFAULT -> shiftLInteger (smallInteger ipv_sohW) ipv1_sohX;
        1# ->
          let {
            s_ao8q [Dmd=<S,U>] :: Int#
            [LclId]
            s_ao8q = negateInt# ipv1_sohX } in
          case ># s_ao8q 23# of {
            __DEFAULT ->
              case <# ipv_sohW 0# of {
                __DEFAULT -> smallInteger (uncheckedIShiftRL# ipv_sohW s_ao8q);
                1# ->
                  smallInteger
                    (negateInt# (uncheckedIShiftRA# (negateInt# ipv_sohW) s_ao8q))
              };
            1# -> lvl_roLO
          }
      }
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.RealFracMethods.properFractionDoubleInt2 :: Double
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.RealFracMethods.properFractionDoubleInt2
  = GHC.Types.D# 0.0##

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
GHC.Float.RealFracMethods.properFractionDoubleInt1 :: (Int, Double)
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.Float.RealFracMethods.properFractionDoubleInt1
  = (GHC.Float.RealFracMethods.properFractionDoubleInt3,
     GHC.Float.RealFracMethods.properFractionDoubleInt2)

-- RHS size: {terms: 22, types: 7, coercions: 0, joins: 0/1}
properFractionDoubleInt :: Double -> (Int, Double)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_doeO [Occ=Once!] :: Double) ->
                 case ds_doeO of { D# x_ao8D ->
                 case ==## x_ao8D 0.0## of {
                   __DEFAULT ->
                     let {
                       n_sopf :: Int#
                       [LclId]
                       n_sopf = double2Int# x_ao8D } in
                     (GHC.Types.I# n_sopf,
                      GHC.Types.D# (-## x_ao8D (int2Double# n_sopf)));
                   1# -> GHC.Float.RealFracMethods.properFractionDoubleInt1
                 }
                 }}]
properFractionDoubleInt
  = \ (ds_doeO :: Double) ->
      case ds_doeO of { D# x_ao8D ->
      case ==## x_ao8D 0.0## of {
        __DEFAULT ->
          let {
            n_sopf :: Int#
            [LclId]
            n_sopf = double2Int# x_ao8D } in
          (GHC.Types.I# n_sopf,
           GHC.Types.D# (-## x_ao8D (int2Double# n_sopf)));
        1# -> GHC.Float.RealFracMethods.properFractionDoubleInt1
      }
      }

-- RHS size: {terms: 20, types: 5, coercions: 0, joins: 0/1}
floorDoubleInt :: Double -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_doeH [Occ=Once!] :: Double) ->
                 case ds_doeH of { D# x_ao8F ->
                 let {
                   n_sopd :: Int#
                   [LclId]
                   n_sopd = double2Int# x_ao8F } in
                 case <## x_ao8F (int2Double# n_sopd) of {
                   __DEFAULT -> GHC.Types.I# n_sopd;
                   1# -> GHC.Types.I# (-# n_sopd 1#)
                 }
                 }}]
floorDoubleInt
  = \ (ds_doeH :: Double) ->
      case ds_doeH of { D# x_ao8F ->
      let {
        n_sopd [Dmd=<S,U>] :: Int#
        [LclId]
        n_sopd = double2Int# x_ao8F } in
      case <## x_ao8F (int2Double# n_sopd) of {
        __DEFAULT -> GHC.Types.I# n_sopd;
        1# -> GHC.Types.I# (-# n_sopd 1#)
      }
      }

-- RHS size: {terms: 20, types: 5, coercions: 0, joins: 0/1}
ceilingDoubleInt :: Double -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_doeA [Occ=Once!] :: Double) ->
                 case ds_doeA of { D# x_ao8H ->
                 let {
                   n_sopb :: Int#
                   [LclId]
                   n_sopb = double2Int# x_ao8H } in
                 case <## (int2Double# n_sopb) x_ao8H of {
                   __DEFAULT -> GHC.Types.I# n_sopb;
                   1# -> GHC.Types.I# (+# n_sopb 1#)
                 }
                 }}]
ceilingDoubleInt
  = \ (ds_doeA :: Double) ->
      case ds_doeA of { D# x_ao8H ->
      let {
        n_sopb [Dmd=<S,U>] :: Int#
        [LclId]
        n_sopb = double2Int# x_ao8H } in
      case <## (int2Double# n_sopb) x_ao8H of {
        __DEFAULT -> GHC.Types.I# n_sopb;
        1# -> GHC.Types.I# (+# n_sopb 1#)
      }
      }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
double2Int :: Double -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_doev [Occ=Once!] :: Double) ->
                 case ds_doev of { D# x_ao94 [Occ=Once] ->
                 GHC.Types.I# (double2Int# x_ao94)
                 }}]
double2Int
  = \ (ds_doev :: Double) ->
      case ds_doev of { D# x_ao94 -> GHC.Types.I# (double2Int# x_ao94) }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
int2Double :: Int -> Double
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_doer [Occ=Once!] :: Int) ->
                 case ds_doer of { I# i_ao95 [Occ=Once] ->
                 GHC.Types.D# (int2Double# i_ao95)
                 }}]
int2Double
  = \ (ds_doer :: Int) ->
      case ds_doer of { I# i_ao95 -> GHC.Types.D# (int2Double# i_ao95) }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
float2Int :: Float -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_doen [Occ=Once!] :: Float) ->
                 case ds_doen of { F# x_ao96 [Occ=Once] ->
                 GHC.Types.I# (float2Int# x_ao96)
                 }}]
float2Int
  = \ (ds_doen :: Float) ->
      case ds_doen of { F# x_ao96 -> GHC.Types.I# (float2Int# x_ao96) }

-- RHS size: {terms: 7, types: 3, coercions: 0, joins: 0/0}
int2Float :: Int -> Float
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (ds_doej [Occ=Once!] :: Int) ->
                 case ds_doej of { I# i_ao97 [Occ=Once] ->
                 GHC.Types.F# (int2Float# i_ao97)
                 }}]
int2Float
  = \ (ds_doej :: Int) ->
      case ds_doej of { I# i_ao97 -> GHC.Types.F# (int2Float# i_ao97) }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Float.RealFracMethods.$trModule4 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 20 0}]
GHC.Float.RealFracMethods.$trModule4 = "base"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.RealFracMethods.$trModule3 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.RealFracMethods.$trModule3
  = GHC.Types.TrNameS GHC.Float.RealFracMethods.$trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
GHC.Float.RealFracMethods.$trModule2 :: Addr#
[GblId,
 Caf=NoCafRefs,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 80 0}]
GHC.Float.RealFracMethods.$trModule2 = "GHC.Float.RealFracMethods"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
GHC.Float.RealFracMethods.$trModule1 :: TrName
[GblId,
 Caf=NoCafRefs,
 Str=m1,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 20}]
GHC.Float.RealFracMethods.$trModule1
  = GHC.Types.TrNameS GHC.Float.RealFracMethods.$trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
GHC.Float.RealFracMethods.$trModule :: Module
[GblId,
 Caf=NoCafRefs,
 Str=m,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
GHC.Float.RealFracMethods.$trModule
  = GHC.Types.Module
      GHC.Float.RealFracMethods.$trModule3
      GHC.Float.RealFracMethods.$trModule1

-- RHS size: {terms: 12, types: 14, coercions: 0, joins: 0/0}
roundDoubleInt :: Double -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_ao8J [Occ=Once!] :: Double) ->
                 case x_ao8J of { D# ds1_dohb [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_dohe
                        ds1_dohb realWorld#
                 of
                 { (# _ [Occ=Dead], ds3_dohc [Occ=Once] #) ->
                 GHC.Types.I# (double2Int# ds3_dohc)
                 }
                 }}]
roundDoubleInt
  = \ (x_ao8J :: Double) ->
      case x_ao8J of { D# ds1_dohb ->
      case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_dohe
             ds1_dohb realWorld#
      of
      { (# ds2_dohd, ds3_dohc #) ->
      GHC.Types.I# (double2Int# ds3_dohc)
      }
      }

-- RHS size: {terms: 31, types: 23, coercions: 0, joins: 0/0}
roundDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: Double -> Integer
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_ao93 [Occ=Once!] :: Double) ->
                 case x_ao93 of { D# ds1_dohb [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_dohe
                        ds1_dohb realWorld#
                 of
                 { (# _ [Occ=Dead], ds3_dohc [Occ=Once] #) ->
                 case decodeDoubleInteger ds3_dohc of
                 { (# ipv_sohs [Occ=Once*], ipv1_soht #) ->
                 case <# ipv1_soht 0# of {
                   __DEFAULT -> shiftLInteger ipv_sohs ipv1_soht;
                   1# ->
                     case integerToInt ipv_sohs of n_ao9b { __DEFAULT ->
                     smallInteger (uncheckedIShiftRA# n_ao9b (negateInt# ipv1_soht))
                     }
                 }
                 }
                 }
                 }}]
roundDoubleInteger
  = \ (x_ao93 :: Double) ->
      case x_ao93 of { D# ds1_dohb ->
      case {__pkg_ccall base-4.11.0.0 Double#
                           -> State# RealWorld -> (# State# RealWorld, Double# #)}_dohe
             ds1_dohb realWorld#
      of
      { (# ds2_dohd, ds3_dohc #) ->
      case decodeDoubleInteger ds3_dohc of { (# ipv_sohs, ipv1_soht #) ->
      case <# ipv1_soht 0# of {
        __DEFAULT -> shiftLInteger ipv_sohs ipv1_soht;
        1# ->
          case integerToInt ipv_sohs of n_ao9b { __DEFAULT ->
          smallInteger (uncheckedIShiftRA# n_ao9b (negateInt# ipv1_soht))
          }
      }
      }
      }
      }

-- RHS size: {terms: 28, types: 22, coercions: 0, joins: 0/0}
roundFloatInteger [InlPrag=INLINE (sat-args=1)] :: Float -> Integer
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_ao8C [Occ=Once!] :: Float) ->
                 case x_ao8C of { F# ds1_doh4 [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_doh7
                        ds1_doh4 realWorld#
                 of
                 { (# _ [Occ=Dead], ds3_doh5 [Occ=Once] #) ->
                 case decodeFloat_Int# ds3_doh5 of
                 { (# ipv_soiv [Occ=Once*], ipv1_soiw #) ->
                 case <# ipv1_soiw 0# of {
                   __DEFAULT -> shiftLInteger (smallInteger ipv_soiv) ipv1_soiw;
                   1# ->
                     smallInteger (uncheckedIShiftRA# ipv_soiv (negateInt# ipv1_soiw))
                 }
                 }
                 }
                 }}]
roundFloatInteger
  = \ (x_ao8C :: Float) ->
      case x_ao8C of { F# ds1_doh4 ->
      case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_doh7
             ds1_doh4 realWorld#
      of
      { (# ds2_doh6, ds3_doh5 #) ->
      case decodeFloat_Int# ds3_doh5 of { (# ipv_soiv, ipv1_soiw #) ->
      case <# ipv1_soiw 0# of {
        __DEFAULT -> shiftLInteger (smallInteger ipv_soiv) ipv1_soiw;
        1# ->
          smallInteger (uncheckedIShiftRA# ipv_soiv (negateInt# ipv1_soiw))
      }
      }
      }
      }

-- RHS size: {terms: 12, types: 14, coercions: 0, joins: 0/0}
roundFloatInt :: Float -> Int
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=False)
         Tmpl= \ (x_ao8l [Occ=Once!] :: Float) ->
                 case x_ao8l of { F# ds1_doh4 [Occ=Once] ->
                 case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_doh7
                        ds1_doh4 realWorld#
                 of
                 { (# _ [Occ=Dead], ds3_doh5 [Occ=Once] #) ->
                 GHC.Types.I# (float2Int# ds3_doh5)
                 }
                 }}]
roundFloatInt
  = \ (x_ao8l :: Float) ->
      case x_ao8l of { F# ds1_doh4 ->
      case {__pkg_ccall base-4.11.0.0 Float#
                           -> State# RealWorld -> (# State# RealWorld, Float# #)}_doh7
             ds1_doh4 realWorld#
      of
      { (# ds2_doh6, ds3_doh5 #) ->
      GHC.Types.I# (float2Int# ds3_doh5)
      }
      }

-- RHS size: {terms: 86, types: 28, coercions: 0, joins: 0/3}
properFractionDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: Double -> (Integer, Double)
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>m,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (v_ao8K [Occ=Once!] :: Double) ->
                 case v_ao8K of wild_XS { D# x_ao8L [Occ=Once] ->
                 case decodeDoubleInteger x_ao8L of { (# ipv_sojs, ipv1_sojt #) ->
                 case <# ipv1_sojt 0# of {
                   __DEFAULT ->
                     (shiftLInteger ipv_sojs ipv1_sojt, GHC.Types.D# 0.0##);
                   1# ->
                     let {
                       s_ao8O :: Int#
                       [LclId]
                       s_ao8O = negateInt# ipv1_sojt } in
                     case ># s_ao8O 52# of {
                       __DEFAULT ->
                         case ltInteger# ipv_sojs 0 of {
                           __DEFAULT ->
                             case integerToInt ipv_sojs of n_ao8S { __DEFAULT ->
                             let {
                               k_ao8T :: Int#
                               [LclId]
                               k_ao8T = uncheckedIShiftRA# n_ao8S s_ao8O } in
                             (smallInteger k_ao8T,
                              case encodeDoubleInteger
                                     (smallInteger (-# n_ao8S (uncheckedIShiftL# k_ao8T s_ao8O)))
                                     ipv1_sojt
                              of wild2_Xf
                              { __DEFAULT ->
                              GHC.Types.D# wild2_Xf
                              })
                             };
                           1# ->
                             case integerToInt (negateInteger ipv_sojs) of n_ao8P { __DEFAULT ->
                             let {
                               k_ao8Q :: Int#
                               [LclId]
                               k_ao8Q = uncheckedIShiftRA# n_ao8P s_ao8O } in
                             (smallInteger (negateInt# k_ao8Q),
                              case encodeDoubleInteger
                                     (smallInteger
                                        (negateInt# (-# n_ao8P (uncheckedIShiftL# k_ao8Q s_ao8O))))
                                     ipv1_sojt
                              of wild2_Xf
                              { __DEFAULT ->
                              GHC.Types.D# wild2_Xf
                              })
                             }
                         };
                       1# -> (0, wild_XS)
                     }
                 }
                 }
                 }}]
properFractionDoubleInteger
  = \ (v_ao8K :: Double) ->
      case v_ao8K of wild_XS { D# x_ao8L ->
      case decodeDoubleInteger x_ao8L of { (# ipv_soj4, ipv1_soj5 #) ->
      case <# ipv1_soj5 0# of {
        __DEFAULT ->
          (shiftLInteger ipv_soj4 ipv1_soj5,
           GHC.Float.RealFracMethods.properFractionDoubleInt2);
        1# ->
          let {
            s_sop7 [Dmd=<S,U>] :: Int#
            [LclId]
            s_sop7 = negateInt# ipv1_soj5 } in
          case ># s_sop7 52# of {
            __DEFAULT ->
              case ltInteger# ipv_soj4 lvl_roLO of {
                __DEFAULT ->
                  case integerToInt ipv_soj4 of n_ao8S { __DEFAULT ->
                  let {
                    k_sop6 :: Int#
                    [LclId]
                    k_sop6 = uncheckedIShiftRA# n_ao8S s_sop7 } in
                  (smallInteger k_sop6,
                   case encodeDoubleInteger
                          (smallInteger (-# n_ao8S (uncheckedIShiftL# k_sop6 s_sop7)))
                          ipv1_soj5
                   of wild2_XA
                   { __DEFAULT ->
                   GHC.Types.D# wild2_XA
                   })
                  };
                1# ->
                  case integerToInt (negateInteger ipv_soj4) of n_ao8P { __DEFAULT ->
                  let {
                    k_sop9 :: Int#
                    [LclId]
                    k_sop9 = uncheckedIShiftRA# n_ao8P s_sop7 } in
                  (smallInteger (negateInt# k_sop9),
                   case encodeDoubleInteger
                          (smallInteger
                             (negateInt# (-# n_ao8P (uncheckedIShiftL# k_sop9 s_sop7))))
                          ipv1_soj5
                   of wild2_XA
                   { __DEFAULT ->
                   GHC.Types.D# wild2_XA
                   })
                  }
              };
            1# -> (lvl_roLO, wild_XS)
          }
      }
      }
      }

-- RHS size: {terms: 51, types: 16, coercions: 0, joins: 0/1}
truncateDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: Double -> Integer
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (x_ao8V [Occ=Once!] :: Double) ->
                 case x_ao8V of { D# x1_ao8L [Occ=Once] ->
                 case decodeDoubleInteger x1_ao8L of { (# ipv_sojs, ipv1_sojt #) ->
                 case <# ipv1_sojt 0# of {
                   __DEFAULT -> shiftLInteger ipv_sojs ipv1_sojt;
                   1# ->
                     let {
                       s_ao8O :: Int#
                       [LclId]
                       s_ao8O = negateInt# ipv1_sojt } in
                     case ># s_ao8O 52# of {
                       __DEFAULT ->
                         case ltInteger# ipv_sojs 0 of {
                           __DEFAULT ->
                             case integerToInt ipv_sojs of n_ao8S { __DEFAULT ->
                             smallInteger (uncheckedIShiftRA# n_ao8S s_ao8O)
                             };
                           1# ->
                             case integerToInt (negateInteger ipv_sojs) of n_ao8P { __DEFAULT ->
                             smallInteger (negateInt# (uncheckedIShiftRA# n_ao8P s_ao8O))
                             }
                         };
                       1# -> 0
                     }
                 }
                 }
                 }}]
truncateDoubleInteger
  = \ (x_ao8V :: Double) ->
      case x_ao8V of { D# x1_ao8L ->
      case decodeDoubleInteger x1_ao8L of { (# ipv_sojs, ipv1_sojt #) ->
      case <# ipv1_sojt 0# of {
        __DEFAULT -> shiftLInteger ipv_sojs ipv1_sojt;
        1# ->
          let {
            s_ao8O [Dmd=<S,U>] :: Int#
            [LclId]
            s_ao8O = negateInt# ipv1_sojt } in
          case ># s_ao8O 52# of {
            __DEFAULT ->
              case ltInteger# ipv_sojs lvl_roLO of {
                __DEFAULT ->
                  case integerToInt ipv_sojs of n_ao8S { __DEFAULT ->
                  smallInteger (uncheckedIShiftRA# n_ao8S s_ao8O)
                  };
                1# ->
                  case integerToInt (negateInteger ipv_sojs) of n_ao8P { __DEFAULT ->
                  smallInteger (negateInt# (uncheckedIShiftRA# n_ao8P s_ao8O))
                  }
              };
            1# -> lvl_roLO
          }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl1_roLP :: Integer
[GblId, Unf=OtherCon []]
lvl1_roLP = -1

-- RHS size: {terms: 39, types: 14, coercions: 0, joins: 0/1}
floorFloatInteger [InlPrag=INLINE (sat-args=1)] :: Float -> Integer
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_doeU [Occ=Once!] :: Float) ->
                 case ds_doeU of { F# x_ao8x [Occ=Once] ->
                 case decodeFloat_Int# x_ao8x of
                 { (# ipv_sojU [Occ=Once*], ipv1_sojV #) ->
                 case <# ipv1_sojV 0# of {
                   __DEFAULT -> shiftLInteger (smallInteger ipv_sojU) ipv1_sojV;
                   1# ->
                     let {
                       s_ao8A :: Int#
                       [LclId]
                       s_ao8A = negateInt# ipv1_sojV } in
                     case ># s_ao8A 23# of {
                       __DEFAULT -> smallInteger (uncheckedIShiftRA# ipv_sojU s_ao8A);
                       1# ->
                         case <# ipv_sojU 0# of {
                           __DEFAULT -> 0;
                           1# -> -1
                         }
                     }
                 }
                 }
                 }}]
floorFloatInteger
  = \ (ds_doeU :: Float) ->
      case ds_doeU of { F# x_ao8x ->
      case decodeFloat_Int# x_ao8x of { (# ipv_sojJ, ipv1_sojK #) ->
      case <# ipv1_sojK 0# of {
        __DEFAULT -> shiftLInteger (smallInteger ipv_sojJ) ipv1_sojK;
        1# ->
          let {
            s_sop3 [Dmd=<S,U>] :: Int#
            [LclId]
            s_sop3 = negateInt# ipv1_sojK } in
          case ># s_sop3 23# of {
            __DEFAULT -> smallInteger (uncheckedIShiftRA# ipv_sojJ s_sop3);
            1# ->
              case <# ipv_sojJ 0# of {
                __DEFAULT -> lvl_roLO;
                1# -> lvl1_roLP
              }
          }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl2_roLQ :: Integer
[GblId, Unf=OtherCon []]
lvl2_roLQ = 1

-- RHS size: {terms: 42, types: 14, coercions: 0, joins: 0/1}
ceilingFloatInteger [InlPrag=INLINE (sat-args=1)]
  :: Float -> Integer
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_dof8 [Occ=Once!] :: Float) ->
                 case ds_dof8 of { F# x_ao8B [Occ=Once] ->
                 case decodeFloat_Int# (negateFloat# x_ao8B) of
                 { (# ipv_sojU [Occ=Once*], ipv1_sojV #) ->
                 case <# ipv1_sojV 0# of {
                   __DEFAULT ->
                     negateInteger (shiftLInteger (smallInteger ipv_sojU) ipv1_sojV);
                   1# ->
                     let {
                       s_ao8A :: Int#
                       [LclId]
                       s_ao8A = negateInt# ipv1_sojV } in
                     case ># s_ao8A 23# of {
                       __DEFAULT ->
                         negateInteger (smallInteger (uncheckedIShiftRA# ipv_sojU s_ao8A));
                       1# ->
                         case <# ipv_sojU 0# of {
                           __DEFAULT -> 0;
                           1# -> 1
                         }
                     }
                 }
                 }
                 }}]
ceilingFloatInteger
  = \ (ds_dof8 :: Float) ->
      case ds_dof8 of { F# x_ao8B ->
      case decodeFloat_Int# (negateFloat# x_ao8B) of
      { (# ipv_sojU, ipv1_sojV #) ->
      case <# ipv1_sojV 0# of {
        __DEFAULT ->
          negateInteger (shiftLInteger (smallInteger ipv_sojU) ipv1_sojV);
        1# ->
          let {
            s_sop1 [Dmd=<S,U>] :: Int#
            [LclId]
            s_sop1 = negateInt# ipv1_sojV } in
          case ># s_sop1 23# of {
            __DEFAULT ->
              negateInteger (smallInteger (uncheckedIShiftRA# ipv_sojU s_sop1));
            1# ->
              case <# ipv_sojU 0# of {
                __DEFAULT -> lvl_roLO;
                1# -> lvl2_roLQ
              }
          }
      }
      }
      }

-- RHS size: {terms: 42, types: 15, coercions: 0, joins: 0/1}
floorDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: Double -> Integer
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_dogw [Occ=Once!] :: Double) ->
                 case ds_dogw of { D# x_ao8X [Occ=Once] ->
                 case decodeDoubleInteger x_ao8X of
                 { (# ipv_sokr [Occ=Once*], ipv1_soks #) ->
                 case <# ipv1_soks 0# of {
                   __DEFAULT -> shiftLInteger ipv_sokr ipv1_soks;
                   1# ->
                     let {
                       s_ao90 :: Int#
                       [LclId]
                       s_ao90 = negateInt# ipv1_soks } in
                     case ># s_ao90 52# of {
                       __DEFAULT ->
                         case integerToInt ipv_sokr of n_ao91 { __DEFAULT ->
                         smallInteger (uncheckedIShiftRA# n_ao91 s_ao90)
                         };
                       1# ->
                         case ltInteger# ipv_sokr 0 of {
                           __DEFAULT -> 0;
                           1# -> -1
                         }
                     }
                 }
                 }
                 }}]
floorDoubleInteger
  = \ (ds_dogw :: Double) ->
      case ds_dogw of { D# x_ao8X ->
      case decodeDoubleInteger x_ao8X of { (# ipv_sokf, ipv1_sokg #) ->
      case <# ipv1_sokg 0# of {
        __DEFAULT -> shiftLInteger ipv_sokf ipv1_sokg;
        1# ->
          let {
            s_sooZ [Dmd=<S,U>] :: Int#
            [LclId]
            s_sooZ = negateInt# ipv1_sokg } in
          case ># s_sooZ 52# of {
            __DEFAULT ->
              case integerToInt ipv_sokf of n_ao91 { __DEFAULT ->
              smallInteger (uncheckedIShiftRA# n_ao91 s_sooZ)
              };
            1# ->
              case ltInteger# ipv_sokf lvl_roLO of {
                __DEFAULT -> lvl_roLO;
                1# -> lvl1_roLP
              }
          }
      }
      }
      }

-- RHS size: {terms: 45, types: 15, coercions: 0, joins: 0/1}
ceilingDoubleInteger [InlPrag=INLINE (sat-args=1)]
  :: Double -> Integer
[GblId,
 Arity=1,
 Str=<S(S),1*U(U)>,
 Unf=Unf{Src=InlineStable, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(arity=1,unsat_ok=False,boring_ok=False)
         Tmpl= \ (ds_dogL [Occ=Once!] :: Double) ->
                 case ds_dogL of { D# x_ao92 [Occ=Once] ->
                 case decodeDoubleInteger (negateDouble# x_ao92) of
                 { (# ipv_sokr [Occ=Once*], ipv1_soks #) ->
                 case <# ipv1_soks 0# of {
                   __DEFAULT -> negateInteger (shiftLInteger ipv_sokr ipv1_soks);
                   1# ->
                     let {
                       s_ao90 :: Int#
                       [LclId]
                       s_ao90 = negateInt# ipv1_soks } in
                     case ># s_ao90 52# of {
                       __DEFAULT ->
                         case integerToInt ipv_sokr of n_ao91 { __DEFAULT ->
                         negateInteger (smallInteger (uncheckedIShiftRA# n_ao91 s_ao90))
                         };
                       1# ->
                         case ltInteger# ipv_sokr 0 of {
                           __DEFAULT -> 0;
                           1# -> 1
                         }
                     }
                 }
                 }
                 }}]
ceilingDoubleInteger
  = \ (ds_dogL :: Double) ->
      case ds_dogL of { D# x_ao92 ->
      case decodeDoubleInteger (negateDouble# x_ao92) of
      { (# ipv_sokr, ipv1_soks #) ->
      case <# ipv1_soks 0# of {
        __DEFAULT -> negateInteger (shiftLInteger ipv_sokr ipv1_soks);
        1# ->
          let {
            s_sooX [Dmd=<S,U>] :: Int#
            [LclId]
            s_sooX = negateInt# ipv1_soks } in
          case ># s_sooX 52# of {
            __DEFAULT ->
              case integerToInt ipv_sokr of n_ao91 { __DEFAULT ->
              negateInteger (smallInteger (uncheckedIShiftRA# n_ao91 s_sooX))
              };
            1# ->
              case ltInteger# ipv_sokr lvl_roLO of {
                __DEFAULT -> lvl_roLO;
                1# -> lvl2_roLQ
              }
          }
      }
      }
      }


