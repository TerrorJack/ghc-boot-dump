
==================== Raw Cmm ====================
2018-03-16 15:55:02.5592202 UTC

[]


==================== Raw Cmm ====================
2018-03-16 15:55:02.560329877 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt3_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.562325489 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInt2_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInt2_closure:
         const GHC.Types.F#_con_info;
         const 0.0 :: W32;
         const 0 :: W32;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.564088665 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInt1_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInt1_closure:
         const (,)_con_info;
         const GHC.Float.RealFracMethods.properFractionDoubleInt3_closure+1;
         const GHC.Float.RealFracMethods.properFractionFloatInt2_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.567250126 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInt_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInt_closure:
         const GHC.Float.RealFracMethods.properFractionFloatInt_info;
 },
 GHC.Float.RealFracMethods.properFractionFloatInt_entry() //  [R2]
         { []
         }
     {offset
       cpoW: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpoX; else goto cpoY;
       cpoX: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpoY: // global
           I64[Sp - 8] = block_cpoT_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uppm; else goto cpoU;
       uppm: // global
           call _cpoT(R1) args: 0, res: 0, upd: 0;
       cpoU: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.properFractionFloatInt_info" {
     GHC.Float.RealFracMethods.properFractionFloatInt_info:
         const GHC.Float.RealFracMethods.properFractionFloatInt_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cpoT() //  [R1]
         { []
         }
     {offset
       cpoT: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cpp3; else goto cpp2;
       cpp3: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpp2: // global
           _soLU::F32 = F32[R1 + 7];
           if (%MO_F_Eq_W32(_soLU::F32,
                            0.0 :: W32)) goto cppl; else goto cppk;
       cppl: // global
           Hp = Hp - 56;
           R1 = GHC.Float.RealFracMethods.properFractionFloatInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cppk: // global
           I64[Hp - 48] = GHC.Types.F#_con_info;
           _soLW::I64 = %MO_FS_Conv_W32_W64(_soLU::F32);
           F32[Hp - 40] = %MO_F_Sub_W32(_soLU::F32,
                                        %MO_SF_Conv_W64_W32(_soLW::I64));
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _soLW::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpoT_info" {
     block_cpoT_info:
         const _cpoT;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.575133659 UTC

[section ""data" . GHC.Float.RealFracMethods.floorFloatInt_closure" {
     GHC.Float.RealFracMethods.floorFloatInt_closure:
         const GHC.Float.RealFracMethods.floorFloatInt_info;
 },
 GHC.Float.RealFracMethods.floorFloatInt_entry() //  [R2]
         { []
         }
     {offset
       cppM: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cppN; else goto cppO;
       cppN: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cppO: // global
           I64[Sp - 8] = block_cppJ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upqc; else goto cppK;
       upqc: // global
           call _cppJ(R1) args: 0, res: 0, upd: 0;
       cppK: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.floorFloatInt_info" {
     GHC.Float.RealFracMethods.floorFloatInt_info:
         const GHC.Float.RealFracMethods.floorFloatInt_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cppJ() //  [R1]
         { []
         }
     {offset
       cppJ: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cppT; else goto cppS;
       cppT: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cppS: // global
           _soM3::F32 = F32[R1 + 7];
           _soM4::I64 = %MO_FS_Conv_W32_W64(_soM3::F32);
           if (%MO_F_Lt_W32(_soM3::F32,
                            %MO_SF_Conv_W64_W32(_soM4::I64))) goto cpqb; else goto cpq5;
       cpqb: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soM4::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpq5: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soM4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cppJ_info" {
     block_cppJ_info:
         const _cppJ;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.58212926 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingFloatInt_closure" {
     GHC.Float.RealFracMethods.ceilingFloatInt_closure:
         const GHC.Float.RealFracMethods.ceilingFloatInt_info;
 },
 GHC.Float.RealFracMethods.ceilingFloatInt_entry() //  [R2]
         { []
         }
     {offset
       cpqy: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpqz; else goto cpqA;
       cpqz: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpqA: // global
           I64[Sp - 8] = block_cpqv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upqY; else goto cpqw;
       upqY: // global
           call _cpqv(R1) args: 0, res: 0, upd: 0;
       cpqw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.ceilingFloatInt_info" {
     GHC.Float.RealFracMethods.ceilingFloatInt_info:
         const GHC.Float.RealFracMethods.ceilingFloatInt_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cpqv() //  [R1]
         { []
         }
     {offset
       cpqv: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpqF; else goto cpqE;
       cpqF: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpqE: // global
           _soMa::F32 = F32[R1 + 7];
           _soMb::I64 = %MO_FS_Conv_W32_W64(_soMa::F32);
           if (%MO_F_Lt_W32(%MO_SF_Conv_W64_W32(_soMb::I64),
                            _soMa::F32)) goto cpqX; else goto cpqR;
       cpqX: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soMb::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpqR: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soMb::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpqv_info" {
     block_cpqv_info:
         const _cpqv;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.587919703 UTC

[section ""data" . lvl_roLO_closure" {
     lvl_roLO_closure:
         const lvl_roLO_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_roLO_entry() //  [R1]
         { []
         }
     {offset
       cprj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cprk; else goto cprl;
       cprk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cprl: // global
           (_cprg::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cprg::I64 == 0) goto cpri; else goto cprh;
       cpri: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cprh: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cprg::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl_roLO_info" {
     lvl_roLO_info:
         const lvl_roLO_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.596564607 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInteger_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInteger_closure:
         const GHC.Float.RealFracMethods.properFractionFloatInteger_info;
         const 0;
 },
 sat_soMn_entry() //  [R1]
         { []
         }
     {offset
       cprP: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cprQ; else goto cprR;
       cprQ: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cprR: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cprN_info;
           R2 = I64[R1 + 16];
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_soMn_info" {
     sat_soMn_info:
         const sat_soMn_entry;
         const 8589934592;
         const 20;
 },
 _cprN() //  [R1]
         { []
         }
     {offset
       cprN: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cprN_info" {
     block_cprN_info:
         const _cprN;
         const 65;
         const 30;
 },
 sat_soMx_entry() //  [R1]
         { []
         }
     {offset
       cpse: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpss; else goto cpst;
       cpss: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpst: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cpsj_info;
           R2 = I64[R1 + 16] - (I64[R1 + 40] << I64[R1 + 32]);
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_soMx_info" {
     sat_soMx_info:
         const sat_soMx_entry;
         const 17179869184;
         const 15;
 },
 _cpsj() //  [R1]
         { []
         }
     {offset
       cpsj: // global
           _soMk::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cpsn_info;
           R3 = _soMk::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeFloatInteger_entry(R3,
                                                          R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cpsj_info" {
     block_cpsj_info:
         const _cpsj;
         const 65;
         const 30;
 },
 _cpsn() //  [F1]
         { []
         }
     {offset
       cpsn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpsx; else goto cpsw;
       cpsx: // global
           HpAlloc = 16;
           F1 = F1;
           call stg_gc_f1(F1) args: 8, res: 8, upd: 24;
       cpsw: // global
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = F1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cpsn_info" {
     block_cpsn_info:
         const _cpsn;
         const 0;
         const 30;
 },
 sat_soMs_entry() //  [R1]
         { []
         }
     {offset
       cpsC: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpsD; else goto cpsE;
       cpsD: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpsE: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_soMs_info" {
     sat_soMs_info:
         const sat_soMs_entry;
         const 4294967296;
         const 17;
 },
 sat_soMG_entry() //  [R1]
         { []
         }
     {offset
       cpsV: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpt9; else goto cpta;
       cpt9: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpta: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cpt0_info;
           R2 = I64[R1 + 16] - (I64[R1 + 40] << I64[R1 + 32]);
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_soMG_info" {
     sat_soMG_info:
         const sat_soMG_entry;
         const 17179869184;
         const 15;
 },
 _cpt0() //  [R1]
         { []
         }
     {offset
       cpt0: // global
           _soMk::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cpt4_info;
           R3 = _soMk::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeFloatInteger_entry(R3,
                                                          R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cpt0_info" {
     block_cpt0_info:
         const _cpt0;
         const 65;
         const 30;
 },
 _cpt4() //  [F1]
         { []
         }
     {offset
       cpt4: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpte; else goto cptd;
       cpte: // global
           HpAlloc = 16;
           F1 = F1;
           call stg_gc_f1(F1) args: 8, res: 8, upd: 24;
       cptd: // global
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = F1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cpt4_info" {
     block_cpt4_info:
         const _cpt4;
         const 0;
         const 30;
 },
 sat_soMB_entry() //  [R1]
         { []
         }
     {offset
       cptj: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cptk; else goto cptl;
       cptk: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cptl: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_soMB_info" {
     sat_soMB_info:
         const sat_soMB_entry;
         const 4294967296;
         const 17;
 },
 GHC.Float.RealFracMethods.properFractionFloatInteger_entry() //  [R2]
         { []
         }
     {offset
       cptm: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cptn; else goto cpto;
       cptn: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpto: // global
           I64[Sp - 8] = block_cprx_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uptJ; else goto cpry;
       uptJ: // global
           call _cprx(R1) args: 0, res: 0, upd: 0;
       cpry: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.properFractionFloatInteger_info" {
     GHC.Float.RealFracMethods.properFractionFloatInteger_info:
         const GHC.Float.RealFracMethods.properFractionFloatInteger_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const SoU1_srt;
 },
 _cprx() //  [R1]
         { []
         }
     {offset
       cprx: // global
           I64[Sp - 8] = block_cprC_info;
           F1 = F32[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cprx_info" {
     block_cprx_info:
         const _cprx;
         const 0;
         const 4294967326;
         const SoU1_srt+8;
 },
 _cprC() //  [R1, R2]
         { []
         }
     {offset
       cprC: // global
           I64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _cprD() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cprC_info" {
     block_cprC_info:
         const _cprC;
         const 1;
         const 4294967326;
         const SoU1_srt+8;
 },
 _cprD() //  []
         { []
         }
     {offset
       cprD: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cpts; else goto cptr;
       cpts: // global
           HpAlloc = 96;
           I64[Sp] = block_cprD_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cptr: // global
           _soMj::I64 = I64[Sp + 16];
           _soMk::I64 = I64[Sp + 8];
           if (%MO_S_Ge_W64(_soMk::I64, 0)) goto cptv; else goto cptG;
       cptv: // global
           I64[Hp - 88] = sat_soMn_info;
           I64[Hp - 72] = _soMj::I64;
           I64[Hp - 64] = _soMk::I64;
           I64[Hp - 56] = (,)_con_info;
           P64[Hp - 48] = Hp - 88;
           P64[Hp - 40] = GHC.Float.RealFracMethods.properFractionFloatInt2_closure+1;
           _cptt::P64 = Hp - 55;
           Hp = Hp - 40;
           R1 = _cptt::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cptG: // global
           _soMo::I64 = -_soMk::I64;
           if (%MO_S_Le_W64(_soMo::I64, 23)) goto cptC; else goto cptF;
       cptC: // global
           if (%MO_S_Ge_W64(_soMj::I64, 0)) goto cpty; else goto cptA;
       cpty: // global
           I64[Hp - 88] = sat_soMx_info;
           I64[Hp - 72] = _soMj::I64;
           I64[Hp - 64] = _soMk::I64;
           I64[Hp - 56] = _soMo::I64;
           _soMr::I64 = _soMj::I64 >> _soMo::I64;
           I64[Hp - 48] = _soMr::I64;
           I64[Hp - 40] = sat_soMs_info;
           I64[Hp - 24] = _soMr::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cptA: // global
           I64[Hp - 88] = sat_soMG_info;
           I64[Hp - 72] = _soMj::I64;
           I64[Hp - 64] = _soMk::I64;
           I64[Hp - 56] = _soMo::I64;
           _soMy::I64 = -%MO_S_Shr_W64(-_soMj::I64, _soMo::I64);
           I64[Hp - 48] = _soMy::I64;
           I64[Hp - 40] = sat_soMB_info;
           I64[Hp - 24] = _soMy::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cptF: // global
           I64[Hp - 88] = (,)_con_info;
           P64[Hp - 80] = lvl_roLO_closure;
           P64[Hp - 72] = P64[Sp + 24];
           _cptE::P64 = Hp - 87;
           Hp = Hp - 72;
           R1 = _cptE::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cprD_info" {
     block_cprD_info:
         const _cprD;
         const 195;
         const 4294967326;
         const SoU1_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.623930115 UTC

[section ""data" . GHC.Float.RealFracMethods.truncateFloatInteger_closure" {
     GHC.Float.RealFracMethods.truncateFloatInteger_closure:
         const GHC.Float.RealFracMethods.truncateFloatInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.truncateFloatInteger_entry() //  [R2]
         { []
         }
     {offset
       cpv0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpv1; else goto cpv2;
       cpv1: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.truncateFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpv2: // global
           I64[Sp - 8] = block_cpuX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upvL; else goto cpuY;
       upvL: // global
           call _cpuX(R1) args: 0, res: 0, upd: 0;
       cpuY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.truncateFloatInteger_info" {
     GHC.Float.RealFracMethods.truncateFloatInteger_info:
         const GHC.Float.RealFracMethods.truncateFloatInteger_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const SoU1_srt+8;
 },
 _cpuX() //  [R1]
         { []
         }
     {offset
       cpuX: // global
           I64[Sp] = block_cpv5_info;
           F1 = F32[R1 + 7];
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cpuX_info" {
     block_cpuX_info:
         const _cpuX;
         const 0;
         const 4294967326;
         const SoU1_srt+8;
 },
 _cpv5() //  [R1, R2]
         { []
         }
     {offset
       cpv5: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpvg; else goto cpvA;
       cpvg: // global
           I64[Sp - 8] = block_cpve_info;
           _soMM::I64 = R2;
           R2 = R1;
           I64[Sp] = _soMM::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpvA: // global
           _soMP::I64 = -R2;
           if (%MO_S_Le_W64(_soMP::I64, 23)) goto cpvy; else goto cpvz;
       cpvy: // global
           if (%MO_S_Ge_W64(R1, 0)) goto cpvv; else goto cpvw;
       cpvv: // global
           R2 = R1 >> _soMP::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       cpvw: // global
           R2 = -%MO_S_Shr_W64(-R1, _soMP::I64);
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       cpvz: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpv5_info" {
     block_cpv5_info:
         const _cpv5;
         const 0;
         const 4294967326;
         const SoU1_srt+8;
 },
 _cpve() //  [R1]
         { []
         }
     {offset
       cpve: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpve_info" {
     block_cpve_info:
         const _cpve;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.632587671 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt2_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt2_closure:
         const GHC.Types.D#_con_info;
         const 0.0 :: W64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.634442232 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt1_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt1_closure:
         const (,)_con_info;
         const GHC.Float.RealFracMethods.properFractionDoubleInt3_closure+1;
         const GHC.Float.RealFracMethods.properFractionDoubleInt2_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.63850527 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt_closure:
         const GHC.Float.RealFracMethods.properFractionDoubleInt_info;
 },
 GHC.Float.RealFracMethods.properFractionDoubleInt_entry() //  [R2]
         { []
         }
     {offset
       cpwd: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpwe; else goto cpwf;
       cpwe: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpwf: // global
           I64[Sp - 8] = block_cpwa_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upwD; else goto cpwb;
       upwD: // global
           call _cpwa(R1) args: 0, res: 0, upd: 0;
       cpwb: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.properFractionDoubleInt_info" {
     GHC.Float.RealFracMethods.properFractionDoubleInt_info:
         const GHC.Float.RealFracMethods.properFractionDoubleInt_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cpwa() //  [R1]
         { []
         }
     {offset
       cpwa: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cpwk; else goto cpwj;
       cpwk: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpwj: // global
           _soMY::F64 = F64[R1 + 7];
           if (%MO_F_Eq_W64(_soMY::F64,
                            0.0 :: W64)) goto cpwC; else goto cpwB;
       cpwC: // global
           Hp = Hp - 56;
           R1 = GHC.Float.RealFracMethods.properFractionDoubleInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpwB: // global
           I64[Hp - 48] = GHC.Types.D#_con_info;
           _soN0::I64 = %MO_FS_Conv_W64_W64(_soMY::F64);
           F64[Hp - 40] = %MO_F_Sub_W64(_soMY::F64,
                                        %MO_SF_Conv_W64_W64(_soN0::I64));
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _soN0::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpwa_info" {
     block_cpwa_info:
         const _cpwa;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.645148572 UTC

[section ""data" . GHC.Float.RealFracMethods.floorDoubleInt_closure" {
     GHC.Float.RealFracMethods.floorDoubleInt_closure:
         const GHC.Float.RealFracMethods.floorDoubleInt_info;
 },
 GHC.Float.RealFracMethods.floorDoubleInt_entry() //  [R2]
         { []
         }
     {offset
       cpx3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpx4; else goto cpx5;
       cpx4: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpx5: // global
           I64[Sp - 8] = block_cpx0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upxt; else goto cpx1;
       upxt: // global
           call _cpx0(R1) args: 0, res: 0, upd: 0;
       cpx1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.floorDoubleInt_info" {
     GHC.Float.RealFracMethods.floorDoubleInt_info:
         const GHC.Float.RealFracMethods.floorDoubleInt_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cpx0() //  [R1]
         { []
         }
     {offset
       cpx0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpxa; else goto cpx9;
       cpxa: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpx9: // global
           _soN7::F64 = F64[R1 + 7];
           _soN8::I64 = %MO_FS_Conv_W64_W64(_soN7::F64);
           if (%MO_F_Lt_W64(_soN7::F64,
                            %MO_SF_Conv_W64_W64(_soN8::I64))) goto cpxs; else goto cpxm;
       cpxs: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soN8::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpxm: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soN8::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpx0_info" {
     block_cpx0_info:
         const _cpx0;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.651460322 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingDoubleInt_closure" {
     GHC.Float.RealFracMethods.ceilingDoubleInt_closure:
         const GHC.Float.RealFracMethods.ceilingDoubleInt_info;
 },
 GHC.Float.RealFracMethods.ceilingDoubleInt_entry() //  [R2]
         { []
         }
     {offset
       cpxP: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpxQ; else goto cpxR;
       cpxQ: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpxR: // global
           I64[Sp - 8] = block_cpxM_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upyf; else goto cpxN;
       upyf: // global
           call _cpxM(R1) args: 0, res: 0, upd: 0;
       cpxN: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.ceilingDoubleInt_info" {
     GHC.Float.RealFracMethods.ceilingDoubleInt_info:
         const GHC.Float.RealFracMethods.ceilingDoubleInt_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cpxM() //  [R1]
         { []
         }
     {offset
       cpxM: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpxW; else goto cpxV;
       cpxW: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpxV: // global
           _soNe::F64 = F64[R1 + 7];
           _soNf::I64 = %MO_FS_Conv_W64_W64(_soNe::F64);
           if (%MO_F_Lt_W64(%MO_SF_Conv_W64_W64(_soNf::I64),
                            _soNe::F64)) goto cpye; else goto cpy8;
       cpye: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soNf::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpy8: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soNf::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpxM_info" {
     block_cpxM_info:
         const _cpxM;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.658003289 UTC

[section ""data" . GHC.Float.RealFracMethods.double2Int_closure" {
     GHC.Float.RealFracMethods.double2Int_closure:
         const GHC.Float.RealFracMethods.double2Int_info;
 },
 GHC.Float.RealFracMethods.double2Int_entry() //  [R2]
         { []
         }
     {offset
       cpyB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpyI; else goto cpyJ;
       cpyI: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.double2Int_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpyJ: // global
           I64[Sp - 8] = block_cpyy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upyN; else goto cpyz;
       upyN: // global
           call _cpyy(R1) args: 0, res: 0, upd: 0;
       cpyz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.double2Int_info" {
     GHC.Float.RealFracMethods.double2Int_info:
         const GHC.Float.RealFracMethods.double2Int_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cpyy() //  [R1]
         { []
         }
     {offset
       cpyy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpyM; else goto cpyL;
       cpyM: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpyL: // global
           _soNm::I64 = %MO_FS_Conv_W64_W64(F64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soNm::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpyy_info" {
     block_cpyy_info:
         const _cpyy;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.66385957 UTC

[section ""data" . GHC.Float.RealFracMethods.int2Double_closure" {
     GHC.Float.RealFracMethods.int2Double_closure:
         const GHC.Float.RealFracMethods.int2Double_info;
 },
 GHC.Float.RealFracMethods.int2Double_entry() //  [R2]
         { []
         }
     {offset
       cpz5: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpzc; else goto cpzd;
       cpzc: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.int2Double_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpzd: // global
           I64[Sp - 8] = block_cpz2_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upzh; else goto cpz3;
       upzh: // global
           call _cpz2(R1) args: 0, res: 0, upd: 0;
       cpz3: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.int2Double_info" {
     GHC.Float.RealFracMethods.int2Double_info:
         const GHC.Float.RealFracMethods.int2Double_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cpz2() //  [R1]
         { []
         }
     {offset
       cpz2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpzg; else goto cpzf;
       cpzg: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpzf: // global
           _soNq::F64 = %MO_SF_Conv_W64_W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _soNq::F64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpz2_info" {
     block_cpz2_info:
         const _cpz2;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.670169948 UTC

[section ""data" . GHC.Float.RealFracMethods.float2Int_closure" {
     GHC.Float.RealFracMethods.float2Int_closure:
         const GHC.Float.RealFracMethods.float2Int_info;
 },
 GHC.Float.RealFracMethods.float2Int_entry() //  [R2]
         { []
         }
     {offset
       cpzz: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpzG; else goto cpzH;
       cpzG: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.float2Int_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpzH: // global
           I64[Sp - 8] = block_cpzw_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upzL; else goto cpzx;
       upzL: // global
           call _cpzw(R1) args: 0, res: 0, upd: 0;
       cpzx: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.float2Int_info" {
     GHC.Float.RealFracMethods.float2Int_info:
         const GHC.Float.RealFracMethods.float2Int_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cpzw() //  [R1]
         { []
         }
     {offset
       cpzw: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpzK; else goto cpzJ;
       cpzK: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpzJ: // global
           _soNu::I64 = %MO_FS_Conv_W32_W64(F32[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _soNu::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpzw_info" {
     block_cpzw_info:
         const _cpzw;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.676559542 UTC

[section ""data" . GHC.Float.RealFracMethods.int2Float_closure" {
     GHC.Float.RealFracMethods.int2Float_closure:
         const GHC.Float.RealFracMethods.int2Float_info;
 },
 GHC.Float.RealFracMethods.int2Float_entry() //  [R2]
         { []
         }
     {offset
       cpA3: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpAa; else goto cpAb;
       cpAa: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.int2Float_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpAb: // global
           I64[Sp - 8] = block_cpA0_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upAf; else goto cpA1;
       upAf: // global
           call _cpA0(R1) args: 0, res: 0, upd: 0;
       cpA1: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.int2Float_info" {
     GHC.Float.RealFracMethods.int2Float_info:
         const GHC.Float.RealFracMethods.int2Float_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cpA0() //  [R1]
         { []
         }
     {offset
       cpA0: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpAe; else goto cpAd;
       cpAe: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpAd: // global
           _soNy::F32 = %MO_SF_Conv_W64_W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _soNy::F32;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpA0_info" {
     block_cpA0_info:
         const _cpA0;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.681605042 UTC

[section ""cstring" . GHC.Float.RealFracMethods.$trModule4_bytes" {
     GHC.Float.RealFracMethods.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.683314361 UTC

[section ""data" . GHC.Float.RealFracMethods.$trModule3_closure" {
     GHC.Float.RealFracMethods.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.RealFracMethods.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.685033704 UTC

[section ""cstring" . GHC.Float.RealFracMethods.$trModule2_bytes" {
     GHC.Float.RealFracMethods.$trModule2_bytes:
         I8[] [71,72,67,46,70,108,111,97,116,46,82,101,97,108,70,114,97,99,77,101,116,104,111,100,115]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.686710076 UTC

[section ""data" . GHC.Float.RealFracMethods.$trModule1_closure" {
     GHC.Float.RealFracMethods.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.RealFracMethods.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.688370675 UTC

[section ""data" . GHC.Float.RealFracMethods.$trModule_closure" {
     GHC.Float.RealFracMethods.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Float.RealFracMethods.$trModule3_closure+1;
         const GHC.Float.RealFracMethods.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.691190816 UTC

[section ""data" . GHC.Float.RealFracMethods.roundDoubleInt_closure" {
     GHC.Float.RealFracMethods.roundDoubleInt_closure:
         const GHC.Float.RealFracMethods.roundDoubleInt_info;
 },
 GHC.Float.RealFracMethods.roundDoubleInt_entry() //  [R2]
         { []
         }
     {offset
       cpAC: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpAL; else goto cpAM;
       cpAL: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpAM: // global
           I64[Sp - 8] = block_cpAz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upAQ; else goto cpAA;
       upAQ: // global
           call _cpAz(R1) args: 0, res: 0, upd: 0;
       cpAA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.roundDoubleInt_info" {
     GHC.Float.RealFracMethods.roundDoubleInt_info:
         const GHC.Float.RealFracMethods.roundDoubleInt_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cpAz() //  [R1]
         { []
         }
     {offset
       cpAz: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpAP; else goto cpAO;
       cpAP: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpAO: // global
           (_soNF::F64) = call "ccall" arg hints:  []  result hints:  [] rintDouble(F64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_FS_Conv_W64_W64(_soNF::F64);
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpAz_info" {
     block_cpAz_info:
         const _cpAz;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.697874089 UTC

[section ""data" . GHC.Float.RealFracMethods.roundDoubleInteger_closure" {
     GHC.Float.RealFracMethods.roundDoubleInteger_closure:
         const GHC.Float.RealFracMethods.roundDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.roundDoubleInteger_entry() //  [R2]
         { []
         }
     {offset
       cpB9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpBa; else goto cpBb;
       cpBa: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpBb: // global
           I64[Sp - 8] = block_cpB6_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upBC; else goto cpB7;
       upBC: // global
           call _cpB6(R1) args: 0, res: 0, upd: 0;
       cpB7: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.roundDoubleInteger_info" {
     GHC.Float.RealFracMethods.roundDoubleInteger_info:
         const GHC.Float.RealFracMethods.roundDoubleInteger_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const SoU1_srt+24;
 },
 _cpB6() //  [R1]
         { []
         }
     {offset
       cpB6: // global
           (_soNN::F64) = call "ccall" arg hints:  []  result hints:  [] rintDouble(F64[R1 + 7]);
           I64[Sp] = block_cpBg_info;
           D1 = _soNN::F64;
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cpB6_info" {
     block_cpB6_info:
         const _cpB6;
         const 0;
         const 4294967326;
         const SoU1_srt+24;
 },
 _cpBg() //  [R1, R2]
         { []
         }
     {offset
       cpBg: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpBp; else goto cpBt;
       cpBp: // global
           R3 = R2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       cpBt: // global
           I64[Sp - 8] = block_cpBs_info;
           _soNQ::I64 = R2;
           R2 = R1;
           I64[Sp] = _soNQ::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cpBg_info" {
     block_cpBg_info:
         const _cpBg;
         const 0;
         const 30;
 },
 _cpBs() //  [R1]
         { []
         }
     {offset
       cpBs: // global
           R2 = %MO_S_Shr_W64(R1, -I64[Sp + 8]);
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpBs_info" {
     block_cpBs_info:
         const _cpBs;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.70783787 UTC

[section ""data" . GHC.Float.RealFracMethods.roundFloatInteger_closure" {
     GHC.Float.RealFracMethods.roundFloatInteger_closure:
         const GHC.Float.RealFracMethods.roundFloatInteger_info;
 },
 GHC.Float.RealFracMethods.roundFloatInteger_entry() //  [R2]
         { []
         }
     {offset
       cpC0: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpC1; else goto cpC2;
       cpC1: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpC2: // global
           I64[Sp - 8] = block_cpBX_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upCt; else goto cpBY;
       upCt: // global
           call _cpBX(R1) args: 0, res: 0, upd: 0;
       cpBY: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.roundFloatInteger_info" {
     GHC.Float.RealFracMethods.roundFloatInteger_info:
         const GHC.Float.RealFracMethods.roundFloatInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cpBX() //  [R1]
         { []
         }
     {offset
       cpBX: // global
           (_soO1::F32) = call "ccall" arg hints:  []  result hints:  [] rintFloat(F32[R1 + 7]);
           I64[Sp] = block_cpC7_info;
           F1 = _soO1::F32;
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cpBX_info" {
     block_cpBX_info:
         const _cpBX;
         const 0;
         const 30;
 },
 _cpC7() //  [R1, R2]
         { []
         }
     {offset
       cpC7: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpCi; else goto cpCn;
       cpCi: // global
           I64[Sp - 8] = block_cpCg_info;
           _soO4::I64 = R2;
           R2 = R1;
           I64[Sp] = _soO4::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpCn: // global
           R2 = %MO_S_Shr_W64(R1, -R2);
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpC7_info" {
     block_cpC7_info:
         const _cpC7;
         const 0;
         const 30;
 },
 _cpCg() //  [R1]
         { []
         }
     {offset
       cpCg: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpCg_info" {
     block_cpCg_info:
         const _cpCg;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.716647178 UTC

[section ""data" . GHC.Float.RealFracMethods.roundFloatInt_closure" {
     GHC.Float.RealFracMethods.roundFloatInt_closure:
         const GHC.Float.RealFracMethods.roundFloatInt_info;
 },
 GHC.Float.RealFracMethods.roundFloatInt_entry() //  [R2]
         { []
         }
     {offset
       cpCR: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpD0; else goto cpD1;
       cpD0: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpD1: // global
           I64[Sp - 8] = block_cpCO_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upD5; else goto cpCP;
       upD5: // global
           call _cpCO(R1) args: 0, res: 0, upd: 0;
       cpCP: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.roundFloatInt_info" {
     GHC.Float.RealFracMethods.roundFloatInt_info:
         const GHC.Float.RealFracMethods.roundFloatInt_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cpCO() //  [R1]
         { []
         }
     {offset
       cpCO: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpD4; else goto cpD3;
       cpD4: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpD3: // global
           (_soOf::F32) = call "ccall" arg hints:  []  result hints:  [] rintFloat(F32[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_FS_Conv_W32_W64(_soOf::F32);
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpCO_info" {
     block_cpCO_info:
         const _cpCO;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.728000629 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInteger_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInteger_closure:
         const GHC.Float.RealFracMethods.properFractionDoubleInteger_info;
         const 0;
 },
 sat_soOo_entry() //  [R1]
         { []
         }
     {offset
       cpDB: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpDC; else goto cpDD;
       cpDC: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpDD: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = I64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_soOo_info" {
     sat_soOo_info:
         const sat_soOo_entry;
         const 4294967297;
         const 19;
 },
 sat_soOz_entry() //  [R1]
         { []
         }
     {offset
       cpE2: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpEg; else goto cpEh;
       cpEg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpEh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cpE7_info;
           R2 = I64[R1 + 32] - (I64[R1 + 40] << I64[R1 + 24]);
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_soOz_info" {
     sat_soOz_info:
         const sat_soOz_entry;
         const 17179869184;
         const 15;
 },
 _cpE7() //  [R1]
         { []
         }
     {offset
       cpE7: // global
           _soOm::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cpEb_info;
           R3 = _soOm::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeDoubleInteger_entry(R3,
                                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cpE7_info" {
     block_cpE7_info:
         const _cpE7;
         const 65;
         const 30;
 },
 _cpEb() //  [D1]
         { []
         }
     {offset
       cpEb: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpEl; else goto cpEk;
       cpEl: // global
           HpAlloc = 16;
           D1 = D1;
           call stg_gc_d1(D1) args: 8, res: 8, upd: 24;
       cpEk: // global
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = D1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cpEb_info" {
     block_cpEb_info:
         const _cpEb;
         const 0;
         const 30;
 },
 sat_soOu_entry() //  [R1]
         { []
         }
     {offset
       cpEq: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpEr; else goto cpEs;
       cpEr: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpEs: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_soOu_info" {
     sat_soOu_info:
         const sat_soOu_entry;
         const 4294967296;
         const 17;
 },
 sat_soOK_entry() //  [R1]
         { []
         }
     {offset
       cpEM: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpF3; else goto cpF4;
       cpF3: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpF4: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cpEU_info;
           R2 = -(I64[R1 + 32] - (I64[R1 + 40] << I64[R1 + 24]));
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_soOK_info" {
     sat_soOK_info:
         const sat_soOK_entry;
         const 17179869184;
         const 15;
 },
 _cpEU() //  [R1]
         { []
         }
     {offset
       cpEU: // global
           _soOm::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cpEY_info;
           R3 = _soOm::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeDoubleInteger_entry(R3,
                                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cpEU_info" {
     block_cpEU_info:
         const _cpEU;
         const 65;
         const 30;
 },
 _cpEY() //  [D1]
         { []
         }
     {offset
       cpEY: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpF8; else goto cpF7;
       cpF8: // global
           HpAlloc = 16;
           D1 = D1;
           call stg_gc_d1(D1) args: 8, res: 8, upd: 24;
       cpF7: // global
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = D1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cpEY_info" {
     block_cpEY_info:
         const _cpEY;
         const 0;
         const 30;
 },
 sat_soOE_entry() //  [R1]
         { []
         }
     {offset
       cpFf: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpFg; else goto cpFh;
       cpFg: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpFh: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = -I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_soOE_info" {
     sat_soOE_info:
         const sat_soOE_entry;
         const 4294967296;
         const 17;
 },
 GHC.Float.RealFracMethods.properFractionDoubleInteger_entry() //  [R2]
         { []
         }
     {offset
       cpFi: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpFj; else goto cpFk;
       cpFj: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpFk: // global
           I64[Sp - 8] = block_cpDl_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upFO; else goto cpDm;
       upFO: // global
           call _cpDl(R1) args: 0, res: 0, upd: 0;
       cpDm: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.properFractionDoubleInteger_info" {
     GHC.Float.RealFracMethods.properFractionDoubleInteger_info:
         const GHC.Float.RealFracMethods.properFractionDoubleInteger_entry;
         const 0;
         const 90194313230;
         const 4294967301;
         const SoU1_srt+8;
 },
 _cpDl() //  [R1]
         { []
         }
     {offset
       cpDl: // global
           I64[Sp - 8] = block_cpDq_info;
           D1 = F64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cpDl_info" {
     block_cpDl_info:
         const _cpDl;
         const 0;
         const 21474836510;
         const SoU1_srt+8;
 },
 _cpDq() //  [R1, R2]
         { []
         }
     {offset
       cpDq: // global
           I64[Sp - 8] = R2;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call _cpDr() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cpDq_info" {
     block_cpDq_info:
         const _cpDq;
         const 1;
         const 4294967326;
         const SoU1_srt+8;
 },
 _cpDr() //  []
         { []
         }
     {offset
       cpDr: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cpFo; else goto cpFn;
       cpFo: // global
           HpAlloc = 56;
           I64[Sp] = block_cpDr_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cpFn: // global
           _soOl::P64 = P64[Sp + 16];
           _soOm::I64 = I64[Sp + 8];
           if (%MO_S_Ge_W64(_soOm::I64, 0)) goto cpFr; else goto cpFL;
       cpFr: // global
           I64[Hp - 48] = sat_soOo_info;
           P64[Hp - 32] = _soOl::P64;
           I64[Hp - 24] = _soOm::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Float.RealFracMethods.properFractionDoubleInt2_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpFL: // global
           _soOp::I64 = -_soOm::I64;
           if (%MO_S_Le_W64(_soOp::I64, 52)) goto cpFt; else goto cpFK;
       cpFt: // global
           Hp = Hp - 56;
           I64[Sp] = block_cpDL_info;
           R3 = lvl_roLO_closure;
           R2 = _soOl::P64;
           I64[Sp + 24] = _soOp::I64;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cpFK: // global
           I64[Hp - 48] = (,)_con_info;
           P64[Hp - 40] = lvl_roLO_closure;
           P64[Hp - 32] = P64[Sp + 24];
           _cpFJ::P64 = Hp - 47;
           Hp = Hp - 32;
           R1 = _cpFJ::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpDr_info" {
     block_cpDr_info:
         const _cpDr;
         const 67;
         const 4294967326;
         const SoU1_srt+8;
 },
 _cpDL() //  [R1]
         { []
         }
     {offset
       cpDL: // global
           _soOl::P64 = P64[Sp + 16];
           if (R1 == 1) goto cpFD; else goto cpFx;
       cpFD: // global
           I64[Sp] = block_cpEv_info;
           R2 = _soOl::P64;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpFx: // global
           I64[Sp] = block_cpDP_info;
           R2 = _soOl::P64;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cpDL_info" {
     block_cpDL_info:
         const _cpDL;
         const 323;
         const 30;
 },
 _cpEv() //  [R1]
         { []
         }
     {offset
       cpEv: // global
           I64[Sp] = block_cpEz_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cpEv_info" {
     block_cpEv_info:
         const _cpEv;
         const 451;
         const 30;
 },
 _cpEz() //  [R1]
         { []
         }
     {offset
       cpEz: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cpFH; else goto cpFG;
       cpFH: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cpFG: // global
           I64[Hp - 88] = sat_soOK_info;
           I64[Hp - 72] = I64[Sp + 8];
           _soOp::I64 = I64[Sp + 24];
           I64[Hp - 64] = _soOp::I64;
           I64[Hp - 56] = R1;
           _soOC::I64 = %MO_S_Shr_W64(R1, _soOp::I64);
           I64[Hp - 48] = _soOC::I64;
           I64[Hp - 40] = sat_soOE_info;
           I64[Hp - 24] = _soOC::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpEz_info" {
     block_cpEz_info:
         const _cpEz;
         const 451;
         const 30;
 },
 _cpDP() //  [R1]
         { []
         }
     {offset
       cpDP: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cpFA; else goto cpFz;
       cpFA: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cpFz: // global
           I64[Hp - 88] = sat_soOz_info;
           I64[Hp - 72] = I64[Sp + 8];
           _soOp::I64 = I64[Sp + 24];
           I64[Hp - 64] = _soOp::I64;
           I64[Hp - 56] = R1;
           _soOt::I64 = %MO_S_Shr_W64(R1, _soOp::I64);
           I64[Hp - 48] = _soOt::I64;
           I64[Hp - 40] = sat_soOu_info;
           I64[Hp - 24] = _soOt::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpDP_info" {
     block_cpDP_info:
         const _cpDP;
         const 451;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.761450438 UTC

[section ""data" . GHC.Float.RealFracMethods.truncateDoubleInteger_closure" {
     GHC.Float.RealFracMethods.truncateDoubleInteger_closure:
         const GHC.Float.RealFracMethods.truncateDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.truncateDoubleInteger_entry() //  [R2]
         { []
         }
     {offset
       cpHf: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cpHg; else goto cpHh;
       cpHg: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.truncateDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpHh: // global
           I64[Sp - 8] = block_cpHc_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upIb; else goto cpHd;
       upIb: // global
           call _cpHc(R1) args: 0, res: 0, upd: 0;
       cpHd: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.truncateDoubleInteger_info" {
     GHC.Float.RealFracMethods.truncateDoubleInteger_info:
         const GHC.Float.RealFracMethods.truncateDoubleInteger_entry;
         const 0;
         const 158913789966;
         const 4294967301;
         const SoU1_srt+8;
 },
 _cpHc() //  [R1]
         { []
         }
     {offset
       cpHc: // global
           I64[Sp] = block_cpHk_info;
           D1 = F64[R1 + 7];
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cpHc_info" {
     block_cpHc_info:
         const _cpHc;
         const 0;
         const 21474836510;
         const SoU1_srt+8;
 },
 _cpHk() //  [R1, R2]
         { []
         }
     {offset
       cpHk: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpHt; else goto cpI5;
       cpHt: // global
           R3 = R2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       cpI5: // global
           _soOS::I64 = -R2;
           if (%MO_S_Le_W64(_soOS::I64, 52)) goto cpHE; else goto cpI4;
       cpHE: // global
           I64[Sp - 16] = block_cpHC_info;
           R3 = lvl_roLO_closure;
           R2 = R1;
           I64[Sp - 8] = _soOS::I64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cpI4: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpHk_info" {
     block_cpHk_info:
         const _cpHk;
         const 0;
         const 4294967326;
         const SoU1_srt+8;
 },
 _cpHC() //  [R1]
         { []
         }
     {offset
       cpHC: // global
           _soOP::P64 = P64[Sp + 16];
           if (R1 == 1) goto cpHY; else goto cpHL;
       cpHY: // global
           I64[Sp] = block_cpHS_info;
           R2 = _soOP::P64;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpHL: // global
           I64[Sp] = block_cpHI_info;
           R2 = _soOP::P64;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cpHC_info" {
     block_cpHC_info:
         const _cpHC;
         const 66;
         const 30;
 },
 _cpHS() //  [R1]
         { []
         }
     {offset
       cpHS: // global
           I64[Sp] = block_cpHW_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cpHS_info" {
     block_cpHS_info:
         const _cpHS;
         const 194;
         const 30;
 },
 _cpHW() //  [R1]
         { []
         }
     {offset
       cpHW: // global
           R2 = -%MO_S_Shr_W64(R1, I64[Sp + 8]);
           Sp = Sp + 24;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpHW_info" {
     block_cpHW_info:
         const _cpHW;
         const 194;
         const 30;
 },
 _cpHI() //  [R1]
         { []
         }
     {offset
       cpHI: // global
           R2 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           Sp = Sp + 24;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpHI_info" {
     block_cpHI_info:
         const _cpHI;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.775005465 UTC

[section ""data" . sat_soP1_closure" {
     sat_soP1_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.776741419 UTC

[section ""data" . sat_soP2_closure" {
     sat_soP2_closure:
         const :_con_info;
         const sat_soP1_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.77920703 UTC

[section ""data" . lvl1_roLP_closure" {
     lvl1_roLP_closure:
         const lvl1_roLP_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_roLP_entry() //  [R1]
         { []
         }
     {offset
       cpIL: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpIM; else goto cpIN;
       cpIM: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpIN: // global
           (_cpII::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cpII::I64 == 0) goto cpIK; else goto cpIJ;
       cpIK: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cpIJ: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cpII::I64;
           R3 = sat_soP2_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl1_roLP_info" {
     lvl1_roLP_info:
         const lvl1_roLP_entry;
         const 0;
         const 4294967317;
         const SoU1_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.784367675 UTC

[section ""data" . GHC.Float.RealFracMethods.floorFloatInteger_closure" {
     GHC.Float.RealFracMethods.floorFloatInteger_closure:
         const GHC.Float.RealFracMethods.floorFloatInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.floorFloatInteger_entry() //  [R2]
         { []
         }
     {offset
       cpJ2: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpJ3; else goto cpJ4;
       cpJ3: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpJ4: // global
           I64[Sp - 8] = block_cpIZ_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upJF; else goto cpJ0;
       upJF: // global
           call _cpIZ(R1) args: 0, res: 0, upd: 0;
       cpJ0: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.floorFloatInteger_info" {
     GHC.Float.RealFracMethods.floorFloatInteger_info:
         const GHC.Float.RealFracMethods.floorFloatInteger_entry;
         const 0;
         const 1653562408974;
         const 4294967301;
         const SoU1_srt+8;
 },
 _cpIZ() //  [R1]
         { []
         }
     {offset
       cpIZ: // global
           I64[Sp] = block_cpJ7_info;
           F1 = F32[R1 + 7];
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cpIZ_info" {
     block_cpIZ_info:
         const _cpIZ;
         const 0;
         const 1103806595102;
         const SoU1_srt+8;
 },
 _cpJ7() //  [R1, R2]
         { []
         }
     {offset
       cpJ7: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpJi; else goto cpJD;
       cpJi: // global
           I64[Sp - 8] = block_cpJg_info;
           _soP8::I64 = R2;
           R2 = R1;
           I64[Sp] = _soP8::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpJD: // global
           _soPb::I64 = -R2;
           if (%MO_S_Le_W64(_soPb::I64, 23)) goto cpJu; else goto cpJC;
       cpJu: // global
           R2 = %MO_S_Shr_W64(R1, _soPb::I64);
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       cpJC: // global
           if (%MO_S_Ge_W64(R1, 0)) goto cpJA; else goto cpJB;
       cpJA: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cpJB: // global
           R1 = lvl1_roLP_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpJ7_info" {
     block_cpJ7_info:
         const _cpJ7;
         const 0;
         const 1103806595102;
         const SoU1_srt+8;
 },
 _cpJg() //  [R1]
         { []
         }
     {offset
       cpJg: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpJg_info" {
     block_cpJg_info:
         const _cpJg;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.792331857 UTC

[section ""data" . sat_soPf_closure" {
     sat_soPf_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.794192163 UTC

[section ""data" . sat_soPg_closure" {
     sat_soPg_closure:
         const :_con_info;
         const sat_soPf_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.797143607 UTC

[section ""data" . lvl2_roLQ_closure" {
     lvl2_roLQ_closure:
         const lvl2_roLQ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_roLQ_entry() //  [R1]
         { []
         }
     {offset
       cpK6: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpK7; else goto cpK8;
       cpK7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpK8: // global
           (_cpK3::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cpK3::I64 == 0) goto cpK5; else goto cpK4;
       cpK5: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cpK4: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cpK3::I64;
           R3 = sat_soPg_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl2_roLQ_info" {
     lvl2_roLQ_info:
         const lvl2_roLQ_entry;
         const 0;
         const 4294967317;
         const SoU1_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.802942554 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingFloatInteger_closure" {
     GHC.Float.RealFracMethods.ceilingFloatInteger_closure:
         const GHC.Float.RealFracMethods.ceilingFloatInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.ceilingFloatInteger_entry() //  [R2]
         { []
         }
     {offset
       cpKn: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpKo; else goto cpKp;
       cpKo: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpKp: // global
           I64[Sp - 8] = block_cpKk_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upLf; else goto cpKl;
       upLf: // global
           call _cpKk(R1) args: 0, res: 0, upd: 0;
       cpKl: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.ceilingFloatInteger_info" {
     GHC.Float.RealFracMethods.ceilingFloatInteger_info:
         const GHC.Float.RealFracMethods.ceilingFloatInteger_entry;
         const 0;
         const 13198434500622;
         const 4294967301;
         const SoU1_srt+8;
 },
 _cpKk() //  [R1]
         { []
         }
     {offset
       cpKk: // global
           I64[Sp] = block_cpKw_info;
           F1 = %MO_F_Neg_W32(F32[R1 + 7]);
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cpKk_info" {
     block_cpKk_info:
         const _cpKk;
         const 0;
         const 8800387989534;
         const SoU1_srt+8;
 },
 _cpKw() //  [R1, R2]
         { []
         }
     {offset
       cpKw: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpKK; else goto cpLe;
       cpKK: // global
           I64[Sp - 8] = block_cpKE_info;
           _soPn::I64 = R2;
           R2 = R1;
           I64[Sp] = _soPn::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpLe: // global
           _soPr::I64 = -R2;
           if (%MO_S_Le_W64(_soPr::I64, 23)) goto cpL2; else goto cpLd;
       cpL2: // global
           I64[Sp] = block_cpL0_info;
           R2 = %MO_S_Shr_W64(R1, _soPr::I64);
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpLd: // global
           if (%MO_S_Ge_W64(R1, 0)) goto cpLb; else goto cpLc;
       cpLb: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cpLc: // global
           R1 = lvl2_roLQ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpKw_info" {
     block_cpKw_info:
         const _cpKw;
         const 0;
         const 8800387989534;
         const SoU1_srt+8;
 },
 _cpKE() //  [R1]
         { []
         }
     {offset
       cpKE: // global
           _soPn::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cpKI_info;
           R3 = _soPn::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cpKE_info" {
     block_cpKE_info:
         const _cpKE;
         const 65;
         const 30;
 },
 _cpKI() //  [R1]
         { []
         }
     {offset
       cpKI: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpKI_info" {
     block_cpKI_info:
         const _cpKI;
         const 0;
         const 30;
 },
 _cpL0() //  [R1]
         { []
         }
     {offset
       cpL0: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpL0_info" {
     block_cpL0_info:
         const _cpL0;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.815663447 UTC

[section ""data" . GHC.Float.RealFracMethods.floorDoubleInteger_closure" {
     GHC.Float.RealFracMethods.floorDoubleInteger_closure:
         const GHC.Float.RealFracMethods.floorDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.floorDoubleInteger_entry() //  [R2]
         { []
         }
     {offset
       cpLN: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpLO; else goto cpLP;
       cpLO: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpLP: // global
           I64[Sp - 8] = block_cpLK_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upMw; else goto cpLL;
       upMw: // global
           call _cpLK(R1) args: 0, res: 0, upd: 0;
       cpLL: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.floorDoubleInteger_info" {
     GHC.Float.RealFracMethods.floorDoubleInteger_info:
         const GHC.Float.RealFracMethods.floorDoubleInteger_entry;
         const 0;
         const 18713172508686;
         const 4294967301;
         const SoU1_srt+8;
 },
 _cpLK() //  [R1]
         { []
         }
     {offset
       cpLK: // global
           I64[Sp] = block_cpLS_info;
           D1 = F64[R1 + 7];
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cpLK_info" {
     block_cpLK_info:
         const _cpLK;
         const 0;
         const 1120986464286;
         const SoU1_srt+8;
 },
 _cpLS() //  [R1, R2]
         { []
         }
     {offset
       cpLS: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpM1; else goto cpMu;
       cpM1: // global
           R3 = R2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       cpMu: // global
           _soPD::I64 = -R2;
           if (%MO_S_Le_W64(_soPD::I64, 52)) goto cpMc; else goto cpMj;
       cpMc: // global
           I64[Sp - 8] = block_cpMa_info;
           R2 = R1;
           I64[Sp] = _soPD::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
       cpMj: // global
           I64[Sp] = block_cpMi_info;
           R3 = lvl_roLO_closure;
           R2 = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cpLS_info" {
     block_cpLS_info:
         const _cpLS;
         const 0;
         const 1103806595102;
         const SoU1_srt+8;
 },
 _cpMa() //  [R1]
         { []
         }
     {offset
       cpMa: // global
           R2 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpMa_info" {
     block_cpMa_info:
         const _cpMa;
         const 65;
         const 30;
 },
 _cpMi() //  [R1]
         { []
         }
     {offset
       cpMi: // global
           if (R1 == 1) goto cpMt; else goto cpMp;
       cpMt: // global
           R1 = lvl1_roLP_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cpMp: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpMi_info" {
     block_cpMi_info:
         const _cpMi;
         const 0;
         const 1103806595102;
         const SoU1_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.827937997 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingDoubleInteger_closure" {
     GHC.Float.RealFracMethods.ceilingDoubleInteger_closure:
         const GHC.Float.RealFracMethods.ceilingDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.ceilingDoubleInteger_entry() //  [R2]
         { []
         }
     {offset
       cpMZ: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpN0; else goto cpN1;
       cpN0: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpN1: // global
           I64[Sp - 8] = block_cpMW_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upNX; else goto cpMX;
       upNX: // global
           call _cpMW(R1) args: 0, res: 0, upd: 0;
       cpMX: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.ceilingDoubleInteger_info" {
     GHC.Float.RealFracMethods.ceilingDoubleInteger_info:
         const GHC.Float.RealFracMethods.ceilingDoubleInteger_entry;
         const 0;
         const 44001939947534;
         const 4294967301;
         const SoU1_srt+8;
 },
 _cpMW() //  [R1]
         { []
         }
     {offset
       cpMW: // global
           I64[Sp] = block_cpN8_info;
           D1 = %MO_F_Neg_W64(F64[R1 + 7]);
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cpMW_info" {
     block_cpMW_info:
         const _cpMW;
         const 0;
         const 8817567858718;
         const SoU1_srt+8;
 },
 _cpN8() //  [R1, R2]
         { []
         }
     {offset
       cpN8: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpNi; else goto cpNW;
       cpNi: // global
           I64[Sp] = block_cpNg_info;
           R3 = R2;
           R2 = R1;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       cpNW: // global
           _soPR::I64 = -R2;
           if (%MO_S_Le_W64(_soPR::I64, 52)) goto cpND; else goto cpNL;
       cpND: // global
           I64[Sp - 8] = block_cpNu_info;
           R2 = R1;
           I64[Sp] = _soPR::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
       cpNL: // global
           I64[Sp] = block_cpNK_info;
           R3 = lvl_roLO_closure;
           R2 = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cpN8_info" {
     block_cpN8_info:
         const _cpN8;
         const 0;
         const 8800387989534;
         const SoU1_srt+8;
 },
 _cpNg() //  [R1]
         { []
         }
     {offset
       cpNg: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpNg_info" {
     block_cpNg_info:
         const _cpNg;
         const 0;
         const 30;
 },
 _cpNu() //  [R1]
         { []
         }
     {offset
       cpNu: // global
           _soPU::I64 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           I64[Sp + 8] = block_cpNB_info;
           R2 = _soPU::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cpNu_info" {
     block_cpNu_info:
         const _cpNu;
         const 65;
         const 30;
 },
 _cpNB() //  [R1]
         { []
         }
     {offset
       cpNB: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpNB_info" {
     block_cpNB_info:
         const _cpNB;
         const 0;
         const 30;
 },
 _cpNK() //  [R1]
         { []
         }
     {offset
       cpNK: // global
           if (R1 == 1) goto cpNV; else goto cpNR;
       cpNV: // global
           R1 = lvl2_roLQ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cpNR: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpNK_info" {
     block_cpNK_info:
         const _cpNK;
         const 0;
         const 8800387989534;
         const SoU1_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:02.840002971 UTC

[section ""relreadonly" . SoU1_srt" {
     SoU1_srt:
         const GHC.Float.RealFracMethods.properFractionFloatInteger_closure;
         const lvl_roLO_closure;
         const GHC.Float.RealFracMethods.truncateFloatInteger_closure;
         const GHC.Integer.Type.decodeDoubleInteger_closure;
         const GHC.Float.RealFracMethods.roundDoubleInteger_closure;
         const GHC.Float.RealFracMethods.properFractionDoubleInteger_closure;
         const GHC.Float.RealFracMethods.truncateDoubleInteger_closure;
         const sat_soP2_closure;
         const GHC.Float.RealFracMethods.floorFloatInteger_closure;
         const lvl1_roLP_closure;
         const sat_soPg_closure;
         const GHC.Float.RealFracMethods.ceilingFloatInteger_closure;
         const lvl2_roLQ_closure;
         const GHC.Float.RealFracMethods.floorDoubleInteger_closure;
         const GHC.Float.RealFracMethods.ceilingDoubleInteger_closure;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.625332917 UTC

[]


==================== Raw Cmm ====================
2018-03-16 15:55:03.62680604 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt3_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt3_closure:
         const GHC.Types.I#_con_info;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.628457644 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInt2_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInt2_closure:
         const GHC.Types.F#_con_info;
         const 0.0 :: W32;
         const 0 :: W32;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.63034697 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInt1_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInt1_closure:
         const (,)_con_info;
         const GHC.Float.RealFracMethods.properFractionDoubleInt3_closure+1;
         const GHC.Float.RealFracMethods.properFractionFloatInt2_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.633480309 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInt_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInt_closure:
         const GHC.Float.RealFracMethods.properFractionFloatInt_info;
 },
 GHC.Float.RealFracMethods.properFractionFloatInt_entry() //  [R2]
         { []
         }
     {offset
       cpSH: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpSI; else goto cpSJ;
       cpSI: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpSJ: // global
           I64[Sp - 8] = block_cpSE_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upT7; else goto cpSF;
       upT7: // global
           call _cpSE(R1) args: 0, res: 0, upd: 0;
       cpSF: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.properFractionFloatInt_info" {
     GHC.Float.RealFracMethods.properFractionFloatInt_info:
         const GHC.Float.RealFracMethods.properFractionFloatInt_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cpSE() //  [R1]
         { []
         }
     {offset
       cpSE: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cpSO; else goto cpSN;
       cpSO: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpSN: // global
           _spOu::F32 = F32[R1 + 7];
           if (%MO_F_Eq_W32(_spOu::F32,
                            0.0 :: W32)) goto cpT6; else goto cpT5;
       cpT6: // global
           Hp = Hp - 56;
           R1 = GHC.Float.RealFracMethods.properFractionFloatInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpT5: // global
           I64[Hp - 48] = GHC.Types.F#_con_info;
           _spOw::I64 = %MO_FS_Conv_W32_W64(_spOu::F32);
           F32[Hp - 40] = %MO_F_Sub_W32(_spOu::F32,
                                        %MO_SF_Conv_W64_W32(_spOw::I64));
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _spOw::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpSE_info" {
     block_cpSE_info:
         const _cpSE;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.640060634 UTC

[section ""data" . GHC.Float.RealFracMethods.floorFloatInt_closure" {
     GHC.Float.RealFracMethods.floorFloatInt_closure:
         const GHC.Float.RealFracMethods.floorFloatInt_info;
 },
 GHC.Float.RealFracMethods.floorFloatInt_entry() //  [R2]
         { []
         }
     {offset
       cpTB: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpTC; else goto cpTD;
       cpTC: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpTD: // global
           I64[Sp - 8] = block_cpTy_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upU1; else goto cpTz;
       upU1: // global
           call _cpTy(R1) args: 0, res: 0, upd: 0;
       cpTz: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.floorFloatInt_info" {
     GHC.Float.RealFracMethods.floorFloatInt_info:
         const GHC.Float.RealFracMethods.floorFloatInt_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cpTy() //  [R1]
         { []
         }
     {offset
       cpTy: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpTI; else goto cpTH;
       cpTI: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpTH: // global
           _spOD::F32 = F32[R1 + 7];
           _spOE::I64 = %MO_FS_Conv_W32_W64(_spOD::F32);
           if (%MO_F_Lt_W32(_spOD::F32,
                            %MO_SF_Conv_W64_W32(_spOE::I64))) goto cpU0; else goto cpTU;
       cpU0: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _spOE::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpTU: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _spOE::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpTy_info" {
     block_cpTy_info:
         const _cpTy;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.646474516 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingFloatInt_closure" {
     GHC.Float.RealFracMethods.ceilingFloatInt_closure:
         const GHC.Float.RealFracMethods.ceilingFloatInt_info;
 },
 GHC.Float.RealFracMethods.ceilingFloatInt_entry() //  [R2]
         { []
         }
     {offset
       cpUq: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cpUr; else goto cpUs;
       cpUr: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpUs: // global
           I64[Sp - 8] = block_cpUn_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upUQ; else goto cpUo;
       upUQ: // global
           call _cpUn(R1) args: 0, res: 0, upd: 0;
       cpUo: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.ceilingFloatInt_info" {
     GHC.Float.RealFracMethods.ceilingFloatInt_info:
         const GHC.Float.RealFracMethods.ceilingFloatInt_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cpUn() //  [R1]
         { []
         }
     {offset
       cpUn: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpUx; else goto cpUw;
       cpUx: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cpUw: // global
           _spOK::F32 = F32[R1 + 7];
           _spOL::I64 = %MO_FS_Conv_W32_W64(_spOK::F32);
           if (%MO_F_Lt_W32(%MO_SF_Conv_W64_W32(_spOL::I64),
                            _spOK::F32)) goto cpUP; else goto cpUJ;
       cpUP: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _spOL::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpUJ: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _spOL::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpUn_info" {
     block_cpUn_info:
         const _cpUn;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.652605395 UTC

[section ""data" . lvl_roLO_closure" {
     lvl_roLO_closure:
         const lvl_roLO_info;
         const 0;
         const 0;
         const 0;
 },
 lvl_roLO_entry() //  [R1]
         { []
         }
     {offset
       cpVe: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpVf; else goto cpVg;
       cpVf: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpVg: // global
           (_cpVb::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cpVb::I64 == 0) goto cpVd; else goto cpVc;
       cpVd: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cpVc: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cpVb::I64;
           R3 = GHC.Types.[]_closure+1;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl_roLO_info" {
     lvl_roLO_info:
         const lvl_roLO_entry;
         const 0;
         const 21;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.661558716 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionFloatInteger_closure" {
     GHC.Float.RealFracMethods.properFractionFloatInteger_closure:
         const GHC.Float.RealFracMethods.properFractionFloatInteger_info;
         const 0;
 },
 sat_spOX_entry() //  [R1]
         { []
         }
     {offset
       cpVN: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpVO; else goto cpVP;
       cpVO: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpVP: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cpVL_info;
           R2 = I64[R1 + 16];
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_spOX_info" {
     sat_spOX_info:
         const sat_spOX_entry;
         const 8589934592;
         const 20;
 },
 _cpVL() //  [R1]
         { []
         }
     {offset
       cpVL: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cpVL_info" {
     block_cpVL_info:
         const _cpVL;
         const 65;
         const 30;
 },
 sat_spP7_entry() //  [R1]
         { []
         }
     {offset
       cpWc: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpWq; else goto cpWr;
       cpWq: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpWr: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cpWh_info;
           R2 = I64[R1 + 16] - (I64[R1 + 40] << I64[R1 + 32]);
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_spP7_info" {
     sat_spP7_info:
         const sat_spP7_entry;
         const 17179869184;
         const 15;
 },
 _cpWh() //  [R1]
         { []
         }
     {offset
       cpWh: // global
           _spOU::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cpWl_info;
           R3 = _spOU::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeFloatInteger_entry(R3,
                                                          R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cpWh_info" {
     block_cpWh_info:
         const _cpWh;
         const 65;
         const 30;
 },
 _cpWl() //  [F1]
         { []
         }
     {offset
       cpWl: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpWv; else goto cpWu;
       cpWv: // global
           HpAlloc = 16;
           F1 = F1;
           call stg_gc_f1(F1) args: 8, res: 8, upd: 24;
       cpWu: // global
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = F1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cpWl_info" {
     block_cpWl_info:
         const _cpWl;
         const 0;
         const 30;
 },
 sat_spP2_entry() //  [R1]
         { []
         }
     {offset
       cpWA: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpWB; else goto cpWC;
       cpWB: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpWC: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_spP2_info" {
     sat_spP2_info:
         const sat_spP2_entry;
         const 4294967296;
         const 17;
 },
 sat_spPg_entry() //  [R1]
         { []
         }
     {offset
       cpWT: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpX7; else goto cpX8;
       cpX7: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpX8: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cpWY_info;
           R2 = I64[R1 + 16] - (I64[R1 + 40] << I64[R1 + 32]);
           I64[Sp - 24] = I64[R1 + 24];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_spPg_info" {
     sat_spPg_info:
         const sat_spPg_entry;
         const 17179869184;
         const 15;
 },
 _cpWY() //  [R1]
         { []
         }
     {offset
       cpWY: // global
           _spOU::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cpX2_info;
           R3 = _spOU::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeFloatInteger_entry(R3,
                                                          R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cpWY_info" {
     block_cpWY_info:
         const _cpWY;
         const 65;
         const 30;
 },
 _cpX2() //  [F1]
         { []
         }
     {offset
       cpX2: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cpXc; else goto cpXb;
       cpXc: // global
           HpAlloc = 16;
           F1 = F1;
           call stg_gc_f1(F1) args: 8, res: 8, upd: 24;
       cpXb: // global
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = F1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cpX2_info" {
     block_cpX2_info:
         const _cpX2;
         const 0;
         const 30;
 },
 sat_spPb_entry() //  [R1]
         { []
         }
     {offset
       cpXh: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpXi; else goto cpXj;
       cpXi: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cpXj: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_spPb_info" {
     sat_spPb_info:
         const sat_spPb_entry;
         const 4294967296;
         const 17;
 },
 GHC.Float.RealFracMethods.properFractionFloatInteger_entry() //  [R2]
         { []
         }
     {offset
       cpXk: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cpXl; else goto cpXm;
       cpXl: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpXm: // global
           I64[Sp - 8] = block_cpVv_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto upXH; else goto cpVw;
       upXH: // global
           call _cpVv(R1) args: 0, res: 0, upd: 0;
       cpVw: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.properFractionFloatInteger_info" {
     GHC.Float.RealFracMethods.properFractionFloatInteger_info:
         const GHC.Float.RealFracMethods.properFractionFloatInteger_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const SpXI_srt;
 },
 _cpVv() //  [R1]
         { []
         }
     {offset
       cpVv: // global
           I64[Sp - 8] = block_cpVA_info;
           F1 = F32[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cpVv_info" {
     block_cpVv_info:
         const _cpVv;
         const 0;
         const 4294967326;
         const SpXI_srt+8;
 },
 _cpVA() //  [R1, R2]
         { []
         }
     {offset
       cpVA: // global
           I64[Sp - 8] = R2;
           I64[Sp] = R1;
           Sp = Sp - 16;
           call _cpVB() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cpVA_info" {
     block_cpVA_info:
         const _cpVA;
         const 1;
         const 4294967326;
         const SpXI_srt+8;
 },
 _cpVB() //  []
         { []
         }
     {offset
       cpVB: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cpXq; else goto cpXp;
       cpXq: // global
           HpAlloc = 96;
           I64[Sp] = block_cpVB_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cpXp: // global
           _spOT::I64 = I64[Sp + 16];
           _spOU::I64 = I64[Sp + 8];
           if (%MO_S_Ge_W64(_spOU::I64, 0)) goto cpXt; else goto cpXE;
       cpXt: // global
           I64[Hp - 88] = sat_spOX_info;
           I64[Hp - 72] = _spOT::I64;
           I64[Hp - 64] = _spOU::I64;
           I64[Hp - 56] = (,)_con_info;
           P64[Hp - 48] = Hp - 88;
           P64[Hp - 40] = GHC.Float.RealFracMethods.properFractionFloatInt2_closure+1;
           _cpXr::P64 = Hp - 55;
           Hp = Hp - 40;
           R1 = _cpXr::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpXE: // global
           _spOY::I64 = -_spOU::I64;
           if (%MO_S_Le_W64(_spOY::I64, 23)) goto cpXA; else goto cpXD;
       cpXA: // global
           if (%MO_S_Ge_W64(_spOT::I64, 0)) goto cpXw; else goto cpXy;
       cpXw: // global
           I64[Hp - 88] = sat_spP7_info;
           I64[Hp - 72] = _spOT::I64;
           I64[Hp - 64] = _spOU::I64;
           I64[Hp - 56] = _spOY::I64;
           _spP1::I64 = _spOT::I64 >> _spOY::I64;
           I64[Hp - 48] = _spP1::I64;
           I64[Hp - 40] = sat_spP2_info;
           I64[Hp - 24] = _spP1::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpXy: // global
           I64[Hp - 88] = sat_spPg_info;
           I64[Hp - 72] = _spOT::I64;
           I64[Hp - 64] = _spOU::I64;
           I64[Hp - 56] = _spOY::I64;
           _spP8::I64 = -%MO_S_Shr_W64(-_spOT::I64, _spOY::I64);
           I64[Hp - 48] = _spP8::I64;
           I64[Hp - 40] = sat_spPb_info;
           I64[Hp - 24] = _spP8::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cpXD: // global
           I64[Hp - 88] = (,)_con_info;
           P64[Hp - 80] = lvl_roLO_closure;
           P64[Hp - 72] = P64[Sp + 24];
           _cpXC::P64 = Hp - 87;
           Hp = Hp - 72;
           R1 = _cpXC::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpVB_info" {
     block_cpVB_info:
         const _cpVB;
         const 195;
         const 4294967326;
         const SpXI_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.687263438 UTC

[section ""data" . GHC.Float.RealFracMethods.truncateFloatInteger_closure" {
     GHC.Float.RealFracMethods.truncateFloatInteger_closure:
         const GHC.Float.RealFracMethods.truncateFloatInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.truncateFloatInteger_entry() //  [R2]
         { []
         }
     {offset
       cpZp: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cpZq; else goto cpZr;
       cpZq: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.truncateFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cpZr: // global
           I64[Sp - 8] = block_cpZm_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq0a; else goto cpZn;
       uq0a: // global
           call _cpZm(R1) args: 0, res: 0, upd: 0;
       cpZn: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.truncateFloatInteger_info" {
     GHC.Float.RealFracMethods.truncateFloatInteger_info:
         const GHC.Float.RealFracMethods.truncateFloatInteger_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const SpXI_srt+8;
 },
 _cpZm() //  [R1]
         { []
         }
     {offset
       cpZm: // global
           I64[Sp] = block_cpZu_info;
           F1 = F32[R1 + 7];
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cpZm_info" {
     block_cpZm_info:
         const _cpZm;
         const 0;
         const 4294967326;
         const SpXI_srt+8;
 },
 _cpZu() //  [R1, R2]
         { []
         }
     {offset
       cpZu: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cpZF; else goto cpZZ;
       cpZF: // global
           I64[Sp - 8] = block_cpZD_info;
           _spPm::I64 = R2;
           R2 = R1;
           I64[Sp] = _spPm::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cpZZ: // global
           _spPp::I64 = -R2;
           if (%MO_S_Le_W64(_spPp::I64, 23)) goto cpZX; else goto cpZY;
       cpZX: // global
           if (%MO_S_Ge_W64(R1, 0)) goto cpZU; else goto cpZV;
       cpZU: // global
           R2 = R1 >> _spPp::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       cpZV: // global
           R2 = -%MO_S_Shr_W64(-R1, _spPp::I64);
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       cpZY: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpZu_info" {
     block_cpZu_info:
         const _cpZu;
         const 0;
         const 4294967326;
         const SpXI_srt+8;
 },
 _cpZD() //  [R1]
         { []
         }
     {offset
       cpZD: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cpZD_info" {
     block_cpZD_info:
         const _cpZD;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.695377898 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt2_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt2_closure:
         const GHC.Types.D#_con_info;
         const 0.0 :: W64;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.697091661 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt1_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt1_closure:
         const (,)_con_info;
         const GHC.Float.RealFracMethods.properFractionDoubleInt3_closure+1;
         const GHC.Float.RealFracMethods.properFractionDoubleInt2_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.69999373 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInt_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInt_closure:
         const GHC.Float.RealFracMethods.properFractionDoubleInt_info;
 },
 GHC.Float.RealFracMethods.properFractionDoubleInt_entry() //  [R2]
         { []
         }
     {offset
       cq0F: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cq0G; else goto cq0H;
       cq0G: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq0H: // global
           I64[Sp - 8] = block_cq0C_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq15; else goto cq0D;
       uq15: // global
           call _cq0C(R1) args: 0, res: 0, upd: 0;
       cq0D: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.properFractionDoubleInt_info" {
     GHC.Float.RealFracMethods.properFractionDoubleInt_info:
         const GHC.Float.RealFracMethods.properFractionDoubleInt_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cq0C() //  [R1]
         { []
         }
     {offset
       cq0C: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cq0M; else goto cq0L;
       cq0M: // global
           HpAlloc = 56;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cq0L: // global
           _spPy::F64 = F64[R1 + 7];
           if (%MO_F_Eq_W64(_spPy::F64,
                            0.0 :: W64)) goto cq14; else goto cq13;
       cq14: // global
           Hp = Hp - 56;
           R1 = GHC.Float.RealFracMethods.properFractionDoubleInt1_closure+1;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cq13: // global
           I64[Hp - 48] = GHC.Types.D#_con_info;
           _spPA::I64 = %MO_FS_Conv_W64_W64(_spPy::F64);
           F64[Hp - 40] = %MO_F_Sub_W64(_spPy::F64,
                                        %MO_SF_Conv_W64_W64(_spPA::I64));
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _spPA::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 47;
           R1 = Hp - 15;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cq0C_info" {
     block_cq0C_info:
         const _cq0C;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.706477611 UTC

[section ""data" . GHC.Float.RealFracMethods.floorDoubleInt_closure" {
     GHC.Float.RealFracMethods.floorDoubleInt_closure:
         const GHC.Float.RealFracMethods.floorDoubleInt_info;
 },
 GHC.Float.RealFracMethods.floorDoubleInt_entry() //  [R2]
         { []
         }
     {offset
       cq1z: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cq1A; else goto cq1B;
       cq1A: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq1B: // global
           I64[Sp - 8] = block_cq1w_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq1Z; else goto cq1x;
       uq1Z: // global
           call _cq1w(R1) args: 0, res: 0, upd: 0;
       cq1x: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.floorDoubleInt_info" {
     GHC.Float.RealFracMethods.floorDoubleInt_info:
         const GHC.Float.RealFracMethods.floorDoubleInt_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cq1w() //  [R1]
         { []
         }
     {offset
       cq1w: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cq1G; else goto cq1F;
       cq1G: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cq1F: // global
           _spPH::F64 = F64[R1 + 7];
           _spPI::I64 = %MO_FS_Conv_W64_W64(_spPH::F64);
           if (%MO_F_Lt_W64(_spPH::F64,
                            %MO_SF_Conv_W64_W64(_spPI::I64))) goto cq1Y; else goto cq1S;
       cq1Y: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _spPI::I64 - 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cq1S: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _spPI::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cq1w_info" {
     block_cq1w_info:
         const _cq1w;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.712424593 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingDoubleInt_closure" {
     GHC.Float.RealFracMethods.ceilingDoubleInt_closure:
         const GHC.Float.RealFracMethods.ceilingDoubleInt_info;
 },
 GHC.Float.RealFracMethods.ceilingDoubleInt_entry() //  [R2]
         { []
         }
     {offset
       cq2o: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cq2p; else goto cq2q;
       cq2p: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq2q: // global
           I64[Sp - 8] = block_cq2l_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq2O; else goto cq2m;
       uq2O: // global
           call _cq2l(R1) args: 0, res: 0, upd: 0;
       cq2m: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.ceilingDoubleInt_info" {
     GHC.Float.RealFracMethods.ceilingDoubleInt_info:
         const GHC.Float.RealFracMethods.ceilingDoubleInt_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cq2l() //  [R1]
         { []
         }
     {offset
       cq2l: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cq2v; else goto cq2u;
       cq2v: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cq2u: // global
           _spPO::F64 = F64[R1 + 7];
           _spPP::I64 = %MO_FS_Conv_W64_W64(_spPO::F64);
           if (%MO_F_Lt_W64(%MO_SF_Conv_W64_W64(_spPP::I64),
                            _spPO::F64)) goto cq2N; else goto cq2H;
       cq2N: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _spPP::I64 + 1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cq2H: // global
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _spPP::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cq2l_info" {
     block_cq2l_info:
         const _cq2l;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.718348086 UTC

[section ""data" . GHC.Float.RealFracMethods.double2Int_closure" {
     GHC.Float.RealFracMethods.double2Int_closure:
         const GHC.Float.RealFracMethods.double2Int_info;
 },
 GHC.Float.RealFracMethods.double2Int_entry() //  [R2]
         { []
         }
     {offset
       cq3d: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cq3k; else goto cq3l;
       cq3k: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.double2Int_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq3l: // global
           I64[Sp - 8] = block_cq3a_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq3p; else goto cq3b;
       uq3p: // global
           call _cq3a(R1) args: 0, res: 0, upd: 0;
       cq3b: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.double2Int_info" {
     GHC.Float.RealFracMethods.double2Int_info:
         const GHC.Float.RealFracMethods.double2Int_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cq3a() //  [R1]
         { []
         }
     {offset
       cq3a: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cq3o; else goto cq3n;
       cq3o: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cq3n: // global
           _spPW::I64 = %MO_FS_Conv_W64_W64(F64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _spPW::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cq3a_info" {
     block_cq3a_info:
         const _cq3a;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.724102606 UTC

[section ""data" . GHC.Float.RealFracMethods.int2Double_closure" {
     GHC.Float.RealFracMethods.int2Double_closure:
         const GHC.Float.RealFracMethods.int2Double_info;
 },
 GHC.Float.RealFracMethods.int2Double_entry() //  [R2]
         { []
         }
     {offset
       cq3J: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cq3Q; else goto cq3R;
       cq3Q: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.int2Double_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq3R: // global
           I64[Sp - 8] = block_cq3G_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq3V; else goto cq3H;
       uq3V: // global
           call _cq3G(R1) args: 0, res: 0, upd: 0;
       cq3H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.int2Double_info" {
     GHC.Float.RealFracMethods.int2Double_info:
         const GHC.Float.RealFracMethods.int2Double_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cq3G() //  [R1]
         { []
         }
     {offset
       cq3G: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cq3U; else goto cq3T;
       cq3U: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cq3T: // global
           _spQ0::F64 = %MO_SF_Conv_W64_W64(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = _spQ0::F64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cq3G_info" {
     block_cq3G_info:
         const _cq3G;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.729721963 UTC

[section ""data" . GHC.Float.RealFracMethods.float2Int_closure" {
     GHC.Float.RealFracMethods.float2Int_closure:
         const GHC.Float.RealFracMethods.float2Int_info;
 },
 GHC.Float.RealFracMethods.float2Int_entry() //  [R2]
         { []
         }
     {offset
       cq4f: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cq4m; else goto cq4n;
       cq4m: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.float2Int_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq4n: // global
           I64[Sp - 8] = block_cq4c_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq4r; else goto cq4d;
       uq4r: // global
           call _cq4c(R1) args: 0, res: 0, upd: 0;
       cq4d: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.float2Int_info" {
     GHC.Float.RealFracMethods.float2Int_info:
         const GHC.Float.RealFracMethods.float2Int_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cq4c() //  [R1]
         { []
         }
     {offset
       cq4c: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cq4q; else goto cq4p;
       cq4q: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cq4p: // global
           _spQ4::I64 = %MO_FS_Conv_W32_W64(F32[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _spQ4::I64;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cq4c_info" {
     block_cq4c_info:
         const _cq4c;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.735744918 UTC

[section ""data" . GHC.Float.RealFracMethods.int2Float_closure" {
     GHC.Float.RealFracMethods.int2Float_closure:
         const GHC.Float.RealFracMethods.int2Float_info;
 },
 GHC.Float.RealFracMethods.int2Float_entry() //  [R2]
         { []
         }
     {offset
       cq4L: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cq4S; else goto cq4T;
       cq4S: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.int2Float_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq4T: // global
           I64[Sp - 8] = block_cq4I_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq4X; else goto cq4J;
       uq4X: // global
           call _cq4I(R1) args: 0, res: 0, upd: 0;
       cq4J: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.int2Float_info" {
     GHC.Float.RealFracMethods.int2Float_info:
         const GHC.Float.RealFracMethods.int2Float_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cq4I() //  [R1]
         { []
         }
     {offset
       cq4I: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cq4W; else goto cq4V;
       cq4W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cq4V: // global
           _spQ8::F32 = %MO_SF_Conv_W64_W32(I64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _spQ8::F32;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cq4I_info" {
     block_cq4I_info:
         const _cq4I;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.740927119 UTC

[section ""cstring" . GHC.Float.RealFracMethods.$trModule4_bytes" {
     GHC.Float.RealFracMethods.$trModule4_bytes:
         I8[] [98,97,115,101]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.742668652 UTC

[section ""data" . GHC.Float.RealFracMethods.$trModule3_closure" {
     GHC.Float.RealFracMethods.$trModule3_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.RealFracMethods.$trModule4_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.744272332 UTC

[section ""cstring" . GHC.Float.RealFracMethods.$trModule2_bytes" {
     GHC.Float.RealFracMethods.$trModule2_bytes:
         I8[] [71,72,67,46,70,108,111,97,116,46,82,101,97,108,70,114,97,99,77,101,116,104,111,100,115]
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.745902417 UTC

[section ""data" . GHC.Float.RealFracMethods.$trModule1_closure" {
     GHC.Float.RealFracMethods.$trModule1_closure:
         const GHC.Types.TrNameS_con_info;
         const GHC.Float.RealFracMethods.$trModule2_bytes;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.747600298 UTC

[section ""data" . GHC.Float.RealFracMethods.$trModule_closure" {
     GHC.Float.RealFracMethods.$trModule_closure:
         const GHC.Types.Module_con_info;
         const GHC.Float.RealFracMethods.$trModule3_closure+1;
         const GHC.Float.RealFracMethods.$trModule1_closure+1;
         const 3;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.750376424 UTC

[section ""data" . GHC.Float.RealFracMethods.roundDoubleInt_closure" {
     GHC.Float.RealFracMethods.roundDoubleInt_closure:
         const GHC.Float.RealFracMethods.roundDoubleInt_info;
 },
 GHC.Float.RealFracMethods.roundDoubleInt_entry() //  [R2]
         { []
         }
     {offset
       cq5m: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cq5v; else goto cq5w;
       cq5v: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundDoubleInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq5w: // global
           I64[Sp - 8] = block_cq5j_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq5A; else goto cq5k;
       uq5A: // global
           call _cq5j(R1) args: 0, res: 0, upd: 0;
       cq5k: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.roundDoubleInt_info" {
     GHC.Float.RealFracMethods.roundDoubleInt_info:
         const GHC.Float.RealFracMethods.roundDoubleInt_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cq5j() //  [R1]
         { []
         }
     {offset
       cq5j: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cq5z; else goto cq5y;
       cq5z: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cq5y: // global
           (_spQf::F64) = call "ccall" arg hints:  []  result hints:  [] rintDouble(F64[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_FS_Conv_W64_W64(_spQf::F64);
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cq5j_info" {
     block_cq5j_info:
         const _cq5j;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.758053073 UTC

[section ""data" . GHC.Float.RealFracMethods.roundDoubleInteger_closure" {
     GHC.Float.RealFracMethods.roundDoubleInteger_closure:
         const GHC.Float.RealFracMethods.roundDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.roundDoubleInteger_entry() //  [R2]
         { []
         }
     {offset
       cq5V: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cq5W; else goto cq5X;
       cq5W: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq5X: // global
           I64[Sp - 8] = block_cq5S_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq6o; else goto cq5T;
       uq6o: // global
           call _cq5S(R1) args: 0, res: 0, upd: 0;
       cq5T: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.roundDoubleInteger_info" {
     GHC.Float.RealFracMethods.roundDoubleInteger_info:
         const GHC.Float.RealFracMethods.roundDoubleInteger_entry;
         const 0;
         const 12884901902;
         const 4294967301;
         const SpXI_srt+24;
 },
 _cq5S() //  [R1]
         { []
         }
     {offset
       cq5S: // global
           (_spQn::F64) = call "ccall" arg hints:  []  result hints:  [] rintDouble(F64[R1 + 7]);
           I64[Sp] = block_cq62_info;
           D1 = _spQn::F64;
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cq5S_info" {
     block_cq5S_info:
         const _cq5S;
         const 0;
         const 4294967326;
         const SpXI_srt+24;
 },
 _cq62() //  [R1, R2]
         { []
         }
     {offset
       cq62: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cq6b; else goto cq6f;
       cq6b: // global
           R3 = R2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       cq6f: // global
           I64[Sp - 8] = block_cq6e_info;
           _spQq::I64 = R2;
           R2 = R1;
           I64[Sp] = _spQq::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cq62_info" {
     block_cq62_info:
         const _cq62;
         const 0;
         const 30;
 },
 _cq6e() //  [R1]
         { []
         }
     {offset
       cq6e: // global
           R2 = %MO_S_Shr_W64(R1, -I64[Sp + 8]);
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cq6e_info" {
     block_cq6e_info:
         const _cq6e;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.766977094 UTC

[section ""data" . GHC.Float.RealFracMethods.roundFloatInteger_closure" {
     GHC.Float.RealFracMethods.roundFloatInteger_closure:
         const GHC.Float.RealFracMethods.roundFloatInteger_info;
 },
 GHC.Float.RealFracMethods.roundFloatInteger_entry() //  [R2]
         { []
         }
     {offset
       cq6P: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cq6Q; else goto cq6R;
       cq6Q: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq6R: // global
           I64[Sp - 8] = block_cq6M_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq7i; else goto cq6N;
       uq7i: // global
           call _cq6M(R1) args: 0, res: 0, upd: 0;
       cq6N: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.roundFloatInteger_info" {
     GHC.Float.RealFracMethods.roundFloatInteger_info:
         const GHC.Float.RealFracMethods.roundFloatInteger_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cq6M() //  [R1]
         { []
         }
     {offset
       cq6M: // global
           (_spQB::F32) = call "ccall" arg hints:  []  result hints:  [] rintFloat(F32[R1 + 7]);
           I64[Sp] = block_cq6W_info;
           F1 = _spQB::F32;
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cq6M_info" {
     block_cq6M_info:
         const _cq6M;
         const 0;
         const 30;
 },
 _cq6W() //  [R1, R2]
         { []
         }
     {offset
       cq6W: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cq77; else goto cq7c;
       cq77: // global
           I64[Sp - 8] = block_cq75_info;
           _spQE::I64 = R2;
           R2 = R1;
           I64[Sp] = _spQE::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cq7c: // global
           R2 = %MO_S_Shr_W64(R1, -R2);
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cq6W_info" {
     block_cq6W_info:
         const _cq6W;
         const 0;
         const 30;
 },
 _cq75() //  [R1]
         { []
         }
     {offset
       cq75: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cq75_info" {
     block_cq75_info:
         const _cq75;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.776350827 UTC

[section ""data" . GHC.Float.RealFracMethods.roundFloatInt_closure" {
     GHC.Float.RealFracMethods.roundFloatInt_closure:
         const GHC.Float.RealFracMethods.roundFloatInt_info;
 },
 GHC.Float.RealFracMethods.roundFloatInt_entry() //  [R2]
         { []
         }
     {offset
       cq7J: // global
           if ((Sp + -8) < SpLim) (likely: False) goto cq7S; else goto cq7T;
       cq7S: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.roundFloatInt_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cq7T: // global
           I64[Sp - 8] = block_cq7G_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uq7X; else goto cq7H;
       uq7X: // global
           call _cq7G(R1) args: 0, res: 0, upd: 0;
       cq7H: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.roundFloatInt_info" {
     GHC.Float.RealFracMethods.roundFloatInt_info:
         const GHC.Float.RealFracMethods.roundFloatInt_entry;
         const 0;
         const 14;
         const 4294967301;
 },
 _cq7G() //  [R1]
         { []
         }
     {offset
       cq7G: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cq7W; else goto cq7V;
       cq7W: // global
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) args: 8, res: 8, upd: 8;
       cq7V: // global
           (_spQP::F32) = call "ccall" arg hints:  []  result hints:  [] rintFloat(F32[R1 + 7]);
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = %MO_FS_Conv_W32_W64(_spQP::F32);
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cq7G_info" {
     block_cq7G_info:
         const _cq7G;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.788570612 UTC

[section ""data" . GHC.Float.RealFracMethods.properFractionDoubleInteger_closure" {
     GHC.Float.RealFracMethods.properFractionDoubleInteger_closure:
         const GHC.Float.RealFracMethods.properFractionDoubleInteger_info;
         const 0;
 },
 sat_spQY_entry() //  [R1]
         { []
         }
     {offset
       cq8v: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cq8w; else goto cq8x;
       cq8w: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cq8x: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R3 = I64[R1 + 24];
           R2 = P64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_spQY_info" {
     sat_spQY_info:
         const sat_spQY_entry;
         const 4294967297;
         const 19;
 },
 sat_spR9_entry() //  [R1]
         { []
         }
     {offset
       cq8W: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cq9a; else goto cq9b;
       cq9a: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cq9b: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cq91_info;
           R2 = I64[R1 + 32] - (I64[R1 + 40] << I64[R1 + 24]);
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_spR9_info" {
     sat_spR9_info:
         const sat_spR9_entry;
         const 17179869184;
         const 15;
 },
 _cq91() //  [R1]
         { []
         }
     {offset
       cq91: // global
           _spQW::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cq95_info;
           R3 = _spQW::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeDoubleInteger_entry(R3,
                                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cq91_info" {
     block_cq91_info:
         const _cq91;
         const 65;
         const 30;
 },
 _cq95() //  [D1]
         { []
         }
     {offset
       cq95: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cq9f; else goto cq9e;
       cq9f: // global
           HpAlloc = 16;
           D1 = D1;
           call stg_gc_d1(D1) args: 8, res: 8, upd: 24;
       cq9e: // global
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = D1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cq95_info" {
     block_cq95_info:
         const _cq95;
         const 0;
         const 30;
 },
 sat_spR4_entry() //  [R1]
         { []
         }
     {offset
       cq9k: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cq9l; else goto cq9m;
       cq9l: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cq9m: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_spR4_info" {
     sat_spR4_info:
         const sat_spR4_entry;
         const 4294967296;
         const 17;
 },
 sat_spRk_entry() //  [R1]
         { []
         }
     {offset
       cq9G: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cq9X; else goto cq9Y;
       cq9X: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cq9Y: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           I64[Sp - 32] = block_cq9O_info;
           R2 = -(I64[R1 + 32] - (I64[R1 + 40] << I64[R1 + 24]));
           I64[Sp - 24] = I64[R1 + 16];
           Sp = Sp - 32;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . sat_spRk_info" {
     sat_spRk_info:
         const sat_spRk_entry;
         const 17179869184;
         const 15;
 },
 _cq9O() //  [R1]
         { []
         }
     {offset
       cq9O: // global
           _spQW::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cq9S_info;
           R3 = _spQW::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.encodeDoubleInteger_entry(R3,
                                                           R2) args: 8, res: 8, upd: 24;
     }
 },
 section ""relreadonly" . block_cq9O_info" {
     block_cq9O_info:
         const _cq9O;
         const 65;
         const 30;
 },
 _cq9S() //  [D1]
         { []
         }
     {offset
       cq9S: // global
           Hp = Hp + 16;
           if (Hp > HpLim) (likely: False) goto cqa2; else goto cqa1;
       cqa2: // global
           HpAlloc = 16;
           D1 = D1;
           call stg_gc_d1(D1) args: 8, res: 8, upd: 24;
       cqa1: // global
           I64[Hp - 8] = GHC.Types.D#_con_info;
           F64[Hp] = D1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (I64[P64[Sp]])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . block_cq9S_info" {
     block_cq9S_info:
         const _cq9S;
         const 0;
         const 30;
 },
 sat_spRe_entry() //  [R1]
         { []
         }
     {offset
       cqa9: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqaa; else goto cqab;
       cqaa: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqab: // global
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = R1;
           R2 = -I64[R1 + 16];
           Sp = Sp - 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . sat_spRe_info" {
     sat_spRe_info:
         const sat_spRe_entry;
         const 4294967296;
         const 17;
 },
 GHC.Float.RealFracMethods.properFractionDoubleInteger_entry() //  [R2]
         { []
         }
     {offset
       cqac: // global
           if ((Sp + -32) < SpLim) (likely: False) goto cqad; else goto cqae;
       cqad: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.properFractionDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cqae: // global
           I64[Sp - 8] = block_cq8f_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uqaI; else goto cq8g;
       uqaI: // global
           call _cq8f(R1) args: 0, res: 0, upd: 0;
       cq8g: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.properFractionDoubleInteger_info" {
     GHC.Float.RealFracMethods.properFractionDoubleInteger_info:
         const GHC.Float.RealFracMethods.properFractionDoubleInteger_entry;
         const 0;
         const 90194313230;
         const 4294967301;
         const SpXI_srt+8;
 },
 _cq8f() //  [R1]
         { []
         }
     {offset
       cq8f: // global
           I64[Sp - 8] = block_cq8k_info;
           D1 = F64[R1 + 7];
           P64[Sp] = R1;
           Sp = Sp - 8;
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cq8f_info" {
     block_cq8f_info:
         const _cq8f;
         const 0;
         const 21474836510;
         const SpXI_srt+8;
 },
 _cq8k() //  [R1, R2]
         { []
         }
     {offset
       cq8k: // global
           I64[Sp - 8] = R2;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call _cq8l() args: 0, res: 0, upd: 0;
     }
 },
 section ""relreadonly" . block_cq8k_info" {
     block_cq8k_info:
         const _cq8k;
         const 1;
         const 4294967326;
         const SpXI_srt+8;
 },
 _cq8l() //  []
         { []
         }
     {offset
       cq8l: // global
           Hp = Hp + 56;
           if (Hp > HpLim) (likely: False) goto cqai; else goto cqah;
       cqai: // global
           HpAlloc = 56;
           I64[Sp] = block_cq8l_info;
           call stg_gc_noregs() args: 8, res: 8, upd: 8;
       cqah: // global
           _spQV::P64 = P64[Sp + 16];
           _spQW::I64 = I64[Sp + 8];
           if (%MO_S_Ge_W64(_spQW::I64, 0)) goto cqal; else goto cqaF;
       cqal: // global
           I64[Hp - 48] = sat_spQY_info;
           P64[Hp - 32] = _spQV::P64;
           I64[Hp - 24] = _spQW::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 48;
           P64[Hp] = GHC.Float.RealFracMethods.properFractionDoubleInt2_closure+1;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
       cqaF: // global
           _spQZ::I64 = -_spQW::I64;
           if (%MO_S_Le_W64(_spQZ::I64, 52)) goto cqan; else goto cqaE;
       cqan: // global
           Hp = Hp - 56;
           I64[Sp] = block_cq8F_info;
           R3 = lvl_roLO_closure;
           R2 = _spQV::P64;
           I64[Sp + 24] = _spQZ::I64;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cqaE: // global
           I64[Hp - 48] = (,)_con_info;
           P64[Hp - 40] = lvl_roLO_closure;
           P64[Hp - 32] = P64[Sp + 24];
           _cqaD::P64 = Hp - 47;
           Hp = Hp - 32;
           R1 = _cqaD::P64;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cq8l_info" {
     block_cq8l_info:
         const _cq8l;
         const 67;
         const 4294967326;
         const SpXI_srt+8;
 },
 _cq8F() //  [R1]
         { []
         }
     {offset
       cq8F: // global
           _spQV::P64 = P64[Sp + 16];
           if (R1 == 1) goto cqax; else goto cqar;
       cqax: // global
           I64[Sp] = block_cq9p_info;
           R2 = _spQV::P64;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       cqar: // global
           I64[Sp] = block_cq8J_info;
           R2 = _spQV::P64;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cq8F_info" {
     block_cq8F_info:
         const _cq8F;
         const 323;
         const 30;
 },
 _cq9p() //  [R1]
         { []
         }
     {offset
       cq9p: // global
           I64[Sp] = block_cq9t_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cq9p_info" {
     block_cq9p_info:
         const _cq9p;
         const 451;
         const 30;
 },
 _cq9t() //  [R1]
         { []
         }
     {offset
       cq9t: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cqaB; else goto cqaA;
       cqaB: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cqaA: // global
           I64[Hp - 88] = sat_spRk_info;
           I64[Hp - 72] = I64[Sp + 8];
           _spQZ::I64 = I64[Sp + 24];
           I64[Hp - 64] = _spQZ::I64;
           I64[Hp - 56] = R1;
           _spRc::I64 = %MO_S_Shr_W64(R1, _spQZ::I64);
           I64[Hp - 48] = _spRc::I64;
           I64[Hp - 40] = sat_spRe_info;
           I64[Hp - 24] = _spRc::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cq9t_info" {
     block_cq9t_info:
         const _cq9t;
         const 451;
         const 30;
 },
 _cq8J() //  [R1]
         { []
         }
     {offset
       cq8J: // global
           Hp = Hp + 96;
           if (Hp > HpLim) (likely: False) goto cqau; else goto cqat;
       cqau: // global
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unbx_r1(R1) args: 8, res: 8, upd: 8;
       cqat: // global
           I64[Hp - 88] = sat_spR9_info;
           I64[Hp - 72] = I64[Sp + 8];
           _spQZ::I64 = I64[Sp + 24];
           I64[Hp - 64] = _spQZ::I64;
           I64[Hp - 56] = R1;
           _spR3::I64 = %MO_S_Shr_W64(R1, _spQZ::I64);
           I64[Hp - 48] = _spR3::I64;
           I64[Hp - 40] = sat_spR4_info;
           I64[Hp - 24] = _spR3::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 40;
           P64[Hp] = Hp - 88;
           R1 = Hp - 15;
           Sp = Sp + 32;
           call (I64[P64[Sp]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cq8J_info" {
     block_cq8J_info:
         const _cq8J;
         const 451;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.819491332 UTC

[section ""data" . GHC.Float.RealFracMethods.truncateDoubleInteger_closure" {
     GHC.Float.RealFracMethods.truncateDoubleInteger_closure:
         const GHC.Float.RealFracMethods.truncateDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.truncateDoubleInteger_entry() //  [R2]
         { []
         }
     {offset
       cqcC: // global
           if ((Sp + -24) < SpLim) (likely: False) goto cqcD; else goto cqcE;
       cqcD: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.truncateDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cqcE: // global
           I64[Sp - 8] = block_cqcz_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uqdy; else goto cqcA;
       uqdy: // global
           call _cqcz(R1) args: 0, res: 0, upd: 0;
       cqcA: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.truncateDoubleInteger_info" {
     GHC.Float.RealFracMethods.truncateDoubleInteger_info:
         const GHC.Float.RealFracMethods.truncateDoubleInteger_entry;
         const 0;
         const 158913789966;
         const 4294967301;
         const SpXI_srt+8;
 },
 _cqcz() //  [R1]
         { []
         }
     {offset
       cqcz: // global
           I64[Sp] = block_cqcH_info;
           D1 = F64[R1 + 7];
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cqcz_info" {
     block_cqcz_info:
         const _cqcz;
         const 0;
         const 21474836510;
         const SpXI_srt+8;
 },
 _cqcH() //  [R1, R2]
         { []
         }
     {offset
       cqcH: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cqcQ; else goto cqds;
       cqcQ: // global
           R3 = R2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       cqds: // global
           _spRs::I64 = -R2;
           if (%MO_S_Le_W64(_spRs::I64, 52)) goto cqd1; else goto cqdr;
       cqd1: // global
           I64[Sp - 16] = block_cqcZ_info;
           R3 = lvl_roLO_closure;
           R2 = R1;
           I64[Sp - 8] = _spRs::I64;
           P64[Sp] = R1;
           Sp = Sp - 16;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
       cqdr: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cqcH_info" {
     block_cqcH_info:
         const _cqcH;
         const 0;
         const 4294967326;
         const SpXI_srt+8;
 },
 _cqcZ() //  [R1]
         { []
         }
     {offset
       cqcZ: // global
           _spRp::P64 = P64[Sp + 16];
           if (R1 == 1) goto cqdl; else goto cqd8;
       cqdl: // global
           I64[Sp] = block_cqdf_info;
           R2 = _spRp::P64;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 8, upd: 8;
       cqd8: // global
           I64[Sp] = block_cqd5_info;
           R2 = _spRp::P64;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cqcZ_info" {
     block_cqcZ_info:
         const _cqcZ;
         const 66;
         const 30;
 },
 _cqdf() //  [R1]
         { []
         }
     {offset
       cqdf: // global
           I64[Sp] = block_cqdj_info;
           R2 = R1;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cqdf_info" {
     block_cqdf_info:
         const _cqdf;
         const 194;
         const 30;
 },
 _cqdj() //  [R1]
         { []
         }
     {offset
       cqdj: // global
           R2 = -%MO_S_Shr_W64(R1, I64[Sp + 8]);
           Sp = Sp + 24;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cqdj_info" {
     block_cqdj_info:
         const _cqdj;
         const 194;
         const 30;
 },
 _cqd5() //  [R1]
         { []
         }
     {offset
       cqd5: // global
           R2 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           Sp = Sp + 24;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cqd5_info" {
     block_cqd5_info:
         const _cqd5;
         const 194;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.83182823 UTC

[section ""data" . sat_spRB_closure" {
     sat_spRB_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.833915013 UTC

[section ""data" . sat_spRC_closure" {
     sat_spRC_closure:
         const :_con_info;
         const sat_spRB_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.836421565 UTC

[section ""data" . lvl1_roLP_closure" {
     lvl1_roLP_closure:
         const lvl1_roLP_info;
         const 0;
         const 0;
         const 0;
 },
 lvl1_roLP_entry() //  [R1]
         { []
         }
     {offset
       cqee: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqef; else goto cqeg;
       cqef: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqeg: // global
           (_cqeb::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cqeb::I64 == 0) goto cqed; else goto cqec;
       cqed: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cqec: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cqeb::I64;
           R3 = sat_spRC_closure+2;
           R2 = GHC.Types.False_closure+1;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl1_roLP_info" {
     lvl1_roLP_info:
         const lvl1_roLP_entry;
         const 0;
         const 4294967317;
         const SpXI_srt+56;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.841491234 UTC

[section ""data" . GHC.Float.RealFracMethods.floorFloatInteger_closure" {
     GHC.Float.RealFracMethods.floorFloatInteger_closure:
         const GHC.Float.RealFracMethods.floorFloatInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.floorFloatInteger_entry() //  [R2]
         { []
         }
     {offset
       cqex: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqey; else goto cqez;
       cqey: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cqez: // global
           I64[Sp - 8] = block_cqeu_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uqfa; else goto cqev;
       uqfa: // global
           call _cqeu(R1) args: 0, res: 0, upd: 0;
       cqev: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.floorFloatInteger_info" {
     GHC.Float.RealFracMethods.floorFloatInteger_info:
         const GHC.Float.RealFracMethods.floorFloatInteger_entry;
         const 0;
         const 1653562408974;
         const 4294967301;
         const SpXI_srt+8;
 },
 _cqeu() //  [R1]
         { []
         }
     {offset
       cqeu: // global
           I64[Sp] = block_cqeC_info;
           F1 = F32[R1 + 7];
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cqeu_info" {
     block_cqeu_info:
         const _cqeu;
         const 0;
         const 1103806595102;
         const SpXI_srt+8;
 },
 _cqeC() //  [R1, R2]
         { []
         }
     {offset
       cqeC: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cqeN; else goto cqf8;
       cqeN: // global
           I64[Sp - 8] = block_cqeL_info;
           _spRI::I64 = R2;
           R2 = R1;
           I64[Sp] = _spRI::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cqf8: // global
           _spRL::I64 = -R2;
           if (%MO_S_Le_W64(_spRL::I64, 23)) goto cqeZ; else goto cqf7;
       cqeZ: // global
           R2 = %MO_S_Shr_W64(R1, _spRL::I64);
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
       cqf7: // global
           if (%MO_S_Ge_W64(R1, 0)) goto cqf5; else goto cqf6;
       cqf5: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cqf6: // global
           R1 = lvl1_roLP_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cqeC_info" {
     block_cqeC_info:
         const _cqeC;
         const 0;
         const 1103806595102;
         const SpXI_srt+8;
 },
 _cqeL() //  [R1]
         { []
         }
     {offset
       cqeL: // global
           R3 = I64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cqeL_info" {
     block_cqeL_info:
         const _cqeL;
         const 65;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.849779142 UTC

[section ""data" . sat_spRP_closure" {
     sat_spRP_closure:
         const GHC.Types.I#_con_info;
         const 1;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.851449933 UTC

[section ""data" . sat_spRQ_closure" {
     sat_spRQ_closure:
         const :_con_info;
         const sat_spRP_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.854215185 UTC

[section ""data" . lvl2_roLQ_closure" {
     lvl2_roLQ_closure:
         const lvl2_roLQ_info;
         const 0;
         const 0;
         const 0;
 },
 lvl2_roLQ_entry() //  [R1]
         { []
         }
     {offset
       cqfE: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqfF; else goto cqfG;
       cqfF: // global
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cqfG: // global
           (_cqfB::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, R1);
           if (_cqfB::I64 == 0) goto cqfD; else goto cqfC;
       cqfD: // global
           call (I64[I64[R1]])() args: 8, res: 0, upd: 8;
       cqfC: // global
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cqfB::I64;
           R3 = sat_spRQ_closure+2;
           R2 = GHC.Types.True_closure+2;
           Sp = Sp - 16;
           call GHC.Integer.Type.mkInteger_entry(R3,
                                                 R2) args: 24, res: 0, upd: 24;
     }
 },
 section ""relreadonly" . lvl2_roLQ_info" {
     lvl2_roLQ_info:
         const lvl2_roLQ_entry;
         const 0;
         const 4294967317;
         const SpXI_srt+80;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.859567623 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingFloatInteger_closure" {
     GHC.Float.RealFracMethods.ceilingFloatInteger_closure:
         const GHC.Float.RealFracMethods.ceilingFloatInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.ceilingFloatInteger_entry() //  [R2]
         { []
         }
     {offset
       cqfX: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqfY; else goto cqfZ;
       cqfY: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingFloatInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cqfZ: // global
           I64[Sp - 8] = block_cqfU_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uqgP; else goto cqfV;
       uqgP: // global
           call _cqfU(R1) args: 0, res: 0, upd: 0;
       cqfV: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.ceilingFloatInteger_info" {
     GHC.Float.RealFracMethods.ceilingFloatInteger_info:
         const GHC.Float.RealFracMethods.ceilingFloatInteger_entry;
         const 0;
         const 13198434500622;
         const 4294967301;
         const SpXI_srt+8;
 },
 _cqfU() //  [R1]
         { []
         }
     {offset
       cqfU: // global
           I64[Sp] = block_cqg6_info;
           F1 = %MO_F_Neg_W32(F32[R1 + 7]);
           call stg_decodeFloat_Int#(F1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cqfU_info" {
     block_cqfU_info:
         const _cqfU;
         const 0;
         const 8800387989534;
         const SpXI_srt+8;
 },
 _cqg6() //  [R1, R2]
         { []
         }
     {offset
       cqg6: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cqgk; else goto cqgO;
       cqgk: // global
           I64[Sp - 8] = block_cqge_info;
           _spRX::I64 = R2;
           R2 = R1;
           I64[Sp] = _spRX::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cqgO: // global
           _spS1::I64 = -R2;
           if (%MO_S_Le_W64(_spS1::I64, 23)) goto cqgC; else goto cqgN;
       cqgC: // global
           I64[Sp] = block_cqgA_info;
           R2 = %MO_S_Shr_W64(R1, _spS1::I64);
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
       cqgN: // global
           if (%MO_S_Ge_W64(R1, 0)) goto cqgL; else goto cqgM;
       cqgL: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cqgM: // global
           R1 = lvl2_roLQ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cqg6_info" {
     block_cqg6_info:
         const _cqg6;
         const 0;
         const 8800387989534;
         const SpXI_srt+8;
 },
 _cqge() //  [R1]
         { []
         }
     {offset
       cqge: // global
           _spRX::I64 = I64[Sp + 8];
           I64[Sp + 8] = block_cqgi_info;
           R3 = _spRX::I64;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cqge_info" {
     block_cqge_info:
         const _cqge;
         const 65;
         const 30;
 },
 _cqgi() //  [R1]
         { []
         }
     {offset
       cqgi: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cqgi_info" {
     block_cqgi_info:
         const _cqgi;
         const 0;
         const 30;
 },
 _cqgA() //  [R1]
         { []
         }
     {offset
       cqgA: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cqgA_info" {
     block_cqgA_info:
         const _cqgA;
         const 0;
         const 30;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.872067991 UTC

[section ""data" . GHC.Float.RealFracMethods.floorDoubleInteger_closure" {
     GHC.Float.RealFracMethods.floorDoubleInteger_closure:
         const GHC.Float.RealFracMethods.floorDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.floorDoubleInteger_entry() //  [R2]
         { []
         }
     {offset
       cqhs: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqht; else goto cqhu;
       cqht: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.floorDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cqhu: // global
           I64[Sp - 8] = block_cqhp_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uqib; else goto cqhq;
       uqib: // global
           call _cqhp(R1) args: 0, res: 0, upd: 0;
       cqhq: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.floorDoubleInteger_info" {
     GHC.Float.RealFracMethods.floorDoubleInteger_info:
         const GHC.Float.RealFracMethods.floorDoubleInteger_entry;
         const 0;
         const 18713172508686;
         const 4294967301;
         const SpXI_srt+8;
 },
 _cqhp() //  [R1]
         { []
         }
     {offset
       cqhp: // global
           I64[Sp] = block_cqhx_info;
           D1 = F64[R1 + 7];
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cqhp_info" {
     block_cqhp_info:
         const _cqhp;
         const 0;
         const 1120986464286;
         const SpXI_srt+8;
 },
 _cqhx() //  [R1, R2]
         { []
         }
     {offset
       cqhx: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cqhG; else goto cqi9;
       cqhG: // global
           R3 = R2;
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 0, upd: 8;
       cqi9: // global
           _spSd::I64 = -R2;
           if (%MO_S_Le_W64(_spSd::I64, 52)) goto cqhR; else goto cqhY;
       cqhR: // global
           I64[Sp - 8] = block_cqhP_info;
           R2 = R1;
           I64[Sp] = _spSd::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
       cqhY: // global
           I64[Sp] = block_cqhX_info;
           R3 = lvl_roLO_closure;
           R2 = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cqhx_info" {
     block_cqhx_info:
         const _cqhx;
         const 0;
         const 1103806595102;
         const SpXI_srt+8;
 },
 _cqhP() //  [R1]
         { []
         }
     {offset
       cqhP: // global
           R2 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cqhP_info" {
     block_cqhP_info:
         const _cqhP;
         const 65;
         const 30;
 },
 _cqhX() //  [R1]
         { []
         }
     {offset
       cqhX: // global
           if (R1 == 1) goto cqi8; else goto cqi4;
       cqi8: // global
           R1 = lvl1_roLP_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cqi4: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cqhX_info" {
     block_cqhX_info:
         const _cqhX;
         const 0;
         const 1103806595102;
         const SpXI_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.88371556 UTC

[section ""data" . GHC.Float.RealFracMethods.ceilingDoubleInteger_closure" {
     GHC.Float.RealFracMethods.ceilingDoubleInteger_closure:
         const GHC.Float.RealFracMethods.ceilingDoubleInteger_info;
         const 0;
 },
 GHC.Float.RealFracMethods.ceilingDoubleInteger_entry() //  [R2]
         { []
         }
     {offset
       cqiI: // global
           if ((Sp + -16) < SpLim) (likely: False) goto cqiJ; else goto cqiK;
       cqiJ: // global
           R2 = R2;
           R1 = GHC.Float.RealFracMethods.ceilingDoubleInteger_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cqiK: // global
           I64[Sp - 8] = block_cqiF_info;
           R1 = R2;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto uqjG; else goto cqiG;
       uqjG: // global
           call _cqiF(R1) args: 0, res: 0, upd: 0;
       cqiG: // global
           call (I64[I64[R1]])(R1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . GHC.Float.RealFracMethods.ceilingDoubleInteger_info" {
     GHC.Float.RealFracMethods.ceilingDoubleInteger_info:
         const GHC.Float.RealFracMethods.ceilingDoubleInteger_entry;
         const 0;
         const 44001939947534;
         const 4294967301;
         const SpXI_srt+8;
 },
 _cqiF() //  [R1]
         { []
         }
     {offset
       cqiF: // global
           I64[Sp] = block_cqiR_info;
           D1 = %MO_F_Neg_W64(F64[R1 + 7]);
           call GHC.Integer.Type.decodeDoubleInteger_entry(D1) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cqiF_info" {
     block_cqiF_info:
         const _cqiF;
         const 0;
         const 8817567858718;
         const SpXI_srt+8;
 },
 _cqiR() //  [R1, R2]
         { []
         }
     {offset
       cqiR: // global
           if (%MO_S_Ge_W64(R2, 0)) goto cqj1; else goto cqjF;
       cqj1: // global
           I64[Sp] = block_cqiZ_info;
           R3 = R2;
           R2 = R1;
           call GHC.Integer.Type.shiftLInteger_entry(R3,
                                                     R2) args: 8, res: 8, upd: 8;
       cqjF: // global
           _spSr::I64 = -R2;
           if (%MO_S_Le_W64(_spSr::I64, 52)) goto cqjm; else goto cqju;
       cqjm: // global
           I64[Sp - 8] = block_cqjd_info;
           R2 = R1;
           I64[Sp] = _spSr::I64;
           Sp = Sp - 8;
           call GHC.Integer.Type.integerToInt_entry(R2) args: 8, res: 8, upd: 8;
       cqju: // global
           I64[Sp] = block_cqjt_info;
           R3 = lvl_roLO_closure;
           R2 = R1;
           call GHC.Integer.Type.ltInteger#_entry(R3,
                                                  R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cqiR_info" {
     block_cqiR_info:
         const _cqiR;
         const 0;
         const 8800387989534;
         const SpXI_srt+8;
 },
 _cqiZ() //  [R1]
         { []
         }
     {offset
       cqiZ: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cqiZ_info" {
     block_cqiZ_info:
         const _cqiZ;
         const 0;
         const 30;
 },
 _cqjd() //  [R1]
         { []
         }
     {offset
       cqjd: // global
           _spSu::I64 = %MO_S_Shr_W64(R1, I64[Sp + 8]);
           I64[Sp + 8] = block_cqjk_info;
           R2 = _spSu::I64;
           Sp = Sp + 8;
           call GHC.Integer.Type.smallInteger_entry(R2) args: 8, res: 8, upd: 8;
     }
 },
 section ""relreadonly" . block_cqjd_info" {
     block_cqjd_info:
         const _cqjd;
         const 65;
         const 30;
 },
 _cqjk() //  [R1]
         { []
         }
     {offset
       cqjk: // global
           R2 = R1;
           Sp = Sp + 8;
           call GHC.Integer.Type.negateInteger_entry(R2) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cqjk_info" {
     block_cqjk_info:
         const _cqjk;
         const 0;
         const 30;
 },
 _cqjt() //  [R1]
         { []
         }
     {offset
       cqjt: // global
           if (R1 == 1) goto cqjE; else goto cqjA;
       cqjE: // global
           R1 = lvl2_roLQ_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
       cqjA: // global
           R1 = lvl_roLO_closure;
           Sp = Sp + 8;
           call (I64[I64[R1]])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section ""relreadonly" . block_cqjt_info" {
     block_cqjt_info:
         const _cqjt;
         const 0;
         const 8800387989534;
         const SpXI_srt+8;
 }]


==================== Raw Cmm ====================
2018-03-16 15:55:03.895792532 UTC

[section ""relreadonly" . SpXI_srt" {
     SpXI_srt:
         const GHC.Float.RealFracMethods.properFractionFloatInteger_closure;
         const lvl_roLO_closure;
         const GHC.Float.RealFracMethods.truncateFloatInteger_closure;
         const GHC.Integer.Type.decodeDoubleInteger_closure;
         const GHC.Float.RealFracMethods.roundDoubleInteger_closure;
         const GHC.Float.RealFracMethods.properFractionDoubleInteger_closure;
         const GHC.Float.RealFracMethods.truncateDoubleInteger_closure;
         const sat_spRC_closure;
         const GHC.Float.RealFracMethods.floorFloatInteger_closure;
         const lvl1_roLP_closure;
         const sat_spRQ_closure;
         const GHC.Float.RealFracMethods.ceilingFloatInteger_closure;
         const lvl2_roLQ_closure;
         const GHC.Float.RealFracMethods.floorDoubleInteger_closure;
         const GHC.Float.RealFracMethods.ceilingDoubleInteger_closure;
 }]

